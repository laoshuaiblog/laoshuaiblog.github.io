<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82b13c6d8cf2b1e171bc76edc83ade17/" rel="bookmark">
			Kotlin-14.密封类(sealed class)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档: http://kotlinlang.org/docs/reference/sealed-classes.html
密封类(sealed class) 密封类: 受限的类继承结构(有限集合的类型,不能有任何其他类型) 在某种意义上,密封类就是扩展的枚举类enum(枚举类的值集合也是受限) 不同之处: 枚举类的每个枚举常量只存在一个实例, 密封类的一个子类可以有可包含状态的多个实例! 密封类的所有子类都必须与密封类在同一文件中, 密封类子类的子类(间接继承者)可以放在任何位置,无需在同一个文件中! //在Kotlin 1.1之前,该规则更加严格:子类必须在密封类的内部 sealed class Expr { class Const(val number: Double) : Expr() class Sum(val e1: Expr, val e2: Expr) : Expr() object NotANumber : Expr() } //自Kotlin 1.1起,该规则放松 sealed class Expr data class Const(val number: Double) : Expr() data class Sum(val e1: Expr, val e2: Expr) : Expr() object NotANumber : Expr() 密封类的好处在于:使用when表达式,如果能覆盖所有情况,就无需再添加else子句 fun eval(expr: Expr): Double = when(expr) { is Const -&gt; expr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82b13c6d8cf2b1e171bc76edc83ade17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9325d96e2b2a1e624a0072e85e30f604/" rel="bookmark">
			Kotlin-13.数据类(data class)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档: http://kotlinlang.org/docs/reference/data-classes.html
1.数据类的概念(data class) 在Kotlin中一些只保存数据的类,称为数据类(data class), 为了确保自动生成的代码一致性和有意义,数据类(data class)必须满足以下要求: 主构造函数至少有一个参数; 主构造函数的所有参数需标记为val 或 var; 数据类不能是抽象、开放、密封或者内部的; 自kotlin 1.1起,数据类可以扩展其他类;在1.1之前,数据类只能实现接口 数据类(data class)的语法实例: data class User(val name: String, val age: Int) 编译器会为数据类(data class)自动生成以下函数: equals()/hashCode() toString() 默认输出"User(name=John, age=42)" componentN() 按声明顺序对应于所有属性 copy() 如果数据类需要无参构造函数,则所有属性必须有默认值: data class User(val name: String = "", val age: Int = 0) 2.copy函数 当要复制一个对象,只改变一些属性,但其余不变,copy()就是为此而生: data class User(val name: String, val age: Int) fun main(args: Array&lt;String&gt;) { val u = User(name = "lioil", age = 1) val u1 = u.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9325d96e2b2a1e624a0072e85e30f604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4728cdce35f3f06a8db7314218c005a1/" rel="bookmark">
			[问题记录]按url context path设置nginx反向代理禅道和Jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 在公司同一台服务器上分别装了禅道的开源版（linux一键安装）和Jenkins（docker），觉得带端口号的链接给上头leader等使用有点难看……就想改成用二级url区别的方法，即目标是：
由 dev.server.com:8001 改成用 dev.server.com/zentao 访问禅道 由 dev.server.com:8002 改成用 dev.server.com/jenkins 访问Jenkins 然后简单搜索了下、写出了下面的（有错误的）nginx配置：
server { listen 80; server_name dev.server.com; location /zentao { proxy_pass http://localhost:8001; } location /jenkins { proxy_pass http://localhost:8002; } } 按上面/zentao、/jenkins这样的新路径，禅道一下子就打开了用户登录界面，但是Jenkins却是404。
原因： 原本以为Jenkins不能用很奇怪，最后发现禅道能用只是碰巧……
为什么打不开Jenkins？ 首先发现如果使用端口号访问的方式、浏览器会自动跳转至Jenkins登录界面、url发生了变化，于是联想到比较下不同的url访问，整理下是：
(1) GET http://dev.server.com/jenkins 跳转至 http://dev.server.com/login?from=%2Fjenkins 404 NOT FOUND (2) GET http://dev.server.com:8002 跳转至 http://dev.server.com:8002/login?from=%2F 200 OK 显示登录界面 (3) GET http://dev.server.com:8002/login 直接 200 OK 显示登录界面 (4) GET http://dev.server.com:8002/jenkins 跳转至 http://dev.server.com:8002/login?from=%2Fjenkins 200 OK 显示登录界面 于是可以知道Jenkins登录界面的访问url是ip:port/login，后面的from query string只是将请求url中的path贴在了后面（%2F即/）。所以nginx配置不能用的原因也很明显，Jenkins监听的是8002端口，加了nginx proxy_pass后变成了请求默认的80端口，自然是找不到/找不对的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4728cdce35f3f06a8db7314218c005a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/232e2c3d7c594ce854f816c50ab4e7f8/" rel="bookmark">
			Ip地址校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 使用正则表达式的方式校验Ip */ private fun checkIpEx(ip: String): Boolean { var rexEx = """(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])""" val pattern = Pattern.compile(rexEx) val matcher = pattern.matcher("172.22.8.256") val boolean = matcher.matches() Log.i("wk", "是否匹配=&gt;$boolean") return false } /** * 使用分割字符串的方式校验ip地址的正确性 */ private fun checkIpSplite(ip: String): Boolean { val split = ip.split(".") if (split.size != 4) return false for (item in split.listIterator()) { val ipNum = Integer.parseInt(item) Log.i("wk","ipNum=&gt;$ipNum") if(ipNum !in 0..255) return false } return true } 没错，Kotlin写的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d031a9795931d595cf7ffc40ef474ee/" rel="bookmark">
			针对IE6、7、8条件注释语句(不同版本IE显示用不用css)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高级应用开发我们都会去利用if来判断用户浏览器不同版本IE显示用不用css，下面我来给大家总结一些针对IE6、7、8条件注释语句用法，希望这些方法对各位朋友有帮助。 一、条件注释简介
1.IE中的条件注释（Conditional comments）对IE的版本和IE非IE有优秀的区分能力，是WEB设计中常用的hack方法。
2.条件注释只能用于IE5以上。
3.如果你安装了多个IE，条件注释将会以最高版本的IE为标准。
4.条件注释的基本结构和HTML的注释(&lt;!– –&gt;)是一样的。因此IE以外的浏览器将会把它们看作是普通的注释而完全忽略它们。
5.IE将会根据if条件来判断是否如解析普通的页面内容一样解析条件注释里的内容。
二、条件注释属性
gt : greater than，选择条件版本以上版本，不包含条件版本
lt : less than，选择条件版本以下版本，不包含条件版本
gte : greater than or equal，选择条件版本以上版本，包含条件版本
lte : less than or equal，选择条件版本以下版本，包含条件版本
! : 选择条件版本以外所有版本，无论高低
1、Css if hack条件语法 &lt; !--[if IE]&gt; Only IE &lt;![endif]--&gt;
仅所有的WIN系统自带IE可识别
&lt; !--[if IE 5.0]&gt; Only IE 5.0 &lt;![endif]--&gt;
只有IE5.0可以识别
&lt; !--[if gt IE 5.0]&gt; Only IE 5.0+ &lt;![endif]--&gt;
IE5.0包换IE5.5都可以识别
&lt; !--[if lt IE 6]&gt; Only IE 6- &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d031a9795931d595cf7ffc40ef474ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3e1264de74e7604bf9e448921cd6bc/" rel="bookmark">
			必须有数字和字母组合的密码正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要求：由数字和字母组成，并且要同时含有数字和字母，且长度要在8-16位之间。
^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{8,16}$ 分开来注释一下：
^ 匹配一行的开头位置
(?![0-9]+$) 预测该位置后面不全是数字
(?![a-zA-Z]+$) 预测该位置后面不全是字母
[0-9A-Za-z] {8,16} 由8-16位数字或这字母组成
$ 匹配行结尾位置
注：(?!xxxx) 是正则表达式的负向零宽断言一种形式，标识预该位置后不是xxxx字符。
附：
要求：可以包含数字、字母、下划线，并且要同时含有数字和字母，且长度要在8-16位之间。
^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z_]{8,16}$ 参考资料：http://blog.sina.com.cn/s/blog_5082f7b901015r2r.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbfa0c0ab97abad08febf9e7158e61ad/" rel="bookmark">
			数据结构 链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在讲链表的数据结构之前，我们先说一个最简单的数据结构-线性表。对于线性表，想必作为开发者都不会陌生，我们常用的数组就是通过线性表实现的，线性表就是在内存中一段连续的内存地址。
与线性表相比，链表的数据结构也是按照每个元素的线性顺序排列的，但是与线性表不同的是，链表的顺序是通过每个元素中指针决定的。
双链表 双向链表也叫双链表，是链表的一种，它的每个数据节点中都有两个指针，分别指向前驱结点和后继结点：pre和next。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。
一般情况下，链表在创建时，都会创建一个头结点。当链表中不存在其他元素是，该头结点的前驱和后继都是指向本身的，此时链表为空链表。如果一个链表的前驱结点指向头结点，那么该结点为链表的头（head）；如果一个结点的后继节点为空，那么该节点就是链表的尾结点（tail）。
单链表和循环链表 如果一个链表的节点中没有指针指向前驱结点，那么该链表为单链表。 如果一个双向链表的尾结点的后继结点指向头结点，同时，链表的头结点的前驱结点指向链表的尾结点，那么该链表被称为循环链表。
双链表的代码实现 package structdemo; /** * 双向链表 * * @author zhangke * */ public class LinkedList&lt;E&gt; { /** * 定义头结点 */ private Node header; private int size; public LinkedList() { // 初始化头节点，此时头结点的前驱和后继都指向自己 header = new Node(null, null, null); header.preNode = header; header.nextNode = header; } /** * 添加，默认在末尾添加 * * @param data */ public void add(E data) { add(size, data); } /** * 指定位置添加 */ public void add(int index, E data) { Node node = node(index); Node newNode = new Node(node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbfa0c0ab97abad08febf9e7158e61ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/600ca18477a4658769a812b411a67c35/" rel="bookmark">
			Shell 判断文件是否存在的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
locate_library() { [ ! "$1*" = "`echo $1*`" ]; } 用法：
# Look for PAM (done weirdly due to distribution bugs (e.g. Debian) or the # crypt library. if find_func pam_start sysdeputil.o; then locate_library /lib/libpam.so.0 &amp;&amp; echo "/lib/libpam.so.0"; locate_library /usr/lib/libpam.so &amp;&amp; echo "-lpam"; locate_library /usr/lib64/libpam.so &amp;&amp; echo "-lpam"; # HP-UX ends shared libraries with .sl locate_library /usr/lib/libpam.sl &amp;&amp; echo "-lpam"; # AIX ends shared libraries with .a locate_library /usr/lib/libpam.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/600ca18477a4658769a812b411a67c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e5739c537653e261608c079fbcb5635/" rel="bookmark">
			CSU 1870 Legendary
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1870: Legendary Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 366 Solved: 102 Description 小GJ和小LMW都很喜欢LOL，他们喜欢互相吹牛，诸如“我昨天非常强，打了20把全部超神了”。但是聪明的SWB却每每都能看着数据识破他们吹牛的伎俩。已知LOL击杀、死亡和助攻可以以任意顺序发生，连续完成8次击杀即被视作超神，死亡会打断连续击杀，助攻没有影响。
Input 有T（T&lt;=20）组数据。 每组给出N（N&lt;=100）场比赛的数据。 每场比赛在一行里给出击杀数K死亡数D助攻数A。（K,D,A&lt;=100）
Output 每组数据给出一定超神的数量和一定不超神的数量，格式如样例所示
Sample Input 2 3 8 0 0 0 8 0 0 0 8 2 20 0 5 8 1 0 Sample Output 1 2 1 0 Hint 注意有些数据并不能判断是一定超神或者一定不超神如8 1 0这组，因此不计入答案的两个类别。
简单题。
#include &lt;cstdio&gt; int T,n,k,d,a; int main() { scanf("%d",&amp;T); while(T--){ int yep=0,nop=0; scanf("%d",&amp;n); for(int i=1 ; i&lt;=n ; i++){ scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e5739c537653e261608c079fbcb5635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa910196c656ef6265577a1e836ebaf/" rel="bookmark">
			CSU 1868 潜在好友
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description 小X在搬砖写一个论坛，这个时候老板突然想到一个功能，让小X今天赶快实现。大概就是如果某个人是你好友的好友那么他的头像上面会有特殊的标志。小X想不到较好的办法来解决如何验证两个人是不是好友的好友，现在向你求助。
Input 第一行是一个整数T(1&lt;=T&lt;=100)，代表数据组数。 每组数据第一行是两个整数n,m(1&lt;=n,m&lt;=10000)，代表这两个人的好友的数量。 之后n行是第一个人的好友id 再之后m行是第二个人的好友id (1&lt;=id&lt;=1e9)
Output 如果第二个人是第一个人的好友的好友输出Yes否则No
Sample Input 2 1 1 1 2 2 3 1 2 2 3 4 Sample Output No Yes Hint 水题，不解释。
但不明白的是，我把Cin换成scanf就TLE了，把map换成int[]就CE了。留下未结之谜。
#include &lt;iostream&gt; #include &lt;map&gt; using namespace std; map&lt;int,int&gt; mp; int main() { int T,n,m; cin&gt;&gt;T; while(T--){ cin&gt;&gt;n&gt;&gt;m; int x; bool flag = false; mp.clear(); for(int i=1 ; i&lt;=n ; i++){ cin&gt;&gt;x; mp[x] = 1; } for(int i=1 ; i&lt;=m ; i++){ cin&gt;&gt;x; if(mp[x]) flag=true; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa910196c656ef6265577a1e836ebaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83db2c7a1473c7cea69231c8a1f11c3a/" rel="bookmark">
			CSU 1867 John and Health rate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description The cold and flu season is here.John is worried about his cow. In order to monitor the situation of his cow,he do some inspecting everyday,and record the “health rate” for each cow.The “health rate” is a integer which can show the cow’s health condition.The higher a cow’s health rate is ,the healthier the cow is.What’s more,the doctor told John that the k-th small health rate is dangerous.Because the doctor thought there are at most k healthy cows.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83db2c7a1473c7cea69231c8a1f11c3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b545812fb7bce63d57c177aa954a8bda/" rel="bookmark">
			VS2013或15 MVC提示“当前上下文中不存在ViewBag”的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vs2012开发的mvc项目使用vs2013或15打开提示“当前上下文中不存在ViewBag”，如下图：
解决方案如下：
1.下载mvc4的dll文件（System.Web.Mvc.dll），同时引用到项目中
2.修改网站根目录下面的Web.config文件
3.修改网站根目录下面的View视图文件夹下的Web.config文件
修改根目录下的Web.config配置如下图：
修改为2.0版本的。
修改网站根目录下面的View视图文件夹下的Web.config配置如下图：
修改为上图的版本，然后关闭除配置文件外的所有文档，最后重新生成项目就可以啦~~~
出于保险，可以同时修改其他的版本
根目录的配置文件如下：
View目录下的配置文件如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edcc451096bf94af400ed43c628eb920/" rel="bookmark">
			Python 3.6 实现简单的爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python作为一种新锐语言，他的更新是非常的快的。
3.x与2.x相比，它整合了urllib，urllib2,urllib3等一系列的模块，在3.x里，实现一个爬取网页简易的程序如下
# -*- coding: utf-8 -*- import urllib.request url='http://www.baidu.com/' def getHtml(url): page=urllib.request.urlopen(url) html=page.read().decode(encoding='utf-8',errors='strict') return html print(getHtml(url)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc32a3495404bf3f2c29c8c9d980dc0c/" rel="bookmark">
			什么是BSP?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）什么是BSP？ BSP是板级支持包，(board support package)是介于主板硬件和操作系统之间的一层，应该说是属于操作系统的一部分,主要目的是为了支持操作系统，使之能够更好的运行于硬件主板。BSP是相对于操作系统而言的，不同的操作系统对应于不同定义形式的BSP,例如VxWorks的BSP和Linux的BSP相对于某一CPU来说尽管实现的功能一样，可是写法和接口定义是完全不同的，所以写BSP一定要按照该系统BSP的定义形式来写（BSP的编程过程大多数是在某一个成型的BSP模板上进行修改），这样才能与上层OS保持正确的接口，良好的支持上层OS。例如： 在VxWorks中的网卡驱动，首先在config.h中包含该网卡，然后将网卡含网卡的信息的参数放入数组 END_TBL_ENTRY endDevTbl [] 中，系统通过函数muxDevLoad( )调用这个数组来安装网卡驱动。 而在Linux中的网卡驱动，是在space.c中声明该网络设备，再把网卡驱动的一些函数加到dev结构中，由函数ether_setup（）来完成网卡驱动的安装。 纯粹的BSP所包含的内容一般说来是和系统有关的驱动和程序，如网络驱动和系统中网络协议有关，串口驱动和系统下载调试有关等等。离开这些驱动系统就不能正常工作。（2）BSP在嵌入式系统和Windows系统中的不同 其实运行与PC机上的windows或linux系统也是有BSP的。只是PC机均采用统一的X86体系架构，这样一定操作系统（windows,linux..)的BSP相对x86架构是单一确定的，不需要做任何修改就可以很容易支持OS在x86上正常运行，所以在PC机上谈论BSP这个概念也没什么意义了。 而对嵌入式系统来说情况则完全不同，目前市场上多种结构的嵌入式CPU（RISC)并存(PPC,ARM,MIPS....),为了性能的需要，外围设备也会有不同的选择和定义。一个嵌入式操作系统针对不同的CPU,会有不同的BSP,即使同一种CPU,由于外设的一点差别（如外部扩展DRAM的大小，类型改变），BSP相应的部分也不一样。 所以根据硬件设计编写和修改BSP，保证系统正常的运行是非常重要的。（3）BSP和PC机主板上的BIOS区别 BSP和PC机主板上的BIOS区别很大，BIOS主要是负责在电脑开启时检测、初始化系统设备（设置栈指针，中断分配，内存初始化..）、装入操作系统并调度操作系统向硬件发出的指令，它的Firmware代码是在芯片生产过程中固化的，一般来说用户是无法修改。其实是为下载运行操作系统做准备，把操作系统由硬盘加载到内存，并传递一些硬件接口设置给系统。在OS正常运行后，BIOS的作用基本上也就完成了，这就是为什么更改BIOS一定要从新关机开机。 BSP是和操作系统绑在一起运行在主板上的，尽管BSP的开始部分和BIOS所做的工作类似，可是大部分和BIOS不同，作用也完全不同。此外BSP还包含和系统有关的基本驱动（串口，网口...),此外程序员还可以编程修改BSP，在BSP中任意添加一些和系统无关的驱动或程序，甚至可以把上层开发的统统放到BSP中。 而BIOS程序是用户不能更改，编译编程的，只能对参数进行修改设置。更不会包含一些基本的硬件驱动（4）BSP在嵌入式开发中的位置和作用 BSP开发处于整个嵌入式开发的前期，是后面系统上应用程序能够正常运行的保证。 大概步骤如下：1.硬件主板研制，测试。2.操作系统的选定，BSP编程。3.上层应用程序的开发。 BSP部分在硬件和操作系统，上层应用程序之间。所以这就要求BSP程序员对硬件，软件和操作系统都要有一定的了解。这样才能做好BSP编程。（5）BSP包括的一些内容 对于开发板提供商来说，BSP就是开发板的生产商提供的一个资料和资源包。通常包括:一 硬件相关: 1 开发板原理图 2 开发板元件列表 3 接口定义 4 地址分布二 软件相关: 1 某些操作系统的bootloader及源代码 2 某些操作系统裁剪好的映像文件(如linux系列可能有源码,如WinCE可能有CEC文件)三 服务相关 1 售后的技术支持(根据价格,差异很大) 转自:http://blog.chinaunix.net/uid-20788636-id-1841270.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e2944ccd2d49b35f1e406fd3616e34/" rel="bookmark">
			用纯客户端JavaScript来写一个有趣的爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拿JavaScript写爬虫，听起来貌似有些不靠谱？
爬虫，大多人对于爬虫的理解都停留在使用后端语言如Python写的爬虫。但是实际上，使用客户端JavaScript有诸多后端爬虫所无法拥有的优势：
可以方便的分享给其他人用，只要对方电脑里有浏览器
由于跑在客户端，几乎可以无视对方网站的反爬虫机制
可以拥有完善的UI，无开发基础的小白也可以随意使用
这东西应该怎么启动？ 而“客户端JavaScript爬虫如何运行”问题，回答这个问题非常简单，大致有3种运行JavaScript的代码：
存浏览器书签，以javascript:打头，点击即可运行
复制到浏览器console中按回车
有个浏览器扩展叫做“油猴子”
这里我们主要看下第三种，油猴脚本方式运行。
或许你听说过油猴扩展，他在Firefox叫做Greasemonkey在Chrome叫做Tampermonkey，你可以轻松的在浏览器的扩展商店找到它。而关于其本身有何作用，一句话
按照规则，在不同的URL额外运行一段JavaScript代码
请参考下面的例子：
// ==UserScript== // @name Pxer // @include http://www.pixiv.net* // ==/UserScript== javascript:void((function() { document.documentElement.appendChild( document.createElement('script') ).src='http://pxer-app.pea3nut.org/jsonp.js?'+(+new Date); })()); ==UserScript==是油猴脚本的规则，上面的规则告诉油猴：
当浏览器打开http://www.pixiv.net*的页面时，执行下面的脚本
而脚本的内容则是：通过jsonp的方式向页面引入一个js文件。
这就可以做很多事了。（不是坏事哦~）
优势，还是非常多的 上图是一个二次元插画交流站pixiv.net。图中显示“Pxer 7”的那一个长条是原本不存在与原网站中的，而是通过油猴脚本自动载入JavaScript脚本来创建的。
若想访问图中的原始链接可以点击这里，可能你需要先在pixiv.net注册一个账号
通过油猴脚本自动载入，你可以做到：
在完全不影响原网站使用的情况下，利用强大的JavaScript向用户提供额外的功能
再结合一开始提到的优点：
可以给任何人使用！哪怕是无开发基础的小白
不会被封杀！由真实用户操作，封账号、IP、验证码等反爬虫策略你觉得会对客户端爬虫有效吗？
利用HTML+CSS，构建一个漂亮的UI完美融入原网站，简直不能再简单~
突然莫名的感觉很无敌有木有？
说了这么多，来个实际实现的例子 空说无凭，来看一个实际的客户端JavaScript爬虫开源项目 —— Pxer
Github：https://github.com/pea3nut/Pxer
项目官网：http://pxer.pea3nut.org/
Pxer是一个纯客户端JavaScript编写的爬虫，无需任何配置即可直接在浏览器端运行。
Pxer最大作用是将pixiv.net网站（类似于花瓣网）中的图片作品快速的抓取下来。它不是简单的检索img标签，而是通过一定的算法和Ajax请求来完成更为复杂的功能。
关于项目的详细描述，可以参考项目官网和Github项目主页
良好的jsDOC格式注释和详细的文档都已经为你准备好了~~
https://github.com/pea3nut/Pxer
让JavaScript来的更猛烈些~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b506b7cb954462aaa87f93156679970/" rel="bookmark">
			Linux怎么取消软链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下取消软连接，做个案例来说明：
1.先建立一个软连接
1 2 3 4 5 6 7 8 9 10 11 12 13 [root@rekfan.com test ] # ls -il 总计 0 1491138 -rw-r–r– 1 root root 48 07-14 14:17 file1 1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2 1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2hand #建立file1和file1soft软连接 [root@rekfan.com test ] # ln -s file1 file1soft [root@rekfan.com test ] # ls -il 总计 0 1491138 -rw-r–r– 1 root root 48 07-14 14:17 file1 1491140 lrwxrwxrwx 1 root root 5 07-14 14:24 file1soft -&gt; file1 1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2 1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2hand 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b506b7cb954462aaa87f93156679970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a8ba36eaf34261c08c6e5a3e4b9f99/" rel="bookmark">
			Angular简介和入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流行框架第一天：Angular简介和入门1.1. 前端流行技术的历史 之前时代，是桌面应用的天下，客户端服务器的天下，本没有前端这样的职位，网站设计师石器时代，互联网开始发展网站设计师（静态）-不过是html、css、js、flash，页面设计师青铜时代，yui、prototype、extjs、dojo等等框架的时代，美工、页面设计师 前端工程师黑铁时代，jquery和jquery的一堆衍生品jqueryui、easyui、ligerui等 ui设计 前端工程师白银时代，angularjs、react黄金时代，现在前端技术和后端平起平坐的时代 跨平台开发 1.2. 前端缘何一地鸡毛？ * 一地鸡毛，书名，刘震云的中篇小说，意思是说琐事特别多，并非贬义词。 * 说前端一地鸡毛，既是机遇又是挑战 * 这几年前端技术迅速发展，特别是在nodejs的基础之上发展， * 分工协作前后端分离，给前端带来的机会
1.3. 什么是库（包），什么是框架？ * jQuery ：库
* * 封装了一些常用的方法，我们主动的调用这些方法 -- 提高了代码的利用，以及代码后期的维护 * Angular: 前端框架 react vue * * 框架提供了一些结构或者模式， * 我们是根据框架提供的结构或者模式去书写代码 * 由框架帮助我们去执行相应的操作。 1.4. 什么是 Angular * 一款非常优秀的前端高级 JS 框架 * 最早由 Misko Hevery 等人创建 * 2009 年被 Google 公式收购，用于其多款产品 * 目前有一个全职的开发团队继续开发和维护这个库 * 有了这一类框架就可以轻松构建 SPA 应用程序 * 单页面应用程序 模拟cs结构 客户端服务器 作出的bs的结构的网站，但是带有客户端的功能性、页面局部刷新特点
* 其核心就是通过指令扩展了 HTML，通过表达式绑定数据到 HTML。 * Angular不推崇DOM操作，也就是说在NG中几乎找不到任何的DOM操作 写一个输入框一个按钮 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65a8ba36eaf34261c08c6e5a3e4b9f99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7d132ea1bcea3c42662b04e3c32f1a/" rel="bookmark">
			ibatis处理器异常（executor.ExecutorException）解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: Executor was closed. ### Cause: org.apache.ibatis.executor.ExecutorException: Executor was closed. at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:23) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:104) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:95) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:124) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:90) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:40) at com.sun.proxy.$Proxy3.getAgeRange(Unknown Source) at com.lrq.service.impl.UserServiceImpl.getAgeRange(UserServiceImpl.java:49) at com.lrq.test.Test.testQuery(Test.java:54) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222) at org.junit.runners.ParentRunner.run(ParentRunner.java:300) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c7d132ea1bcea3c42662b04e3c32f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9031e41644904055383d0ff3a4821cb/" rel="bookmark">
			cpu性能评测(i5-4460,i5-4400,i5-3470,i5-2400s,i3-3220T,G860)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Intel i5-4460 (3200MHZ)，2*4GB(DDR3 1333) 在 Aida64 V5.60.3700 的测试结果 CPU Queen 31460 CPU PhotoWorxx 13017 兆像素/秒 CPU ZLib 211.5 MB/秒 CPU AES 14043 MB/秒 CPU Hash 2841 MB/秒 FPU VP8 4666 FPU Julia 20017 FPU Mandel 10515 FPU SinJulia 2777 内存读取 19877 MB/秒 内存写入 120595 MB/秒 内存复制 18984 MB/秒 内存潜伏 78.6 ns Intel i5-4400 (3100MHZ)，1*4GB(DDR3 1600) 在 Aida64 V5.60.3700 的测试结果 CPU Queen 30930 CPU PhotoWorxx 7061 兆像素/秒 CPU ZLib 205.9 MB/秒 CPU AES 13648 MB/秒 CPU Hash 2773 MB/秒 FPU VP8 3095 FPU Julia 19375 FPU Mandel 10240 FPU SinJulia 2695 内存读取 11028 MB/秒 内存写入 11983 MB/秒 内存复制 11082 MB/秒 内存潜伏 71.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9031e41644904055383d0ff3a4821cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982320d14082be0fc2dc3a05257c7405/" rel="bookmark">
			TPC-H系列---3---TPC-H的22条查询语句分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用TPC-H进行性能测试，需要有很多工作配合才能获得较高性能，如建立索引，表数据的合理分布（使用表空间和聚簇技术）等。
本文从查询优化技术的角度，对TPC-H的22条查询语句和主流数据库执行每条语句对应的查询执行计划进行分析，目的在于了解各个主流数据库的查询优化技术，以TPC-H实例进一步掌握查询优化技术，对比主流数据库的实现情况对查询优化技术融会贯通。
1. Q1，价格统计报告查询
Q1语句是查询lineItems的一个定价总结报告。在单个表lineitem上查询某个时间段内，对已经付款的、已经运送的等各类商品进行统计，包括业务量的计费、发货、折扣、税、平均价格等信息。
Q1语句的特点是：带有分组、排序、聚集操作并存的单表查询操作。这个查询会导致表上的数据有95%到97%行被读取到。
Q1的查询语句如下：
select l_returnflag, //返回标志
l_linestatus, sum(l_quantity) as sum_qty, //总的数量
sum(l_extendedprice) as sum_base_price, //聚集函数操作
sum(l_extendedprice * (1 - l_discount)) as sum_disc_price, sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge, avg(l_quantity) as avg_qty, avg(l_extendedprice) as avg_price, avg(l_discount) as avg_disc, count(*) as count_order //每个分组所包含的行数
from lineitem
where l_shipdate &lt;= date'1998-12-01' - interval '90' day //时间段是随机生成的
group by //分组操作
l_returnflag, l_linestatus
order by //排序操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/982320d14082be0fc2dc3a05257c7405/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/124/">«</a>
	<span class="pagination__item pagination__item--current">125/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/126/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>