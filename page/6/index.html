<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1286c79894a498633f0b21171d0027ca/" rel="bookmark">
			如何在 Ubuntu 安装桌面环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Ubuntu 上安装不同的桌面环境 如果你正在使用官方的 Ubuntu 发行版，它运行在 GNOME 上，那么你可以很容易地从默认的包管理器安装其他流行的桌面环境（DE）。让我们开始吧…
在 Ubuntu 上安装 KDE Plasma 如果你正在使用 GNOME 的 Ubuntu，那么你不需要移除它；你可以很容易地在你当前的 Ubuntu 系统上安装 KDE 桌面，并且可以从登录界面切换到可用的桌面环境。
有几种不同的 KDE 包可供安装，因此你可以根据你的需求安装其中一个。
安装完整的 KDE Plasma 桌面，包括完整包和核心 KDE Plasma 桌面（包大小约为 1 GB）。sudo apt install kde-full安装标准 KDE Plasma 桌面，包括一套标准的 KDE 应用，如 Kate、Konqueror、KGet、KMail、Dolphin 等（包大小约为 273 MB）。sudo apt install kde-standard安装最小的 KDE Plasma 桌面，包括最小的 KDE 应用集合，如浏览器、文件管理器、文本编辑器等，适合于你只是想尝试一下（包大小约为 175 MB）。sudo apt install kde-plasma-desktop 在安装过程中，系统会提示你配置 “SDDM”，即简单桌面显示管理器，KDE 桌面使用的显示管理器。从列表中选择 “sddm” 并按 Enter 键。
一旦完成，它将配置剩余的包。然后，你可以重启，从登录界面选择 KDE（如果需要），并使用你的默认凭据登录。
在这里，你可以开始使用 KDE 作为你的默认桌面环境，如果你希望切换到 GNOME，可以从登录界面的左上角选择 GNOME 会话。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1286c79894a498633f0b21171d0027ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c5a5b7f5e5a005250e670cbe44e4ab/" rel="bookmark">
			Kali-Linux汉化教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kali Linux汉化教程如下：
打开终端。输入命令 sudo dpkg-reconfigure locales 并回车。在出现的界面中，使用空格键选中想要的语言选项，包括 en_US.UTF-8、zh_CN.GBK 和 zh_CN.UTF-8。选中 zh_CN.UTF-8 作为默认语言。按 “Tab” 键切换到 “OK”，再按 “Enter” 键确认选择。为了确保中文字符能够正确显示，需要下载并安装一些中文字体。输入命令 sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy 并回车，等待字体安装完成。输入命令 reboot 并回车，重启你的Kali Linux系统。系统重启后，你将看到Kali Linux的界面已经更改为中文。 另外，如果想要通过安装中文语言包来实现Kali Linux的汉化，可以按照以下步骤操作：
打开终端。输入命令 sudo apt-get install language-pack-zh-hans 并回车，安装中文语言包。安装完成后，输入命令 sudo update-locale LANG=zh_CN.UTF-8 并回车，设置系统语言为中文。重启系统，即可看到Kali Linux已经变成中文界面。 请注意，在进行系统语言更改时，确保你的系统已经备份了重要数据，以防万一出现意外情况导致数据丢失。同时，确保你的网络连接稳定，以便在需要时能够顺利下载和安装所需的软件包和字体。
极客安全（jikeanquan.com)
希望以上教程能帮助你成功实现Kali Linux的汉化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2c6f0cd9966bf89ac3940971c0f155/" rel="bookmark">
			网络七层模型之表示层：理解网络通信的架构（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 🤍 前端开发工程师、技术日更博主、已过CET6
🍨 阿珊和她的猫_CSDN博客专家、23年度博客之星前端领域TOP1
🕠 牛客高级专题作者、打造专栏《前端面试必备》 、《2024面试高频手撕题》
🍚 蓝桥云课签约作者、上架课程《Vue.js 和 Egg.js 开发企业级健康管理项目》、《带你从入门到实战全面掌握 uni-app》
文章目录 摘要：引言正文：1️⃣ 表示层的定义与作用2️⃣ 表示层的功能3️⃣ 表示层的实现技术 总结：参考资料： 🌐网络七层模型之表示层解析🔍
摘要： 本文将详细介绍网络七层模型中的表示层，探讨其在数据传输过程中的作用及重要性。
引言 ：在网络通信的世界里，数据传输的稳定性和可靠性至关重要。为了实现这一目标，网络通信采用了分层的设计理念，其中最具代表性的就是OSI七层模型。本文将重点介绍其中的表示层，帮助大家更好地理解其在网络通信中的地位和作用。
正文： 1️⃣ 表示层的定义与作用 表示层位于OSI七层模型的第六层，其主要作用是对数据进行转换、加密和压缩，以确保数据在网络中的传输效率和安全。同时，表示层还负责数据的语法和语义转换，使得不同系统和设备之间能够进行有效的通信。
表示层是 OSI 模型中的第六层，它的主要定义和作用包括以下几个方面：
定义：表示层主要负责处理数据的表示和编码问题，使得不同系统之间能够相互理解和交换信息。
作用：
数据格式转换：表示层将应用层产生的数据转换成适合网络传输的格式，如将二进制数据转换为 ASCII 码或其他编码格式。语法协商：它可以处理不同系统之间的语法差异，确保数据的语法正确和可理解性。数据加密和解密：表示层可以提供数据的加密和解密服务，保护数据的安全性和保密性。压缩和解压缩：通过压缩技术减少数据传输量，提高网络带宽的利用效率。媒体类型转换：例如，将图像、音频或视频等多媒体数据转换成适合传输的格式。系统异构性：表示层用于解决不同系统之间的差异和不兼容性，使得应用程序能够跨平台进行通信。 表示层的存在使得不同的应用程序和系统能够以一种通用的、可理解的方式进行数据交换。它提供了对数据的编码、解码、加密、解密等功能，确保了信息的正确传输和理解。
需要注意的是，在实际的网络协议栈中，表示层的功能可能并不总是明确地划分出来，而是与其他层次的功能结合在一起实现。此外，OSI 模型只是一个理论参考模型，实际的网络实现可能会有所不同，但表示层的概念和作用在网络通信中仍然具有重要的意义。
2️⃣ 表示层的功能 数据转换：表示层可以将数据从一种格式转换为另一种格式，以满足不同系统和设备的需求。例如，将图片从BMP格式转换为JPEG格式，或将文本从ASCII编码转换为UTF-8编码。数据加密：为了保护数据的安全性，表示层可以对数据进行加密处理。加密后的数据在传输过程中不易被窃取和篡改，从而确保数据的安全。数据压缩：表示层可以对数据进行压缩，减少数据在网络中的传输量，提高传输效率。压缩后的数据在传输过程中占用的带宽更小，传输速度更快。 3️⃣ 表示层的实现技术 表示层的实现技术主要包括以下几种：
语法转换：将数据从一种语法格式转换为另一种语法格式，例如XML、JSON等。语义转换：对数据进行语义解释，确保数据在不同系统和设备之间的正确理解和处理。编码转换：将数据从一种编码格式转换为另一种编码格式，例如ASCII、UTF-8等。加密算法：采用对称加密、非对称加密等算法对数据进行加密和解密。压缩算法：采用哈夫曼编码、LZ77等压缩算法对数据进行压缩和解压缩。 总结： 表示层在网络通信中起着至关重要的作用，它通过对数据进行转换、加密和压缩，确保了数据在网络中的传输效率和安全。了解表示层的工作原理和实现技术，有助于我们更好地设计和优化网络通信系统。
参考资料： 谢希仁. 计算机网络[M]. 人民邮电出版社, 2013.James F. Kurose, Keith W. Ross. 计算机网络: 自顶向下方法[M]. 机械工业出版社, 2017. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4516ae5886b2fdf1dcb268d7380e1c/" rel="bookmark">
			网络七层模型之数据链路层：理解网络通信的架构（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 🤍 前端开发工程师、技术日更博主、已过CET6
🍨 阿珊和她的猫_CSDN博客专家、23年度博客之星前端领域TOP1
🕠 牛客高级专题作者、打造专栏《前端面试必备》 、《2024面试高频手撕题》
🍚 蓝桥云课签约作者、上架课程《Vue.js 和 Egg.js 开发企业级健康管理项目》、《带你从入门到实战全面掌握 uni-app》
文章目录 摘要：引言：正文：1️⃣ 数据链路层的基本概念2️⃣ 数据链路层的功能3️⃣ 数据链路层的主要协议和技术4️⃣ 数据链路层在网络通信中的作用 总结：参考资料： 网络七层模型之数据链路层：可靠的设备间通信
摘要： 本文将详细介绍网络七层模型中的数据链路层，包括其功能、协议和技术，帮助您深入理解数据链路层在网络通信中的重要作用。
引言： 🌐 在计算机网络通信中，网络七层模型是一个描述数据传输和处理过程的分层体系结构。数据链路层作为模型中的第二层，负责在相邻网络设备之间可靠地传输数据帧。接下来，让我们一起来探索数据链路层的奥秘。
正文： 1️⃣ 数据链路层的基本概念 数据链路层是网络七层模型中的第二层，它直接与物理层交互，负责在相邻网络设备之间可靠地传输数据帧。数据链路层不关心数据帧的内容，只负责确保它们从一端传输到另一端。
数据链路层是计算机网络协议栈中的一层，它位于物理层之上，负责在直接相连的节点之间传输数据。以下是数据链路层的一些基本概念：
节点：数据链路层中的节点可以是计算机、路由器、交换机等网络设备。链路：链路是连接两个节点的物理通信通道，可以是有线链路（如以太网电缆）或无线链路（如 Wi-Fi）。帧：数据链路层将数据分割成较小的单元，称为帧。帧包含了源节点和目标节点的地址、数据以及用于差错检测的校验信息。MAC 地址：每个节点都有一个唯一的媒体访问控制（MAC）地址，用于标识节点在链路中的身份。差错控制：数据链路层负责检测和纠正传输过程中可能发生的错误，以确保数据的完整性。流量控制：为了避免发送方发送数据过快导致接收方无法及时处理，数据链路层采用流量控制机制来协调数据的传输速度。访问控制：由于多个节点可能共享同一链路，数据链路层需要确定节点访问链路的规则，以防止冲突和提高传输效率。协议：数据链路层有多种协议，如以太网、无线局域网（WLAN）等。这些协议定义了帧的格式、寻址方式、差错控制和流量控制等规则。数据链路层设备：交换机是常见的数据链路层设备，它根据 MAC 地址进行数据帧的转发。服务：数据链路层为上层提供可靠的链路级服务，使得上层无需关心物理链路的细节。 数据链路层的主要任务是在相邻节点之间可靠地传输数据帧，并提供了地址识别、差错检测、流量控制等功能，使得网络能够正常工作。它在网络通信中起到了关键的作用，为上层协议提供了稳定的数据传输基础。具体的实现方式和功能可能因网络类型和协议而有所不同。
2️⃣ 数据链路层的功能 数据链路层的主要功能包括：
帧的传输：数据链路层负责将数据分割成帧，并在相邻设备之间传输这些帧。错误检测和校正：数据链路层可以检测并校正传输过程中的错误，以保证数据的可靠性。媒体访问控制：数据链路层还负责媒体访问控制，以确保多个设备可以共享同一物理媒体。 3️⃣ 数据链路层的主要协议和技术 数据链路层使用的主要协议和技术包括：
以太网协议（Ethernet）：以太网是最常用的局域网技术之一。高级数据链路控制（HDLC）：HDLC是一种广泛使用的数据链路层协议。点到点协议（PPP）：PPP是一种广泛使用的点对点数据链路层协议。 4️⃣ 数据链路层在网络通信中的作用 数据链路层在网络通信中起着至关重要的作用。它不仅确保了数据从一台设备可靠地传输到另一台设备，还通过错误检测和校正提高了数据的可靠性。
总结： 🎉 数据链路层是网络七层模型中的关键层，它确保了相邻设备之间的可靠通信。通过了解数据链路层的基本概念、功能、主要协议和技术，我们可以深入理解它在网络通信中的重要作用。
参考资料： 网络七层模型之数据链路层基础教程数据链路层在网络通信中的作用数据链路层的主要协议和技术 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ae491b10842e6f94b3deac17085030/" rel="bookmark">
			单链表算法库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		singlelist.cpp
#include "singlelist.h" /************************************************** ①函数名: CreatList_Head 功 能: 头插法建立单链表 参 数: (1)LinkList *&amp;L: 传入的单链表指针地址 (2)ElemType Array_used[]:要用来建表的数组 (3)int Array_number: 数组的长度 返回值: 无 **************************************************/ void CreatList_Head(LinkList *&amp;L, ElemType Array_used[], int Array_number) { int counter; LinkList *newnode; L = (LinkList *)malloc(sizeof(LinkList)); //创建头结点 L-&gt;next = NULL; for(counter = 0; counter &lt; Array_number; counter++) { newnode = (LinkList *)malloc(sizeof(LinkList)); //创建新节点 newnode-&gt;data = Array_used[counter]; newnode-&gt;next = L-&gt;next; //将newnode插在原开始结点之前,头结点之后 L-&gt;next = newnode; } } /************************************************** ②函数名: CreatList_Tail 功 能: 尾插法建立单链表 参 数: (1)LinkList *&amp;L: 传入的单链表指针地址 (2)ElemType Array_used[]:要用来建表的数组 (3)int Array_number:数组的长度 返回值: 无 **************************************************/ void CreatList_Tail(LinkList *&amp;L, ElemType Array_used[], int Array_number) { int counter; LinkList *newnode,*tailnode; L = (LinkList *)malloc(sizeof(LinkList));//创建头结点 L-&gt;next = NULL; tailnode = L; //尾结点tailnode始终指向终端结点,开始指向头结点 for(counter = 0; counter &lt; Array_number; counter++) { newnode = (LinkList *)malloc(sizeof(LinkList)); //创建新节点 newnode-&gt;data = Array_used[counter]; tailnode-&gt;next = newnode; //将新节点插入到尾结点之后 tailnode = newnode; //更新尾结点 } tailnode-&gt;next = NULL; //终端结点next域置空 } /************************************************** ③函数名: DisplayLinkList 功 能: 输出单链表 参 数: (1)LinkList *L:将要输出的单链表 返回值: 无 **************************************************/ void DisplayLinkList(LinkList *L) { LinkList *shownode; shownode = L-&gt;next; while(shownode !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ae491b10842e6f94b3deac17085030/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aceaa7fc5ad712570eede6a4ad31e39/" rel="bookmark">
			Docker与K8S实战系列教程--靠谱、易学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在招聘网站上，Docker和K8S已经成为频繁出现的技能：
对于Java高级开发、架构师、技术总监，Docker和K8S是必备技能。对于Java初级、中级开发，Docker和K8S是简历里的加分项。 为什么Docker和K8S这么重要？
因为Docker和K8S确实强大！它们的作用是：让项目部署非常便捷、让挂掉的应用自动重启、让应用数的增加和减少非常方便、访问量低时自动减少资源占用、访问量高时自动提高处理速度……
所以，本文介绍靠谱的Docker与K8S实战教程，地址：Docker与K8S实战 - 自学精灵
看完此教程能学到什么？
Linux虚拟机的创建与使用Docker的作用与实战K8S的作用与实战 有了这些技能，无论你是找工作还是部署个人服务器，都是手到擒来！
基础知识 Docker的作用是什么？（免费）Docker、Docker Compose、Docker Swarm、K8S的区别（免费）K8S的作用是什么？Docker和K8S是什么关系？（免费） 准备工作 搭建Linux服务器（免费）
Docker实战 安装Docker（免费）Docker Compose是什么？怎么安装？（免费）体验用Docker运行MySQL（免费）体验用Docker运行SpringBoot项目（免费） K8S实战 安装K8S（免费）安装K8S官方可视化界面（免费）K8S的持久化（免费）K8S部署SpringBoot简单项目K8S部署SpringBoot项目(调用MySQL)K8S部署SpringCloud项目K8S为什么要用Ingress？与Nginx有什么区别？（免费）K8S部署Ingress-Nginx（暴露服务）K8S如何请求和限制资源？（免费）体验K8S的自动扩容与缩容 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c77f7269dd70dd089367f652b1c0891/" rel="bookmark">
			分片技术：一致性哈希和普通哈希的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一致性哈希和普通哈希是两种不同的哈希技术，它们有着不同的设计原理和应用场景。
1. 一致性哈希（Consistent Hashing） 特点：
一致性哈希是一种特殊的哈希技术，用于将数据映射到一个连续的环上。环上的每个位置对应一个节点，例如服务器节点。数据通过计算哈希值，并在环上顺时针找到最近的节点来决定被存储的节点。 应用场景：
分布式缓存：用于将缓存键映射到一组缓存节点，以实现缓存数据的分布式存储和访问。负载均衡：用于将请求映射到一组服务器节点，以实现负载均衡和高可用性。 2. 普通哈希 特点：
普通哈希是一种将数据映射到固定范围的离散值的技术。数据通过计算哈希值，并通过哈希函数得到一个离散值来决定数据被存储的位置。 应用场景：
散列表：在编程中常用的数据结构，用于快速查找和存储数据。数据存储：常用于数据索引和数据分区。 3.区别 数据映射方式：
一致性哈希将数据映射到一个连续的环上，通过顺时针查找最近的节点来确定数据的存储位置。普通哈希将数据映射到一个固定范围的离散值上，通过哈希函数直接得到数据的存储位置。 数据分布策略：
一致性哈希在增加或删除节点时，通常只会影响到少量的数据移动。普通哈希在增加或删除节点时，可能会导致大量数据的移动和重新分布。 适用场景：
一致性哈希适用于负载均衡和数据分布式存储，特别适用于分布式系统中节点动态变化的情况。普通哈希适用于散列表和数据存储等场景，但在节点动态变化的情况下，可能会导致数据的大规模移动。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653d0dfa047dd08b778a5b5f59edd5e7/" rel="bookmark">
			Acwing_799最长连续不重复子序列 【双指针 快慢指针】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目： 代码： #include &lt;bits/stdc++.h&gt; #define int long long #define INF 0X3f3f3f3f #define endl '\n' using namespace std; const int N = 100010; int arr[N]; int n; signed main(){ std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin&gt;&gt;n; int cnt[N];//用来记录元素个数 int ans = 1; for(int i = 1 ; i &lt;= n; i++){ cin&gt;&gt;arr[i]; } for(int i = 1 , j = 1; i &lt;= n; i++){ cnt[arr[i]]++; while(cnt[arr[i]]&gt;1){ //出现重复元素 删除前面元素的数量 cnt[arr[j]]--; j++;//移动指针 } ans = max(ans,i-j+1); } cout&lt;&lt;ans; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3614c1dc26f92519a4f3855159705467/" rel="bookmark">
			【代驾&#43;顺风车&#43;货运】全开源双端APP代驾&#43;顺风车&#43;货运代驾小程序源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容目录 一、详细介绍二、效果展示1.部分代码2.效果图展示 一、详细介绍 系统是基于Thinkphp+uniapp开发的，全开源未加密，这套源码可以拿回去自己做二开
后台+用户端+司机端
功能详情介绍：
车主实名认证，驾驶证认证，车辆信息认证，后台审核，代驾管理，顺风车管理会员管理 认证管理 代驾管理 顺风车管理 分类管理 提现管理 优惠券管理 车辆设置 地图 平台管理 问题投诉 资料档案 权限管理 常规管理
一、乘客端
多版本：小程序、APP（安卓/苹果）
客户叫车时可以地图选点和手动搜索地址
查看司机和车辆信息
安全中心：一键呼救和紧急联络人
司机的评分与投诉
优惠券营销
支持在线支付
二、司机端
内置高德地图导航
线下收款：行程结束后司机可线下收款，平台从司机余额中扣除服务费
接单模式：自动派单、手动接单、后端指派
可以实时查看周围范围内的司机及其状态
一键导航，线路规划，等待时间计费方式
二、效果展示 1.部分代码 代码如下（示例）：
/** * 第三方登录 * * @param string $platform 平台名称 * @param string $code Code码 */ public function third() { $url = url('user/index'); $platform = $this-&gt;request-&gt;request("platform"); $code = $this-&gt;request-&gt;request("code"); $config = get_addon_config('third'); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3614c1dc26f92519a4f3855159705467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18ab65e63398dd223ed8964ee06d3c4/" rel="bookmark">
			uniapp 安卓跳转到应用设置等页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// #ifdef APP-PLUS const platform = uni.getSystemInfoSync().platform if (platform === 'android') { var	main = plus.android.runtimeMainActivity(); //获取activity var pkName = main.getPackageName(); var Intent = plus.android.importClass('android.content.Intent'); var Settings = plus.android.importClass('android.provider.Settings'); var Uri = plus.android.importClass('android.net.Uri'); var packageUri = Uri.parse("package:" + pkName); var intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS, // 应用省电策略 packageUri); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); main.startActivity(intent); } // #endif 普通设置 var	main = plus.android.runtimeMainActivity(); //获取activity var Intent = plus.android.importClass('android.content.Intent'); var Settings = plus.android.importClass('android.provider.Settings'); var intent = new Intent(Settings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b18ab65e63398dd223ed8964ee06d3c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/829a40315626153e57864c074e871b59/" rel="bookmark">
			2.7、创建列表（List）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 列表是一种复杂的容器，当列表项达到一定数量，内容超过屏幕大小时，可以自动提供滚动功能。它适合用于呈现同类数据类型或数据类型集，例如图片和文本。在列表中显示数据集合是许多应用程序中的常见要求（如通讯录、音乐列表、购物清单等）。
使用列表可以轻松高效地显示结构化、可滚动的信息。通过在List组件中按垂直或者水平方向线性排列子组件ListItemGroup或ListItem，为列表中的行或列提供单个视图，或使用ForEach迭代一组行或列，或混合任意数量的单个视图和ForEach结构，构建一个列表。List组件支持使用条件渲染、循环渲染、懒加载等渲染控制方式生成子组件。
我开发的 Demo 展示 以下代码均经过我 demo 的实战验证，确保代码和效果对应
布局与约束 列表作为一种容器，会自动按其滚动方向排列子组件，向列表中添加组件或从列表中移除组件会重新排列子组件。
如下图所示，在垂直列表中，List按垂直方向自动排列ListItemGroup或ListItem。
ListItemGroup用于列表数据的分组展示，其子组件也是ListItem。ListItem表示单个列表项，可以包含单个子组件。
布局 List除了提供垂直和水平布局能力、超出屏幕时可以滚动的自适应延伸能力之外，还提供了自适应交叉轴方向上排列个数的布局能力。
利用垂直布局能力可以构建单列或者多列垂直滚动列表，如下图所示。
垂直滚动列表 单列
对应代码 @Entry @Component struct ListVerticalPage { @State listItems:Array&lt;String&gt; = [] aboutToAppear() { for (var i =0;i&lt; 50;i++) { this.listItems.push("") } } build() { Navigation() { List({space: 5}) { ForEach(this.listItems, ()=&gt; { ListItem() { Stack() .width('100%') .height(100) .backgroundColor('#9dc3e6') } .padding({left:15, right:15}) }) } } .title('垂直滚动列表') .titleMode(NavigationTitleMode.Mini) } } 多列
@Entry @Component struct ListMultiVerticalPage { @State listItems:Array&lt;String&gt; = [] aboutToAppear() { for (var i =0;i&lt; 50;i++) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/829a40315626153e57864c074e871b59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8ef14eeb0ff709cc32ddab7b1d80ad/" rel="bookmark">
			多线程合并练习题，线程安全（售票任务引入）--学习JavaEE的day30
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day30 练习（day29） 注意代码注释，里面涉及代码实现遇到问题及解决方案，由于理解方便没有单独出来
1.计算任务 1.计算任务，一个包含了2万个整数的数组，分拆了多个线程来进行并行计算，最后汇总出计算的结果。
使用线程类 public class MyThread extends Thread{ private int startIndex;//开始下标（包含） private int endIndex;//结束下标（不包含） private int[] arr;//外界数组 public MyThread(int startIndex, int endIndex, int[] arr) { this.startIndex = startIndex; this.endIndex = endIndex; this.arr = arr; } private int sum; private boolean flag = true; @Override public void run() { for (int i = startIndex; i &lt; endIndex; i++) { sum += arr[i]; } flag = false; } public int getSum() { return sum; } public boolean isFlag() { return flag; } } public class Test01 { public static void main(String[] args) throws InterruptedException { //创建数组 int[] arr = new int[20000]; //初始化数组数据 -- {1,2,3,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8ef14eeb0ff709cc32ddab7b1d80ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38392e10850d675bf443021fadca292d/" rel="bookmark">
			36.基于SpringBoot &#43; Vue实现的前后端分离-高校汉服租赁网站系统（项目 &#43; 论文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 本站是一个B/S模式系统，采用SpringBoot + Vue框架，MYSQL数据库设计开发，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得基于SpringBoot + Vue技术的高校汉服租赁网站系统设计与实现管理工作系统化、规范化。
系统包含普通用户和管理员两个角色：
普通用户：注册、登录系统、查看汉服首页发帖公告信息、交流论坛（发帖、查看帖子、评论）、公告咨询（查看公告以及评论）、 汉服信息（查看汉服、收藏、点赞）、个人中心（修改资料、收藏管理、汉服租赁归还、评价）管理员：登录系统、个人中心、管理员维护、用户管理维护、汉服信息管理(汉服、评价、收藏、租赁维护)、交流论坛维护、公告咨询维护以及基础数据维护和轮播图的维护 技术选型 后端: SpringBoot +Mybatis
数据库 : MySQL 8
前端: VUE + ElementUI + nodejs
功能结构图 成果展示 前台网站系统 登录 注册 首页 交流论坛 汉服信息 个人中心 汉服租赁 后台管理系统 登录 用户管理 汉服信息管理 汉服租赁管理 交流论坛管理 公告资讯管理 汉服类型管理 轮播图管理 源码下载地址获取 QQ: 3638108660
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a54e54a98302316859675af42147bc3/" rel="bookmark">
			数据库审计和安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互联网、云计算、物联网等新技术的应用，数据安全面临前所未有的挑战!我国信息安全已从终端安全、网络安全，发展到数据安全建设阶段。数据安全的核心是对“数据”全方位的安全防护，其产品及解决方案直接涉及国家和企业的核心机密
核心数据库存在的风险
1、敏感信息被泄露，如用户姓名，电话，用户地址等重要信息被泄露。
2、操作人员非法更改数据信息，例如日常业务或交易信息，这些对信息化系统的运作以及客户隐私有重大影响。
3、非法对数据库访问权限授权，某些人没有数据库的写权限，通过非法授权，他就可以对重要数据随意获取、更改，破坏。
4、数据库维护人员对业务系统的误操作，恶意操作，权限滥用等行为无法做到全面的审计。
5、黑客攻击，黑客惯常使用的攻击手段包括窃听、重发攻击、迂回攻击、假冒攻击、越权攻击等等，网络中总是存在各种安全漏洞，因此黑客的攻击行为是威胁核心数据安全的一大隐患。黑客攻击网络的目的通常是扰乱系统正常运行或者窃取重要的商业机密。
什么是数据库审计
对进出核心数据库的访问流量进行数据报文字段级的解析操作，还原操作细节，并提供实时的记录告警、审计取证追溯以及异常行为分析功能，解决数据库权限划分混乱、账号复用、事故追查难、安全规章制度难以落实等全方位的安全监控保障
德迅云安全数据库审计和安全是保障数据库数据安全的重要手段，主要涉及以下功能：
1、信息脱敏：支持银行账号、身份证号码等敏感信息的脱敏展示，系统会自动发现敏感信息并过滤掉部分字段进行展示
2、安全告警：支持多维度的数据库访问行为分析，并产生不同级别的告警信息，用户可通过告警日志回溯可疑的用户访问行为，并可以根据时间、字段和告警等级、规则名称进行筛选
3、报表统计：支支持丰富的报表，每张报表都是以不同的维度展示当前被审计的数据库系统的运行情况，包含塞班斯报表、综合分析报表、性能分析报表、等保参考分析报表、语句分析类报表、会话分析类报表、告警分析类报表等
4、智能分析：数据库审计通过UEBA（用户实体行为分析）的理念分析数据库访问行为中可能存在的可疑行为，通过可配置的行为模型学习数据库服务器历史被访问轨迹快速判断访问行为可能存在的风险
5、安全审计：支持主流的数据库系统审计，包括传统的数据库系统、大数据系统和Web系统等，如Oracle、SQLServer、Mysql、DB2、Sybase、MARIADB、MongoDB、Hana、人大金仓神州OSCAR、达梦（DM）、南大通用（GBase）、Informix、TERADATA、PostgreSQL、HbaseProtobuf、GuassDB、HTTPFtp等
德迅云安全公司为用户提供数据库审计与监控能力，对数据库风险操作行为进行实时记录与告警，提供数据库权限管控、事后行为审计能力，满足云上等保合规要求，能够解决：
操作审计：通过录像回放记录操作过程，作为事后分析的依据
行为监控：解析请求流量，还原操作，实时监控数据库的行为行归类
安全告警：智能分析数据库的异常访问行为，并实时告警资产间的关联分析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ac3b9ad024e3340f3dc33368af3e12/" rel="bookmark">
			什么是CVE？ CVE漏洞应该如何防护？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CVE（Common Vulnerabilities and Exposures）的全称是公共漏洞和暴露，是公开披露的网络安全漏洞列表。IT人员、安全研究人员查阅CVE获取漏洞的详细信息，进而根据漏洞评分确定漏洞解决的优先级。
在CVE中，每个漏洞按CVE-1999-0067、CVE-2014-10001、CVE-2014-100001这样的形式编号。CVE编号是识别漏洞的唯一标识符。CVE编号由CVE编号机构（CVE Numbering Authority，CNA）分配，CVE编号机构主要由IT供应商、安全厂商和安全研究组织承担。
CVE如何形成的？ CVE漏洞信息由CVE组织机构的网站承载（http://cve.mitre.org/），CVE这个组织最初由麻省理工学院在1999年建立，是一个非营利性组织。网站上的CVE信息是公开的，可以在法律许可前提下免费使用。
每个漏洞都被分配一个称为CVE标识符的编号，编号格式为“CVE-年份-编号”，例如CVE-2019-0708代表远程桌面服务远程代码执行漏洞。
CVE的发布主体是CVE编号机构（CVE Numbering Authority，CNA），当前大约有100个CNA，由来自世界各地的IT供应商、安全公司和安全研究组织组成。任何机构或个人都可以向CNA提交漏洞报告，CNA对应的组织往往也会鼓励人们寻找漏洞，以增强产品的安全性。
不是所有漏洞都能被录入CVE，CNA主要根据如下规则判定是否为漏洞分配CVE编号：
漏洞可独立修复，与其他漏洞没有耦合。
软件或硬件供应商承认此漏洞的存在或有书面公告。
漏洞只影响一个代码库，如果漏洞影响多个产品，则为每个产品独立分配CVE编号。
经过上述判断，如果可以分配编号则编写描述信息并发布到CVE网站。每个CVE条目主要包含以下信息：
描述：漏洞的来源、攻击方式等简要描述。
参考：漏洞的相关参考信息链接汇总，例如供应商的漏洞公告、紧急响应建议等。
发布的CNA：发布此CVE的CNA。
发布日期：此CVE的发布日期。
综上，CVE机构通过与CNA合作，识别、定义、公开发布网络安全漏洞，形成漏洞信息行业标准。
CVE有什么作用？ 如果没有CVE，每个IT供应商或安全组织都维护自己的漏洞数据库，数据无法共享，大家对漏洞的认识也不统一。CVE为漏洞赋予唯一编号并标准化漏洞描述，主要作用如下：
IT人员、安全研究人员基于相同的语言理解漏洞信息、确定修复漏洞的优先级并努力解决漏洞。
不同的系统之间可以基于CVE编号交换信息。
安全产品或安全工具开发者可以将CVE作为基线，评估产品的漏洞检测覆盖范围。
有的人可能会认为公开披露漏洞会给黑客带来可乘之机，黑客会利用这些漏洞发起攻击。其实利大于弊，首先CVE只公开已知的漏洞，不管是否有CVE，黑客都能获取漏洞信息；其次漏洞详细信息和修复建议可以暂时隐藏，只分配编号，直到IT供应商发布补丁等修复程序；最后漏洞信息在整个行业的共享可以加快修复建议的推出。
建议在安全产品或工具的安全事件报告等内容中包含CVE编号信息，这样使用该安全产品或工具的人员可以迅速获取网络中存在的漏洞信息，并根据漏洞修复建议解决问题。
当然CVE网站中的信息比较简要，CVE主要用于给漏洞指定身份。更多的修复建议、影响、评分等信息需要直接到IT供应商网站、其他漏洞数据库获取。但是不可否认，CVE编号是这些信息的串联者，基于CVE编号可以快速检索到漏洞信息。
CVE与CVSS的关系 通用漏洞评估系统（Common Vulnerability Scoring System，CVSS）是广泛应用的漏洞评分开放标准。CVSS的分值代表漏洞的严重程度，分值范围为0.0到10.0，数字越大漏洞的严重程度越高。CVSS评分往往是漏扫工具、安全分析工具不可或缺的信息。
CVE单纯是漏洞的字典库，CVE列表中不包含CVSS分值，需要使用其他漏洞管理系统查阅CVSS分值。IT人员结合CVE信息和CVSS确定漏洞解决优先级。
遇到CVE攻击应该怎么办 这一漏洞允许攻击者远程执行代码，获取服务器权限，会对企业网络和数据造成严重损失。因此，德迅云安全建议您采取以下有效措施来保护服务器免受攻击：
第一，我们需要进行深入的漏洞分析，了解漏洞的本质和可能产生的影响。通过分析漏洞的原理，我们可以找到漏洞的入口点，并尝试利用漏洞实现远程执行代码，以验证漏洞的有效性。在确认漏洞确实存在之后，我们需要尽快采取关闭T3和iiop协议端口等有效措施来防止攻击。
第二，我们需要寻找并安装相应的补丁程序。由于漏洞是由软件程序中的错误导致的，因此软件供应商通常会在发现漏洞后发布相应的补丁程序。我们需要及时查找并安装这些补丁程序，以修复漏洞并增强服务器的安全性。
第三，我们需要对服务器进行安全加固和配置调整。安全加固可以帮助我们识别并修复潜在的安全漏洞，包括限制服务器访问权限、修改默认用户名和密码、关闭不必要的服务和端口等。此外，我们还需要对服务器的配置进行调整，以提高服务器的安全性和稳定性。
第四，可以使用德迅云安全漏洞扫描。通过漏洞扫描器对Web应用资产进行安全扫描，发现Web应用中存在的安全漏洞，针对最紧急爆发的VCE漏洞，安全专家第一时间分析漏洞、更新规则、提供最快速专业的VCE漏洞扫描并可快速部署相关防护
最后，我们需要加强人员的安全意识和培训。由于服务器的安全性需要人员的共同维护，安全意识和培训包括教育用户采用强密码、不随意打开附件、不信任来路不明的链接等，以防范攻击者通过钓鱼等手段获取服务器权限。
结语 我们需要采取多重措施来保护服务器的安全性。包括深入分析漏洞、寻找并安装补丁程序、进行安全加固和配置调整，以及加强人员的安全意识和培训。只有通过综合手段加强服务器的安全性，才能有效防范黑客攻击，保护企业网络和数据的安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce5eaf37aac460f132cad1fd302d1e16/" rel="bookmark">
			多进程编程及相关函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 查看系统中的进程进程标识进程创建进程终止僵尸进程守护进程和孤儿进程wait函数exec函数system函数 程序是存放在磁盘文件中的可执行文件。程序的执行实例被称为进程，进程具有独立的权限与职责。
每个进程运行在其各自的虚拟地址空间中，进程之间可以通过由内核控制的机制相互通讯。如果系统中某个进程崩溃，它不会影响到其余的进程。
每个Linux进程都一定有一个唯一的数字标识符，称为进程ID，PID(进程ID)总是一个非负整数。
在进程的main函数执行之前内核会启动，编译器在编译的时候会将启动例程编译进可执行文件中。
启动例程的作用：搜集命令行的参数传递给main函数中的argc和argv；搜集环境信息构建环境表并传递给main函数；登记进程的终止函数。
查看系统中的进程 通过下面的命令就可以查看当前系统执行的进程。
ps
ps -ef
ps -aux
ps -ef | more
当前系统执行的进程如下图所示。
USER是指进程的属主；PID：进程ID号；PPID：父进程ID号；%CPU：进程占用的CPU百分比；%MEM：占用内存的百分比；VSZ：进程虚拟大小；RSS：驻留中页的数量；TTY：终端ID；STAT：进程的状态；START：启动进程的时间；TIME：进程消耗CPU的时间；COMMAND：命令的名称和参数。
进程常见的状态：运行状态®、等待状态(S)、停止状态(T)、僵尸状态(Z)。僵尸状态指的是进程终止或结束，但是在进程表项中仍有记录。
进程标识 获取进程相关标识的函数原型如下。
#include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; pid_t getpid(void); //获取当前进程ID uid_t getuid(void); //获得当前进程的实际用户ID uid_t geteuid(void); //获得当前进程的有效用户ID gid_t getgid(void); //获得当前进程的用户组ID pid_t getppid(void); //获得当前进程的父进程ID pid_t getpgrp(void); //获得当前进程所在的进程组ID pid_t getpgid(pid_t pid); //获得进程ID为pid的进程所在的进程组ID 关于进程标识相关的代码示例如下。
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; int main() { printf("pid : %d\n",getpid()); printf("ppid : %d\n",getppid()); printf("uid : %d\n",getuid()); printf("euid : %d\n",geteuid()); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce5eaf37aac460f132cad1fd302d1e16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e84bd6d534dabcdc3af5da1dabbd3a7b/" rel="bookmark">
			SQLiteC/C&#43;&#43;接口详细介绍sqlite3_stmt类（十三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返回：SQLite—系列文章目录 上一篇：SQLiteC/C++接口详细介绍sqlite3_stmt类（十二） 下一篇： SQLite数据库文件损坏的可能几种情况 51、sqlite3_stmt_scanstatus_reset sqlite3_stmt_scanstatus_reset 函数用于重置指定语句对象最近一次执行的 WHERE 子句中搜索的行数及扫描的页数的数据，以便进行下一次查询。
函数原型如下：
void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt); 参数说明：
- pStmt：已经编译的 SQLite 语句对象。
该函数没有返回值。
举例用法：
int nLoop = 0; int nVisit = 0; sqlite3_stmt *stmt; sqlite3_prepare_v2(db, "SELECT * FROM user WHERE age &gt; ?", -1, &amp;stmt, NULL); sqlite3_bind_int(stmt, 1, 18); while (sqlite3_step(stmt) == SQLITE_ROW) { nLoop++; } sqlite3_stmt_scanstatus_reset(stmt); // 重置搜索的行数和扫描的页数 while (sqlite3_step(stmt) == SQLITE_ROW) { nLoop++; } sqlite3_stmt_scanstatus(stmt, SQLITE_SCANSTAT_NLOOP, 0, &amp;nLoop); sqlite3_stmt_scanstatus(stmt, SQLITE_SCANSTAT_NVISIT, 0, &amp;nVisit); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e84bd6d534dabcdc3af5da1dabbd3a7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21681dbb71094c11ca83244b057171c0/" rel="bookmark">
			如何在Linux系统使用宝塔面板搭建Inis博客并发布至公网【内网穿透】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. Inis博客网站搭建1.1. Inis博客网站下载和安装1.2 Inis博客网站测试1.3 cpolar的安装和注册 2. 本地网页发布2.1 Cpolar临时数据隧道2.2 Cpolar稳定隧道（云端设置）2.3.Cpolar稳定隧道（本地设置） 3. 公网访问测试总结 前言 互联网技术总在不断进步，新技术和新软件也会来带更多功能，就以最常见的个人博客系统，也在不断推陈出新，发掘出更多功能和特色。从早期少量自定义和编辑功能，发展到现在的支持各种自定义模块和外观，以及更多更全的支持软件适配（包括php程序、数据库程序等）。今天，笔者就为大家介绍，如何在Ubuntu系统上部署新版Inis博客系统，并使用cpolar创建的内网穿透数据隧道，将Inis博客网站发布到公共互联网上。
1. Inis博客网站搭建 Inis博客系统作为较新的个人博客网站程序，自然使用了较新的php程序，同时也能支持Web端、APP和小程序端，并且内置了丰富的API（可以理解为软件的数据接口，让开发者能更方便的开发扩展功能），对于使用者来说，就是更多样化的外观选择和功能扩展。
1.1. Inis博客网站下载和安装 与常见的软件一样，Inis也设有自己的官网（inis.cc），我们可以在Inis的官网上找到安装指南、问题解决、新外观预览等多种内容。
在Inis官网的安装说明中，我们可以找到Inis支持8.0版本的php，数据库则是MySQL5.5版本。因此我们需要在宝塔面板上安装对应版本的Apache、MySQL、PHP（即所谓的LAMP，如果是在Linux下安装Nginx、MySQL、PHP，则称为LNMP）。通常第一次登录宝塔面板，只要本地硬件设备上没有安装过Apache、MySQL、PHP这些软件，宝塔面板就会自动弹出询问，选择安装哪些网页运行程序。
当然，也可以在宝塔面板的主页（可以在浏览器中输入本地地址:宝塔面板输出端口号）左侧，找到“软件商店”按钮，点击进入软件商店页面。在这个页面，我们可以找到常用的网站运行支持程序，包括Nginx、Apache、MySQL、PHP、phpMyadmin、Tomcat、Docker管理器、Redis等等。我们找到所需的软件，点击该软件条目右侧的“安装”，即可将其安装至ubuntu系统上。
完成Apache、MySQL、PHP几项软件的安装后，我们可以点击软件商店页面上方的“已安装”按钮，查看已经安装的软件。同时，也可以在这里切换每个软件的版本。
下一步，就可以进行Inis博客网站的部署。通常网站部署的步骤是将下载的网站源代码，放置到宝塔面板的wwwroot文件夹下，不过好在宝塔面板中提供了Inis博客网站的“一键部署”模式，大大减轻了新手用户的网站部署难度。
点击宝塔面板主界面左侧的“软件商店”。进入软件商店后，在页面上方找到“一键部署”按钮，进入可以一键部署的网站分页，从中选取“hadsky”条目，点击该条目右侧的“一键部署”按钮。
接下来宝塔面板会弹出网站基本设置窗口，在这里我们可以指定网站的基本信息，这些信息包括：
域名（以及输出端口号） - 在“域名”栏位，通过“打算使用的域名：打算使用的端口”形式设置；
根目录 – 这个栏位可改可不改，但这个根目录内容会与“域名”栏位联动，为防止混淆，笔者还是将其更改为inis；
数据库 – 这里填入打算设置的数据库信息即可；为方便分辨，笔者将其设置为inis；
PHP版本 – 对于某些网站可能会要求使用特定版本的PHP，我们就可以在PHP版本栏位修改（前提是已经安装了对应版本的PHP软件），比如inis要求使用php8.0及以上，因此这里选择php8.0版本；
完成这些设置后，就可以点击窗口下方的“提交”按钮，创建本地的inis博客网站。
Inis网站创建完成后（也就是inis源码下载及数据库建立），宝塔面板会弹出已创建网站的地址，重要的网站信息（可能是数据库信息，或是网站后台登录信息）。
接着打开ubuntu系统上的宝塔面板，在软件主界面左侧点击“网站”按钮，进入网站列表页面，就能看到刚刚安装上线的inis博客网站。
此时在ubuntu的浏览器地址栏输入设置好的inis博客网站地址，就能看到haddsky的设置页面。我们继续根据网站显示页面的提示，进行具体的网站设置工作。
首先是对inis博客网站的数据库设置，我们需要在这步填入创建网站时设置的数据库名称和密码。如果忘记所设置的数据库信息，则可以在宝塔面板左侧的“数据库”页面找到所设置的相关信息。
填入数据库信息后，就可以点击“下一步”，inis会对网站的安装环境进行自检（主要是php的各项扩展），只有各项插件都自检通过后，才能继续下一步安装。
第三步，就是设置inis博客网站本身的信息，包括博主名称、账号、密码及邮箱信息。
完成这最后一步设置，就可以点击页面下方的“开始安装”，进行inis博客网站的部署。只需等待很短时间，inis博客就能在本地安装完成。Inis博客网站会在安装完成后，转入登录页面。
我们可以在这里对inis博客网站进行各种设置。
虽然此时inis博客网站已经安装完成，但我们还没有为inis博客安装前端（也就是inis网站的主题），因此我们在访问本地的inis博客地址时，会自动跳转到后台登录页面。想要让我们的inis博客网站能以漂亮的主题接待访客（任何人都能看到的博客外观），我们需要新建一个inis博客网站的前端站点。
要新建inis博客的前端站点，我们可以点击宝塔面板左侧的“网站”，在“网站”页面点击“添加站点”按钮，新建一个inis博客网站的前端站点。由于inis博客前端使用了vue3开发，因此可以设置为纯静态，也不用设置php版本，只要设置网站域名即可（宝塔面板默认网站输出端口为80，但笔者的80端口已经占用，因此以添加:87方式，设置inis博客网站前端为87端口）。
完成inis博客网站前端网站的建立后，我们再到inis博客网站的主页下载一个外观主题（inis.cc/index/themes/page/2）。
将这个主题文件解压后的所有文件，粘贴到inis的前端站点根目录里。这个例子中，笔者将inis博客的前端文件粘贴到“www”文件夹下“wwwroot”文件夹的“www.inisweb.com”文件夹中。
需要注意的是，由于Ubuntu系统的权限限制，我们无法直接复制（或剪切）这些文件到wwwroot文件夹，因此可以在ubuntu终端中输入命令“sudo nautilus”，打开一个拥有权限的文件管理器，在这里我们就可以将inis前端的文件移动到wwwroot文件夹下的inis前端站点根目录里（这个例子中inis前端站点根目录为www.inisweb.com文件夹，并且在文件移动完成前，不要关闭ubuntu终端窗口）。
最后，我们在inis博客网站前端根目录找到“static”文件夹，在这个文件夹里找到名为config.js的文件
双击打开这个文件进行编辑，主要修改的内容 ，就是“API地址”列，将原有的api值改为正在修改的config.js文件路径。在这个例子中，config.js文件的路径为www/wwwroot/inisweb/static，因此就要填入“https://www/wwwroot/inisweb/static/config.js”。
再将“route_hash”行的值，改为“fales”。
修改完成后，保存并退出。
1.2 Inis博客网站测试 最后，我们在浏览器地址栏中输入inis博客网站的前端地址（在这个例子中是192.168.157.131:87），就能看到inis博客展示给访客的主页面啦（注：对于Inis博客的前后端网站设置不清晰的，可以访问inis官网的安装教程docs.inis.cc/#/start/install-inis-theme）。
火狐浏览器问题解决
在修改static文件夹下的config.js文件内容时，很可能会碰到权限不足而导致无法修改的问题，这时我们可以打开ubuntu的终端界面，输入命令“su root”，在输入正确密码后，进入root权限进行config.js文件内容的修改；
如果没有进行过root权限设置的，则可以输入命令“sudo passwd root”设置修改root用户密码。
完成后暂时不要关闭终端窗口，而是关闭文件管理窗口，再重新打开和编辑config.js文件，就会发现已经可以对其进行编辑。
ubuntu修改文件权限问题解决
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21681dbb71094c11ca83244b057171c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee5ba2d20e5238c432ed82398041da06/" rel="bookmark">
			Web学习笔记——网络安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作为 前端开发者，了解一点 Web 安全方面的基本知识是有很必要的，未必就要深入理解。本文主要介绍常见的网络攻击类型，不作深入探讨。
正文 网络攻击的形式种类繁多，从简单的网站敏感文件扫描、弱口令暴力破解，到 SQL 注入，再到复杂的网络劫持等，种类万千。
本文只介绍以下两种攻击：
XSS 攻击CSRF 攻击 XSS 攻击 XSS，跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为 XSS。恶意攻击者往Web页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。
XSS 攻击实现的方式和 SQL 注入有点类似，是一种基于 DOM 结构的攻击。利用网站对用户输入、请求参数没有验证，在参数中构造恶意 JavaScript 脚本，嵌入页面运行，从而达到攻击的目的。
如果再细分，XSS 可分成以下三种：
DOM-based XSS（基于 DOM的 XSS 攻击）Stored XSS（基于存储的 XSS 攻击）Reflected XSS（基于反射的 XSS 攻击） 这三种方式大同小异，这里不做细分。
简单示例 举个例子：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 文章内容：&lt;%= request.getParameter("content") %&gt; &lt;/body&gt; &lt;/html&gt; 我们在浏览器打开连接：http://example.com/page?content=&lt;script&gt;alert('Hello world')&lt;/script&gt;，就可以看到一个 Hello world 的弹窗。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee5ba2d20e5238c432ed82398041da06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2abad83c51992796b2eb6eea64804b/" rel="bookmark">
			P2440 木材加工【二分答案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例题
二分答案思路 首先我们输入 n 和 k 并且运用二分找到合适的尺寸，而l 必须要足够小，r 必须要足够的大。题中写道数组中的数最大不会超过 100000000 ，所以我们设1e8+10就可以了。
现在就走到了判断的环节，我们如何判断 mid 是太小还是太大呢？我们需要编写一个新函数 check（）。
在函数 check（） 中，我们依次要判断 a 中的每一个数并计算出能切出多少个 mid ，还要用一个变量 ans 储存他们，如果 ans 分的分数比 k 多或者正好等于，返回真。如果是小于 k ，返回假。
当 check（） 返回的是真的时候，我们就要试试还能不能把 mid 调大一点，就要
l = mid; 如果返回的是假，我们就加的太大了，就要把mid调小一点，就要
r = mid; A了 88 分的代码 少考虑了一个特殊情况 AC代码 #include &lt;bits/stdc++.h&gt; #define endl '\n' #define int long long #define INF 0x3f3f3f3f3f const int N = 100010; using namespace std; int arr[N]; int n, k; bool check(int mid){ int cnt = 0 ; for(int i = 1 ;i &lt;= n;i++){ cnt += arr[i]/mid; } if(cnt &gt;= k)//数量多 咱们就把单位长度变大 return true; return false;//否则.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b2abad83c51992796b2eb6eea64804b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/5/">«</a>
	<span class="pagination__item pagination__item--current">6/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/7/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>