<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7773f6797654b68e9bf43d68a4c0432/" rel="bookmark">
			linux系统在线安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx安装：注意，如果是以前没有安装过nginx这些，需要先安装运行环境
一、依赖安装 在linux下安装nginx，首先需要安装 gcc-c++编译器。然后安装nginx依赖的pcre和zlib包。最后安装nginx即可。
1、先安装gcc-c++编译器 yum install gcc-c++
yum install -y openssl openssl-devel
2、再安装pcre包 yum install -y pcre pcre-devel
3、再安装zlib包 yum install -y zlib zlib-devel
二、nginx 安装 1、在网上下nginx包上传至Linux（https://nginx.org/download/），也可以直接下载，上传目录自己新建一个nginx目录 mkdir /XXXX/XXXXX/nginx
2、对上传的nginx压缩包进行解压操作 tar -zxvf nginx-1.23.1.tar.gz
3、进入解压后的nginx目录 注意，下面的nginx的配置，编译和安装命令一定要在解压后的nginx目录中进行
cd /XXXX/XXXXX/nginx/nginx-1.23.1
4、开始配置nginx ./configure后面不带目录是使用nginx的默认配置，会在/usr/local目录下面自动创建一个nginx目录进行存放安装的nginx配置，有的用户可能没有/usr/local的创建文件权限，那就使用后面的命令，指定目录进行nginx的配置
./configure 或者 ./configure --prefix=/data/zhang/nginx
5、编译 make
6、安装 make install
7、查找安装路径 whereis nginx
8、查看nginx的安装情况 注意，目录是nginx安装后的目录，我使用的是默认目录，所以就：/usr/local/nginx/sbin/nginx -V
/XXX/XXXX/nginx/sbin/nginx -V
到这里nginx基本安装完成了，启动一下nginx
9、进入nginx的安装目录的sbin目录下面，启动nginx 1）进入sbin目录
cd sbin
2）验证配置文件是否有误：加上-t
./nginx -t
3）没有问题之后，启动nginx
./nginx或者指定启动nginx的读取配置文件 ./nginx -c /usr/local/nginx/conf/nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7773f6797654b68e9bf43d68a4c0432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224b38cf18a10e3b9155fc7d03ed4c17/" rel="bookmark">
			如何打开管理员命令提示符窗口？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些系统设置需要打开管理员命令提示符窗口，但是很多用户发现自己打开的命令提示符窗口没有管理员三个字，那要如何以管理员身份运行命令提示符，下面就来看看几种常用的方法。
方法一：
右键点击系统桌面左下角的【开始】，在开始菜单中点击【命令提示符（管理员）】，可以打开系统【管理员命令提示符】窗口（最常用的打开管理员命令提示符窗口的方法）。
方法二：
同时按住键盘上的Win+X组合键，然后放开再按A键，就可以打开【管理员命令提示符】窗口。
方法三：
在系统桌面左下侧搜索栏输入CMD或者命令提示符，右键点击命令提示符在右键菜单中点击：以管理员身份运行，可以打开系统【管理员命令提示符】窗口。
方法四：
左键点击【开始】-【所有应用】，展开【Windows系统】项，右键点击【命令提示符】- 更多 - 以管理员身份运行，可以打开系统【管理员命令提示符】窗口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15ce4d1bb5191cf75824eda2d3d94c6/" rel="bookmark">
			Cisco Packet Tracer8.0工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思科模拟器，挺好用的工具
http://www.wodown.com/soft/26183.html
链接: https://pan.baidu.com/s/1L1Q1-uFIm3H5Ap_ncsHf5w 提取码: s8ey 复制这段内容后打开百度网盘手机App，操作更方便哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d92573f055bcbb3bfcf024d2b8f7e3a/" rel="bookmark">
			解决问题：Key is invalid. You must supply a key in OpenSSH public key format
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
我们在github上面添加秘钥的时候，保存会出现这个错误
Key is invalid. You must supply a key in OpenSSH public key format
原因分析：
这个原因是由于我们直接用工具打开id_rsa文件，然后粘贴复制上去的，但是id_rsa文件被打开之后，格式就会发生变化，所以就会一直报错
解决方案：
有两种解决方法：
1.有一个id_rsa.pub文件，用工具打开，复制粘贴到对应的位置就可以了
github成功的截图如下：
也可以使用命令验证下
2.输入命令clip &lt; ~/.ssh/id_rsa.pub
回车后就复制到剪切板了，然后在github上，添加ssh keys的地方直接就能粘贴上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/899022664d83c5aba6e16e50467523d0/" rel="bookmark">
			C语言进阶 —— 枚举与联合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、枚举1.1 枚举类型的定义1.2 枚举的优点1.3 枚举的使用 二、联合体（共用体）2.1联合类型的定义2.2 联合的特点2.3 联合大小的计算 总结 前言 今天我们会给大家介绍一下枚举和联合体这两个概念，这两者我们其实和结构体结合起来对比学习，三者之间都有其相似之处，当然也有不小的区别，我们今天将会从枚举和联合体的基本定义入手，剖析二者的使用和功能。
一、枚举 我们先讲枚举，从字面意义上来说，枚举的意思就是一一列举
即把所有有可能的值一一列举
比如说：一月份一共有31天，这是有限的，我们是可以一一列举的
又如：性别只有三种情况，男、女或者保密，我们也可以一一列举
等等…
诸如此类，我们都可以称其为列举
在这种情况下我们就可以使用枚举了
1.1 枚举类型的定义 先来看几个例子:
enum Day //星期 { Mon, Tues, Wed, Thur, Fri, Sat, Sun }; enum Sex //性别 { MALE, FEMALE, SECRET }; 以上定义的 enum Day，enum Sex都是枚举类型。
{}中的内容是枚举类型的可能取值，也叫枚举常量 。
那如果现在我们想描述一下星期应该怎么用代码表达出来呢？我们可以这样做：
int main() { enum Day d = Fri; return 0; } 以此类推，其他的枚举类型也是如此
在这里可能有人会问了，既然大括号内的内容叫做枚举常量，那么枚举常量有没有值呢？
在这里我可以很明确的告诉大家，这些枚举常量都是有值的，大家可以尝试用printf函数将所有的枚举常量的值一一打印出来比对一下，
我们很容易就可以发现一个有趣的规律：我们枚举的可能取值都是从0开始的，依次往下递增1，当然这里的前提是默认情况下。
那么我们是否可以修改它们的值呢？比如我希望第一个枚举常量从1开始，其实这是很容易实现的，只需将"Mon"改为"Mon = 1"即可。
后面的枚举常量也和默认情况下一样依次递增1。
1.2 枚举的优点 为什么使用枚举？使用枚举的好处是什么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/899022664d83c5aba6e16e50467523d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deaa39e4775f186e3a73388219ef22d3/" rel="bookmark">
			关于form表单的回显问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		form表单新添加了一个新的字段，但是后台没有返回此字段的问题，回显有问题，无法进行更改单选框或选择框。可能是form表单数据的类型问题。转换一下就可以。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/116d9d5c5af0677de7ad0ae10b02bbfd/" rel="bookmark">
			Promise学习（四）异步编程的终极解决方案async &#43; await：用同步的方式去写异步代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. async 函数2. await表达式3. 解决异步编程的终极方案 async + await4. async 和 await 结合实践1：读取文件信息5. async 和 await 结合实践2：结合Ajax获取接口信息注意接口的跨域问题 前言 本文是通过尚硅谷老师的Promise教程和阮一峰ES6教程以及一些其他的网络资源来进行总结学习。
1. async 函数 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 async 函数是使用 async 关键字声明的函数。 async 函数是AsyncFunction构造函数的实例， 并且其中允许使用 await 关键字。async 和 await 关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。
async 是一个加在函数前的修饰符，被 async 定义的函数会默认返回一个Promise对象 resolve 的值。因此对 async 函数可以直接 then，返回值就是then方法传入的函数。
函数的返回值为 promise 对象promise 对象的结果由 async 函数执行的返回值决定 async function main() { //1. 如果返回值是一个非Promise类型的数据 // return 521; // 成功 //2. 如果返回的是一个Promise对象 // return new Promise((resolve, reject) =&gt; { // // resolve('ok'); // 成功 // reject('err'); // 失败 // }); //3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/116d9d5c5af0677de7ad0ae10b02bbfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e897cb808e8b93604c15fc496605af5d/" rel="bookmark">
			【repo】SyntaxError: invalid syntax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【repo】SyntaxError: invalid syntax 问题描述 Windows10系统上安装git之后，安装repo并进行配置后，为了校验repo是否能够正常使用，在git bash中输入repo后，出现以下问题
$ repo File "C:\User\****\bin\repo", line 271 except OSError, e: ^ SyntaxError: invalid syntax 原因分析： 提示：这里填写问题的分析：
定位到相关文件的271行之后，查看该区域的提示代码为：
if not os.path.isdir(repodir): try: os.mkdir(repodir) except OSError, e: print &gt;&gt;sys.stderr, \ 'fatal: cannot make %s directory: %s' % ( repodir, e.strerror) # Don't faise CloneFailure; that would delete the # name. Instead exit immediately. # sys.exit(1) 解决方案： 怀疑是python版本问题，解决办法为更换电脑安装的python，将python3版本更换为python2即可解决问题，在安装python2时，记得配置python2的环境变量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a480c56c4336b4923eaac47d66fd659/" rel="bookmark">
			Git基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
Git基础操作 前言一、基础操作类型？二、基础操作示例1.git init（创建仓库）2.git clone（克隆）3.git config（配置）4.git add（添加至缓存区）5.git status（查看状态）6.git commit（提交文件） 前言 配置完成git之后，可以通过以下的git基本操作来实现对git上面的文件进行操作。
一、基础操作类型？ git基础操作包括：git init（创建仓库）、git clone（克隆）、git config（配置）、git add（添加至缓存区）、git status（查看状态）、git commit（提交文件）
二、基础操作示例 1.git init（创建仓库） Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。
代码如下（示例）：
git init newrepo 初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。
2.git clone（克隆） 我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。
克隆仓库的命令格式为：
git clone &lt;repo&gt; 如果我们需要将文件克隆到我们指定的目录，则可以使用以下命令格式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a480c56c4336b4923eaac47d66fd659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4edb5a63a1789cdda5e2e574402f6427/" rel="bookmark">
			解决vscode输入! 无法快捷生成骨架（新版vscode快速生成骨架的三种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 本次vscode更新后，无法再用 ! 快捷生成html骨架三种方法方法一方法二方法三 本次vscode更新后，无法再用 ! 快捷生成html骨架 三种方法 方法一 也是当前更新的新方式，输入html，选择 html:5，即可生成骨架 方法二 您当前使用的输入法可以添加快捷短语，设置你想用的快捷键字母快捷生成骨架，这里我使用的是搜狗输入法。 中文输入一个快捷字母，将鼠标移动到字母上时，即可添加短语 将复制好的骨架添加到自定义短语下面确定即可 中文输入快捷键字母，即可看见骨架短语直接生成骨架 方法三 输入英文 ! 后按下 Tab 键快捷生成骨架 进入vscode左下角设置里面搜索emmet:Tab 勾选启用该功能即可输入英文 ! 后按下Tab键快捷生成骨架 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48b78a2eb38a4845ee9d53f7e2e71936/" rel="bookmark">
			DCloud之Android原生工程配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、开发环境准备1.安装 Android Studio2.下载 App离线SDK 二、导入工程三、配置工程1.基础库配置2.build.gradle 中添加资源引用3.应用配置（1）获取 Android 证书签名SHA1（2）申请 Appkey（3）配置 Appkey（4）build.gradle 配置应用版本号（5）配置应用名称（6）配置应用启动页及 provider 节点（7）配置应用图标和启动界面 4.资源配置（1）创建 data 文件夹并拷贝资源（2）创建apps文件夹并拷贝资源（3）修改dcloud_control.xml 文件 5.其他配置（1）AndroidX 配置 四、运行 一、开发环境准备 1.安装 Android Studio 见 android studio安装使用（从Git上获取项目）。
2.下载 App离线SDK 下载地址：https://nativesupport.dcloud.net.cn/AppDocs/download/android
SDK 包目录结构如下：
二、导入工程 SDK 2.7.0 之后提供了 HBuilder-Integrate-AS 工程，可以直接导入 HBuilder-Integrate-AS 工程，直接运行 simpleDemo 项目即可。
三、配置工程 1.基础库配置 将 lib.5plus.base-release.aar、android-gif-drawable-release@1.2.23.aar、uniapp-v8-release.aar、oaid_sdk_1.0.25.aar 和 breakpad-build-release.aar 拷贝到 libs 目录下。
注意：HBuilder X 3.5.0 及以上版本新增库 breakpad-build-release.aar
2.build.gradle 中添加资源引用 注意：HBuilderX3.2.5 版本之后适配了 AndroidX。
AndroidX 版本需添加如下资源：
dependencies { implementation fileTree(dir: 'libs', include: ['*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48b78a2eb38a4845ee9d53f7e2e71936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdc296ee8d3f5626c2a42f7a8a49c02f/" rel="bookmark">
			c&#43;&#43;文件操作std::ifstream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++对文件操作相关：
ifs.is_open() 判断文件是否打开
ifs.get() 获取文件的一个字符
ifs.good() 判断文件是否结束
std::ifstream::in 以只读的方式打开
ios_base::in	以读取方式打开文件。 ios_base::out	以写入方式打开文件。 ios_base::out	以写入方式打开文件。 ios_base::binary	以二进制模式打开文件。 ios_base:: ate	打开文件的时候，定位到文件的末尾。 ios_base:: ate	打开文件的时候，定位到文件的末尾。 ios_base:: app	以追加方式打开文件，所有写文件的数据都是追加在文件末尾。 ios_base::trunc	打开文件时，但是文件之前的内容都会被清空。 #include &lt;iostream&gt; #include &lt;fstream&gt; // std::ifstream using namespace std; int main(int argc, char *argv[]) { std::ifstream ifs("a.cpp", std::ifstream::in);//only read if(ifs.is_open()) { std::cout&lt;&lt;"file is already open"&lt;&lt;endl; } char c = ifs.get(); while(ifs.good()) { std::cout&lt;&lt;c; c = ifs.get(); } ifs.close(); return 0; } ———————————————— 版权声明：本文为CSDN博主「勇zhe无wei」的原创文章，遵循CC 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdc296ee8d3f5626c2a42f7a8a49c02f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d0694272dc3d80dfb72b49c70464c9/" rel="bookmark">
			starUML教程-用例图/类图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用例图 也称为用户模型图 是从软件需求分析到最终实现的第一步 它是从客户的角度来描述系统功能
它包含3个基本组件：
1.参与者：与系统打交道的人或使用该系统的人
2.用例：表示该系统的某项完整功能
3.关系：定义用例之间的关系 ——泛化关系 扩展关系 包含关系
用例之间的关系——泛化关系：
表示同意业务目的（父用例）的不同技术实现（各个子用例）在UML中 用例泛化用一个三角箭头从子例指向父例 说白了就是面向对象继承里的父子类关系
用例之间的关系——包含关系：
一个用例可以包含其他用例具有的行为 并把它包含的用例行为作为资深行为的一部分 在UML中包含关系用虚线箭头加 “&lt;&lt;include&gt;&gt;” 箭头指向被包含的用例
用例之间的关系——扩展关系
如果在完成某个功能的时候偶尔会执行另一个功能 则用扩展关系表示 在UML中扩展关系用虚线箭头 加 "&lt;&lt;extend&gt;&gt;" 箭头指向被扩展的用例
类图 类图是面向对象系统建模中最常见的图 是定义其他图的基础
类图主要是用来显示系统中的类 接口 以及它们之间的关系
类图包含的主要元素有类 接口 和关系 其中关系有泛化关系 关联关系 依赖关系和实现关系 在类图中也可以包含注释和约束
类的表示法：
类是类图的主要组成 由3部分组成：类名 属性和方法 在UML中 类用矩形来表示 顶端部分存放类的名称 中间部分存放类的属性 属性的类型及值 底部部分存放类的方法 方法的参数和返回类型
在UML中可以根据实际情况有选择的隐藏属性部分或方法部分或两者都隐藏
类之间的关系——泛化关系：
在UML中 泛化关系用来表示类与类 接口与接口之间的继承关系 泛化关系有时候也称为 “is a kind of” 关系
在UML中泛化关系用一条实心空箭头 子类指向父类
类之间的关系——实现关系
在UML中 实现关系用来表示类与接口之间的实现关系
在UML中 实现关系用一条虚线空心箭头由子类指向父类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69d0694272dc3d80dfb72b49c70464c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/428425734d4ee34c849cf9d1f63ea98e/" rel="bookmark">
			MoviePy - 使用 Python 编辑视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MoviePy 是一个用于编辑视频的 Python 模块，可用于视频剪切、视频合并、标题插入、视频旋转变换等一些基本的视频操作。MoviePy 可以读写很多常见的视频格式，包含 GIF。
本文介绍如何使用 MoviePy。
欢迎点击链接跳转 Github Page 博客，享受更舒适的排版界面。
什么时候需要 MoviePy 在以下情况十分适合使用 MoviePy：
以一致的方式编辑和处理大批量视频；想在如 Django、Flask 等服务上合成视频或动图；希望将繁琐的任务自动化，例如标题插入、剪辑场景、制作片尾字幕等；从另一个 Python 库（如 Matplotlib、Mayavi）生成的图像创建动画。 以下用途中 MoviePy 不是最佳解决方案：
需要对视频做帧级的分析，例如人脸检测等，此时只需要使用 imageio、OpenCV 或 SimpleCV 等专门处理这些任务的库；仅需要转换视频格式，或将多张图片合成视频，可以直接使用 ffmpeg 更加快速。 MoviePy 的优缺点 MoviePy 在开发中考虑了以下目标：
简单易用。视频编辑操作基本能使用极少的代码实现，容易上手；灵活性高。能够在视频或音频的每一帧上做处理；多平台可用。MoviePy 使用 numpy、ffmpeg 实现，能在几乎所有平台和 Python 版本运行。 MoviePy 如何工作 MoviePy 使用软件 ffmpeg 读写视频和音频文件，借助 ImageMagick 合成文本和写入 GIF 文件。视频的处理过程使用到 Numpy、Scipy 等 Python 库。
样例代码 # 引入用于编辑视频的所有包 from moviepy.editor import * # 加载视频并选择 00:00:50 - 00:00:60 的片段 clip = VideoFileClip("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/428425734d4ee34c849cf9d1f63ea98e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc3771d2d1ba1778b26298bde1b89e7/" rel="bookmark">
			谷歌浏览器如何查看cookie存放信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息。下面以谷歌游览器查看cookie为例
谷歌浏览器查看cookie
1.打开谷歌游览器后，点击url最右边的三个点
2. 点击设置
3.点击安全加隐私设置
4.点击cookie及其他网站数据
5.点击查看 所有cookie和网站数据
6.下面展示的是所有的列表 7.如果比较多的话， 可以输入地址，搜索
8.点击右边的箭头可以看到cookie信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/201909a65afb1f906543c3e894a73b0a/" rel="bookmark">
			Unity编辑器扩展 UI控件篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前摇 ：认识编辑器扩展的必要性 由于各种各样的原因，无论是移动端亦或是主机/PC端，进几年的发行的游戏体量是越来越大。通常来说大体量的游戏开发需要一套很成熟完善的工作流，亦或说有很强的工业化的能力，像R星育碧这样的游戏厂商一定会有非常强大的工业化能力，才能有大表哥这样充斥大量细节或刺客信条这样充斥BUG，口误，是持续迭代的游戏作品
所谓工欲善其事必先利其器，要想提升游戏开发效率，就要有好用的游戏开发工具，说到最后就绕不开游戏开发引擎
游戏业界常说，自研的引擎不一定是最好的，但是最好的引擎一定是自研的，一定程度上说明了定制化引擎存在优势。 虽然像Unity与虚幻这样的商业引擎已经非常成熟好用，但其本身还是通用性的商品，很难在每一个方面都做到很好的适配性
而就Unity引擎，又相比于虚幻来说在整个工作流上表现还不够成熟。操作方式使用习惯上还是存在非常多的程序员思想，很多开发工具可视化程度还不够完善，对于程序员来说也许问题不大，但是对策划与美术来说就非常不友好
各种层面上来说，为提升编辑器的易操作性与保障项目开发独特性，而对编辑器进行扩展魔改，已经变成了游戏开发者所必须的技能之一
发生：Unity编辑器扩展之UI控件 乱七八糟的话说完后，回归正题。根据Unity文档的解释与案例，了解编辑器界面创建过程所需的结构与方法
与做游戏UI界面不同，引擎编辑器界面的搭建完全没有现成控件做可视化搭建，而只能依靠较底层的代码命令手撸完成。不过好在Unity提供了一套完整的纯代码界面编辑模式，并称其为“即时模式”GUI 系统。关于该系统的具体解释这里直接搬运官方文档的说明：
“即时模式”GUI 系统（也称为 IMGUI）是一个完全独立的功能系统，不同于 Unity 基于游戏对象的主 UI 系统。IMGUI 是一个代码驱动的 GUI 系统，主要用作程序员的工具 虽然该系统与主UI系统不太相同，但是也同根同源，学习起来难度并不大。通过下面的一个小Demo来演示IMGUI的具体使用方法与应该注意的一些点
继承EditorWindow创建编辑器窗口：
编辑器UI界面展示与逻辑刷新一般都是继承于EditorWindow这个类来实现的，对其生命周期结构的使用类似于通过编辑继承MonoBehavior的脚本代码完成游戏生命周期逻辑的实现。两者有着相似的监听事件，一样的周期性刷新方法，所以可以无学习的成功的上手使用
在Unity中创建并继承于EditorWindow类编辑器脚本并命名为EditorDemo ，然后使用类中的GetWindow方法创建CreateWindow静态方法（注意一定要是静态），通过该静态方法实现编辑器窗口界面的初始化，具体的代码细节如下：
public class EditorDemo : EditorWindow { [MenuItem("EditorDemo/Test &amp;1")] public static EditorDemo CreateWindow() { EditorDemo window = GetWindow&lt;EditorDemo&gt;("测试编辑器"); window.autoRepaintOnSceneChange = true; window.Show(); return window; } } 在上面的代码中，会在初始化静态方法上添加MenuItem命令用以实现在引擎内的上部导航栏中增加一个自定义编辑器的开启页签
关于MenuItem：
MenuItem 属性用于向主菜单和检视面板上下文菜单添加菜单项，使用特定格式可以实现一些额外效果，如上面案例中使用反斜杠符号可以创建多个层级的菜单，而“&amp;”符号则可以为该编辑器界面添加开启快捷键（通常与Alt形成组合键），如图所示： 在对编辑器界面完成初始化的工作后，后面的界面细节需要对EditorWindow类做一些了解。查阅文档来熟悉以下该类提供的一些消息函数。了解他们分别用来实现不同状态下的哪些编辑器功能：
在上面的消息，对编辑器扩展UI方面最需要关注的OnGUI函数，通常来说，界面元素的创建通常都需要写入到改方法内。前面有说到即时模式GUI创建编辑器UI控件无法通过可视化的操作工具来完成，只能由Unity提供的相关API来做，过程类似于不使用游戏开发引擎，直接基于相应编程语言的游戏开发，常用的控件创建类有下面几个：
GUI：是UnityEngine下的类，其方法可在Runtime状态下调用执行GUILayout：GUI的可自动排版版本，无需Rect布局定位EditorGUI：是UnityEditor下的编辑器类EditorGUILayout： EditorGUI的可自动排版版本，无需Rect布局定位 通过四个类的命名也很容易的看出他们之间的区别与使用区间。通常来说，GUI与GUILayout是使用最广的，编辑器状态与RunTime下都可用。独立的编辑窗口通常GUI与EditorGUI两个类可以混合使用，而在运行状态下使用就只能使用GUI或GUIlayerout
以使用场景较多的GUIlayout为案例，可以从文档介绍中看到Unity引擎提供了相当多的创建控件的接口，熟悉使用这些接口，完全可以利用自己游戏界面的开发界面方便的开发出所需的编辑器
通过一个简单的案例介绍这些API的使用方法。尝试在场景中选中某一个物体，并通过编辑器来控制其整体缩放与颜色改变：
首先关于选择对象的获取，Unity提供了获取编辑器状态下的开发者所选择的对象编辑器方法Selection.activeGameObject，而在前面的关于EditorWindow的消息中存在OnSelectionChange函数，该函数会在选择对象改变时被调用。通过使用这两个函数与接口可以高效的得到实时选择的物体：
public GameObject selectObj; private void OnSelectionChange() { selectObj = Selection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/201909a65afb1f906543c3e894a73b0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2deaa850aed53a957c354ece7159aa/" rel="bookmark">
			关于优雅去重的一些感想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		也就不赘述有的没的，看代码↓
1、通过reduce()方法进行去重
this.pageDataList = this.pageDataList.reduce((tempArr, item) =&gt; { if ( tempArr.findIndex( (ele) =&gt; ele.businessSettleManageId === item.businessSettleManageId ) === -1 ) { tempArr.push(item); } return tempArr; }, []); 日常更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c8b766dc3307f9714f26a693dfc4fc/" rel="bookmark">
			知识单元三 面向对象-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 设 x、 y为已定义的类名，下列声明x类的对象x1的语句中正确的是( )。 [单选题] *
static x x1;
public x x1=new x(int 123);
y x1;
x x1=new x( );(正确答案)
2. 类的设计要求它的某个成员变量不能被外部类直接访问。应该使用下面的哪些修饰符获得需要的访问控制?
[单选题] *
public
不加修饰符
protected
private(正确答案)
3. 为AB类的一个无形式参数无返回值的方法method书写方法头，使得使用类名AB作为前缀就可以调用它，该方法头的形式为()
[单选题] *
static void method( )(正确答案)
public void method( )
final void method( )
abstract void method( )
4. 关于类和对象的叙述正确的是：（ ）
[单选题] *
Java的类分为两大部分：系统定义的类和用户自定义的类(正确答案)
类的静态属性和全局变量的概念完全一样，只是表达形式不同
类的成员至少有一个属性和一个方法
类是对象的实例化
5. 关于对象成员占用内存的说法哪个正确？　（　）
[单选题] *
同一个类的对象共用同一段内存
同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间(正确答案)
对象的方法不占用内存
以上都不对 属性必须是简单变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94c8b766dc3307f9714f26a693dfc4fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7198c1652ea8e9e15e0c61426ea267c/" rel="bookmark">
			存储系统Cache（知识点&#43;例题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储系统 前言一、存储系统的结构层次与分类1.Cache存储系统(Cache-主存存储层次)2.虚拟存储系统(主存-辅存存储层次)3.存储器分类4.练习 二、高速缓冲存储器(Cache)1.局部性原理2.Cache的基本结构及工作原理3.Cache地址监听4.替换算法 三、地址映像1.直接映像2.全相联映像3.组相联映像4.Cache映像总结 四、虚拟存储器1.段式管理2.页式管理（类比Cache地址映像）3.段页式管理4.存储管理部件MMU 五、巩固练习总结 前言 本章内容较长但干货满满，如果耐心看完，定会有所收获。
一、存储系统的结构层次与分类 存储器三个主要特性的关系
存储系统：计算机中由存放程序和数据的各种存储设备（Cache、内存、硬盘等）、控制部件（SATA控
制器、内存控制器）以及管理信息调度的硬件设备（MMU，地址转换）和算法（块或段页替换算法）
所组成的系统。
概念结构：
1.Cache存储系统(Cache-主存存储层次) 注意：Cache存储的内容是主存部分内容的副本
Cache-主存存储层次对系统程序员和应用程序员都是透明的，在这里的透明指的是看不见，不公开的意思。
2.虚拟存储系统(主存-辅存存储层次) 虚拟存储系统(主存-辅存存储层次)对系统程序员是不透明的，即系统程序员可以对此层次进行修改。
3.存储器分类 作用(层次)
主存储器(主存、内存):使用DRAM和ROM
高速缓冲存储器(Cache):使用SRAM
辅助存储器(辅存、外存)存储介质
磁芯存储器
磁表面存储器:磁盘、磁带
半导体存储器
光存储器存取方式
（1）随机存取:RAM(DRAM、SRAM),ROM
任何一个存储所需时间都相同，与存储单元所在的物理位置无关
（2）串行访问:顺序存取(磁带)、直接存取(磁盘)
读写某个存储单元所需时间与存储单元的物理位置有关
（3）按内容访问：相联存储器（CAM）
可以按照内容检索到存储位置进行读写，"快表"就是一种相联存储器信息可保存性
断电后存储信息是否消失:易失性(RAM)、非易失性（磁盘，光盘）
读出是否破坏信息:破坏性读出(DRAM)、非破坏性读出（SRAM,磁盘，光盘） 4.练习 解析：Cache中存储的是主存部分内容的副本，实际上该存储系统的容量就是主存的容量为12MB，故选B。
二、高速缓冲存储器(Cache) 1.局部性原理 ➢ 时间局部性
在最近的未来要用到的信息,很可能是现在正在使用的信息。
➢ 空间局部性
在最近的未来要用到的信息(指令和数据),很可能与现在正在使用的信息在存储空间上是邻近的。
2.Cache的基本结构及工作原理 cache块/行包括有效位（占1位）、主存标记位和数据位，当采用回写策略时还要考虑标志位（占1位）。
➢ 地址映像：为把信息存放与Cache，应用某种函数把主存地址映像到Cache，称为地址映像。（直接映像、全相联映像、组相联映像）
➢ 命中率：CPU欲访问的信息已在Cache中的比率。Cache的容量和块的大小影响命中率。
➢ 替换策略：从主存读出新的字块调入Cache时，如遇到Cache中相应位置已被占用，则需要替换掉旧的字块，此时采用的替换规则为替换策略。（随机算法、先进先出算法、近期最少使用算法）
例题：
读操作：
写操作：
➢原则：保持Cache与主存内容一致性问题
➢命中的两种写方式：
• 标志交换方式flag-swap(写回法/回写法write-back)：只把数据写入Cache，当Cache数据被替换出去时，才写回内存。需要标志位。写操作时间就是访问 Cache 的时间。
• 通过式写write-throgh(写通法)：数据既写入Cache又写入内存。写操作时间就是访问主存的时间。
➢ 未命中的两种写方式：只对主存写；加载该块到Cache，再更新Cache
◆ 需要增加一位标记有效位（刚加电后所有标记位都为0）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7198c1652ea8e9e15e0c61426ea267c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148b0fd4f0c7b7e3ffc36e69209b8d91/" rel="bookmark">
			Python实现股票数据接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源下载地址：https://download.csdn.net/download/sheziqiong/85984124
资源下载地址：https://download.csdn.net/download/sheziqiong/85984124
这篇文章主要介绍如何使用 Python 股票数据和实现数据接口。
1.定时抓取和解析数据
2.存储数据到 MongoDB
3.缓存数据到 Redis
4.配置 Nginx 和数据接口
1.定时抓和解析数据 按照链接的格式，我们拼接好股票代码、年份和季度：
url = "http://quotes.money.163.com/trade/lsjysj_" + key + ".html?year=" + year + "&amp;season=" + season 拼接好链接后，使用 requests 库获取页面的内容：
requests.get(url) self.parse_pager(content.content, item["code"]) 考虑到网络请求可能会失败，我们在请求失败时设置多次重新请求(最多 8 次)，如果多次请求后仍然失败，则将请求的相关内容存储到 error_logs 中：
# 请求失败后重新请求(最多8次) max_try = 8 for tries in range(max_try): try: content = requests.get(url) self.parse_pager(content.content, item["code"]) break except Exception: if tries &lt; (max_try - 1): sleep(2) continue else: add_error_logs("crawl_error", "501", key) 获取到页面内容后，我们先来分析页面结构（图 1），我们需要的数据大概是以这样的格式存在的：tr 标签表示股票某一天的行情，tr 标签下的 td 标签表示当前行情的详细数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148b0fd4f0c7b7e3ffc36e69209b8d91/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/70/">«</a>
	<span class="pagination__item pagination__item--current">71/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/72/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>