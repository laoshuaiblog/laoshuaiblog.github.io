<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c12cdc3e2618b3bedf1b5dff2ea3e52/" rel="bookmark">
			Python3.6 爬取网页图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标URL = https://tieba.baidu.com/p/5316245951
查看网页的源代码：
可以发现，该贴吧的图片链接都包含在&lt;image class="BDE_Image"&gt;的标签中的，例如：
&lt;img class="BDE_Image" src="https://imgsa.baidu.com/forum/w%3D580/sign=10191d3660600c33f079dec02a4d5134/ee1b9d16fdfaaf5188a45f9d875494eef01f7a49.jpg" size="219669" changedsize="true" width="560" height="320" size="219669"&gt;
因此写出以下正则表达式：
r'&lt;img class="BDE_Image".*?src="[^"]*\.jpg".*?&gt;'
测试如下代码：
import urllib.request import re response = urllib.request.urlopen("http://tieba.baidu.com/p/3823765471") html = response.read().decode('utf-8') p = r'&lt;img class="BDE_Image".*?src="[^"]*\.jpg".*?&gt;' imglist = re.findall(p,html) for each in imglist: print(each) 输出：
&lt;img class="BDE_Image" src="https://imgsa.baidu.com/forum/w%3D580/sign=f9cf09409c25bc312b5d01906ede8de7/8f0ede0735fae6cdafb377ef0ab30f2443a70fda.jpg" pic_ext="jpeg" changedsize="true" width="560" height="497"&gt; &lt;img class="BDE_Image" src="https://imgsa.baidu.com/forum/w%3D580/sign=35c4709bb9315c6043956be7bdb0cbe6/cc223ffae6cd7b894b6be60d0a2442a7d8330eda.jpg" pic_ext="jpeg" changedsize="true" width="560" height="497"&gt;
...
为下载图片，需要知道图片的准确地址，如何从上面的字符串中取出图片的地址呢？
解决方法如下：
p = r'&lt;img class="BDE_Image".*?src="([^"]*\.jpg)".*?&gt;' 其实就是将图片的地址用小括号分组。
最后整理代码，得到最后完整的程序：
import urllib.request import re def open_url(url): req = urllib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c12cdc3e2618b3bedf1b5dff2ea3e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5762130efab73324920174b7d08164e2/" rel="bookmark">
			单元测试——持久层单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 主要依赖：
&lt;dependency&gt;
&lt;groupId&gt;junit&lt;/groupId&gt;
&lt;artifactId&gt;junit&lt;/artifactId&gt;
&lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-test-autoconfigure&lt;/artifactId&gt;
&lt;version&gt;1.4.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.h2database&lt;/groupId&gt;
&lt;artifactId&gt;h2&lt;/artifactId&gt;
&lt;scope&gt;test&lt;/scope&gt;
&lt;version&gt;1.4.194&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.assertj&lt;/groupId&gt;
&lt;artifactId&gt;assertj-core&lt;/artifactId&gt;
&lt;version&gt;2.5.0&lt;/version&gt;
&lt;/dependency&gt;
在spring-boot项目中只需要如下依赖：
&lt;dependency&gt;
&lt;groupId&gt;com.h2database&lt;/groupId&gt;
&lt;artifactId&gt;h2&lt;/artifactId&gt;
&lt;scope&gt;test&lt;/scope&gt;
&lt;version&gt;1.4.194&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
&lt;/dependency&gt;
主要代码：
import com.demo.constants.types.DeleteStatus; import com.demo.domain.entity.DemoEntity; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.orm.jpa.AutoConfigureTestDatabase; import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest; import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager; import org.springframework.test.context.junit4.SpringRunner; import java.util.UUID; import static org.springframework.boot.autoconfigure.jdbc.EmbeddedDatabaseConnection.H2; /** * Author: liyang * Date: 03/09/2017 10:59 PM * Version: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5762130efab73324920174b7d08164e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a30e5ec626447e45eba447cb820f47/" rel="bookmark">
			Matlab的size 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		x=[1,4,7;2,5,6]是一个2*3的矩阵，则：
d = size(X); %返回矩阵的行数和列数，保存在d中 [m,n] = size(X)%返回矩阵的行数和列数，分别保存在m和n中 m = size(X,dim);%返回矩阵的行数或列数，dim=1返回行数，dim=2返回列数
MATLAB自带的例子
% If
% X = rand(2,3,4);
% then
% d = size(X) returns d = [2 3 4]
% [m1,m2,m3,m4] = size(X) returns m1 = 2, m2 = 3, m3 = 4, m4 = 1
% [m,n] = size(X) returns m = 2, n = 12
% m2 = size(X,2) returns m2 = 3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2242a9178cfd459e6de46bdfea3fa9a/" rel="bookmark">
			【python Excel】如何使用python将大量数据导出到Excel中的小技巧之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何使用python将大量数据导出到Excel中的小技巧 （1） 问题描述：为了更好地展示数据，Excel格式的数据文件往往比文本文件更具有优势，但是具体到python中，该如何导出数据到Excel呢？如果碰到需要导出大量数据又该如何操作呢？本文主要解决以上两个问题。 （2）具体步骤如下： 1.第一步，安装openpyxl, 使用pip install openpyxl即可，但是在windows下安装的是2.2.6版本，但是centos自动安装的是4.1版本,（多谢海哥的提醒）。 写的代码在windows下运行没问题，但centos上却报错了，说是ew=ExcelWriter(workbook=wb)少提供一个参数，于是果断在 237服务器上我已安装2.2.6版本的，问题解决。 pip install openpyxl==2.2.6 2.第二步，哈哈，没有啦，废话不说了，直接上代码，ps，代码中包含xlwt和openpyxl的两个实现版本。 （3）扩展阅读：通过查阅资料，发现网上众说纷纭，总结起来有如下几点： python Excel相关的操作的module lib有两组，一组是xlrd、xlwt、xlutils，另一组是openpyxl,但是前一组（xlrd，xlwt）比较老，只能处理由Excel 97-2003 或者Excel 97 以前版本生成的xls格式的excel文件，xlwt甚至不支持07版以后的excel ，这个格式excel文件一般来说，最大只能支持256列或者65536行的excel文件。因此面对需要导出大量数据到excel的情况，你将有如下三种选择，1）换一种存储格式，如保存为CSV文件 2)使用openpyxl—，因为它支持对Excel 2007+ xlsx/xlsm format的处理 3) win32 COM (Windows only) 当然，我们要直面困难了，为了更好地展示数据给产品和用户，我们依然选择的第二种。 ps,非常lucky，一番搜索后我找到了openpyxl，支持07+的excel，一直有人在维护，文档清晰易读，参照Tutorial和API文档很快就能上手，就是它了~ 【20180713 add ps，以下代码在 openpyxl 的__version__ = '2.2.6' 和 openpyxl 的__version__ = '2.4.8' 测试通过 ，考虑到openpyxl的最新版本是__version__ = '2.5.4' , 如需最新版本python操作excel的例子，请参照另一篇博客，地址：点击打开链接】 (4)闲话少说，直接上代码，敬请参考 # coding:utf-8 ''' # 希望对大家有帮助哈，请多提问题 create by yaoyz date: 2017/01/24 ''' import xlrd import xlwt # workbook相关 from openpyxl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2242a9178cfd459e6de46bdfea3fa9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9908121f0a21d5bed1843938dd79229c/" rel="bookmark">
			[经验] I2C和SPI通信方式的讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I2C和SPI是两种不同的通信协议。 一。 IIC 简介 它是由数据线 SDA 和时钟 SCL 构成的串行总线， 可发送和接收数据。在 CPU 与被控 IC 之间、IC 与 IC 之间进行双向传送，高速 IIC 总线一般可达 400kbps 以上。用I2C通信的芯片最常用的就是EEPROM芯片，如Atmel的AT24CXX系列，此外，还有一些其它功能的芯片。 (这是EEPROM芯片的接法) （对应的单片机引脚） I2C 总线在传送数据过程中共有三种类型信号， 它们分别是：开始信号、结束信号和应答信号。 开始信号：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。 结束信号：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。 应答信号： 接收数据的 IC 在接收到 8bit 数据后， 向发送数据的 IC 发出特定的低电平脉冲，表示已收到数据。CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号，CPU 接收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为受控单元出现故障。 二.SPI SPI通常有SCK时钟，STB片选，DATA数据信号三个信号。SPI总线真正实现了全双工数据传输，SPI 有3线跟4线两种，4线的话，就是多了一条叫SDC的线，用来告知从设备现在传输的是数据还是指令。这个接口较快，可以传输较连续的数据。SPI要想连接多个从设备，就需要给每个从设备配备一根片选信号。如果要可以实现全双工，也是需要多加一根数据线（MOSI MISO）。SPI通信芯片的引脚名称不一定都是这几个名称，可能还有会别的名称，但是意思是一样的，例如MOSI引脚的意思是“主机输出从机输入”，某个SPI接口的芯片就有可能会写成SDI，因为这个SPI器件是作为从机的，所以它的SDI的意思就是“从机数据输入引脚”。
SPI通信过程为：把CS引脚拉低，然后SCK输出时钟，然后就可以在MOSI引脚上输出数据，同时可以在MISO上获得数据了。
(这是一个SPI FLASH芯片，DO是MISO，DI是MOSI，CLK是SCK，功能一样，叫法不一样而已)
(单片机接法)
下面主要总结一下2种总线的异同点：
1 iic总线不是全双工，2根线SCL SDA。spi总线实现全双工，4根线SCK CS MOSI MISO
2 iic总线是多主机总线，通过SDA上的地址信息来锁定从设备。spi总线只有一个主设备，主设备通过CS片选来确定从设备
3 iic总线传输速度在100kbps-4Mbps。spi总线传输速度更快，可以达到30MHZ以上。
4 iic总线空闲状态下SDA SCL都是高电平。spi总线空闲状态MOSI MISO也都是 SCK是有CPOL决定的
5 iic总线scl高电平时sda下降沿标志传输开始，上升沿标志传输结束。spi总线cs拉低标志传输开始，cs拉高标志传输结束
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9908121f0a21d5bed1843938dd79229c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7c350798150dd95b04de942b347c2a/" rel="bookmark">
			Python3.6爬取网站图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近几天在学习python，写了个简单的爬虫程序：
成功运行代码的前提是安装了Python需要的第三方库，以下是代码：
# -*- coding:utf8 -*- import os import re import requests as rq import urllib from bs4 import BeautifulSoup #下载图片 def getHtml2(): html = rq.get(urls).text soup = BeautifulSoup(html,"html.parser")#文档对象 for k in soup.find_all('a',class_="tit"):#获取class为tit的a标签 print(k) addr = re.compile('&lt;a class="tit" href="(.*?)"') url = re.findall(addr,repr(k))[0] #创建路径文件夹名称 cate_name = re.findall('&lt;a .*?&gt;(.*?)&lt;/a&gt;',repr(k),re.S|re.M)[0] path = 'C:/data/images\\%s' % cate_name # 创建文件目录 os.mkdir(path) # 切换到该目录 os.chdir(path) #print(url) for x in range(1,20): url1 = url.split(".html")[0]+"_"+str(x)+".html" html1 = rq.get(url1).text soup1 = BeautifulSoup(html1,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a7c350798150dd95b04de942b347c2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03db02b0793601d6c9ecca1fb513e501/" rel="bookmark">
			用python爬github上星级排名前列的项目报错AttributeError: &#39;NoneType&#39; object has no attribute &#39;decode&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码： import requests import pygal from pygal.style import LightenStyle as ls,LightColorizedStyle as lcs #执行api调用并存储相应 url = 'https://api.github.com/search/repositories?q=language:python&amp;sort=stars' r = requests.get(url) print(r.status_code) #响应存储在变量中 response_dic = r.json() #print(response_dic.keys()) print("total:"+str(response_dic["total_count"])) #respon_dic :所有仓库，是一个列表，有很多字典 respon_dics = response_dic["items"] print("dics:"+str(len(respon_dics))) """找出第一个字典 respon_dic = respon_dics[0] print("\nkeys:"+str(len(respon_dic))) for key in sorted(respon_dic.keys()): print(key)""" names,plot_dicts = [],[] for respon_dic in respon_dics: names.append(respon_dic['name']) plot_dict = { 'value':respon_dic['stargazers_count'], 'label':respon_dic['description'] } plot_dicts.append(plot_dict) #plot_dicts.append(respon_dic['stargazers_count']) #可视化 my_style= ls('#333366',base_style = lcs) my_config = pygal.Config() my_config.x_label_rotation = 45 my_config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03db02b0793601d6c9ecca1fb513e501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ca5049ea580a0d5e6144a653b82013/" rel="bookmark">
			【Python3.6爬虫学习记录】（一）爬取简单的静态网页图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：之前跟着廖雪峰的教程简单的学习了最基本的python语法，还没学完，小学期又认真的学习了java，暑假闲来无事，着手学习python爬虫。开学就大二了，然而还是各种小白(文中会提到很多小白，痴问题)。
千里之行始于足下，百尺高楼起于垒土。
学习计划：跟着网上的教程敲代码，再自己写一个，了解个中奥妙，一个知识点一个知识点的突破，边学边查。 学习Python爬虫的精华摘要
爬虫代码及注释：
#本部分内容-根据指定正则表达式（即图片的网址）匹配 # -以及图片文件保存 import requests import re url = 'http://www.nipic.com/photo/jingguan/ziran/index.html' #获得网页源码 data = requests.get(url).text #图片正则表达式 regex = r'&lt;img src="(.*?.jpg)"' #re是一个列表 pa = re.compile(regex) #创建一个pa模板，使其符合匹配的网址 ma = re.findall(pa,data) #findall 方法找到data中所有的符合pa的对象，添加到re中并返回 #图片的名字 i=0 #要在控制台打印提示，了解进程 print('Start downloading') #将ma中图片网址依次提取出来 for image in ma: i+=1 image = requests.get(image).content print(str(i)+'.jpg is downloading') # \ 要用转义符号 \\表示，要注意原图片的格式 with open('D:\Python Study\crawl\crawl pictures\\'+str(i)+'.jpg','wb') as f: #注意打开的是就jpg文件 f.write(image) print('Finish downloading') 相关问题： ①HTML相关知识 之前还准备自学来着，偶然间就发现了谷歌的人性化 真的很好用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11ca5049ea580a0d5e6144a653b82013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc8c69a3ed9cd39df0b274a6d9f0f42/" rel="bookmark">
			python3常见编码转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/crylearner/article/details/38521685 python常用的十进制、16进制、字符串、字节串之间的转换，进行协议解析时，总是会遇到各种各样的数据转换的问题，从二进制到十进制，从字节串到整数等等。 一、整数之间的进制转换: 10进制转16进制: hex(16) ==&gt; 0x10 16进制转10进制: int('0x10', 16) ==&gt; 16 类似的还有oct()， bin() ------------------- 二、字符串转整数: 10进制字符串: int('10') ==&gt; 10 16进制字符串: int('10', 16) ==&gt; 16 16进制字符串: int('0x10', 16) ==&gt; 16 ------------------- 三、字节串转整数: 转义为short型整数: struct.unpack('&lt;hh', bytes(b'\x01\x00\x00\x00')) ==&gt; (1, 0) 转义为long型整数: struct.unpack('&lt;L', bytes(b'\x01\x00\x00\x00')) ==&gt; (1,) ------------------- 四、整数转字节串: 转为两个字节: struct.pack('&lt;HH', 1,2) ==&gt; b'\x01\x00\x02\x00' 转为四个字节: struct.pack('&lt;LL', 1,2) ==&gt; b'\x01\x00\x00\x00\x02\x00\x00\x00' ------------------- 五、字符串转字节串: 字符串编码为字节码: '12abc'.encode('ascii') ==&gt; b'12abc' 数字或字符数组: bytes([1,2, ord('1'),ord('2')]) ==&gt; b'\x01\x0212' 16进制字符串: bytes().fromhex('010210') ==&gt; b'\x01\x02\x10' 16进制字符串: bytes(map(ord, '\x01\x02\x31\x32')) ==&gt; b'\x01\x0212' 16进制数组: bytes([0x01,0x02,0x31,0x32]) ==&gt; b'\x01\x0212' ------------------- 六、字节串转字符串: 字节码解码为字符串: bytes(b'\x31\x32\x61\x62').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fc8c69a3ed9cd39df0b274a6d9f0f42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bdee51965c00ae1b110e1b67863e29b/" rel="bookmark">
			计算任意两个日期之间相隔的天数以及年数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算任意两个日期之间相隔的天数以及年数。 //&lt;思路&gt; //历法规定，四年一闰，四百年闰，例如2000年是闰年，2100年不闰年， //公历年份是整百数的，必须是400的倍数的才是闰年，不是400的倍数的就是平年 //计算两个日期之间的天数(C++) //定义变量year1, month1, day1, year2, month2, day2 //首先比较两个日期，将小的给date1 //再将date1进行加1，一直增加到date2的日期 //其中当天数大于GetLastDay时，月数加1，同理当月数大于12时，年加1 //再这过程中delta进行自增（++）——&gt; return delta； /* 问题: 给你两个日期(如"2017，8，18"和"2013，6，11"),求它们之间相差的天数 分析: 这是一年看似简单，实际上却有点复杂的小问题，首先你要考虑到月大月小的问题，其次你要考虑到闰年的问题 当然，你也要检测一下，给定的日期格式是否合法，对这个问题的解法，写出伪代码如下 */ #include &lt;Windows.h&gt; #include &lt;stdio.h&gt; struct tagDate { int year; int month; int day; }; //设置日期 void SetDate(int y, int m, int d, tagDate *date) { date-&gt;year = y; date-&gt;month = m; date-&gt;day = d; } //是否闰年 int IsLeapYear(int year) { return ((year%4==0) &amp;&amp; (year%100!=0)||year%400==0); } //得到date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bdee51965c00ae1b110e1b67863e29b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d6c0cc05d6bb5f180e6fe728253f8b4/" rel="bookmark">
			Statement、PreparedStatement、CallableStatement
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章实在上一篇文章的基础上进行增删改查操作的。不懂得可以去看看第一篇。 http://blog.csdn.net/qq_36748278/article/details/76861334
父Statement————————&gt;子PreparedStatement 父PreparedStatement————&gt;子CallableStatement 这三个都是接口。用于和数据库连接是使用的。
Statement接口 1、用于执行静态 SQL 语句并返回它所生成结果的对象。 2、在默认情况下，同一时间每个 Statement 对象只能打开一个 ResultSet 对象。 3、因此，如果读取一个 ResultSet 对象与读取另一个交叉，则这两个对象必须是由不同的 Statement 对象生成的。
ResultSet executeQuery(String sql) ：执行给定的 SQL 语句，该语句返回单个 ResultSet 对象。 通常用于查找。 int executeUpdate(String sql) ： 执行给定 SQL 语句，该语句可能为 INSERT、UPDATE 或 DELETE 语句，或者不返回任何内容的 SQL 语句。 PreparedStatement接口：表示预编译的 SQL 语句的对象。 下标是指？所在第几个位置，下标就是几。下标从1开始。根据参数类型选个对应的方法，比如int类型的值就选择setInt()方法 1、 void setString(int parameterIndex, String x) ：将指定参数设置为x(第一个参数是下标从1开始，x 是字符串类型) 2、 void setFloat(int parameterIndex, float x) ：将指定参数设置为x(第一个参数是下标从1开始，x 是float类型) 3、void setInt(int parameterIndex, int x) ：将指定参数设置为x(第一个参数是下标从1开始，x 是int类型)
举个例子，在Student上进行更新操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d6c0cc05d6bb5f180e6fe728253f8b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f50673fabe63640e1e6832ac12359603/" rel="bookmark">
			R语言读CSV、txt文件方式以及read.table read.csv 和readr（大数据读取包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先准备测试数据*(mtcars)
分别为CSV. TXT
read.table 默认形式读取CSV（×）与TXT(效果理想)
[plain] view plain copy &lt;span style="font-size:14px;"&gt;① &gt; test&lt;-read.table("C:/Users/admin/Desktop/test.txt",header = F) Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : line 1 did not have 12 elements &gt; test&lt;-read.table("C:/Users/admin/Desktop/test.txt") &gt; str(test) 'data.frame': 32 obs. of 11 variables: $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... $ cyl : int 6 6 4 6 8 6 8 4 4 6 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f50673fabe63640e1e6832ac12359603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc135a0b2e26538ac79e0d89624db94/" rel="bookmark">
			python文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、python中对文件、文件夹操作时经常用到的os模块和shutil模块常用方法。 1.得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd() 2.返回指定目录下的所有文件和目录名:os.listdir() 3.函数用来删除一个文件:os.remove() 4.删除多个目录：os.removedirs(r”c：\python”) 5.检验给出的路径是否是一个文件：os.path.isfile() 6.检验给出的路径是否是一个目录：os.path.isdir() 7.判断是否是绝对路径：os.path.isabs() 8.检验给出的路径是否真地存:os.path.exists() 9.返回一个路径的目录名和文件名:os.path.split() 例子： 复制代码 代码如下: os.path.split(‘/home/swaroop/byte/code/poem.txt’) 结果：(‘/home/swaroop/byte/code’, ‘poem.txt’)
10.分离扩展名：os.path.splitext() 11.获取路径名：os.path.dirname() 12.获取文件名：os.path.basename() 13.运行shell命令: os.system() 14.读取和设置环境变量:os.getenv() 与os.putenv() 15.给出当前平台使用的行终止符:os.linesep Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’ 16.指示你正在使用的平台：os.name 对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’ 17.重命名：os.rename(old， new) 18.创建多级目录：os.makedirs(r”c：\python\test”) 19.创建单个目录：os.mkdir(“test”) 20.获取文件属性：os.stat(file) 21.修改文件权限与时间戳：os.chmod(file) 22.终止当前进程：os.exit() 23.获取文件大小：os.path.getsize(filename) 二、文件操作方法大全 1.os.mknod(“test.txt”) 创建空文件 2.fp = open(“test.txt”,w) 直接打开一个文件，如果文件不存在则创建文件 3.关于open 模式： 复制代码 代码如下: w：以写方式打开， a：以追加模式打开 (从 EOF 开始, 必要时创建新文件) r+：以读写模式打开 w+：以读写模式打开 (参见 w ) a+：以读写模式打开 (参见 a ) rb：以二进制读模式打开 wb：以二进制写模式打开 (参见 w ) ab：以二进制追加模式打开 (参见 a ) rb+：以二进制读写模式打开 (参见 r+ ) wb+：以二进制读写模式打开 (参见 w+ ) ab+：以二进制读写模式打开 (参见 a+ )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc135a0b2e26538ac79e0d89624db94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e7e673ee66153b585e304b82639c8f/" rel="bookmark">
			AndroidStudio安装配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载请注明出处：http://blog.csdn.net/m0_37240709/article/details/76069176
一、简介 Android Studio作为Google推荐的安卓开发第一利器，为绝大多数安卓开发人员钟爱。那要怎样对AS进行安装和配置呢？下面小依手把手带你走进AS的大门。
先来介绍两个网址，第一个是AS中文社区官网：http://www.android-studio.org/，我们可以在这里下载安装版的AS，并且这里面也有很多教程之类的，可以参看。第二网址，是今天要用到的，AndroidDevTools：http://www.androiddevtools.cn/index.html，这上面收集整理了好多实用的工具、开发教程。
二、下载AndroidStudio和SDK 根据自己的操作系统，选择AS和SDK的版本。
三、解压下载的安装包到指定目录中 四、找到AS的bin目录下 我们看到这下面有这样的一些文件，其中我圈出了两个文件，32位点击studio.exe，64位操作系统点击studio64.exe。
五、启动配置AS 第一次安装时，没有以往配置的数据，所以选择第二个选项。如果以往安装过AS，有过他的配置，那么可以选择第一个，导入配置。
接下来，他会进行查找sdk安装情况，由于还没有sdk，会出现线面的提示框。点击cancel就好。
接下里，会提示选择界面主题风格。我选择了炫酷的黑色主题。
选择好后，最终finish，会进入这个窗口中。窗口左边回显示曾经建立的项目，当然第一次进来是空的。右侧有6个选项，下方有两个菜单。
第一个是创建一个新的Android项目，第二个是打开一个已有的项目，第三个从版本控制中导入项目，第四个是调试APK，第五个是导入非AS项目，第六个导入官方样例。
Configure中有AS的设置。
六、新建一个项目 选择第一个选项，弹出如下窗口。
第一个是项目名，第二个是公司域名，遵循DNS反转原则，第三个是项目保存的路径，创建一个自己的项目工作空间，设置好后点击next
出现如下窗口，第一个是选择项目最低支持的系统版本，选择一个，其余默认就好。
点击next，出现选择activity界面的窗口，选择Empty Activity就好，是一个空白界面
接下来出现的窗口是设置activity和layout的名称
点击finish，开始创建项目，第一次可能时间会久一些，耐心等待。
七、设置sdk、jdk、ndk 点击file --&gt; other settings --&gt; default project structure
弹出如下窗口，其中包含三个输入框，第一个是sdk的输入框，输入内容为下载的sdk那个文件夹的目录E:\Android\android-sdk-windows，第二个是jdk的路径，其中默认有AS自带的jre的路径，去掉勾选，可自行选择。第三个是NDK的路径，是进行JNI开发时用得，目前可以不配置。
八、SDK Manager下载SDK 在未进入项目的初始界面，选择菜单configure中sdk manager选项。如果已经进入项目，可以点击file --&gt;settings弹出窗口中选择Apperance.. --&gt; System settings --&gt;android SDK。
弹出下图所示的窗口，我们可以看到，在sdk platforms板块下，有当前所有版本的sdk的列表，勾选右下角show package选框，能看到sdk中详细构造。将常用的sdk版本勾线，点击apply便可以下载。
在sdk tools板块下，有关于英文文档的下载，可以用来参看。勾选Documentation for Android SDK，点击apply。文档中有引用Google的一些网址，是打不开的，所以建议使用火狐浏览器的脱机模式来查看这些资料。
九、配置SVN 首先要在电脑上安装小乌龟，安装小乌龟时要注意一点，就是安装command line 功能。要将这个功能选上。
小乌龟安装参看：http://www.cnblogs.com/songmeng/p/4389446.html
关联svn，在configure中选setting，而后出现的窗口中按下图选择（以打开项目的界面可以在file --&gt;settings中找到）。在version controller --&gt;subversion中，General板块中，讲第一个路径配置成你的svn路径C:\Program Files\TortoiseSVN\bin\svn.exe。配置后OK即可。
而后，点击第三个选项，选择其中的subversion
弹出窗口后点击“+”，在出现的窗口中输入你的SVN路径
选中你要检出的项目，点击CheckOut。
这样SVN就配置完成。项目也可以检出了。
十、安装配置结束，enjoy yourself 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/347fa8c1f8738ab00b02a2c5974401b7/" rel="bookmark">
			Kotlin-47.Kotlin调用JavaScript(Call JavaScript from Kotlin)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档: http://kotlinlang.org/docs/reference/js-interop.html
1.Kotlin调用JavaScript(Calling JavaScript from Kotlin) Kotlin被设计能够与Java平台轻松互操作,kotlin可将Java类转为Kotlin类,Java也将Kotlin类转为Java类! 但JavaScript是一种动态类型语言,意味着不会在编译期检查类型,可以在Kotlin中与JavaScript自由交流, 但如果想用Kotlin类型系统全部功能,需要在JavaScript库创建Kotlin头文件! 2.内联JavaScript(Inline JavaScript) 可用js("JavaScript代码")函数将JavaScript代码嵌入到Kotlin代码中: fun jsTypeOf(o: Any): String { return js("typeof o") } js("...")函数参数必须是字符串常量,因此以下代码错误: fun jsTypeOf(o: Any): String { return js(getTypeof() + " o") // 此处报错 } fun getTypeof() = "typeof" 3.external修饰符(external modifier) 用external修饰符来标记,通知Kotlin某个声明是用纯JavaScript编写! 编译器会认为被修饰的类/函数/属性的具体实现由开发人员提供,不会在声明中生成任何JavaScript代码, 因此external声明应该没有代码体内容,例如: // 以下声明都没有代码体,具体代码由JavaScript提供 external fun alert(message: Any?): Unit external val window: Window external class Node { //external修饰符会被继承,即Node类的成员函数和属性前不需要添加external val firstChild: Node fun append(child: Node): Node fun removeChild(child: Node): Node } 提示: external修饰符只允许在包级声明中使用(package-level) 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/347fa8c1f8738ab00b02a2c5974401b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6a5c8c5c0f25f040aa94dc08f93ae4/" rel="bookmark">
			机器学习-模型的评估与选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		- 机器学习-模型的评估与选择 如今的世界AI出现的频率越来越高，相信过不了多久就会想java一样普及了。为了不使自己落后。只能跟上时代的步伐了，谁叫自己选择了一个对知识更新要求这么强的行业呢！
最近在看几本关于机器学习的数据。算法对于程序来说还是一如既往的是其根基。发现从周志华的《机器学习》入手理论更适合，写个博客分享一下。
《机器学习实战》和《统计学原理》可以同时看，会发现有些单看一本书不能理解的地方，看过三本书之后突然就悟了，当然还不能忘记同时在网上搜搜各种博客哈哈。
评价一个机器学习模型的好坏需要特定的评估方法，并据此对模型进行选择，从而得到一个更好的模型。
但在实际任务中，我们往往有很多的算法可供选择。甚至对同一个学习算法，使用不同的配置参数也会产生不同的模型。那么，我们该选用什么算法、什么配置？所以，本文主要介绍模型的选择与评估。
一：经验误差与过拟合
错误率 = a个样本分类错误/m个样本
精度 = 1 - 错误率 误差：学习器实际预测输出与样本的真是输出之间的差异。 训练误差：即经验误差。学习器在训练集上的误差。 泛化误差：学习器在新样本上的误差。
过拟合：学习器把训练样本学的”太好”，把不太一般的特性学到了，泛化能力下降，对新样本的判别能力差。必然存在，无法彻底避免，只能够减小过拟合风险。 欠拟合：对训练样本的一半性质尚未学好。
二：评估方法
1，留出法 2，交叉验证法 3，自助法 4，调参与最终模型
2.1留出法
D分为两个互斥的集合，一个作为S，一个作为T。
分层采样：S和T中正例和反例比例一样。
例如D包含500个正例，500反例。分层采样获得含70%样本的S，有350正例，350反例；30%样本的T，有150正例，150反例。数学定义上有：D=S∩T,S∪T=∅ 一般采用随机划分、重复进行实验评估后取平均值作为留出法的评估结果。
例如，进行100次随机划分，每次产生一个训练/测试集用于实验评估，100次后得到100个结果，而留出法返回的则是这100个结果的平均。 弊端：T比较小，评估结果不够稳定准确，偏差大。 常见将大约2/3~4/5的样本用于训练，剩余样本用于测试。
2.2，交叉验证法 将D划分为k个大小相似的互斥子集。(D通过分层采样得到每个子集Di,保持数据分布一致性)。每次用k-1个子集的并集作为训练集，余下那个作测试集。即可获得K组训练/测试集，进行K次训练和测试，最终返回k个测试结果的均值。也称”k折交叉验证”。数学定义上有：D=D1∪D2∪⋯∪Dk,Di∩Dj=∅(i≠j)
为减小因样本划分不同而引入的差别，k折交叉验证要随机使用不同的划分重复p次，最终评估结果是这p次k折交叉验证结果的均值，即进行p*k次训练/测试。
留一法：m个样本划分成m个子集，每个子集包含一个样本。留一法中被实际评估的模型与期望评估的用D训练出来的模型很相似，因此，留一法的评估结果往往被认为比较准确。 留一法缺陷：数据集较大，例如，数据集包含100w个样本，则需训练100w个模型。且留一法的估计结果未必比其他评估法准确。
2.3，自助法
以自助采样法（bootstrapsampling）为基础，从m个样本的数据集D，随机采样(选)一个样本，拷贝入训练D’，放回，继续随机挑选，直至m次。
样本在m次采样中始终不被踩到的概率(1-1/m)^m。 实际评估的模型与期望评估的模型都使用m个训练样本，而仍有约1/3的没有在训练集的样本用于测试。 自助法在数据集较小、难以有效划分训练/测试集时很有用。在初始数据量足够时，留出法和交叉验证法更常用。
2.4，调参与最终模型
对每种参数都训练处结果模型，然后选出最好的学习模型。这种想法是正确的，但需要注意，学习算法很多是在实数范围内取值，因此对每种参数都训练出模型来是不可行的。现实中常用的做法是：对每个参数选定一个变化步长，如在[0,0.2]范围以内已0.05为步长。则实际要评估的候选参数值有5个，最终从这5个中选出定值。显然，这样选定的参数值往往不是“最佳”值，但这是在计算机开销和性能估计之间折中的的结果。通过这个折中机器学习才变的可行，事实上，通过这样的折中调参任然很困难。例如：假定有3个参数，每个参数有5个候选值，这样对每组训练/训练集就有3^5=125个模型需要考察。像大型的“深度学习”的参数往往有上百亿个。 在给定的m个样本的数据集D，在模型的选择中往往会留出一部分数据做为训练模型。因此应该在模型选用完成之后，学习算法和配置参数已选定，再使用D数据集重新训练模型，这个模型的训练过程中使用了m个样本，这才是我们最后交给用户的模型。
三：性能度量
性能度量：衡量模型泛化能力的评价标准。
给定样例集D={(x1,y1),(x2,y2),……,(xm,ym)},yi是对xi的真实标记，要评估学习器f的性能，就要把学习器预测结果f(x)与真实标记y进行比较。 均方误差： 数据分布D和概率密度函数p(.),均方误差： 1，错误率与精度 2，查准率和查全率 3，ROC AUC 4，代价敏感错误率与代价曲线
3.1，错误率与精度 错误率：分类错误的样本数占样本总数的比例。 精度：分类正确的样本数占样本总数的比例。 数据分布D和概率密度函数p(.)。
错误率： 精度： 3.2，查准率和查全率 对于二分类的问题可分为： True positive 真正例，False positive 假正例，True negative 真反例，False negative 假反例，TP+FP+TN+FN = 样例总数，如图： 查准率P和查全率R分别定义为： 通常，查准率高时，查全率偏低；查全率高时，查准率偏低。 例如，若希望好商品尽可能的挑选出来，则可通过增加选商品的数量来实现，查准率就会低；若希望挑出的商品中好商品比例尽可能高，则可挑选有把握的商品，必然会漏掉好商品，查全率就低了。 学习器把最可能是正例的样本排在前面。按此排序，把样本作为正例进行预测，根据PR绘图。 “平衡点”是：查准率=查全率，在一些应用中对查全率和查准率的要求是不同的，如：商品推荐更希望推荐的内容是用户感兴趣的，则查准率更为看重。公安系统的检索当中则更看重查全率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db2f58de42e9cfe010cf90838f2adab5/" rel="bookmark">
			Android实战 RxJava2&#43;Retrofit&#43;RxBinding解锁各种新姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
前言 作为主流的第三方框架Rx系列，不学习也不行啊，对于初学者来说，可能RxJava看起来很难，用起来更难，但是你要知道，越复杂的东西往往能解决越复杂的问题，有可能你应用在项目中，也许你在面试的时候，就会和初级工程师拉开一大段距离。
RxJava2的介绍 用原话就是：RxJava2是一个在Java虚拟机上，使用可观察的序列构成基于事件的，异步的程序库。不理解没关系，可以类比成我们的AsyncTask，这样就好理解多了
RxJava传送门：
https://github.com/ReactiveX/RxJava
RxJava2观察者模式的介绍 观察者模式就是RxJava使用的核心点，掌握这个模式，可以理解RxJava更简单，观察者模式简单的说就是”订阅-发布”的模式。
举一例子说，当你订阅某家牛奶店的早餐奶（订阅过程），只要牛奶店生产牛奶，便会给你送过去（发布过程）。这里的牛奶店只有一家，但是订阅的人可以很多，这是一种一对多的关系，只要牛奶店发布牛奶，那么订阅的人就会收到牛奶。换做RxJava里面的话，牛奶店就是被观察者（Observable），订阅的人就是观察者（Observer）
RxJava2观察者模式的使用 这里我们举一例子学校点名的例子，首先创建我们所说的观察者和被观察者
各位可以思考一下，根据上面的介绍，学生和老师，谁是观察者，谁是被观察者，下面就看代码给你分析
通过代码可以看到，注意分别实现的不同接口
1、老师是被观察者，他需要实现接口的方法
订阅/取消订阅：往集合中存放/移除观察者
发布：循环遍历观察者，调用观察者方法
2、学生是观察者，那么我们只需要给他个名字，实现观察者的方法即可
最后，我们就把观察者和被观察者关联起来，LessonStart （上课啦）
代码很简单，我们模拟了一个老师和小明同学和小红同学，老师已经知道看到两个人来了，那么可以开始点名了，下面通过Log打印出信息
点名啦:小明到 点名啦:小红到 2
RxJava2的基本使用
首先我先贴出我们后面所用到的第三方依赖库，以免后面忘记说了，大家对号入座
其次还需要添加联网权限
&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 最后我们回到正题，看完上面的例子，我们可以知道RxJava就是这种订阅和发布的模式，换成我们的RxJava代码应该是怎么样的？当然也是通过被观察者订阅观察者啦
我们具体被观察者和观察者的实现，当然是创建出来啦
onNext方法就是我们的发布过程，我们看其观察者的创建就知道怎么回事了
我们可以发现，观察者的创建实现的方法，在被观察者中是对应起来的，也就是说，我们发布了什么，就可以在观察者中收到订阅信息，那么我们就可以在代码中编写我们的逻辑了，这样基本上已经使用好了RxJava了，通过Log打印出信息。
1、RxJava支持链式编程，下面这段代码可以完美替代上面的所有代码
这里我多写了两个方法，也就是.subscribeOn(Schedulers.io())和.observeOn(AndroidSchedulers.mainThread())，这里就是RxJava的好处之一，他可以手动切换线程，这两个方法在这里表示被观察者创建实现的方法都放在io线程也就是子线程；
因为在被观察者中通常会调用网络数据请求，那么网络请求必须在子线程运行，当网络请求收到后，则发布出去，在观察者中通过TextView等控件展示在界面上，那么UI的更新必须在主线程进行，也就是我们上面的代码mainThread。
2、若喜欢简洁，喜欢定制服务，巧了，RxJava也给你满足了，下面这段代码中，实现的方法跟上面的实现方法是对应起来的，大家看参数就知道哪个对应哪个了，你可以通过new Consumer，不需要实现的方法你可以不写，看上去更简洁，这里我为了方便大家看，都new出来了，Consumer就是消费者的意思，可以理解为消费了onNext等等等事件
哦，对了，我们还忘记打印Log信息，不能否认了我很帅这个事实
com.handsome.boke2 E/onNext: 俊俊俊很帅 com.handsome.boke2 E/onNext: 你值得拥有 com.handsome.boke2 E/onNext: 取消关注 当然你觉得只要夸奖我一个帅就行了，那么你也可以通过下面这几种方法发送给观察者
3
模拟发送验证码 这里的案例使用我们平时最简单的需求，看效果图就知道（图片会卡，效果大家脑补）
这里是整个代码的实现思路，我会在代码下面注释一下需要注意的点，代码我就直接贴出来：
1、操作符
像这种interval、take、map、observeOn、doOnSubscribe、subscribe都是属于RxJava的操作符，简单的说就是实现某个方法，里面的功能都被包装起来了
RxJava支持的操作符很多，很多操作符用起来都简单，但是组合起来就很复杂，功能很强大，具体分类如图所示
2、操作符介绍
interval：延时几秒，每隔几秒开始执行
take：超过多少秒停止执行
map：类型转换，由于是倒计时，案例需要将倒计时的数字反过来
observeOn：在主线程运行
doOnSubscribe：在执行的过程中
subscribe：订阅
4
RxJava2与Retrofit的使用 RxJava与Retrofit的使用，更像我们的AsyncTask，通过网络获取数据然后通过Handler更新UI
模拟用户登陆获取用户数据 拿出我过硬的美工技术给你们画图了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db2f58de42e9cfe010cf90838f2adab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7acd15408cb61014a00704c412e08d/" rel="bookmark">
			Kotlin-35.反射(Reflection)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档: http://kotlinlang.org/docs/reference/reflection.html
1.反射概念(Reflection) 反射是一套语言功能库,允许在程序运行时自省/内省(introspect)程序结构! 与java语言不同, 函数和属性是Kotlin世界的一等公民, 对它们自省与函数式或响应式风格密切相关(functional/reactive style)! 自省/内省(introspect): 在运行时获取类,属性,函数的名称和类型! 提示: 在Java平台(JVM)上使用kotlin反射功能,需要在项目中添加kotlin反射库的jar包(kotlin-reflect.jar)! 因为kotlin反射库JAR文件(kotlin-reflect.jar)是单独分发的,不包含在kotlin标准库中, 这是为了减少[不使用反射功能的应用]所需运行库的大小! 2.类引用(Class References) kotlin最基本的反射功能是获取Kotlin类的运行时引用(runtime reference)! 获取静态已知的Kotlin类引用,可用[类字面值语法](class literal syntax): val c = MyClass::class kotlin类引用是KClass类型的一个值! Java类引用和Kotlin不同,获取Java类引用要在KClass实例对象上使用.java属性: fun main(args: Array&lt;String&gt;) { println(String::class) //输出class kotlin.String println(String::class.java) //输出class java.lang.String } 自kotlin 1.1起,开始有[绑定类引用](Bound Class References), 使用对象作为接收者(::class语法)获取指定对象的类引用: val widget: Widget = ... assert(widget is GoodWidget) { //获取widget对象的精确类(实际类)的引用, GoodWidget 或 BadWidget "Bad widget: ${widget::class.qualifiedName}" } 3.函数引用(Function References) 有一个命名函数声明如下: fun isOdd(x: Int) = x % 2 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b7acd15408cb61014a00704c412e08d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c545014d1546c624d830835a21872880/" rel="bookmark">
			WINDOWS远程桌面死机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“救活”WINDOWS远程桌面死机
通过远程桌面来访问远程WINDOWS机器，输完用户名和密码后，点登录，有时会出现用户登录时，界面卡死，甚至蓝屏。但是其他用户可以正常的登录。如果你有管理员用户或与管理员很友好，请管理员帮个忙，把这个卡死的用户注销一下，当然没有问题了。如果你无法请到管理员用户，那如何处理呢？以下有两个场景（情况）我有解决方法。
场景1：远程服务器正常，其他用户可以登录，但是系统响应比较慢（可能是CPU或内存占用过高），问题用户也可以登录远程桌面，但是登录后只有桌面的图标可以点，底的
任务栏卡死，鼠标放上去是漏斗。
解决方法：这种情况很有可能是这个问题用户的某个进程大量占用CPU达到100%或大量占用内存。处理方法就是进入任务管理器，结束这个进程。但是在通常情况下，我们都是通过任务栏上右键进入任务管理器的。可以现在任务栏无法响应鼠标操作了。
后来我看到桌面上的图标可以用，有一个文件夹的快捷方式（如果桌面上没有文件夹的快捷方式，可以右击桌面，新建一个文件夹）。打开文件
夹，进行系统盘（通常是C盘），C:\WINDOWS\system32\Askmgr.exe。打开任务管理器后，就可以结束占用CPU或内存的进程了。
场景2：远程服务器正常，其他用户可以登录。问题用户登录后界面蓝屏（蓝色界面覆盖整个桌面），无法进行任何操作，只能断开。解决方法：虽然登录后无法操作，但是能不能在登录前做些操作呢？答案是，能！在远程桌面的界面上点“选项”按钮，打开详细的界面。点击“程序”选项卡，再勾选“连接时启动以下程序（S）”的复选框，在“程序路径和文件名（P）”输入命令，就可以在登录时运行程序了。运行什么好呢？输入logoff，这个是注销终端的命令，结果发现登录成功后窗口是注销了。但是再次登录时，发现还是蓝屏。（记得把logoff去掉，要不然下次登录时，一登录就注销
了）。再试，输入taskmgr.exe，这是任务管理器的程序名，这次成功了，打开了任务管理器，查看进程发现少了explorer.exe，这是桌面的进程名，怪不得没有桌面。重新运行桌面，切到任 务 管 理 器 的 “ 应 用 程 序”选项卡，点 “ 新 任 务 ” 按 钮，再输入 Explorer再点“确定”按钮。就可以运行桌面程序了，桌面出来了。接下来你就可以正常的操作了。（但是记得把远程桌面中的“程序路径和文件名”去掉。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41719f9d8edc3cca39f7c5316e3a01c/" rel="bookmark">
			MySQL学习划重点（《MYSQL必知必会》总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，数据库概念
数据库（Database）：
是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据
关系型数据库管理系统（RDBMS）：
是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据，存储和管理的大数据量。
RDBMS即关系数据库管理系统(Relational Database Management System)的特点：
（1）数据以表格的形式出现
（2）每行为各种记录名称
（3）每列为记录名称所对应的数据域
（4）许多的行和列组成一张表单
（5）若干的表单组成database
RDBMS 术语： 数据库: 数据库是一些关联表的集合。.数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。外键：外键用于关联两个表。复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
MYSQL特点：
（1）Mysql是开源的，所以你不需要支付额外的费用。
（2）Mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。
（3）MySQL使用标准的SQL数据语言形式。
（4）Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等
二，安装MySQL
可以在window和linux下安装，请自行百度，以下是在window下的操作。
三，MYSQL语法之一：创建和操纵表
MySQL语句以分号（；）为结束符，若不加分号则会提示继续输入。
1，创建数据库
create database tt; //创建一个空的数据库 show databases; //显示已存在的所有数据库 命令行执行如下：
2，使用数据库，首先要选定它。
use tt;
3，创建表
create table my_table(
my_id int not null auto_increment,
my_name char(50) not null default "a tang ge",
my_city char(50) null,
my_state char(5) null,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e41719f9d8edc3cca39f7c5316e3a01c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/123/">«</a>
	<span class="pagination__item pagination__item--current">124/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/125/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>