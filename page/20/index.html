<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e213e50204718b19b2fc2ced3d53c3a/" rel="bookmark">
			啥是大语言模型LLM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 在人工智能的世界里，有一种技术正迅速改变我们与机器交流的方式——这就是大语言模型LLM（Large Language Model）。它们像是拥有海量知识库的超级智能，能够理解和生成人类语言。那么，大语言模型LLM到底是什么呢？本文将带您一探究竟！
一、大语言模型LLM是什么？ 想象一下，如果有一个超级大脑，它阅读过无数的图书、文章和其他文本资料，并且能够理解这些内容，还能根据它所学到的知识回答问题、创作故事或者撰写报告。大语言模型LLM就像是这样一个数字化的大脑。
大语言模型是一种基于人工智能的计算机程序，通过学习大量的文本数据，它们可以理解和生成语言。这些模型使用深度学习技术，特别是一种叫做变换器（Transformer）的结构，来处理和预测文本序列。
二、大语言模型LLM如何工作？ 让我们用一个简单的比喻来理解大语言模型的工作原理。想象一个孩子在学习语言，他通过听周围的人说话、读书和不断尝试自己说话来学习。类似地，大语言模型通过“吃”掉大量的文本数据来学习语言的规则和结构。
数据摄入：首先，模型需要大量的文本数据作为输入，这包括书籍、文章、网站内容等。训练学习：然后，通过复杂的算法，模型开始识别语言中的模式，比如单词的组合、句子结构和语法规则。生成语言：一旦训练完成，当给出一个提示或问题时，模型就能够生成连贯、有意义的回答或文本段落。 三、大语言模型LLM的应用 大语言模型的应用场景非常广泛，包括但不限于：
聊天机器人：提供自然的对话体验，用于客服支持或娱乐。文本生成：自动撰写新闻文章、创意写作或生成社交媒体内容。翻译：快速将一种语言翻译成另一种语言。教育辅助：帮助学生学习新语言或提供个性化的学习材料。编程助手：辅助开发者编写代码或解决问题。 四、大语言模型LLM的挑战 虽然大语言模型有很多令人兴奋的应用，但也存在一些挑战和问题：
误解和错误：有时模型可能会产生不准确或不合适的输出。偏见和歧视：如果不加以控制，模型可能会学会并复制存在于训练数据中的偏见。隐私和安全：需要确保使用这些模型不会泄露敏感信息。 结语： 大语言模型LLM是人工智能领域的一颗璀璨明珠，它们正在改变我们与机器的交流方式。虽然还有挑战需要克服，但随着技术的不断进步，未来大语言模型的应用将会更加广泛和深入。让我们拭目以待，看看这个语言大师将如何继续影响我们的世界！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89df16b0458d43068f6647fd5eb090d2/" rel="bookmark">
			对https://registry.npm.taobao.org/tyarn的请求失败，原因:证书过期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天安装tyarn时，报错如下：
request to https://registry.npm.taobao.org/tyarn failed, reason: certificate has expired 原来淘宝镜像过期了，需要重新搞一下
记录一下解决过程：
1.查看当前npm配置
npm config list 2.清空缓存
npm cache clean --force 3.修改淘宝镜像
npm config set registry https://registry.npmmirror.com 4.查看 registry是否更改成功
npm config list 5.ok啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44a6525379449f80bf2253d0813f872/" rel="bookmark">
			SinoDB客户端工具dbaccess
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类似Oracle的客户端工具sqlplus，Mysql的客户端工具mysql，SinoDB数据库也有自带的命令行客户端工具dbaccess。
dbaccess 识别用户输入，将用户输入的 SQL 语句打包发送给 SinoDB 数据库服务器执行，然后接收服务器的执行结果，并按用户的要求将执行结果展示给用户。用户只要安装了 SinoDB 数据库，就可以在命令行启动dbaccess。
dbaccess工作模式 1. 交互模式 1.1 菜单交互模式 dbaccess提供了一个基于控制台的菜单，用户可以使用方向键或快捷键，选择和执行相应的功能。
直接运行dbaccess命令，即可进入菜单的交互模式。
[informix@vm84145 ~]$ dbaccess DBACCESS: Query-language Connection Database Table Session Exit Use SQL query language. ------------------------------------------------ Press CTRL-W for Help -------- 可在菜单模式下，可以进行以下操作：
选择/连接数据库实例编辑/执行SQL代码选择/执行文件中的SQL代码
注: 可选择和执行的文件，在启动dbaccess的目录中，且扩展名为.sql。 1.2 指令交互模式 dbaccess提供了一个类似mysql或sqlplus的客户端交互模式，用户输入要执行的指令并回车，dbaccess执行用户输入的指令，并返回执行结果。
可以通过为dbaccess提供两个参数，进入指令交互模式。
dbaccess &lt;param1&gt; &lt;param2&gt; param1:提供数据库名称或-，当该参数为-时，表示未选择默认的数据库，后续可在dbaccess中，使用database &lt;db_name&gt;指定当前数据库。 param2:固定为-，表示dbaccess的输入为标准输入STDIN。 示例1：
[informix@vm84145 ~]$ dbaccess - - &gt; database testdb; Database selected. &gt;create table tuser(cuserid int,cusername varchar(50)); Table created. &gt; insert into tuser values(1,‘sinodb’); 1 row(s) inserted.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a44a6525379449f80bf2253d0813f872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec1f13cb8a63b2dac0ae0773de5f727/" rel="bookmark">
			数据分析能力模型分析与展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体内容：
专业素质 专业素质-01 数据处理 能力定义•能通过各种数据处理工具及数据处理方法，对内外部海量数据进行清洗和运用，提供统一数据标准，为业务分析做好数据支持工作。 L1•掌握一定的数据提取的方法和工具，能为业务提供一定的数据支持。 L2•熟练掌握较多数据提取的方法和工具，能独立、准确、及时地为业务提供数据支持。 L3•熟练掌握各类数据提取的方法和工具（包括但不限于SQL、Excel、Python），能够在做好数据支持的同时，响应业务的更多需求。 L4•熟练掌握各类数据提取的方法和工具，能够在满足业务需求同时，主动挖掘业务需求和数据异常，做好数据监测及反馈。
专业素质-02 分析方法 能力定义•能够通过多种方法洞察业务本质，从数据对业务的实际用途出发，覆盖描述、诊断、预测、决策四大功能，为业务提供有效决策支持。 "
L1•具备一定的数据分析理论、方法和技巧。 •能够独立完成有明确目标的分析需求。" "
L2•掌握较全面的数据分析理论、方法和技巧。•能够独立完成运营、产品等业务问题分析。•能收集并主动识别关键业务问题。" "
L3•能够综合运用数据分析的能力和业务分析的方法。•独立完成用户、经营、产品、运营等各业务板块的分析工作。•主动挖掘深层次的业务问题，并做准确识别。" "
L4•能够综合运用各类数据分析的能力和业务分析的方法。•能够从宏观视角评估业务，主动解决完成各业务板块的问题。•能有效分析数字化战略目标与现状的差距，推进业务目标落地并保障推进。"
专业素质-03 业务洞察 能力定义•能够在复杂的商业环境和快速变化中保持冷静的思考和独立的判断力，结合业务场景和模式进行总结和提炼，发现业务本质和共性，产出最具价值的业务模式。 L1•能够简单结合现有业务对单一需求进行业务分析，使用业务分析的各项工具。 L2•能够对现有业务的单一需求进行提炼总结，对普遍共性的需求进行业务分析，熟练使用业务分析的各项工具。 L3•具备一定程度业务模式抽象能力，能通过对普遍共性的需求进行提炼总结找到业务共性，使业务抽象具备通用性，并落实某类产品及业务，并能够有业务产出。 L4•能通过现有业务共性发现本质原理，能够梳理业务抽象的多个要素, 独立完成业务抽象，冷静分析其影响与价值，形成独立的判断，使之覆盖多数业务模式以及跨业务线的实例。
专业素质-04 指标体系 能力定义•能有效梳理业务流程的关键路径，确定业务核心指标，搭建业务指标体系，实现对业务的量化监测及及时反馈。 L1•了解基本的指标体系概念，能够看懂各类业务报表和指标变化含义。 L2•掌握一定的指标体系搭建方法，可进行产品、运营等业务指标体系的优化迭代。 L3•掌握各类指标体系构建方法，能够独立完成产品、运营等业务指标体系的搭建工作。 "
L4•对指标体系构建有系统性认识，能独立构建业务北极星指标。•能根据公司战略要求，对业务指标进行合理化拆解和体系构建。"
专业素质-05 数据工具 能力定义•能通过各类数据工具，高效、快捷地完成数据分析、挖掘、可视化的工作。 L1•具备一定的专业知识和技能，能通过一定数据工具完成业务提出的分析需求。 "
L2•能通过SQL完成常见数据提取工作。•能通过Excel实现数据处理、数据分析、数据可视化工作。" "
L3•熟练掌握数据提取及分析工具，包括SQL、Python、R语言等。•熟练掌握数据可视化工具，包括Excel、PowerBI等。•能完成相应的数据分析报告。" "
L4•熟练运用各类数据提取、分析、可视化工具，独立实现各类数据需求。•具有丰富的数据分析及呈现的实践经验，能凭借在大型项目中对以上工具的实际操作，实现数据更有说服力的效果。•能独立完成各类数据分析报告。"
专业素质-06 数据化运营 •进行数据收集和分析，基于对业务目标的理解进行数据分析，提供决策支持和建议。 L1•对单个或者多个的指标进行日常追踪、运营和管理，能对单点的或者局部的数据进行准确（指标数据和口径标准）的事后分析。 L2•对单个或者多个的指标进行日常追踪、运营和管理，能对单点的或者局部的数据进行准确（指标数据和口径标准）的事后分析。 L3•围绕业务增长，数据分析出的报告能对业务增长有所帮助，能全局性、从多个维度的对数据进行综合分析，能掌控比较成熟的运营数据的分析方法，对未来有一定预判。 L4•能够围绕商业模式与公司战略，通过行业数据的分析对比，能总结过往成功实践，形成公司系统化的数据分析模型和分析方法论，准确预测未来，大大提升了公司在数据分析方面的效率和质量。
通用素质 通用素质-01 数据思维 •通过流程规划、时程安排、任务和人员的管理以及资源的整合运用，有效识别项目风险并进行有效沟通，顺利达成项目目标。 "
L1•熟悉项目管理基础知识、项目管理工具和核心管理控制点。•在指导下进行简单项目的计划跟踪和监控。" "•在有限指导下能组织实施小型项目。
L2•能够按照总体计划制定阶段性计划及监控点，并按实际执行情况及时修正项目计划。•项目中能够判断风险点并解决一般难度的问题。" "•能够独立负责中型项目/活动的实施和运作，具备项目统筹能力。•掌控各方资源协调的能力。
L3•能够设立项目中的关键里程碑，关注关键事件的实现，具备成本意识，准确预判风险点并解决较复杂问题。" "•项目建立之初项目范围及边界的确认，能成功主导大型项目的运作。•项目高级工具的使用。
L4•项目干系人的确立，识别出风险，预测未知的不确定因素，确立项目管理的机制，对成本和项目进度做出预测，完成既定目标。"
通用素质-02 业务协同 "•有效的识别相关方及关键沟通对象，有效表达目标以达成相关方共识。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aec1f13cb8a63b2dac0ae0773de5f727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87dd2c349f299fba1db480abee49d7ec/" rel="bookmark">
			使用原生nodejs搭建一个简易的web服务器demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简易demo
var http = require('http'); var url = require("url"); const app= http.createServer(function (request, response) { var urlObj = url.parse(request.url,true); console.log(request.url); // 内容类型: text/plain。并用charset=UTF-8解决输出中文乱码 response.writeHead(200, {'Content-Type': 'text/plain; charset=UTF-8'}); // 下句是发送响应数据 response.end('Hello World! 这是简单的web服务器测试。\n'); }).listen(8888); // 终端打印如下信息 console.log('Server running at http://127.0.0.1:8888/'); 或者这样写法
var http = require("http"); var url = require("url"); const app = http.createServer(); app.on("request", (req, res) =&gt; { res.writeHead(200, { "Content-Type": "text/plain; charset=UTF-8" }); let path = url.parse(req.url, true).pathname; console.log(123, req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87dd2c349f299fba1db480abee49d7ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed523de9f87828edc407b8a8b12759e/" rel="bookmark">
			POI导入excel读取excel中图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先excel图片需要跟单元格绑定
2.pom文件
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;${poi.version}&lt;/version&gt; &lt;/dependency&gt; 3.编写测试方法进行导入
import java.io.FileOutputStream; import java.io.InputStream; import java.util.List; import java.util.UUID; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.ClientAnchor; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Shape; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import org.apache.poi.xssf.usermodel.XSSFDrawing; import org.apache.poi.xssf.usermodel.XSSFPicture; import org.apache.poi.xssf.usermodel.XSSFPictureData; import org.apache.poi.xssf.usermodel.XSSFShape; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.access.prepost.PreAuthorize; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.PutMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; /** * 资产清单Controller * * @author hhxx * @date 2024-03-13 */ @RestController @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bed523de9f87828edc407b8a8b12759e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19a0aa00d0be9e3701cda3e71b2f224e/" rel="bookmark">
			java注解类-导入Excel文件到数据库中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实体类 @Data @ToString @AllArgsConstructor @NoArgsConstructor @TableName("zhuzao_xiaohao_lingwai_daoru") public class ZhuzaoLingWaiData implements Serializable { @Excel(name = "日期") private String date; @Excel(name = "批次号") private String batchno; @Excel(name = "第几周") private String weekday; @Excel(name = "生产线") private String productline; @Excel(name = "图号") private String produtname; @Excel(name = "物料编码") private String productdescription; @Excel(name = "产品名称") private String productweight; @Excel(name = "铸件毛重") private String box; @Excel(name = "件/箱") private String classes; @Excel(name = "班次") private String ronghualu; @Excel(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19a0aa00d0be9e3701cda3e71b2f224e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6ef7e74025c3a187fa9e71f292eb1d/" rel="bookmark">
			k8s集群架构维护k8s集群以及搭建k8s集群以及k8s集群的常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、k8s架构 Kubernetes（K8s）是一个由Google主导开发的开源容器编排平台，用于自动化部署、扩展和管理容器化应用程序。它的设计目标是简化容器化应用程序在生产环境中的部署和运营。Kubernetes的架构设计复杂且高效，主要包括以下几个核心组件：
1、控制平面（Control Plane）
API服务器（API Server）：作为集群的大脑，它提供了用于管理集群的RESTful API接口。所有对集群资源的操作都需要通过API服务器进行。
调度器（Scheduler）：负责根据预定的策略将Pod调度到合适的节点上运行。
控制器管理器（Controller Manager）：负责运行各种控制器，如部署控制器、节点控制器、服务控制器等，以确保集群的状态符合用户的定义。
etcd：一个分布式键值存储系统，用于存储集群的状态信息，如Pod、节点、服务等的元数据。
2、工作节点（Worker Nodes）
Kubelet：在节点上运行的组件，负责Pod的创建、配置和运行。
Kube-Proxy：在节点上运行的网络代理，负责为Pod提供网络代理服务，实现Pod之间的网络通信。
3、Pod
Kubernetes的基本工作单元，一个Pod可以包含一个或多个容器。Pod中的容器共享网络和存储资源，并且总是运行在同一个宿主机上。
4、服务（Service）
用于定义一组Pod的抽象，它定义了如何访问这一组Pod，如IP地址、端口号等。服务可以暴露内部的服务，也可以隐藏底层的Pod。
5、部署（Deployment）
用于控制应用程序的版本和扩展。Deployment定义了应用程序的预期状态，Kubernetes会自动确保应用程序的实际状态与预期状态一致。
6、副本控制器（ReplicaSet）
确保指定的Pod副本数在任何时候都得到维护。如果Pod丢失，副本控制器会自动创建新的Pod来替换它。
7、持久化存储（Persistent Storage）
用于提供持久的存储卷，以供Pod使用。支持多种存储系统，如本地存储、iSCSI、NFS、Ceph等。
8、网络插件（Network Plugins）
用于为Kubernetes提供网络功能。不同的网络插件支持不同的网络模型和特性。
9、Addon Manager
负责管理和配置集群中的附加组件，如监控、日志记录等。
二、k8s集群搭建以及高可用集群搭建 1、准备环境：
确保所有节点（物理机或虚拟机）的操作系统都是兼容的，通常使用Linux系统，如Ubuntu、CentOS等。
每个节点都需要有一个唯一的MAC地址和主机名。
2、安装Docker：
在所有节点上安装Docker。Docker是Kubernetes用来运行容器的引擎。
3、安装Kubeadm、Kubelet和Kubectl：
Kubeadm是一个工具，用于初始化和管理Kubernetes集群。
Kubelet是在集群中所有机器上运行的组件，负责启动Pod和容器等。
Kubectl是集群管理员和开发人员与集群通信的命令行工具。
4、使用kubeadm创建集群：
在主节点上运行kubeadm init命令来初始化集群。
按照命令输出中的指示，配置kubectl，使其能够与集群通信。
5、配置高可用集群：
安装一个高可用性的存储解决方案，如etcd集群。
配置负载均衡器，以便管理节点通信。
6、加入节点：
使用kubeadm join命令将工作节点加入到集群中。
7、验证集群状态：
使用kubectl get nodes命令来检查所有节点的状态。
搭建高可用Kubernetes集群
高可用Kubernetes集群的目的是确保集群的关键组件（如API服务器、etcd等）在面对故障时能够继续运行。
8、增加集群组件的冗余：
使用多个API服务器实例，通过负载均衡器提供服务。
创建etcd集群，通常需要至少三台机器，以实现数据的冗余和故障转移。
9、使用控制器管理器的高可用模式：
配置控制器管理器以在多个节点上运行，确保即使一个节点失败，其他控制器管理器仍然可以继续工作。
10、配置服务发现和负载均衡：
使用高可用性的服务发现方案，如CoreDNS和Calico，确保服务即使在节点故障的情况下也能够正常发现和通信。
11、灾难恢复计划：
制定灾难恢复计划，包括备份集群状态、离线恢复等。
12、监控和告警：
安装监控工具，如Prometheus和Grafana，以及配置适当的告警规则，以便在集群出现问题时及时通知维护人员。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6ef7e74025c3a187fa9e71f292eb1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48aff8a100a529cd6beef261d886751a/" rel="bookmark">
			MySQL数据库的基本概念与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
一、数据库的基本概念
（一）数据、表与数据库
1.数据(Data)
2.表
3.数据库
（二）数据库管理系统
（三）数据库系统
二、数据库的发展
三、主流数据库的介绍
（一）关系型数据库
（二）非关系型数据库
（三）关系与非关系型的区别
四、MySQL数据库介绍
五、MySQL的安装
引言 数据库作为一种系统化的数据存储、管理和检索的软件，已成为我们日常生活和工作中不可或缺的一部分，无论是电子商务网站、社交媒体平台，还是企业内部的各种信息系统，背后都有数据库的身影
一、数据库的基本概念 （一）数据、表与数据库 1.数据(Data) 描述事物的符号记录
包括数字，文字、图形、图像、声音、档案记录等数据库
2.表 将不同的记录组织在一起
用来存储具体数据存放信息的集合，类似于EXCEL表格一样
姓名出生年月张三2000-01-05李四1998-07-28 3.数据库 表的集合，是存储数据的仓库
以一定的组织方式存储的相互有关的数据集合
（二）数据库管理系统 我们的生活中无时无刻都在接触到数据，而数据库便是通过指定的组织结构将这数据存储的仓库，并且随着互联网和信息技术的发展，数据库也已经从最初只能存储简单表格发展到了存储海量数据的大型分布式模式。在信息化社会，充分有效地管理和利用各类信息资源，是进行科学研究和决策管理的前提条件。
数据库技术是管理信息系统、办公自动化系统、决策支持系统等各类信息系统的核心部分，是进行科学研究和决策管理的重要技术手段。
数据库管理系统(即 DatabaseManagementSystem)是一种能够对数据库进行建立、使用和维护的软件程序，数据库管理系统通过将计算机中具体的物理数据转换成适合用户理解的抽象逻辑数据，方便用户维护数据库的安全和可用性。
DBMS的工作模式如下：
1.接受应用程序的数据请求和处理请求
2.将用户的数据请求（高级指令）转换为复杂机器代码（底层指令）
3.实现对数据库的操作
4.从数据库的操作中接受查询结果
5.对查询结果进行处理（格式转换）
6.将处理结果返回给用户
（三）数据库系统 是一个人机系统，由硬件、OS、数据库、DBMS、应用软件和数据库用户组成。用户可以通过DBMS或应用程序操作数据库
数据库管理员（DatabaseAdministrator，DBA）
负责数据库的更新和备份、数据库系统的维护、用户管理等工作，保证数据库系统的正常运行。DBA 一般由业务水平较高、资历较深的人员担任。
二、数据库的发展 数据库的发展历史可以追溯到20世纪60年代，经历了几个重要阶段和技术革新。以下是详细介绍：
第一代数据库系统主要基于网状数据模型和层次数据模型。网状数据库模型于1964年诞生，它将数据从应用程序中独立出来并进行集中管理，能反映现实世界中信息的关联。层次数据库则采用树结构，解决了集中存储、管理和共享数据的问题，但数据独立性和抽象级别存在不足。236
第二代数据库系统以关系数据模型为代表，于1970年出现。关系数据库系统基于表格型数据，通过结构化查询语言(SQL)提供定义、操纵、查询和控制功能。1974年，IBM发布了第一个商用关系数据库系统IMS，随后，关系数据库系统得到了广泛的应用和推广。
第三代数据库系统则以面向对象模型为主要特征，产生于20世纪80年代。这一代数据库系统支持多种数据模型，并结合了新技术，如分布式处理、并行计算、人工智能等，广泛应用于商业管理、地理信息系统(GLS)、计划统计等多个领域。
此外，随着云计算技术的发展，数据库系统也逐渐向云上转移，出现了云数据库的概念。云数据库通过计算机网络提供数据管理服务，具有部署和虚拟化在“云端”的特点。同时，数据库技术也呈现出多元化的趋势，非关系型数据库如NoSQL数据库因其能适应更多应用场景而得到发展。此外，数据库管理系统(DBMS)的核心组件集一般可以分为管理组件、网络组件、计算组件、存储组件四大模块。
三、主流数据库的介绍 主流的数据库系统包括关系型数据库和非关系型数据库两大类
（一）关系型数据库 关系型数据库（Relational Database Management System, RDBMS）是一种基于关系模型理论的数据库管理系统。关系模型由英国计算机科学家艾伦·科德在1970年提出，其核心思想是将数据组织成一系列二维表格（关系）的形式，并通过表格之间的关联关系来描述和操作数据。
关系数据库系统是基于关系模型的数据库系统，关系模型的数据结构使用简单易懂的二维数据表
，可用简单的“实体-关系”(E-R)图来表示
E-R图中包含了关系、实体(数据对象)、和属性三个要素
实体：也称为实例，对应现实世界中可区别于其他对象的“事件”邻事物'。
属性：实体所具有的某一特性，一个实体可以有多个属性
联系：实体集之间的对应关系称为联系，也称为关系。
所有实体及实体之间联系的集合构成一个关系数据库
通过上图可以看到，关系表中存放着其它表与表之间的对应关系，如用户名编号为1的张三用户，他的账号和密码对应的是账号表中的编号3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48aff8a100a529cd6beef261d886751a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2af998047c0d6af4bc7ab647667f3a/" rel="bookmark">
			探索未来教育：培训机构架构的创新之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着社会的发展和教育需求的不断增长，培训机构在教育领域扮演着越来越重要的角色。而培训机构的架构设计将直接影响到教学效果、管理效率以及未来发展方向。本文将深入探讨培训机构架构的创新之路，从组织结构、课程设计、师资队伍等方面进行分析，探索未来教育的可能性。
## 培训机构架构的重要性
培训机构的架构设计是决定其运营效率和教学质量的关键因素之一。一个合理的架构可以提升培训机构的竞争力，吸引更多学员和优秀教师，同时也能够更好地适应市场变化和教育需求的变化。
## 创新之路：培训机构架构的重点
1. **组织结构创新**：建立扁平化管理结构，促进信息流动和决策效率；设立跨部门协作机制，提升服务质量和用户体验。
2. **课程设计创新**：结合个性化学习需求，设计多样化的课程体系；引入项目化学习，培养学生实践能力和创新思维。
3. **师资队伍建设**：建立完善的师资培训机制，提升教师教学水平和专业素养；搭建师生互动平台，促进师生沟通和互动。
4. **技术支持创新**：整合教育科技资源，引入在线教育平台和虚拟实验室等技术手段，提升教学效果和学习体验。
## 未来展望：教育的数字化转型
随着信息技术的飞速发展，未来的培训机构架构将更加数字化、智能化。通过大数据分析、人工智能等技术手段，培训机构可以更好地实现个性化教学、精准招生和教学效果评估，推动教育行业向数字化转型迈出坚实的步伐。
在未来教育的道路上，培训机构架构的创新将成为推动教育发展和提升教育品质的关键。只有不断探索和创新，培训机构才能更好地适应时代的需求，培养出更多具有创新精神和实践能力的优秀人才，为社会发展贡献更多力量。让我们共同期待未来教育的美好前景！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0041d846860bce2e8b048e931481ed5/" rel="bookmark">
			C&#43;&#43; List底层实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言成员变量成员函数迭代器self&amp; operator++()前置++self operator++(int)后置++self operator--()前置--self operator--(int)后置--bool operator!=(const self &amp; tmp)判断是否相等T* operator*() 解引用操作 list()初始化iterator begin()iterator end()const_iterator begin()constconst_iterator end()constiterator insert(iterator pos, const T&amp; val)在pos位置插入valvoid push_back(const T&amp; val)在尾部位置后插入void push_front(const T&amp; val)在头部位置插入iterator erase(iterator pos)void pop_back()//删除最后一个元素void pop_front()删除第一个元素list(list&lt;T&gt;&amp; tmp)拷贝构造void swap(list&lt;int&gt;&amp;tmp)交换两个listlist&lt; T&gt;&amp; operator=(list&lt; T&gt; it)赋值int size()判断有多少元素bool empty() 判断list是否为空T&amp; front()取首元素T&amp; back()取尾元素void clear()清空元素~list()析构再谈迭代器 完整代码总结 前言 我们都清楚c++中的容器list，本质上就是一个带头双向循环链表，接下来我们实现一下list的底层，帮助我们更深层次的了解list的结构和使用
成员变量 我们知道这个节点有三部分构成 _prev,_next,_val;每个节点看作list的一个元素，这又是一个双向带头循环链表，那么我们如果仅仅知道头节点，就可以访问遍历链表中的所有元素。
//类模板
template &lt; class T&gt;
struct ListNode
{
ListNode(const T&amp; val=T()) //初始化
:_prev(nullptr)
,_next(nullptr)
,_data(val)
{ }
ListNode* _prev;//指向前一个元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0041d846860bce2e8b048e931481ed5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0fe6b5738e24ebe1deff8de41173027/" rel="bookmark">
			王道c语言-链表分为两半，逆置后一半，与前一半轮流合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		王道c语言-链表分为两半，逆置后一半，与前一半轮流合并 设线性表 L = ( a 1 , a 2 , a 3 , ⋯ , a n − 2 , a n − 1 , a n ) L=(a_1,a2,a3,\cdots,a_{n-2},a_{n-1},a_{n}) L=(a1​,a2,a3,⋯,an−2​,an−1​,an​) 采用带头结点的单链表保存，设计一个空间复杂度为 O ( 1 ) O(1) O(1)且时间上尽可能高效的算法，重新排列 L 中的各结点，
得到线性表 L ′ = ( a 1 , a n , a 2 , a n − 1 , a 3 , a n − 2 , ⋯ ) L'=(a_1,a_n,a_2,a_{n-1},a_3,a_{n-2},\cdots) L′=(a1​,an​,a2​,an−1​,a3​,an−2​,⋯) 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0fe6b5738e24ebe1deff8de41173027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ef013dbd2838c6037af221094797a18/" rel="bookmark">
			汇编器AS命令行用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 常用的两种汇编器：汇编码格式as（1） - Linux 手册页名字概要(重要)描述(不重要)选项另见版权引用者 汇编器：将汇编语言翻译为机器目标代码的程序。 全称assembler. assemb是组装的意思。 常用的两种汇编器： as和nasm
汇编码格式 AT&amp;T
as（1） - Linux 手册页 名字 AS - 可移植的 GNU 汇编程序。
概要(重要) as [-a[cdghlns][=file]] [--alternate] [-D] [--compress-debug-sections] [--nocompress-debug-sections] [--debug-prefix-map old=new] [--defsym sym=val] [-f] [-g] [--gstabs] [--gstabs+] [--gdwarf-&lt;N&gt;] [--gdwarf-sections] [--gdwarf-cie-version=VERSION] [--help] [-I dir] [-J] [-K] [-L] [--listing-lhs-width=NUM] [--listing-lhs-width2=NUM] [--listing-rhs-width=NUM] [--listing-cont-lines=NUM] [--keep-locals] [--no-pad-sections] [-o objfile] [-R] [--hash-size=NUM] [--reduce-memory-overheads] [--statistics] [-v] [-version] [--version] [-W] [--warn] [--fatal-warnings] [-w] [-x] [-Z] [@FILE] [--sectname-subst] [--size-check=[error|warning]] [--elf-stt-common=[no|yes]] [--generate-missing-build-notes=[no|yes]] [--target-help] [target-options] [--|files .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ef013dbd2838c6037af221094797a18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4246e4b1ff211e9e7fa7bb707e2682/" rel="bookmark">
			python与excel第一节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python与excel第一节 由于excel在日常办公中大量使用，我们工作中常常会面对高频次或者大量数据的情况。使用python语言可以更加便捷的处理excel。
python与vba的比较 python语法更加简洁，相较于vba冗长复杂的语法，python更加容易学习。
python在处理多个excel工作簿或者不同格式文件时相较于vba更加简单实用。
python处理大量数据的excel速度更快。
处理excel常见的模块 python中可以用于处理excel的模块很多，如XlsxWriter、xlrd、xlwt、xlutils、openpyxl、xlwings等。其中xlwings的功能是最强大的、最齐全的不仅能读、写、修改xls和xlsx两种格式的excel文件。xlwings还能与vba结合使用，实现更加强大的功能。
多个模块的比较：
例子1：
# 批量新建工作簿10个
import xlwings as xw
app = xw.App(visible=True,add_book=False)
for i in range(10):
workbook = app.books.add()
workbook.save(f'd:\\test\\python与excel\\工作簿test{i}.xlsx')
workbook.close()
app.quit()
上面例子中：app()方法的visible参数用于设置excel程序窗口的可见性，为True时，表示显示excel程序窗口，为False时，表示隐藏excel程序的窗口。add_book方法用于设置启动excel程序后是否新建工作簿，为True时新建，为False时不新建。
然后下面一行app.books.add()方法才新建工作簿，循环了10次，建立十个excel文件。
workbook.save()保存工作簿。
workbook.close()关闭工作簿。
app.quit() 退出excel程序。结束进程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66186f3f6487683caa990e47f3522984/" rel="bookmark">
			118.Qt入门，实现一个图片查看软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要用到的控件 QLabelQLineEditQPushButton 需要实现的功能 打开目录选择图片显示图片的名字显示图片 QLabel基本用法 void setText(const QString &amp;);//设置文本QString text() const;//获取文本void setPixmap(const QPixmap &amp;);设置大小 使用父类QWidget的方法设置样式表（qss）setStyleSheet QLineEdit基本用法 void settext(const QString &amp;);//设置文本QString text() const;//获取文本设置大小 使用父类QWidget的方法 QPushButton基本用法 void settext(const QString &amp;);//设置文本QString text() const;//获取文本设置图片 qss设置大小 使用父类QWidget的方法 代码 #ifndef WIDGET_H #define WIDGET_H #include &lt;QWidget&gt; QT_BEGIN_NAMESPACE namespace Ui { class Widget; } QT_END_NAMESPACE class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); private: void open1(); void open2(); void open3(); void open4(); private slots: void on_btnOpen_clicked(); private: Ui::Widget *ui; }; #endif // WIDGET_H #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66186f3f6487683caa990e47f3522984/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a406f88bdf454c9b87a0d6c3db9df0ce/" rel="bookmark">
			vivado 物理优化约束、交互式物理优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物理优化约束
Vivado Design Suite在物理优化过程中尊重DONT_TOUCH特性。它不在具有这些属性的网络或小区上执行物理优化。要加快网络选择过程中，具有DONT_TOUCH属性的网络经过预过滤，不被考虑用于物理优化。此外，还遵守Pblock分配，以便复制逻辑继承原始逻辑的Pblock赋值。定时异常也从复制从原始细胞到复制细胞。有关更多信息，请参阅《Vivado Design Suite用户指南》中的“合成属性”一节：合成（UG901）。DONT_TOUCH属性通常放置在叶细胞上，以防止它们优化。分层单元格上的DONT_TOUCH保留了单元格边界，但进行了优化仍然可以发生在细胞内。
工具会自动将值为TRUE的DONT_TOUCH属性添加到具有值为TRUE的MARK_DEBUG属性。这样做是为了在整个实现流程，以便可以在任何设计阶段对其进行探索。这是推荐的MARK_DEBUG的使用。但是，DONT_TOUCH限制性太强，阻止了复制和重定时等优化，导致关闭时机困难。在这些情况下，DONT_TOUCH可以设置为FALSE值，而保持MARK_DEBUG为真。删除DONT_TOUCH属性的结果是DEBUG的网络可以被优化掉并且不再被探测。如果MARK_DEBUGnet被复制，只有原始的net保留MARK_DEBUG，而不是被复制的net。
物理优化报告
Tcl报告命令report_phys_opt提供了执行的每个优化的详细信息通过phys_opt_design在非常精细的细节级别上实现。它必须在与相同的Vivado会话中运行phys_opt_design，而优化历史存在于存储器中。因此，如果需要报告，建议包括report_phys_opt命令在最后一个phys_ opt_design命令之后的Tcl脚本中。这些报告仅可用于放置后的phys_opt_design优化。这个报告不是累积的。每个phys_pt运行都有一个不同的phys_pt报告，仅说明在phys_opt_design的特定运行期间所做的更改。以下报告示例显示了涉及寄存器的扇出优化的第一个条目命名为pipeline_en。报告中显示了以下详细信息：
1.原始驱动器pipeline_en驱动816负载和包含该高扇出网络的路径WNS为-1.057 ns的故障定时。
2.复制驱动程序pipeline_en以创建一个新的单元pipeline_en_replica。
3.816个负载在pipeline_en_replica和原始负载之间分配，前者占用386个负载驱动程序pipeline_en，它承担剩余的430个负载。
4.在复制和放置pipeline_en_replica之后，pipeline_en _replica路径的WNS是+0.464ns，并且pipeline_en路径的WNS减少到零。
5.改变了原始驱动程序pipeline_en的位置，以改进基于其减少的一组负载的位置。
交互式物理优化
从2015.3版本开始，物理优化具有“回放”功能使用交互式Tcl命令iphys_opt_design进行优化。iphys_opt_design命令描述特定的优化事件，例如关键单元的复制或者从块RAM中提取一组寄存器。该命令包括所有信息重新创建网表和优化所需的位置更改所必需的发生交互式物理优化可以通过两种方式使用：
•将放置后物理优化应用于放置前网表，以改进整体布局结果并提高设计性能。
•将物理优化保存在Tcl脚本中，以便根据需要重复修改phys_opt_design网表更改涉及改造的设计流程如下图所示。
涉及两个运行，即“原始运行”，其中phys_opt_design在之后运行place_design和“重播运行”，其中执行phys_opt_design网表更改放置之前。在原始运行之后，phys_opt_design优化将使用保存到Tcl脚本文件中Tcl命令write_ iphys_。该脚本包含一系列iphys_opt_design Tcl命令以精确地重新创建由执行的设计更改原始运行中的phys_opt_design。您可以保存当前设计中的优化在内存中或打开实现的设计或检查点之后，其中phys_opt_design已经进行了优化。
重播运行使用相同的设计和约束。在place_design运行之前read_iphys_opt_tcl命令处理iphys_opt_design命令脚本应用原始运行中的网表更改。由于网表的更改，中的设计重播运行可能比原始运行更适合放置。现在的设计在放置之前结合了phys_opt_design优化的好处，例如复制后更少的高扇出网络和来自块RAM输出的更少的长距离路径。与phys_opt_design命令类似，read_iphys_opt_tcl命令具有将重播的设计步骤限制为某些类型的选项，如扇出优化、块RAM寄存器优化和重新布线。
重复phys_opt_design设计更改
重复phys_opt_design设计更改的设计流程如下所示图形
该流程与改造流程在两个方面不同：
•iphys_opt_design更改包含在place_design之后，而不是预先
•布局更改和网表更改都会在iphys_opt_design中捕获Tcl脚本。
通常，您会使用此流来获得对放置后phys_opt_design的更多控制步自定义“配方”是由重播的优化和新的组合创建的优化为探索设计闭包带来了许多可能性。write_iphys_opt_tcl和read_iphys_pt_tcl命令有一个-place选项以回放phys_opt_design中的位置更改。此选项应用于流以在放置之后重复phys_opt_design步骤。
交互式物理优化命令参考
交互式物理优化命令以及相应的选项包括如下所述。
write_iphys_opt_tcl
此命令写入一个文件，其中包含与当前设计中执行的物理优化。
语法：
write_iphys_opt_tcl [-place] [-quiet] [-verbose] &lt;output file&gt; -place选项指示命令将放置信息包括在iphys_opt_tcl命令。当您打算使用网表应用放置时，请使用此选项iphys_opt_design命令重播期间的更改。write_iphys_opt_tcl命令可以在phys_opt_design已运行。read_iphys_opt_tcl此命令读取一个文件，该文件包含与上次运行中执行的物理优化。
语法：
read_iphys_opt_tcl [-fanout_opt] [-critical_cell_opt] [-replicate_cell] [-placement_opt] [ -restruct_opt] [-forward_retime] [-backward_retime] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-shift_register_opt] [-shift_register_to_pipeline] [-auto_pipeline] [-pipeline_to_shift_register] [-critical_pin_opt] [-restruct_opt] [-equ_drivers_opt] [-include_skipped_optimizations] [-create_bufg] [-insert_negative_edge_ffs] [-hold_fix] [-slr_crossing_opt] [-quiet] [-verbose] [&lt;input&gt;] read_iphys_opt_tcl命令具有许多与phys_opt_design相同的选项将重播优化的范围限制为仅指定的优化。这些选项包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a406f88bdf454c9b87a0d6c3db9df0ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ad011799be501a5d3300891505892c/" rel="bookmark">
			一款非常流行的数字音乐工作站软件FL Studio for Mac 21.2.3.3586中文版新功能特色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FL Studio（Fruity Loops）是一款非常流行的数字音乐工作站软件，它可以让用户轻松地制作各种类型的音乐。前不久，FL Studio发布了最新的Mac版21.2.3.3586中文版，这个新版本的发布让广大Mac用户感到非常兴奋。
本文将介绍FL Studio for Mac 21.2.3.3586中文版的一些特点。
首先，FL Studio for Mac 21.2.3.3586中文版具有非常强大的功能。它支持多种音频格式，包括MP3、WAV、OGG等，用户可以使用这些格式导入和导出音频文件。此外，FL Studio还具有强大的MIDI控制功能，用户可以使用MIDI设备控制音乐的制作过程，这使得音乐制作更加简单和灵活。
其次，FL Studio for Mac 21.2.3.3586中文版拥有可自定义的界面，使用户可以将工作区根据自己的喜好进行设置。用户可以使用不同的主题、颜色和布局来创建自己的工作环境，这使得FL Studio非常适合个性化和创意性强的音乐家。
此外，FL Studio for Mac 21.2.3.3586中文版还具有非常实用的插件。它包含了大量的效果器和工具，这些插件可以帮助用户快速制作出高质量的音乐。FL Studio还支持第三方插件，这使得它的功能得到了进一步的扩展，用户可以使用更多的插件来增强音乐的创意性和表现力。
最后，FL Studio for Mac 21.2.3.3586中文版的易用性非常高。它的操作界面非常简洁明了，即使是初学者也可以轻松上手。FL Studio还提供了大量的教程和视频，帮助用户更快地掌握它的使用方法。此外，FL Studio的社区非常活跃，用户可以在社区中获取更多的帮助和支持。
安装方法
1、下载FL Studio21编曲软件，如下图所示：
FL Studio 21.2.3中文破解版链接: https://pan.baidu.com/s/1HX8I_r0gsxWLPAN4BphHtw?pwd=yrn5 提取码: yrn5 ​
FL Studio win版下载地址：https://souurl.cn/POH7Io
FL Studio mac版下载地址：https://souurl.cn/65dJkc FL Studio 解锁序列号使用 （Mac和Win均适用）
FL Studio注册解锁码：
D9TVR-LXH2S-J9YUN-YYAFA
NTYVB-HGMJF-IYTVU-NDJGF
NBVCX-MJHGF-IUYTR-NJGFD ​
2、双击运行“FL Studio.dmg”后再双击“Install FL Studio.pkg”
​
3、进入安装页面，见下图：
​
点击“继续”进行下一步
​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ad011799be501a5d3300891505892c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bea051a54612bdb27ba873c393f6f6a/" rel="bookmark">
			大数据面试题 —— Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 消息队列 / Kafka 的好处消息队列的两种模式什么是 KafkaKafka 优缺点你在哪些场景下会选择 Kafka讲下 Kafka 的整体结构Kafka 工作原理 / 流程Kafka为什么那么快/高效读写的原因 / 实现高吞吐的原理生产者如何提高吞吐量（调优）kafka 消息数据积压，消费者如何提高吞吐量说一下Kafka生产者如何生产数据，消费者如何消费数据Kafka 中的数据是有序的吗，如何保证有序性？指定partition的话，如果发生了数据倾斜，一个key的数据全发到了一个partition会出现什么问题Kafka 中是如何实现消息的有序的Kafka Producer Batchbroker 的工作流程Kafka 的单播和多播生产者消息为什么分区生产者分区策略Kafka分区分配的概念？消费者分区分配策略Kafka 分区数可以增加或减少吗kafka 如果有台机器挂掉会发生什么Kafka在哪些地方会有选举过程，使用什么工具支持选举?Kafka中Producer，Broker，Cousumer的关系Kafka 怎么保证数据不丢失 / 可靠性 ***Kafka解决两个客户端消费数据的问题Kafka分区多副本机制？Kafka数据的一致性如何保证 ***Kafka一个生产者可以把消息发到多个分区吗？Kafka集群为什么挂掉一个broker后还能工作Kafka设置ack=-1时一定会保证消息不丢失吗Kafka Follower如何与Leader同步数据Kafka日志保存时间Kafka单条日志的传输大小Kafka消息的消费方式？Kafka消息存储机制Kafka 的 ISR、OSR 和 AR说下 Kafka 的 ISR 机制Kafka 的 ack 有几种值 / ack 机制Kafka的 offset 管理消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1？如果有一条offset对应的数据，消费完成之后，手动提交失败，如何处理?Kafka为什么同一个消费者组的消费者不能消费相同的分区?正在消费一条数据，Kafka挂了，重启以后，消费的offset是哪一个为什么需要消费者组有哪些情形会造成重复消费有哪些情形会造成消息漏消费当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？Kafka读取消息 Pull 模式的优缺点Kafka的消费者组是如何消费数据的Kafka 消费者是否可以消费指定分区消息Kafka 零拷贝技术kafka服务器默认能接收的最大消息是多少Kafka新建的分区会在哪个目录下创建数据传输的事务有几种Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？Kafka生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？失效副本是指什么？有那些应对措施？kafka 有几种数据保留的策略？聊一聊Kafka Controller的作用？如果我指定了一个offset，Kafka Controller 怎么查找到对应的消息？简述Kafka的日志目录结构？kafka中的 zookeeper 起到什么作用，可以不用zookeeper么Kafka消费者如何消费多分区Raft 消息队列 / Kafka 的好处 （1）缓冲/消峰：有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况；
（2）解耦：允许独立的扩展或修改两边的处理过程，只要确保它们遵守相同的接口约束；
（3）异步通信：允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。
消息队列的两种模式 （1）点对点（一对一）
（2） 发布/订阅（一对多）
什么是 Kafka Kafka是由 Apache 开发的一个分布式的基于发布订阅模式的消息队列，主要应用于大数据的实时处理领域。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bea051a54612bdb27ba873c393f6f6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5219695dacb02deaaec2ad7bb8727908/" rel="bookmark">
			【leetcode&#43;剑指offer】LCR 186. 文物朝代判断（LCR表示剑指offer,原题题干有问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LCR 186. 文物朝代判断: https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/description/
教学-图解算法数据结构：https://leetcode.cn/leetbook/detail/illustration-of-algorithm/
原题（表达有问题，建议直接看解析） 展览馆展出来自 13 个朝代的文物，每排展柜展出 5 个文物。某排文物的摆放情况记录于数组 places，其中 places[i] 表示处于第 i 位文物的所属朝代编号。其中，编号为 0 的朝代表示未知朝代。请判断并返回这排文物的所属朝代编号是否连续（如遇未知朝代可算作连续情况）。
示例 1：
输入: places = [0, 6, 9, 0, 7]
输出: True
示例 2：
输入: places = [7, 8, 9, 10, 11]
输出: True
提示：
places.length = 5
0 &lt;= places[i] &lt;= 13
思路 https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/description/comments/2236358
连续不管在数组中顺序，即[0, 6, 9, 0, 7]是连续是因为 0 6 7 0 9，返回true，
0像扑克牌的赖子，可以替代任何数
不能有重复的数
第一：只有五个数
第二：如果五个数是连续的 比如：1 2 3 4 5 返回true
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5219695dacb02deaaec2ad7bb8727908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a146cb31d7de87a0c05a50458b77e125/" rel="bookmark">
			uniapp rich-text组件在苹果手机上最多显示两行样式失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 rich-text在苹果部分手机上溢出隐藏显示…样式失效的问题
.rich-text-container&gt;rich-text { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; line-height: 48rpx; height: 96rpx; } 完整代码
&lt;view class="rich-text-container"&gt; &lt;rich-text :nodes="content"&gt;&lt;/rich-text&gt; &lt;/view&gt; &lt;script&gt; export default { data() { return { content:'' } } } &lt;/script&gt; &lt;style&gt; .rich-text-container&gt;rich-text { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; line-height: 48rpx; height: 96rpx; } &lt;/style&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/19/">«</a>
	<span class="pagination__item pagination__item--current">20/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/21/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>