<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a7e0c1ee5963e7a227e287a75caca47/" rel="bookmark">
			Hadoop的简介、安装配置和集群搭建（hadoop2.7.7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章内容
框架介绍搭建环境
2.1-2.10 基本设置
2.11 本地运行模式
2.12 伪分布式模式
2.13 完全分布式运行模式 1.框架介绍 1.1 HDFS
NameNode：存储文件的元数据，如文件名，文件目录结构，文件属性，以及每个文件的块列表和块所在的DataNode等。等于就是一个目录，DataNode：在本地文件系统存储文件块数据，以及块数据的校验和。Secondary NameNode：用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS远数据的快照。类似于NameNode的副本。 1.2 YARN框架
ApplicationMaster和Container是非常驻的，有任务才出现，没任务就消失。而NM和RM都是常驻的。
1.3 MapReduce
Map阶段并行处理输入数据Reduce阶段对Map结果进行汇总 大数据的技术生态系统
2.搭建环境 2.1 关闭防火墙 systemctl stop firewalld.service #关闭 systemctl disable firewalld.service #禁止开机自启 2.2 创建一个新用户并设置密码 useradd us passwd us 2.3 在opt文件下创建两个文件夹module和software，并且修改他们的权限 mkdir /opt/software /opt/module #创建文件夹 chown us:us /opt/software /opt/module #修改使用权限 2.4 把创建的的用户增加到sudoers vim /etc/sudoers 在root的下一行输入 us	ALL=(ALL)	NOPASSWD:ALL :wq! #强制保存 下面测试一下是否设置成功
su us #切换到新用户 sudo ls #不报错即为成功 2.5 修改host vim /etc/hosts 增加下面的内容（根据自己的ip）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a7e0c1ee5963e7a227e287a75caca47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701ead1109c6abf611c89435978b32ed/" rel="bookmark">
			ajax获取boolean值并返回的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ajax获取boolean值并返回的坑 问题描述 前台需要通过ajax请求从后台获取一个返回值为boolean的，并且把结果通过调用的函数返回
例如
function check(){
var result = false;
$.post(‘check.do’,’’,function(data){
result = JSON.parse(data);
});
console.log(result);
return result;
}
如果你写过你会发现这样返回的结果一直会有问题的
原因 因为ajax是异步请求，所以还没等到ajax的结果返回就已经往下执行了
解决 既然是因为ajax的异步造成的，那么就关闭异步
function check(){
var result = false;
$.ajaxSettings.async = false;
$.post(‘check.do’,’’,function(data){
result = JSON.parse(data);
});
console.log(result);
return result;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3bdd4853d5b440a9ac7815c6918028f/" rel="bookmark">
			kotlin  中字符串replace操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.xg.myapplication import android.os.Bundle import android.support.v7.app.AppCompatActivity import android.util.Log class kotlinStringActivity : AppCompatActivity() { private val stringreplace = "Kotlin is a very good programming language" override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_kotlin_string) // Kotlin is Y very good progrYmming lYnguYge Log.d("kotlin 替换所有a 变为Y", stringreplace.replace("a", "Y")) //Kotlin is a very good programming languaY Log.d("kotlin 替换掉最后一个a后面所有的字段", stringreplace.replaceAfterLast("a", "Y")) // Kotlin is aY Log.d("kotlin 替换掉第一个a后面的所有字段", stringreplace.replaceAfter("a", "Y")) // Ya very good programming language Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3bdd4853d5b440a9ac7815c6918028f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64180f4a953abbf8eaee0f9bbcfb6baf/" rel="bookmark">
			leetcode 排列硬币
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。
给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围内。
示例 1:
n = 5
硬币可排列成以下几行:
¤
¤ ¤
¤ ¤
因为第三行不完整，所以返回2.
示例 2:
n = 8
硬币可排列成以下几行:
¤
¤ ¤
¤ ¤ ¤
¤ ¤
因为第四行不完整，所以返回3.
链接：https://leetcode-cn.com/problems/arranging-coins
暴力法
class Solution: def arrangeCoins(self, n: int) -&gt; int: rows = 0 num = 0 while True: if num&gt;n: return (rows-1) if num==n: return rows rows += 1 num += rows 二分查找
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64180f4a953abbf8eaee0f9bbcfb6baf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11b6606465b722082832e17235cf6319/" rel="bookmark">
			ggplot2组合绘制多个图形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win.graph() library(ggplot2) library(cowplot) library(showtext) font_add_google("Dancing Script", "Dancing") 图1 plot.iris &lt;- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + geom_point() + facet_grid(cols = vars(Species)) # 按Species列分面 图2 plot.mpg &lt;- ggplot(mpg, aes(x = cty, y = hwy, colour = factor(cyl))) + geom_point(size = 2.5) + labs(title = "dot plot") 图3 plot.diamonds &lt;- ggplot(diamonds, aes(clarity, fill = cut)) + geom_bar() + theme(axis.text.x = element_text(angle = 70, vjust = 0.5)) + labs(title = "bar plot") 组合绘图叠加 gg &lt;- ggdraw() + draw_plot(plot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11b6606465b722082832e17235cf6319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c3bad0c67c9b8ecc3a2080b46b0320/" rel="bookmark">
			枚举及赋值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public enum EnumDemo {
read(0),
blue(1),
green(2);
private int value;
EnumDemo(int value) {
this.value = value;
}
public int getValue() {
return value;
}
}
我们都知道，枚举在不指定值得情况下，系统设置有默认值。如果默认枚举值不满足要求如何修改？关键点在于设置一个变量指定枚举值数据类型，指定构造函数，和get方法。那我要设置为string类型怎么办？真机智，自己尝试修改数据类型试试~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d102daac017d444292a62cc09943eb5/" rel="bookmark">
			k8s在其他用户下报错: /etc/kubernetes/admin.conf  permission denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：最近客户需要回收root权限，需要自己创建audio用户并设置为sudo权限
问题：项目都是用k8s部署的，创建了audio用户并设置了sudo权限之后，切换到audio用户下执行 kubectl get po报错：
error: Error loading config file "/etc/kubernetes/admin.conf": open /etc/kubernetes/admin.conf: permission denied
解决办法：
1、切换至root用户
2、修改admin.conf文件权限chmod 666 /etc/kubernetes/admin.conf
3、再次切换至audio用户，执行kubectl get pods即可正常显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddfb36380a30e73bc244f54dd317c45b/" rel="bookmark">
			ajax返回boolean的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前台ajax请求，后台返回boolean（代码如下）
$.ajax({ type : "post", data : { "xxx" : xxx }, url: "/xxx/xxx.do", success: function (result) { console.log(result); console.log(typeof result); if (result) { alert(true); } else { alert(false); } } }); @RequestMapping("test") @ResponseBody public boolean test() { return false; } 后台返回的Boolean类型，ajax是不认的，会简单的认为是string类型。如果返回 false 也会执行 if (result) 中的逻辑而不是走 else，因为 if('false') 是等于 true 的。
需要将代码修改为如下
$.ajax({ type : "post", data : { "xxx" : xxx }, url: "/xxx/xxx.do", success: function (result) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddfb36380a30e73bc244f54dd317c45b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f92612c9b3e00432f825387a4f9c0c/" rel="bookmark">
			nestjs中typeorm事务操作的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据库中事务操作的必要性 在数据库操作中,如果涉及到多表关联、多表有关系操作的时候,我们就要进行事务处理,以免一张表的数据已经发生了修改,刚好发生了异常,造成另外一张表的数据不进行更新。
常见场景
两张表关联关系同时需要插入、删除数据银行转换一个表数据减少另外一个表的数据增加 二、方式一、隐式commit,隐式rollback 1、控制层的代码
@Post() async create(@Body() data: Extract&lt;CreateUserDto, CreateUserExtendDto&gt;) { return this.userService.create(data); } 2、服务层的代码
async create(data: Extract&lt;CreateUserDto, CreateUserExtendDto&gt;) { const { name, password, email, mobile, gender, qq, address } = data; return getManager() .transaction(async (entityManage: EntityManager) =&gt; { const user: { [propName: string]: any } = await entityManage.save( UserEntity, { name, password, email, mobile, gender, }, ); //throw new Error('主动抛出错误'); await entityManage.save(UserExtendEntity, { userId: user.id, qq, address, }); }) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f92612c9b3e00432f825387a4f9c0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c29dea2d6f98bde52d88ac8ed5bb8c8d/" rel="bookmark">
			《流畅的Python》读书笔记——Python一等函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，函数是一等对象：
在运行时创建能赋值给变量或数据结构中的元素能作为参数传给函数能作为函数的返回结果 把函数视作对象 &gt;&gt;&gt; def factorial(n): #通过控制台会话运行时创建一个函数 ... '''returns n!''' ... return 1 if n &lt; 2 else n * factorial(n-1) ... &gt;&gt;&gt; factorial(42) 1405006117752879898543142606244511569936384000000000 &gt;&gt;&gt; factorial.__doc__ 'returns n!' &gt;&gt;&gt; type(factorial) &lt;class 'function'&gt; #是function类的实例 我们来看下赋值、调用：
&gt;&gt;&gt; fact = factorial &gt;&gt;&gt; fact &lt;function factorial at 0x7f1c69958e18&gt; &gt;&gt;&gt; fact(5) 120 &gt;&gt;&gt; map(factorial,range(11)) &lt;map object at 0x7f1c62361908&gt; &gt;&gt;&gt; list(map(fact,range(11))) [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800] 有了一等函数，就可以使用函数式风格编程。
高阶函数 接受函数为参数，或者把函数作为结果返回的函数是高阶函数。map函数就是的，另外sorted()函数也是：可选的key参数可用于提供一个函数，应用到各个元素上进行排序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c29dea2d6f98bde52d88ac8ed5bb8c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8788f6dc09623c1ad5fff918c1572a9/" rel="bookmark">
			自定义springboot starter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义 springboot starter 上一篇springboot-自动配置原理在最后提了一下，了解了autoConfiguration，离springboot-stater就只差一个demo，好了，最近比较闲，来搞一个demo看看，demo实现了两个功能：
使用Aspectj方式的aop，来实现对某类函数参数监控;定义一个自己的配置类，读取我们在yml或properties里面配置的参数，同时提供一个service，用来获取我们读取的结果。 这里是示例工程starter.
starter 看了自动配置原理之后，应该知道META-INF/spring.facotires这个家伙是配置的重点了吧，我们很多个的东西都是在这个里头。因此，我们自己的stater当然也少不了这个配置文件，先贴个工程结构。
spring-boot-myaop-starter ├─ pom.xml ├─ spring-boot-myaop-starter.iml └─ src/main ├─ java └─ resources └─ META-INF └─ spring.factories AOP部分 先按照正常工程把一些配置都配好，先来写一个AspectJ的。
package com.wt.myaop.aspect; @Aspect @Component public class MyAspect { @Pointcut("@annotation(myAnno)") public void myAspectPointCut(MyAopAnnotation myAnno) { } @Before("myAspectPointCut(myAnno)") public void performanceTrance2(JoinPoint joinPoint, MyAopAnnotation myAnno) throws Throwable { System.out.println("--------------myaop-starter args monitor start-----------------"); Object[] args = joinPoint.getArgs(); Class&lt;?&gt;[] types = myAnno.argTypes(); for (int i = 0; i &lt; Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8788f6dc09623c1ad5fff918c1572a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75fb049741dcae09f75c61584bac1a05/" rel="bookmark">
			Android Studio下的SDK的配置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio下的SDK的配置 方法一 打开软件，点击File-&gt;Setting进入设置界面
搜索框输入SDK，进入Android SDK设置界面
选择图片上标红圈的地方，找到自己要的版本勾选，然后Apply，然后会在线下载，按照提示一路OK，下载完成点击Finish，回到设置界面，再点击OK，即可。
这样就完成了SDK的设置了。
方法二 直接点击下图中标红圈的地方，立马就掉到了Android SDK设置的界面，然后按照方法一种的方法一步一步进行即可完成。
两种方法都比较实用，方法一更多在于除了设置SDK，其他的设置也可以借鉴，方法二只是SDK的快捷方法，所以我觉得方法一更应该了解哟！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4353d29f2d8a69f75358b926e7db1159/" rel="bookmark">
			浅谈vue中key的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue中key的作用：
1、提高vue更新DOM的性能
key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。有相同父元素的子元素必须有独特的key。
2、管理可复用的元素
Vue尽可能高效地渲染元素，通常复用已有的元素，而不是从头开始渲染
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf810d38521e20cc8d2c3c38d478409/" rel="bookmark">
			STM32F0 USB VCP数据发送丢包错位问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近调试用STM32F070 USB VCP发送数据到上位机，每10mS上传6个字节（4位数字+回车换行），从1000开始加1计数，每次发送到1351，就会出现一个空行，接着又从1011开始发送数据，出现丢数据并错位。
此时查看发送缓存变量APP_Rx_ptr_in为64，APP_Rx_ptr_out为58，没有溢出。
查看usbd_cdc_core.c文件中的static void Handle_USBAsynchXfer (void *pdev)函数，发现在575行有一句：if (APP_Rx_ptr_in == 64) APP_Rx_ptr_in=0;
当APP_Rx_ptr_in为64时，直接把发送缓存指针清零了，导致后面的数据丢失，前面的数据又重发了，把这句注释后发送数据就正常了。
难道这是ST官方库固件的bug？是不是注释掉后会有什么其它问题？非常令人困惑。
实在没办法，只能试试ST最新的HAL固件库了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd8287209982fb2275a3b5b1ab59ece/" rel="bookmark">
			Segmentation Fault错误原因总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 什么是“Segmentation fault in Linux”
所谓的段错误就是指访问的内存超过了系统所给这个程序的内存空间，通常这个值是由gdtr来保存的，他是一个48位的寄存器，其中的32位是保存由它指向的gdt表，后13位保存相应于gdt的下标，最后3位包括了程序是否在内存中以及程序的在cpu中的运行级别,指向的gdt是由以64位为一个单位的表，在这张表中就保存着程序运行的代码段以及数据段的起始地址以及相应的断限和页面交换还有程序运行级别和内存粒度等信息，一旦一个程序发生了越界访问，CPU就会产生相应的异常保护，于是segmentation fault就出现了。
即“当程序试图访问不被允许访问的内存区域（比如，尝试写一块属于操作系统的内存），或以错误的类型访问内存区域（比如，尝试写一块只读内存）。这个描述是准确的。为了加深理解，我们再更加详细的概括一下SIGSEGV。段错误应该就是访问了不可访问的内存，这个内存要么是不存在的，要么是受系统保护的。
Ø SIGSEGV是在访问内存时发生的错误，它属于内存管理的范畴
Ø SIGSEGV是一个用户态的概念，是操作系统在用户态程序错误访问内存时所做出的处理。
Ø 当用户态程序访问（访问表示读、写或执行）不允许访问的内存时，产生SIGSEGV。
Ø 当用户态程序以错误的方式访问允许访问的内存时，产生SIGSEGV。
用户态程序地址空间，特指程序可以访问的地址空间范围。如果广义的说，一个进程的地址空间应该包括内核空间部分，只是它不能访问而已。
二、 SIGSEGV产生的可能情况
指针越界和SIGSEGV是最常出现的情况，经常看到有帖子把两者混淆，而这两者的关系也确实微妙。在此，我们把指针运算（加减）引起的越界、野指针、空指针都归为指针越界。SIGSEGV在很多时候是由于指针越界引起的，但并不是所有的指针越界都会引发SIGSEGV。一个越界的指针，如果不引用它，是不会引起SIGSEGV的。而即使引用了一个越界的指针，也不一定引起SIGSEGV。这听上去让人发疯，而实际情况确实如此。SIGSEGV涉及到操作系统、C库、编译器、链接器各方面的内容，我们以一些具体的例子来说明。
（1）错误的访问类型引起
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main(){
char *c = "hello world";
c[1] = 'H';
}
上述程序编译没有问题，但是运行时弹出SIGSEGV。此例中，”hello world”作为一个常量字符串，在编译后会被放在.rodata节（GCC），最后链接生成目标程序时.rodata节会被合并到text segment与代码段放在一起，故其所处内存区域是只读的。这就是错误的访问类型引起的SIGSEGV。
（2）访问了不属于进程地址空间的内存
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;
int main(){ int* p = (int*)0xC0000fff; *p = 10; }　还有一种可能，往受到系统保护的内存地址写数据，最常见的就是给一个指针以0地址；
int i=0; scanf ("%d", i); /* should have used &amp;i */ printf ("%d\n", i);
return 0;　（3）访问了不存在的内存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd8287209982fb2275a3b5b1ab59ece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c29fa1265e15e0a3da8394c29ab0283/" rel="bookmark">
			导入项目：Error:No such property: GradleVersion for class: JetGradlePlugin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error:No such property: GradleVersion for class: JetGradlePlugin
这个的意思是找不到对应的gradle插件，具体要怎么解决呢？
第一种办法：
1.升级最新的android studio，然后就会自动下载，也就是说当前的android studio和导入项目使用android studio版本不一致造成的
第二种办法：
1.修改项目想gradle下面的wrapper下面的gradle-wrapper.properties文件。
将
distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip 修改为，你能运行的版本地址
2.修改项目下的build.gradle文件中的
classpath 'com.android.tools.build:gradle:3.4.1' 为你能运行版本对应的字符串。
然后sysnc或者try again等待下载完成即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/695f767623f1e1bd2bdc605b10a47537/" rel="bookmark">
			STM32F0 硬件I2C驱动调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本以为很快能搞定，结果还是花了大半天，大意地把下面两句合并成一句了：
GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_1);
GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_1);
GPIO_PinAFConfig(GPIOB, GPIO_PinSource6 | GPIOB, GPIO_PinSource7, GPIO_AF_1); //错误写法
下面把代码贴出来，供大家参考，避免浪费时间。
void I2C1_init()
{
I2C_InitTypeDef I2C_InitStructure;
GPIO_InitTypeDef GPIO_InitStructure;
I2C_DeInit(I2C1);
RCC_I2CCLKConfig(RCC_I2C1CLK_SYSCLK);//时钟源设定
RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE); //使能I2C1的时钟
RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_1); //配置PB6 PB7 成第二功能引脚
GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_1);
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
I2C_InitStructure.I2C_AnalogFilter = I2C_AnalogFilter_Enable;
I2C_InitStructure.I2C_DigitalFilter = 0x01;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/695f767623f1e1bd2bdc605b10a47537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b730342cd1a3e15f55a7bf50975f542/" rel="bookmark">
			go mod常用命令 以及 常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接触到go mod，网上查了查资料，这里记录一下。 1 介绍 1.1、go mod是什么 go mod 是Golang 1.11 版本引入的官方包（package）依赖管理工具，用于解决之前没有地方记录依赖包具体版本的问题，方便依赖包的管理。
之前Golang 主要依靠vendor和GOPATH来管理依赖库，vendor相对主流，但现在官方更提倡go mod。
1.2、go mod初始化及使用 下载官方包1.11(及其以上版本将会自动支持gomod) 默认GO111MODULE=auto(auto是指如果在gopath下不启用mod)
Golang 提供一个环境变量 GO111MODULE 来设置是否使用mod，它有3个可选值，分别是off, on, auto（默认值），具体含义如下：
off: GOPATH mode，查找vendor和GOPATH目录on：module-aware mode，使用 go module，忽略GOPATH目录auto：如果当前目录不在$GOPATH 并且 当前目录（或者父目录）下有go.mod文件，则使用 GO111MODULE， 否则仍旧使用 GOPATH mode。 修改 GO111MODULE 的值的语句是：set GO111MODULE=on 。
在使用模块的时候， GOPATH 是无意义的，不过它还是会把下载的依赖储存在 GOPATH/src/mod 中，也会把 go install 的结果放在 GOPATH/bin（如果 GOBIN 不存在的话）
go mod download 下载模块到本地缓存，缓存路径是 $GOPATH/pkg/mod/cachego mod edit 是提供了命令版编辑 go.mod 的功能，例如 go mod edit -fmt go.mod 会格式化 go.modgo mod graph 把模块之间的依赖图显示出来go mod init 初始化模块（例如把原本dep管理的依赖关系转换过来）go mod tidy 增加缺失的包，移除没用的包go mod vendor 把依赖拷贝到 vendor/ 目录下go mod verify 确认依赖关系go mod why 解释为什么需要包和模块 注意有几个坑的地方：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b730342cd1a3e15f55a7bf50975f542/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d377e2c872084064064653e65c80ff/" rel="bookmark">
			对np.shape()的一点理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		np.array()创建时需要几个维度就要用几个[ ]括起来
import numpy as np a=np.array([1,2,3,4]) print(a) print(a.shape) 结果：
[1 2 3 4]
(4,)
如上面所示，只有1个[ ]，也就是只有一个维度，a.shape(4,)表示第一个维度为4
import numpy as np a=np.array([1,2,3,4],[1,2,3,4]) print(a) print(a.shape) 结果：
Traceback (most recent call last):
File "C:/Users/xj/test2.py", line 2, in &lt;module&gt;
a=np.array([1,2,3,4],[1,2,3,4])
TypeError: data type not understood
注意这里报错了，数据类型无法被理解，前面也说了，用array创建时需要几个维度要用[ ]括起来，我们把代码改成
import numpy as np a=np.array([[1,2,3,4],[1,2,3,4]]) print(a) print(a.shape) 结果：
[[1 2 3 4]
[1 2 3 4]]
(2, 4)
被最外围的[ ]包含的List有两对，所以第一维为2，第二维为4
import numpy as np a=np.array([[[1,2,3,4],[1,2,3,4]]]) print(a) print(a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d377e2c872084064064653e65c80ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1b40467dd81c93e3b55f10d1031f0f/" rel="bookmark">
			算术逻辑单元 —— ALU的功能与结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ALU是一种功能较强的组合逻辑电路，它能进行多种算术运算和逻辑运算。ALU的基本结构如下图
最简单的ALU是四位的，如下图所示，74181为4位并行加法器，其4位进位是同时产生的
用4片74181芯片可以组成16位ALU，其片内进位是快速的，但片间进位是逐片传递的，即组内并行、组间串行，是单级先行进位。
若把16位ALU中的每四位作为一组，将74181与74182芯片配合，用类似位间快速进位的方式来实现16位ALU，则能得到16位的两级线性进位ALU，即组内并行、组间并行，是二级先行进位。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/111/">«</a>
	<span class="pagination__item pagination__item--current">112/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/113/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>