<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534ffb99f6ac78343bd7329d7e0289fb/" rel="bookmark">
			java.sql.SQLException: 无效的列索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“无效的列索引”的原因无非以下几个： 1、sql串的?号数目和提供的变量数目不一致： 例如：jdbcTemplate.update(sql, new Object[] {newState,oldState}); 如果sql里面有1个?号，Object[]送了2个，就会报错。 2、sql串里的?号书写不正确 英文?和中文？有时难以区分。 3、sql串的?号用''括了起来。 例如：sql="UPDATE abc SET abc.name='?' WHERE abc.id='?'"; 把''去掉就可以了。 4，遇到这种情况select*from user where info like %?%; 虽然这是sql的写法，但是在jdbc 中需要改成 select*from user where info like ?; 如ps.setString(“%”+value+“%”);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad52a968380c781647496b778921c8dd/" rel="bookmark">
			iOS中，在类的源文件(.m)中，@interface部分的作用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 此@interface部分为类扩展（extension）。 其被设计出来就是为了解决两个问题的，
其一，定义类私有方法的地方。
其二，实现public readonly,private readwrite的property（意思是在h头文件中定义一个属性对外是readonly的，但在类的内部希望是可读写的，所以可以在m源文件中的@interface部分重新定义此属性为readwrite，此时此属性对外是只读的，对内是读写的）。
此外，也可在此部分申明变量和属性，但申明的变量，属性和方法均为私有的，只能够被当前类访问，相当于private。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0a7af6fe9b0d9c34b563bb81c09a01/" rel="bookmark">
			Redis源码分析（十四）——持久化RDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis在系统正常运行情况下，是将数据库数据以数据结构的形式维持在内存中的，为了让这些数据在Redis重启之后以及在系统故障等特殊情况下依然可用，Redis提供了RDB和AOF两种持久化模式。在此介绍RDB模式。
在Redis运行时，RDB程序将内存中的数据按照配置的模式快照保存到磁盘文件中（每次保存的都是服务器中所有非空数据库中的所有键值对以及过期时间等数据），在Redis重启时，RDB程序可以通过载入RDB文件来还原数据库的状态。 该RDB文件的保存和载入过程主要用两个核心函数完成： rdbSave:生成RDB文件保存到磁盘；rdbLoad：将RDB文件中的数据重新载入到内存中。
在进行RDB文件保存或载入过程实际是对内存与磁盘的I/O操作。I/O操作的API函数主要由rio.c/rio.h文件完成。
_rio结构如下：
RIO API 接口和状态 持久化的IO操作 ：内存缓冲buf&lt;——&gt;文件 */ struct _rio { /* Backend functions. * Since this functions do not tolerate short writes or reads the return * value is simplified to: zero on error, non zero on complete success. */ //成功返回非零。失败返回零 size_t (*read)(struct _rio *, void *buf, size_t len); size_t (*write)(struct _rio *, const void *buf, size_t len); off_t (*tell)(struct _rio *);//文件指针移动操作 /* The update_cksum method if not NULL is used to compute the checksum of * all the data that was read or written so far.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f0a7af6fe9b0d9c34b563bb81c09a01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e1a89942248b6afc5a1f014d48ca22/" rel="bookmark">
			数轴点覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数轴上从左到右有n个点a[0],a[1],…a[n-1]，给定一根长度为L的绳子，求该绳子能覆盖几个点。
#include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int MaxCoverCount1(int* arr, int len, int L) { int maxCover = 1, nCurCount; for ( int i = 0; i &lt; len; i++ ) { for ( int j = i+1; j &lt; len; j++ ) { if ( (arr[j]-arr[i]) &lt;= L ) { nCurCount = j-i+1; maxCover = (maxCover&gt;nCurCount)?maxCover:nCurCount; } } } return maxCover; } int MaxCoverCount2(int *a,int n, int L){ if(a==NULL) return 0; int curr=0; int currCover=1; int maxCover=1; int begin=0; for(int i=1;i&lt;n;i++){ if(curr&gt;L){ while(curr+a[i]&gt;=L &amp;&amp; begin&lt;i){ curr=curr-a[begin++]; currCover--; } curr+=a[i]; currCover++; } else { curr+=a[i]; currCover++; } cout&lt;&lt;curr&lt;&lt;endl; maxCover=max(maxCover,currCover); } return maxCover; } int main() { int a[] = {1,10,90,105,150,200,203,250,300}; int Len = 100; cout &lt;&lt; MaxCoverCount1(a,9,Len) &lt;&lt;endl; cout &lt;&lt; MaxCoverCount2(a,9,Len) &lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65fc8d8ff8ca2624f219ef3fd695e677/" rel="bookmark">
			jvm学习笔记--基本结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要来学习jvm的基本结构 知识点1：什么是java虚拟机（你以为你知道，如果你看我下面的例子，你会发现你其实不知道） 第一步：先来写一个类： package test; public class JVMTestForJava { public static void main(String[] args) throws InterruptedException { Thread.sleep(10000000); } } 第二步：cmd窗口输入：java test.JVMTestForJava 第三步：打开任务管理器-进程 你看到一个叫java.exe的程序没有，是滴这个就是java的虚拟机，java xxx这个命令就是用来启动一个java虚拟机，而main函数就是一个java应用的入口，main函数被执行时，java虚拟机就启动了。好了ctrl+c结束你的jvm。 第四步：打开你的ecplise，右键run application，再run application一次 第五步：打开任务管理器-进程 好了，我已经圈出来了，有两个javaw.exe，为什么会有两个？因为我们刚才运行了两次run application。这里我是要告诉你，一个java的application对应了一个java.exe/javaw.exe（java.exe和javaw.exe你可以把它看成java的虚拟机，一个有窗口界面一个没有）。你运行几个application就有几个java.exe/javaw.exe。或者更加具体的说，你运行了几个main函数就启动了几个java应用，同时也启动了几个java的虚拟机。 知识点1总结： 什么是java虚拟机，什么是java的虚拟机实例？java的虚拟机相当于我们的一个java类，而java虚拟机实例，相当我们new一个java类，不过java虚拟机不是通过new这个关键字而是通过java.exe或者javaw.exe来启动一个虚拟机实例。 知识点2：jvm的生命周期 基本上学习一种容器（更具体的说我们在学习servlet的时候），我们都要学习它的生命周期。那么jvm的生命周期如何，我一惯不喜欢丢概念，所以来实验，实践出真知，老师说过的，对不！ 第一步：copy我代码 package test; public class JVMTestLife { public static void main(String[] args) { new Thread(new Runnable() { @Override public void run() { for(int i=0;i&lt;5;i++){ try { Thread.currentThread().sleep(i*10000); System.out.println("睡了"+i*10+"秒"); } catch (InterruptedException e) { System.out.println("干嘛吵醒我"); } } } }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65fc8d8ff8ca2624f219ef3fd695e677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1318413e13b6a91aaaf536c55389b3/" rel="bookmark">
			图像分析：投影曲线的波峰查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文的主要内容来自 Ronny's CV Site，在最后加上自己在实际项目中的应用，显得效果还不错。
一、前言 在图像分析里，投影曲线是我们经常要用到的一个图像特征，通过投影曲线我们可以看到在某一个方向上，图像灰度变化的规律，这在图像分割，文字提取方面应用比较广。一个投影曲线，它的关键信息就在于波峰与波谷，所以我们面临的第一个问题就是找到波峰与波谷。
第一次涉及到求波峰与波谷时，很多人都不以为意，觉得波谷波峰还不容易，无非是一些曲线变化为零的点，从离散的角度来说，也就是:
波峰： F(x)&gt;F(x−1)且F(x)&gt;F(x+1) 波谷： F(x)&lt;F(x−1)且F(x)&lt;F(x+1) 这么简单吗？显示不是，你首先就会遇到这样的曲线图，然后图上的波峰点并不满足上面的条件。
看到这种情况，你也许会考虑在上面的等式中把 &gt; 和 &lt; 改为 ≥ 和 ≤ 。
波峰： F(x)≥F(x−1)&amp;&amp;F(x)&gt;F(x+1) 或者 F(x)&gt;F(x−1)&amp;&amp;F(x)≥F(x+1) 波谷： F(x)≤F(x−1)&amp;&amp;F(x)&lt;F(x+1) 或者 F(x)&lt;F(x−1)&amp;&amp;F(x)≤F(x+1) 这次是否就这样简单，答案显示不是，下面的这个图就会让你对一些非峰值点作出错误的判断。
上面这幅图真正的峰值只有一个，其他平台上的点，你如果按上面修改的公式，就会被错误的当成波峰点。下面让我们看一下，到底如何能求得准确的曲线波峰与波谷。
二、波峰波谷算法 投影曲线实际上是一个一维的向量：
V=[v1,v2,…,vn] 其中 vi,i∈[1,2,…,N] ，代表图像在第 i 行或列上的灰度累积。当然不仅仅是投影曲线， T 也可以是某一事件中变量的观测值，我们需要研究这个变量的变化规律。
下面给出波峰与波谷的算法：
1，假投影曲线可以表示为 V=[v1,v2,…,vn] 。
2，计算V的一阶差分向量 DiffV :
Diffv(i)=V(i+1)−V(i),其中i∈1,2,…,N−1 3,对差分向量进行取符号函数运算， Trend=sign(Diffv) ,即遍历 Diffv ，若 Diffv(i) 大于0，则取1；如果小于0，则取-1，否则则值为0。
sign(x)=⎧⎩⎨⎪⎪⎪10−1if x&gt;0if x=0if x&lt;0
4，从尾部遍历 Trend 向量,进行如下操作：
if Trend(i)=0且Trend(i+1)≥0，则Trend(i)=1if Trend(i)=0且Trend(i+1)&lt;0，则Trend(i)=−1 5，对 Trend 向量进行一阶差分运算，如同步骤2，得到 R=diff(Trend) 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1318413e13b6a91aaaf536c55389b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf11cf7c40cf8b2dfe9698dc2e4bf4b/" rel="bookmark">
			Impala ODBC 安装笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Impala在线文档介绍了 Impala ODBC接口安装和配置 http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/Impala/Installing-and-Using-Impala/ciiu_impala_odbc.html Impala ODBC 驱动下载地址： http://www.cloudera.com/content/support/en/downloads/connectors.html 本文详细讲解了CentOS-6.5-x86_64环境下 Impala ODBC的安装和使用。
一、检查unixODBC是否安装： rpm -qa|grep unixODBC
如果没有安装，使用下面的命令安装：
yum install unixODBC yum install unixODBC-devel
使用odbcinst命令查看unixODBC配置文件路径，不同版本的unixODBC配置文件路径是不同的，如果是源代码方式安装unixODBC，也可以通过编译参数--sysconfdir指定。
[root@h1 ~]# odbcinst -j unixODBC 2.2.14 DRIVERS............: /etc/odbcinst.ini SYSTEM DATA SOURCES: /etc/odbc.ini FILE DATA SOURCES..: /etc/ODBCDataSources USER DATA SOURCES..: /root/.odbc.ini SQLULEN Size.......: 8 SQLLEN Size........: 8 SQLSETPOSIROW Size.: 8 二、安装Impala ODBC驱动 下载ClouderaImpalaODBC-2.5.15.1015-1.el6.x86_64.rpm，保存到：/home/soft 目录，并进行安装：
[root@h1 soft]# ll total 16232 -rw-r--r--. 1 root root 16619934 Aug 24 06:37 ClouderaImpalaODBC-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cf11cf7c40cf8b2dfe9698dc2e4bf4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac83ffd93b0aaead22d075c3da8e5870/" rel="bookmark">
			Windows下配置ftp服务器，使用QT实现文件上传和下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Windows下配置ftp服务器 1.1、windows自带的ftp服务器配置 准备工作：在本地计算机创建一个用户并设置用户密码，后面可以使用这个用户测试ftp是否正确配置并投入使用。创建用户的过程就不啰嗦了，不会的朋友可以去百度如何创建用户。当然这里可以使用本地计算机已经创建的其他用户。 下面介绍配置windows自带的ftp服务器的步骤： 1、打开控制面板，左边有一个“打开或关闭Windows功能”选项，单击该选项，在弹出的窗口中找到 “Internet 信息服务”， 展开可以找到“FTP服务器”并勾选该选项，然后确定即可，估计要等个几分钟才 能安装好ftp服务器。如图所示： 2、右键桌面的“计算机”，选择“管理”（快捷方式：“运行”里面输入“compmgmt.msc”命令，回车即可）， 在窗口的 左边找到“服务和应用程序”选项，选择 “服务和应用程序”下的“Internet信息服务(IIS)管理器”； 3、在第2步弹出的窗口中，在里面嵌套着4个“小窗口”，找到第2个名为“连接”的窗口，右键“网站”选择 “添加FTP站点...”； 在FTP名称中填写ftp服务器的名称：ftp_test（就是个名称，随你填），物理路径： D:\upld（填你需要上传或者下载的目 录路径，这个也是根据需要而填， 不过不能选一个不存在的路径 ） ，填写好了，单击下一步；在窗口中填写服务器的ip 地址（在命令提示符cmd里面输入ipconfig可以知道本 地ip地址），在SSL下选择“允许”，单击下一步；在窗口中，身份认 证中勾选“基本”前面的复选框，授权中 选择“所有用户”； 权限中勾选“读取”和“写入”，两个都要选 ；单击完成，部分图片如下： 4、至此，服务器配置完成！下面即可开始测试ftp服务器了。测试方法，打开浏览器，在地址栏输入 “ftp://192.168.0.50:21”，这里要换成你自己的ip地址，即把192.168.0.50替换成你的ip地址，后面的 21是端口号，是ftp服务器的通用端口号，一般不会被占用。输入地址之后回车，浏览器会弹出一个让 你输入用户名和密码的窗口，填写你在准备工作中添加的用户和密码(不局限，只要能登录服务器端 的windows系统的用户都可以)，测试成功则会显示第三步中设置的物理路径目录下的文件。如下图： 1.2、使用FileZilla作为ftp服务器 FileZilla是一个免费开源的FTP软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。FileZilla软件可以到官网下载：https://filezilla-project.org/，FileZilla的安装和配置我就不一一细说了，你们可以去网上百度FileZilla的安装和配置，方法大同小异。提供一些参考网站：http://jingyan.baidu.com/article/6079ad0e67acf828ff86db3f.html和http://www.jiaocheng8.com/wangzhan/ftp/383.html； 2、使用QT实现文件上传和下载 配置好服务器之后，便可以使用QT或者其他工具实现文件上传和下载了。 关键代码如下： void ftp_upload::upload() { ftp = new QFtp(this); ftp-&gt;connectToHost("192.168.0.50",21); //连接到服务器,填写你的ip地址，这里默认端口号为21 ftp-&gt;login("test","testpasswd"); //登录,填写响应的用户名和密码 //windows自带的ftp服务器，客户端上传文件到服务器 QFile *uploadFile = new QFile("D:/2014.txt");//要上传到服务器的的文件位置：D盘下的2014.txt文档，该文档存在于客户端 QString des = "2014_uploadToServer.txt";//ftp服务器“收到”客户端上传的文档位置：物理路径根目录下的文档2014_upload.txt uploadFile-&gt;open(QIODevice::ReadWrite); ftp-&gt;put(uploadFile,des); //windows自带的ftp服务器，从服务器下载文件到客户端 QFile *download = new QFile("D:/downloadFromServer.txt"); download-&gt;open(QIODevice::ReadWrite); ftp-&gt;get("download.txt",download);//把服务器物理路径根目录下的download.txt下载到本地D盘根目录 } 源码打包csdn下载地址：http://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac83ffd93b0aaead22d075c3da8e5870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa0c4abb99c9dda71b6d5a5607ff6ab/" rel="bookmark">
			初识 Cloudera Impala
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Impala是Cloudera公司主导开发的新型查询系统，它提供SQL语义，能查询存储在Hadoop的HDFS和HBase中的PB级大数据。已有的Hive系统虽然也提供了SQL语义，但由于Hive底层执行使用的是MapReduce引擎，仍然是一个批处理过程，难以满足查询的交互性。相比之下，Impala的最大特点也是最大卖点就是它的快速。Impala 为存储在 HDFS 和 HBase 中的数据提供了一个实时 SQL 查询接口。
Impala优点 下图来自zdnet，描述了Impala的一些优点：
从上图中看出主要的优点：SQL友好，比Hive快，支持多种存储引擎文件格式，接口丰富（ODBC，JDBC，Client），开源，部署容易。
Impala架构 Impala解决方案包含下面几大部分：
Clients：包括 Hue, ODBC clients, JDBC clients, and the Impala Shell Hive Metastore：存放结构定义的元数据，当你创建、删除、修改表结构，或者加载数据到表中时，会自动的通知Impala节点。
Cloudera Impala：运行在数据节点上，分析、调度、执行查询任务，每个Impala实例都可以接收、调度来自客户端的查询，这些查询分发到Impala节点进行查询，Impala节点相当于工作进程，执行查询，并将结果返回。
HBase and HDFS：存储供Impala查询的数据。
下图描述了Impala的架构：
上图中，黄色部分为Impala组件。Impala使用了Hive的SQL接口（包括SELECT、 INSERT、Join等操作），但目前只实现了Hive的SQL语义的子集（例如尚未对UDF提供支持），表的元数据信息存储在Hive的 Metastore中。StateStore是Impala的一个子服务，用来监控集群中各个节点的健康状况，提供节点注册、错误检测等功能。 Impala在每个节点运行了一个后台服务Impalad，Impalad用来响应外部请求，并完成实际的查询处理。Impalad主要包含Query Planner、Query Coordinator和Query Exec Engine三个模块。QueryPalnner接收来自SQL APP和ODBC的查询，然后将查询转换为许多子查询，Query Coordinator将这些子查询分发到各个节点上，由各个节点上的Query Exec Engine负责子查询的执行，最后返回子查询的结果，这些中间结果经过聚集之后最终返回给用户。
Impala进程 从进程的角度看分为如下的三类进程：
The Impala Daemon
是Impala的核心进程，进程名叫做：impalad，运行在所有的数据节点上，可以读写数据，并接收客户端的查询请求，并行执行来自集群中其他节点的查询请求，将中间结果返回给调度节点。调用节点将结果返回给客户端。
The Impala Statestore
状态管理进程，定时检查The Impala Daemon的健康状况，协调各个运行impalad的实例之间的信息关系，Impala正是通过这些信息去定位查询请求所要的数据，进程名叫做statestored，在集群中只需要启动一个这样的进程，如果Impala节点由于物理原因、网络原因、软件原因或者其他原因而下线，Statestore会通知其他节点，避免查询任务分发到不可用的节点上。
The Impala Catalog Service
元数据管理服务，进程名叫做 catalogd，用于广播Impala中DDL、DML语句导致的元数据变化到所有Impala节点，因此新建表、新载入数据、等等操作对于任意节点提交的查询都可见（Impala 1.2之前,你必须在每个节点上执行 REFRESH 或 INVALIDATE METADATA 语句以同步元数据的更新。现在只需要在Hive中执行DDL、DML语句之后再执行这些语句）。
在搭建的CDH5环境上找到了这些进程：
Impala进程分布 hostname进程名称h1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aa0c4abb99c9dda71b6d5a5607ff6ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e411c3bbb6813c47251cb725afc30140/" rel="bookmark">
			11款最好的JavaScript源代码编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码编辑器是一个允许你编辑任何编程语言的源代码的文本编辑器。 它可以是一个独立的应用程序，也可以是内置的一个集成开发环境(IDE)。 有一些源代码编辑器能够在程序员编写程序的时候做语法检查，并在第一时间对其产生的语法问题提出警告； 有一些源代码编辑器可以压缩代码， 将常见的关键词转化为单字节标记，删除不必要的空格，并将数字转换成二进制形式， 当要查看文件时，它会再产生出与以前一致大小和间隔的文件；还有一些源代码编辑器会上述两种功能。 —— 维基百科对源代码编辑器的定义 如果你正在寻找优秀的JavaScript源代码编辑器，那么这11款“网络上评出的最好的JavaScript源代码编辑器”可能会帮到你。
1.CodeMirror - 基于内嵌框架（ iframe ）的可编辑代码编辑器 CodeMirror是一个基于iframe的可编辑源代码编辑器组件 ，它允许你创建类似相对舒适的源代码编辑器接口(代码内容包括HTML、XHTML、XML、CSS、Python、PHP、c#、Java标记以及其它类似的语言）。
Codemirror的特性 ：
自动完成模式覆盖搜索/替换预览HTML编辑器自动调整编辑器大小设置断点语法高亮显示主题化强调独立支持全屏幕编辑模式自动改变 2.Ace - JavaScript编辑器 Ace是一个独立的JavaScript代码编辑器，拥有基于浏览器的代码编辑器相匹配的特性和扩展特性，还拥有目前常见的本地编辑器（如TextMate，Vim或Eclipse）的功能。 用户可以很容易把Ace编辑器嵌入进任何网页或JavaScript应用程序。
Ace JavaScript编辑器的特性：
语法高亮显示自动缩进和凸排可选命令行大文档处理包含VI和Emacs模式的完全自定义关键字绑定主题化 3.CodePress -基于JavaScript的实时语法高亮显示的编辑器 CodePress是基于JavaScript的在线源代码编辑器，它突出的语法高亮特性：只要在浏览器中输入代码，便能够立刻产生彩色语法文本。
CodePress的特性：
实时语法高亮显示代码片段自动完成快捷键可以对相同的页面添加多个CodePress窗口 4. EditArea -免费的JavaScript源代码编辑器 EditArea是一个免费的JavaScript源代码编辑器，它允许开发人员在一个文本区域内编辑源代码文件，主要用于小型文本和轻文本的文本格式、搜索、替换和实时语法高亮显示的开发。
EditArea的特性：
易于集成，只包含有一个脚本和一个函数调用提供列表支持可定制的实时语法高亮显示的编辑器支持自动换行容易搜索和替换对象。新行自动缩进编号线多语言支持多个实例支持PHP gzip压缩全屏模式简单的插件集成提供动态内容管理 5. Helene Helene是一个用JavaScript编写的语法高亮显示的文本编辑器，它可以替代文本的web集成开发环境。
6. MarkItUp ! - 通用的标记编辑器框架 MarkItUp !是一个JavaScript插件， 它允许您将任何文本区域变成一个标记编辑器 。 用户可以很容易用Html、 文本环境、Wiki 语法、Markdown、BBcode甚至他自己的标记系统来实现MarkItUp编辑器。 这是一个非常轻量级的、可定制的和灵活的引擎，满足开发人员在CMS、博客、论坛或网站的需求。
7. 9ne - 在线的语法高亮显示的代码编辑器 9ne是一个在线的源代码编辑器，它支持语法高亮显示和基于Emacs的关键字绑定。
8. Jsvi - 克隆Vi的JavaScript代码编辑器 jsvi是一个基于JavaScript，拥有Vi编辑器所有类似特征的源代码编辑器，包括支持ed/ex的命令、Unicode兼容、实时检查类型拼写错误以及集成host的剪贴板功能。
9. Ymacs – AJAX源代码编辑器 Ymacs是一个与Emacs相似的AJAX源代码编辑器，它支持语法高亮显示和自动缩进的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e411c3bbb6813c47251cb725afc30140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccfc8119f33d09f1db814bd154a7f55c/" rel="bookmark">
			Matlab Coder的使用方法以及VS2010的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于Matlab Coder的使用，在百度经验中讲得很明白：Mhttp://jingyan.baidu.com/article/8065f87fe146332331249898.html
在VS2010的使用中，需要注意的是，自己添加的头文件，需要在VS中自己添加路径，否则会出现打不开头文件的错误。
操作步骤：
项目-》属性-》项目目录 添加进自己编写的头文件所在的路径即可。
复制去Google翻译 翻译结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9bdd2973ed7a77dcc6659aaeec0be33/" rel="bookmark">
			有关“双重检查锁定失效”的说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双重检查锁定（以下称为DCL）已被广泛当做多线程环境下延迟初始化的一种高效手段。
遗憾的是，在Java中，如果没有额外的同步，它并不可靠。在其它语言中，如c++，实现DCL，需要依赖于处理器的内存模型、编译器实行的重排序以及编译器与同步库之间的交互。由于c++没有对这些做出明确规定，很难说DCL是否有效。可以在c++中使用显式的内存屏障来使DCL生效，但Java中并没有这些屏障。
来看下面的代码
01 // Single threaded version 02 class Foo { 03 private Helper helper = null; 04 public Helper getHelper() { 05 if (helper == null) 06 helper = new Helper(); 07 return helper; 08 } 09 // other functions and members... 10 } 如果这段代码用在多线程环境下，有几个可能出错的地方。最明显的是，可能会创建出两或多个Helper对象。（后面会提到其它问题）。将getHelper()方法改为同步即可修复此问题。
01 // Correct multithreaded version 02 class Foo { 03 private Helper helper = null; 04 public synchronized Helper getHelper() { 05 if (helper == null) 06 helper = new Helper(); 07 return helper; 08 } 09 // other functions and members.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9bdd2973ed7a77dcc6659aaeec0be33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91da788cfffc062608ec2e4bffff8c1/" rel="bookmark">
			PLL_setFreq的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PLL_setFreq是一个比较常用的CSL函数，作用是初始化PLL。下面是CSL库的参考指南：
函数原型：void PLL_setFreq (Uint16 mode, Uint16 mul, Uint16 div0, Uint16 div1, Uint16 div2,Uint16 div3, Uint16 oscdiv);(本函数只适合C5502):
参数说明：
Uint16 mode //PLL模式：PLL旁路模式、PLL非旁路模式
Uint16 mul //倍频系数，取值范围2到15
Uint16 div0 //系统时钟0的分频系数, 取值范围0到31（对应1分频到32分频）
Uint16 div1 //系统时钟1的分频系数, 取值为0，1和3（对应1分频，2分频，和4分频）
Uint16 div2 //系统时钟2的分频系数, 取值为0，1和3（对应1分频，2分频，和4分频）
Uint16 div3 //系统时钟3的分频系数, 取值为0，1和3（对应1分频，2分频，和4分频）
Uint16 oscdiv //DSP核心时钟分频系数,取值范围0到31（对应1分频到32分频）
这个太抽象，直接看原理框图理解得深入一点：
从图中可以看出，所谓旁路PLL模式就是获得的时钟不经过PLL，所以控制该位的寄存器又叫PLLEN（即使能PLL），其他的分频器、倍频器，所处的位置一目了然。
例如：PLL_setFreq(1, 0xC, 0, 1, 3, 3, 0);//PLL模式开启，如果外部时钟为20MHz，经过D0不分频，经过mul的12倍倍频，再经过D1不分频，得到系统的快速时钟为240MHz，若果经过D2的4分频就得到慢速时钟为60MHz，同理得到EMIF时钟是60MHz
复制去Google翻译 翻译结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e53894a8a6c2c4b37a563fe2cbe44d7/" rel="bookmark">
			simulink的相关东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1，Random Integer Generator :
M-ary : 表示，产生的值在0到M-1之间
Sample time： 当仿真时间设置为t时，产生的数据量为t/(sample time);
samples per frame: 以帧为单位输出时，每一帧数据的数据量。举例：当如上图，sample time为0.01时，仿真时间设置为100s时，此时，产生的数据量为10000个，当sample per frame为100时，此时，帧数为100.
2，有的时候需要这样一个模块：Rate Transition。
3，注意这一组模块的用法： GoTo 和From
4，Raised Cosine Transmit Filter和 Raised Cosine Reciever
5，可以把计算步长改小一些
6，关于Probe：
主要作用是观测，可以观测信号的宽度，采样时间 ，复数信号的数量 信号的维数，检测信号帧数
复制去Google翻译 翻译结果 1 ， 随机 整数 发生器： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ff0df8ed866e6aae440701a261e8bf2/" rel="bookmark">
			easyui datagrid rowediting使用心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前不久使用了easyui的tree，现如今换了项目组，居然整个页面都是使用easyui的，而今我写的模块需要rowediting，有了easyui-tree的使用，我多少对easyui有了一定的了解，在使用rowediting的时候也算的上是熟路，但是奈何框架是封装的框架，有好多规则需要遵守，最后无奈的发现我不是轻车了，可谓之“重车熟路”。
言归正传，使用easyui，必须要把其需要的js、css都准备好了，这个就不多说了，需要的官网上下载。在官网上给的demo中已经有的基本使用的发放了。调用方式如下代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Row Editing in DataGrid - jQuery EasyUI Demo&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="../../themes/default/easyui.css"&gt; &lt;link rel="stylesheet" type="text/css" href="../../themes/icon.css"&gt; &lt;link rel="stylesheet" type="text/css" href="../demo.css"&gt; &lt;script type="text/javascript" src="../../jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../../jquery.easyui.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Row Editing in DataGrid&lt;/h2&gt; &lt;div class="demo-info"&gt; &lt;div class="demo-tip icon-tip"&gt;&lt;/div&gt; &lt;div&gt;Click the row to start editing.&lt;/div&gt; &lt;/div&gt; &lt;div style="margin:10px 0;"&gt;&lt;/div&gt; &lt;table id="dg" class="easyui-datagrid" title="Row Editing in DataGrid" style="width:700px;height:auto" data-options=" iconCls: 'icon-edit', singleSelect: true, toolbar: '#tb', url: 'datagrid_data1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ff0df8ed866e6aae440701a261e8bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6352888e66ea0cf48c7deed48bb5aca9/" rel="bookmark">
			C&#43;&#43; 指针与作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++中的指针操作是一个令人抓狂的问题，这几天在温习林锐的《高质量C++C编程指南》，里面的内存管理这一章对我受益匪浅。看到下面的一段内容，不禁和作者提出相同的疑问：该程序不出错是因为编译器的原因吗？并在网上查找相关资料。
源码1：
#include &lt;iostream&gt; using namespace std; class A { public: void Func(void) { cout&lt;&lt;"Func of class A"&lt;&lt;endl; } }; void Test(void) { A *p; { A a; p = &amp;a; // 注意 a 的生命期 } p-&gt;Func(); // p是“野指针” } int main() { Test(); return 0; } 为了探索这个问题，我分别在CodeBlocks、VC++6.0和VS2010上运行这段代码，发现并无错误，所以，这个并非编译器的原因，那么到底是什么原因呢？
1、我们知道在Test函数中内部用花括号括起来的部分是一个局部作用范围，因此，该语句块拥有局部的作用域，在里面定义的局部对象a，是一个存放在栈中的自动变量，一旦离开了这个作用域（离开花括号），就不复存在了。可以通过简单的单步调试，跟踪对象a的变化，实践证明，这个想法是对的。
2、一般来说，一个对象所占的空间大小只取决于该对象中数据成员所占的空间，而与成员函数无关。通过下面一段代码可以验证
源码2：
#include &lt;iostream&gt; using namespace std; class A { int i; char chr; }; class B { int i; char chr; void fun() { int j = 1; cout&lt;&lt;j&lt;&lt;endl; } }; int main() { A a; B b; cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6352888e66ea0cf48c7deed48bb5aca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/281af5d0b3058f290ce2fa182f69f6a3/" rel="bookmark">
			批处理文件——多个QQ一键登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		偶然看到有的同学登录PC的QQ，发现他有很多QQ，每登录一个要切换一个，虽然记住了密码，但还是不方便，于是想通过批处理来实现“一键登录”的功能。以下内容为作者的假想，如有雷同，实属巧合！
具体的实现步骤如下：
(1)首先，查看QQ安装时的文档位置（用于保存用户登录历史记录），我的是：C:\Users\David\Documents\TencentFiles\All Users\QQ；如图1所示：
图1 数据信息所在目录
(2)目录下有三个后缀名为db的文件：
History.db是一个存放所有历史登录记录的表，该表是有序的，第一个记录就是客户端最近一次登录的QQ用户；
Perfre.db则是实际登录的QQ用户，每次打开客户端，都会从History.db中取出第一个记录（即第一个QQ用户）存入Perfre.db并登录，里面保存的是一个用户的信息；
Registry.db保存的应该就是Perfre.db中保存的登录用户的信息，包括QQ头像，登录设置（代理，端口号，自定义图像和好友列表等用户信息），如下图所示：
图2 登录客户端 图3 设置信息窗口
(3)三者的执行顺序简介：在启动QQ.exe应用程序的时候，首先就是加载History.db文件，于是在客户端可以看到我们之前在本地PC所登录的所有历史记录；其次，动态创建Perfre.db文件，从History.db文件取出第一个QQ用户记录信息，保存在Perfre.db文件中；Registry.db文件也是动态生成的，它根据Perfre.db文件中的用户唯一标识符，在Misc文件夹(图1所示)下找到此用户的代理，端口号，自定义图像和好友列表等用户信息，最后登录，后面还要检验密码什么的就不在本博文的研究范围内了。
(4)既然这样，我们就可以写一个bat批处理脚本来实现多个QQ用户同时登录了，当然，这也是一个一劳永逸的办法，刚开始比较麻烦一点。
1) 在"C:\Users\David\Documents\TencentFiles\All Users\QQ "文件夹(这里每个人的文件夹可能不一样)分别创建文件夹1、2、3、……(要登录几个QQ就创建几个)；
2) 登录第一个QQ，输入账号密码，勾选自动登录。登录成功后，将History.db文件剪切到文件夹1；
3) 登录第二个QQ，同上，将History.db文件剪切到文件夹2，依次类推，直到所有登录的QQ所创建的History.db文件都备份好；
4) 在任何地方创建一个QQlogin.bat批处理文件，该脚本代码如下：
del "C:\Users\David\Documents\Tencent Files\All Users\QQ\History.db" copy "C:\Users\David\Documents\Tencent Files\All Users\QQ\1\History.db" "C:\Users\David\Documents\Tencent Files\All Users\QQ\History.db" start D:\Progra~1\Tencent\QQ\Bin\qq.exe ping 127.0.0.1 -n 7 del "C:\Users\David\Documents\Tencent Files\All Users\QQ\History.db" copy "C:\Users\David\Documents\Tencent Files\All Users\QQ\2\History.db" "C:\Users\David\Documents\Tencent Files\All Users\QQ\History.db" start D:\Progra~1\Tencent\QQ\Bin\qq.exe ping 127.0.0.1 -n 7 del "C:\Users\David\Documents\Tencent Files\All Users\QQ\History.db" copy "C:\Users\David\Documents\Tencent Files\All Users\QQ\3\History.db" "C:\Users\David\Documents\Tencent Files\All Users\QQ\History.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/281af5d0b3058f290ce2fa182f69f6a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4f75ac24d748e6612719ec8ff4f97b/" rel="bookmark">
			SplitContainer容器控件左右Panel大小调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新建一个Winform窗体，从上图中选择SplitContainer空间，拖拽到Form到上，如下图：
2、你会发现，随便点击Panel1或者Panel2,会显示出粗框，但怎么调整两个Panel的大小呢？两个Panel之间的那条线，是选不中的，哈哈，不信可以试试。
那么如何才能调整两个Form的大小呢？
==》随便单击一个Panel，再按一下Esc，会出现下图：
这时，可以选择中间的那条线来调整界面的大小了。（对于容器类的处理貌似都应该是这样，通过Esc键来处理）
小注：
Winform调试中，Esc键可以用来查找，控件的下层是哪个控件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55a7c3f3bd5c887d8a2bedd175fbc029/" rel="bookmark">
			BerkeleyDB同名key值（Duplicate Key）的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，我们要知道一个概念：duplicate keys,也就是说：在同一个库中多条记录共享一个key。在建库的过程中，如果存在多条同名的记录对应不同data时，就要用到这个东东了。例如某公司职工数据库里，以员工的名字作为记录的key，同时有好几个名叫Jackey的员工，这时就要用到同名key值的概念了。 注意：duplicate keys只能在二进制树以及hash表格式的库中。 启用duplicates应该在建立数据库的时候用DB-&gt;set_flags()来设置。有DB_DUP及DB_DUPSORT两种标志。前者不 使数据库duplicate keys自动排列,而后者利用DB-&gt;set_dup_compare()指定排列函数后，支持自动排列功能，该排列函数的格式为： int (*function)(DB *db, const DBT *key1, const DBT *key2); ` 看一个代码片段： DB *dbp; DBC *cursor; DBT key, data; db_create(&amp;dbp, NULL, 0); dbp-&gt;set_flags(dbp, DB_DUP);//或者DB_DUPSORT dbp-&gt;open(dbp, NULL, file_name, NULL, DB_BTREE, DB_CREATE, 0); 这样，新键的数据库就有对duplicate keys的支持。 支持duplicate key的库的写入与一般的库没有什么区别，用DB-&gt;put写入时，记录会被排在库的最后； dbp-&gt;put(dbp, NULL, &amp;key, &amp;value, 0);//flag不可为DB_NOOVERWRITE 当用DBC-&gt;put()写入时，可以用到下面几个用于加入duplicate记录的标志宏： DB_BEFORE；DB_AFTER //当前加入记录的key与游标当前指向的记录的key一致。直接将该记录作为duplicate记录加到当前记录的前\后面。当库的标志为DB_DUPSORT时，该标志无用。 DB_KEYFIRST;DB_KEYLAST //如果该记录的key值在库中已经存在，且库的定义为DB_DUP(即不自动分类)时,该记录被加到所属key的duplicate列表的最前\后面。 需要说明的是，带duplicate keys支持的库，当你用普通的DB-&gt;get()来读取记录的时候，取得的是指定key值对应的第一个data，要取得后面一些data的时候，需要用到游标DBC-&gt;c_get。请看下面的代码片段： DB *dbp; DBC *cursor; DBT key, data; db_create(&amp;dbp, NULL, 0); dbp-&gt;open(dbp, NULL, file_one, NULL, DB_HASH, DB_CREATE, 0); dbp-&gt;cursor(dbp, NULL, &amp;cursor, 0); /***对key与value进行初始化空间***/ cursor-&gt;c_get(cursor, &amp;key, &amp;value, DB_SET); //游标指到第一个符合key值的记录。 cursor-&gt;c_get(cursorp, &amp;key, &amp;data, DB_NEXT_DUP); //查找下一个该key对应的记录。 这里有几个c_get常用的flag: DB_SET; //游标指向第一个符合key的记录。 DB_SET_RANGE; //支持模糊查找，游标指向第一个大于等于key值的value DB_NEXT; DB_PREV; //下\上一条记录（将duplicate记录也作为记录看待） DB_GET_BOTH；//前者游标指向key、value值都匹配的记录； DB_GET_BOTH_RANGE; //后者支持模糊查找，游标指向与key、value值最接近的第一条记录。 DB_NEXT_NODUP; DB_PREV_NODUP; //下\上一条记录（将duplicate排除在外） DB_NEXT_DUP；//下一条duplicate记录。 删除duplicate key记录: 当你用普通的DB-&gt;del()来删除某条记录的时候,如果该库是带duplicate key支持的,并且你在函数中指定的key值又恰好对应着多个data(即duplicate组),那么你这个操作将把这个duplicate组中所有记录全部删除.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55a7c3f3bd5c887d8a2bedd175fbc029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfaedcccaaa1ad1ee2aef0c876cc01f/" rel="bookmark">
			[转]session listener的配置和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在web.xml中增加listener的配置信息 &lt;listener&gt; &lt;listener-class&gt; com.SessionListener(实现session监听器接口的类的名字，包也要写上) &lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt; com.AnotherSessionListener(有多个session监听器的时候，加多个&lt;listener&gt;) &lt;/listener-class&gt; &lt;/listener&gt;
在JDK1.5和1.6的javax.servlet.http包中，可以看到session的监听器接口有4个，
分别是： HttpSessionListener
HttpSessionAttributeListener
HttpSessionBindingListener
HttpSessionActivationListener
要使用这些session的监听器，必须建立一个实现这些监听器接口的类，并在web.xml中配置这个类或者在会捆绑到session中的对象中实现监听器接口。
1. HttpSessionListener ：在WEB应用中，当一个session被创建或销毁时启用这个监听器。
HttpSessionListener接口定义了两个方法：void sessionCreated(HttpSessionEvent se)和void sessionDestroyed(HttpSessionEvent se)，每个方法都接受一个HttpSessionEvent对象作为参数。（实现类要提供一个无参数的构造函数）
官方英文说明：Implementations of this interface are notified of changes to the list of active sessions in a web application. To receive notification events, the implementation class must be configured in the deployment descriptor for the web application.
package com;
public class SessionListener implements HttpSessionListenter {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cfaedcccaaa1ad1ee2aef0c876cc01f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/130/">«</a>
	<span class="pagination__item pagination__item--current">131/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/132/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>