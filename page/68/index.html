<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76d99136588e9812f8675d4b29f0078/" rel="bookmark">
			python参数引用传递踩坑实录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题描述 写字符串全排列的时候，预期res变量应当返回所有全排列组合。
def check(nums, ind, res): if len(nums) == ind: res.append(nums) return for i in range(ind, len(nums)): nums[i], nums[ind] = nums[ind], nums[i] check(nums, ind + 1, res) nums[i], nums[ind] = nums[ind], nums[i] res = [] check([1, 2, 3], 0, res) print(res) 但是结果却是：
结果怎么和想象中不太一样…在函数内打印看看
def check(nums, ind, res): if len(nums) == ind: print(nums) res.append(nums) return for i in range(ind, len(nums)): nums[i], nums[ind] = nums[ind], nums[i] check(nums, ind + 1, res) nums[i], nums[ind] = nums[ind], nums[i] res = [] check([1, 2, 3], 0, res) print(res) 打印结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f76d99136588e9812f8675d4b29f0078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d185b6e5956ee1569d1216a96a14793/" rel="bookmark">
			继承中super关键字的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 super到底是什么呢？ super关键字出现在子类中，我们new子类的实例对象的时候，子类对象里面会有一个父类对象。怎么去引用里面的父类对象呢？
使用super来引用，所以可以得出结论：
super主要的功能是完成子类调用父类中的内容，也就是调用父类中的属性或方法。 super是解决：当子类重写父类的方法后，子类对象将无法直接访问父类被重写的方法。
super的使用： 调用父类成员变量
super.成员变量
调用父类成员方法
super.成员方法（[参数1，参数2，......]）
super调用属性和方法 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."。
当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。
当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。
super调用构造器 我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器。
"super(形参列表)"的使用，必须声明在子类构造器的首行。
我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现。
在构造器的首行，没有显式的声明"this(形参列表)“或"super(形参列表)”，则默认调用的是父类中空参的构造器：super()。
在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器。
super调用父类的无参数的构造方法 创建子类对象的时候(调用子类构造方法)，无论如何都会调用到父类的构造方法。
一个类如果没有显示的继承一个父类，则默认继承自Object顶级父类。
super关键字的使用方法解析： 一位Java从入门到放弃的准程序员 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc6193b97819201d79a0ca8b8d8f062a/" rel="bookmark">
			在mac系统上安装anaconda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		anaconda是包管理器和环境管理器，使用它可以方便地创作
在anaconda官网上下载安装包，下载链接：
Anaconda | Anaconda Distribution
下载后是一个pkg文件，双击安装，按照步骤一步一步往下操作。
安装成功的页面：
安装完成后，就可以看到anaconda图标啦，双击打开，界面是这样的：
运行Spyder，可以开始编写代码啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/992a0c70dac0a37ac489c6b56dcde6db/" rel="bookmark">
			【服务器数据恢复】服务器RAID0&#43;1数据恢复案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器数据恢复环境：
4个磁盘组成RAID0+RAID1。
服务器故障&amp;分析：
根据用户描述这是两组raid1。RAID状态显示3快盘offline。如果如用户所说的两组盘都是做的raid1，现在应该有一组逻辑盘可以正常工作，但是事实并不是这样。
服务器数据恢复过程：
1、把硬盘单独接到SCSI适配器，进入系统后没有发现异常，也没有发现比较明显的raid信息区域。比较之后发现1、3号盘及2、4号盘每组都有相同性，但后面有大量不一致的数据。1号盘和2号盘有分区表，从每个分区表里的描述可以判断出原逻辑盘分区的总大小。
2、通过上面的检测结果，服务器数据恢复工程师推测这2组raid莫非是两组RAID0？但1、3号及2、4号均有部分完全相同的数据，这不符合2组RAID0的特征。
3、假设这2组RAID是RAID1+0（即两两做RAID1，再做RAID0）。两组RAID1中先后有一块硬盘离线（此后就相当于RAID0，再不能提供冗余），然后又有一块硬盘离线，系统崩溃。
4、假设这2组RAID是RAID0+1（即两两做RAID0，再做RAID1）。如果是这种情况，除了1、3组成的RAID，没有任何错误，重组数据直接写回RAID，系统正常可以启动，文件访问也正常。
5、但是在对第二种假设（RAID0+1）进行验证的时候发现这都是两年前的数据。难道是用户做了RAID0+1，组成RAID1的其中一组RAID0中有一块盘离线（应该为1号磁盘或3号磁盘），导致整个RAID0离线（两块磁盘都离线）。之后一直以单RAID0的方式工作（这种工作方式持续了两年多）。直到剩下的一组RAID0中有一块磁盘离线，RAID彻底崩溃。用户使用的RAID卡无法安全缓冲数据，最后离线时，因部分数据未写入等原因导致文件系统一致性出现问题。
6、重新组织3号磁盘及5号磁盘，修正错误，数据恢复完成。
服务器数据安全Tips:
1、重要的数据不要存储在单盘上，组建一组RAID是比较好的数据存储方式。
2、一定要做好备份，备份包不要放到同一存储媒介上。即使存放在同一媒介也不要放到同一分区下。
3、硬盘出现故障后千万不要反复尝试各种恢复或者修复的操作，最需要做的就是尽快对故障硬盘做完整备份。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f39e9d3b575610955e042b2bb0a760/" rel="bookmark">
			linux clickhouse 密码设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认密码 clickhouse 安装好之后，系统默认的登录账号密码是 /etc/clickhouse-server/users.d/default-password.xml 文件中配置的，默认密码是 SHA256加密算法生成，由 password_sha256_hex 标签定义，所以不输入密码时会发生如下报错：
ClickHouse client version 22.8.4.7 (official build). Connecting to localhost:9000 as user default. If you have installed ClickHouse and forgot password you can reset it in the configuration file. The password for default user is typically located at /etc/clickhouse-server/users.d/default-password.xml and deleting this file will reset the password. See also /etc/clickhouse-server/users.xml on the server where ClickHouse is installed. Code: 516. DB::Exception: Received from localhost:9000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f39e9d3b575610955e042b2bb0a760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e821782437aad30b55577c0bb9380c45/" rel="bookmark">
			warning C4819最简单解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码中存在不是utf-8编码的内容，第一步，先去掉中文，如果还不行，则可能是某个空格或者table不对，推荐使用notepad++转格式。如下图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8edf8fd20e87b5e2d086024b96818176/" rel="bookmark">
			【虚拟机数据恢复】VMware ESX SERVER数据恢复案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机数据恢复环境：
中*化某省分公司的信息管理平台，几十台VMware虚拟机（ESX SERVER）共享一台IBM存储。
虚拟机故障&amp;分析：
正常工作时候vc上报告虚拟磁盘丢失，管理员ssh到ESX中执行fdisk -l命令查看磁盘，发现STORAGE分区表丢失找不到了。重启所有设备，ESX SERVER均无法连接到那台IBM存储所在的STORAGE。于是联系我们数据恢复中心进行数据恢复。
管理员在和北亚服务器数据恢复工程师沟通过程中提到曾经在这个存储网络中连接过一台windows server服务器，具体情况不详。服务器数据恢复工程师初步判断可能是接入的那台windows server服务器对storage独享操作从而导致vmfs卷损坏。
数据恢复工程师对整个存储进行分析发现分区表清零，但是有55aa有效结束标志和硬盘ID标志。进一步查看发现了一个似乎没有写入数据的NTFS卷，好像刚刚被格式化过。对这个NTFS卷的BITMAP做分析，其大小和发生故障前所有虚拟机占用的总空间大小差不多。这个NTFS卷前部占用了部分空间，3G左右位置占用了部分空间，0.9T位置占用了部分空间，但总占用空间不到100M。
分析VMFS卷发现在原磁盘里有2组VMFS分区，第2组是对第1组的extend，因NTFS分区并未写数据到第2组VMFS分区里，所以重点在于第一组VMFS分区。分析第1组VMFS发现卷头结构丢失，一级索引和二级索引均存在，NTFS覆盖的数据区正好是某组虚拟机的临时内存镜像，即使损坏也没有影响。
虚拟机数据恢复过程：
1、对整个STORAGE进行镜像备份。
2、连接两个VMFS分区，按照VMFS分析组织方式提取所有VMDK及配置文件。
3、通过nfs直接迁移回ESX SERVER。
*已对故障存储做了安全备份，可以直接重建第1组VMFS卷头、索引列表、分区表等信息，然后直接附加在ESX SERVER环境，这个方案可以做备选方案。
数据恢复总结：
本案例中故障依然是光纤环境互斥不当造成的。应该是这个卷在WINDOWS系统做了重新分区，并格式化成了NTFS，之后又对分区做了删除操作。因ESX VMFS的互斥不依赖于硬件，而是依赖于操作系统驱动层，所以在其他服务器接入存储网络时一定要小心，需要提前考虑好存储的分配权限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc87cc39a90531aa173008fe98c5399/" rel="bookmark">
			Navicat 荣获「Microsoft 金牌合作伙伴」殊荣，彰显一流的技术能力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​近日，Navicat 凭借自身过硬的技术能力，在微软合作伙伴网络计划考核中获得高度认可，荣获 Microsoft 金牌合作伙伴称号。被授予的 Microsoft 金牌认证合作伙伴能力充分表明自身在 Microsoft 技术方面具有高水平的能力和专业知识，并且具备部署特定 Microsoft 业务解决方案的一流能力。可见，Navicat 是值得信赖的数据库工具供应商以及数据库开发管理技术领域的专家。
作为Microsoft的金牌合作伙伴以及数据库管理开发工具领军者。早在2011年，Navicat 凭借在数据库管理开发领域的技术研发能力，推出支持SQL Server 数据库的管理开发工具。 在Navicat 畅销产品中，Navicat Premium 与 Navicat for SQL Server均可为 SQL Server 数据库管理和开发提供全方位的图形化的解决方案。旨在帮助用户快速轻松地创建、编辑和删除所有数据库对象，运行 SQL 查询和脚本。同时，它们也支持连接任何本地或远程 SQL Server，并与Microsoft Azure云数据库以及多种主流云数据库Amazon RDS、阿里云、腾讯云和华为云兼容。另外，Navicat Premium除了支持SQL Server 数据库，还赋予单一应用程序同时连接和管理其他6种主流数据库，包括：MySQL、MariaDB、MongoDB、Oracle、PostgreSQL 和 SQLite 数据库，极大地满足用户多场景多数据库部署和管理需求。
除了「Microsoft 金牌合作伙伴」的头衔，Navicat 凭借多年积累和技术钻研，依靠产品的易用性、功能性、稳定性、可靠性和用户满意度，多年来，Navicat屡获业内权威机构颁发的重要奖项。近期，Navicat 又蝉联了database两项数据库潮流产品奖项：
1、Navicat 被评为 DBTA 100 2022 - 最重要的数据公司。它表扬那些正在改进和扩展现有技术和流程以帮助其客户更有效地使用数据的公司。​​​​​​​
2、Navicat 被评为 2022 年数据库趋势和应用程序（DBTA）引领潮流产品。该奖项授予那些致力于创新并力求为企业组织提供工具以应对不断变化的市场需求的公司。
我们很高兴地看到，Navicat 的能力不仅受到像微软这样的大厂的肯定，还受到业界许多权威媒体/机构的高度认可。但荣誉是对过往努力的肯定，而技术的发展是无止境的。所以，Navicat 团队将继续发扬勇于技术创新和专研精神，深耕数据库管理开发工具领域，致力于帮助全球数据库开发人员不断提升工作效能，最终为企业和个人降低运营成本与时间。
往期回顾 Navicat 被投毒了 | 真相来了！
盗版引发设备瘫痪
Navicat 16.1 为OceanBase 社区版
Navicat 成为信通院数据库创新实验室成员
Navicat 学术伙伴计划 - 免费教育版申请
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acc87cc39a90531aa173008fe98c5399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50277f96ca0ee95c99074c61c93fa98/" rel="bookmark">
			Vue-获取组件($root-$parent-$children-$refs)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 $root$parent$children$ref $root 表示当前组件树的根 Vue 实例，即new Vue({…根组件内容})。
如果当前实例没有父实例，此实例将会是其自己。
Vue子组件可以通过$root属性访问父组件实例的属性和方法
原理：再入口文件main.js中对Vue的原型设置一个属性并绑定vm对象,后面的子组件都能访问这个根节点
//main.js中 var vm=new Vue({ render: h =&gt; h(App), }).$mount('#app') Vue.prototype.myroot=vm //box1中 &lt;template&gt; &lt;div&gt; &lt;button @click="fn"&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { fn() { console.log(this.$root) console.log(this.myroot) console.log(this.myroot === this.$root) }, }, } &lt;/script&gt; 点击打印：
$parent 和$root 类似，$parent property 可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。
$children 子组件:$children // 数组
$children表示当前实例的直接子组件。需要注意$children并不保证顺序，也不是响应式的。如果正在尝试使用$children来进行数据绑定，考虑使用一个数组配合v-for来生成子组件，并且使用Array作为真正的来源
$ref 尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 这个 attribute 为子组件赋予一个 ID 引用。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50277f96ca0ee95c99074c61c93fa98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad6249219db225d4208c6895b3fbf42/" rel="bookmark">
			补码的加减法运算及溢出判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机当中我们通常需要使用补码来进行二进制数字的加减法运算 首先先写出补码加减法运算的规则：
[X+Y]补=[X]补+[Y]补 即补码的和等于和的补码
[X-Y]补=[X]补+[-Y]补 这个是将减法转换成加法的形式这也是使用补码在计算机中进行减法运算的好处可以将减法转换成加法这样就会有助于计算机的运算。
这里列出补码运算的两个结论:
1.用补码表示的两个数进行运算得到的结果也是补码
2.符号位和数值位一样参与运算
关于如何求一个数的补码我在之前的文章里提到过原码 反码 补码 移码_用编程写诗的博客-CSDN博客
我们知道由于在计算机中储存的位数是一个确定的值所以我们知道补码的表示是有范围的一个n+1位的补码（含有一个符号位）它的表示范围是-2^n~2^n-1。所以我们在进行加减法的时候就会出现超出所能表示范围的数字。只有同号数相加才会出现溢出的现象例如两个负数相加或者两个正数相加只有这一种可能会出现溢出的现象。发生溢出这种事情对计算机很不友好会导致自动关闭软件甚至设备停机的后果，所以我们要避免这种现象的发生。
关于溢出的判断一共有三种方法：
1.根据符号位进行判断
当符号相同的两个数进行运算算出的得数跟原来的两个数符号位不相同则发生溢出。
fa fb表示两个操作数的符号位 fs表示运算结果的符号位 fs和fa,fb不一致则发生了溢出
2.根据符号位进位和数值位最高位进位来判断
由于在运算过程中符号位也是在参与运算的，所以符号位也会发生进位。如果符号位和数值位都没有进位或者都有进位那么我们说这个是没有溢出的否则我们说这个是发生溢出了。
3.最后一个也是最重要的一个采用双符号位的方式来进行的判断
我们知道在补码中是存在一个符号位的，这里采用双符号位的方式也就是“变形补码”的形式。原补码的符号位是什么这个双符号位就是什么例如：补码符号位是1那么双符号位就是11反之亦然。在运算过程中双符号位也是参与运算的，如果算出结果的双符号位是不一致的那么我们说这个是溢出的如果算出的双符号位是相同的那么我们说这个是没有溢出的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5152fb021ebe9c0474167c3ace5374e/" rel="bookmark">
			IDEA 之常用插件（提高开发效率）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Presentation AssistantFree Mybatis pluginLombokMaven HelperCamelCase (下划线转驼峰)Alibaba Java Coding GuidelinesAiXcoder Code Completer(代码提示补全)GenerateAllSetterGenerateSerialVersionUIDGitToolBox（每一行代码Git的用户和日期）Key promoter X(帮助记忆快捷键)Translation(翻译工具)CodeGlance(缩略图插件)Rainbow Brackets(区分括号嵌套层级)Nyan progress barSequenceDiagram（一键生成时序图）SonarLint（帮你优化代码）炫酷Sao操作 Presentation Assistant —快捷键展示
Free Mybatis plugin 插件名： Free Mybatis plugin
功能：
提供Mapper接口与配置文件中对应SQL的导航编辑XML文件时自动补全根据Mapper接口, 使用快捷键生成xml文件及SQL标签ResultMap中的property支持自动补全，支持级联(属性A.属性B.属性C)快捷键生成@Param注解XML中编辑SQL时, 括号自动补全XML中编辑SQL时, 支持参数自动补全(基于@Param注解识别参数)自动检查Mapper XML文件中ID冲突自动检查Mapper XML文件中错误的属性值支持Find Usage支持重构从命名支持别名自动生成ResultMap属性 使用方法：
Lombok Maven Helper 分析依赖冲突插件
使用方式：
打开项目中的pom文件，在底部会显示一个“Dependency Analyzer”
CamelCase (下划线转驼峰) 快捷键：ctrl+shift+u，可以进行大小写的转换，并不能满足开发的需求。
IntelliJ IDEA提供了CamelCase很方便的工具插件，使用快捷键：alt+shift+u。
按住alt+shift再不停的按U，会把选中内容的单词的下划线转驼峰转大写等，不停的转换，会得到你想要的。
Alibaba Java Coding Guidelines 阿里巴巴代码规范检查插件。
插件名： Alibaba Java Coding Guidelines
功能： 代码规范检查。
使用方法： 在你需要检查的代上面，点击右键，选择编码规约扫描。
将会出现如下所示的检查结果，并会给出编码规范和提示：
AiXcoder Code Completer(代码提示补全) 插件名： AiXcoder Code Completer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5152fb021ebe9c0474167c3ace5374e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3134e5f08672ce8ad692ee9839e1310/" rel="bookmark">
			simulink与modelsim联合仿真buck闭环设计 主电路用simulink搭建，控制电路完全有verilog语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		simulink与modelsim联合仿真buck闭环设计
主电路用simulink搭建，控制电路完全有verilog语言实现（包括DPWM,PI补偿器)
适用于验证基于fpga的电力电子变换器控制，由于控制回路完全由verilog语言编写，因此仿真验证通过，可直接下载进fpga板子，极大缩短了开发数字电源的研发周期。
buck变换器指标如下：
(额定输入电压) Vin-&gt;20,
(最大输入电压) Vin_max-&gt;25,
(最小输入电压) Vin_min-&gt;15,
(输出电压)Vo&gt;10,
(开关频率)fs-&gt;50*10^3,
(输出功率)Po-&gt;100,
(最小占空比)Dmin-&gt;0.1,
(额定占空比)D -&gt;0.5,
(最大占空比) Dmax-&gt;0.6,
(额定输出电流) Io-&gt; 10
包括：buck主电路以及控制回路设计文档，仿真文件。
以及simulink与modelsim的联合仿真调试说明文档。
ID:78999651044433674玩电的和尚
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f888b63d4f2026713e8ae17c67d16d55/" rel="bookmark">
			Unity编辑器扩展： 程序化打图集工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始前的声明：该案例中图集所使用图片资源均来源于网络，仅限于学习使用
一、前言 关于编辑器扩展相关的知识，在前面的两篇内容中做了详细的描述，链接地址：
第一篇 ：Unity编辑器扩展 UI控件篇
第二篇 ：Unity编辑扩展：功能篇之Json数据编辑器
前两篇着重于介绍编辑器界面扩展相关控件接口的使用方式。作为系列文章的第三篇，会更偏重于引擎内编辑器扩展承担 的提升开发效率的功能模块设计
通过程序化打图集减少工作量的同时可以稳定全局的管理图集，避免随着项目膨胀手动管理产生资源上的混乱。从图集整个生命周期来说，对于图集管理通常需要下面的模块支持：
程序化图集打包UI界面引用图集检测工具图集资源自动/手动加载、卸载框架支持 本篇文章介绍第一部分，即图集程序化打包的逻辑执行
1、关于图集 官方文档对精灵图集的描述：
在2D 项目使用精灵和其他图形来创建其场景的视觉效果。这意味着单个项目可能包含许多纹理文件。Unity 通常会为场景中的每个纹理发出一个绘制调用。但是，在具有许多纹理的项目中，多个绘制调用会占用大量资源，并会对项目的性能产生负面影响
精灵图集 (Sprite Atlas) 是一种将多个纹理合并为一个组合纹理的资源。Unity 可以调用此单个纹理来发出单个绘制调用而不是发出多个绘制调用，能够以较小的性能开销一次性访问压缩的纹理。此外，精灵图集 API 还可以控制如何在项目运行时加载精灵图集
图集对性能开销的正向影响：
从文档描述中可以看出，图集主要在两方面影响影响性能开销：
第一，减少绘制调用，即提升合批数量，减少Draw Call
从文档的描述可以看出，图集概念出现与渲染的绘制调用相关,衡量绘制调用通常以Draw Call数量为标准。而在Unity中UI合批策略，不同的Image控件要执行合批必须要有相同的材质、Texture。为了满足该条件，将一些小图合并成为大图片，就可以在渲染时，尽可能的一次性的将渲染数据提交给GPU
第二，合理的图集打包策略利于资源的压缩
在前面的性能优化文章中有提到过，某些压缩策略通常只会对规则大小的图片资源生效。如下图提示，当导入的图片资源非2倍数时，引擎会弹出对应警告信息。Unity引擎对Texture资源的常用的DXT压缩处理需要满足其宽度与高度的必须为4的倍数（这是因为DXT压缩策略是以4X4的像素块为基本单位做处理）
而对于图集而言，其尺寸设定策略时基于是以2的次方为基本数值，即图集是可以执行压缩的。而资源的压缩无疑会提升资源的载入速度
图集对性能开销的负面影响：
如果图集使用不当，也可能会额外占用大量的内存，举例来说，如果当前界面只使用了某一图集中很小的一张图片，却不得已将整张图集加载到内存中。亦或者说由于打入图集的Sprite的尺寸不合理，使得图集产生大量的空白，产生额外的性能消耗
2、Unity中图集打包方法 在Unity中手动打出图集的方法，在之前的文章有描述，这里稍微做一些描述，如果想了解详细的操作过程，可以查看该文章，链接地址：
Unity 将Sprite打包进图集
Sprite Packer：
在2020.1或更早的版本中，Unity提供了Sprite Packer图集纹理的生成和使用方法。相比于其他的打图集方式，Sprite Packer是封装性较高的方式。通常只会对相应的Sprite预设好指定图集标签。后续图集本身的资源管理基本由引擎自设定。这样做的优势可以减少开发者的工作量，但同时也牺牲了开发者对资源管理的灵活性。而不同项目的资源利用策略的不同又很需要这样的灵活性来定制
Sprite Atlas：
通过Sprite Atlas打出图集会生成对应的序列化配置文件，并且在资源面板是可见与可编辑的，可以灵活的控制图集资源的载入与卸载，当然也可以默认使用Unity自设定的加载与删除策略
动态图集：
动态图集是相对比较高阶的打图集解决方案，由于Unity没有提供与之对应的处理方法，意味着要自己实现一套集合动态资源管理、高效的图集生成算法等等
抛弃实现难度，动态图集目前是对于某些动态UI元素（如王者荣耀英雄头像）界面少有的解决方案
二、代码结构 在对图集的理论知识做完解释后，开启核心的程序设计阶段。后面的内容主要集中于对图集程序化过程的代码解释，主要是路径围绕编辑器内资源的遍历查询、创建删除与对图集打出参数操作方面的功能模块做设计
1、数据结构设计： 该图集生成工具的编辑器的界面操作逻辑不是很复杂，不过也需要维护一个简单的数据类。来记录编辑的缓存数据
除了一些常规的标识ID字段与简单的资源索引字段。稍微需要注意的是，在于对本地文件索引后SpriteAtlas的对象的直接保存在某些操作后造成索引丢失而出现空引用。所以这里的atlas字段会指向本地资源的实例话数据的缓存，来避免指向丢失，影响后续的数据操作
public class AtlasData { public string atlasName; public string assetPath; /// &lt;summary&gt; /// 缓存中的SpriteAtlas，不直接指向本地资源 /// &lt;/summary&gt; public SpriteAtlas atlas; public List&lt;Sprite&gt; sprites; //编辑器界面数据 public bool isShowDital; } 2、获取某文件夹下的所有符合图集生成规范的Sprite类型的资源： 通过遍历该文件夹下所有文件（不包括子文件下的文件），并筛选出满足条件的Sprite文件，得到该路径文件夹下的Sprite列表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f888b63d4f2026713e8ae17c67d16d55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76b0d69327212ea0ca39cae98919a48/" rel="bookmark">
			postMessage，addEventListener， 前端跨域请求之js代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们今天讲讲postMessage，addEventListener，实现跨域信号发送和监听；废话不多说，直接上代码，有码有真相。
Site A:
function sendTo(token){ if (token) { var url="https://192.168.0.150:44328/thc/index"; var targetWin='_blank'; var feature="width="+ (screen.availWidth - 10) +",height="+(screen.availHeight - 30)+",scrollbars=1,resizable=1"; var popWinHelp=openWin(url,targetWin,feature); popWinHelp.focus(); var postData = { "sign":0, "token":token } this.timeOfmsg = setInterval(() =&gt; popWinHelp.postMessage(postData, "*"), 1000); window.addEventListener("message", receiveMessage, false); } } function receiveMessage(){ alert("Got it"); if (event.data.sign == 1) { //from Site B if (event.data.msg === 'getMsg' &amp;&amp; event.data.sign == 1) { //alert("post message complate, close the timer."); clearInterval(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c76b0d69327212ea0ca39cae98919a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbdfb458a4dca8c9ad8939f8d529aad/" rel="bookmark">
			黑盒测试思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑盒测试
概念 关注程序外部结构，不考虑内部逻辑结构，只注重执行结果和外部特性注重软件的功能性需求，主要针对软件界面和软件功能进行测试基本思路 黑盒测试是以用户的角度，以输入数据与输出数据的对应关系出发进行测试的，又称数据驱动测试黑盒测试是在程序外部接口进行的测试黑盒测试发现的主要类型 输入输出错误初始化或终止性错误功能遗漏或者不正确界面错误性能不符合要求数据库和其他外部数据结构访问错误安全性错误黑盒测试用例设计方法 等价类划分 等价类 是指某个输入域的子集合 在该子集合中，各个输入数据对于揭露程序中的错误都是等效的测试某等价类的代表值就等价于对这一类其他值的测试有效等价类 对于软件规格说明来说，合理的、有意义的输入数据构成的集合无效等价类 对于软件规格说明来说，不合理的、无意义的输入数据构成的集合步骤 1、划分等价类（有效等价类和无效等价类） 按双边区间划分按取值划分按单边区间划分按限制条件/规则划分2、建立等价类表，等价类进行编号3、通过等价类导出测试用例 编号唯一尽可能多的覆盖尚未覆盖的有效等价类仅覆盖一个无效等价类覆盖所有的有效和无效等价类测试用例设计法 弱等价类测试 弱一般等价类 至少覆盖一次，取值不组合，不考虑异常区域策略 对于有效输入，取每个有效等价类的一个值不取无效等价类弱健壮等价类 取值不组合，要考虑异常区域，这是传统的等价类测试策略 对于有效输入，取每个有效等价类的一个值对于无效输入，测试用例将拥有一个无效值，并保持区域的值是有效的强等价类测试 强一般等价类 取值组合，不考虑异常区域，测试用例的设计时需要考虑等价类之间的相互作用，选取等价类的笛卡尔积的元素值来实现策略 对于有效输入，取每个有效等价类的一个值对于无效输入不考虑强健壮等价类 取值组合，考虑异常区域。这种测试也考虑到了从无效等价类取值，同时考虑多个等价类之间的互相影响策略 从所有的等价类笛卡尔乘积中选取（组合）边界值测试法 概念 是对输入或输出的边界值进行测试他作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界步骤 1、确定边界情况、2、选取测试数据3、导出测试用例测试用例设计法 一般边界条件测试用例设计法 每次保留程序中的一个变量，让其余的变量取正常值，被保留的变量依次是min、min+、nom、max-，max对程序中每个变量重复健壮性边界条件测试用例设计法 每次保留程序中的一个变量，让其余的变量取正常值，被保留的变量依次是min-1、min、min+、nom、max-，max、，max+对程序中每个变量重复最坏边界条件测试用例设计法 所有的变量均可取min、min+、nom、max-，max这五个边界值的任何一个测试用例为五个集合的笛卡尔积健壮最坏边界条件测试用例设计法 所有的变量均可取所有的变量均可取min、min+、nom、max-，max这七个边界值的任何一个测试用例为七个集合的笛卡尔积错误推测法 概念 基于经验、问题分析和直觉推测程序中可能存在的各种错误前提 需要测试人员具有一定的经验软件常见缺陷 1、对输入数据没有限制和校验2、对单次数据查询的结果集大小没有约束3、网站页面执行错误时会将服务器的调试信息显示在页面上程序执行时易错情况 1、对空数据表执行删除记录操作2、重复删除记录3、添加两条相同的记录4、采用空字符串进行登录应用 登陆测试错误推测法 (1 )采用空字符串进行登录。(2)采用空格字符串进行登录。(3)输入的登录名和密码前后存在空格是否能够正常登录。(4)登录时输入SQL代码进行注入式攻击，会不会被拦截。(5)输入的密码是否加密显示。(6)密码能否复制和粘贴。(7)用户在注销之后是否能够马上再次登录。(8)是否允许同一账号在不同的客户端重复登录。(9)用户名和密码是否区分大小写。( 10)是否明确提示用户名错误或者明确提示密码错误。( 11 )是否能够较为容易地对账号和密码进行暴力破解。数据库操作测试错误推测法 (1 )对空数据表执行删除记录操作。(2)重复删除记录。( 3)添加两条相同的记录。(4)无条件查询能否执行。(5)查询的关键字之间是否可用连接符，是否能输入SQL代码。(6)输入正确的查询条件，并在前面加上空格，看查询是否能正确地执行。(7)是否支持模糊查询，对模糊查询有没有限制。(8)数据操作出错后的提示会不会泄露敏感信息。缺点 无法保证测试的覆盖率，通常不宜单独使用判定表法 用处 能够把复杂的问题按各种情况一一列举，简明易于理解，可避免疏漏适合处理针对不同的逻辑条件的组合值分别执行不同操作的数据处理问题组成 条件桩：列出问题的所有条件动作桩：列出所有可能的操作条件项：列出各个条件的具体取值动作项：列出在各个条件的具体取值下，应该采取的具体的动作判定表 也称决策表，是一个用来表达条件和行动的二维表，是分析和表达多逻辑条件下不同操作的情况的工具可以清晰地表达条件、决策规则和应采取的行动之间的逻辑关系判定表很适合描述不同条件集合下采取行动的若干组合的情况判定表驱动法 或决策表法，是根据需求描述建立判定表后，导出测试用例的方法在所有黑盒测试方法中，基于判定表的测试是最为严格、最具有逻辑性的测试方法可以设计出完整的测试用例集合判定表的类型 有限条目判定表 特点:所有条件都是二值条件C真/假)扩展条目判定表 特点:条件可以有多个值判定表的建立步骤 1、确定规则的条数2、列出所有的条件桩和动作桩3、填入条件的不同取值组合4、填入具体动作，得到初始判定表5、化简，合并一些具有相同动作的相似规则 约束：另外两个条件取当前值的前提下结果与第三个条件无关合并后的条件项用符号“—”表示，说明执行的动作与该条件无关，也称无关条件适合使用判定表驱动法的条件 (1 )程序规格说明以判定表形式给出，或很容易转换成判定表。(2)条件的排列顺序不会也不影响执行哪些操作。(3)规则的排列顺序不会也不影响执行哪些操作。(4)每当某一规则的条件已经满足，并确定要执行的操作后，不必检验别的规则。(5)如果某一规则得到满足 要执行多个操作，这些操作的执行顺序无关紧要。因果图法 用法 当被测对象的输入条件相互依赖、相互制约的时候，适合用因果图法进行测试概念 因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法因果图提供了一个把需求转化为判定表的系统化方法因果图法最后生成的就是判定表，它适合于检查程序输入条件的各种组合情况因果图的关系符号 因果图的四种基本关系 恒等 恒等:若原因出现，则结果出现;若原因不出现，则结果也不出现。父主题 非(~ ) 非(~ ):若原因出现，则结果不出现;若原因不出现，则结果出现或(V) 或(V):若几个原因中有一个出现，则结果出现;若几个原因都不出现，则结果不出现与(N) 与(N):若几个原因都出现，结果才出现:若其中有一个原因不出现，因果图的基本图形符号因果图的约束符号 因果图的五种约束类型 E约束(互斥) (1)E约束(互斥):表示不同时为1，即a、b、c中至多只有一个1:I约束(包含) (2)I约束(包含):表示至少有一个1，即a、B、c中不同时为0;0约束(唯一-) (3)0约束(唯一-):表示a b、c中有且仅有一一个1;R约束(要求) (4)R约束(要求):表示若a=1，则b必须为1。即不可能a=1日b=0M约束( 屏蔽) （5）输出的约束只有M约束( 屏蔽):若结果a是1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fbdfb458a4dca8c9ad8939f8d529aad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b1234c24d09db53d26734b98e08a3dd/" rel="bookmark">
			图像平滑简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像平滑简介
图像平滑从信号处理的角度看就是去除其中的高频信息。因此我们可以对图像实施低通滤波。低通滤波可以去除图像中的噪声，对图像进行平滑。
根据滤波器的不同可分为均值滤波，高斯滤波、中值滤波、双边滤波。
2.1均值滤波
采用均值滤波模板对图像噪声进行滤除。令Sxy表示中心在(x,y)点，尺寸为m x n的矩形子图像窗口的坐标组。均值滤波器可表示为：
由一个归一化卷积框完成的。它只是用卷积覆盖区域所有像素的平均值来代替中心元素。例如，3X3标准化的平均过滤器如下所示： 均值滤波的优点是算法简单，计算速度快，缺点是在去噪的同时去除了很多细节部分，将图像变得模糊。
API：
Cv.blur(src,ksize,anchor,borderType)
参数：
src:输入图像
Ksize:卷积核大小
Anchor：默认值（-1，-1），表示核中心
borderType:边界类型
示例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f62dffb5b601f54a63c312516cfa2f90/" rel="bookmark">
			CentOS下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1、CentOS下载镜像地址2、选择安装包 1、CentOS下载镜像地址 官网地址：https://www.centos.org/
阿里镜像站：https://mirrors.aliyun.com/centos
清华镜像源：https://mirrors.tuna.tsinghua.edu.cn/centos/
CentOS搜狐镜像：http://mirrors.sohu.com/centos/
CentOS网易镜像：http://mirrors.163.com/centos/
CentOS北京理工大学镜像：http://mirror.bit.edu.cn/centos/
2、选择安装包 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9667c731508ad347ccf4a2fcd6830a77/" rel="bookmark">
			WPF 八（ UserControl 与 CustomControl区别总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UserControl vs CustomControl区别 UserControl
将多个WPF控件(例如：TextBox，TextBlock，Button)进行组合成一个可复用的控件组；
由XAML和Code Behind代码组成；
不支持样式/模板重写，其不支持重写是自己本页面不支持重写，但是页面内可以嵌套自定义控件；
由一个xaml和对应的后台组合而成
继承自UserControl；
下面创建的一个RGBControl由3个TextBlock，3个TextBox，1个Rectangle组成。我们可以在WPF的任意窗体/Page上面复用该UserControl。
XAML Code: &lt;Grid Background="LightGray"&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition /&gt; &lt;RowDefinition /&gt; &lt;RowDefinition /&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width="*" /&gt; &lt;ColumnDefinition Width="*" /&gt; &lt;ColumnDefinition Width="2*" /&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;TextBlock Text="Red" /&gt; &lt;TextBlock Text="Green" Grid.Row="1" /&gt; &lt;TextBlock Text="Blue" Grid.Row="2" /&gt; &lt;TextBox Text="{Binding Red, UpdateSourceTrigger=PropertyChanged}" VerticalContentAlignment="Center" Grid.Column="1" Height="25" Width="80" Margin="0,5" /&gt; &lt;TextBox Text="{Binding Green, UpdateSourceTrigger=PropertyChanged}" VerticalContentAlignment="Center" Grid.Row="1" Grid.Column="1" Height="25" Width="80" Margin="0,5" /&gt; &lt;TextBox Text="{Binding Blue, UpdateSourceTrigger=PropertyChanged}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9667c731508ad347ccf4a2fcd6830a77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/733417650f8400741c13ab2bbd880af5/" rel="bookmark">
			深度学习——Batch Normalization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 通过前面的实验，可以看到不同的激活函数通过设置不同的权重初始值，学习的效果不一样，好的学习效果的标准是各层的激活值的分布有适当的广度。
如果“强制性”的调整激活参数的分布（在选择了合适的权重参数初始值情况下），进而使得各层有适当的广度。于是乎就引出了接下来的内容——Batch Normalization算法
Batch Normalization 的算法 优点：
①增加学习率
②对不同的激活函数不再过度依赖权重的初始值
③减轻过拟合
————————————————————————————————
算法的思路：
要向神经网络中插入对数据分布进行正规化的层，即Batch Normalization层。
数学式表示如下：
ε是一个微小值（比如，10e-7）
通过（6.7）式，会得到一组 均值为0、方差为1的数据x1，x2…Xm。在激活函数前后执行此操作，可以减小数据分布的偏向。
接下来对正规化后的数据进行缩放和平移变换。
γ和β是参数。一开始γ = 1，β = 0，然后再通过学习调整到合适的值。
Batch Norm算法在神经网络上的计算图如下；
对Batch Normalization 效率的评估 使用Batch Norm层和不使用 Batch Norm层的学习过程变化，实验代码如下。
import sys, os sys.path.append(os.pardir) # 为了导入父目录的文件而进行的设定 import numpy as np import matplotlib.pyplot as plt from dataset.mnist import load_mnist from common.multi_layer_net_extend import MultiLayerNetExtend from common.optimizer import SGD, Adam (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True) #减少学习数据 x_train = x_train[:1000] t_train = t_train[:1000] max_epochs = 20 train_size = x_train.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/733417650f8400741c13ab2bbd880af5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1cf294cd79efd070933d66752354eb9/" rel="bookmark">
			java利用数组和位运算构建bitmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class BitMap { private char[] bytes; /** * 定义最大值 */ private int nbits; public BitMap(int nbits) { this.nbits = nbits; this.bytes = new char[nbits / 16 + 1]; } public void set(int k) { if (k &gt; nbits) { return; } int byteIndex = k / 16; int bitIndex = k % 16; bytes[byteIndex] |= (1 &lt;&lt; bitIndex); } public boolean get(int k) { if (k &gt; nbits) { return false; } int byteIndex = k / 16; int bitIndex = k % 16; return (bytes[byteIndex] &amp; (1 &lt;&lt; bitIndex)) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1cf294cd79efd070933d66752354eb9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/67/">«</a>
	<span class="pagination__item pagination__item--current">68/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/69/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>