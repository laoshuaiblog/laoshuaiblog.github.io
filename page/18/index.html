<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5579e48a2d85ab9f7a6e461ee81cd60/" rel="bookmark">
			ASP.NET中的GridView和DataList控件：功能、应用与比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、GridView控件
三、DataList控件
四、GridView与DataList的比较
五、结论
一、引言 ASP.NET是微软公司开发的一款强大的Web应用程序开发框架，它提供了丰富的控件库，使得开发人员能够更快速、更高效地构建功能强大的Web应用程序。其中，GridView和DataList是两个常用的数据绑定控件，它们具有不同的特性和应用场景。本文将对这两个控件进行详细介绍和比较。
二、GridView控件 GridView控件是ASP.NET中用于展示表格数据的强大工具。它支持数据绑定，能够将数据源（如数据库、XML文件等）中的数据以表格的形式呈现在Web页面上。GridView控件具有丰富的配置选项，允许开发人员自定义表格的外观和行为。例如，可以设置表格的列数、列宽、列标题等；还可以添加分页、排序、编辑和删除等功能。此外，GridView控件还支持事件处理，开发人员可以为其添加事件处理程序以响应用户的操作。
GridView控件的优点在于其简单易用且功能强大。通过简单的配置和代码编写，开发人员即可快速实现数据的展示和处理。然而，GridView控件的灵活性相对有限，对于复杂的布局和样式需求，可能需要结合其他技术或控件来实现。
三、DataList控件 DataList控件是ASP.NET中另一个用于数据绑定的控件，它提供了更灵活的数据展示方式。DataList控件可以根据数据源中的记录动态生成HTML元素（如表格、列表等），并将数据填充到这些元素中。与GridView控件不同，DataList控件允许开发人员自定义数据项的模板，从而实现更丰富的布局和样式。此外，DataList控件还支持嵌套数据绑定，可以展示具有层次结构的数据。
DataList控件的优点在于其高度的灵活性和可定制性。开发人员可以根据需求自定义数据项的模板和样式，实现各种复杂的布局和交互效果。然而，相对于GridView控件，DataList控件的使用可能更为复杂，需要更多的代码和配置。
四、GridView与DataList的比较 GridView和DataList控件在功能和应用场景上存在一定的差异。GridView控件更适合用于展示简单的表格数据，其简单易用且功能强大的特点使得它成为许多开发人员的首选。而DataList控件则更适合用于展示具有复杂布局和样式需求的数据，其高度的灵活性和可定制性使得它能够满足各种个性化的需求。
在选择使用GridView还是DataList控件时，开发人员需要根据具体的需求和项目特点进行权衡。如果需求较为简单且追求快速开发，那么GridView控件可能是一个更好的选择；如果需求复杂且需要高度定制化的布局和样式，那么DataList控件可能更为适合。
五、结论 GridView和DataList作为ASP.NET框架中的两个重要控件，各自具有独特的功能和应用场景。通过深入了解它们的特性和优缺点，开发人员可以更好地选择和使用这些控件，以提高Web应用程序的开发效率和用户体验。在未来的Web应用程序开发中，随着技术的不断进步和需求的不断变化，GridView和DataList控件将继续发挥重要作用，为开发人员提供强大的支持和帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e49a0a654bba8c3fb0dbfa59f89087/" rel="bookmark">
			数据结构：9、二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上堆中已经介绍了什么是二叉树，所以这里直接写二叉树实现。
1、二叉树的构建 二叉树的构建第一步肯定是初始化，也就是构建这棵树，这里是利用前序遍历构建的，因为这里是利用链表形式创建的二叉树，所以这里就是和之前文章一样，先是申请地址的函数，紧接着就是递归去申请空间，因为构建的树是字符型，所以这里在#号停下构建并且递归返回，销毁也是递归销毁，因为左节点和右节点最后肯定为空，所以可以直接判断这两个节点，代码如下
//申请地址 BTNode* BuyNode(BTDataType* a) { BTNode* newnode = (BTNode*)malloc(sizeof(BTNode)); if (newnode == NULL) { perror("malloc fail"); return NULL; } newnode-&gt;data = *a; newnode-&gt;left = NULL; newnode-&gt;right = NULL; return newnode; } // 通过前序遍历的数组"ABD##E#H##CF##G##"构建二叉树 BTNode* BinaryTreeCreate(BTDataType* a,int* pi) { if (a[*pi] == '#') { (*pi)++; return NULL; } BTNode* root = BuyNode(&amp;a[*pi]); (*pi)++; root-&gt;left = BinaryTreeCreate(a, pi); root-&gt;right = BinaryTreeCreate(a, pi); return root; } // 二叉树销毁 void BinaryTreeDestory(BTNode* root) { if (root == NULL) return; BinaryTreeDestory(root-&gt;left); BinaryTreeDestory(root-&gt;right); free(root); } 2、二叉树的前序遍历 这个前序遍历就是按照根左节点右节点的形式去打印数据当判断到当前地址为空时也就是说这个节点到头了，就可以直接返回接着递归了，所以这种就是打印前序遍历的，代码如下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24e49a0a654bba8c3fb0dbfa59f89087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18358d864befbdeb94d8484f24b4536/" rel="bookmark">
			Python的内建比较函数cmp比较原理剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的cmp()函数用于比较两个对象的大小。
cmp( x, y)：比较2个对象，前者小于后者返回-1，相等则返回0，大于后者返回1.
Python的cmp比较函数比较原理
Python的cmp函数可以比较同类型之间，或者不同数据类型之间。然后根据Python的cmp比较函数的返回值来判定比较大小。
&gt;&gt;&gt; list1, list2 = [123, 'xyz'], [456, 'abc'] &gt;&gt;&gt; cmp(list1, list2) -1 &gt;&gt;&gt; cmp(list2, list1) 1 &gt;&gt;&gt; list3 = list2 + [789] &gt;&gt;&gt; list3 [456, 'abc', 789] &gt;&gt;&gt; cmp(list2, list3) -1 观察上面cmp函数的几个比较，可以总结：
Python的cmp比较函数 ，如果我们比较的是两个同类的对象，比较操作是非常直观的。
数字和字符串的比较，直接比较它们的值。
对于序列类型的比较，方式上有相似。Python在两个对象基本不能比较的时候尽量做出公平的结果。比如当两个对象没有关系时，或者两种类型根本就没有用于比较的函数时，这时 Python只能根据"逻辑"来做出结论。比较的算法逻辑：
1. 对两个列表的元素进行比较.
2. 如果比较的元素是同类型的,则比较其值,返回结果.
3. 如果两个元素不是同一种类型,则检查它们是否是数字.
a. 如果是数字,执行必要的数字强制类型转换,然后比较.
b. 如果有一方的元素是数字,则另一方的元素"大"(数字是"最小的")
c. 否则,通过类型名字的字母顺序进行比较.
4. 如果有一个列表首先到达末尾,则另一个长一点的列表"大".
5. 如果我们用尽了两个列表的元素而且所有元素都是相等的,那么结果就是个平局,就
是说返回一个 0.
这就是Python的cmp函数比较原理了。
注意：
Python 3.X 的版本中已经没有 cmp 函数，如果你需要实现比较功能，需要引入 operator 模块，适合任何对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475ec675a4be8c442686284fb4e5502b/" rel="bookmark">
			【随笔馆001-安住当下是最高的人生智慧】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌲今天我去另外一个地方参加会议，结束后叫了一个滴滴，结果司机走错了路害我等了好久。我开始有点不悦，突然听到马路对面有一个人在弹萨克斯。我想与其在这里焦躁地等司机，还不如静下心来好好欣赏音乐。就这样，我的心逐渐平静下来，甚至因为欣赏到这么美妙的音乐而感到欣慰。
ㅤ
🌴后来司机终于来了，我礼貌地跟他打招呼，他有点不好意思地对我笑了一笑，解释说刚走错路了，我说没关系，不要紧。后来我们在车上闲聊起来，得知司机以前在东风公司上班，2018年经济效益不好被裁员了，所以现在出来跑出租车。我为他的遭遇表示遗憾，司机也是一个很豁达的人，觉得现在的生活也还不错。
ㅤ
☘️再后来我们经过了武汉长江大桥，我看着这座宏伟的大桥升起一种敬畏感，这座桥已经有67年历史，是共产党成立后建立的第一座大桥。我在想它的建造有多么的不容易，有多少人为此付出了多少心血，才换来了从汉阳到武昌的交通便利。
ㅤ
🌲在整个乘车过程中，我跟司机都在愉快地聊天，有时候聊到某个话题我们会放声大笑。我感到很放松和愉悦，哪怕他只是一个司机，哪怕我们只是陌生人，对呀，我当时的的确确感觉到了一种轻松和愉悦。后来我在想，我们现在的人拥有那么多东西，却好像总是不快乐。有时候好像我们一定要跟一个很喜欢的人，在一个很高档的饭店，吃一顿很丰盛的晚餐，我们才能够满足，所以不知道从什么时候开始，我们把快乐的标准提得如此之高。
ㅤ
🌴有人为找工作而焦虑，有人为付不起首付而焦虑，我非常能够理解。因为我也曾经经历过这样的日子。但是某种程度上来说，好像是我们主动选择了不开心，主动承载了这些焦虑。由于我们在潜意识里做出了这样的选择，所以我们可以找到很多验证的理由。但是你有没有想过，一旦你选择了开心，你其实也可以找到很多开心的理由。
ㅤ
☘️每当我上班的时候，看到一位身患残疾的同事，走路只能缓慢往前移动，我感觉到自己很幸福，同时也为这位同事的遭遇感到惋惜；每当我看到某些书，那些原本是精英，原本有自己很理想的人生规划，却突然迎来了人生噩耗，如《我与地坛》《当呼吸化为空气》。我也觉得自己是多么幸运，在一些人眼里，能拥有一个健康的身体，就是一件很满足的事情。每当我看到二战时期德国人迫害犹太人的电影，我会觉得自己很幸运，生活在这个和平年代不用每天担心身首异处。
ㅤ
☘️如果你选择不快乐，你可以找到很多不快乐的理由。我还没有赚到我想要的钱，我还没有住进我想要的房子，我的小孩子还没有上到理想的学校，我的爱人对我还不够好，，，但如果你选择快乐，你也可以找到很多快乐的理由。我拥有健康的身体，爱人、家人，关心我的人，我可以下班之后去任何一个小巷子或者商场吃一顿想吃的火锅、披萨或西餐。我可以在下班的时候跟爱人说一句辛苦了，我爱你。
ㅤ
☘️所以当你焦虑，不快乐的时候，想想是不是你把快乐的标准拔得太高，想想是不是你自己选择了不快乐。其实只要你用心感受，你会发现生活中有很多美好的时刻。三月份来了，樱花开了；早晨醒来，你还可以自由呼吸；下班回到家你可以看到孩子天真的笑脸。
ㅤ
☘️有的人会说，但是得不到我想要的我就是会难受怎么办？有研究人员做过跟踪实验，发现那些中了百万千万彩票的人，他们在最开始确实是狂喜，快乐，幸福。但随后也就平均1个月的时间，他们的感受就恢复到中彩票之前。也就是说，假如你现在立马得到了想要的工作，支付得起房子的首付，我不否认在最开始的那几天你一定会感受到满足、快乐和幸福。但是如同中彩票的人一样，很快你也会适应这种已经得到的生活，于是紧接着你又要开始奔赴下一个焦虑的目标，或许是职场晋升，或许是学区房担忧。回想我们小时候能得到一个棉花糖，能吃到一块肉，能得到来自爸妈的夸赞我们就会很幸福，回想我们高中的时候，我们能考上理想的大学，我们能遇到一个不错的对象，我们就会很幸福。可如今回头来，那些我们曾经渴望的东西都曾得到过，你现在依旧不开心 ，依旧焦虑不是吗。
ㅤ
☘️所以我们不能总被生活牵着鼻子走，我们要做一次生活的主人，我们不要活在他人的定义中，不要活在世俗的束缚中。我们把“好学生”、“好员工”、“好儿子/好女儿”、“好妻子/好丈夫”、“好妈妈/好爸爸”，“好人”等等这些标签都统统撕掉，从今天开始，只做自己，听从自己内心的召唤。我们不辜负当下的每一分每一秒，我们去努力，去创造，去热爱。当然我们也会有累，有怕，有痛的时候，但请告诉自己，我是自己选择了不快乐，我需要修整一下，就像发动机总有需要保养的时候，我知道自己到了保修期，我选择安静下来，我选择冥想，我知道等我调整好了之后，明天又将是美好的一天。
ㅤ
☘️我不羡慕别人有多少钱，有多大房子，有多高声誉，但是我真的想要并且羡慕一种能力。那就是在任何时候都可以安住当下，都可以把心放在当下，去感受，去欣赏，去珍惜当下的每一分每一秒。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70c4602919628b7e5869bd228525a2e/" rel="bookmark">
			spaCy NLP库的模型的下载、安装和使用说明书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言2 安装3 模型命名规范3.1 模型版本控制3.2 支持对旧版本的兼容 4 下载模型5 加载和使用模型6 手动下载和安装7 spaCy v1.x模型的命名规范8 问题和错误报告 1 前言 explosion网址：https://explosion.ai/
spaCy下载网址：https://explosion.ai/software
spaCy的GitHub网址：https://github.com/explosion/spaCy
spaCy的网页网址：https://spacy.io/
此存储库包含spaCy NLP库的模型发布版。有关如何下载、安装和使用模型的更多信息，请参阅模型文档。
⚠️ Important note:
由于模型可能非常大且主要由二进制数据组成，我们不能简单地将其作为文件提供在GitHub存储库中。因此，我们选择将它们添加到发布版本中，以 .whl 和 .tar.gz 文件格式提供。这样我们仍然可以保持公开发布历史。
2 安装 快速入门 要安装特定模型，请运行以下命令并输入模型名称（例如，英文：en_core_web_sm ，中文：zh_core_web_sm）：
python -m spacy download [model] spaCy v3.x models directoryspaCy v3.x model comparisonspaCy v2.x models directoryspaCy v2.x model comparisonIndividual release notes 对于spaCy v1.x模型，请 查看此处。
3 模型命名规范 总的来说，spaCy期望所有模型包遵循 [lang]_[name]的命名规范。对于我们提供的流水线，我们将名称分为三个部分：
core： dep： ent： sent： genre：
类型: 模型功能： core: 具有标记、解析、词形还原和命名实体识别的通用模型dep: 仅具有标记、解析和词形还原ent: 仅具有命名实体识别sent: 仅具有句子分割 体裁: 模型训练的文本类型（例如，web 表示网络文本，news 表示新闻文本）大小: 模型大小指示器: sm: 没有单词向量md: 减少的单词向量表，包含20,000个唯一的向量，用于约500,000个单词lg: 大型单词向量表，包含约500,000个条目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d70c4602919628b7e5869bd228525a2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443ce4a09dd167dbc53132c84f5e48e7/" rel="bookmark">
			AI 时代法律行业风云变幻，法律人的未来之路在哪里？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解析传统的法律行业模式 从19世纪的狄更斯时代到现在，律师和法官的工作方式基本没变。这种模式在全球范围内类似，律师通常以一对一的形式，为客户提供人工定制的法律建议，帮助解决纠纷、提供交易建议、咨询权利与义务等，交付物一般是长篇文件。
20 世纪 70 年代中期以来，法律咨询服务基本按小时收费。之后，各方会在专门的法庭集合，由仲裁者采用正式程序和古老流程，使用难懂的语言解决争端。 除了专业之内的法官和律师，大多数人都难以弄懂这些法律条文和法庭上复杂的逻辑辩证。如今，传统模式最大的问题在于成本高。狄更斯也许有些夸张，说法律文件是“昂贵的胡言乱语”。但多数法律和法庭服务确实价格不菲，个人和企业客户都难以承受。
在《法律人的明天会怎样？》一 书中，我们曾预测司法行业在未来 20 年将发生巨大变化，且变化程度将超过过去 200 年。众多评论家也认为，法律专业将面临前所未有的冲击。
技浪潮下的法律行业变革 现在，英国、澳大利亚等国的法律市场已然开放，律师不再垄断法律工作。没有律师资格的人也能从事法律业务，律师事务所还可以上市或融资。这彻底改变了市场格局。研究表明，近三分之二的人更倾向于选择商业街的品牌公司，而非传统律所。英国合作银行称将在 350 个银行分支提供法律服务，其他知名非法律企业，如英国电信和英国汽车协会 AA 也承诺提供日常法律服务。传统律师的“独唱”模式面临挑战。
2019年的旧的新闻：外国银行纷纷推出优惠、便捷的法律服务
新的服务提供商已进军商业法领域，比如法律流程外包商 Integreon、Novus Law，综合咨询机构汤森路透，还有大量“替代性商业机构”。这些机构受 2007 年英格兰和威尔士地区颁布的《法律服务法案》授权，可以以低于传统律所的固定费率聘请有资质的律师，Riverview Law 就是其中的典型。
China | 中国 | 汤森路透 (thomsonreuters.cn)：汤森路透是著名咨询机构，提供专业信息、数据分析和解决方案，业务涵盖多领域。其产品服务多样，为多方提供决策支持和信息服务。汤森路透在法律方面注重数据分析和信息技术应用，有庞大数据库和先进搜索工具，可助用户了解法律趋势和风险。与传统法律机构相比，其服务更规模化和标准化。
法律业务的另一个发展方向是自由职业律师网络，Axiom 在 2000 年开创了这一先河，此后许多律所纷纷效仿，大多与前雇员签约提供合同服务。比如，英国博闻律师事务所的“按需提供律师”和英国品诚梅森律师事务所的“Vario 模式”。
Pinsent Masons：英国品诚梅森律师事务所成立于1831年，是一家提供综合法律服务的国际性律师事务所。其总部设在伦敦，在全球各地设有办事处，拥有1500多名律师。
总的来说，大型律师事务所正在设立新的劳务部门来应对成本压力。律师将法律工作分解为基础任务，寻找替代方案完成日常和重复性工作，如法律文件审查、尽职调查、日常合同起草和基础法律研究等。有些事务被外包甚至离岸外包给律师助理，然后向客户收取固定价格。一些领先的律所已经开始建立自己的低成本基础服务设施。
此外，法律行业针对企业的新课题——法律风险整体管理，采取了“避免争端好过解决争端”的基本精神，并认可法律只是整体服务的一部分，律师将与会计师、咨询顾问和税务专家一起为客户提供专业服务。技术在律师执业转变中起到核心作用。
除了普及的办公自动化系统和完善的法律搜索工具，许多新系统使律师的工作更加系统化，甚至改变他们的工作方式。其中一类重要系统是用于系统化生成法律文件的“文件汇编系统”，它可以通过简单的互动自动生成高质量文件。起初这些工具为律师服务，现在类似的在线系统也逐渐向外行人开放。法律行业中还出现了其他与文件相关的工具。
四大会计事务所（PwC、KPMG、Deloitte、EY）在全球迅速、持续拓展法律业务，并引入律师 AI 工具。2023 年 3 月 15 日，普华永道与 Harvey 建立全球合作伙伴关系，Harvey 将为其 4000 多名法律专业人士提供支持，包括合同分析等服务。此外，贝恩咨询、波士顿咨询集团、Allen &amp; Overy 等也与 Harvey 或其竞争对手合作。
合同起草示例：
Spellbook嵌入Microsoft Word，在输入蓝色条款后，自动生成了绿色条款 很多不是学法律的人通常认为国家网站或非营利性网站提供的法律指南更有帮助。如今，人们都可以免费查看法律和判例法，如中国裁判文书网、中国司法案例网、中国人民法院网等。商业性的在线法律服务也在发展，同时出现了一些更复杂的专家诊断系统，可以处理复杂的跨地区法律问题，并能比一流专家做得更好。安理国际律师事务所已经开始提供这样的服务，而像 Neota Logic 这样更年轻的法律服务供应商也在推出能够处理复杂规则和进行深度推理的系统。
虚拟数据室（VDR）指南 (alltechbuzz.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/443ce4a09dd167dbc53132c84f5e48e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5f7508574af7206b9cef4d81e289dd/" rel="bookmark">
			进程管理与计划任务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程管理 1、查看进程 静态 ps -aux ps -elf 动态 top pgrep 查看特定条件的进程 pgrep -l “log” pgrep -l "ssh" pgrep -l -U redhat pstree 查看进程树 pstree -aup 所有用户、进程id\详细信息 pstree -ap redhat 查看redhat用户的进程 任务调度和进程管理
后台启动，加 &amp; 字符
#cp /dev/sr0 mycd.iso &amp;
查看后台任务： jobs
调度任务
fg [任务序列号]
启动后台停止进程：
bg [任务序列号]
终止进程 前台进程终止：crtl + c
后台进程终止：kill -9 进程号， killall -9 进程名称
杀死特定条件进程:pkill -9 -U “用户名”
监控系统 #uptime 负载、运行时间，用户数。 #lscpu 查看cpu数量，参数等。 2.控制服务和守护进程 systemd 第一个进程
systemctl --version 查看版本 systemctl get-default 系统运行级别 systemctl 列出所有已经加载且运行的单元 systemctl --help systemctl list-units --type=service 列出服务单元 --type=socket systemctl list-unit-files 列出服务单元所有的文件。 Systemctl status sshd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f5f7508574af7206b9cef4d81e289dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33ab06a8e230aa205c70e7fa9d95f45/" rel="bookmark">
			Codeforces Round 935 (Div. 3) （A~G）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1945A - Setting up Camp 题意：三种人安排住宿,a只能跟自己住,b只能三个人住,c能1~3个人，问最终最少房间数
思路：a单独安排,b放一起,不足三个人的用c补,然后c按照3人一房间尽可能分配
void solve() { int a , b , c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int ans = a + b / 3; b %= 3; int res = b + c; if(res == 0){ cout &lt;&lt; ans &lt;&lt; endl; return; } if(b){ if(res &lt; 3){ cout &lt;&lt; -1 &lt;&lt; endl; } else{ cout &lt;&lt; ans + (res - 1) / 3 + 1 &lt;&lt; endl; } } else{ cout &lt;&lt; ans + (res - 1) / 3 + 1 &lt;&lt; endl; } } 1945B - Fireworks 题意：装置A每a分钟放一次烟花,装置B每b分钟放一次烟花,烟花能存在m分钟,求空中同时存在最多多少烟花.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c33ab06a8e230aa205c70e7fa9d95f45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea34e24a404f837813db60db8e9bce95/" rel="bookmark">
			nrm切换源和私有库下载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装nrm（npm 源管理器） 可以在 npm源间快速切换
npm install -g nrm
2.添加公司私有库 nrm add registry http://npm.siyouku.co/ 3.查看可选源 nrm ls
4.登录私有库地址输入账号密码 npm login
5.下载私有库里的包 npm i vite-plugin-aliyun-oss -D
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3adc5c80aba855fadf533dddda6125b1/" rel="bookmark">
			服务器数据恢复—异常断电导致服务器磁盘阵列崩溃的数据恢复案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器数据恢复环境&amp;故障：
由于机房多次断电导致一台服务器中raid阵列信息丢失。该阵列中存放的是文档，上层安装的是Windows server操作系统，没有配置ups。
因为服务器异常断电重启后，raid阵列可以正常使用，所以未引起管理员的注意。后续出现的多次异常断电导致raid报错，服务器无法找到存储设备，进入raid管理模块进行任何操作都会导致操作系统死机。管理员尝试多次重启服务器，故障依旧。
服务器故障分析：
北亚企安数据恢复工程师在日常工作中经常碰到这类故障。出现这类故障的原因：1、管理员没有及时检修服务器设备状态，服务器在即将出现故障的时候没有及时处理。2、raid阵列一旦创建完成后，理论上raid信息不会改变，但是意外断电也可以导致raid信息丢失。
本案例中的故障情况极有可能就是服务器多次断电导致raid卡硬件损坏。
服务器数据恢复过程：
1、将故障服务器阵列中所有磁盘编号后取出，由硬件工程师检测后没有发现有硬盘存在硬件故障。以只读方式将所有磁盘做扇区级别的全盘镜像，在镜像过程中观察这些硬盘的物理状态，确认无物理故障。镜像完成后将所有磁盘按照编号还原到原服务器中，后续的数据分析和数据恢复操作都基于镜像文件进行，避免对原始磁盘数据造成二次破坏。
2、基于镜像文件分析所有硬盘底层数据，结合文件系统存储规则分析获取到该raid阵列中的raid数据块大小、raid盘序以及raid校验方式。使用分析得到这些raid信息虚拟重组raid阵列。
3、重组完raid磁盘阵列后进行逻辑校验，校验无误后再交由用户方进行验证。
4、用户仔细验证后，确认服务器raid阵列中的数据已经恢复到故障前的状态，本次服务器数据恢复工作完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2139f43e1e71823487d3e5ccdc73b57/" rel="bookmark">
			Wpf-自定义图标Button
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 FontFamily：指定图标字体资源文件；（推荐iconfont阿里矢量图标）
示例代码：
&lt;Style x:Key="MyIconButtonStyle" TargetType="Button"&gt; &lt;Setter Property="Width" Value="40" /&gt; &lt;Setter Property="Height" Value="30" /&gt; &lt;Setter Property="Template"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType="Button"&gt; &lt;Border Name="back" Background="Transparent"&gt; &lt;TextBlock HorizontalAlignment="Center" VerticalAlignment="Center" FontFamily="./Fonts/#iconfont" FontSize="{Binding FontSize, RelativeSource={RelativeSource AncestorType=Button, Mode=FindAncestor}}" Text="{Binding Content, RelativeSource={RelativeSource AncestorType=Button, Mode=FindAncestor}}" /&gt; &lt;/Border&gt; &lt;ControlTemplate.Triggers&gt; &lt;Trigger Property="IsMouseOver" Value="True"&gt; &lt;Setter TargetName="back" Property="Background" Value="#FFFFFF" /&gt; &lt;/Trigger&gt; &lt;Trigger Property="IsPressed" Value="True"&gt; &lt;Setter TargetName="back" Property="Background" Value="#AAAAAA" /&gt; &lt;/Trigger&gt; &lt;/ControlTemplate.Triggers&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da66073ea2a4ca3bd3970e40c7db4c6/" rel="bookmark">
			SpringBoot项目通过触发器调度实现定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、quartz是什么？二、quartz中核心概念三、集成步骤1.引入依赖2.demo样例a.定义一个任务参数实体类b.定义操作触发器、定时任务接口及实现c.作业实现d.结果截图 四、其他1.QuartzJobBean和Job区别2.注意事项3.作业（Job）和触发器（Trigger）参数解析a.JobDetail 参数解析a.Trigger 参数解析 前言 项目中可能会遇到一些需要定时同步数据的业务场景，比如从多个数据库汇总数据形成结果，可以使用数据自带的定时任务去执行存储过程实现，也可以通过集成quartz来实现，
一、quartz是什么？ 1、Quartz是一个功能强大且灵活的开源任务调度库，用于在Java应用程序中实现定时任务和作业调度。它允许你根据特定的时间表（比如每天凌晨执行一次，或者每隔一段时间执行一次）来调度任务的执行。Quartz提供了丰富的功能，包括支持CRON表达式、作业持久化、集群环境下的分布式调度、监听器支持等。
2、通过Quartz，可以创建各种类型的作业，例如简单作业（只需要执行一次）、重复作业（按照指定的时间间隔重复执行）、以及基于CRON表达式的作业（按照指定的时间规则执行）。
二、quartz中核心概念 1、任务 Job： Job 就是你想要实现的任务类，每一个 Job 必须实现org.quartz.job 接口，且只需实现接口定义的execute() 方法。
2、触发器 Trigger： Trigger 为你执行任务的触发器，Trigger将会设置3点执行该任务。 Trigger主要包含两种 SimplerTrigger 和 CronTrigger 两种。
3、调度器 Scheduler： Scheduler 为任务的调度器，它会将任务 Job 及触发器 Trigger 整合起来，负责基于Trigger 设定的时间来执行 Job。
三、集成步骤 1.引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;version&gt;2.6.13&lt;/version&gt; &lt;/dependency&gt; 2.demo样例 a.定义一个任务参数实体类 @Data public class QuartzJobInfo { private String type; private Map&lt;String, Object&gt; params; private String jobName; private String cronj; private String orderId; } b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2da66073ea2a4ca3bd3970e40c7db4c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0689e526523f58c898d8fcfcb309f04c/" rel="bookmark">
			快速画流程图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用在线工具：PlantUML
PlantUML
官网:https://plantuml.com/
中文官网:https://plantuml.com/zh/
使用步骤如下：
1、拷贝一个完成函数：
int func_init(const char *tag) { if (tag != NULL) { printf("set TAG :%s", tag); } print_test(); return 0; } 2、使用chatGPT把代码转换成标准的plantuml语言输出流程图，具体输入如下：
用标准plantuml语言输出流程图
int func_init(const char *tag) {
if (tag != NULL) {
printf(“set TAG :%s”, tag);
}
print_test();
return 0;
}
3、chatGPT输出如下：
@startuml
start
if (tag != NULL) then (yes)
:printf(“set TAG :%s”, tag);
else (no)
endif
:print_test();
stop
@enduml
4、登录https://plantuml.com/zh/ 选择 活动图，输出流程图如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256ca98cea77e44eeca4bbc467a6f020/" rel="bookmark">
			Android studio添加阿里云仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工程的settings.gradle中添加
repositories {
google()
jcenter()
mavenCentral()
maven { url 'https://jitpack.io' }
//阿里云镜像
maven { url 'https://maven.aliyun.com/repository/google' }
maven { url 'https://maven.aliyun.com/repository/public' }
maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4368626aa22d4f1596271bca070e01d1/" rel="bookmark">
			adb logcat 命令使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		adb logcat 命令-CSDN博客
c++ fork, execl 参数 logcat | grep-CSDN博客
一.命令格式
adb logcat [选项] [过滤项], 其中 选项 和 过滤项 在 中括号 [] 中, 说明这是可选的;
选项解析:
1."-s"选项 : 只显示指定标签的日志; ------&gt;adb logcat -s SWVDEC 显示SWVDEC标签的日志
2."-v"选项 : 设置日志的输出格式;-----&gt;adb logcat -v threadtime 查看日志输出时间和线程信息
3."-c"选项 : 清空所有的日志缓存信息;----&gt;adb logcat -c
4."-d"选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;-------&gt;adb logcat -d
5."-t"选项 : 输出最近的几行日志, 输出完退出, 不阻塞;------&gt;adb logcat -t 5 输出日志缓冲区的最近5行
6."-g"选项 : 查看日志缓冲区信息; ------&gt;adb logcat -g
7."-B"选项 : 以二进制形式输出日志; ----&gt; adb logcat -B
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c979c9ed7a88b84732f947b94081e6/" rel="bookmark">
			vue动态获取本地图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在复习插槽有关知识的时候，遇到一个问题。
我想把本地图片动态的展示到页面上，却实现不了。😭😭😭😭😭😭😭😭😭😭😭😭
后来搜索了很多有关这方面的知识，才得到了解决。🥳🥳🥳🥳🥳🥳🥳🥳🥳🥳🥳🥳
展示错误情况 （一）直接使用相对路径 &lt;template&gt; &lt;div class=""&gt; &lt;Child :arr="list"&gt; &lt;template v-slot="slotProps"&gt; &lt;img width="100px" height="100px" :src="slotProps.row.avatar" alt="" /&gt; &lt;/template&gt; &lt;/Child&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Child from './components/child.vue' export default { data() { return { list: [ { name: '小明', avatar: '@/assets/剑士.jpg' }, { name: '小红', avatar: '@/assets/路飞.jpeg' }, { name: '小刚', avatar: '@/assets/小黄人.jpg' } ] } }, components: { Child } } &lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 报错：404，找不到：
（二）在 src 里面加上require &lt;template&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c979c9ed7a88b84732f947b94081e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb89db509c8a47ef66530e8df54dc45e/" rel="bookmark">
			Stable Diffusion训练图片时，简陋的数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 图片从命名 如果有强迫症，看到似乎乱码的命名会不舒服，那么就批量从命名
import os def rename_files_in_directory(directory, key_word, new_suffix): i = 1 for filename in os.listdir(directory): new_file = key_word + str(i).zfill(3) + new_suffix source = os.path.join(directory, filename) destination = os.path.join(directory, new_file) os.rename(source, destination) i += 1 # 使用方法 # rename_files_in_directory('/path/to/directory', '.new_suffix') # D:\SdTrainerGUI\lora-scripts-v1.7.3\train\XiboBird\5_zkz 1 批量缩小图片分辨率 如果是用同一个相机拍的，分辨率都是一样的，只不过分辨率太大了8K以上的分辨率显卡受不了
from PIL import Image import os def resize_image(image_path, output_path, scale_factor): # 打开图片 img = Image.open(image_path) # 获取图片的宽度和高度 width, height = img.size # 计算新的宽度和高度 new_width = width // scale_factor new_height = height // scale_factor # 使用ANTIALIAS滤镜来缩小图片 # new_img = img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb89db509c8a47ef66530e8df54dc45e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ece8a2a1a2532ff5af60301018a3a2b9/" rel="bookmark">
			“未等待完成”在异步操作还没有完成时，就进行下一次操作，可能导致数据不一致或逻辑错误。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		等待异步操作完成就进行下一次操作可能会导致数据不一致或逻辑错误，这在异步操作频繁、互相独立而又不可忽略的场景中尤为常见。下面，我来举个例子帮助解释。
假设我们需要通过异步操作获取用户信息并渲染页面，页面上还需要显示用户的最新发布。如果我们在获取用户信息和最新发布时没有正确管理异步操作的顺序，则有可能导致最新发布和用户信息不一致，造成用户体验问题。下面是示例代码：
function getUserInfo(userId) { return fetch(`https://api.example.com/users/${userId}`) .then(response =&gt; { if (!response.ok) { throw new Error('数据获取失败'); } return response.json(); }); } function getLatestPost(userId) { return fetch(`https://api.example.com/posts/latest/${userId}`) .then(response =&gt; { if (!response.ok) { throw new Error('数据获取失败'); } return response.json(); }); } // 用户信息和最新发布的渲染函数 function renderUserInfoAndPost(userInfo, latestPost) { // 渲染用户信息... // // 渲染最新发布... // 假设这里有一些渲染逻辑 } // 错误处理函数 function handleError(error) { console.error('发生错误：', error); // 显示错误信息或者进行其他错误处理... } // 异步操作调用 getUserInfo(123) .then(userInfo =&gt; { // 假设这里进行了一些处理 getLatestPost(123) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ece8a2a1a2532ff5af60301018a3a2b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a6031b04b7d53615ef5b52fcb6655f8/" rel="bookmark">
			kafka 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署准备 至少三台服务器，Zookeeper 集群
安装 Kafka 安装包准备 Kafka 下载页面
配置文件修改 server.properties # The id of the broker. This must be set to a unique integer for each broker. broker.id=0 # The address the socket server listens on. listeners=PLAINTEXT://x.x.x.x:9092 # A comma separated list of directories under which to store log files # 数据文件存放地址 log.dirs=/home/bigdata/kafka/log # Zookeeper connection string # 最后的 /kafka 是zk上的路径信息，如果不写，默认在根目录下展开 kafka 元数据信息，容易于其他系统冲突 zookeeper.connect=x.x.x.x:2181/kafka 分发配置文件到所有节点 # 复制 hadoop 安装包的解压文件夹到所有的机器 scp -r kafka_2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a6031b04b7d53615ef5b52fcb6655f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5a4c1854f42cd4539247c6397b5609/" rel="bookmark">
			使用 node.js 开发前端跨域代理服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是跨域？当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。
为什么会出现跨域问题？出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。
打开 cmd 窗口，切换到 D:\proxyServer 目录
npm install express
npm install http-proxy-middleware
npm init -y 在proxyServer文件夹，新建 proxyServer.js，内容如下：
const express = require("express");
const { createProxyMiddleware } = require("http-proxy-middleware");
const app = express();
//设置跨域访问
app.all("*", function (req, res, next) {
//设置允许跨域的域名，*代表允许任意域名跨域
res.header("Access-Control-Allow-Origin", "*");
//允许的header类型
res.header("Access-Control-Allow-Headers", "Content-Type,Authorization"); //content-type
//跨域允许的请求方式
res.header("Access-Control-Allow-Methods", "DELETE,PUT,POST,GET,OPTIONS");
if (req.method.toLowerCase() == "options") res.send(200);
//让options尝试请求快速结束
else next();
});
//这个链接是 福州市电子信息 企业二级节点
app.use(
"/api",
createProxyMiddleware({
target: "https://www.fzcitln.cn",
changeOrigin: true,
pathRewrite: {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5a4c1854f42cd4539247c6397b5609/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/17/">«</a>
	<span class="pagination__item pagination__item--current">18/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/19/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>