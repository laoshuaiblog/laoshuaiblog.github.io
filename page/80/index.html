<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c04a00524b3d0d539ad445ada0c4e576/" rel="bookmark">
			数据结构与算法(3)线性表中的顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在预习数据结构与算法，记录一下学习的知识。
线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。
前驱元素、后继元素:
若A在B的前面，则A为B的前驱元素,若B在A的后面，则称B为A的后继元素
线性表的特征:数据元素之间具有一种“一对一”的逻辑关系。
1.第一个数据元素没有前驱，这个数据元素被称为头节点；
2.最后一个数据元素没有后继，这个数据元素被称为尾节点；
3.除了第一个和最后一个元素外，其他数据元素有且仅有一个前驱和后继。
顺序表：
顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素，使得线性表中在逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。
(1)顺序表API设计：
(第一次用Java)
public class Sequencelist&lt;T&gt; { //存储元素的数组 private T[] eles; //记录当前顺序表中的元素个数 private int N; //构造方法 public Sequencelist(int capacity) { //初始化数组 this.eles=(T[])new object[capacity];//(T[])是强转类型 //初始化长度 this.N=0; } //将一个线性表置为空表 public void clear() { this.N=0; } //判断当线性表是否为空表 public boolean isEmpty() { return N==0; } //获取线性表的长度 public int length() { return N; } //获取指定位置的元素 public T get(int i) { return eles[i]; } //向线性表中添加元素t public void insert(T t) { eles[N++]=t;//不能是++N！！ } //在i元素处插入元素t public void insert(i,T t) { //先把i索引处的元素及其后面的元素依次向后移动一位 for(int index=N-1;index&gt;i;index--)//N-1是最后一个元素的索引 { eles[index]=eles[index-1]; } //再把t元素放到i索引处即可 eles[i]=t; } //删除指定位置i处的元素，并返回该元素 public T remove(int i) { //记录索引i处的值 int current = eles[i]; //索引i后面的元素依次向前移动一位即可 for(int index=i;index&lt;N-1;index++) { eles[index]=eles[index+1]; } //元素个数-1 N--; return current; } //查找t元素第一次出现的位置 public int indexOf(T t) { for(int i=0;i&lt;N;i++) { if(eles[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c04a00524b3d0d539ad445ada0c4e576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305a0198c648558aa4469f329dead937/" rel="bookmark">
			选择习题集2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、
1、以下描述正确的是 B
A：CallableStatement是PreparedStatement的父接口
B：PreparedStatement是CallableStatement的父接口
C：CallableStatement是Statement的父接口
D：PreparedStatement是Statement的父接口
CallableStatement继承自PreparedStatement
PreparedStatement继承自statement
2、下列程序的运行结果B
public static void main(String args[]) { Thread t = new Thread() { public void run() { pong(); } }; t.run(); System.out.print("ping"); } static void pong() { System.out.print("pong"); } hheA：pingpong
B：pongping
C：pingpong和pongping都有可能
D：都不输出
在main方法中并没有创建一个新的线程，只是一个简单的方法调用。想要创建线程，需要t.start()。
3、下列关于容器集合类的说法正确的是 C
A：LinkedList继承自List
B：AbstractSet继承自Set
C：HashSet继承自AbstractSet
D：WeakMap继承自HashMap
LinkedList继承自AbstractSequentialList，实现了List接口
AbstractSet是实现了Set接口，本身是一个抽象类。继承自AbstractCollection（抽象类，实现了Collection接口）
HashSet继承自AbstractSet，实现了Set接口
WeakMap不存在于java集合框架的。只有一个叫做WeakHashMap（继承自AbstractMap）。
4、ArrayList list = new ArrayList(20);中的list扩充几次 A
A：0
B：1
C：2
D：3
ArrayList默认的长度是10，但是这里指明了需要多少空间，一次性就可以分配这么多的空间，就不需要扩充了
5、
以下程序的输出结果是？ B
public class Example { String str = new String("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/305a0198c648558aa4469f329dead937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25ae8fa612456e07f9d7b8be2c1f812/" rel="bookmark">
			一定要避免latch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在做项目的项目的时候遇到了一个很有意思的问题，功能仿真没有问题，可是在FPGA上面上板调试就是不对，最后通过检查综合后的电路发现有一处生成了latch，在实际电路中latch容易产生毛刺，导致下一级电路可能出现错误状态，如果书写不规范，仿真是发现不了这个问题的，平时书上经常看到一定要避免latch这样的字眼，自己感觉懂了，直到这次真的遇到问题时，调试好久才发现，所以就把不规范的代码都在vivado上面跑了一下综合，给自己长长记性。（由于笔者比较菜，有不对的地方，欢迎大家批评指正）
一个变量声明为寄存器时，它既可以被综合成触发器，也可能被综合成 Latch，甚至是 wire 型变量。
第一种：组合逻辑中，不完整的 if - else 结构会综合成latch，这种是最为常见的，因为平时多用时序逻辑电路， if - else不完整并不会综合成latch，可能由于习惯，组合逻辑中有时候也会忘记。
always@(*) if(a_i) out_o = c_i; else if(b_i) out_o = 1'b1; 第二种：组合逻辑电路中将值赋值给自己
always@(*) if(a_i) out_o = c_i; else if(b_i) out_o = 1'b0; else out_o = out_o; 第三种、这种情况是正确的
always@(*) if(a_i) out_o = c_i; else if(b_i) out_o = 1'b1; else out_o = 1'b0; 这个是通过时序逻辑电路完成相同功能
always@(posedge clk or negedge rst_n) if(~rst_n) out_o &lt;= 1'b0; else if(a_i) out_o = c_i; else if(b_i) out_o = 1'b1; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d7af86ce13aeb914e76d0cc5bf9c850/" rel="bookmark">
			Undefined control sequence. \makecover
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 今天刚下载了github上2021年的UESTC硕士学位论文latex模板，直接编译\makecover报错
产生原因： 在begin{document}前面的内容还缺少字段
解决办法： 添加以下字段
\maintitle
\degree
专硕需要把master改成promatesr，并添加\theEngineeringFieldName字段
现在再编译就 OK 了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621e26a01fc887ec2805b0f3a063c7d4/" rel="bookmark">
			关于基础微积分的结束语
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 美国著名数学家J.Keisler在其代表作《Elementary Calculus》(基础微积分)结束语(后记)中首次把微积分建立在公理系统之上。
对此，有兴趣的读者可访问无穷小微积分专业网站下载《Elementary Calculus》查阅。
我们建议详细阅读基础微积分的结束语，不做数学守旧派。
袁萌
2022年01月10日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa61c4b4f4fbae785f1af58a8fdebeed/" rel="bookmark">
			matlab实验——信号和噪声产生及其功率谱分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、高斯白噪声自相关函数及功率谱1.matlab代码2.运行结果 二、均匀白噪声自相关函数及功率谱1.matlab代码2.运行结果 三、正弦波与高斯白噪声叠加1.matlab代码2.运行结果 四、正弦波与均匀白噪声叠加1.matlab代码2.运行结果 总结 前言 本文的主要内容是利用matlab实现信号和噪声产生及其功率谱分析。
高斯白噪声：功率谱密度服从均匀分布，幅度分布服从高斯分布。
均匀白噪声：功率谱密度服从均匀分布，幅度分布服从均匀分布。
功率谱的计算需要信号先做自相关，然后再进行FFT运算。
频谱的计算则是将信号直接进行FFT就行了。
维纳-辛钦定理：任意一个均值为常数的广义平稳随机过程的功率谱密度是其自相关函数的傅立叶变换 。
一、高斯白噪声自相关函数及功率谱 1.matlab代码 %产生高斯白噪声 normal=0.1*randn(1,201); %产生均值为0,方差为0.01的高斯白噪声 [r,lags]=xcorr(normal); %做自相关 subplot(2,1,1);plot(lags,r);grid on;xlabel("高斯白噪声做自相关"); f=fftshift(fft(r));%频谱校正 x=(0:length(f)-1)*200/length(f)-100; %x轴 y=abs(f); subplot(2,1,2);plot(x,y,'g');grid on; axis([-100 100 -50 50]);xlabel("高斯白噪声功率谱"); 2.运行结果 二、均匀白噪声自相关函数及功率谱 1.matlab代码 %产生均匀白噪声 uniform=-0.2+0.4*rand(1,201); %产生强度在-0.2到0.2之间的均匀白噪声 [r,lags]=xcorr(uniform); %做自相关 subplot(2,1,1);plot(lags,r);grid on;xlabel("均匀白噪声做自相关"); f=fftshift(fft(r));%频谱校正 x=(0:length(f)-1)*200/length(f)-100; %x轴 y=abs(f); subplot(2,1,2);plot(x,y,'g');grid on; axis([-100 100 -50 50]);xlabel("均匀白噪声功率谱"); 2.运行结果 三、正弦波与高斯白噪声叠加 1.matlab代码 %产生正弦波 figure; x=0:0.01:2; y1=sin(10*pi*x); subplot(3,1,1);plot(x,y1,'b');grid on;xlabel("正弦波的波形"); %产生高斯白噪声 normal=0.1*randn(1,201); %这里的长度必须与x的长度相同 subplot(3,1,2);plot(x,normal,'g');grid on;xlabel("高斯白噪声的波形"); y2=y1+normal; %将正弦波与高斯白噪声叠加 subplot(3,1,3);plot(x,y2,'r');grid on;xlabel("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa61c4b4f4fbae785f1af58a8fdebeed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2e36103a4839ed7c319e20d0ab8b28/" rel="bookmark">
			C语言：顺序查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; main() { int i,x,j=0; int a[10]={12,34,64,73,23,56,43,54,32,56}; printf("请输入要查找的数：\n"); scanf("%d",&amp;x); for(i=0;i&lt;10;i++) { if(a[i]==x) printf("%d ",i); else j++; } if(j&gt;=10) printf("没有找到"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a78d7c0ae6c132091308b667be14cb/" rel="bookmark">
			STM32F1C8T6Flash读取音频和DAC播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Flash简介1、Flash原理2、STM32F1中的Flash 二、Flash地址空间的数据读取1、题目要求2、CUbeMX工程建立3、Keil工程修改4、STlink调试说明5、调试运行 三、基于片内Flash的提示音播放程序1、使用DAC输出周期2khz的正弦波2、使用DAC输出数字音频歌曲数据转换为模拟音频波形输出 四、总结五、参考资料 一、Flash简介 1、Flash原理 Flash全名叫做Flash Memory，从名字就能看出，是种数据存储设备，存储设备有很多类，Flash属于非易失性存储设备(Non-volatile Memory Device)，与此相对应的是易失性存储设备(Volatile Memory Device)。关于什么是非易失性/易失性，从名字中就可以看出，非易失性就是不容易丢失，数据存储在这类设备中，即使断电了，也不会丢失，这类设备，除了Flash，还有其他比较常见的入硬盘，ROM等，与此相对的，易失性就是断电了，数据就丢失了，比如大家常用的内存，不论是以前的SDRAM，DDR SDRAM，还是现在的DDR2，DDR3等，都是断电后，数据就没了。
典型的Flash内存单元的物理结构：
2、STM32F1中的Flash 不同型号的 STM32，其 FLASH 容量也有所不同，最小的只有 16K 字节，最大的则达到了 1024K 字节。市面上 STM32F1 开发板使用的芯片是 STM32F103系列，其 FLASH 容量一般为 512K 字节，属于大容量芯片。
STM32F1 的闪存（Flash）模块由：主存储器、信息块和闪存存储器接口寄存器等 3 部分组成。下面我们就来介绍下这些组成部分：
①主存储器。该部分用来存放代码和数据常数（如 const 类型的数据）。对于大容量产品，其被划分为 256 页，每页 2K 字节。注意，小容量和中容量产品则每页只有 1K 字节。从上图可以看出主存储器的起始地址就是0X08000000， BOOT0、BOOT1 都接 GND 的时候，就是从 0X08000000 开始运行代码的。
②信息块。该部分分为 2 个小部分，其中启动程序代码，是用来存储 ST 自带的启动程序，用于串口下载代码，当 BOOT0 接 V3.3， BOOT1 接 GND 的时候，运行的就是这部分代码。用户选择字节，则一般用于配置写保护、读保护等功能，这里我们不做介绍，大家可以百度了解。
③闪存存储器接口寄存器。该部分用于控制闪存读写等，是整个闪存模块的控制机构。对主存储器和信息块的写入由内嵌的闪存编程/擦除控制器(FPEC)管理；编程与擦除的高电压由内部产生。
在执行闪存写操作时，任何对闪存的读操作都会锁住总线，在写操作完成后读操作才能正确地进行；既在进行写或擦除操作时，不能进行代码或数据的读取操作。
二、Flash地址空间的数据读取 1、题目要求 Flash地址空间的数据读取。stm32f103c8t6只有20KB 内存（RAM）供程序代码和数组变量存放，因此，针对内部Flash的总计64KB存储空间(地址从0x08000000开始），运行一次写入8KB数据，总计复位运行代码4次，将32KB数据写入Flash。并验证写入数据的正确性和读写速率。
2、CUbeMX工程建立 配置定时器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0a78d7c0ae6c132091308b667be14cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d8640dd7280d61f07fe9a65ec4a7b5/" rel="bookmark">
			jenkins生成allure报告，打开是空白的，日志提示allure-results does not exist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开allure显示这个
查看控制台日志，发现没有读取到结果文件
首先我们要知道，allure生成报告有两步，第一步是生成json、txt这种结果文件。
第二步是根据生成的结果文件，去生成报告，如下图
所以是我们jenkins上读取结果文件设置地址不对，所以报告打开就是空的
（中间省略一万字的踩坑史，直接说解决方案）
我们在配置中设置读取结果文件的地址在这里，下面提示说要输入workspance的相对路径
那当前的workspace路径是什么呢？
看这里。这个就是
然后banbanauto是我的jenkins的项目名称（你们可以打开你们自己的这个路径看看，然后下面的结构就清晰了）
那我们生成的结果文件又在哪？我是专门有个脚本
注意：我是先进到了 aboutlogin这个目录 ，使用的相对路径，是相对于jenkins的当前的workspace路径（即进到了：C:\Windows\ServiceProfiles\LocalService\.jenkins\workspace\banbanauto\aboutlogin 这个路径）
然后执行我的exefile.py。那我生成的结果文件的路径就是 C:\Windows\ServiceProfiles\LocalService\.jenkins\workspace\banbanauto\aboutlogin\report\tmp
然后我们设置读取结果文件的地址，以及存放报告的地址，就是这样
为什么要带上aboutlogin？是因为这里的workspace还是jenkins的workspace，并不是我执行py文件的路径。所以加上就可以了。
这样就可以读取到结果文件了。然后打开报告也ok了。
（ps：不要嫌我啰嗦，我怕我表达不清楚，所以只能重复说了）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22b6a53ae534fbbaf1acfc4cb7adf33/" rel="bookmark">
			基于JAVA&#43;Swing&#43;MYSQL的学生选课系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目功能：
该系统主要包括学生和管理员两个用户角色 以学生角色登陆进去 学生可以查看自己的选修课情况 修改自己的个人信息
以管理员的角色登陆进去，管理员可以查看选修课的选修情况 增加选修课，查看学生的个人情况
管理员操作学生信息
页面效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0385fbfcc9289be7492f53c18a6033f6/" rel="bookmark">
			java取模场景下设置数组等长度尽量用2的n次方数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下除数为2的N次方取模可以用与运算替代，效率更高
转载：除数为2的N次方取模可以用与运算替代，效率更高_taoshengyang的专栏-CSDN博客
取模运算在包括JAVA在内的大多数语言中的效率都十分低下，而当除数为2的N次方时，取模运算将退化为最简单的位运算，其效率明显提升（按照Bruce Eckel给出的数据，大约可以提升5～8倍） 。看看JDK中是如何实现的：
Java代码：
static int indexFor(int h, int length) { return h &amp; (length-1); } 当key空间长度为2的N次方时，计算hashCode为h的元素的索引可以用简单的与操作来代替笨拙的取模操作！假设某个对象的hashCode为35（二进制为100011），而hashMap采用默认的initialCapacity（16），那么indexFor计算所得结果将会是100011 &amp; 1111 = 11，即十进制的3，是不是恰好是35 Mod 16。
上面的方法有一个问题，就是它的计算结果仅有对象hashCode的低位决定，而高位被统统屏蔽了；以上面为例，19（10011）、35（100011）、67（1000011）等就具有相同的结果。针对这个问题， Joshua Bloch采用了“防御性编程”的解决方法，在使用各对象的hashCode之前对其进行二次Hash，参看JDK中的源码：
Java代码：
static int hash(Object x) { int h = x.hashCode(); h += ~(h &lt;&lt; 9); h ^= (h &gt;&gt;&gt; 14); h += (h &lt;&lt; 4); h ^= (h &gt;&gt;&gt; 10); return h; } 采用这种旋转Hash函数的主要目的是让原有hashCode的高位信息也能被充分利用，且兼顾计算效率以及数据统计的特性，其具体的原理已超出了本文的领域。
加快Hash效率的另一个有效途径是编写良好的自定义对象的HashCode，String的实现采用了如下的计算方法：
Java代码：
for (int i = 0; i &lt; len; i++) { h = 31*h + val[off++]; } hash = h; 这种方法HashCode的计算方法可能最早出现在Brian W.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0385fbfcc9289be7492f53c18a6033f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6894364a84860a7a87cfd73e276f127/" rel="bookmark">
			所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。举例：153就是一个水仙花数。 153 = 1*1*1 &#43; 5*5*5 &#43; 3*3*3 = 1 &#43; 125 &#43; 27 =
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //创建main方法 public static void main(String[] args) { int num1 = 0;//存放个位 int num2 = 0; //存放十位 int num3 = 0; //存放百位 int result = 0; //存放最终结果 for(int i = 1;i &lt; 1000;i++){ //for循环 if(i &gt;99 &amp;&amp; i&lt; 1000){ //筛选出三位数 num1 = i%10; //获取所有三位数字的个位 num2 = i/10%10; //获取十位 num3 = i/100; //获取百位 if(i == num1*num1*num1+num2*num2*num2+num3*num3*num3){ //筛选出符合的三位数 result=i; //把符合条件的三位数赋值 System.out.println("符合条件的水仙花为："+result); //输出符合的三位数 } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d11f4a30312d8278481720274b1042/" rel="bookmark">
			JDBCTemplate中queryForObject方法查询为空抛异常的问题（.IncorrectResultSizeDataAccessException: Incorrect resu）【解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言问题重现源码： 解决方案查询结果为空抛出异常解决方法查询数量大于1解决方法 前言 虽然目前我们大多使用Mybatis、JPA进行数据操作，但是在特殊情况下，我们还是可能通过JDBCTemplate继续对数据库进行操作的。前天在项目开发中，使用JDBCTemplate进行开发时发现一个异常。
问题重现 就是如果使用JDBCTemplate.queryForObject进行查询数据，如果查询数据为空（null）时会抛出异常。
org.springframework.dao.IncorrectResultSizeDataAccessException: Incorrect result size: expected 1, actual 2 问题分析：
通过追查源码发现是因为，在源码中方法返回结果判断时如果为空就抛出throw new EmptyResultDataAccessException(1);异常；
如果返回值的数量大于1 的时候也会抛出：throw new IncorrectResultSizeDataAccessException(1, results.size());的异常。
但是我想要的功能就是如果数据库为空那就返回空，而不是抛出异常。
源码： @Nullable public &lt;T&gt; T queryForObject(String sql, @Nullable Object[] args, RowMapper&lt;T&gt; rowMapper) throws DataAccessException { List&lt;T&gt; results = (List)this.query((String)sql, (Object[])args, (ResultSetExtractor)(new RowMapperResultSetExtractor(rowMapper, 1))); return DataAccessUtils.nullableSingleResult(results); } @Nullable public static &lt;T&gt; T nullableSingleResult(@Nullable Collection&lt;T&gt; results) throws IncorrectResultSizeDataAccessException { if (CollectionUtils.isEmpty(results)) { throw new EmptyResultDataAccessException(1); } else if (results.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0d11f4a30312d8278481720274b1042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5547dc70f65a4f505c33341a42ada851/" rel="bookmark">
			编译原理基本定义（文法、算符文法、算符优先文法、算符优先关系表、算符优先分析过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文法 文法和语言分为4类。
0型文法：最大类，包含1、2、3型文法。
1型文法：对0型文法来说，所有的产生式的右边的字符长度都要大于左边的字符长度。
2型文法：所有的产生式左边都只有一个字符。
3型文法：在满足2型文法的基础上，每个产生式具有以下形式：A–&gt;a（终结符）、A–&gt;a（终结符）B(非终结符)，或者具有以下形式：A–&gt;a（终结符）、A–&gt;B（非终结符）a（终结符）。
例：
S–&gt;aS
S–&gt;aA
A–&gt;bA
A–&gt;bB
B–&gt;cB
B–&gt;c
这个就是3型文法。
但是
S–&gt;aS
S–&gt;aA
A–&gt;bA
A–&gt;bB
A–&gt;Ac
就不是3型文法，因为它既是左线性，又是右线性。
算符优先文法 算符文法：任何产生式的右部都不含两个相邻的非终结符。
定义算符优先文法之前先定义终结符的关系。
在产生式中，如果R–&gt;…ab…或者R–&gt;…aQb…，那么这两个终结符a和b的关系为：a=b，等于号中间还有个点，但是不知道怎么打上去，所以后面都用等号来代替书上的符号。
在产生式中，如果R–&gt;…aQ…，然后又有Q–&gt;b…或者Q–&gt;Cb…这样的情况存在，那么这两个终结符a和b的关系为：a&lt;b，小于号中间还有个点，所以后面都用小于号来代替书上的符号。
在产生式中，如果R–&gt;…Qb…，然后又有Q–&gt;…a或者Q–&gt;…aC这样的情况存在，那么这两个终结符a和b的关系为：a&gt;b，大于号中间还有个点，所以后面都用大于号来代替书上的符号。
其实终结符的关系，画出语法树就很容易看出来，如果一个终结符的深度大于另一个终结符的深度，那么很可能就是深度越深的那个终结符关系大于深度较浅的终结符关系。后面我们定义了FIRSTVT和LASTVT就很容易求得并理解这些关系了。
算符优先文法：满足算符文法的情况下，任意一对终结符的关系（a,b）最多只有一种情况。
如何求一个非终结符的FIRSTVT？
很简单，对于一个非终结符T来说，有产生式是这样的T–&gt;Qa…或者T–&gt;a…，那么就有 F I R S T V T ( T ) = { a } 集 合 并 上 F I R S T V T ( Q ) FIRSTVT(T)=\{a\}集合并上FIRSTVT(Q) FIRSTVT(T)={a}集合并上FIRSTVT(Q)，即如果 F I R S T V T ( Q ) = { b , c } FIRSTVT(Q)=\{b,c\} FIRSTVT(Q)={b,c}，那么就有 F I R S T V T ( T ) = { a , b , c } FIRSTVT(T)=\{a,b,c\} FIRSTVT(T)={a,b,c}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5547dc70f65a4f505c33341a42ada851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c96ee0283a458c2d16ef047ed99abf8/" rel="bookmark">
			verilog150个经典例子仿真及电路图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.4位全加器
代码：
module module_full_add( input [3:0] iv_a,iv_b, input is_cin, output [3:0] owv_sum, output ows_cout ); assign {ows_cout,owv_sum} = iv_a+iv_b+is_cin; endmodule RTL：
Simulation:
2.4位计数器
module module_full_add( input reset, input clk, output [3:0] orv_out ); reg [3:0] orv_out1; always@(posedge clk) begin if(reset) orv_out1 &lt;= 4'b0; else orv_out1 &lt;= orv_out1+1'b1; end assign orv_out=orv_out1; endmodule RTL:
仿真：
3.与或非
代码：
module module_full_add(A,B,C,D,F); //模块名为 AOI(端口列表 A，B，C，D，F) input A,B,C,D; //模块的输入端口为 A，B，C，D output F; //模块的输出端口为 F wire A,B,C,D,F; //定义信号的数据类型 assign F= ~((A&amp;B)|(C&amp;D)); //逻辑功能描述 endmodule RTL：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c96ee0283a458c2d16ef047ed99abf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c87e675a775e26d86a07dd4756e4565/" rel="bookmark">
			vue的组件components基础和安装vue脚手架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件 组件在vue是一个很强大的功能,可以对HTML进行扩展,在大型应用中,可以对一些抽象的功能进行封装
作用：可复用的vue实例
组件注册 局部注册组件
new Vue({
el:
components:{
自定义组件名称:{
template:'模板内容'
}
}
})
&lt;!-- 1.引入vue --&gt; &lt;script src="./vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 2.创建DOM元素 --&gt; &lt;div id="app"&gt; &lt;h1&gt;这是文本内容给&lt;/h1&gt; &lt;!-- 组件调用 --&gt; &lt;one&gt;&lt;/one&gt; &lt;two&gt;&lt;/two&gt; &lt;/div&gt; &lt;script&gt; // 3.实例化vue let vm = new Vue({ el:'#app', data:{ }, methods:{ }, /** * 1.components:组件 * 2.在components中可以注册多个组件 */ components:{ // 声明一个one组件 one:{ template:'&lt;h2&gt;这是一个局部one注册组件&lt;/h2&gt;' }, // 声明一个two组件 two:{ template:'&lt;h3&gt;这是一个局部two注册组件&lt;/h3&gt;' } } }) &lt;/script&gt; 全局注册组件
书写语法:
Vue.component('自定义组件名称',{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c87e675a775e26d86a07dd4756e4565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b148236b270d69edf9fd530f234af1/" rel="bookmark">
			JVM简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是jvm?
（1）jvm是一种用于计算设备的规范，它是一个虚构出来的机器，是通过在实际的计算机上仿真模拟各种功能实现的。
（2）jvm包含一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域。
（3）JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。
JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。
2.jdk、jre、jvm是什么关系？
（1）JRE(Java Runtime Environment)，也就是java平台。所有的java程序都要在JRE环境下才能运行。
（2）JDK(Java Development Kit)，是开发者用来编译、调试程序用的开发包。JDK也是JAVA程序需要在JRE上运行。
（3）JVM(Java Virtual Machine)，是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。
JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。
Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。
3.JVM原理
（1）jvm是java的核心和基础，在java编译器和os平台之间的虚拟处理器，可在上面执行字节码程序。
（2）java编译器只要面向jvm，生成jvm能理解的字节码文件。java源文件经编译成字节码程序，通过jvm将每条指令翻译成不同的机器码
，通过特定平台运行。
JVM执行程序的过程 加载.class文件
管理并分配内存
执行垃圾收集
JRE（java运行时环境）由JVM构造的java程序的运行环，也是Java程序运行的环境，但是他同时一个操作系统的一个应用程序一个进程，
因此他也有他自己的运行的生命周期，也有自己的代码和数据空间。
JVM在整个jdk中处于最底层，负责于操作系统的交互，用来屏蔽操作系统环境，
提供一个完整的Java运行环境，因此也就虚拟计算机。
操作系统装入JVM是通过jdk中Java.exe来完成，
通过下面4步来完成JVM环境：
创建JVM装载环境和配置
装载JVM.dll
初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例
调用JNIEnv实例装载并处理class类。
5. JVM的生命周期
JVM实例对应了一个独立运行的java程序它是进程级别
a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void
main(String[] args)函数的class都可以作为JVM实例运行的起点
b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以表明自己创建的线程是守护线程
c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出
JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的
6、JVM内存模型
（1）java代码具体执行过程如下图，
（2）运行时数据区，即jvm内存结构图如下图
（3）运行时数据区存储了哪些数据？
a) 程序计数器(PC寄存器)
由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，
因此，为了能够使得每个线程都在线程切换后能够恢复在切　换　之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，
否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，
因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。
b) java栈
Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、
指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b148236b270d69edf9fd530f234af1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e611d7b025fca0fb1d255015735eff/" rel="bookmark">
			Altium Designer绘制一个stm32最小系统的电路原理图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Altium Designer二、新建工程文件三、绘制原理图库1.绘制元器件2.导入元器件库3.绘制模块 一、Altium Designer Altium Designer 是原Protel软件开发商Altium公司推出的一体化的电子产品开发系统，主要运行在Windows操作系统。这套软件通过把原理图设计、电路仿真、PCB绘制编辑、拓扑逻辑自动布线、信号完整性分析和设计输出等技术的完美融合，为设计者提供了全新的设计解决方案，使设计者可以轻松进行设计，熟练使用这一软件使电路设计的质量和效率大大提高。
二、新建工程文件 首先在Altium Designer中新建我们需要的内容，我们需要绘制原理图库，PCB库，PCB和原理图。
根据顺序依次是：
创建好原理图库，将我们需要的元器件放在库中绘制原理图，将元器件放在原理图中，进行连线将原理图中的元器件映射到PCB库中在PCB中进行排版 首先打开AD界面如图所示：
在上面的file中新建中找到原理图，PCB ,下面的库中找到原理图库，PCB元件库，我们下面就需要用到这些内容。
建好四个工程后如图所示：
三、绘制原理图库 1.绘制元器件 我们可以在网上找绘制元器件的视频，因为较为琐碎这里暂且不介绍。
2.导入元器件库 我们可以直接导入现成的元器件库在工程中，这样就不需要我们再进行绘制就可以直接使用。
链接
提取码：mlkt
这里我们先点击文件，然后选择打开，然后选择路径导入所需内容。
然后找到我们需要的模块，点击复制，然后添加到我们的库中。
3.绘制模块 然后就是根据原理图库绘制每个模块，进行连线等等，最后布局得到原理图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b00fadca6c172c230ab8b378e585e9a/" rel="bookmark">
			windows RDP远程连接卡死问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近通过RDP远程一台windows server 2019主机时，频繁发生远程窗口卡住不动，操作无响应，而断开重新登录又是正常的。排查网络带宽利用率和延迟一直正常，发现卡死总是发生在一个特定软件打开的过程中，如果不使用那个软件，远程是不会发生卡死问题的。进一步检测那个软件，它本应该是用GPU跑渲染任务的，结果由于显卡驱动问题，导致软件使用的cpu去跑渲染，把cpu占满，然后现象就是RDP远程频繁卡死。修复显卡驱动后，软件可以用到GPU，使用过程中cpu不再负载过高，RDP也没有卡死了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90593b3f18a7f62c4dc659d28d15183d/" rel="bookmark">
			Vue的系统指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
v-text
v-html
{{}}，v-text，v-html的优缺点
v-on事件绑定
v-once
v-if条件渲染
v-show(条件展示)
v-if和v-show区别: v-model
v-bind
动态类名class
动态样式style
v-for
v-for遍历时key的作用
指令:采用v- 开始的,一般称之为指令.指令通常在属性中-
v-text &lt;script src="./vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 指令:采用v- 开始的,一般称之为指令.指令通常在属性中--&gt; &lt;div v-text="name"&gt;&lt;/div&gt; &lt;div v-text="desc"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ name:'vue', desc:` &lt;div&gt; &lt;ul&gt; &lt;li&gt;海淀&lt;/li&gt; &lt;li&gt;昌平&lt;/li&gt; &lt;li&gt;朝阳&lt;/li&gt; &lt;/ul&gt; &lt;img src="https://gw.alicdn.com/tps/TB1x2eZLVXXXXbCXVXXXXXXXXXX-1130-500.jpg_570x10000Q75.jpg_.webp" alt=""&gt; &lt;/div&gt; ` } }) &lt;/script&gt; v-html &lt;script src="./vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 指令:采用v- 开始的,一般称之为指令.指令通常在属性中--&gt; &lt;div v-html="name"&gt;&lt;/div&gt; &lt;div v-html="desc"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ name:'vue', desc:` &lt;div&gt; &lt;ul&gt; &lt;li&gt;海淀&lt;/li&gt; &lt;li&gt;昌平&lt;/li&gt; &lt;li&gt;朝阳&lt;/li&gt; &lt;/ul&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90593b3f18a7f62c4dc659d28d15183d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/79/">«</a>
	<span class="pagination__item pagination__item--current">80/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/81/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>