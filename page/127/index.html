<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c54633e2bb91fcc60cec9bf292a282/" rel="bookmark">
			JS实现HTML中frameset浏览器全屏和退出全屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;script type="text/javascript"&gt; /* 全屏 */ function fullScreen() { var el = document.documentElement; var rfs = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullScreen; if (typeof rfs != "undefined" &amp;&amp; rfs) { rfs.call(el); } else if (typeof window.ActiveXObject != "undefined") { // for Internet Explorer 模拟按下F11键退出全屏 var wscript = new ActiveXObject("WScript.Shell"); if (wscript != null) { wscript.SendKeys("{F11}"); } } } /* 退出全屏 */ function exitFullScreen() { var el = document; var cfs = el.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c54633e2bb91fcc60cec9bf292a282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6454648a744480476dfa3c21f7a471be/" rel="bookmark">
			【JDBC4.2】JDBC中的Exception
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC中的异常类包括SQLException类和它的子类们。
1.SQLException SQLException包含下面信息：
信息项获取方法备注错误描述SQLException#getMessageSQLStateSQLException#getSQLStateerror codeSQLException#getMessagecauseSQLException#getCause递归获取一个异常上的Throwable多个异常SQLException#getNextException递归如果已经没有异常，返回null 对Chained Execeptions的支持 chained exceptions :异常链或链式异常 在java代码中常常会再捕获一个异常后抛出另外一个异常，并且希望把异常原始信息保存下来，这被称为异常链 JDK1.4以后，所有Throwable的子类子构造器中都可以接受一个cause对象作为参数，这个cause就异常原由，代表着原始异常，即使在当前位置创建并抛出行的异常，也可以通过这个cause追踪到异常最初发生的位置。比如:throw new RuntimeException("ex---2",e1); 把e1加载到另一个异常的异常链上。
SQLException对异常链的支持包括： 1.增加了构造函数支持cause Throwable参数 2.可以使用ForEach循环获取所有Cause（代替每次getNextException后调用getCause） 3.getCause可能返回一个非SQLException的Exception
定位SQLExceptions的代码 在执行SQL的时候，可能会出现多个Exception，每个Exception都有它们自己的Cause。可以递归使用getNextException获取所有的Exception，每次获取Exception时候再递归调用getCause获取所有Cause Throwable。
try{ //... }catch(SQLException ex) { while(ex != null) { System.out.println("SQLState:" + ex.getSQLState()); System.out.println("Error Code:" + ex.getErrorCode()); System.out.println("Message:" + ex.getMessage()); Throwable t = ex.getCause(); while(t != null) { System.out.println("Cause:" + t); t = t.getCause(); } ex = ex.getNextException(); } } 使用ForEach直接获取所有Cause Throwable
try{ //... }catch(SQLException ex) { for(Throwable e : ex ) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6454648a744480476dfa3c21f7a471be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b27538465b67c02e9a10f8c828db0e0/" rel="bookmark">
			Latex的常见错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、! Undefined control sequence. l.101 \subfigure [Small Box with a Long Caption] 问题就是 \subfigure是一个未定义的命令。应该加上定义。至于\subfigure是在哪里定义的，你要查到信息的方法有很多。最快的方法就是google或者baidu，输入\subfigure，latex，未定义之类的关键词，搜索，就能在结果当中找到答案。 找到这句话：注意要使用宏包\usepackage{graphicx} 和\usepackage{subfigure} 那么，你在导言区加入以上两句就行了。 其实我觉得LATEX2e 插图指南应该有说调用哪个宏包，建议楼主仔细阅读。 2、并列的子图形 \begin{figure} \subfigure[Small Box with a Long Caption]{ \label{fig:mini:subfig:a} %% label for first subfigure \begin{minipage}[b]{0.5\textwidth} \centering \includegraphics[width=1in]{graphic.eps} \end{minipage}}% \subfigure[Big Box]{ \label{fig:mini:subfig:b} %% label for second subfigure \begin{minipage}[b]{0.5\textwidth} \centering \includegraphics[width=1.5in]{graphic.eps} \end{minipage}} \caption{Minipages Inside Subfigures} \label{fig:mini:subfig} %% label for entire figure \end{figure} 参考：http://www.ctex.org/documents/latex/graphics/node111.html 3、latex中错误：”Unknown graphics extension: .eps“ 或者在插入图片时明明有这个文件 但是can not find ** 错误原因：很简单， 就是使用includegraphics插入图片为eps格式，是多数参考书籍给出的方法，但此种方法只能用latex默认编译器使用，如果使用Ctex（中国改造版，默认为pdflaTex），则不能。是图片和pdflatex一起用时的错误，参考下面引用： 两种解决方法： 1、可以将eps文件转换为pdf图片或jpg图片。 2、用latex而不是pdflatex： tex处理过tex文件后生成dvi文件，然后通过dvipdf转换成pdf文件； pdflatex直接处理tex文件，输出pdf文件，pdflatex使用jpg，png能图片格式，不能使用eps文件。但用latex后，模板Singapore就不会有像pdflatex很好的效果，底色都变成了白的。 4、pdf书签乱码的解决方法主要是通过编译时来解决的,可在终端(也叫命令行吧)下如下运行编译: latex template GBK2uni template latex template bibtex template makeindex template.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b27538465b67c02e9a10f8c828db0e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c02fe40ed5020fbb56b73a044077317/" rel="bookmark">
			Echarts四周的边框的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在使用echarts的时候，突然发现页面高度不够用了。需要将echarts周围的边框去掉，以此腾出空间。
通过翻阅api终于找到grid选项可以操作。通过博客记录一下
grid:直角坐标系内绘图网格
{number} zlevel 0 一级层叠控制。每一个不同的zlevel将产生一个独立的canvas，相同zlevel的组件或图标将在同一个canvas上渲染。zlevel越高越靠顶层，canvas对象增多会消耗更多的内存和性能，并不建议设置过多的zlevel，大部分情况可以通过二级层叠控制z实现层叠控制。 {number} z 0 二级层叠控制，同一个canvas（相同zlevel）上z越高约靠顶层。 {number | string} x 80 直角坐标系内绘图网格左上角横坐标，数值单位px，支持百分比（字符串），如'50%'(显示区域横向中心) {number | string} y 60 直角坐标系内绘图网格左上角纵坐标，数值单位px，支持百分比（字符串），如'50%'(显示区域纵向中心) {number | string} x2 80 直角坐标系内绘图网格右下角横坐标，数值单位px，支持百分比（字符串），如'50%'(显示区域横向中心) {number | string} y2 60 直角坐标系内绘图网格右下角纵坐标，数值单位px，支持百分比（字符串），如'50%'(显示区域纵向中心) {number} width 自适应 直角坐标系内绘图网格（不含坐标轴）宽度，默认为总宽度 - x - x2，数值单位px，指定width后将忽略x2，见下图。 支持百分比（字符串），如'50%'(显示区域一半的宽度) {number} height 自适应 直角坐标系内绘图网格（不含坐标轴）高度，默认为总高度 - y - y2，数值单位px，指定height后将忽略y2，见下图。 支持百分比（字符串），如'50%'(显示区域一半的高度) {color}backgroundColor 'rgba(0,0,0,0)' 背景颜色，默认透明。 {number}borderWidth 1 边框线宽 {color}borderColor '#ccc' 边框颜色。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81acb8ca685365b0c3ba98f14a99f021/" rel="bookmark">
			eclipse里启动rabbitmq报错 java.net.SocketException: Connection reset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是因为当前用户设置 Virtual Hosts有问题,问题具体描述可以看看http://blog.csdn.net/only09080229/article/details/43304543
如何解决这个问题？只要正确设置当前用户的 Virtual Hosts并和用户绑定就行了。
例如你想添加一个/Admin 的virtual hosts 并和用户绑定。
设置办法见图：
步骤一：添加virtual hosts
1 点击Admin 2 点击virtual hosts
3 在3处name 添加 /admin
4 点击4 Add virtual host 按钮
5 就可以在5处看到结果了
步骤二：绑定用户
现在virtual hosts设置好了，下一步和用户绑定
点击5
单击1处下拉框选择当前的virtual hosts 绑定的用户
单击2 set permission即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be54c50f221784932ec662320a7e3fca/" rel="bookmark">
			python中矩阵（matrix或array）运算比for循环速度更快
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在matlab中进行矩阵元素处理时，使用矩阵运算比for循环快。在Python语言中也是这样的。下面这个程序是一个简单的测试。
import time as tm import numpy as np dim = 100000#数据长度(包含的元素个数) x1 = np.ones(dim) x2 = np.ones(dim) yFor = np.ones(dim) tStart = tm.clock()#开始计时 #for循环解算x1*x2(对应元素相乘) for i in range(dim): yFor[i] = x1[i]*x2[i] tEnd=tm.clock()#停止计时 tFor = tEnd-tStart#计算用时 tStart = tm.clock()#开始计时 #矩阵计算x1*x2(对应元素相乘) yMatrix = x1*x2 tEnd = tm.clock()#停止计时 tMatrix = tEnd-tStart#计算用时 print 'for循环用时tFor=',tFor print '矩阵运算用时tMatrix=',tMatrix print '运算用时tFor-tMatrix=',tFor-tMatrix print '运算结果的差(所有元素累积和)yFor-yMatrix=',np.sum(yFor-yMatrix) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45024ecb6803cdc4aee4c02eb465be96/" rel="bookmark">
			Asp.Net Cookie 和 Session 的编写、读取 和 删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Cookie（分两种操作方式）
（一）第一种操作方式
#region 第一种操作方式 //（一）未带子健的 Cookie //1.编写（创建 和 修改 一样） HttpCookie cookie = new HttpCookie("userName"); cookie.Value = "李春林"; cookie.Expires = DateTime.Now.AddHours(1); Response.Cookies.Add(cookie); //2.读取 if (Request.Cookies["userName"] != null) { string userName = Request.Cookies["userName"].Value; userName = Server.HtmlEncode(userName);//确保恶意用户没有向 Cookie 中添加可执行脚本 } //3.删除 HttpCookie cookie = new HttpCookie("userName"); cookie.Expires = DateTime.Now.AddHours(-1); Response.Cookies.Add(cookie); //（二）带子健的 Cookie //1.编写（创建 和 修改 一样） HttpCookie cookie = new HttpCookie("userInfo"); cookie.Values["userName"] = "李春林"; cookie.Expires = DateTime.Now.AddDays(1); Response.Cookies.Add(cookie); //2.读取 if (Request.Cookies["userInfo"] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45024ecb6803cdc4aee4c02eb465be96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a3db278c5f3f821f23238d41a442a6/" rel="bookmark">
			lombok注解介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lombok注解介绍 lombok注解文档 lombok官网下载
lombok是一个可以帮助我们简化java代码编写的工具类，尤其是简化javabean的编写，即通过采用注解的方式，消除代码中的构造方法，getter/setter等代码，使我们写的类更加简洁，当然，这带来的副作用就是不易阅读…不过，还是能看得懂吧，废话不多说，先看一下lombok支持的一些常见的注解。
@NonNull@Cleanup@Getter/@Setter@ToString@EqualsAndHashCode@NoArgsConstructor/@RequiredArgsConstructor /@AllArgsConstructor@Data@Value@SneakyThrows@Synchronized@Log @NonNull 这个注解可以用在成员方法或者构造方法的参数前面，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，举个例子来看看：
//成员方法参数加上@NonNull注解 public String getName(@NonNull Person p){ return p.getName(); } 实际效果相当于：
public String getName(@NonNull Person p){ if(p==null){ throw new NullPointerException("person"); } return p.getName(); } 用在构造方法的参数上效果类似，就不再举例子了。
@Cleanup 这个注解用在变量前面，可以保证此变量代表的资源会被自动关闭，默认是调用资源的close()方法，如果该资源有其它关闭方法，可使用@Cleanup(“methodName”)来指定要调用的方法，就用输入输出流来举个例子吧：
public static void main(String[] args) throws IOException { @Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[1024]; while (true) { int r = in.read(b); if (r == -1) break; out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97a3db278c5f3f821f23238d41a442a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90185d659251429c30a4097746441a3/" rel="bookmark">
			Asp.Net WebForm 母版页&#43;用户控件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		母版页： 是整体代码，布局位置是固定的。
用户控件： 是用局部代码 位置不固定，比如登录框。
【一、母版页】
[方式一，常用：]
1.新建母版页：在项目上面单击右键→添加→添加新项→模板页。
2.新建子页面：在项目上面单击右键→添加→添加新项→使用母版页的 Web 窗体（针对vs2012）,会弹出【选择母版页】选项卡。
3.在母版页里面“挖坑”：
&lt;asp:ContentPlaceHolder Id="a" runat="server"&gt;&lt;/asp:ContentPlaceHolder&gt; 4.要在子页面填充需写的代码为：
&lt;asp:Content ID="contentbody" ContentPlaceHolderID="a" runat="server"&gt;&lt;/asp:Content&gt; 注意：母版页可以不用&lt;form id="form1" runat="server"&gt;标签。
[方式二：]
首先：文件→新建→网站→已安装→模板→Visual C#→空网站
然后：在项目上面单击右键→添加→添加新项→模板页
最后：在项目上面单击右键→添加→添加新项→Web窗体，【并在右下角选择选择模板页。】
【二、用户自定义控件】
1.在项目上面单击右键→添加→Web 用户控件
2.在ascx页面写局部代码，然后将其拖放到需要使用的页面。
3.手动添加如下：
3.1 用户控件名为：uc.ascx
3.2 用户控件指令集：
&lt;%@ Control Language="C#" AutoEventWireup="true" CodeBehind="uc.ascx.cs" Inherits="C01ListViewTest.测试.uc" %&gt; 3.3* 使用页添加指令集为：
&lt;%@ Register Src="~/测试/uc.ascx" TagPrefix=【"uc1"】 TagName=【"uc"】 %&gt; 3.4* 使用页代码为：
&lt;uc1:WebUserControl1 runat="server" id="WebUserControl1" /&gt; 注意：一个自定义控件在一个页面可以多次使用,并且可以写后台代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e22a51f2ed482d1c71f20f783728c9cb/" rel="bookmark">
			web前端之锋利的jQuery二：jQuery选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web前端之锋利的jQuery二：jQuery选择器 1.css选择器 标签选择器：E{CSS规则} ID选择器：#ID{CSS规则} 类选择器：.className{CSS规则} 群选择器：E1,E2,E3{CSS规则} 后代选择器：E F{CSS规则} 通配选择器：*{CSS规则} 其他选择器：伪类选择器（E:PseudoElements{CSS规则}）、子选择器(E&gt;F{CSS规则})、临近选择器(E + F{CSS规则})、属性选择器(E[attr]{CSS规则})
2.jQuery选择器 jQuery选择器完全继承了CSS的风格。利用jQuery选择器，可以非常便捷和快速地找出特定的DOM元素，然后为他们添加相应的行为。
&lt;script type="text/javascript"&gt; function demo(){ alert('javascript demo'); } &lt;/script&gt; &lt;p onclick="demo();"&gt;点击我&lt;/p&gt; &lt;script type="text/javascript"&gt; $(".demo").click(function(){ alert(' jquery demo'); }); &lt;/script&gt; &lt;p class="demo"&gt;点击我&lt;/p&gt; jQuery选择器的优势： $()函数在很多JavaScript类库中都被作为一个选择器函数来使用，$(“#ID”)用来代替document.getElementById()函数。通过$(“tagName”)来代替document.getElementsByTagName()函数。 jQuery选择支持CSS1、CSS2的全部和CSS3的部分选择器。
&lt;div&gt;test&lt;/div&gt; &lt;script type="text/javascript"&gt; document.getElementById("tt").style.color="red"; &lt;/script&gt; //报错，因为没有ID为tt的元素 //改进版 &lt;div&gt;test&lt;/div&gt; &lt;script type="text/javascript"&gt; if(docuemnt.getElementById("tt")){ docuemnt.getElementById("tt").style.color="red"; } &lt;/script&gt; //这样可以解决这个问题，但是代码量无疑变多了 &lt;div&gt;test&lt;/div&gt; &lt;script type="text/javascript"&gt; $("#tt").css("color","red");//这里无需判断$("#tt")是否存在 &lt;/script&gt; jQuery选择器：
基本选择器： #id 给指定的id匹配一个元素$(‘#id’) .class 给指定的class匹配元素$(‘.class’) element 给指定的元素名匹配元素 $(‘element’) * 匹配所有元素 $(‘*’) selector1,selectro2… 将每个匹配到的元素合并后一起返回 $(‘selector1,selectro2’)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e22a51f2ed482d1c71f20f783728c9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353371520a21d1fe95dc0878d7ac4f90/" rel="bookmark">
			JQuery实现旅游导航菜单应用方便
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最终实现的效果是如图所示
HTML部分代码
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;demo&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/index.css" /&gt; &lt;!--[if IE 6]&gt; &lt;script type="text/javascript" language="javascript" src="js/png.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/web.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="product_sort fl"&gt; &lt;div class="hd"&gt;旅游产品导航&lt;/div&gt; &lt;div class="bd"&gt; &lt;div class="item"&gt; &lt;div class="title one"&gt;&lt;a href="http://www.htmlsucai.com"&gt;&lt;i&gt;&lt;/i&gt;出境游&lt;/a&gt;&lt;/div&gt; &lt;div class="list"&gt; &lt;a href="http://www.htmlsucai.com"&gt;泰国&lt;/a&gt; &lt;a href="http://www.htmlsucai.com"&gt;首尔&lt;/a&gt; &lt;a href="http://www.htmlsucai.com"&gt;曼谷&lt;/a&gt; &lt;a href="http://www.htmlsucai.com"&gt;大阪&lt;/a&gt; &lt;a href="http://www.htmlsucai.com"&gt;普吉岛&lt;/a&gt; &lt;/div&gt; &lt;div class="arrow"&gt;&gt;&lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/353371520a21d1fe95dc0878d7ac4f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be4fe3a2d2cb1d74276e2624ded07ffe/" rel="bookmark">
			SQL对数据进行统计、常用集合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生表：
1、统计记录个数
1） count（【all】*）【as 列别名】 返回表中的记录数
执行：SELECT COUNT (* ) FROM 学生表
结果为：
执行：SELECT COUNT (* ) as 学生总人数 FROM 学生表
结果为：
2） COUNT(列名) 函数返回指定列的值的数目（NULL 值不计入）
执行：SELECT COUNT (专业代码) FROM [ts].[dbo].[学生表]
结果为：
3） COUNT(distinct 列名) 返回指定列的不同值的数目（NULL 值不计入） 执行：SELECT COUNT (distinct 专业代码) FROM [ts].[dbo].[学生表]
结果为：
2、计算某一列值的总和
格式：select sum (column_name) from table_name 执行：SELECT sum(高考分数) as 高考总分数 FROM [ts].[dbo].[学生表]
结果为：
3、求某一列值的最大值 格式：select max (column_name) from table_name MAX 函数返回一列中的最大值。NULL 值不包括在计算中。
注释：MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be4fe3a2d2cb1d74276e2624ded07ffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af771a6b5ed4bdcf03a47170f36f0ce/" rel="bookmark">
			Android 仪表进度条 自定义View
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 自定义仪表进度条浅析 最近写了几个小教程，一次性发出来吧，今天最后一篇，继续玩一玩自定义View吧，这次加上了自定义属性，即，在xml中引用该控件可以通过自定义属性设置一些效果。该进度条实现了颜色渐变等，是出门旅行，熟悉自定义View之必备补品，可直接用于实际项目，已优化，比如下载东西展示个进度什么的，知识点掌握之后，你想怎么折腾就怎么折腾吧。 (Gradle Build)
原创帖，转载请注明出处，开源思想，欢迎关注探讨Github：https://github.com/Zjinji/MeterView 作者：尽际
目录 Android 自定义仪表进度条浅析 目录学习流程 基础知识绘制技巧Have Fun附上截图 学习流程： 基础知识
绘制技巧
Have fun
基础知识 1、Canvas旋转 a、baseCanvas.rotate(1, 2, 3); 参数1：画布旋转角度，负数为逆时针，正数为顺时针 参数2：旋转围绕的中心x坐标 参数3：旋转围绕的中心y坐标 2、attrs定义 a、在values文件夹中，创建attrs.xml文件，文件内容大致如下， 主要是定义一些后续会使用到的属性： &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources&gt; &lt;declare-styleable name="MeterView"&gt; &lt;attr name="arcColor" format="color"/&gt; &lt;attr name="arcWidth" format="dimension"/&gt; &lt;attr name="text" format="string"/&gt; &lt;attr name="levelCount" format="integer"/&gt; &lt;attr name="innerCircleColor" format="color"/&gt; &lt;attr name="pointerColor" format="color"/&gt; &lt;attr name="textSize" format="dimension"/&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; 3、TypedArray a、在自定义View的构造方法中，通过该对象得到引用资源，即 TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MeterView, defStyleAttr, 0); b、 参数1：attrsSet集合 参数2：你刚才定义的declare-styleable 参数3：默认样式 这个默认样式为如果用户没有显示的在xml中使用你刚才的属性，那么这些属性的默认值是多少，你可以自己设定一下，比如： &lt;style name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5af771a6b5ed4bdcf03a47170f36f0ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b09f4d1eb31716c1b3a9025e9f90ac0/" rel="bookmark">
			J2EE之java自定义注解在项目中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		J2EE之java自定义注解在项目中的使用 源代码： Filter.java:
package com.imooc.test; @Table("user")//表名 public class Filter { @Column("id")//数据名 private int id; @Column("user_name")//数据名 private String userName; @Column("nick_name")//数据名 private String nickName; @Column("age")//数据名 private int age; @Column("city")//数据名 private String city; @Column("email")//数据名 private String email; @Column("mobile")//数据名 private String mobile; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getNickName() { return nickName; } public void setNickName(String nickName) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b09f4d1eb31716c1b3a9025e9f90ac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52916c14be3c33b6f84d2fd5ad893111/" rel="bookmark">
			J2EE之java的注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		J2EE之java的注解 例子： JDK自带的注解：
Person.java:
package com.ann.test; public interface Person { public String name(); public int age(); @Deprecated //表示方法过时 public void sing(); } Child.java:
package com.ann.test; public class Child implements Person{ @Override // 表示被重写 public String name() { // TODO Auto-generated method stub return null; } @Override public int age() { // TODO Auto-generated method stub return 0; } @Override public void sing() { // TODO Auto-generated method stub } } Test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52916c14be3c33b6f84d2fd5ad893111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da106a708ebf59b1efeb4d2dac090294/" rel="bookmark">
			JVM常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 内存模型以及分区，需要详细到每个区放什么。
栈区：
栈分为java虚拟机栈和本地方法栈
重点是Java虚拟机栈，它是线程私有的，生命周期与线程相同。
每个方法执行都会创建一个栈帧，用于存放局部变量表，操作栈，动态链接，方法出口等。每个方法从被调用，直到被执行完。对应着一个栈帧在虚拟机中从入栈到出栈的过程。
通常说的栈就是指局部变量表部分，存放编译期间可知的8种基本数据类型，及对象引用和指令地址。局部变量表是在编译期间完成分配，当进入一个方法时，这个栈中的局部变量分配内存大小是确定的。
会有两种异常StackOverFlowError和 OutOfMemoneyError。当线程请求栈深度大于虚拟机所允许的深度就会抛出StackOverFlowError错误；虚拟机栈动态扩展，当扩展无法申请到足够的内存空间时候，抛出OutOfMemoneyError。
本地方法栈为虚拟机使用到本地方法服务（native）
堆区：
堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。
堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区最要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。
不过很多文章介绍分为3个区块，把方法区算着为永久代。这大概是基于Hotspot虚拟机划分，然后比如IBM j9就不存在永久代概论。不管怎么分区，都是存放对象实例。
会有异常OutOfMemoneyError
方法区：
被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment generation）
垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池回收，类型卸载。
常量池用于存放编译期生成的各种字节码和符号引用，常量池具有一定的动态性，里面可以存放编译期生成的常量；运行期间的常量也可以添加进入常量池中，比如string的intern()方法。
程序计数器：
当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。
Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程私有的。
唯一一块Java虚拟机没有规定任何OutofMemoryError的区块。
2. 堆里面的分区：Eden，survivalfrom to，老年代，各自的特点。
1.JVM中堆空间可以分成三个大区，新生代、老年代、永久代
2.新生代可以划分为三个区，Eden区，两个幸存区
在JVM运行时，可以通过配置以下参数改变整个JVM堆的配置比例
1.JVM运行时堆的大小
-Xms堆的最小值
-Xmx堆空间的最大值
2.新生代堆空间大小调整
-XX:NewSize新生代的最小值
-XX:MaxNewSize新生代的最大值
-XX:NewRatio设置新生代与老年代在堆空间的大小
-XX:SurvivorRatio新生代中Eden所占区域的大小
3.永久代大小调整
-XX:MaxPermSize
4.其他
-XX:MaxTenuringThreshold,设置将新生代对象转到老年代时需要经过多少次垃圾回收，但是仍然没有被回收
复制（Copying）算法
将内存平均分成A、B两块，算法过程：
1. 新生对象被分配到A块中未使用的内存当中。当A块的内存用完了， 把A块的存活对象对象复制到B块。
2. 清理A块所有对象。
3. 新生对象被分配的B块中未使用的内存当中。当B块的内存用完了， 把B块的存活对象对象复制到A块。
4. 清理B块所有对象。
5. goto 1。
优点：简单高效。缺点：内存代价高，有效内存为占用内存的一半。
对复制算法进一步优化：使用Eden/S0/S1三个分区
平均分成A/B块太浪费内存，采用Eden/S0/S1三个区更合理，空间比例为Eden:S0:S1==8:1:1，有效内存（即可分配新生对象的内存）是总内存的9/10。
算法过程：
1. Eden+S0可分配新生对象；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da106a708ebf59b1efeb4d2dac090294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9e978c3f56043c99b5d68d35a184a1/" rel="bookmark">
			Spring及J2EE常用注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1， @Controller
用来标记控制类
2， @RequestMapping()
用来标记在controller类上或者方法上，做地址映射
3， @Autowired
注释在成员变量上spring就会将其以Byname的形式自动化注入到spring容器中，因此便省去了get/set方法和spring配置文件的配置
4， @Service
标记业务逻辑层Bean
5, @Resource
这个注解不属于spring,是J2EE的注解；注解与@Autowried的使用方法一样，但是建议使用@Resource。
@Resource与@Autowried的不同就是@Autowried是是通过Bytype的方式注入spring的，而@Resource是通过Byname或Bytype方式注入spring的。@Resource有两个重要的属性分别是name和type，spring将属性name解析为bean的名字，而将type属性解析成bean的类型。如果使用name属性就是使用Byname自动注入策略，如果使用type属性就是使用Bytype自动修护乳策略，如果即不指定name也不指定type，那么spring就通过反射机制使用Byname自动注入策略。如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配（见2）；如果没有匹配，则回退为一个原始类型（UserDao）进行匹配，如果匹配则自动装配；
6，@Transational
标记该方法是事务执行的；
7，@Repository
标记数据访问层Bean
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8babdbe6081ce33993b4f794be814e39/" rel="bookmark">
			牛吃草问题的实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		牛吃草问题 1.牧场上有一片匀速生长的草地，可供27头牛吃6周，或供23头牛吃9周，那么它可供21头牛吃几周？ 解答这类问题，困难在于草的总量在变，它每天，每周都在均匀地生长，时间愈长，草的总量越多.草的总量是由两部分组成的：某个时间期限前草场上原有的草量；这个时间期限后草场每天（周）生长而新增的草量.因此，必须设法找出这两个量来。 假设一头牛一周吃草一份 则23头牛9周吃的总草量：1×23×9=207份 27头牛6周吃的总草量：1×27×6=162份 所以每周新生长的草量：（207-162）÷（9-6）=15份 牧场上原有草量：1×27×6-15×6=72份，（或1×23×9-15×9=72份） 牧场上的草21头牛几周才能吃完呢？解决这个问题相当于把21头牛分成两部分：一部分看成专吃牧场上原有的草，另一部分看成专吃新生长的草. 假设有15头牛专吃新生长的草，另一部分21-15=6头牛专去吃原有的草 则牧场上原有的的草够吃72÷6=12周 即这个牧场上的草够21头牛吃12周. 2.由于天气逐渐变冷，牧场上的草每天以均匀的速度减少。已知某草地上的草可供20头牛吃5天，或供15头牛吃6天。那么它可供多少头牛吃10天？ 假设一头牛一天吃草一份 则20头牛5天吃的总草量：1×20×5=100份 15头牛6天吃的总草量：1×15×6=90份 所以每天枯草量：（100-90）÷（6-5）=10份 牧场上原有草量：1×20×5+10×5=150份 牧场上的草可供多少头牛吃10天？ （150-10×10）÷10=5头牛 3.一块草地，每天生长的速度相同.现在这片牧草可供16头牛吃20天，或者供80只羊吃12天.如果一头牛一天的吃草量等于4只羊一天的吃草量，那么10头牛与60只羊一起吃可以吃多少天？ 由于1头牛每天的吃草量等于4只羊每天的吃草量，故60只羊每天的吃草量和15头牛每天吃草量相等，80只羊每天吃草量与20头牛每天吃草量相等。 所以问题可转化为：这片牧草可供16头牛吃20天，或者供20头牛吃12天.那么（10+15）=25头牛可以吃多少天 设一牛一天吃草一份 则每天长草（1×16×20-1×20×12）÷（20-12）=10份　原有草1×16×20-10×20=120份 假设25头牛中，10头牛专吃每天新长的10份草，另外的25-10=15头牛专吃原有草 则120÷15=8天 即这块草场可供10头牛和60只羊吃8天。 4.一只船发现漏水时，已经进了一些水，水匀速进入船内.如果12人淘水，3小时淘完；如5人淘水，10小时淘完.如果要求2小时淘完，要安排多少人淘水？ 设1人1小时的淘水量为“1份” 则12人3小时淘水：1×12×3=36份 5人10小时淘水：1×5×10=50份 所以每小时漏进水：（50-36）÷（10-3）=2份 淘水时已漏进的水：36-2×3=30份 所以如果要求2小时淘完，要安排（30+2×2）÷2=17人淘水 5.一水库原有存水量一定，河水每天均匀入库.5台抽水机连续20天可抽干；6台同样的抽水机连续15天可抽干.若要求6天抽干，需要多少台同样的抽水机？ 设1台抽水机连1天抽水1份 则5台抽水机连续20天抽水5×20=100份 6台抽水机连续15天抽水6×15=90份 每天进水（100-90）÷（20-15）=2份 原有的水100-2×20=60份 所以若6天抽完，共需抽水机（60+2×6）÷6=12台 6.有三块草地，面积分别为5、6和8公顷。草地上的草一样厚，而且长得一样快。第一块草地可供11头牛吃10天，第二块草地可供12头牛吃14天。问第三块草地可供19头牛吃多少天？ 将三块草地的面积统一起来： 即[5，6，8]=120 第一块草地可供11头牛吃10天，120/5=24，变为120公顷草地可供11×24=264头牛吃10天 第二块草地可供12头牛吃14天，120/6=20，变为120公顷草地可供12×20=240头牛吃14天 120/8=15，问题变为120公顷草地可供19×15=285头牛吃多少天 于是，假设一头牛一天吃草一份 所以120公顷草地每天新生长的草：（240×14-264×10）÷（14-10）=180份 120公顷草地原有草：264×10-180×10=840份 所以可供285头牛吃840÷（285-180）=8天 即第三块草地可供19头牛吃8天 7.经测算，地球上资源可供100亿人生活100年，或可供80亿人生活300年。假设地球新生资源速度一定，那么为满足人类不断发展需要，地球最多能养活多少亿人？ 设1亿人1年消费资源1份 则100亿人生活100年消费资源100*100=10000份 80亿人生活300年消费资源80*300=24000份 所以每年新生资源（24000-10000）÷（300-100）=70份 为满足人类不断发展需要，应使每年消费的总资源不超过每年新生资源 所以地球最多能养活70÷1=70亿人 8.某车站在检票前若干分钟就开始排队，每分钟来的旅客人数一样多。从开始检票到等候检票的队伍消失，同时开4个检票口需30分钟，同时开5个检票口需20分钟，如果同时开7个检票口，那么需多少分钟？ 假设1个检票口1分钟检票1组 则4个检票口30分钟检票4*30=120组 5个检票口20分钟检票5*20=100组 所以每分钟来的旅客：（120-100）÷（30-20）=2组 开始检票前已来旅客：120-2×30=60组 所以如果同时开7个检票口，那么需60÷（7-2）=12分钟 9.画展9点开门，但早有人排队等候入场，从第一个观众来到时起，每分钟来的观众人数一样多，如果开3个入场口，9点9分就不再有人排队；如果开5个检票口，9点5分就没有人排队。那么第一个观众到达时间是8点多少分？ 假设1个入口1分钟进入人数为1组 则3个入口9分钟进入人数3*9=27组 5个入口5分钟进入人数5*5=25组 所以每分钟来的观众人数：（27-25）÷（9-5）=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8babdbe6081ce33993b4f794be814e39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ccff1d2e50b96be16728b4d5bd878f/" rel="bookmark">
			J2EE基础知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		J2SE基础
1. 九种基本数据类型的大小，以及他们的封装类。
基本类型 大小(字节) 默认值 封装类
byte 1 (byte)0 Byte
short 2 (short)0 Short
int 4 0 Integer
long 8 0L Long
float 4 0.0f Float
double 8 0.0d Double
boolean - false Boolean
char 2 \u0000(null) Character
void - - Void
基本类型所占的存储空间是不变的：这种不变性也是java具有可移植性的原因之一。
基本类型是放在栈中，直接存储值。
所有数值类型都有正负号，没有无符号的数值类型。
注意：
1.int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。
2.基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值
3.数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。
2. Switch能否用string做参数？
在 Java 7之前，switch 只能支持 byte、short、char、int或者其对应的封装类以及Enum 类型。在 Java 7中，String支持被加上了。
3. equals与==的区别。
1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。
2.复合数据类型(类)，当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。 对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。
3.String比较特殊：new的作为复合数据类型，直接双引号的作为基本类型。
4. Object有哪些公用方法？
1)．clone方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17ccff1d2e50b96be16728b4d5bd878f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b577d1a5f98d637c4feb65b89a37c2c/" rel="bookmark">
			一些JAVA面试知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 九种基本数据类型的大小，以及他们的封装类。 基本类型 大小(字节) 默认值 封装类 byte 1 (byte)0 Byte short 2 (short)0 Short int 4 0 Integer long 8 0L Long float 4 0.0f Float double 8 0.0d Double boolean - false Boolean char 2 \u0000(null) Character void - - Void 基本类型所占的存储空间是不变的：这种不变性也是java具有可移植性的原因之一。 基本类型是放在栈中，直接存储值。 所有数值类型都有正负号，没有无符号的数值类型。 注意： 1.int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。 2.基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值 3.数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。 2. Switch能否用string做参数？ 在 Java 7之前，switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。在 Java 7中，String支持被加上了。 3. equals与==的区别。 1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。 2.复合数据类型(类)，当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。 对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 3.String比较特殊：new的作为复合数据类型，直接双引号的作为基本类型。 4. Object有哪些公用方法？ 1)．clone方法 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。 主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。 2)．getClass方法 final方法，获得运行时类型。 3)．toString方法 该方法用得比较多，一般子类都有覆盖。 4)．finalize方法 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。 5)．equals方法 该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。 6)．hashCode方法 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 一般必须满足obj1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b577d1a5f98d637c4feb65b89a37c2c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/126/">«</a>
	<span class="pagination__item pagination__item--current">127/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/128/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>