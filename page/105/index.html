<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a805d5bf629a28d4b08d271bf2d57fe/" rel="bookmark">
			JdbcTemplate对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述
使用 例子 插入
修改
删除
查询
queryForMap()：查询结果，将结果集封装为map集合
queryForList()：查询结果，将结果集封装为list集合
query()：查询结果，将结果集封装为JavaBean对象
queryForObject：查询结果，将结果集封装为对象
描述 JdbcTemplate是Spring框架对JDBC的简单封装，依赖于数据源DataSource
使用 要是用得先导包
调用JdbcTemplate的方法来完成CRUD的操作
update()：执行DML语句。增、删、改语句queryForMap()：查询结果，将结果集封装为map集合queryForList()：查询结果，将结果集封装为list集合query()：查询结果，将结果集封装为JavaBean对象queryForObject：查询结果，将结果集封装为对象 例子 下面我们用一个例子说明，为何封装方便，例子用到：
druid连接池以及Jdbc工具类单元测试 package com.lingaolu; import org.springframework.jdbc.core.JdbcTemplate; /** * @author 林高禄 * @create 2020-06-28-9:43 */ public class TemplateDemo { private JdbcTemplate template = new JdbcTemplate(JdbcUtils.getDataSource()); } 用到的数据库表
学生表 班级表 插入 @Test public void insert() { String sql = "insert into student(name,class_id,ageNum) values('王帅',2,22)"; int update = template.update(sql); System.out.println(update); } 运行输出：
1
运行后学生表中的数据多了一条王帅
修改 @Test public void update(){ String sql = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a805d5bf629a28d4b08d271bf2d57fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc67aa535fede0cf878c71cd7e7d98e1/" rel="bookmark">
			Halcon学习---毛刺凸点检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路：二进制阈值分割图像---》用圆形区域进行闭运算---》背景差分，得出不同点---》用矩形开操作去除小点，保留真正的差异点---》得到真正差异点的面积和中心点
fin.hdev dev_update_window ('off') read_image (Fins, 'fin' + [1:3]) get_image_size (Fins, Width, Height) dev_close_window () dev_open_window (0, 0, Width[0], Height[0], 'black', WindowID) set_display_font (WindowID, 14, 'mono', 'true', 'false') for I := 1 to 3 by 1 select_obj (Fins, Fin, I) dev_display (Fin) *二进制阈值分割图像 binary_threshold (Fin, Background, 'max_separability', 'light', UsedThreshold) dev_set_color ('blue') dev_set_draw ('margin') dev_set_line_width (4) dev_display (Background) disp_continue_message (WindowID, 'black', 'true') stop () *用圆形区域进行闭运算，能达到保留圆弧边，消除毛刺效果 closing_circle (Background, ClosedBackground, 250) dev_set_color ('green') dev_display (ClosedBackground) disp_continue_message (WindowID, 'black', 'true') stop () *背景差分，得出不同点 difference (ClosedBackground, Background, RegionDifference) *用矩形开操作去除小点，保留真正的差异点 opening_rectangle1 (RegionDifference, FinRegion, 5, 5) dev_display (Fin) dev_set_color ('red') dev_display (FinRegion) *得到真正差异点的面积和中心点 area_center (FinRegion, FinArea, Row, Column) if (I &lt; 3) disp_continue_message (WindowID, 'black', 'true') stop () endif endfor 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39dfa02644cebcf674a460a2cc0fb77/" rel="bookmark">
			浅谈ES6模块化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是ES6模块化 在ES6之前，JS一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法将他们拼装起来。尽管社区制定了一些模块加载方案，主要有CommonJS和AMD两种，但是这两种方案都有自己的局限性，前者主要用于服务器，后者主要用于浏览器。
ES6在语言规格的层面上实现了模块功能，而且实现的相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。
ES6模块的设计思想是尽量静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD都只能在运行时确定这些东西。（运行时加载的缺陷是只有在运行时才能得到整个对象，导致无法在编译时进行静态优化）
import {start,exists,readFile} from 'fs'; //上面代码的实质是从fs模块加载这3个方法，而不加载其他方法，这种加载方式称为'编译时加载'或者 //静态加载，即ES6在编译时即可完成模块加载，显然这个效率比CommonJS高 注：ES6的模块自动采用严格模式，不管有没有在模块头部加上'use strict'
二、ES6模块的使用 ES6模块的功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块的功能。
export命令 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。export命令除了输出变量，还可以输出函数或类。
通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。例如：
function v1(){} function v2(){} export { v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion } 上面的代码使用as关键字重命名了函数v1和v2的对外接口，重命名后v2可以用不同的名字输出两次。
需要特别注意的是：export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。
//报错，不能直接输出1 export 1; //报错，依然直接输出1,1只是一个值，不是一个接口 let num = 1; export num; 可以改成以下写法
export let m = 1; const num = 1; export { m, num as age } 他们的实质是，在接口名与模块内部变量之间建立了一一对应的关系。
注意事项：
export语句输出的接口与其对应的值是动态绑定关系，即通过该接口可以取到模块内部实时的值，而CommonJS模块输出的是值的缓存，不存在动态更新export命令可以出现在模块顶层任意位置，如果处于块级作用域内就会报错，import命令也是如此。因为处于条件代码块中就无法做静态优化，这违背了ES6模块的设计初衷。 import命令 使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块了。例如：
import {year,month,date} from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b39dfa02644cebcf674a460a2cc0fb77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa100ea6eb561f7d36b9188bdd993870/" rel="bookmark">
			Linux内核中断系列之多处理器系统中的中断处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理器间中断(IPI)
原作者有个Linux中断专栏系列
多重中断处理图示
一、处理器间中断（核间中断） 1、在多处理器系统中，操作系统需要在多个处理器间协调操作，通常是通过处理期间中断(IPI)实现的。
2、IPI是一种特殊的硬件中断，由处理器发出，被其他处理器接收，以便于处理器间通信或同步。
3、通常并不明确区分IPI和设备中断，当一个处理器接收到一个中断时，如果发现另一个处理器处理该终端更加合理，则可以通过IPI机制将该终端传递到其他的处理器，实现处理器的负载平衡。
4、当一个CPU相对另一个CPU发送中断信号时，就在自己的本地APIC的ICR(中断命令寄存器)中存放其中断向量，和目标CPU拥有的本地APIC的标识符，触发中断。IPI中断信号经由APIC总线传递到目标APIC，那个收到中断的APIC就像自己所属的CPU发送一个中断。
5、Linux针对IA32的SMP系统定义了5中IPI，中断向量号为251~255:
(1) CALL_FUNCTION_VECTOR:发往除自己以外的所有CPU，强制它们执行指定的函数；
(2) RESCHEDDULE_VECTOR:是终端的CPU重新调度；
(3) INVLIDATE_TLB_VECTOR:使被中断的CPU废弃自己的TLB缓存内容;
(4) ERROR_APIC_VECTOR:错误的APIC向量，应该从不发生;
(5) SPUROUS_APIC_VECTOR:假的APIC向量，应该从不发生;
另外请参考：http://www.docin.com/p-70820238.html
二、中断亲和力 1、中断亲和力是将一个或多个中断服务程序绑定到特定的CPU上运行。
2、中断亲和力通过操作/proc/irq目录下的文件来控制。对于已注册的中断服务程序的硬件设备，在/proc/irq目录下存在一个该中断号命名的目录，该目录下有一个smp_affinity 文件(SMP体系结构下才有)。它是一个CPU的位掩码，其中的每一位对应一个CPU，可以用来设置该中断的亲和力，默认为0xFFFFFFFF，表示把中断送到所有的CPU上去 处理。如果中断控制器不支持IRQ affinity，则不能改变此默认值。
注意不能设置为0x0，即关闭所有CPU对该中断的处理。
3、利用亲和力，可以在多处理系统中均衡各个CPU的负载。
三、中断负载均衡 是将重负载CPU上的中断迁移到较空闲的CPU上进行处理；
实现代码位于arch\i386\kernel\io-apic.c,其中balanced_irq_init函数进行中断负载均衡模块儿的初始化，同时创建一个内核线程kirqd用于执行具体的均衡处理。
而kirqd每隔5s调用一次do_irq_balanced函数，进行中断的迁徙。
static int __init balanced_irq_init(void) { int i; struct cpuinfo_x86 *c; cpumask_t tmp; cpus_shift_right(tmp, cpu_online_map, 2); c = &amp;boot_cpu_data; /* When not overwritten by the command line ask subarchitecture. */ if (irqbalance_disabled == IRQBALANCE_CHECK_ARCH) irqbalance_disabled = NO_BALANCE_IRQ; if (irqbalance_disabled) return 0; /* disable irqbalance completely if there is only one processor online */ if (num_online_cpus() &lt; 2) { irqbalance_disabled = 1; return 0; } /* * Enable physical balance only if more than 1 physical processor * is present */ if (smp_num_siblings &gt; 1 &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa100ea6eb561f7d36b9188bdd993870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5fb589947948beaca4fd56a1bb190f/" rel="bookmark">
			完美解决form表单中提交Ajax请求不进入回调方法无法接收返回的任何数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 做了个简单的注册功能 提交用户名和密码信息到后台 后台返回status 很简单的逻辑
然而令我疑惑的是 在前台的ajax一直无法接收到后台返回的数据 无论是success回调还是error回调
刚开始还以为是不是类型转换的问题 于是乎进行JSON转换 但转来转去依旧无法解决 因为压根没进入任何回调函数
折腾了一天了 包括后台的@RequestBody注解、@RequestParam注解、@PostMapping注解的produces属性和前台的dataType属性和Content-Type属性全都换了个遍 但问题依旧
由于我是用mui的ajax提交的 甚至换成了原生js来发送ajax 但问题还是一样出现…
经过我的反复测试 问题是时有时无 有几次是注册失败时能正常返回数据 注册成功时又无法返回了🙄
原因 看了一篇博客后很有启发 可能是请求了两次
想起偶然在一次测试中 后台返回的数据是两条 可我明明只点击了一次按钮 更加印证了我的判断
我的表单是这样的：
&lt;form id="form"&gt; &lt;input type="text" placeholder="用户名"/&gt; &lt;input type="password" placeholder="密码"/&gt; &lt;input type="password" placeholder="确认密码"/&gt; &lt;button type="submit"&gt;注册&lt;/button&gt; &lt;/form&gt; JS是这样的：
form.addEventListener("submit",function(){ mui.ajax("http://000,000,000,000:1234/api/demo",{ data:{ username:表单值, password:表单值, }, dataType:'json', type:'post', timeout:10000, headers:{'Content-Type':'application/json'},	success:function(data){ console.log(data); } }) }) 原因就在于 我点击按钮请求了两次后台
第一次请求的是&lt;form&gt;中的action 这是空的 第二次请求的才是ajax的url
第一次请求空地址 自然得不到任何数据 然后ajax将其作为接收的值了 因此success和error都无法拿到任何数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df5fb589947948beaca4fd56a1bb190f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f69bd4054fe7101caa2806826c6ec871/" rel="bookmark">
			PreparedStatement的介绍与解决sql注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文章
jdbc连接以及出现的异常处理Jdbc工具类ResultSet的介绍与使用jdbc中的sql注入PreparedStatement的介绍与解决sql注入jdbc管理事务 PreparedStatement PreparedStatement是Statement的子接口，Statement是试行静态sql对象，PreparedStatement是执行预编译sql对象，用占位符?动态传参，解决sql注入问题。
下面就通过一个例子演示，例子是通过jdbc连接查account表中的数据，然后用实体类Account封装起来，返回这个类的集合。 jdbc工具类代码
package com.lingaolu.Utils; import java.io.FileReader; import java.io.IOException; import java.net.URL; import java.sql.*; import java.util.Properties; /** * @author 林高禄 * @create 2020-06-23-11:12 */ public class JdbcUtils { private static String driver; private static String url; private static String userName; private static String pw; static{ try { Properties p = new Properties(); ClassLoader classLoader = JdbcUtils.class.getClassLoader(); // 这个路径相对于src的路径来说 URL resource = classLoader.getResource("com/lingaolu/file/jdbc.properties"); String path = resource.getPath(); p.load(new FileReader(path)); driver = p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f69bd4054fe7101caa2806826c6ec871/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ecf7b4dc2e98270471d4fd19048cbe/" rel="bookmark">
			ResultSet的介绍与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文章
jdbc连接以及出现的异常处理Jdbc工具类ResultSet的介绍与使用jdbc中的sql注入PreparedStatement的介绍与解决sql注入jdbc管理事务 ResultSet ResultSet是我们使用jdbc连接时，查询的一个返回结果集,ResultSet resultSet = stmt.executeQuery(sql),下面就使用例子介绍ResultSet的使用
例子是通过jdbc连接查account表中的数据，然后用实体类Account封装起来，返回这个类的集合。 jdbc工具类代码
package com.lingaolu.Utils; import java.io.FileReader; import java.io.IOException; import java.net.URL; import java.sql.*; import java.util.Properties; /** * @author 林高禄 * @create 2020-06-23-11:12 */ public class JdbcUtils { private static String driver; private static String url; private static String userName; private static String pw; static{ try { Properties p = new Properties(); ClassLoader classLoader = JdbcUtils.class.getClassLoader(); // 这个路径相对于src的路径来说 URL resource = classLoader.getResource("com/lingaolu/file/jdbc.properties"); String path = resource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ecf7b4dc2e98270471d4fd19048cbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99420a6b1cf6b9484d8007758e685aa3/" rel="bookmark">
			Linux之编译程序详细介绍---./configure、make、make install
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节介绍如何通过源代码生成可执行程序，在博主前期使用NVIDIA Jetson TX2时,由于Arm架构的各个包不完备,经常需要源码编译OpenCV等.
为什么要编译软件呢？
可用性:尽管有些发行版已经包含了版本库中的一些预编译程序，但并不会包含用户所有可能需要的应用程序。此时，用户只能源码编译安装及时性:虽然有些发行版本专注于一些前沿的程序版本,但是多数并不会。这意味着要想获取最新版本的程序，编译必不可少. 0.参考文献 《Linux命令行大全》 [美] William E. Shotts. Jr 著 郭光伟 郝记生 译， 人民邮电出版社
更多有用的Linux知识详解，可参加博主的Linux学习导航页.
1.什么是编译 编译就是一个将源代码(程序员编写的人类可读的程序描述–高级语言)翻译成计算机处理器能识别的语言(机器语言)的过程.
高级语言编写的程序通过编译器转换成机器语言。有些编译器则将高级语言程序转换成汇编语言，然后再使用一个汇编程序将其转换成机器语言.
经常与编译一起使用的步骤是链接.库提供了通用任务支持，包含了多个例程，每一个实现的都是许多程序能够共享的通用任务，这些程序通常在/lib和/usr/lib中.链接器(linker)程序可以实现编译器的输出与编译程序所需要库之间的链接.该操作的最终结果就是生成一个可供使用的可执行文件.
2.是不是所有程序都需要编译 答案是否定的.像shell脚本可以直接运行，这些文件都是用脚本或解释型语言编写的，例如Perl,Python,PHP等。
脚本语言由一个称为解释器的特殊程序来执行，解释器负责输入程序文件并执行其包含的所有指令.通常，解释型程序要比编译后的程序执行起来慢.这是因为,在解释型语言中，每条源代码指令在执行时都要重新翻译一次该代码指令.然而编译后的程序中,每条源代码指令只翻译一次,并且该翻译结果将永久地记录到最后的可执行文件中.
3.编译一个C程序 在执行编译操作之前,需要一些工具,诸如编译器、链接器以及make等. **gcc(GNU C编译器)**是Linux环境中通用的C编译器.
$ which gcc /usr/bin/gcc 表明已经安装该编译器.
3.1 获取源代码 从一个叫做diction的GNU项目中选择一个程序进行编译练习.
使用ftp下载源码到src/目录.
$ mkdir src $ cd src $ ftp ftp.gnu.org Connected to ftp.gnu.org. 220 GNU FTP server ready. Name (ftp.gnu.org:lmj): anonymous 230-NOTICE (Updated October 13 2017): 230- 230-Because of security concerns with plaintext protocols, we still 230-intend to disable the FTP protocol for downloads on this server 230-(downloads would still be available over HTTP and HTTPS), but we 230-will not be doing it on November 1, 2017, as previously announced 230-here.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99420a6b1cf6b9484d8007758e685aa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88787091e77ab20ecbae05bded452444/" rel="bookmark">
			iStat Menus 无法正常读取传感器温度的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题解决方式如果是App Store版本，安装插件如果是突然读取不到，尝试重置传感器过滤器重置Mac的SMC使用新版软件 问题 换了电脑之后，像往常一样安装了各种惯用软件。最后发现iStat Menus 没办法读取硬件温度，只能读取到一个SSD的温度，尝试了重置传感器过滤也不行。读取不到温度，风扇转速控制自然也用不了，对于不满足于Mac系统本身的风扇转速策略的人来讲，在夏天实在是很难过。
解决方式 查阅了各种方式，最终还是成功修复了该问题，最主要的原因可能还是程序员没有适配最新的系统版本。
由于每个人的情况可能不同，最终生效的办法也不一样，在此列举，可以根据情况进行尝试。
先上官网链接
https://bjango.com/mac/istatmenus/
如果是App Store版本，安装插件 Mac App Store的版本由于审核原因本身不包括温度监测和风扇转速控制功能，需要安装一个助手来实现。
下载地址
https://bjango.com/help/istatmenus6/helper/
如果是突然读取不到，尝试重置传感器过滤器 软件有隐藏传感器功能，可以重置一下过滤器，看是否设置了隐藏。
首先打开iStat Menus面板，在系统栏中选择 菜单栏-重置传感器过滤器
重置Mac的SMC 啥东西？
SMC 负责管理与以下功能相关的行为：
电源，包括电源按钮以及 USB 端口的电源
电池和充电
风扇和其他热能管理功能
指示灯或感应器，例如状态指示灯（睡眠状态、电池充电状态等）、突发移动感应器、环境光传感器和键盘背光
打开和合上笔记本电脑盖时的行为
重置系统管理控制器 (SMC) 可以解决某些与电源、电池和其他功能相关的问题。
操作方法见官方指导：
https://support.apple.com/zh-cn/HT201295
使用新版软件 如果到这里还是没有解决你的问题，那么大概率你的macOS也是比较新的版本。到这里只能安装最新版本的iStat Menus 。
目前官网上最新版本6.4，这个版本是6.4.1，虽然没有正式的release，但确实是官方版本
是针对于兼容性的Bug提前释放的，可以放心。
下载地址：
https://download.csdn.net/download/csdn100861/12541420
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5457b8ca6e83f4dca264aa040ee7e29e/" rel="bookmark">
			Kinect2.0相机标定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我搜相机标定的时候有很多种方法，小白也不知道哪一个能用有用，感觉乱七八糟的，这个总结的很好Kinect2的标定和图像配准，我选的最简单的用matlab计算的。
下面是一些需要知道的基础知识，更好的操作和理解一些步骤吧（摘抄自上面那个博客）
相机结构 需要标定的参数：
标定方法和工具：
操作 参考：Kinect深度图与RGB摄像头的标定与配准（主要是参考的彩色相机的标定，还有最后对齐部分，红外相机看不太懂，我直接就拍了照片放在matlab里计算了）
kinect 2的数据获取与深度相机的标定（主要参考的matlab使用）
棋盘格下载
也可以去官网（应该是吧，反正好多人用这个）：https://github.com/code-iai/iai_kinect2/tree/master/kinect2_calibration/patterns（这个只是最终的存放路径，只下载这个好像不行，需要返回找到整个项目然后把整个项目下载，再在文件夹里找图片）
标定彩色摄像头 目的：获得彩色摄像头内参： f x f_x fx​, f y f_y fy​, c x c_x cx​, c y c_y cy​,还有畸变参数
用相机拍摄不同角度的彩色图片（正视、俯视、仰视、左倾、右倾），不少于20张 注意：
棋盘尽量覆盖在画面一半角度越多越好；棋盘要出现在图像的各个位置；平面与摄像头平面角度不要超过45°（我自己设置的时候发现角度太斜了红外图像就采集不到了，但是彩色摄像头可以，彩色图片也能采集到，但是不知道放在matlab里能不能识别格子的角点了，所以还是按照大家都这么做的做吧）
参考的一篇博客说距离要2种及以上（我不知道距离远近有什么影响，反正我是照顾到红外相机太远了就采集不到，所以都离得比较近） 2. 把图片放到matlab里，就会自动计算出参数啦（matlab是通过检测棋盘格的角点然后计算相机参数的，虽然具体原理不太懂，不过这样至少知道拍摄的时候要注意什么，就是尽量把角点都显示全，让matlab容易捕捉）
调用matlab工具箱：
导入图片
会弹出一个框让你填写你的棋盘格单个格子的大小，我用的3cm的，所以改成30
然后会弹出一个框提示你一共输入了35张图片，识别并添加进matlab23张，有12张没有识别出来（反正就是不好用）被丢弃了。然后matlab就用这23张图片计算相机参数
Calibrate就可以开始计算相机参数啦
结果：
直接按确定：
标定红外摄像头 目的：获得彩色摄像头内参： f x f_x fx​, f y f_y fy​, c x c_x cx​, c y c_y cy​,还有畸变参数
Kinect深度图片好像是又红外摄像头拍来的，所以标定红外摄像头就可以了。步骤同上，但是我采集到的红外图像很奇怪，画面是雪花状的（这个博主和我情况一样16位深度的TIF图像转8位深度——Matlab标定 一片白，可能保存成16位就没问题了，但是我直接用的这个图片好像也可以检测出来，就没有管），而且位置要求很苛刻，角度太大了或者太近都采集不到。
最后结果如下：
Camera Intrinsics
IntrinsicMatrix: [3×3 double]
FocalLength: [361.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5457b8ca6e83f4dca264aa040ee7e29e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc25c1c961b2e649986329ebc05bab6/" rel="bookmark">
			python pandas拆分单元格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拆分单元格是excel中经常遇到的内容之一。那么在pandas中如何实现呢？
例如有如下数据:
&gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; df=pd.read_excel(r'D:/myExcel/1.xlsx') &gt;&gt;&gt; df name score 0 bob_B 45 1 jiken_A 67 我们需要将name列拆分为name和grade两列
下面看一下实践
方案一：
# 此处应注意，split拆分时，不指定expand参数，则此时 # 会拆分为['bob', 'B']类似的列表。之后调用get方法即可， # 获取指定的值 &gt;&gt;&gt; df['grade']=df['name'].str.split('_').str.get(1) &gt;&gt;&gt; df name score grade 0 bob_B 45 B 1 jiken_A 67 A &gt;&gt;&gt; df['name']=df['name'].str.split('_').str.get(0) &gt;&gt;&gt; df name score grade 0 bob 45 B 1 jiken 67 A 方案二:
使用split拆分之后，调用merge方法
此种模式适合拆分的列数较多，又全都需要
# 拆分之后成为dataFrame &gt;&gt;&gt; df1=df['name'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bc25c1c961b2e649986329ebc05bab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ccb661acc053cd3d8460c2384634997/" rel="bookmark">
			Halcon学习之缺陷检测-凸点检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：读取图片--》图片转化为灰度---》快速傅里叶变换把图像转到频域---》频域滤波器进行卷积---》快速傅里叶反变换---》用一个矩形掩膜计算像素点的灰度范围---》求图片灰度值的最大和最小值和变换范围---》利用全局阈值对图像进行分割---》连通区域---》根据面积筛选区域---》合并区域---》使用圆形元素对区域进行闭运算---》连通区域---》根据面积筛选区域---》计算区域的面积以及中心位置---》显示结果
例程：detect_indent_fft.hdev 说明：这个程序展示了如何利用快速傅里叶变换（FFT）对塑料制品的表面进行目标（缺陷）的检测，大致分为三步：
首先，我们用高斯滤波器构造一个合适的滤波器（将原图通过高斯滤波器滤波）；
然后，将原图和构造的滤波器进行快速傅里叶变换；
最后，利用形态学算子将缺陷表示在滤波后的图片上（在缺陷上画圈）。
注：代码中绿色部分为个人理解和注释,其余为例程中原有代码
*Initialization（初始化） dev_updata_off() //这一句包含如下三个算子： //dev_updata_pc(‘off’) 关闭更新程序计数器 //dev_updata_var(‘off’) 关闭更新变量窗口 //dev_updata_window(‘off’) 关闭更新图像窗口（即通过命令来显示想要在图像窗口显示的图片） dev_close_window() //关闭活动的图像窗口 read_image(Image,’plastics / plastics_01’) //载入图片 //参数说明：为读入图片命名（Image） // 文件名（’plastics/plastics_01’） get_image_size(Image,Width,height) //获取图片的长宽； //参数说明：之前读入或生成的图片（Image） // 图片的宽（Width） // 图片的高（Height） dev_open_window(0,0,Width,Height,’Black’,WindowHandle) //打开一个新的图像窗口 //参数说明：起始坐标（0,0） // 大小（Width,Height） // 背景颜色（’Black’） // 窗口句柄（WindowHandle） set_display_font （WindowHandle,14,’mono’,’ture’,’false’）//设置不依赖操作系统的字体 //参数说明：窗口句柄（WindowHandle） // 字体大小（14） // 字体类型（’mono’） // 是否黑体（’ture’） // 是否倾斜（’false’） dev_set_draw(‘Margin’) //定义区域填充模式 //参数说明：填充模式（’Margin’或者’Fill’） dev_set_line_width（3） //设置输出区域轮廓线的线宽 //可以修改参数来看最后缺陷区域标示的区别 dev_set_color（’red’） //设置一种或者多种输出颜色 * *Optimize the fft speed for the specific image size(根据指定图像大小进行fft速度最优化) optimize_rft_speed（Width,Height,’standard’） //对指定大小的图片的fft速度进行优化 //参数说明：图片大小（Width,Height） // 优化模式（’standard’） * *Construct a suitable filter by combining two Gaussian filters（结合两个高斯滤波器构造一*个合适的滤波器） Sigma1 := 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ccb661acc053cd3d8460c2384634997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e87522166a650ec0d9a3896bc20bc6/" rel="bookmark">
			Java中的网络编程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 准备知识网络编程（Socket编程）UDP协议传输数据TCP协议传输数据多线程改进上传文本文件与网络编程有关的DOS命令 准备知识 1、IP、协议、端口详解 点击这里
2、网络编程的三要素：
IP地址：InetAddress: 网络中设备的标识，不易记忆，可用主机名；
端口号：用于标识进程的逻辑地址，不同进程的标识 ；
传输协议：通讯的规则常见协议：TCP，UDP
3、UDP协议与TCP协议的区别：
UDP——发短信
将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小在限制在64k；因无连接，是不可靠协议；不需要建立连接，速度快 TCP——打电话、视频
建立连接，形成传输数据的通道；在连接中进行大数据量传输；需要连接所以是可靠协议；必须建立连接，效率会稍低； 网络编程（Socket编程） 1、Socket是什么
Socket是应用层与TCP/IP协议族通信的中间软件抽象层，是一组接口；在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议；应用程序可以通过套接字发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作；套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信； 2、Socket原理
网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字，即就是Socket=IP+端口号；通信的两端都有Socket、网络通信其实就是Socket间的通信、数据在两个Socket间通过IO传输； 3、Java如何进行网络编程
针对不同协议的Socket，Java给我们提供了相应的Socket；UDP协议使用的Socket，Java提供了DatagramSocket类来描述；TCP协议使用的Socket，Java使用了Socket类来描述； 4、动态获取IP、主机名
在Java中，使用InetAddress类来描述IP，它的子类有：Inet4Address、Inet6Address，我们可以直接使用父类；常用方法： 方法作用static InetAddress getByName(String host)在给定主机名的情况下确定主机的 IP 地址String getHostAddress()返回 IP 地址字符串String getHostName()获取此 IP 地址的主机名 代码演示： import java.net.InetAddress; import java.net.UnknownHostException; public class MyTest { public static void main(String[] args) throws UnknownHostException { //可以传递主机名或IP地址获取InetAddress对象 InetAddress ip1 = InetAddress.getByName("LAPTOP-4IO7TG8A"); InetAddress ip2 = InetAddress.getByName("192.168.0.103"); System.out.println(ip1==ip2); System.out.println(ip1.getHostAddress()); //192.168.0.103---获取IP地址 System.out.println(ip1.getHostName()); //LAPTOP-4IO7TG8A----获取主机名 } } UDP协议传输数据 1、UDP协议发送数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7e87522166a650ec0d9a3896bc20bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/456159e237dd492f1fe87ab52b2a18fd/" rel="bookmark">
			SVG常用图形与path路径详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础知识 svg 描述
所有的svg元素都应放在svg标签下才可以生效，svg实际上是用于显示所创建的svg矢量图的一个画布
属性
参数描述widthsvg画布的真实宽度heightsvg画布的真实高度viewBox视野，用于规定svg画布显示的位置以及显示的范围，由4个参数x，y，w，h控制 viewBox详解：
​ 首先，对于svg的是没有边界的，svg画布只是用于展示svg世界中某一个范围的内容，而对于超过了svg画布范围的内容，则会被遮挡。默认svg画布默认显示世界坐标下原点坐标的width*height面积的矩形视野。
​ 我们可以通过viewBox来修改默认的显示配置，viewBox由4个点组成，viewBox=“x, y, w, h”；其中x，y就是用于定义svg画布在世界坐标下的位置，通过修改x，y可以移动画布在世界坐标下的位置。而w，h则是定义svg画布的视野区域；默认情况下viewBox=“0,0,width,height”
当w&lt;width、h&lt;height的时候，相当于是拉近了视野，视野小了，但实际显示的区域没有发生变化；这就会导致显示的图形变大，显示的区域变小。当w&gt;width、h&gt;height的时候，相当于拉远了视野，视野变大了，但实际显示的区域没有发生变化；这就会导致显示的图形变小，显示的区域变大。 示例
&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400px" height="400px" viewBox="20,20,400,400" &gt; &lt;ellipse cx="0" cy="0" rx="5" ry="5" style="fill:aquamarine;stroke-width:0"&gt;&lt;/ellipse&gt; &lt;rect x="0" y="0" width="100" height="100" stroke="red" stroke-width="1" fill="none"&gt;&lt;/rect&gt; &lt;rect x="300" y="300" width="100" height="100" style="stroke:cadetblue;stroke-width:1;fill:none"&gt;&lt;/rect&gt; &lt;/svg&gt; 显示属性 描述
用于规定svg元素的样式显示属性，包括颜色，边框，线宽等属性，显示属性既可以作为元素的属性也可作为css样式属性来生效，如红色的2p边框
普通属性：stroke=“red” stroke-width=“2”;
css属性：style=“stroke:red;stroke-width=2”
两种方式都是可以实现红色的2px边框
属性
参数描述值fill填充图形颜色颜色，渐变stroke绘制图形的边框颜色颜色，渐变stroke-width绘制图形的边框宽度数值stroke-linejoin线条连接处样式miter|round|bevelstroke-linecap线条首尾处样式butt|round|squaretransform属性变换translate|scale|rotatetransform-origin变换中心数值|百分比|位置 图形绘制 直线 描述
绘制一条直线
属性
参数是否必须描述x1否直线起点的x坐标，默认是0y1否直线起点的y坐标，默认是0x2是直线终点的x坐标y2是直线终点的y坐标style否显示样式，主要用于规定了绘制矩形的样式属性，详情参考显示属性 示例
&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="200" &gt; &lt;line x1="40" y1="10" x2="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/456159e237dd492f1fe87ab52b2a18fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7533e1cc1477f460cfe07b3016aeafc/" rel="bookmark">
			通过MVVM使您的视图控制器节食
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本系列的上一篇文章中，我写了关于Model-View-Controller模式及其一些缺陷的文章。 尽管MVC给软件开发带来了明显的好处，但在大型或复杂的Cocoa应用程序中，它往往不尽人意。 不过，这不是新闻。 多年来，出现了几种架构模式，旨在解决“模型-视图-控制器”模式的缺点。 例如，您可能听说过MVP ，Model-View-Presenter和MVVM ，Model-View-ViewModel。 这些模式看起来和感觉都类似于Model-View-Controller模式，但是它们也解决了Model-View-Controller模式所遇到的一些问题。 1.为什么选择Model-View-ViewModel 在我偶然发现Model-View-ViewModel模式之前，我已经使用Model-View-Controller模式多年了。 MVVM成为可可社区的后来者也就不足为奇了，因为它的起源可以追溯到微软。 但是，MVVM模式已移植到Cocoa并适应Cocoa框架的要求和需求，并且最近在Cocoa社区中越来越受到关注。 最具吸引力的是MVVM感觉像是Model-View-Controller模式的改进版本。 这意味着它不需要剧烈改变思维定势。 实际上，一旦您了解了该模式的基础知识，就可以轻松实现它，而不比实现Model-View-Controller模式更困难。 2.节食View Controller 在上一篇文章中 ，我写道典型的Cocoa应用程序中的控制器与原始MVC模式中定义的Reenskaug控制器有些不同。 例如，在iOS上，视图控制器控制视图。 它的唯一职责是填充其管理的视图并响应用户交互。 但这不是大多数iOS应用程序中视图控制器的唯一责任，不是吗？ MVVM模式向组合中引入了第四个组件，即视图模型 ，它有助于重新定位视图控制器。 它通过接管视图控制器的某些职责来做到这一点。 请看下面的图，以更好地了解视图模型如何适合Model-View-ViewModel模式。 如图所示，视图控制器不再拥有模型。 拥有模型的是视图模型，并且视图控制器向视图模型询问其需要显示的数据。 这是与“模型-视图-控制器”模式的重要区别。 视图控制器无法直接访问模型。 视图模型将其需要显示在视图中的数据交给视图控制器。 视图控制器及其视图之间的关系保持不变。 这很重要，因为这意味着视图控制器可以专注于填充其视图和处理用户交互。 这就是视图控制器的设计目的。 结果非常引人注目。 视图控制器节食，许多责任转移到视图模型。 您不再需要一个跨越数百甚至数千行代码的视图控制器。 3.视图模型的责任 您可能想知道视图模型如何适应更大的画面。 视图模型的任务是什么？ 它与视图控制器有何关系？ 那模型呢？ 我之前显示给您的图表为我们提供了一些提示。 让我们从模型开始。 该模型不再由视图控制器拥有。 视图模型拥有该模型，并且充当视图控制器的代理。 每当视图控制器需要其视图模型中的一条数据时，后者就会向其模型询问原始数据，并以使其可以立即在其视图中使用的方式对其进行格式化。 视图控制器不负责数据操作和格式化。 该图还显示该模型归视图模型所有，而不是视图控制器。 还值得指出的是，Model-View-ViewModel模式尊重视图控制器及其视图的紧密关系，这是Cocoa应用程序的特征。 这就是为什么MVVM感觉很自然地适合可可应用的原因。 4.一个例子 由于Model-View-ViewModel模式不是Cocoa固有的，因此没有严格的规则来实现该模式。 不幸的是，许多开发人员对此感到困惑。 为了澄清一些事情，我想向您展示一个使用MVVM模式的应用程序的基本示例。 我们创建了一个非常简单的应用程序，该应用程序从Dark Sky API获取预定义位置的天气数据，并将当前温度显示给用户。 步骤1：建立专案 启动Xcode并基于Single View Application模板创建一个新项目。 我在本教程中使用Xcode 8和Swift 3。 将项目命名为MVVM ，并将Language设置为Swift并将Devices设置为iPhone 。 步骤2：建立检视模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7533e1cc1477f460cfe07b3016aeafc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5abd37d0f9271a08ef7c3137ed7be34c/" rel="bookmark">
			Clickhouse INSERT操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建表： CREATE TABLE city ( `id` UInt8, `country` String, `province` String, `city` String, `create_time` datetime DEFAULT now() ) ENGINE = MergeTree() PARTITION BY toYYYYMM(create_time) ORDER BY id Ok. 0 rows in set. Elapsed: 0.012 sec. 插入数据： 1.单行插入： Clickhouse&gt; insert into city(id,country,province,city) VALUES(1,'China','Hubei','wuhan'); INSERT INTO city (id, country, province, city) VALUES Ok. 1 rows in set. Elapsed: 0.017 sec. 2.多行插入： Clickhouse&gt; insert into city(id,country,province,city) VALUES(2,'China','Hubei','xiangyang'),(2,'China','Guangdong','shenzhen'); INSERT INTO city (id, country, province, city) VALUES Ok.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5abd37d0f9271a08ef7c3137ed7be34c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d43790e1289a380a05dee98d24694a/" rel="bookmark">
			【数据结构】基于栈的中缀算式表达式求值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于栈的中缀算式表达式求值 问题：要求：运行软件调试引用函数将字符串转换成浮点数atof函数：strtod函数：memset函数 判断符号优先级表代码实现： 问题： 输入一个中缀算术表达式，求解表达式的值。运算符包括+、-、*、/、(、)、=，参加运算的数为double类型且为正数。（要求：直接针对中缀算术表达式进行计算，不能转换为后缀或前缀表达式再进行计算，只考虑二元运算即可。）
要求： （1）创建名为kcsj12.cpp的文件，并编写程序实现指定功能；
（2）输入：多组数据，每组数据一行，对应一个算术表达式，每个表达式均以“=”结尾。当表达式只有一个“=”时，输入结束。参加运算的数为double类型；
（3）输出：对于每组数据输出一行，为表达式的运算结果。输出保留两位小数。
输入样例和输出样例：
输入：
2+2=
20*（4.5-3）=
=
输出：
4.00
30.00
运行软件 CLion
调试 debug
引用函数 将字符串转换成浮点数 atof函数： atof()是C 语言标准库中的一个字符串处理函数，功能是把字符串转换成浮点数，所使用的头文件为&lt;stdlib.h&gt;。
示例代码：
#include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; int main() { double d; char str[] = "123.456"; d=atof(str); printf("string=%sdouble=%lf\n",str,d); return 0; } strtod函数： strtod是C语言及C++中的重要函数，功能是将字符串转换成浮点数，表头文件是#include &lt;stdlib.h&gt;，相关函数有atoi，atol，strtod，strtol。
示例代码：
#include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; void main() { char *endptr; char a[] = "12345.6789"; char b[] = "1234.567qwer"; char c[] = "-232.23e4"; printf( "a=%lf\n", strtod(a,NULL) ); printf( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d43790e1289a380a05dee98d24694a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80c898d7fccefe5cdebd829e4c72b8c7/" rel="bookmark">
			Vue跨组件可响应通信【provide / inject】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. Vue 组件之间常用的通信方式 2. provide / inject 基本使用 3. provide / inject 可响应通信 4. provide / inject 替代 Vuex 5. 进阶技巧
6. 结语
1. Vue 组件之间常用的通信方式
Vue 组件之间常用的通信方式有：
props 属性传递数据自定义事件 event
a. 全局的eventHub机制
b. 父组件调用子组件使用 @eventName="handleFunc"，子组件在需要的时候调用 this.$emit(eventName, params) 即可通过 params 传参。ref 给元素或组件注册引用信息，然后父组件通过 this.$refs.child 获取到子组件实例对象。 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素。$parent / $children：访问父 / 子实例。 但以上这些方法一般只适合在父子组件中通信，无法在跨级或兄弟间通信，或者要实现跨级通信会很麻烦，需要一层一层的传递。
2. provide / inject 基本使用
我们知道，在做 Vue 大型项目时，可以使用 Vuex 做状态管理来突破跨组件的数据共享，它是一个专为 Vue.js 开发的状态管理模式，用于集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
那不使用 Vuex 的情况下，我们能否有其他跨组件的通信方式呢？答案是肯定有的，这就需要Vue内置的 provide / inject 接口，它可以实现无依赖的组件通信方法，类似于react的 Context共享数据, 父组件 与【子孙】组件而不只是子组件共享数据，可以跨层级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80c898d7fccefe5cdebd829e4c72b8c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7becd9d32deeb6ab623535108cf571a0/" rel="bookmark">
			MATLAB（PYTHON（pandas））如何读写Excel数据文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB如何读：
将电脑中某个位置的Excel表格里面的数据读入MATLAB软件里面并赋给某个变量。
我们只需要使用MATLAB中提供的系统函数xlsread函数即可，其主要的调用形式为：
a=xlsread(‘H:\filename.xls’);
其中a表示读入文件所保存的变量名称，filename.xls（或者filename.xlsx）表示excel数据文件名，H:\是文件所在地址。
MATLAB如何写：
将MATLAB软件里面的某个变量保存为Excel表格里面的数据保存到电脑指定的位置。
我们只需要使用MATLAB中提供的系统函数xlswrite()函数即可，其主要的调用形式为：
xlswrite(‘C:\filename.xls’,variable);
其中variable表示需要写入Excel文件的变量名称，filename.xls（或者filename.xlsx）表示excel数据文件名字，“C:\”是你要准备存放的地址。
PYTHON 关于文件的读取，
我们利用第三方库pandas进行，未完待续
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102a11071c76457c851e94c7f84fd21a/" rel="bookmark">
			Linux学习笔记导航页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客中与博主Linux学习相关的博文导航，方便查看
Linux系统ls命令详解Linux系统中目录的内容详解—bin、dev、etc、home、lib、opt、usr、varLinux操作文件与目录——cp、mv、mkdir、rm和ln命令Linux 命令行入门大全—type、man、help、apropos、whatis、infoLinux命令行I/O重定向—重定向操作符、cat、管道、sort、uniq、wc、grep、head、tail、teeshell命令的扩展和引用—$Linux键盘使用技巧—光标移动、修改文本、复制粘贴、history查看历史命令Linux权限详情—id、chmod、umask、su、chown、chgrp、passwdLinux进程详解(非常详细且入门)—ps、top、kill、fgLinux环境详情与配置——export,alias,set,printenvLinux之vi介绍----完整入门及快捷键Linux系统软件包管理——dpkg、apt-get、rpm、yumLinux之网络相关命令——ping、tranceroute、netstat、ftp、lftp、wget、ssh、scp、sftpLinux文件搜索命令介绍——locate、find、xargs、touch、statLinux归档与备份——gzip、gunzip、bzip2、bunzip2、tar、zip、unzip、rsyncLinux之存储介质——mount、umount、fdisk、mkfsLinux之正则表达式—grep、元字符、任意字符、锚、中括号、否定、POSIX字符类Linux之文本处理—cat、sort、uniq、cut、paste、join、comm、diff、patch、tr、sed、aspellhttps://blog.csdn.net/mathlxj/article/details/106918876 更新中…一起加油！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/104/">«</a>
	<span class="pagination__item pagination__item--current">105/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/106/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>