<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24bdcb3c1f0f48a71579375dde565d30/" rel="bookmark">
			Java高级--反射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反射 Java反射机制概述Java反射机制提供的功能反射相关的主要API反射和封装性的疑问 理解Class类并`获取Class实例`关于java.lang.Class类的理解：获取Class实例的方式哪些类型可以有Class对象？ 类的加载与ClassLoader的理解读取配置文件的两种方式(掌握) `创建运行时类的对象`newInstance()方法实例体会反射的动态性 获取运行时类的完整结构获取运行时类中的属性获取运行时类中的方法获取运行时类的构造器获取运行时类的父类及父类的泛型(掌握)获取运行时类的接口、所在包、注解 `调用运行时类的指定结构`操作运行时类中的指定的属性(掌握)操作运行时类中的指定的方法(掌握)操作运行时类中的指定的构造器 反射的应用：动态代理动态代理原理静态代理动态代理使用场合动态代理相比于静态代理的优点示例静态代理动态代理 动态代理与AOP(Aspect Orient Programming) Java反射机制概述 Reflection(反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法
框架 = 反射 + 注解 + 设计模式
Java反射机制提供的功能 在运行时判断任意一个对象所属的类在运行时构造任意一个类的对象在运行时判断任意一个类所具有的成员变量和方法在运行时获取泛型信息在运行时调用任意一个对象的成员变量和方法在运行时处理注解生成动态代理 反射相关的主要API java.lang.Class:代表一个类java.lang.reflect.Method:代表类的方法java.lang.reflect.Field:代表类的成员变量java.lang.reflect.Constructor:代表类的构造器
… 反射和封装性的疑问 1、通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用哪个？ 建议直接new的方式在需要用到反射的特征(动态性)使就用反射。在java代码运行起来后，在不确定需要用到哪个方法的对象时，就需要用到反射。如：我们在一个项目里，java代码已经在服务器里运行了，但并不知道用户会使用哪个功能，可能会注册，可能会登录…，就可以通过url中的后缀来判断需要用到哪个方法，利用反射机制，servlet动态的new出该方法的对象去执行相应的操作。 2、反射机制与面向对象的封装性是不是有矛盾？如何看待两个技术？ 不矛盾封装性，对于公共的可以调，私有的不能掉，但是在公共的方法里可能在内部已经自己调用过了，所以不需要外部去调用。反射，当公共的结构不满足需求时，就可以通过反射机制去调用封装性，是建议只用get,set方法去修改公共的，建议怎么调；反射，是能不能调 理解Class类并获取Class实例 关于java.lang.Class类的理解： 1、类的加载过程：程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)，接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。类就可以作为Class类的一个对象。eg:Class clazz = Person.class2、换句话，Class的实例就对应着一个运行时类3、加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类 获取Class实例的方式 1、调用运行时类的属性:class Class clazz1 = Person.class;//Class&lt;Person&gt; clazz1 = Person.class;可以加上泛型，后面用对象clazz1就不用强转了 System.out.println(clazz1); 2、通过运行时类的对象,调用getClass() Person p1 = new Person(); Class clazz2 = p1.getClass(); System.out.println(clazz2); 3、调用Class的静态方法：forName(String classPath)(使用频率更高) Class clazz3 = Class.forName("com.llc.java.Person"); System.out.println(clazz3); //任何类都可以作为Class的实例 Class clazz4 = Class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24bdcb3c1f0f48a71579375dde565d30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bbea64ef766e800b1b7a7ffb2f7de49/" rel="bookmark">
			Git提交代码注释信息规范-相关命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		- Git提交代码注释信息规范 - git commit -m "提交类型+代码总结" - 提交类型： 1. feat: 修改/增加新功能 2. fix: 修改bug/功能代码的变更 3. docs: 文档相关变更 4. style: 不影响代码含义的变更(空白/格式/缺少符号等) 5. refactor: 代码重构变更 6. perf: 改进性能的变更 7. test: 添加/修改现有的测试 8. chore: Build/.gitignore/辅助工具/库(文档生成)等变更 - Example: feat: support for async execution - Git命令测试 - 命令类型： 1. git config --global user.name "用户名": 配置全局用户名变量 2. git config --global user.email "用户邮箱": 配置全局用户邮箱变量 3. git config --global --list: 查看全局全部配置变量 4. git config --system --list: 查看系统全部配置变量 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bbea64ef766e800b1b7a7ffb2f7de49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e149bd1bf0232508a3e9db3c61f548/" rel="bookmark">
			Linux创建和删除软连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建软连接 ln -s &lt;源路径&gt; &lt;软连接路径&gt; 如： ln -s /home/src ./src_ln , src_ln即为软连接，src为源文件
删除软连接 rm [option] &lt;软连接&gt; 如果软连接对应的源路径是文件，则直接rm src_ln如果软连接对应的路径是文件夹，要注意是否包含/ !!! 如果你的目的仅仅是删除软连接，而不是同时删除对应的源文件夹里的内容，使用rm -rf src_ln，最后千万不要带/否则使用rm -rf src_ln/命令的话，会将src中的内容同时删除 修改软连接 在Ubuntu系统中，如果软连接已经存在，可以j直接ln -s &lt;指向的目录&gt; &lt;软连接&gt;, 或者ln -snf &lt;指向的目录&gt; &lt;软连接&gt;在Centos系统中，如果软连接已经存在，需要使用ln -snf &lt;指向的目录&gt; &lt;软连接&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a96ced9de09c4b1fe4ce5f61eb0e7bb/" rel="bookmark">
			CAD图清晰打印设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近偶尔遇到CAD打印，突然发现打印出来的图比较淡，甚至于看不清楚，经过学习终于解决了这个问题，给大家分享一下，如果有和我一样遇到问题的希望能帮到你。
例如需要打印下图中的图纸，我们需要长按住鼠标滚轮进行拖动图纸，前后滑动进行放大或者缩小
接下来，Ctrl+p键快捷打印
第一步：设置打印机，需要用那台打印机打印
第二步：设置打印纸尺寸，A3或者A4
第三步：设置打印范围，注意这里选择为“窗口”，选择为窗口后会跳转到图纸上进行选择打印区域，这时需要用鼠标左键拖选打印图纸区域。
第四步：设置打印偏移，可以直接选中居中打印。
第五步：根据图纸的方向选择横向打印，或者纵向打印
第六步：（重要设置，这里关系到图纸打印的清晰度）一般按照上面设置的就可以打印了，但是有些图纸进行了多种颜色设置，线条也比较细，导致打印出来图纸不清晰，这时需要进行打印样式设置
1：在打印样式表中随便选择一个样式
2：然后点击后面的（编辑）图标
3：第一步设置打印样式，按住shift键，一直拉到最后的颜色点一下，全选所有颜色；第二步在特性-颜色中选择黑色；第三步编辑线宽，根据自己需要设置；第四步点击保存并关闭。
到此所有设置已经设置完毕。点击预览进行打印预览效果，如果没有问题就可以打印了。此次分享到此结束。有问题留言沟通
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73eee65473226cfe1de9e96f4ff732b5/" rel="bookmark">
			JWT 做 token 签发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JWT简介JWT 数据格式案例 JWT 交互流程JWT 存在的问题实战 JWT 简介 JWT，全称是 Json Web Token ， 是一种 JSON 风格的轻量级的授权和身份认证规范，可实现无状态、分布式的 Web 应用授权。
JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的 Java 实现是 GitHub 上的开源项目 jjwt，地址如下：https://github.com/jwtk/jjwt
JWT 数据格式 JWT 包含三部分数据：
1.Header：头部，通常头部有两部分信息：
声明类型，这里是JWT
加密算法，自定义
我们会对头部进行 Base64Url 编码（可解码），得到第一部分数据。
2.Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了 7 个示例信息：
iss (issuer)：表示签发人
exp (expiration time)：表示token过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
这部分也会采用 Base64Url 编码，得到第二部分数据。
3.Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥 secret（密钥保存在服务端，不能泄露给客户端），通过 Header 中配置的加密算法生成。用于验证整个数据完整和可靠性。
生成的数据格式如下图：
注意，这里的数据通过 . 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。
案例 eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzaG9wX2lkIjo2NjY2NjYsInVzZXJfaWQiOiJjaGVuZnUiLCJvcGVuX2lkIjoiY2hlbmZ1IiwiYXBwX2lkIjoiY2hlbmZ1In0.Q6qVIxPOf8jpK5idQgm7g3yUatyrh5RnF_JQhyZZeRU JWT 交互流程 流程图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73eee65473226cfe1de9e96f4ff732b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/276360d59512d3c32c8a2e6c1d30e075/" rel="bookmark">
			Spring Security 登录获取用户信息流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Security 登录获取用户信息流程分析 Spring Security 登录获取用户信息方式SecurityContextHolder 简介 流程分析SecurityContextPersistenceFilter 核心源码HttpSessionSecurityContextRepository从 session 中获取 认证信息 SecurityContext将认证信息 SecurityContext 保存到 session 中 SecurityConfigurer 配置项configure(HttpSecurity http)configure(WebSecurity web) 参考 Spring Security 登录获取用户信息方式 如果使用了 Spring Security，当我们登录成功后，可以通过如下方式获取到当前登录用户信息：
SecurityContextHolder.getContext().getAuthentication()
在 Controller 的方法中，加入 Authentication 参数
这两种办法，都可以获取到当前登录用户信息。
SecurityContextHolder 简介 SecurityContextHolder 中的数据，本质上是保存在 ThreadLocal 中，ThreadLocal 的特点是存在它里边的数据，哪个线程存的，哪个线程才能访问到。
流程分析 无论是 Spring Security 还是 Shiro，它的一系列功能其实都是由过滤器来完成的，在 Spring Security 中，有一些重要的过滤器比如 UsernamePasswordAuthenticationFilter 过滤器，在这个过滤器之前，还有一个过滤器就是 SecurityContextPersistenceFilter，请求在到达 UsernamePasswordAuthenticationFilter 之前都会先经过SecurityContextPersistenceFilter。
我们在成功进行登录了之后，AbstractAuthenticationProcessingFilter#successfulAuthentication 中有这么一段代码，SecurityContextHolder.getContext().setAuthentication(authResult); 会将 Authentication 设置到 SecurityContext 中，后续 SecurityContextPersistenceFilter 会将 SecurityContext 保存到 session 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/276360d59512d3c32c8a2e6c1d30e075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28d40ccffee9b93c1707978dccc983c/" rel="bookmark">
			Java设计模式简介、设计模式原则及分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN话题挑战赛第2期
参赛话题：学习笔记
目录
一、Java设计模式简介
二、设计模式原则
三、设计模式分类
一、Java设计模式简介 在软件工程中，设计模式是对软件设计中普遍存在的各种问题，所提出的解决方案。
换句话说，设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计的经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性。
二、设计模式原则 1、开闭原则（Open Close Principle）
开闭原则的意思是： 对扩展开放，对修改封闭 。在程序需要进行扩展的时候，不能去修改或影响原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性更好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。
2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当子类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而且子类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则通俗来讲就是:子类可以扩展父类的功能,但不能改变父类原有的功能
3、依赖倒转原则（Dependence Inversion Principle）
这个原则是开闭原则的基础，核心内容：针对接口编程，高层模块不应该依赖底层模块，二者都应该依赖抽象而不依赖于具体。
4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个庞大的接口要好。其目的在于降低耦合度。由此可见，其实设计模式就是从大型软件架构出发，便于升级和维护软件的设计思想。它强调低依赖、低耦合。
5、单一职责原则（Single Responsibility Principle）
类的职责要单一，不能将太多的职责放在一个类中。
可能有的人会觉得单一职责原则和前面的接口隔离原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要约束的是类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。
6、最少知道原则（Demeter Principle）
最少知道原则也叫迪米特法则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。一个对象应该对其他对象保持最少的了解。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。所以在类的设计上，每一个类都应当尽量降低成员的访问权限。
7、合成复用原则（Composite Reuse Principle）
合成复用原则就是在一个新的对象里通过关联关系（组合关系、聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，尽量多使用 组合/聚合 的方式，尽量少使用甚至不使用继承关系。
三、设计模式分类 通常来说设计模式分为三大类：
● 创建型模式，共 5 种：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。
● 结构型模式，共 7 种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
● 行为型模式，共 11 种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
下面用图片来整体描述一下设计模式之间的关系：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/223b4422c98ddabfb2fa37e9dcdb3c9c/" rel="bookmark">
			OPLS-DA的S-plot图可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OPLS-DA的S-plot图，横坐标表示主成分与代谢物的协方差，纵坐标表示主成分与代谢物的相关系数，越靠近右上角和左下角的代谢物表示其差异越显著，红色的点表明这些代谢物的VIP值大于等于1，蓝色的点表示这些代谢物的VIP值小于1。
library(testpackage) s_plot_data &lt;- t(s_plot_data) data &lt;- data.frame('Secondary_ID' = c('A1','A2','A3','A4', 'A5','A6','A7','A8', 'B1','B2','B3','B4', 'B5','B6','B7','B8'), 'Class_ID' = rep(c('A','B'),each = 8)) data &lt;- data.frame(data,s_plot_data) s_plot(data) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c1b4a08a340f9117dda63858a4f3eb3/" rel="bookmark">
			Flask: flask &#43; tornado&#43; nginx组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本地完成大部分开发后，迁移到阿里云生产环境。因为是小网站，选择了windows平台，但是后端又选择了flask框架，只能选择tornado web容器和nginx组合。其实，nginx都没有必要，只是为了试着玩玩，看看生产环境如何配置。
tornado代码很简单，就是一个server.py.
具体在阿里云上：
我选择了生产环境配置了一台ecs服务器。
server name 是阿里云上绑定对应域名的www.myweb.com（假定）的主页地址。端口需要看ecs网络安全组对应的端口设置。允许有相应的访问权限就可以。
需要说明的是，这里域名绑定，域名申请，网络安全组设置等不介绍了。
nginx第一次设置，可能会让大家感觉是不是会很复杂？其实大可不必紧张。首先去下载一个nginx到本地，如下：
配置文件 就是conf目录下，nginx.conf文件。打开即可，进行相关设置。
主要就两部分：
1、sever下 listen 端口和server_name
server { listen 80; server_name myweb.com; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://localhost:9000; } #error_page 404 /404.html; } 另外一个linux下设置：
db@iZgw041dtbsye3lhp8lz3eZ:~/dataapi/http_server$ cd /etc/nginx db@iZgw041dtbsye3lhp8lz3eZ:/etc/nginx$ ls conf.d fastcgi_params koi-win modules-available nginx.conf scgi_params sites-enabled uwsgi_params fastcgi.conf koi-utf mime.types modules-enabled proxy_params sites-available snippets win-utf db@iZgw041dtbsye3lhp8lz3eZ:/etc/nginx$ sudo vi nginx.conf 在nginx.conf中http下：增加
server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c1b4a08a340f9117dda63858a4f3eb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01693d400bdc79ad8e3670822b3c30e4/" rel="bookmark">
			OpenCV&#43;python实现摄像头简单手势识别--进度条控制亮度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、整体框架二、使用步骤;1.引入库;2.第一步:打开摄像头;3.第二步:设置回调函数;4.第三步:肤色检测;5.第四步:进行高斯滤波;6.第五步:边缘轮廓检测；7.第六步:求出手势的凹凸点；8.第七步: 利用凹凸点个数判断当前手势; 成果展示完整代码 总结 前言 例如：随着人工智能的不断发展，计算机视觉这门技术也越来越重要，很多人都开启了学习计算机视觉，本文在Opencv基础上实现了摄像头简单手势识别–进度条控制亮度的基础内容,并没有使用深度学习技术,因此准确率并不高。
一、整体框架 ∙ \bullet ∙第一步： 开启摄像头，检测每帧图片；
∙ \bullet ∙第二步： 设置回调函数,操纵滑动条来调整亮度；
∙ \bullet ∙第三步： 肤色检测，基于HSV颜色空间H,S,V范围筛选法。在HSV中 7&lt;H&lt;20，28&lt;S&lt;256，50&lt;V&lt;256；
∙ \bullet ∙第四步： 进行高斯滤波；
∙ \bullet ∙第五步： 边缘轮廓检测；
∙ \bullet ∙第六步： 求出手势的凹凸点；
∙ \bullet ∙第七步： 利用凹凸点个数判断当前手势。例如：0个凹凸点就是拳头，4个凹点就是布。
二、使用步骤; 1.引入库; import cv2 import numpy as np import math 2.第一步:打开摄像头; 代码如下（示例）：
cap = cv2.VideoCapture(0) while (cap.isOpened()): ret, frame = cap.read() # 读取摄像头每帧图片 frame = cv2.flip(frame, 1) #镜像调整,将图像左右调换回来正常显示 3.第二步:设置回调函数; def callback(object): #注意这里createTrackbar会向其传入参数即滑动条地址（几乎用不到），所以必须写一个参数 pass cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01693d400bdc79ad8e3670822b3c30e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b91429c4ca398170b794e9a217bd41/" rel="bookmark">
			解析 JSON Schema 文档生成 Java 代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据 JSON Schema 文档生成 Java 代码，使用的是 GitHub 上的开源项目 jsonschema2pojo，该项目有多种使用方式，详细看文档，这里采用引入依赖方式
步骤如下
项目中引入依赖，准备对应的 JSON Schema 文档
编写解析 JSON Schema 文档 的代码
执行程序即可
详细步骤 引入依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsonschema2pojo&lt;/groupId&gt; &lt;artifactId&gt;jsonschema2pojo-core&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 解析 JSON Schema 文档的核心代码 生成实例类代码
import com.sun.codemodel.JCodeModel; import org.jsonschema2pojo.*; import org.jsonschema2pojo.rules.RuleFactory; import java.io.File; import java.io.IOException; import java.net.URL; public class Example { public static void main(String[] args) throws IOException { JCodeModel codeModel = new JCodeModel(); // URL source = Example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6b91429c4ca398170b794e9a217bd41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d4f4822a9dacd01a78286485aec12e/" rel="bookmark">
			Android studio环境开发配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JDK环境配置 1.1下载JDK 官网下载jdk 安装jdk-8u341-windows-x64.exe
1.2安装JDK 下载完毕之后安装jdk
这里需要记住安装的目录后面会用到，下一步
等待下载
jdk安装完毕
1.3配置JDK、JAVA环境 此电脑右键打开计算机属性
在菜单栏中查找高级系统
打开环境变量
配置JAVA_HOME
如图所示
变量名：JAVA_HOME
变量值：C:\Program Files\Java\jdk1.8.0_341（刚才下载jdk的路径）
配置CLASSPATH
变量名：CLASSPATH
变量值：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar;
编辑Path
Path在系统中存在不需要新建，直接选择Path编辑，直接选择编辑文本
在最后追加;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
最后更改完后点击确认
到这里jdk环境配置完毕
可以Win+R输入cmd打开黑框输入java看看配置成功没有
2、安装Android studio 2.1安装Android studio 官网下载Android Studio
下载完毕后点击exe文件安装
点击next
勾选Android Virtual Device手机模拟器
重新设置安装路径（不能带空格或中文）
这里不需要创建桌面快捷方式，不勾选直接点下一步
完成安装，启动Android studio
是否需要导入之前的配置设置，默认不需要（若之前下载过可以导入）
安装完成第一次启动Android studio会弹出弹框，提示我们是否设置代理，直接取消
点击下一步
standard安装最常见的设置和选项，推荐给大多数用户
也可以自定义安装设置和组件
推荐黑色护眼模式
2.2下载Android SDK 检查要安装的组件，更改Android SDK 的路径
下载组件
下载组件完成
三、创建新项目 点击new project
选择empty activity
语言可以选择JAVA或Kotlin
四、下载和创建虚拟机 进入欢迎界面后，点击more actions中的SDK Manager
在SDK Tools里面，选择安装必要组件：Android模拟器、SDK Platform Tools和虚拟机加速，选择好之后点击安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8d4f4822a9dacd01a78286485aec12e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5807573762cdb77b2739d80546bc6fe0/" rel="bookmark">
			Linux进程管理2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 PCB结构体
为什么要有结构体PCB
PCB是什么
二 如何创建一个进程？
1 用命令行创建一个进程
2 用代码来创建进程
① 基本使用
②其他问题
a 为什么有两个返回值
b 为什么这样返回
c if和else会被同时执行？
一 PCB结构体 为什么要有结构体PCB 在windows中，我们双击桌面图标，启动一个软件的本质上，就是启动了一个进程。那么类似的，在linux下，运行一条命令，就是在系统层面创建了一个进程。操作系统只能对进程来进行调度。因此我们用操作系统管理的时候，也就是对进程进行管理。
有这样一种情况，我们可以同时运行成千上万条命令，同时加载多个程序，也就是说，在OS中可能存在大量的进程，那么OS怎么对这些进程来进行管理？
之前谈到的概念，先描述，再组织（管理的本质）
更正：struct_task-&gt;task_struct
我们写的一个个可执行程序以文件（内容+属性）的形式存储在磁盘上，当运行的时候，需要把他加载到内存中。由于进程很多，为了实现管理，把他们描述成一个个PCB结构体（不用存放内容，只用加载属性即可），以链表的数据结构形式对他们来实现管理。
struct PCB { struct PCB* next;//指向下一个PCB struct PCB* prev;//指向上一个PCB ……//data 其他的属性数据与进程相关的 }; 写成代码就是这样的一个意思。
因此，PCB存在的意义就是管理OS中存在的大量进程。
PCB是什么 PCB（process control block）进程控制块，是结构体的形式存储的。在不同的操作系统中，PCB不同，但是在Linux中叫做task_struct
task_struct中，有各种属性数据。
从知乎上截取的：
(1)标示符 ： 描述本进程的唯一标识符，用来区别其他进程。
(2)状态 ：任务状态，退出代码，退出信号等。
(3)优先级 ：相对于其他进程的优先级。
(4)程序计数器：程序中即将被执行的下一条指令的地址。
(5)内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针。
(6)上下文数据：进程执行时处理器的寄存器中的数据。
(7) I／O状态信息：包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。
(8) 记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
还有一些其他信息
接下来会对这些先简单说明下，有个初步的概念，有个感性的认知。
标识符：相当于我们的身份证号码。用来单独唯一标识我们这些人。也是便于管理
状态：一个人平时可以在学习，在运动，在娱乐，对应进程就相当于这些状态
优先级：就是先做什么事情，再做什么事情。注意与权限差别：能否做某事
程序计数器：一个程序被执行，默认是顺序结构，自顶向下一句一句执行的。但是遇到一些比如循环语句，分支语句，就要进行跳转。是由PC指针（EPC）保存当前正在被执行的下一条指令的地址，从而保证指令自顶向下执行。
上下文数据：以各种队列的方式存储在寄存器中的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5807573762cdb77b2739d80546bc6fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0caa7352bb9ac256eb1487c3c12bf9f5/" rel="bookmark">
			VMware NAT模式下 配置固定IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware NAT模式下 配置固定IP
VMware NAT模式下 配置固定IP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc147da1f4694fc1120c0f7a31691e9/" rel="bookmark">
			testpackage包做kmeans趋势分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		testpackage包做kmeans趋势分析 a &lt;- read.table('kmeans20220919.txt',header = T) a &lt;- smalltools::col_to_rowname(a,1) group &lt;- read.table('e:group20220919.txt',header = T) colnames(a) &lt;- group$Sample a &lt;- data.frame(a) data &lt;- a data &lt;- testpackage::means_calculate(data,group) testpackage::kmeans_plot( data, centers = 6, row = 2, col = 3, center_col = "blue", las = 2 ) testpackage::kmeans_plot2( data, centers = 6, row = 2, col = 3, center_col = "blue", las = 2 ) testpackage::kmeans_plot3( data, centers = 6, row = 2, col = 3, center_col = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fc147da1f4694fc1120c0f7a31691e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3405bfe42d099b73bfc0ce4e10f4fa79/" rel="bookmark">
			Internal Error occurred while analyzing this expression
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R.文件找不到报错 原因就是 下面的版本不匹配
以下是官网 对应版本号
https://developer.android.com/studio/releases/gradle-plugin?hl=zh-cn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccab2094f459cc129b021543bafc26fb/" rel="bookmark">
			阿里云OSS云存储简介 与 基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是阿里云oss云存储 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。其数据设计持久性不低于 99.9999999999%（12 个 9），服务设计可用性（或业务连续性）不低于 99.995%。
可以使用阿里云提供的 API、SDK 接口或者 OSS 迁移工具轻松地将海量数据移入或移出阿里云 OSS。数据存储到阿里云 OSS 以后，可以选择标准存储（Standard）作为移动应用、大型网站、图片分享或热点音视频的主要存储方式，也可以选择成本更低、存储期限更长的低频访问存储（InfrequentAccess）和归档存储（Archive）作为不经常访问数据的存储方式。
OSS 具有与平台无关的 RESTful API 接口，可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。
2、OSS与自建存储对比的优势 对比项对象存储OSS自建服务器存储可靠性 OSS作为阿里巴巴全集团数据存储的核心基础设施，多年支撑双11业务高峰，历经高可用与高可靠的严苛考验。OSS的多重冗余架构设计，为数据持久存储提供可靠保障。同时，OSS基于高可用架构设计，消除单节故障，确保数据业务的持续性。服务设计可用性不低于99.995%。数据设计持久性不低于99.9999999999%（12个9）。规模自动扩展，不影响对外服务。数据自动多重冗余备份。 受限于硬件可靠性，易出问题，一旦出现磁盘坏道，容易出现不可逆转的数据丢失。人工数据恢复困难、耗时、耗力。安全 提供企业级多层次安全防护，包括服务端加密、客户端加密、防盗链、IP黑白名单、细粒度权限管控、日志审计、WORM特性等。多用户资源隔离机制，支持异地容灾机制。获得多项合规认证，包括SEC和FINRA 等，满足企业数据安全与合规要求。 需要另外购买清洗和黑洞设备。需要单独实现安全机制。成本 多线BGP骨干网络，无带宽限制，上行流量免费。无需运维人员与托管费用，0成本运维。 存储受硬盘容量限制，需人工扩容。单线或双线接入速度慢，有带宽限制，峰值时期需人工扩容。需专人运维，成本高。智能存储提供多种数据处理能力，如图片处理、视频截帧、文档预览、图片场景识别、人脸识别、SQL就地查询等，并无缝对接Hadoop生态、以及阿里云函数计算、EMR、DataLakeAnalytics、BatchCompute、MaxCompute、DBS等产品，满足企业数据分析与管理的需求。 需要额外采购，单独部署。 3、应用场景 图片和音视频等应用的海量存储
网页或者移动应用的静态和动态资源分离云 云端数据处理 4、计量计费 阿里云对象存储 OSS 服务费用的各项组成部分及计费方式分为按量计费和包年包月两种。
按量付费：按实际使用量*单价的方式计费，每小时统计前一小时的实际用量并从账户余额中扣除实际消费金额。例如当前时间是 9:30，结算的是 8:00-9:00 产生的费用 。
包年包月：预先购买指定资源包，之后使用资源时，扣除相应的额度。一般情况下，包年包月比按量付费更加优惠。资源包目前仅提供标准（LRS）存储包、低频（LRS）存储包、归档（LRS）存储包、标准（ZRS）存储包、低频（ZRS）存储包、下行流量包、 回源流量包、传输加速包，可购买地域请参见购买对象存储 OSS 资源包。
这个看一个实际的计费案例即可
https://help.aliyun.com/document_detail/109686.html?spm=a2c4g.11186623.6.562.4bbd7c28AAnl9D
5、存储空间（Bucket） 存储空间是用户用于存储对象（Object）的容器，所有的对象都必须隶属于某个存储空间。存储空间具有各种配置属性，包括地域、访问权限、存储类型等。用户可以根据实际需求，创建不同类型的存储空间来存储不同的数据。
同一个存储空间的内部是扁平的，没有文件系统目录的概念,所有的对象都直接隶属于其对应的存储空间。每个用户可以拥有多个存储空间。存储空间的名称在 OSS 范围内必须是全局唯一的，一旦创建之后无法修改名称。存储空间内部的对象数目没有限制。 存储空间的命名规范如下：
只能包括小写字母、数字和短横线（-）。必须以小写字母或者数字开头和结尾。长度必须在 3–63 字节之间。 6、对象/文件（Object） 对象是 OSS 存储数据的基本单元，也被称为 OSS 的文件。对象由元信息（Object Meta），用户数据（Data）和文件名（Key）组成。对象由存储空间内部唯一的 Key 来标识。对象元信息是一组键值对，表示了对象的一些属性，比如最后修改时间、大小等信息，同时用户也可以在元信息中存储一些自定义的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccab2094f459cc129b021543bafc26fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bb3fa5a44fde6e360a7081909bfd5a5/" rel="bookmark">
			Wireshark使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 介绍与说明界面介绍表达式捕获过滤器表达式语法：捕获过滤器例子 显示过滤器表达示语法显示过滤器例子 两种过滤器的区别 分析TCP的三次握手Wireshark中常见的TCP数据包的红黑着色问题 介绍与说明 大学上计算机网络的时候就学习了TCP的三次握手协议，当时我学的时候就觉得这些东西好虚啊，看不见摸不着，学的费心费力，结果却差强人意。最近因为要做TCP/IP的课设，老师要求要用wireshark，然后就接触到了这款开源软件Wireshark。通过了解知道这是一款非常流行的网络封包分析软件，功能十分强大，可以截取各种网络封包，显示网络封包的详细信息。有了wireshark就能截获这些网络数据包，可以清晰的看到数据包中的每一个字段。更能加深我们对网络协议的理解。（所以在这插一句话哦： 理论指导实践，实践发展理论)在过去，网络封包分析软件是非常昂贵的，或是专门属于盈利用的软件。wireshark的出现改变了这一切。在GNUGPL通用许可证的保障范围底下，使用者可以以免费的途径取得软件与其源代码，并拥有针对其源代码修改及客制化的权利。
Ethereal（wireshark的前身）是全世界最广泛的网络封包分析软件之一。为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容.
总结，如果是处理HTTP,HTTPS 还是用Fiddler, 其他协议比如TCP,UDP 就用wireshark.
简单介绍一下：Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指cookie,html,js,css等文件）。
Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。它是用C#写出来的,包含一个简单却功能强大的基于JScript .NET 事件脚本子系统，它的灵活性非常棒，可以支持众多的http调试任务，并且能够使用.net框架语言进行扩展。（百度百科，官方文档）
那么我们在Linux系统下一般用什么抓包工具呢？
那就是TCPDUMP啦！
简单介绍一下：TCPDump可以将网络中传送的数据包完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。
Linux作为网络服务器，特别是作为路由器和网关时，数据的采集和分析是不可少的。TcpDump是Linux中强大的网络数据采集分析工具之一。
用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。
作为互联网上经典的的系统管理员必备工具，tcpdump以其强大的功能，灵活的截取策略，成为每个高级的系统管理员分析网络，排查问题等所必备的工具之一。（官方文档）
界面介绍 上图，一般用作对手机应用上网时的抓包分析，比如说想分析手机版微信聊天或者打开朋友圈的数据包。
点击不同协议的数据包，数据包分层协议展示的内容就不一样，上图笔者分别选中的是第六个（TLS）和第七个(TCP)数据包。
TLS：它是一个在传输层为数据提供保密和完整性的一个安全协议，说白了就是保障传输层数据包的安全，大家所熟知的HTTPS中的S就是TLS。
再例如：http协议是一个应用协议所以
对IP层数据报进行一一对应：
对TCP数据报进行一一对应
表达式 简单介绍一下Wireshark分析数据包时最重要的技巧之一的过滤器。一次性嗅探到的数据包有很多，想要高效地提取出你想要的数据包或者对某个数据包中某个字段值的分析等，必不可少的就是过滤。过滤器分为捕捉过滤器（CaptureFilters）和显示过滤器（DisplayFilters）。
可以把捕获过滤器看作是一级过滤，显示过滤看做二级过滤
也就是说：先规定一下数据报的特征（一级过滤），由于需求过滤完之后还是满足不了要求所以再进行一次过滤（二级过滤），笔者只是打个比方，可能不太严谨。
捕获过滤器表达式 捕获过滤器表达式作用在wireshark开始捕获数据包之前，只捕获符合条件的数据包，不记录不符合条件的数据包。
捕获过滤器表达式没有像显示过滤器表达式那样明显的规律，但写法不多所以也不难；而且除非全部捕获要占用的磁盘空间实现太大，且你非常明确过滤掉的数据包是你不需要的，不然一般都不用捕获过滤器表达式而用显示过滤器表达式。
如何打开捕获过滤器：
语法： Protocol（协议）
可能的值: ether, fddi, ip, arp, rarp, decnet, tcp and udp等。如果没有特别指明是什么协议，则默认使用所有支持的协议
Direction（方向）
可能的值: src, dst, src and dst, src or dst。如果没有特别指明来源或目的地，则默认使用 “src or dst” 作为关键字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bb3fa5a44fde6e360a7081909bfd5a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f8f94d606fe9abf80bff3dede45a75/" rel="bookmark">
			spring security OAuth2 实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、OAuth 介绍
（1）OAuth 2.0授权流程
（2）授权模式分类
2、OAuth2的授权码模式
（1）相关依赖引入
（2）配置 spring security （3）添加授权服务器
（4）添加资源服务器
3、OAuth2的简化模式
4、OAuth2的密码模式
5、OAuth2的客户端模式
6、更新令牌
7、基于 redis 存储 Token
1、OAuth 介绍 OAuth（Open Authorization）是一个关于授权（authorization）的开放网络标准，允许用户授权第三方应用访问存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。OAuth在全世界得到广泛应用，目前的版本是2.0版。
OAuth协议：https://tools.ietf.org/html/rfc6749
OAuth 基本概念
Third-party application：第三方应用程序，又称"客户端"（client），比如京东商城HTTP service：HTTP服务提供商，简称"服务提供商"，比如微信Resource Owner：资源所有者，又称"用户"（user），登陆用户的信息User Agent：用户代理，比如浏览器。Authorization server：授权服务器，即服务提供商专门用来处理授权的服务器。Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。 OAuth的作用就是让"客户端"安全可控地获取"用户"的授权，与"服务商提供商"进行交互。
（1）OAuth 2.0授权流程 以微信开放平台为例：准备工作 | 微信开放文档
基本设计思想：OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。
授权流程图示：
步骤明细：
第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据 code 参数；通过 code 参数加上 AppID 和 AppSecret 等，通过 API 换取 access_token；// 微信方生成token通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。 （2）授权模式分类 客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0 对于如何颁发令牌有四种方式：
授权码模式（authorization code）密码模式（resource owner password credentials）简化(隐式)模式（implicit）客户端模式（client credentials） 不论哪一种授权方式，第三方应用申请令牌之前，都必须先到授权系统备案，注册自己的身份，然后会获取两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36f8f94d606fe9abf80bff3dede45a75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd11e0b930ac34489a533cfdfc7c4a6d/" rel="bookmark">
			ShardingSphere入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第一章 高性能架构模式1、读写分离架构2、数据库分片架构2.1 垂直分片2.1.1 垂直分库2.1.2 垂直分表 2.2 水平分片 3、实现方式3.1 程序代码封装3.2 中间件封装3.3 常用解决方案 第二章 ShardingSphere1、简介2、ShardingSphere-JDBC3、ShardingSphere-Proxy 第三章 MySQL主从同步1、MySQL主从同步原理2、一主多从配置2.1 准备主服务器2.2 准备从服务器2.3 启动主从同步2.4 实现主从同步 第四章 ShardingSphere-JDBC1、读写分离1.1 添加依赖1.2 创建实体类1.3 创建Mapper1.4 配置读写分离(application.properties)1.5 测试 2、垂直分片2.1 创建server-user容器2.2 创建server-order容器2.3 程序实现 3、水平分片3.1 创建server-order0容器3.2 创建server-order1容器3.3 基本水平分片配置3.4 测试水平分片3.5 分布式序列算法 4、多表关联4.1 创建关联表4.2 创建实体类4.3 创建Mapper4.4 配置关联表4.5 测试插入数据 5、绑定表5.1 创建VO对象5.2 添加Mapper方法5.3 测试关联查询5.4 配置绑定表 6、广播表6.1 什么是广播表6.2 创建广播表6.3 创建实体类6.4 创建Mapper6.5 配置广播表6.6 测试广播表 第五章 ShardingSphere-Proxy1、安装1.1 启动Docker容器1.2 上传MySQL驱动1.3 修改配置server.yaml1.4 重启容器1.5 远程连接ShardingSphere-Proxy1.6 访问测试 2、读写分离2.1 修改配置文件2.2 实时查看日志2.3 远程访问测试2.4 应用程序访问Proxy 3、垂直分片3.1 修改配置config-sharding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd11e0b930ac34489a533cfdfc7c4a6d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/66/">«</a>
	<span class="pagination__item pagination__item--current">67/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/68/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>