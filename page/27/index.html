<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2a243f939d496f4ec57a2b231e4d27/" rel="bookmark">
			嵌入式 Linux 下的 LVGL 移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 准备创建工程修改配置修改 lv_drv_conf.h修改 lv_conf.h修改 main.c修改 Makefile 编译运行更多内容 LVGL（Light and Versatile Graphics Library）是一个轻量化的、开源的、在嵌入式系统中广泛使用的图形库，它提供了一套丰富的控件和组件，只需要少量的内存和计算资源，使得在资源受限的设备上创建高端的图形界面成为可能。本文记录如何将 LVGL 移植到嵌入式 Linux 系统中。
编程环境：Windows11 VS Code编译环境：Ubuntu18.04 交叉编译测试平台：正点原子 i.MX6ULL显示屏：5inch RGB 800×480 准备 打开 LVGL 的 Github 主页，分别下载 lvgl、lv_drivers、lv_port_linux_frame_buffer 仓库源码，lvgl 和 lv_drivers 我这里选择了当前最新的已发布版本：
创建工程 创建 lvgl_demo 文件夹；将 lvgl、lv_drivers 复制到 lvgl_demo 中；将 lv_port_linux_frame_buffer 仓库中的 main.c 文件和 makefile 文件复制到 lvgl_demo 中；将 lvgl 中的 lv_conf_template.h 文件复制到 lvgl_demo 中并且改名为 lv_conf.h；将 lv_drivers 中的 lv_drv_conf_template.h 文件复制到 lvgl_demo 中并且改名为 lv_drv_conf.h；创建好的工程目录如图所示：
修改配置 修改 lv_drv_conf.h 将 #if 0 改成 #if 1： 将 USE_FBDEV 的值改为 1，使能 frame buffer 设备： 将 USE_EVDEV 的值改为 1，配置触控输入设备的文件路径： 修改 lv_conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b2a243f939d496f4ec57a2b231e4d27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb863a81ca82fc7eef9265373146efae/" rel="bookmark">
			中国气象站点数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		愁死个人，找不到站点数据啊啊啊啊啊
—————————————————————————————————分割线
1、NCDC网站（隶属于NASA），很全的逐日、逐月、逐年的气象站点数据，但是我下载了，发现中国的气象站点看着是全的，打开下载的表格里2013-2019年的数据几乎全部空缺，并没有卯用。。
NCEI Maps and Geospatial Products
数据下载处理方法见：美国国家气候数据中心（NCDC）数据下载与处理_ftp://ftp.ncdc.noaa.gov/pub/data/noaa/isd-lite/-CSDN博客
2、网站名为Reliable Prognosis，有各站点的逐日气象数据，以csv或xlsx格式下载，数据可靠性未验证，需要科学上网。具体见全网最全免费的气象数据中心 - 知乎，该答主还分享了一些其他的免费气象数据网站。“该网站的天气数据由地面气象站通过气象数据国际自由交换系统提供。“
优点：网站能直接根据给定的时间段，计算某一要素的平均、最大、最小值，省去了计算的麻烦。
缺点：只能逐站点下载/计算，还是麻烦。
北京历史天气
3、常用数据网站，包括气象、排放、降水、土地利用分类等。气象网站Sounding Map，是怀俄明大学探空站点数据，但只有2018年以后的，同样可靠性未验证。
来自CSDN的up主：地学/大气/生态/环境 常用数据（不定时更）_gs(2020)4619-CSDN博客
4、来自经管之家网页：分享几个下载历史气象数据的网站 - 区域经济学 - 经管之家(原人大经济论坛)
以及：数据查询 | 奇妙天气
给了十来个公开分析气象数据的网站，还没完全看完。
3月30日更新：
分析完毕！2号渠道的气温数据应该是靠谱的，和中国气候公报中的趋势一致，降水数据一言难尽。
推荐王晓磊前辈的主页 （中国空气质量历史数据 | 中国气象历史数据 | 北京市空气质量历史数据 ）：他是从NCDC网页选取了中国区域(含港澳台)的观测站点数据,重新按年打包，更新速度非常快（最新数据到2023年初）。
这个数据每年包含400+个站点，注意事项：
1）气温、降水数据中都有部分未观测到为-9999，要剔除；
2）降水、气温数据的比例系数都是10，因此观测值除以10才是实际的降水/气温；
3）最重要的一点，困扰了我很久——甚至多次发邮件咨询王晓磊老师，结果发现是自己粗心没理解导致计算错误！
美国国家气候数据中心NCDC的中国地面气象站数据的6小时降水字段的定义是: Pos 56-61, Length 6: Liquid Precipitation Depth Dimension - Six Hour Duration The depth of liquid precipitation that is measured over a six hour accumulation period. UNITS: millimeters。但是它的数据是每3小时更新一次，比如2022年10月1日的00时为5mm，03时4mm，06时5mm……如何计算日降水量？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb863a81ca82fc7eef9265373146efae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db15184c02e933db1f79a46b768989e/" rel="bookmark">
			数据结构(一)——概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、绪论 1.1数据结构的基本概念 数据：用来描述客观事物的数、计算机中是字符及所有能输入并被程序识别和处理的符号的集合。
数据元素：数据的基本单位，一个数据元素可由若干数据项组成。
数据结构：指相互之间存在一种或多种特定关系的数据元素的集合。
数据结构的三要素：逻辑结构、存储结构、数据的运算。
数据对象：具有相同性质的数据元素的集合，是数据的一个子集。
逻辑结构：指数据元素之间的逻辑关系
集合：各个元素同属一个集合，别无其它关系。线性结构：数据元素之间是一对一的关系。树型结构：数据元素之间是一对多的关系。图状结构（网状结构）：数据元素之间存在多对多的关系。 存储结构(物理结构)：用计算机表示数据元素的逻辑关系（后三种统称为非顺序存储)
顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。链式存储：逻辑上相邻的元素在物理位置上可以不相邻，可借助指示元素存储地址的指针来表示元素之间的逻辑关系。索引存储：在存储元素信息的同时，建立附加的索引表。索引表中的每项称为索引项，索引项 的一般形式是（关键字，地址）。散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储。 若采用顺序存储，则各个数据元素在物理上必须是连续的；
若采用非顺序存储，则各个数据元素在物理上可以是离散的。数据的存储结构会影响存储空间分配的方便程度数据的存储结构会影响对数据运算的速度 数据的运算：运算的定义是针对逻辑结构的， 指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。
例：结合现实需求定义队列这种逻辑结构的运算：
①队头元素出队； ②新元素入队； ③输出队列长度；
数据类型：数据类型是一个值的集合和定义在此集合上的一组操作的总称。
1）原子类型。其值不可再分的数据类型
2）结构类型。其值可以再分解为若干成分（分量）的数据类型
抽象数据类型（ADT）：是抽象数据组织及与之相关的操作。
​
1.2算法和算法评价 1.2.1 算法的基本概念 算法：对特定问题求解步骤的一种描述，是指令的有限序列。其中的每条指令表示一个或多个操作
算法的特性：有穷性、确定性、可行性、输入、输出。
有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
用有限步骤解决某个特定的问题确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。 算法的设计目标：正确性，可读性，健壮性，高效率与低存储量需求。
正确性。算法应能够正确地解决求解问题。可读性。算法应具有良好的可读性，以帮助人们理解健壮性。输入非法数据时算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果高效率与低存储量需求。花费时间少时间复杂度低；不费内存，空间复杂度低。 1.2.2 算法的时间复杂度 算法时间复杂度：事前预估算法时间开销T(n)与问题规模 n 的关系（T 表示 “time）.
如何计算：
找到一个基本操作（最深层循环)分析该基本操作的执行次数x与问题规模n的关系x=f(n)x的数量级O(x)就是算法时间复杂度T (n) 大O表示“同阶”，同等数量级，即当n→∞时，二者之比为常数。
结论：可以只考虑阶数高的部分,问题规模足够大时，常数项系数也可以忽略。
常用技巧：
a）加法规则
多项相加，只保留最高阶的项，且系数变为1
b）乘法规则
多项相乘，都保留
c）“常对幂指阶” 常数级&lt;对数级&lt;幂函数级&lt;指数级&lt;阶层级
三种时间复杂度:
最坏时间复杂度：最坏情况下算法的时间复杂度平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间最好时间复杂度：最好情况下算法的时间复杂度 （一般不考虑） 1.2.3 算法的空间复杂度 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8464cb49c69dafe5f24b18b1a4a54497/" rel="bookmark">
			117.移除链表元素（力扣）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 代码解决 class Solution { public: ListNode* removeElements(ListNode* head, int val) { //删除头节点 while(head!=NULL&amp;&amp;head-&gt;val==val){ ListNode*tmp=head; head=head-&gt;next; delete tmp; } //删除非头节点 ListNode*cur=head; while(cur!=NULL&amp;&amp;cur-&gt;next!=NULL){ if(cur-&gt;next-&gt;val==val) { ListNode*tmp=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; delete tmp; } else { cur=cur-&gt;next; } } return head; } }; 代码思路 这段 C++ 代码定义了一个名为 Solution 的类，其中包含一个名为 removeElements 的成员函数，用于从单链表中删除指定值的所有节点。以下是代码的主要逻辑：
removeElements 函数接受两个参数：指向链表头部的指针 ListNode* head 和要删除的整数值 int val。函数在删除元素后返回修改后链表的头指针。
函数首先检查头节点是否与要删除的值匹配。如果匹配，则迭代删除头节点，直到头节点的值不再匹配指定的值。
处理完头节点后，函数遍历剩余的链表部分。如果遇到节点的值与指定的值匹配，则通过调整指针来删除该节点。否则，移动到下一个节点。
最后，函数返回修改后的链表的头指针。
以下是代码各部分的简要说明：
在删除头节点的循环中，函数检查头节点是否存在（head != NULL），并且其值是否与指定的值匹配（head-&gt;val == val）。在循环内部，将 head 赋值为下一个节点，并删除先前的头节点。
在删除非头节点的循环中，函数遍历链表（cur != NULL &amp;&amp; cur-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8464cb49c69dafe5f24b18b1a4a54497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/642d8e446fbecef829cb7965795fc479/" rel="bookmark">
			CentOS部署FastDFS&#43;Nginx并实现远程访问本地服务器中文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 本地搭建FastDFS文件系统1.1 环境安装1.2 安装libfastcommon1.3 安装FastDFS1.4 配置Tracker1.5 配置Storage1.6 测试上传下载1.7 与Nginx整合1.8 安装Nginx1.9 配置Nginx 2. 局域网测试访问FastDFS3. 安装cpolar内网穿透4. 配置公网访问地址5. 固定公网地址5.1 保留二级子域名5.2 配置二级子域名 6. 测试访问固定二级子域名 前言 FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。
FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。
配备一台公网服务器作为文件上传下载,花费资源和开销比较大,如果在本地搭建FastDFS服务,只把上传后的文件通过cpolar内网端口转发工具将文件配置可通过互联网访问,极大了减少服务器费用及开销,本文介绍详细搭建FastDFS教程,并结合Nginx+cpolar工具实现远程访问文件。
1. 本地搭建FastDFS文件系统 1.1 环境安装 由于fastDFS是由c语言编写,所以我们需要安装gcc
yum -y install gcc-c++ FastDFS依赖libevent库，需要安装。执行如下命令：
yum -y install libevent 1.2 安装libfastcommon 进入local目录
cd /usr/local libfastcommon是FastDFS官方提供的，libfastcommon包含了FastDFS运行所需要的一些基础库。点击下面链接即可获取:
https://github.com/happyfish100/libfastcommon/releases/tag/V1.0.7
获取后,上传到local目录下
解压libfastcommon
tar -zxvf libfastcommonV1.0.7.tar.gz 进入解压文件夹
cd libfastcommon-1.0.7/ 编译
./make.sh 安装
./make.sh install libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录所以需要将/usr/lib64下的库文件拷贝至/usr/lib下。
cp /usr/lib64/libfastcommon.so /usr/lib/ 1.3 安装FastDFS 进入local目录
cd /usr/local 点击下列地址,可获取下载FastDFS_v5.05.tar.gz文件:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/642d8e446fbecef829cb7965795fc479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3991282482d2ee8ffdf77586006a5d64/" rel="bookmark">
			Sqlserver大中小版本下载路径，生命周期，对应OS版本，Edition版本报价介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键术语解释
https://docs.microsoft.com/en-us/sql/t-sql/functions/serverproperty-transact-sql?view=sql-server-ver15
SP = Service Pack 服务包版本
RTM = Original release version 原始发布版本，一般是指没有SP1、SP2的情况下的数据库大版本，比如Sql server 2017目前还没有SP1和SP2，就只有RTM
GDR = General Distribution Release 常规分发版本
CU = Cumulative Update 累积更新
Sqlserver大版本下载路径
Sqlserver 2016
https://www.microsoft.com/en-in/evalcenter/download-sql-server-2016
Sqlserver 2019
https://www.microsoft.com/en-in/evalcenter/download-sql-server-2019
Sqlserver 2022
https://www.microsoft.com/en-in/evalcenter/download-sql-server-2022
Sqlserver大版本生命周期
https://learn.microsoft.com/zh-cn/sql/sql-server/end-of-support/sql-server-end-of-support-overview?view=sql-server-ver16
版本 发布年份 主要支持结束年份 延长支持结束年份
SQL Server 2022 2022 2028 2033
SQL Server 2019 2019 2025 2030
SQL Server 2017 2017 2022 2027
SQL Server 2016 2016 2021 2026
SQL Server 2014 2014 2019 2024
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3991282482d2ee8ffdf77586006a5d64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39da6e170c3de6577c0ab94366164ca8/" rel="bookmark">
			无极低码：五分钟快速上手，开启编程新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无极低码平台凭借其革命性的设计理念和强大的功能特性，正在彻底改变软件开发的传统格局。该平台专为开发者、初创企业和各类研发团队量身打造，旨在提供一种快速而高效的解决方案，以应对日益增长的业务需求和技术挑战。
1.无极低码的核心价值在于降低了编程的准入门槛，它不仅支持5分钟即可上手的快捷学习路径，还允许不会编写复杂代码的用户通过SQL语言来实现服务接口的设计与管理。即使对于完全没有编程经验的用户，仅需具备基本的鼠标操作能力，也能在平台上完成简单的数据处理和服务配置。
2.无极低码平台提供了标准化的服务生成流程，一键式地自动生成后端代码（包括控制层、服务层、实体层等）、管理端前端代码以及Postman测试接口文档，极大地提高了工作效率，减少了开发中的重复劳动。此外，编写好的接口能够实时发布且无需重启服务，这一特点确保了应用部署过程的连续性和稳定性。
3.无极低码平台充分考虑到了API调用的便捷性与效率，支持一次性请求多个接口并同时返回结果，内建分页机制，大大简化了前端数据请求的逻辑，减轻了开发者的工作负担。
4.不仅如此，针对复杂的业务场景和个性化的定制需求，无极低码同样具有高灵活性和扩展性。用户可以在平台生成的基础代码基础上进行二次开发，直接修改底层代码以满足特殊业务逻辑，使得平台既能适应标准化场景，又能无缝衔接非标业务需求。
5.在安全性方面，无极低码也做出了贴心设计，如支持限流策略以保护系统稳定运行，并可以配置登录验证和前置执行逻辑，保障数据的安全访问。
6.无极低码是一个极具创新力的低代码/无代码开发工具，它将传统的编码工作转变为直观的图形化界面操作，极大提升了开发速度和生产力，是数字化时代下企业快速构建及迭代内部应用、优化业务流程的理想选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b65bcf1f2eb59f90b8fa6d690868b951/" rel="bookmark">
			P8665 [蓝桥杯 2018 省 A] 航班时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 洛谷里本道题的第一位题解人@lailai0916。大佬真的太牛啦，思路很是简单。
本题一定要注意输入格式
#include&lt;bits/stdc++.h&gt; using namespace std; /* 去程时间 =飞行时间 +时差 回程时间 = 飞行时间 − 时差。不难发现，求出来回飞行时间的总和取平均值即可 单位为秒（简单粗暴） */ int get() { int h1,m1,s1,h2,m2,s2,day=0; scanf("%d:%d:%d %d:%d:%d",&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2);//输入 if(getchar()==' ') scanf("(+%d)",&amp;day);//如果上述输入之后还有空格，则为第二、三种情况； return day*86400+(h2*3600+m2*60+s2)-(h1*3600+m1*60+s1);//统统化为秒数，简单粗暴 } int main() { int N; scanf("%d",&amp;N); while(N--) { int sum=0; sum=(get()+get())/2;//两次来回时间的平均值 printf("%02d:%02d:%02d\n",sum/3600,sum%3600/60,sum%60);注意小时与分钟的% /号的运算，当算小时之时，分钟则直接舍弃，以此类推... } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a46b6b3af01c23b64b8b1e1776c307/" rel="bookmark">
			无极低码：无极低码部署版操作指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无极低码 ：https://wheart.cn
无极低码是一个面向开发者的工具，旨在为开发者、创业者或研发企业，提供快速，高效，标准化，可定制，私有化部署的平台，在兼顾开发速度的同时，兼顾标准化，低学习门槛，高灵活性和扩展性。 不会写代码也可以写服务, 会写sql就会写服务, 5分钟学会操作, 会写代码可以进行二开定制开, 一键部署服务无需重启, 一键生成后端代码, 一键生成管理端代码, 一键生成postman测试接口！ 帮您进行快速开发应用 快来下载试试吧！ 当前演示环境：tomcat9.0+jdk1.8+mysql5.7
1.资源下载
无极低码基础版部署版v0120240303文档下载—无极低码
2.资源部署
下载资源包解压
3.将资源包拷贝到tomcat发布目录
4.修改数据库配置地址账号密码
路径为：wujicodebase\WEB-INF\classes目录jdbc.properties
只需修改数据库名，密码和账号，如果是远程数据库，别忘了修改地址
如果要看控制台日志，请将debug.switch的值改为true
debug.switch=false
这样就可以看到控制台日志了
5.修改log4j日志输出路径
路径为：wujicodebase\WEB-INF\classes目录log4j.properties，将路径改为自己本地的，如果本地已有D盘，可以不用改
6.导入数据库
使用Navicat 工具或者其他数据库工具导入数据库wujicodebase.sql
7.启动项目
进入tomcat目录，启动tomcat
看到下图为启动成功
8.测试
浏览器地址栏输入：http://localhost:8080/wujicodebase/commapi?m=q&amp;k=selectDSysLogByDayToYear
显示如下结果，或其他json返回结果，即为部署成功，下一步就可以自己编写自己的接口和服务了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d561338d3847eb68b10f133c808457/" rel="bookmark">
			知乎批量自动回答发文章软件工具引流秘籍...，探索知乎账号怎么提高权重引流工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（领取工具：hack466）
知乎，这个知识分享和交流的平台，每天都有大量的内容被创建、分享和讨论。作为内容创作者或品牌推广者，你可能会想：如何才能让自己的声音在这个庞大的社区中被更多人听到呢？
答案很简单，就是需要一款好的引流推广工具。你可能会觉得，这样的工具应该很常见吧？但实际上，真正适合知乎平台、功能齐全且操作简便的引流推广工具并不多。而今天，我要向大家介绍的Win运营工具，就是其中的佼佼者。
（领取工具：hack466） Win运营工具，如其名，是一款专为知乎设计的运营辅助工具。它能帮助你解决很多知乎运营中的痛点，让你的推广之路更加顺畅。
首先，它支持多账号同时操作。你是不是经常需要切换不同的知乎账号来管理内容？有了Win运营工具，这个问题就迎刃而解了。你可以一次性登录多个账号，轻松管理，再也不用频繁切换了。
（领取工具：hack466） 其次，Win运营工具还提供了批量发布回答和文章的功能。想象一下，你只需要一次性设置好内容，然后点击一下按钮，就可以将内容发布到多个账号上。这样一来，内容的覆盖范围和曝光率都会大大提高。
（领取工具：hack466） 当然，光是发布内容还不够，如何让这些内容得到更多人的关注和互动呢？Win运营工具也考虑到了这一点。它可以帮助你实现批量点赞、喜欢、收藏和评论，让你的内容更容易被其他用户发现，并增加互动率。
（领取工具：hack466） 除此之外，Win运营工具还具备资料批量修改的功能。你可以一次性修改多个账号的资料信息，确保它们在知乎平台上保持一致性和专业性。这样一来，不仅提高了管理效率，还能增强用户对你品牌的信任感。
（领取工具：hack466） 另外，Win运营工具还提供了关键词相关用户批量私信的功能。你可以根据关键词筛选出与你内容或品牌相关的用户，然后通过私信与他们建立联系。这样一来，你不仅可以精准地找到潜在的目标用户，还能与他们建立更紧密的联系，提高转化率。
（领取工具：hack466） 最后，不得不提的是Win运营工具的神回复功能。你可以预设一些机智且有趣的回复，让你的评论更容易置顶。这样一来，你的评论就能得到更多人的关注和认可，进一步提高你在知乎平台上的影响力。
（领取工具：hack466） 总之，Win运营工具是一款功能强大、操作简便、朴实实用的知乎引流推广工具。它能帮助你更高效地管理多个账号、发布内容、增加互动率，并与潜在用户建立更紧密的联系。如果你正在寻找一款适合知乎平台的引流推广工具，不妨试试Win运营工具吧！相信它会成为你的得力助手！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a5e5231503980fe6f0068f60475b99/" rel="bookmark">
			【数据分享】2000~2023年MOD15A2H 061 光合有效辐射分数FPAR数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​各位同学们好，今天和大伙儿分享的是2000~2023年MOD15A2H 061 光合有效辐射分数FPAR数据集。如果大家有下载处理数据等方面的问题，可以评论或私信。
Myneni, R., Y. Knyazikhin, T. Park. MODIS/Terra Leaf Area Index/FPAR 8-Day L4 Global 500m SIN Grid V061. 2021, distributed by NASA EOSDIS Land Processes Distributed Active Archive Center,
1 数据简介
MOD15A2H 6.1 版中分辨率成像光谱仪 (MODIS) 结合了叶面积指数 (LAI) 和光合有效辐射分数 (FPAR) 产品，是一个为期 8 天的复合数据集，像素大小为 500 米 (m)。该算法从 8 天内 Terra 传感器的所有采集中选择可用的“最佳”像素。
LAI 被定义为阔叶树冠中每单位地面面积的一侧绿叶面积，以及针叶树冠中每单位地面面积的针叶总表面积的一半。FPAR 定义为被植被冠层绿色元素吸收的入射光合有效辐射（400-700 纳米 (nm)）的比例。
4 级 (L4) MOD15A2H 产品中的科学数据集 (SDS) 包括 LAI、FPAR、两个质量层以及 LAI 和 FPAR 的标准差。每个 MOD15A2H 颗粒还提供两个低分辨率浏览图像 LAI 和 FPAR。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12a5e5231503980fe6f0068f60475b99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9cd7d7bbab0c5f66eb401da37ef1f8/" rel="bookmark">
			Python：关于数据服务中的Web API的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建类似joinquant、tushare类似的私有数据服务应用，有以下一些点需要注意：
需要说明的是，这里讨论的是web api前后端，当然还有其它方案，thrift，grpc等。因为要考虑到一鱼两吃，本文只探讨web api。在web api的基础上，可以提供封装sdk库，供前端函数式调用服务或纯手动写restful api 的方式，自己封装调用函数服务。
一、性能
性能主要取决于后端，前端可以考虑性能更好的语言、多线程和异步。
后端开发上，主要是序列化+压缩。
1、序列化
需要考虑跨语言的问题。比如，如果后端用python开发，用pickle序列化，前端用julia,用rust调用就会存在反序列化的问题。
如果用json序列化，虽然会通用，但效率会差一些。
阿里的Fury据说是一个跨语言的序列化的库，没有试用过。
https://furyio.org python:
pip install pyfury 比如python:
from typing import Dict import pyfury class SomeClass: f1: "SomeClass" f2: Dict[str, str] f3: Dict[str, str] fury = pyfury.Fury(ref_tracking=True) fury.register_class(SomeClass, "example.SomeClass") obj = SomeClass() obj.f2 = {"k1": "v1", "k2": "v2"} obj.f1, obj.f3 = obj, obj.f2 data = fury.serialize(obj) # bytes can be data serialized by other languages. print(fury.deserialize(data)) 这个库，正好缓解不少跨语言的痛点。但是并不一定可以解决所有语言的痛点，比如，对于R，或C#呢，就不知道是否可以。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee9cd7d7bbab0c5f66eb401da37ef1f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6cd3f2e0e859ba2093616bcf5db0f3/" rel="bookmark">
			第三章 软件定义汽车的典型架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 软件定义汽车的典型架构 软件定义汽车的总体架构可以分为四层架构：
（1）硬件平台，异构分布式硬件架构；
（2）系统软件层，包括虚拟机、系统内核、POSIX、Autosar等；
（3）应用中间件和开发框架包括功能软件、SOA等；
（4）应用软件层，包括智能座舱HMI、ADAS/AD算法、网联算法、云平台等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85751f04f273390db1ff9fbba4b2d373/" rel="bookmark">
			大数据技术学习笔记（一）—— 大数据概论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 大数据的概念2 大数据的特点3 大数据生态圈3.1 Hadoop 是什么3.2 Hadoop 的来源3.3 Hadoop的优势3.4 Hadoop的组成3.4.1 HDFS3.4.2 YARN3.4.3 MapReduce 4 大数据技术生态体系 1 大数据的概念 大数据：指无法在一定的时间范围内用常规的软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。
主要解决，海量数据的存储和海量数据的分析计算问题。
按顺序给出数据存储单位：bit、Byte、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB。
2 大数据的特点 大数据的特点简称 4V 特征：
Volume（数据量大）Velocity（速度快）Variety（种类多）Value（价值密度低） 3 大数据生态圈 3.1 Hadoop 是什么 Hadoop是一个由Apache基金会所开发的分布式系统基础架构，主要解决海量数据的存储和海量数据的分析计算问题。从广义来说，Hadoop通常指的是一个更广泛的概念——Hadoop生态圈。
3.2 Hadoop 的来源 Google是Hadoop的思想之源，（Google在大数据方面的三篇论文）
GFS ——&gt; HDFSMapReduce ——&gt; MapReduceBigTable ——&gt; HBase 3.3 Hadoop的优势 Hadoop的优势
高容错性 ：能够自动将失败的任务重新分配高可靠性：Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点高效性：在MapReduce的思想下，Hadoop并行工作，以加快任务处理速度 3.4 Hadoop的组成 注意：模块间联系越多,其耦合性越强,同时表明其独立性越差
3.4.1 HDFS Hadoop Distributed File System，简称 HDFS，是一个分布式文件系统。
HDFS架构：
NameNode（nn）：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。DataNode（dn）：在本地文件系统存储文件块数据，以及块数据的校验和Secondary NameNode（2nn）：每隔一段时间对NameNode中存储的元数据进行备份，一般恢复数据的时候才会用到它，但是它也不能保证完全数据恢复。 3.4.2 YARN 3.4.3 MapReduce MapReduce将计算过程分为两个阶段：Map和Reduce
Map阶段并行处理输入数据Reduce阶段对Map结果进行汇总 4 大数据技术生态体系 图中涉及的技术名词解释如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85751f04f273390db1ff9fbba4b2d373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe5908ce0150a776e0122885a4c59f2/" rel="bookmark">
			5个强大的EDA探索性数据分析神器！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：Deephub Imba
作者:Sharod Dey
大家好，我是阿粥
EDA或探索性数据分析是一项耗时的工作，但是由于EDA是不可避免的，所以Python出现了很多自动化库来减少执行分析所需的时间，今天就跟大家聊聊几个好用的库。
前排提示：文末送两本好书
EDA的主要目标不是制作花哨的图形或创建彩色的图形，而是获得对数据集的理解，并获得对变量之间的分布和相关性的初步见解。我们在以前也介绍过EDA自动化的库，但是现在已经过了1年的时间了，我们看看现在有什么新的变化。
为了测试这些库的功能，本文使用了两个不同的数据集，只是为了更好地理解这些库如何处理不同类型的数据。
YData-Profiling 以前被称为Pandas Profiling，在今年改了名字。如果你搜索任何与EDA自动化相关的内容时，它都会作为第一个结果出现，这也是有充分理由的。
这个库最有用和最常用的是ProfileReport()命令。它生成整个数据集的详细摘要，报告对于获得数据的概览非常有用，特别是如果你不知道从哪里或如何开始分析(通常是这种情况)。这对于那些想要节省时间的新手或有经验的分析师来说非常有用。该报告提供单变量分布，突出数据质量问题，并创建相关性。让我们看一下患者风险概况数据的报告:
patient_data = pd.read_csv('/kaggle/input/patient-risk-profiles/patient_risk_profiles.csv') zomato_data=pd.read_csv('/kaggle/input/zomato-data-40k-restaurants-of-indias-100-cities/zomato_dataset.csv') from ydata_profiling import ProfileReport patient_report=ProfileReport(patient_data) patient_report zomato_report=ProfileReport(zomato_data) zomato_report 这份报告在很直观，也非常全面，它提供了一个很好的概述:
变量统计的简明概述，缺失值的百分比，重复值等。
在Alerts选项卡的简单文本中高亮显示数据质量问题，如高相关性，类不平衡等。
在variables 选项卡中给出了所有变量的单变量分析。有助于了解该变量的分布和统计特性。
点击变量下的“More Details”可以提供对各种其他统计数据，直方图，常见值和极值的更深入分析。基本上包含了一般我们想要知道的所有信息。
对于文本变量，报告生成了一个类似于NLP的概述，如下所示:
Interactions选项卡可以进行双变量分析，其中x轴变量在左列，y轴变量在右列。可以混搭来观察变量之间的相关性。这里唯一的限制是可用的图表类型只有散点图，所以如果想使用不同类型的图表，必须手动绘制。
在Correlations 下，可以观察到所有变量的热图。但是由于变量数量太多，热图几乎难以辨认，所以最好是用自定义参数绘制手动热图。
最后还显示了缺失值和相应的列，以及重复的行(如果有的话)。
现YData报告对于在新数据集上获得立足点并找到进一步调查的方向非常有用。因为Pandas Profiling算是最早 的一个自动化EDA库了，并且YData对它做了非常大的更新。但是在较大数据集的情况下生成报告所需的时间很长，并且有时会崩溃。
SweetViz 这是我自己最喜欢用的自动化库。它有三个主要函数可用于汇总数据集
analyze() -汇总单个数据集并生成报告。
compare() -比较两个df，如' train '和' test '。它只会比较常见的功能。
compare_intra() -比较相同数据集的子集。例如，同一数据中的“男性”和“女性”统计数据。
如果在Jupyter或Kaggle中工作，可以使用show_notebook()来呈现报告，在本地可以使用show_html()在新的浏览器窗口中打开报告。
import sweetviz as sv patient_report_2=sv.analyze(patient_data) patient_report_2.show_notebook(w="100%", h="full") 该报告与YData类似，提供了类似的信息，但UI感觉有点过时。
Association 选项卡创建了一个热图，提供了对变量相关性的洞察，由于变量的数量很大，热图是难以辨认的，对我们没有用处。所以可以使用explore_correlations()函数导出相关矩阵，并使用这些数据绘制带有自定义参数的热图。
为每个变量提供的信息更加简洁。缺失值、惟一值、分布甚至相关性都在每个变量部分中一起给出，所以不必在各个模块之间跳转以查看信息。
对于直方图，箱的数量也可以改变。统计信息可以在右上角查看，频繁值和极值也可以在底部看到。
但是它除了热图之外没有提供双变量分析，因此无法看到两个变量如何相互作用，这与YData不同。
在分析文本数据时，所提供的信息主要基于类和百分比分布，这比YData报告中少了很多
SweetViz给出了数据集的一个很好的概述，并且作为任何分析的起点都是很好的，关键是它运行的速度很快。
D-Tale D-Tale只需一行代码就可以创建一个完全交互的界面，其中有大量的选项可随意使用。只需点击一个按钮就可以完成一些事情，不需要编写许多行代码。几乎所有你想通过编码做的事情都有一个UI功能，可以通过下拉菜单轻松获得。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fe5908ce0150a776e0122885a4c59f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca1c58221b29e5f3b53b5634d82d491e/" rel="bookmark">
			git提交注释规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git初始化 首先下载安装git，配置好公私密钥和github
git命令 git init
git remote add origin [远程库地址]
git pull origin master
git add .
git commit -m “注释”
git push origin master
其他：
git status
git log
git branch
git checkout
git merge
git 注释 格式： &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
// 空一行
&lt;body&gt;
type（必需） 用于说明 commit 的类别
br: 此项特别针对bug号，用于向测试反馈bug列表的bug修改情况
feat：新功能（feature）
fix：修补
docs：文档（documentation）
style： 格式（不影响代码运行的变动）
refactor：重构（即不是新增功能，也不是修改bug的代码变动）
test：增加测试
chore：其他的小改动. 一般为仅仅一两行的改动, 或者连续几次提交的小改动属于这种
revert：feat(pencil): add ‘graphiteWidth’ option (撤销之前的commit)
upgrade：升级改造
bugfix：修补bug
optimize：优化
perf: Performance的缩写, 提升代码性能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca1c58221b29e5f3b53b5634d82d491e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb47725c8bf61fc3e5051b0e38d3e1a/" rel="bookmark">
			vSphere 网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 vSphere网络简介
1 物理网络 为了使物理机之间能够收发数据，在物理机之间建立的网络。VMware ESXi 运行于物理机之上。
2 虚拟网络 在单台物理机上运行的虚拟机之间为了互相发送和接收数据而相互逻辑连接所形成的网络。虚拟机可连接到已创建的虚拟网络。
3 物理以太网交换机 管理物理网络上计算机之间的网络流量。一台交换机可具有多个端口，每个端口都可与网络上的一台计算机或其他交换机连接。可按某种方式对每个端口的行为进行配置，具体取决于其所连接的计算机的需求。交换机将会了解到连接其端口的主机，并使用该信息向正确的物理机转发流量。交换机是物理网络的核心。可将多个交换机连接在一起，以形成较大的网络 4 vSphere 标准交换机 其运行方式与物理以太网交换机十分相似。它检测与其虚拟端口进行逻辑连接的虚拟机，并使用该信息向正确的虚拟机转发流量。可使用上行链路适配器将虚拟网络连接至物理网络，以将 vSphere 标准交换机连接到物理交换机。此类型的连接类似于将物理交换机连接在一起以创建较大型的网络。即使 vSphere 标准交换机的运行方式与物理交换机十分相似，但它不具备物理交换机所拥有的一些高级功能。
5 标准端口组 PortGroup 标准端口组为每个成员端口指定了诸如带宽限制和 VLAN 标记策略之类的端口配置选项。网络服务通过端口组连接到标准交换机。端口组定义通过交换机连接网络的方式。通常，单个标准交换机与一个或多个端口组关联。
6 分布式交换机 vSphere DistributedSwitch 它可充当数据中心中所有关联主机的单一交换机，以提供虚拟网络的集中式置备、管理以及监控。您可以在 vCenter Server 系统上配置 vSphere DistributedSwitch，该配置将传播至与该交换机关联的所有主机。这使得虚拟机可在跨多个主机进行迁移时确保其网络配置保持一致。
7 主机代理交换机 驻留在与 vSphere Distributed Switch 关联的每个主机上的隐藏标准交换机。主机代理交换机会将 vSphere Distributed Switch 上设置的网络配置复制到特定主机。
8 分布式交换机、标准交换机和主机代理交换机三者之间的系
1）在分布式交换机上的配置将会传播至每个主机上隐藏的主机代理交换机上
2）主机代理交换机将分布式交换机上的配置应用在主机上
3）主机代理交换机与分布式交换机同步存在，即分布式交换机存在才会有主机代理交换机
4）标准交换机连接物理主机上的虚拟机，要是想要每台主机上都有同样的配置，就必须一台一台的配置
9 分布式端口 连接到主机的 VMkernel 或虚拟机的网络适配器的 vSphere Distributed Switch上的一个端口。连接网络的方式。通常，单个标准交换机与一个或多个端口组关联。
10 分布式端口组 与 vSphere Distributed Switch 关联的一个端口组，并为每个成员端口指定端口配置选项。分布式端口组可定义通过 vSphere Distributed Switch 连接到网络的方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fb47725c8bf61fc3e5051b0e38d3e1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0deb06ed89c9c4ea2cbe3171518c7d/" rel="bookmark">
			Vue3:全局API(应用实例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		createApp 创建一个应用实例
import { createApp } from 'vue' import App from './App.vue' const app = createApp(App); app.mount() 将应用实例挂载在一个容器元素中。
import { createApp } from 'vue' import App from './App.vue' const app = createApp(App); app.mount('#app') app.unmount()​ 卸载一个已挂载的应用实例
app.component()​ 如果同时传递一个组件名字符串及其定义，则注册一个全局组件；如果只传递一个名字，则会返回用该名字注册的组件 (如果存在的话)。
import { createApp } from 'vue' import App from './App.vue' const app = createApp(App); import { Button } from 'view-ui-plus'; app.component('Button', Button); app.directive()​ 如果同时传递一个名字和一个指令定义，则注册一个全局指令；如果只传递一个名字，则会返回用该名字注册的指令 (如果存在的话)。
import { createApp } from 'vue' const app = createApp({ /* .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe0deb06ed89c9c4ea2cbe3171518c7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741cd7ae573325c21f9de8f7f942f284/" rel="bookmark">
			Python的解释器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无极低码 ：https://wheart.cn
2. 使用 Python 的解释器 2.1. 唤出解释器 当 Python 解释器在机器上可用时，它通常被安装在 /usr/local/bin/python3.12；只要将 /usr/local/bin 加入 Unix shell 的搜索路径就可以通过输入如下命令来启动它：
python3.12 这样，就可以在 shell 中运行 Python 了 [1] 。因为可以选择安装目录，解释器也有可能安装在别的位置；如果还不明白，就去问问身边的 Python 大神或系统管理员。（例如，常见备选路径还有 /usr/local/python。）
在 Windows 机器上当你从 Microsoft Store 安装 Python 之后，python3.12 命令将可使用。 如果你安装了 py.exe 启动器，你将可以使用 py 命令。 请参阅 附录：设置环境变量 了解其他启动 Python 的方式。
在主提示符中，输入文件结束符（Unix 里是 ，Windows 里是 ），就会退出解释器，退出状态码为 0。如果不能退出，还可以输入这个命令：quit()。
在支持 GNU Readline 库的系统中，解释器的行编辑功能包括交互式编辑、历史替换、代码补全等。检测是否支持命令行编辑最快速的方式是，在首次出现 Python 提示符时，输入 。听到“哔”提示音，说明支持行编辑；请参阅附录 交互式编辑和编辑历史，了解功能键。如果没有反应，或回显了 ^P，则说明不支持行编辑；只能用退格键删除当前行的字符。
解释器的操作方式类似 Unix Shell：用与 tty 设备关联的标准输入调用时，可以交互式地读取和执行命令；以文件名参数，或标准输入文件调用时，则读取并执行文件中的 脚本。
另一种启动解释器的方式是 python -c command [arg] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741cd7ae573325c21f9de8f7f942f284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6bfd57554d2ac767bba28aac3bd194/" rel="bookmark">
			textView文本过长显示省略号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		textView文本过长显示省略号在textView标签中添加如下代码即可：
android:ellipsize=“end”
android:lines=“1”
显示指定字符后再显示省略号
举例：
android:maxEms=“9” 用来规定最大字符，根据实际情况更改
android:layout_width=“wrap_content” 注意这里的宽度为wrap_content
可尝试添加下边这两行达到显示省略号的效果
android:singleLine=“true”
android:ellipsize=“end”
补充：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/26/">«</a>
	<span class="pagination__item pagination__item--current">27/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/28/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>