<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a62f2520dbd4815dbbef03df224975e6/" rel="bookmark">
			十大热门开源项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十大体量可观，而且完全由社区成员管理开源项目。
Mozilla Firefox
Mozilla Firefox是由Mozilla基金会开发的开源网络浏览器，于2002年首次以Phoenix之名亮相。Firefox适用于大多数操作系统，涵盖Windows、MacOS、Linux以及大多数手机和平板电脑。
相关技术： C++、C、HTML、JavaScript
Linux
不得不看的十大热门开源项目
Linux是由Linus Torvald于1991年开发的自由开源项目。在本质上，Linux属于面向所有人开放且免费的操作系统内核。
相关技术： C、汇编语言
Apache Cassandra
不得不看的十大热门开源项目
Apache Cassandra NoSQL分布式数据库，用于管理全球海量结构化与非结构化数据。
Cassandra诞生于Facebook之手，最初用于实现收件箱搜索功能，并于2008年7月开源。
相关技术： Java
杰出贡献者：DataStax公司联合创始人兼CTO Jonathan Ellis
TensorFlow
不得不看的十大热门开源项目
TensorFlow是一套用于机器学习及人工智能的免费开源软件库，由Google Brain团队于2015年打造而成。
相关技术： Python、C++
Django
不得不看的十大热门开源项目
Django是一款基于Python的开源Web框架，遵循模型模板视图架构模式。Django的目标只有一个：帮助开发人员快速完成开发工作。
相关技术： Python
Kubernetes
不得不看的十大热门开源项目
Kubernetes是一款开源容器编排系统，用于自动实现计算机应用程序的部署、扩展和管理。Kubernetes最初由谷歌设计完成，目前由云原生计算基金会负责维护。
Kubernetes旨在提供一套“跨主机集群的应用程序容器自动部署、扩展与操作平台”，能够支持包括Docker在内的一系列容器工具。
相关技术： Go
Ansible
不得不看的十大热门开源项目
Ansible是由Red Hat赞助的开源社区项目，其实质是一套非常简单的IT自动化引擎，能够自动实现云供应、配置管理、应用程序部署、服务内编排及其他多种IT需求。
相关技术：Python、PowerShell、Shell、Ruby
Geany
不得不看的十大热门开源项目
Geany是一款小巧的轻量化IDE，能够运行在Linux、Windows、MacOS及各种支持GTK库的系统平台之上。
相关技术： C、C++
Renovate
不得不看的十大热门开源项目
Renovate是一款人见人爱的代码维护工具，用于“保持一切处于最新状态”。Renovate于2019年11月被WhiteSource收购，通过帮助软件项目中的依赖项更新实现自动化以节约开发者时间、降低安全风险。
相关技术： JavaScript、TypeScript
Jenkins
不得不看的十大热门开源项目
Jenkins是一款开源自动化服务器，着力以自动化方式完成软件开发中的构建、测试与部署环节，助力持续集成与持续交付。
咨询热线：+86 400-966-9672
商务合作：info@foreverht.com
官网： https://www.workplus.io
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700f64efc7c9f6c13adf27b8bffee4d1/" rel="bookmark">
			红黑树、b&#43;树、b树、mysql索引详细剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 树基础知识回顾红黑树b树、b+树为什么不能使用二叉树来存储数据库索引B/B+树的索引数量 索引什么是聚簇（集）索引？mysql聚簇和非聚簇索引的区别b+树和哈希索引二级索引二级索引存储主键值而不是存储行指针的优点与缺点 树基础知识回顾 排序二叉树：左 &lt; 根&lt; 右
B 树：有序数组 + 多叉平衡树，节点存储关键字、数据、指针；
B+ 树：有序数组链表 + 多叉平衡树，非叶子节点存储指针、关键字，不存储数据；
红黑树：红黑树是一种不大严格的平衡树（平衡树要求太高）
红黑树 红黑树：
红黑树(一棵自平衡的排序二叉树)五大特性：
1）每个结点要么是红的，要么是黑的。
2）根结点是黑的。
3）每个叶结点，即空结点是黑的。
4）如果一个结点是红的，那么它的俩个儿子都是黑的。
5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。
场景
1）广泛用于C++的STL中,map和set都是用红黑树实现的.
2）著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块,进程的虚拟内存
区域都存储在一颗红黑树上,每个虚拟地址区域都对应红黑树的一个节点,左指针指向相邻的地址
虚拟存储区域,右指针指向相邻的高地址虚拟地址空间.
3）IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.
4）ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.
5）java中的TreeSet,TreeMap
左旋和右旋可以参考：红黑树旋转过程
拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。
而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持 平衡 是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于 8 的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
平衡树是为了防止二叉查找树退化为链表，而红黑树在维持平衡以确保 O(log2(n)) 的同时，不需要频繁着调整树的结构；
当我们进行插入或者删除操作时所作的一切操作都是为了调整树使之符合这五条性质。
下面我们先介绍两个基本操作，旋转。
旋转的目的是将节点多的一支出让节点给另一个节点少的一支，旋转操作在插入和删除操作中经常会用到
b树、b+树 B 树即：多路平衡查找树；
B 树的巧妙之处在于：
将一个节点的大小设置为一页的大小；一个节点可以存放多个关键字（多叉树）；自平衡； 这 3 点结合起来就可以做到：
一个节点大小为一页，被加载进内存时，这些关键字在进行对比，找出需要 leftChild 还是 rightChild 时，都是有用的（如最右侧时需要对比所有节点）；一个节点可以存储多个关键字，有效降低了树的高度； B+ 树的巧妙之处在于：
非叶子节点不存储数据，进一步增大了一页中存储关键字的数量；叶子节点中存储数据且存在指向下一页的链表指针，可以使用顺序查询（支持范围查询）； b+树比b树的优点：
1.顺序查找 范围查找 排序查找能力强
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700f64efc7c9f6c13adf27b8bffee4d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2949db74de1073f6e5d7e8fef0b769/" rel="bookmark">
			vue_过滤器： 对要显示的数据进行特定格式化后再显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 过滤器 对要显示的数据进行特定格式化后再显示 并未改变原本的数据，可是产生新的对应的数据
后台数据 private Timestamp tCreateTime;//创建时间
前端展示 方式一.ant-design-vue 可采用插槽的方法
(1)js文件中:
import moment from ‘moment’
(2)data的columns中:
data(){
return{
columns:[
{title:‘创建日期’,
dataIndex:‘tCreateTime’,
align:‘center’,
customRender:(text,row,index){
return moment(text).format(‘YYYY-DD-MM HH:mm:ss’)
}
]
}
}
(3)
创建时间 方式二.vue中采用定义过滤器的方法 (1)main.js import moment from 'moment' Vue.filter('dateFormat',(datestr,pattern='YYYY-DD-MM HH:mm:ss')=&gt;{ return moment(datestr).format(pattern) }) (2)创建时间 {{param.tcreateTime | dateFormat}} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d5dc59ddaed2aadd05e105f2674d91/" rel="bookmark">
			FeignClient 支持占位符及其原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题与解决方案 在使用 FeignClient 的时候，测试环境和线上环境的域名是不同的，可以使用占位符来动态配置。如下
@FeignClient(name = "test-feign", url = "${feign.url}") public interface TestFeignClient { ... } application.properties
feign.url=localhost:8080 原理 坑人的是 FeignClient 的注释中只说了 value、name 支持占位符，并没有说其他的是否支持。这是通过百度和调试源码发现 contextId、path、url 也支持占位符。下面从源码进行分析：
通过在启动类上添加 @FeignClient 来启用 feign，可配置需要扫描的包：
@EnableFeignClients(basePackages = {"com.example.feign"}) @SpringBootApplication public class FeignApplication { ... } EnableFeignClients 通过 @Import 引入了 FeignClientsRegistrar.class：
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @Import(FeignClientsRegistrar.class) public @interface EnableFeignClients { } FeignClientsRegistrar 实现了接口 ImportBeanDefinitionRegistrar，ImportBeanDefinitionRegistrar 的作用是在项目启动时向 Spring 注册一些 BeanDefinition
class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware, EnvironmentAware {} FeignClientsRegistrar 实现了 ImportBeanDefinitionRegistrar 的 registerBeanDefinitions 方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d5dc59ddaed2aadd05e105f2674d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef19e9d1f9acaf96a095b1a89f431c2e/" rel="bookmark">
			求平均成绩-C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设一个班有n(n&lt;=50)个学生，每人考m(m&lt;=5)门课，求每个学生的平均成绩和每门课的平均成绩，并输出各科成绩均大于等于平均成绩的学生数量。 提示： 1、使用float类型可能无法AC，需使用double类型才能AC； 2、每次测试实例的结果后面有个空行，就是要有两个"\n"或"endl"； #include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int main() { int n,m,a[50][50],i,j,l,k; double b[50],c[50],sum; while(cin&gt;&gt;n&gt;&gt;m) { for(i=0; i&lt;n; i++) { for(j=0; j&lt;m; j++) cin&gt;&gt;a[i][j]; } for(i=0; i&lt;n; i++) { sum=0; for(j=0; j&lt;m; j++) sum=sum+a[i][j]; b[i]=sum/m; } for(j=0; j&lt;m; j++) { sum=0; for(i=0; i&lt;n; i++) sum=sum+a[i][j]; c[j]=sum/n; } k=0; for(i=0; i&lt;n; i++) { l=0; for(j=0; j&lt;m; j++) { if(a[i][j]&lt;c[j]) { l=1; break; } } if(l==0) k++; } for(i=0; i&lt;n; i++) { cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;b[i]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef19e9d1f9acaf96a095b1a89f431c2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176a4a370a61e92bdf14fc67511a1bc5/" rel="bookmark">
			数据的交换输出-C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入n(n&lt;100)个数，找出其中最小的数，将它与最前面的数交换后输出这些数。 输入
输入数据有多组，每组占一行，每行的开始是一个整数n，表示这个测试实例的数值的个数，跟着就是n个整数。n=0表示输入的结束，不做处理。 输出
对于每组输入数据，输出交换后的数列，每组输出占一行。 难度
入门 输入示例
4 2 1 3 4 5 5 4 3 2 1 0 输出示例
#include&lt;stdio.h&gt; int main(){ int a[100]; int n,m,l; int i; while(scanf("%d",&amp;n)!=EOF&amp;&amp;n!=0){ m=0;l=0; for(i=0;i&lt;n;i++){ scanf("%d",&amp;a[i]); if(i==0)m=a[i]; if(a[i]&lt;m){m=a[i];l=i;}//找出最小元素并存储元素值及对应下标 } //将最小值与第一个值互换位置 a[l]=a[0]; a[0]=m; for(i=0;i&lt;n;i++){ if(i!=0) printf(" "); printf("%d",a[i]); } printf("\n"); } return 0; } 1 2 3 4 1 4 3 2 5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2d3912ce279818f2a96010b1e6bd69/" rel="bookmark">
			数据挖掘项目——新零售无人智能售货机商务数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘项目——新零售无人智能售货机商务数据分析 前言一、 原始数据分析二、数据清洗1、处理附件12、处理附件2 三、数据分析1、描述性分析2、数据可视化 结果如下： 前言 本文所使用的代码和数据集请关注公众号： CV市场， 后台回复“零售机项目”获取，感谢支持。
一、 原始数据分析 原数据中包含两个附件annex_1和annex_2。
其中annex_1中有数据：订单号、设备ID、应付金额、实际金额、商品、支付时间、地点、状态、提现。具体如下：
#原始数据 detail = pd.read_csv('annex_1.csv',parse_dates=[0],encoding='gbk') detail.head() annex_2是对附件1(annex_1)中出售商品的具体分类：
goods = pd.read_csv('annex_2.csv',encoding='gbk') goods.head() 二、数据清洗 1、处理附件1 查看附件1的数据信息：
detail.info() #查看是否有缺失值 (detail.isnull()).sum() 可以看到附件1没有空值，那么再继续仔细分析每个数据，这里使用pandas.to_datetime处理“支付时
间”列，由于"创建时间"列包含AM和PM这样的字段，所以使用如下处理：
import pandas as pd from dateutil.parser import parse import datetime as dt detail['支付时间']=detail['支付时间'].apply(lambda x:parse(x)) print(detail['支付时间']) 但是报错了：
意思是日期超过了当前月份的天数，那么具体些代码分析：
#解析出每条数据的年、月、日 detail['year'] = detail['支付时间'].apply(lambda x : int(str(x).split('/')[0])) detail['month'] = detail['支付时间'].apply(lambda x : int(str(x).split('/')[1])) detail['day'] = detail['支付时间'].apply(lambda x : int(str(x).split('/')[-1].split(' ')[0])) detail['year'].unique() 可以看到附件1中只包含2017年的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d2d3912ce279818f2a96010b1e6bd69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928729c1024f8562a015178a4d837eb9/" rel="bookmark">
			求出所有的水仙花数。所谓水仙花数是指一个三位数，其各位数字的立方和等于该数字本身。比如153是一个水仙花数，因为153=1^3&#43;5^3&#43;3^3。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt; int main(void) { int a,b,c; for (a=1;a&lt;10;a++) for (b=0;b&lt;10;b++) for (c=0;c&lt;10;c++) if (a*100+b*10+c==a*a*a+b*b*b+c*c*c) printf("%d",a*100+b*10+c); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb30afa0918c20cea4aabbedf7effc0/" rel="bookmark">
			Clickhouse与Mybatis相结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间由于工作需要，在项目上使用了clickhouse作为存储介质，用来存储原始数据，由于时间仓促又仅仅是存储原始数据，所以将功能简单的实现了一下。不过随着项目的进行，存入clickhouse的数据总类越来越多，导致代码十分混乱，每个功能都在创建自己的DataSource，冗余的代码很多，后期维护起来必然是个坑。所以周末花了点时间将Clickhouse和Mybatis进行整合，在此做个记录。
该功能是基于Maven工程的，引入如下依赖包：
&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ru.yandex.clickhouse&lt;/groupId&gt; &lt;artifactId&gt;clickhouse-jdbc&lt;/artifactId&gt; &lt;version&gt;0.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; 初始化initSessionFactory()，由于我们的使用环境是内网，所以Clickhouse没有设置用户名和密码。
private static SqlSessionFactory initSessionFactory() { String url = PropertiesUtil.getProperty("clickhouse.url"); HikariDataSource ds= new HikariDataSource(); ds.setDriverClassName("ru.yandex.clickhouse.ClickHouseDriver"); ds.setJdbcUrl(url); Environment environment = new Environment("clickhouse", new JdbcTransactionFactory(), ds); Configuration configuration = new Configuration(environment); configuration.setLocalCacheScope(LocalCacheScope.STATEMENT); configuration.addMapper(IDemoMapper.class); synchronized (CLASS_LOCK) { if (factory == null ) { factory = new SqlSessionFactoryBuilder().build(configuration); } } return factory; } 获取当前连接，getCurrentSqlSession()
public static SqlSession getCurrentSession() { if (factory == null) { initSessionFactory(); } if (sqlSession == null) { sqlSession = factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eb30afa0918c20cea4aabbedf7effc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0a1c26a2840904a51a158ae2b694796/" rel="bookmark">
			1163：阿克曼(Ackmann)函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【原题描述】
阿克曼(Ackmann)函数akm(m，n)中，m，n定义域是非负整数(m≤3,n≤10)，函数值定义为：
1.当m=0时，返回n+1
2.当m&gt;0,n=0时，返回akm（m-1，1）
3.当m,n均大于0时，返回akm（m-1,akm（m,n-1））
【思路】
总的来说，这题只需要将题目的信息套进去就好了。或者自己把全部的结果想好，用switch来挑选
//1163：阿克曼(Ackmann)函数 #include&lt;iostream&gt; using namespace std; int akm(int m,int n) { if(m==0) return n+1; else if(m&gt;0 &amp;&amp; n==0) return akm(m-1,1); else if(m&gt;0 &amp;&amp; n&gt;0) return akm(m-1,akm(m,n-1)); } int main() { int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;akm(a,b); } 这样测出来的结果全对，也算是简单的题目了
就这样，886！
作者第一次用，不好的地方请见谅！
如有雷同，纯属意外，本文原创。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4742291bc0f19ee0a54521608f4a0857/" rel="bookmark">
			邮政储蓄银行面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一面： 4，5个人看着简历来问： 1. postgresql 原理了解吗？
2.postgres 调优是怎么进行的？ 都调哪些参数
3.java 技术栈都用哪些？
4.springboot 和springcloud有什么区别？
数据调优：是对软件配置调优还是对sql调优？
sql调优的思路：
pg的运行模式:
数据库性能调优?
springboot 和springcloud 的区别；
hadoop hive 有没有搭建过；
hadoop 的管理节点，数据节点；
实际编写的都有多少行；
awk sed 有使用经验？
笔试： java开发方向的试题，都是比较基础的，平常经常在用但是容易忽略的点。
interface 和 abstract的特点？
final 关键字不能用在什么上面？ （抽象方法？接口类？）
怎样定义常量
抽象类中是否必须定义抽象方法？
抽象类是否能创建对象；abstract方法只能声明，不能实现；
一个类的初始类必须和类的名称相同？
被public 修饰的类 访问约束： 可以被其他包访问；
try{} catch finally 那个可以不写？
Object对象中有哪些方法？ finalize() clone(), toString(),等
volatile 是线程安全的吗？
不是，不能保证原子性；
AtomicInteger 这些可以保证原子性；
abstract 和 interface：
抽象类和接口的概念：
抽象类： 可以没有抽象方法，但抽象类的方法必须是抽象的；
接口： 不能有
z=2 c=0
do{ c-- } while(z=1) ; 执行后，c==?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4742291bc0f19ee0a54521608f4a0857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d672d025da3d613dadfc43a51b433b3e/" rel="bookmark">
			水仙花数-C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 所谓水仙花数，是指一个三位数，其各位数字的立方和等于该数本身。例如：153是一个水仙花数，因为153=1*1*1+5*5*5+3*3*3。请求出给定范围n内的水仙花数 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n,a,b,c,i; scanf("%d",&amp;n); for(i=153;i&lt;=n;i++) { a=i/100; b=i%100/10; c=i%10; if(i==a*a*a+b*b*b+c*c*c) printf("%d ",i); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1013c7c920e497faf3dee582d1da04d6/" rel="bookmark">
			java8 对象转map时重复key Duplicate key 该如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在利用java8 Lambda 表达式将集合中对象的属性转成Map时就会出现 Duplicate key xxxx , 说白了也就是key 重复了！案例如下：
@Data @NoArgsConstructor @AllArgsConstructor class Person{ private String className; private String studentName; } public class DuplicateKey { public static void main(String[] args) { List&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(new Person("一班", "小明")); list.add(new Person("二班", "小芳")); list.add(new Person("一班", "小华")); Map&lt;String, String&gt; map = list.stream().collect(Collectors.toMap(Person::getClassName, Person::getStudentName)); System.out.println(map); } } 此时就会出现Duplicate key xxxx 这个问题，那怎么解决呢？其实很简单，有三种方法 我们需要使用toMap的另外一个重载的方法！ Collectors.toMap(keyMapper, valueMapper, mergeFunction)
作用：重复时采用后面的value 覆盖前面的value
Map&lt;String, String&gt; map = list.stream().collect(Collectors.toMap(Person::getClassName, Person::getStudentName,(key1,key2)-&gt;key1)); 重复时将之前的value 和现在的value拼接或相加起来； Map&lt;String, String&gt; map = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1013c7c920e497faf3dee582d1da04d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9586d8a2eca0b7d38ad8546d58ce256/" rel="bookmark">
			Python 中Dataframe初步理解，探讨参数Data，切片函数loc和iloc含义和应用，适合初学者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dataframe是pandas的模块最具代表的数据结果，其作用之强大溢于言表，下面我们分几个最常用的说一下.
Dataframe中的切片loc，iloc； import pandas as pd
我们先说loc，基本上loc会了，iloc知道原理后自然就会了， 他们俩是一致的；
Dataframe的定义和初始话,直接上几个例子更直接：
---------------------------------------------------------------1----------------------------------------------------------------------------------------------------------------
source=[[1,2,3],[4,5,6],[7,8,9]] col_arr=[‘a’,'b','c']
row_arr = ['aa','bb','cc'] df = pd.Dataframe(data=source,columns=col_arr,index=row_arr)
abcaa123bb456cc789 ---------------------------------------------------------------2----------------------------------------------------------------
df = pd.Dataframe(data=source,columns=col_arr)
如果没有设置行索引或者列所以，Dataframe将会自动用0,1,2,3...作为自动的行列索引
abc012314562789 ---------------------------------------------------------------3----------------------------------------------------------------
df = pd.Dataframe(data=source)
012012314562789 Dataframe的data参数，有一下几个类型：元组，列表，字典
当是一维元组的时候：df = pd.Dataframe(data=(1,2,3))
当是一维列表的时候：df = pd.Dataframe(data=[1,2,3])
当是二维元组的时候：df = pd.Dataframe(data=((1,2,3)))
当是二维列表的时候：df = pd.Dataframe(data=[[1,2,3]])
可以看出当都是一维的时候，参数data是元组还是列表，他俩构成的Dataframe都是一致的，可以混用
但是当都是二维的时候，元组表现出来的还是一列，但是列表确实一行，这就是区别，知道区别了，自己慢慢体会下，((1,2,3),(4,5,6)) 和[[1,2,3],[4,5,6]]分别可以构成什么样的矩阵呢？大家可以自己试一下。
让大家纳闷的是，结果并不是按照上面能推理出来的，二维的元组和列表构建成的Dataframe的矩阵看起来又是一样的。记住，知道怎么用就OK了，没必要知道为什么。-_-
在说一下参数data是字典的情况： pd.DataFrame(data={'a':[1,2,3],'b':[4,5,6],'c':[7,8,9]})
对于这种{'a':xx,'b':xx}字段作为data的参数，字典的key就是列索引名，如果没有指定index的话，行所以就是默认的0,1,2,3...
提醒一下，这个时候就不能指定列索引(columns)了，否则会error
还有一些list和Dictionary，元组混合作为参数的，大家有兴趣可以自己试一下
初始化讲完了，我们来看下具体用法。
Dataframe可以理解为是二维矩阵，或者说是一个二维数组，loc最大的作用就是标记了这个二维矩阵行索引和列索引，因为可以更好的对这个二维数字进行分析和切割；
loc的定义是 loc[rows_index,columns_index]
如果想取矩阵中某一个元素， df.loc['aa','b'] #返回 2
我们列举了一下几个功能：拿上面初始化第一个例子说一下
abcaa123bb456cc789 取一行数据 df.loc['aa'] #返回的是series类型的数据集 df.loc['aa',] #返回的是series类型的数据集 df.loc['aa',:] #返回的是series类型的数据集 df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9586d8a2eca0b7d38ad8546d58ce256/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/904498bf1a5906aa1eb944bb7c51f558/" rel="bookmark">
			计算机组成原理cache例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设某计算机的cache采用4路组相联映像，已知cache容量为16KB，主存容量为2MB，每个字块有8个字，每个字有32位，请回答：
（1） 主存地址多少位（按字节编址），各字段如何划分？
（2） 设cache起始为空，CPU从主存单元0，1，…，100依次读出101个字（主存一次读出一个字），并按此次序数读11次，问命中率为多少？若cache速度是主存速度的5倍，问采用cache和无cache比较速度提高多少倍？
（1）主存字段划分为区号，组号，块号和块内地址，cache字段没有区号。
主存容量为2MB，为2²¹，所以主存地址有21位。
4路组相连说明有4块，所以块号有2位。
8个字*32位=256位，256/8=32字节，因为按字节编址，所以每个字块有32个字节，所以块内地址有5位。
cache容量为16KB，是2¹⁴字节，即为2¹⁴B。一组有四块（4路组相连嘛），一块有2⁵字节，所以一组有2⁷字节，可得cache一共2¹⁴/2⁷=2⁷组，所以组号占7位。
主存大小为2MB，cache大小为16KB，所以一共有2MB/16KB=2⁷个cache区，所以区号占7位。
结果就是区号7组号7块号2块内地址5
也有其他方法，比如知道了主存和cache的位数，求出其中某几个，剩下最后一个一减就求出来了
（2）第一次CPU读cache，cache为空，将主存的数据放到cache，然后再读，所以第1次没命中，剩下10次命中，命中率10/11=0.91。
设读一次cache的时间为t，若有cache，第一次需要读一次cache，读一次主存（第一次没命中，要到主存里取数放到cache里），时间为t+5t=6t，剩下10次用了10t，共16t。
若没有cache，则需要11×5t=55t。
速度提高55/16=3.4375倍。
第一次码字，有些手忙脚乱，不对之处还请纠正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec393f8629c2ca8c358379351837ec5b/" rel="bookmark">
			k8s kubectl cp 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在k8s集群中我们经常需要拷贝文件到容器以及从容器中拷贝文件到本地
拷贝本地文件到容器中:
kubectl cp a.txt xxxx:/opt/ -n namespace
xxxx: pod的名称 , -n 后为pod的namespace
拷贝容器中的文件到本地:
这里有个潜在的k8s bug, k8s 默认不支持绝对路径，只能从工作目录开始拷贝，我们登录到pod中默认的路径就是工作目录，登录进容器的命令
kubectl exec -it -n namespace &lt;pod name&gt; bash 这时将想要拷贝出去的文件放到容器的工作目录下， 比如我这里是a.txt
kubectl cp xxxx:a.txt a.txt -n acp-system
可以看到k8s 容器里不要加路径活绝对路径，直接文件名就好，然后再本地不要写 ./ 或其他路径，需要我们在本地自定义一个文件名， 否则会报错，比如下面的命令就是个错误的命令
kubectl cp xxxx:a.txt ./ -n acp-system
错误如下：
tar: 1.txt: Cannot stat: No such file or directory
tar: Exiting with failure status due to previous errors
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c630854ef1417fe5337a6c3d2241c324/" rel="bookmark">
			组件内slot插槽传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于vue插槽slot来回传值问题 有些情况下，我们需要将组件内的值传给slot插槽，供使用组件的地方调用，这时候可以给slot一个name属性，在使用组件的地方#name名称接收。
&lt;swiper class="swiper" :options="swiperOption" id="cateCard"&gt; &lt;swiper-slide v-for="(category, index) in categories" :key="index"&gt; &lt;slot name="items" :category="category.newsList"&gt;&lt;/slot&gt; &lt;/swiper-slide&gt; &lt;div class="swiper-pagination" slot="pagination"&gt;&lt;/div&gt; &lt;/swiper&gt; 给slot添加有个name属性，并传值在引用组件处使用 #items="{ category }"接收 &lt;m-list-card icon="caidan" title="新闻资讯" :categories="newsCates"&gt; &lt;template #items="{ category }"&gt; &lt;div class="swiper-centent mt-3 d-flex" v-for="(item, index) in category" :key="index" &gt; &lt;sapn&gt;[{{ item.categories }}]&lt;/sapn&gt; &lt;sapn class="mx-2"&gt;|&lt;/sapn&gt; &lt;sapn class="flex-grow-1"&gt;{{ item.title }}&lt;/sapn&gt; &lt;sapn&gt;{{ item.date }}&lt;/sapn&gt; &lt;/div&gt; &lt;/template&gt; &lt;/m-list-card&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b575a3931b4cd270adc1b3a610f2990/" rel="bookmark">
			Spring 5中使用JdbcTemplate的queryForObject()方法查询数据库表中对象时无法创建对象以及对象有的属性值为null的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Spring 5框架时，调用JdbcTemplate进行对数据库的查询：
DaoImpl中的方法：
@Override public User searchUserById(Integer id) { String sql = "select * from user where id = ?"; /** * 返回单个对象使用jdbcTemplate.queryForObject方法 */ User user = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class),id); return user; } 测试方法：
ApplicationContext context = new ClassPathXmlApplicationContext("bean3.xml"); UserService userService = context.getBean("userService", UserService.class); User user = userService.searchUserById(1); System.out.println(user); 报错：
org.springframework.beans.BeanInstantiationException: Failed to instantiate [pojo.User]: No default constructor found; nested exception is java.lang.NoSuchMethodException: pojo.User.()
未能成功创建对象！缺少 default constructor ！即空参构造器！！！
加上对应的空参构造器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b575a3931b4cd270adc1b3a610f2990/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b1ea36efc313a404562ab7369f72473/" rel="bookmark">
			如何批量打印图片文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有大量的图片（bmp、jpg、png等）文件需要打印，如何快速批量打印图片文件？
最简单的方法莫过于选中图片文件，单击鼠标右键，打印即可。
上述方法虽然简单，但很多时不能满足要求：
文件的打印顺序有可能是混乱的，并不是所见的那样；当要计算页数时需要打开每个文件才能查看页数，总页数需要手动统计；无法指定只打印某些页等等。 所有这些需求可以通过使用一款绿色软件【Office批量打印精灵】来满足！
Office批量打印精灵（以下简称“打印精灵”）是一款Word、Excel、Powerpoint、PDF、图片、DWF等文档的批量打印软件。
可到【依云软件官网】（yiyunsoftware.com）下载。
打印精灵无需安装，下载后打开即可使用。
拖放要打印的文件到打印精灵列表，单击“开始打印”即可打印并统计页数。
注意打印精灵同时支持多种类型的文件批量打印，若只想打印某个文件夹下一种类型的文件，可单击“过滤选项”，只勾选指定类型的文件即可。
除支持打印份数等设置外还支持：
支持指定或自动选择纸张大小、纸张来源；支持缩放、旋转。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f6e561f8c44c57f6eda35da5b00dad7/" rel="bookmark">
			如何批量打印Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有大量的Excel文件需要打印，如何快速批量打印Excel文件？
最简单的方法莫过于选中Excel文件，单击鼠标右键，打印即可。
上述方法虽然简单，但很多时不能满足要求：
文件的打印顺序有可能是混乱的，并不是所见的那样；当要计算页数时需要打开每个文件才能查看页数，总页数需要手动统计；无法指定只打印某些页等等。 所有这些需求可以通过使用一款绿色软件【Office批量打印精灵】来满足！
Office批量打印精灵（以下简称“打印精灵”）是一款Word、Excel、Powerpoint、PDF、图片、DWF等文档的批量打印软件。
可到【依云软件官网】（yiyunsoftware.com）下载。
打印精灵无需安装，下载后打开即可使用，注意打印 Excel 文件需安装“Microsoft Office”或“WPS 专业版”。
拖放要打印的文件到打印精灵列表，单击“开始打印”即可打印并统计页数。
注意打印精灵同时支持多种类型的文件批量打印，若只想打印某个文件夹下一种类型的文件，可单击“过滤选项”，只勾选指定类型的文件即可。
除支持双面打印、打印份数等设置外还支持：
支持打印部分Sheet、部分页、奇偶页；支持选择纸张大小、纸张方向、页边距；支持在每版上打印多页。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/80/">«</a>
	<span class="pagination__item pagination__item--current">81/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/82/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>