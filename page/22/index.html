<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef32f0f566d78ec51f75ca7d08cdf818/" rel="bookmark">
			Uni-app开发介绍及入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Uni-app 简介 Uni-app 是一个使用 Vue.js 开发所有前端应用的框架，它使开发者能够使用同一套代码构建应用并发布到 iOS、Android、Web（包括微信小程序、支付宝小程序、百度小程序等）等多个平台。它基于 Vue.js 并扩展了很多特定的 API 和组件，以支持多平台的特性。
Uni-app 的主要特点 跨平台：一套代码，编译到多个平台，包括 Web、移动端（iOS、Android）、以及各大主流小程序平台。基于 Vue.js：开发体验与 Vue.js 类似，如果你熟悉 Vue.js，将很容易上手 Uni-app。组件丰富：提供了丰富的组件和 API，用于快速开发应用。性能优化：Uni-app 对多平台的性能都进行了优化，确保应用运行流畅。社区支持：有活跃的社区和丰富的插件生态系统，可以帮助解决开发中遇到的问题。 入门 Uni-app 环境准备
在开始开发之前，你需要安装 Node.js。Uni-app 的命令行工具（CLI）依赖于 Node.js 环境。
安装 Uni-app CLI
通过 npm 安装 Uni-app 的命令行工具，打开终端（或命令提示符）并执行以下命令：
npm install -g @vue/cli vue create -p dcloudio/uni-preset-vue my-project 这将会创建一个名为 my-project 的新 Uni-app 项目。
开发工具
虽然你可以使用任何文本编辑器或 IDE 来开发 Uni-app，但推荐使用 HBuilderX，它是由 Uni-app 官方提供的，对 Uni-app 有很好的支持。
创建第一个页面
Uni-app 使用页面（pages）和组件（components）的概念。要创建一个新页面，你需要在 pages 目录下创建一个新的 .vue 文件。例如，创建 pages/index/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef32f0f566d78ec51f75ca7d08cdf818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7250fb454d75dbf50e417dd072f8e60/" rel="bookmark">
			HTML、XHTML和HTML5 的区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HTML（HyperText Markup Language）、XHTML（eXtensible HyperText Markup Language）和HTML5是网页设计和互联网标准中使用的三种不同的标记语言。它们之间的主要区别可以从语法、结构和功能等方面来概括：
HTML（HyperText Markup Language）:
历史: HTML是最早的网页标记语言，起源于1990年代初。语法: HTML的语法相对宽松，不要求遵循严格的规则。例如，标签可以不区分大小写，也不一定需要闭合。目的: HTML的主要目的是定义网页的结构和内容，使用标签来组织文本、图片、链接等元素。兼容性: 由于其宽松的语法，HTML在所有主流浏览器中都能得到很好的支持。 XHTML（eXtensible HyperText Markup Language）:
历史: XHTML是HTML的一个更严格的版本，于2000年左右被提出，旨在结合XML的严格性和HTML的功能。语法: XHTML要求遵循XML的规则，所有标签必须小写，并且必须正确闭合。XHTML文档也必须是格式良好的XML文档。目的: XHTML旨在提高网页的兼容性和可维护性，同时为将来的网络技术发展提供基础。兼容性: 由于其严格的规则，XHTML在浏览器中的兼容性也很好，但由于其复杂性，实际应用中逐渐被HTML5所取代。 HTML5:
历史: HTML5是HTML的第五个修订版本，于2014年成为W3C的推荐标准。语法: HTML5简化了HTML和XHTML的语法，同时引入了新的元素和API，以支持多媒体内容和图形的集成，如&lt;audio&gt;、&lt;video&gt;和&lt;canvas&gt;。目的: HTML5旨在创建更丰富的网页内容和应用，支持跨平台的网页应用，并且增强了网页与设备硬件的交互能力。功能: HTML5引入了许多新特性，如语义化标签（如&lt;article&gt;、&lt;footer&gt;、&lt;nav&gt;等），表单控件的增强，以及离线存储和Web Workers等API，使得网页应用更加强大和高效。兼容性: HTML5在现代浏览器中得到了很好的支持，但对于旧版浏览器可能需要使用polyfills或转译工具来实现兼容性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd9c9524478fbd21b006627f64d35bd/" rel="bookmark">
			Elasticsearch数据写入、检索流程及底层原理全方位解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		码到三十五 ： 个人主页 心中有诗画，指尖舞代码，目光览世界，步履越千山，人间尽值得 ! 目录 ✍🏻序言✍🏻1️⃣✍🏻es的架构简介1. 分布式架构2. 索引与搜索3. 数据写入与持久化4. 缓存与性能优化 2️⃣✍🏻es的数据写入流程与原理1. 客户端请求与协调节点2. 路由与主分片处理3. 数据同步与副本分片4. 写入确认与响应5. 底层写入机制5.1. 缓冲区（Buffer）和事务日志（Translog）5.2. 刷新（Refresh）操作5.3. Flush操作 3️⃣✍🏻es读取数据流程1. 客户端发送请求2. 请求到达协调节点3. 解析查询并确定目标分片4. 将请求转发给数据节点5. 在数据节点上执行查询6.聚合和排序结果7.返回结果给客户端缓存和优化策略 4️⃣✍🏻总结 ✍🏻序言✍🏻 在当今数据驱动的时代，能够快速、准确地存储和检索信息是企业成功的关键。Elasticsearch，作为一个分布式的、RESTful风格的搜索和分析引擎，以其强大的索引、搜索和聚合功能，成为众多企业和开发者的首选。其背后的读写流程，融合了高效的数据结构与先进的分布式系统原理，确保数据既能被可靠地存储，又能被迅速检索。
1️⃣✍🏻es的架构简介 首先，从架构的角度来看，Elasticsearch是一个分布式的搜索和分析引擎，它能够存储、搜索和分析大量数据。为了实现这些功能，Elasticsearch采用了分片和副本的机制，使得数据可以分布在多个节点上，并且具有容错性和可扩展性。简要介绍Elasticsearch的架构：
1. 分布式架构 节点与集群：Elasticsearch由多个节点（Node）组成，这些节点可以组成一个集群（Cluster）。每个节点都可以处理读写请求，并且数据在集群中的节点之间进行分布和复制，以实现高可用性和扩展性。
分片与副本：为了支持大规模数据，Elasticsearch将索引划分为多个分片（Shard），每个分片可以独立存储和处理数据。此外，每个分片可以有多个副本（Replica），用于提供数据冗余、故障恢复和读取负载均衡。
2. 索引与搜索 倒排索引：Elasticsearch使用Lucene作为其底层的搜索库。Lucene构建倒排索引（Inverted Index）来加速搜索过程。倒排索引将文档中的单词映射到包含这些单词的文档列表，从而实现快速查找和检索。
查询执行：当客户端发送搜索请求时，请求首先到达一个协调节点。协调节点解析查询语句，确定需要访问的分片，并将请求转发给相应的数据节点。数据节点在本地执行查询，并将结果返回给协调节点。协调节点聚合来自各个数据节点的结果，并进行排序、分页等处理，最终将结果返回给客户端。
3. 数据写入与持久化 写入流程：当文档被写入Elasticsearch时，它们首先被放置在内存中的一个缓冲区中，并同时记录到事务日志（Translog）中以确保数据的持久性。随着时间的推移或达到一定的条件，缓冲区中的数据会被刷新（Refresh）到Lucene的索引中，形成新的段（Segment）。这些段是不可变的，一旦被写入就不能被修改。最终，通过flush操作将内存中的数据以及Translog中的更改持久化到磁盘上。
段合并：为了优化存储和搜索性能，Lucene会定期进行段合并（Segment Merging）操作。合并过程中会将多个小的段合并成更大的段，并删除重复和已删除的文档以释放存储空间。
4. 缓存与性能优化 查询缓存：Elasticsearch会对某些查询结果进行缓存以加速重复查询的响应速度。此外，还有分片请求缓存等机制用于减少不必要的计算和I/O操作。
优化策略：为了提高性能，Elasticsearch还提供了多种优化策略，如使用合适的分析器（Analyzer）和查询语句、合理配置索引设置、利用聚合和过滤操作等。这些优化可以减少查询的复杂性和计算开销，提高查询速度和响应时间。
所以，Elasticsearch的架构结合了分布式处理、索引与搜索技术、数据写入与持久化机制以及缓存与性能优化策略等多个方面来实现高效、可靠的数据存储和检索功能。
2️⃣✍🏻es的数据写入流程与原理 在写入数据时，Elasticsearch遵循以下原理和步骤：
1. 客户端请求与协调节点 客户端向Elasticsearch集群发送一个写入请求，这个请求可以发送到集群中的任何一个节点。接收到请求的节点会充当协调节点的角色。协调节点负责处理客户端的请求，并将请求路由到正确的数据节点。 2. 路由与主分片处理 协调节点会根据文档的_id和索引的设置（如分片数量）来确定文档应该写入到哪个主分片。这是通过一个哈希函数和模运算来实现的，确保同一个_id的文档总是路由到同一个主分片。确定目标主分片后，协调节点将请求转发给该主分片所在的数据节点。数据节点上的主分片接收到请求后，会先将文档写入到内存中的Lucene索引结构里。这个过程包括将文档转换成倒排索引的形式，以便后续的搜索和分析。 3. 数据同步与副本分片 一旦文档被写入到主分片，主分片会开始将数据同步到其对应的副本分片上。这是为了保证数据的冗余和可用性。副本分片是主分片的完整拷贝，它们可以处理搜索请求并提供数据恢复的能力。当主分片不可用时，副本分片可以被提升为新的主分片。数据同步是异步进行的，这意味着写入请求在主分片处理完毕后就可以返回给客户端，而不需要等待所有副本分片都完成同步。 4. 写入确认与响应 当主分片和足够数量的副本分片（根据配置可能是全部或大多数）都成功写入了文档后，协调节点会收到这些分片的确认信息。一旦收到足够的确认信息，协调节点就会向客户端发送一个成功的响应，表示文档已经被成功写入。 5. 底层写入机制 在Elasticsearch中，底层写入机制是确保数据可靠、持久化并可以被高效搜索的关键部分：
5.1. 缓冲区（Buffer）和事务日志（Translog） 当文档被写入Elasticsearch时，它们首先被放置在内存中的一个缓冲区中。这个缓冲区是临时的，用于快速接收并处理写入请求。同时，为了确保数据的持久性和可靠性，每一个写入操作也会被记录到事务日志（Translog）中。Translog是一个追加写入的日志文件，它记录了所有对索引的更改。这种机制类似于数据库中的写前日志（WAL）或重做日志（redo log），用于在系统崩溃后恢复数据。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfd9c9524478fbd21b006627f64d35bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd37baa6c5cc1a1a0b08ba8ffa9aa799/" rel="bookmark">
			SpringBoot中使用MybatisX插件的详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MybatisX 是一款针对 MyBatis 框架的 IntelliJ IDEA 的快速开发插件，旨在提高 MyBatis 开发效率的工具。它提供了一系列功能来简化 MyBatis 的配置和使用，包括 XML 文件的智能补全、快速跳转、代码生成等功能。
实现细节 （1）在IDEA中安装MybatisPlus插件：
（2）在application.yml中配置数据库连接：
（3）选择Database --&gt;Data Source ---&gt; MYSQL：
（4）在要实现代码生成的表上，右键选择MybatisX-Generator：
（5）module path选择生成的路径，base package替换为自己要的包路径，如下为com.gzu.peng等配置，表有前缀的记得在ignore table prefix哪里尽心填写。
（6）annotation选择Mybatis-Plus3，template选择mybatis-plus3,options勾选Comment【注解】、Model[实体类domain,不√无domain]、Lombok：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d7fc4627b9da4948ff50393af29e99/" rel="bookmark">
			vim | vim的快捷命令行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 快捷进入shell界面 -&gt; :nnoremap &lt;F8&gt; :sh&lt;CR&gt; -&gt; 绑定到了F8
:nnoremap &lt;F8&gt; :sh&lt;CR&gt; 快捷执行 -&gt; :nnoremap &lt;F5&gt; :wa&lt;CR&gt;:!g++ % -o a.out &amp;&amp; ./a.out&lt;CR&gt; -&gt; 绑定到了F5
:nnoremap &lt;F5&gt; :wa&lt;CR&gt;:!g++ % -o a.out &amp;&amp; ./a.out&lt;CR&gt; 快捷保存 -&gt; :noremap &lt;F4&gt; :wa&lt;CR&gt; -&gt; 绑定到了F4
:nnoremap &lt;F4&gt; :wa&lt;CR&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28baac3d89f911ed21ab6b70fee11df/" rel="bookmark">
			Python的编码和解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的编码和解码 1 什么是编码和解码2 编码的产生3 Python编码的使用4 Python编码和解码函数5 乱码 1 什么是编码和解码 编码是指将字符转换为字节流的过程，解码则是相反的操作。Python3字符的默认编码是Unicode。 2 编码的产生 大家都知道在计算机中一个字节（byte）为8个比特位（bit），能表示的最大整数为255（11111111），2个字节可表示的最大整数为65535（11111111 11111111）。基于上述原理就有了各种编码格式，如ASCII可表示256个字符（英文字母、数字、少部分符号），但中文的范围要更大，因此出现了GB2312、GBK、GB18030等编码用于表示中文，但还不够，比如一些生辟字就表示不了，此时 Unicode 字符集出现了，它将所有的语言都容纳在一起，后续为了在存储和传输数据时节省空间，出现了 UTF8 编码。 3 Python编码的使用 ord()函数获取字符的整数，chr()函数将整数转换为字符
&gt;&gt;&gt; ord('A') 65 &gt;&gt;&gt; chr(65) 'A' &gt;&gt;&gt; ord('学') 23398 &gt;&gt;&gt; chr(23398) '学' 十六进制的使用，10的十六进制是a
&gt;&gt;&gt; int('a', 16) 10 &gt;&gt;&gt; chr(10) '\n' &gt;&gt;&gt; chr(int('a',16)) '\n' 4 Python编码和解码函数 编码函数：encode()，示例如下： &gt;&gt;&gt; en_code = '学习'.encode('utf-8') &gt;&gt;&gt; print('编码结果：', en_code) 编码结果： b'\xe5\xad\xa6\xe4\xb9\xa0' 解码函数：decode()，示例如下： &gt;&gt;&gt; de_code = en_code.decode('utf-8') &gt;&gt;&gt; print('解码结果：', de_code) 解码结果： 学习 5 乱码 如果编码和解码所使用的编码不一致就会出现乱码，示例如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c28baac3d89f911ed21ab6b70fee11df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df168dff9eecdda9afde635b978c4743/" rel="bookmark">
			程序人生——Java使用关于性能和效率的建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引出性能和效率建议132：提升Java性能的基本方法建议133：若非必要，不要克隆对象 建议134：推荐使用“望闻问切”的方式诊断性能建议135：必须定义性能衡量标准 建议136：枪打出头鸟—解决首要系统性能问题建议137：调整JVM参数以提升性能建议138：性能是个大“咕咚” 深入认识JVMJVM内存分配，类加载创建对象的4种方法总结垃圾回收GCJVM调优，Arthas使用 认识多线程创建多线程方法+了解线程池多线程下-1非原子性问题即解决再论线程，创建、生命周期 总结 引出 程序人生——Java使用关于性能和效率的建议
性能和效率 建议132：提升Java性能的基本方法 如何让Java程序跑的更快、效率更高、吞吐量更大：1、不要在循环条件中计算，每循环一次就会计算一次，会降低系统效率；2、尽可能把变量、方法声明为final static类型，加上final static修饰后，在类加载后就会生成，每次方法调用则不再重新生成对象了；3、缩小变量的作用范围，目的是加快GC的回收；4、频繁字符串操作使用StringBuilder或StringBuffer；5、使用非线性检索，使用binarySearch查找会比indexOf查找元素快很多，但是使用binarySearch查找时记得先排序；6、覆写Exception的fillInStackTrace方法，fillInStackTrace方法是用来记录异常时的栈信息的，这是非常耗时的动作，如果不需要关注栈信息，则可以覆盖，以提升性能；7、不建立冗余对象 建议133：若非必要，不要克隆对象 （克隆对象并不比直接生成对象效率高）（通过clone方法生成一个对象时，就会不再执行构造函数了，只是在内存中进行数据块的拷贝，看上去似乎应该比new方法的性能好很多，但事实上，一般情况下new生成的对象比clone生成的性能方面要好很多。JVM对new做了大量的系能优化，而clone方式只是一个冷僻的生成对象的方式，并不是主流，它主要用于构造函数比较复杂，对象属性比较多，通过new关键字创建一个对象比较耗时间的时候 建议134：推荐使用“望闻问切”的方式诊断性能 性能诊断遵循“望闻问切”，不可过度急躁 建议135：必须定义性能衡量标准 原因： 1、性能衡量标准是技术与业务之间的契约；2、性能衡量标志是技术优化的目标 建议136：枪打出头鸟—解决首要系统性能问题 解决性能优化要“单线程”小步前进，避免关注点过多而导致精力分散）（解决性能问题时，不要把所有的问题都摆在眼前，这只会“扰乱”你的思维，集中精力，找到那个“出头鸟”，解决它，在大部分情况下，一批性能问题都会迎刃而解 建议137：调整JVM参数以提升性能 四个常用的JVM优化手段： 1、调整堆内存大小，JVM两种内存：栈内存（Stack）和堆内存（Heap），栈内存的特点是空间小，速度快，用来存放对象的引用及程序中的基本类型；而堆内存的特点是空间比较大，速度慢，一般对象都会在这里生成、使用和消亡。栈空间由线程开辟，线程结束，栈空间由JVM回收，它的大小一般不会对性能有太大影响，但是它会影响系统的稳定性，超过栈内存的容量时，会抛StackOverflowError错误。可以通过**“java -Xss ”设置栈内存大小来解决。堆内存的调整不能太随意，调整得太小，会导致Full GC频繁执行，轻则导致系统性能急速下降，重则导致系统根本无法使用；调整得太大，一则浪费资源（若设置了最小堆内存则可以避免此问题），二则是产生系统不稳定的情况，设置方法“java -Xmx1536 -Xms1024m”**，可以通过将-Xmx和-Xms参数值设置为相同的来固定堆内存大小；2、调整堆内存中各分区的比例，JVM的堆内存包括三部分：新生区（Young Generation Space）、养老区（Tenure Generation Space）、永久存储区（Permanent Space 方法区），其中新生成的对象都在新生区，又分为伊甸区（Eden Space）、幸存0区（Survivor 0 Space）和幸存1区（Survivor 1 Space），当在程序中使用了new关键字时，首先在Eden区生成该对象，如果Eden区满了，则触发minor GC，然后把剩余的对象移到Survivor区（0区或者1区），如果Survivor取也满了，则minor GC会再回收一次，然后再把剩余的对象移到养老区，如果养老区也满了，则会触发Full GC（非常危险的动作，JVM会停止所有的执行，所有系统资源都会让位给垃圾回收器），会对所有的对象过滤一遍，检查是否有可以回收的对象，如果还是没有的话，就抛出OutOfMemoryError错误。一般情况下新生区与养老区的比例为1:3左右，设置命令：“java -XX:NewSize=32m -XX:MaxNewSize=640m -XX:MaxPermSize=1280m -XX:NewRatio=5”,该配置指定新生代初始化为32MB（也就是新生区最小内存为32M），最大不超过640MB，养老区最大不超过1280MB，新生区和养老区的比例为1:5.一般情况下Eden Space : Survivor 0 Space : Survivor 1 Space == 8 : 1 : 1）；3、变更GC的垃圾回收策略，设置命令“java -XX:+UseParallelGC -XX:ParallelGCThreads=20”，这里启用了并行垃圾收集机制，并且定义了20个收集线程（默认的收集线程等于CPU的数量），这对多CPU的系统时非常有帮助的，可以大大减少垃圾回收对系统的影响，提高系统性能；4、更换JVM，如果所有的JVM优化都不见效，那就只有更换JVM了，比较流行的三个JVM产品：Java HotSpot VM、Oracle JRockit JVM、IBM JVM。 建议138：性能是个大“咕咚” 1、没有慢的系统，只有不满足义务的系统；2、没有慢的系统，只有架构不良的系统；3、没有慢的系统，只有懒惰的技术人员；4、没有慢的系统，只有不愿意投入的系统 深入认识JVM JVM内存分配，类加载 Java进阶（1）——JVM的内存分配 &amp; 反射Class类的类对象 &amp; 创建对象的几种方式 &amp; 类加载（何时进入内存JVM）&amp; 注解 &amp; 反射+注解的案例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df168dff9eecdda9afde635b978c4743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef7c0dae14826824fa74d2525c4ea738/" rel="bookmark">
			【数据结构】栈与队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、栈 1.基本概念 栈是只能在一段进行插入或者删除的线性表
出栈进栈 只能在栈顶进行
三个术语：栈底，空栈，栈顶 字面理解即可 栈的基本操作：
创 销 增 删 查
2.顺序栈的实现 （1）初始化
#define max 10 typedef struct { int data[max]; int top; //记录数组下标 }sqstack; //初始化 void inite(sqstack&amp; s) { s.top = -1; } 2.入栈
//入栈 bool push(sqstack&amp; s, int x) { if (s.top == max - 1) //栈满 报错 return false; s.top = s.top + 1; //指针加一 s.data[s.top] = x; return true; } 3.出栈
//出栈 bool pop(sqstack&amp; s, int&amp; x) { if (s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef7c0dae14826824fa74d2525c4ea738/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e34bcb57c6483148ab647655301a3f/" rel="bookmark">
			我们篇002-【自律达人】俱乐部会议2-目标复盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤾‍♀️昨晚跟俱乐部小伙伴们一起复盘了本周目标完成情况，截止目前2周，大家目标执行情况参差不齐。有的小伙伴执行效果很好，也有的小伙伴执行效果相对差点，大家一起把自己本周目标完成情况进行了系统梳理，并且对目标执行较差的情况进行了分析以及讨论出改进意见。以下是目标未完成原因及改进建议：
ㅤ
🛌1、睡眠问题–没有在规定的时间睡觉原因及解决方案
相信绝大部分人都有过这样的经历，我今晚23点一定要睡觉，但到了晚上又被某个消息或者某条新闻吸引，然后就没有然后。下面就梳理一下具体有哪些因素导致无法在规定时间睡觉以及应对方案。
ㅤ
👉原因分析及应对方案：
①玩手机导致晚睡
这应该是大部分人晚睡的原因，尽管很多时候我们一再嘱咐自己要早睡早起，可还是办不到。原因主要有3个方面：(1)人的意志力是有限的，一般情况下，你在立flag的时候意志力都是满满的，你可以克制自己不去做一些本能欲望的事情，但是到了晚上，意志力基本消耗殆尽，你只想放松，只想在手机里寻找多巴胺来慰藉自己疲惫的大脑。(2)环境不一样。千万别小瞧了环境对人的影响，当你在办公室的时候，你只能工作，没有选择。但是当你晚上躺床上时，你自由了，你可以做任何你想做的事情，如果你没有足够的意志力或者没有清晰的规划，毫无疑问本能就会接管你的选择，它会贱贱地对你说“嗨，我知道你累了，来这里(微信、微博、抖音、小红书)休息吧，这里能让你及时行乐，快来”。(3)立 flag 时脑袋里只看到希望，动动脑袋或者动动嘴就行。但是实现 flag 时，面临的却是困难和诱惑。
应对方案：
这个看似复杂的问题解决方案其实很简单，在睡觉前20分钟逐渐跟手机告别，到了睡觉的点手机强制关机或者飞行模式。我知道刚开始有点艰难，但是这种微小的习惯，一般坚持做个5天就养成了。
ㅤ
②跟朋友聊天聊晚了导致晚睡
应对方案：
如果是很久没联系的朋友，偶尔聊到某个话题导致很晚是可以理解的。我们生活中总归会有一些意外事件。如果常规聊天导致晚睡，可以跟朋友坦诚地沟通，我们以后聊天可以提前一点，或者对于没聊完的话题，可以友好地商量明天再继续。我们都渴望与人连接，特别是深度连接。但是当一种连接持续或者严重影响到你的睡眠计划，我们就需要考虑调整这种连接方式，当然一定要注意沟通技巧。
ㅤ
③想着要早点睡，导致反而睡不着
应对方案：
a. 提前20分钟准备睡觉环境，例如提前关灯，睡觉前听一些舒缓的音乐，关闭手机(飞行模式或者关机)。
b. 不要刻意想着一定要睡着，放松心态，实在睡不着就起来看看书，做做运动，不要把睡觉当成一个事来完成。
ㅤ
更多关于睡眠的问题可以参考《经验篇002-试试这些方法，告别失眠》。
ㅤ
2、运动问题–没有按照计划执行运动目标
【自律计划】执行2周以来，大家每次运动时会在群里进行打卡，这样对其他小伙伴是很好的提醒和激励，所以整体上大家运动的执行率都比较高。但是也有个别小伙伴运动项目没有得到很好地执行。主要原因有以下2点：
①到了运动的时间还是忘记了
像我们常年坐在办公室办公的人，一般到了30+之后的年纪，体检报告单上就会有一堆异常，特别是对于有些微胖的人。所以在工作没有特别忙的情况下，我们都期望在工作期间能有点运动量。但是既然是在办公室，大家想到的都是工作，很难有固定的时间走动走动，于是计划自然落空。
应对方案：
建议给自己制定固定的时间点，去做固定的事情。不能只是简单地说，我想上班期间走动走动。比如可以在具体的下午2点或4点，给自己订个闹钟，然后固定的去爬一下5层楼梯，而不是我就随便走动走动。一个行为(习惯)要想得到有效执行一定要固定时间，固定项目。
ㅤ
②啥都想做，结果啥都没做成
关于运动这一块，有些人会有很多想法，想跑步，想冥想，也想练瑜伽等。我们复盘时，发现如果对某个事项，你的选择太多，在执行时反而效果不佳。原因很简单，选择一旦多了，那就不要选了。
应对方案：在众多运动项目中找到自己最想做的那个，或者最多两个，然后给它分配具体的时间。比如晚上20点练瑜伽30分钟，20点30练冥想30分钟。
ㅤ
3、学习问题–没有按照计划执行学习目标
在本次复盘中，发现部分小伙伴也没有按照预期计划执行学习目标。除了刚开始做计划有些时间安排上不太合理之外。也有小伙伴想学的东西太多，导致学不过来，而且自己也不知道对多个学习目标如何进行筛选。
应对方案：
我给小伙伴制作了一个优先级打分表，把所有想要学的项目按照重要性和难易程度进行打分，然后合计分数，分数最高的项目也就是最应该去做的项目。比如你想学英语、想考一个证书。那么思考英语对你的重要性有多大，1-5分进行打分，5分表示最重要。再思考英语学习难度如何，也是1-5分进行打分，5分表示最容易。然后假设英语重要性为4分，难易度为3分，那么合计就是7分，考证书重要性打5分，难易度为4分，那么合计就是9分，很明显你当前的最佳选择就是先考证书。
ㅤ
ㅤ
ㅤ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be0b5da9fc2343d73e910f8a8359b993/" rel="bookmark">
			STM32 POR 上电断电等的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022.05.03
偶然看到这个文章：
STM32L151缓慢上断电-电源控制模块的使用（PVD、BOR、POR/PDR）
可见我以往忽视了多么重要的知识点。
经过测试 STM32F407 ，运行这句话：
printf("defalut bor value is %d\r\n", xxxFLASH_OB_GetBOR());
得到：defalut bor value is 12。
也就是
#define OB_BOR_LEVEL3 ((uint8_t)0x00) /*!&lt; Supply voltage ranges from 2.70 to 3.60 V */ #define OB_BOR_LEVEL2 ((uint8_t)0x04) /*!&lt; Supply voltage ranges from 2.40 to 2.70 V */ #define OB_BOR_LEVEL1 ((uint8_t)0x08) /*!&lt; Supply voltage ranges from 2.10 to 2.40 V */ #define OB_BOR_OFF ((uint8_t)0x0C) /*!&lt; Supply voltage ranges from 1.62 to 2.10 V */ 可以看出默认是OB_BOR_OFF。也就是1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be0b5da9fc2343d73e910f8a8359b993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f05a2500d8c48b7344acd16ee33fd831/" rel="bookmark">
			qt qcheckbox 响应 点击消息， 槽函数传递一个参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 void(QCheckBox:: *pCheckBox)(bool bchecked) = &amp;QCheckBox::clicked; connect(m_pLichengModeCheckBox, pCheckBox, this, &amp;UITestConfig::onLichengMode); void UIConfig::onLichengMode(bool bChecked)//2024.3.8 { //设置激光器延时时间 nLaserms范围 0-255 默认4ms unsigned char pdata[1] = {0}; if(bChecked) { pdata[0] = 0x01; cameramgr_ns::setComFunc(0x2a, pdata);//20mm } else { pdata[0] = 0x00; cameramgr_ns::setComFunc(0x2a, pdata);//50mm } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01533e177114a1223b26997816597a4f/" rel="bookmark">
			直播预告 | 长安链2024年技术路线规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过技术委员会细致的研讨与盘点，长安链2024年技术路线规划形成。长安链产品特性创新、多维技术融合、版本迭代策略等工作内容将如何有序开展？
3月6日（下周三）长安链架构师将与社区开发者交流答疑、征询建议，欢迎开发者预约直播互动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0799010358d3bd09efa3f9dd4def20c/" rel="bookmark">
			长安链共识算法切换：动态调整，灵活可变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#功能发布
长安链3.0正式版发布了多个重点功能，包括共识算法切换、支持java智能合约引擎、支持后量子密码、web3生态兼容等。我们接下来为大家详细介绍新功能的设计、应用与规划。
随着长安链应用愈加成熟与广泛，一些在生产中很实用的需求浮出水面。长安链3.0正式版围绕此类需求融合了多个功能特性，共识算法切换作为其中之一可以赋予联盟链更好的可扩展性，动态灵活的应对系统上线后业务发展、组织节点新增或变更等场景。
共识算法的选择取决于链上节点互信程度、容错率需求等因素。随着业务的发展，已有业务链可能会面临共识性能逐渐不满足现有需求、链上新增组织时节点间互信程度发生了改变等情况，这时共识算法切换就成了非常迫切的需求。
长安链原生支持RAFT、TBFT、ABFT、DPOS等多种共识算法，在首次配置启动后所使用的共识算法即落定不可改变。为了满足更多使用场景中改变共识的需求，长安链在3.0正式版开始支持切换已完成配置的链共识算法，目前TBFT和RAFT共识之间可切换，未来将会带来更多支持。在这里将为大家剖析下长安链是如何进行共识算法切换的。
一、概述 长安链共识算法切换是通过发起共识算法切换交易请求，判定当前的运行环境是否允许新共识算法运行，并对这种判定达成共识后，如果允许切换，则终止原共识算法启用新的共识算法。共识类型在长安链中配置如下
二、共识切换合约逻辑 图1
1.合约执行时，通过虚拟机运行获取到本节点所知晓的当前的共识运行环境信息；
2.获取切换的目标共识算法运行所依赖的环境条件；
3.判定目前的运行环境信息是否满足目标共识依赖的环境条件；
4.如果可切换，合约将更改链配置中共识的类型到目标共识类型，如果需要，则同时更改共识相关的额外配置信息。
概念说明
共识的运行环境：一般包括的信息有参与共识的节点、当前在线的共识节点、互相可正常连通的共识节点等。
共识算法依赖的条件：不同类型的共识算法能够正常运行所依赖的条件不尽相同，如CFT类共识需要满足2f+1&lt;=n, BFT类满足3f+1&lt;=n
三、整体流程 核心流程如下：
图2
1.在共识切换合约逻辑中有提到在执行合约时，需要通过合约运行时获取到共识的运行环境信息，在长安链中这个信息由当前运行的共识算法实例提供，因此在依据链配置中的共识类型初始化成功相应的共识算法实例后，将其注册到vm中（共识状态holder）；
2.创建配置块订监听器，解析监听到配置块，比对配置块中的共识类型同当前运行的共识类型是否相同，不同意味着需要对共识算法进行切换。
3.切换时，终止掉当前链的共识实例，并依据新的共识类型创建新的共识算法实例，而后将其注册到vm中以替换掉原有注册的共识实例。启动新的共识实例，完成切换。
四、共识运行环境信息的采集 在这里我们以RAFT为例，选择RAFT是因为RAFT算法的实现中，从节点之间是不知道彼此的状态的，而共识算法切换对于所有共识节点来说都需要获取到一个相对完备的环境信息，只有这样才能保证对切换的结果达成确定的共识，切换完成后共识也能正常地进行作业。
图3
RAFT信息收集中，定义了两种消息类型
lHeartBeat：心跳消息，各个节点在启动后，会定时地给其他节点发送心跳，以保证对方节点能够知晓自己的存活状态，如果超时未获取，则标记此节点为掉线状态
lNodeLink：节点的连接信息，即节点还需要知晓其他节点所掌握的外部节点的状态信息。比如，node_1需要知道node_2所掌握的node_1、node_2、node_3的心跳状态。
通过这两个消息类型，一个节点就能够知晓整个共识网络中节点的连通状况，在目前的长安链版本中，依据最小交集原则，从中计算出能够彼此都连通的节点的最小集合，在合约执行中，判定这个最小集合是否满足目标共识的需求，如在四节点RAFT-&gt;TBFT切换时，判定最小集合的节点数是否满足2f+1即3个节点。
至此，我们从合约逻辑、整体流程及信息采集三个方面阐述了长安链共识算法切换的机制和流程。
五、共识算法切换使用 sdk逻辑接口
// ### 构造 raft切换到tbft payload
// 参数说明：extConfig: 应用到tbft共识的配置信息 无更改则填nil
CreateRaftToTbftPayload(extConfig []*common.KeyValuePair) (*common.Payload, error)
// ### 构造 tbft切换到raft payload
// 参数说明：extConfig: 应用到raft共识的配置信息 无更改则填nil
CreateTbftToRaftPayload(extConfig []*common.KeyValuePair) (*common.Payload, error)
目前版本仅支持TBFT和RAFT算法之间的相互切换，其中参数extConfig是为目标共识配置的扩展信息，对应链配置的consensus.ext_config，不需要此参数可选填nil。
权限配置
共识切换默认启用的权限为major，可通过更改资源策略来更改共识切换的权限合约名：CHAIN_CONFIG， 方法名：CONSENSUS_SWITCH，资源名：CHAIN_CONFIG-CONSENSUS_SWITCH， 描述：共识切换
cmc命令
./cmc client chainconfig consensus switch \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0799010358d3bd09efa3f9dd4def20c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b51b267725683b176a2ce024ba25b74/" rel="bookmark">
			获取年月日时分秒的npm插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 插件名称：get-year-month-day-hour-minute-second 插件地址：点击跳转 插件介绍： 当前年份 year当前月份 month当前日 day当前年份字符串 yearDate当前年月字符串 formattedDate当前年-月-日字符串 dayDate前一天的年份 previousYear前一天的月份 previousMonth前一天的日 previousDay前一天的（年-月-日）lastDayDate当前小时 hour当前分钟 minutes当前秒 seconds时分秒 hms年月日时分秒 ymdhms 插件使用： 直接通过inmort导入即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916b429f8eb187e93320eb2c057e4676/" rel="bookmark">
			LVS&#43;Keepalived 高可用群集--部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际操作 LVS + Keepalived 高可用群集
环境设备
LVS1192.168.6.88 （MASTER）LVS2192.168.6.87 （BACKUP）web1192.168.6.188web2192.168.6.189客户端192.168.6.86VIP192.168.6.180 （一）web服务器 首先配置web服务
1.下载安装web服务
yum install httpd -y
2.建立虚拟IP
3.调整内核参数
vim /etc/sysctl.conf
调整完毕后开启web服务：systemctl start network
在站点目录下构建数据文件
两台web服务器同样操作
（二）LVS集群服务器 1.下载服务
yum install ipvsadm.x86_64 -y &amp;&amp; yum install keepalived_64 -y
先启动ipvsadm服务
ipvsadm-save &gt;/etc/sysconfig/ipvsadm #生成配置信息文件
systemctl start ipvsadm.service #启动服务
2.配置文件
在配置文件之前，最好先进行备份
cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak
删除60行以下的内容
配置全局设置
配置VRRP热备实例
配置虚拟路由 (注意空格）
配置完毕后启动服务：systemctl start keepalived.service
查看规则情况:ipvsadw -ln
另一台服务器与其基本一致
可主服务配置信息拷到这台机器
需要修改12，19，22行信息，其余配置与主服务一致
配置完毕后启动服务
ipvsadm-save &gt;/etc/sysconfig/ipvsadm
systemctl start ipvsadm.service
systemctl start keepalived.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/916b429f8eb187e93320eb2c057e4676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c01dc341877dcf87a7bf1ac3851aaa7/" rel="bookmark">
			k8s的网络组件有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes 中的网络组件是关键的基础设施，负责管理集群中 Pod 之间、Pod 到服务之间以及集群与外部网络之间的通信。
常见的 Kubernetes 网络组件： Pod 网络：
Flannel： 一种简单且轻量的网络解决方案，通过虚拟网络（VXLAN）实现 Pod 之间的通信。Flannel 可以很容易地部署和配置，适用于各种网络环境。
Calico： 提供了网络和网络安全功能，支持多种网络层技术，包括 VXLAN 和 BGP。Calico 具有强大的网络策略支持，可用于实现细粒度的网络策略和安全性。
Weave： 通过虚拟网络技术连接集群中的节点，支持 Docker 和 Kubernetes。Weave 具有内建的 DNS 支持，并能够透明地在跨主机的 Pod 之间进行通信。
服务发现和负载均衡：
kube-proxy： Kubernetes 核心组件之一，运行在每个节点上，负责维护网络规则并实现服务的负载均衡。kube-proxy通过iptables或IPVS等技术，将服务 IP 地址映射到后端 Pod 的 IP 地址。
CoreDNS： 一个灵活的、可插拔的 DNS 服务器，用于提供服务发现和域名解析。在 Kubernetes 中，CoreDNS 负责将服务名称解析为相应的 Pod IP 地址。
Ingress 控制器：
NGINX Ingress Controller： 通过使用 NGINX 作为反向代理，实现对集群中服务的访问控制和路由。NGINX Ingress Controller 通常与 Ingress 资源结合使用，定义了外部流量如何到达服务。
Traefik： 一款现代的反向代理和负载均衡工具，可以作为 Ingress 控制器使用。Traefik 支持自动发现和动态配置，并且可以与多种后端服务集成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c01dc341877dcf87a7bf1ac3851aaa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6f6584cf1e9a56495975b7f3c38a1de/" rel="bookmark">
			基于YOLOv8深度学习的玉米叶片病害智能诊断与防治系统【python源码&#43;Pyqt5界面&#43;数据集&#43;训练代码】深度学习实战、目标分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《博主简介》
小伙伴们好，我是阿旭。专注于人工智能、AIGC、python、计算机视觉相关分享研究。
✌更多学习资源，可关注公-仲-hao:【阿旭算法与机器学习】，共同学习交流~
👍感谢小伙伴们点赞、关注！
《------往期经典推荐------》
一、AI应用软件开发实战专栏【链接】
项目名称项目名称1.【人脸识别与管理系统开发】2.【车牌识别与自动收费管理系统开发】3.【手势识别系统开发】4.【人脸面部活体检测系统开发】5.【图片风格快速迁移软件开发】6.【人脸表表情识别系统】7.【YOLOv8多目标识别与自动标注软件开发】8.【基于YOLOv8深度学习的行人跌倒检测系统】9.【基于YOLOv8深度学习的PCB板缺陷检测系统】10.【基于YOLOv8深度学习的生活垃圾分类目标检测系统】11.【基于YOLOv8深度学习的安全帽目标检测系统】12.【基于YOLOv8深度学习的120种犬类检测与识别系统】13.【基于YOLOv8深度学习的路面坑洞检测系统】14.【基于YOLOv8深度学习的火焰烟雾检测系统】15.【基于YOLOv8深度学习的钢材表面缺陷检测系统】16.【基于YOLOv8深度学习的舰船目标分类检测系统】17.【基于YOLOv8深度学习的西红柿成熟度检测系统】18.【基于YOLOv8深度学习的血细胞检测与计数系统】19.【基于YOLOv8深度学习的吸烟/抽烟行为检测系统】20.【基于YOLOv8深度学习的水稻害虫检测与识别系统】21.【基于YOLOv8深度学习的高精度车辆行人检测与计数系统】22.【基于YOLOv8深度学习的路面标志线检测与识别系统】23.【基于YOLOv8深度学习的智能小麦害虫检测识别系统】24.【基于YOLOv8深度学习的智能玉米害虫检测识别系统】25.【基于YOLOv8深度学习的200种鸟类智能检测与识别系统】26.【基于YOLOv8深度学习的45种交通标志智能检测与识别系统】27.【基于YOLOv8深度学习的人脸面部表情识别系统】28.【基于YOLOv8深度学习的苹果叶片病害智能诊断系统】29.【基于YOLOv8深度学习的智能肺炎诊断系统】30.【基于YOLOv8深度学习的葡萄簇目标检测系统】31.【基于YOLOv8深度学习的100种中草药智能识别系统】32.【基于YOLOv8深度学习的102种花卉智能识别系统】33.【基于YOLOv8深度学习的100种蝴蝶智能识别系统】34.【基于YOLOv8深度学习的水稻叶片病害智能诊断系统】35.【基于YOLOv8与ByteTrack的车辆行人多目标检测与追踪系统】36.【基于YOLOv8深度学习的智能草莓病害检测与分割系统】37.【基于YOLOv8深度学习的复杂场景下船舶目标检测系统】38.【基于YOLOv8深度学习的农作物幼苗与杂草检测系统】39.【基于YOLOv8深度学习的智能道路裂缝检测与分析系统】40.【基于YOLOv8深度学习的葡萄病害智能诊断与防治系统】41.【基于YOLOv8深度学习的遥感地理空间物体检测系统】42.【基于YOLOv8深度学习的无人机视角地面物体检测系统】43.【基于YOLOv8深度学习的木薯病害智能诊断与防治系统】44.【基于YOLOv8深度学习的野外火焰烟雾检测系统】45.【基于YOLOv8深度学习的脑肿瘤智能检测系统】 二、机器学习实战专栏【链接】，已更新31期，欢迎关注，持续更新中~~
三、深度学习【Pytorch】专栏【链接】
四、【Stable Diffusion绘画系列】专栏【链接】
五、YOLOv8改进专栏【链接】，持续更新中~~
《------正文------》
基本功能演示 摘要：玉米是全球范围内种植最为广泛的农作物之一，对于粮食安全和农业经济发展有着举足轻重的作用。玉米病害会严重影响作物的生长和产量，直接威胁粮食供应。本文基于YOLOv8深度学习框架，通过3852张图片，训练了一个玉米叶片病害的识别模型,可用于识别4种不同的玉米病害类型。并基于此模型开发了一款带UI界面的玉米叶片病害智能诊断与防治系统，可快速、准确地识别实时识别场景中的玉米叶片病害类型，同时提供科学的防治建议，这有助于农户及时采取措施，有效控制病害扩散，显著提升农业生产的效率和可持续性。该系统是基于python与PyQT5开发的，支持图片、批量图片、视频以及摄像头进行识别检测。本文提供了完整的Python代码和使用教程，给感兴趣的小伙伴参考学习，完整的代码资源文件获取方式见文末。
文章目录 基本功能演示前言一、软件核心功能介绍及效果演示软件主要功能（1）图片检测演示（2）视频检测演示（3）摄像头检测演示 二、模型的训练、评估与推理1.YOLOv8的基本原理2. 数据集准备与训练3.模型训练4. 训练结果评估5. 利用模型进行推理 【获取方式】结束语 点击跳转至文末《完整相关文件及源码》获取
前言 玉米是全球范围内种植最为广泛的农作物之一，对于粮食安全和农业经济发展有着举足轻重的作用。玉米叶片病害会严重影响作物的生长和产量，直接威胁粮食供应。通过智能诊断与防治系统，可以快速准确地识别病害类型，及时提供防治建议，极大提升病害管理的效率和效果，降低农业生产的风险，保障农业可持续发展。
玉米叶片病害智能诊断与防治系统的应用场景包括：
玉米农田监控：辅助农民在大面积的玉米种植区进行病害监测和管理，确保作物健康生长。
农业研究和病害防控评估：为研究人员提供数据，帮助他们研究病害发展规律和评估防治措施的有效性。
农技推广和培训：系统可以作为教育工具，辅助农技人员和农民学习病害识别和处理方法。
农资企业服务：农资企业可基于系统诊断结果，为农户提供个性化的防病农药和肥料配套方案。
智能农业解决方案：将玉米叶片病害检测与农场管理系统相结合，提供从种植、管理到收获的全流程智能解决方案。
总结来说，玉米叶片病害智能诊断与防治系统对现代农业的精准管理和科学化经营至关重要。这种系统的应用能显著提升病害管理水平，减少经济损失，并有助于实现农药的精准化使用，最终促使农业生产朝着更加绿色、智能的方向发展。随着人工智能技术在农业领域的深入应用，类似的系统也将在提高农业生产效率和保障粮食安全方面发挥日益重要的作用。
博主通过搜集玉米叶片病害的相关数据图片并整理，根据YOLOv8的深度学习技术训练识别模型，并基于python与Pyqt5开发了一款界面简洁的玉米叶片病害智能诊断与防治系统，可支持图片、批量图片、视频以及摄像头检测。
软件初始界面如下图所示：
检测结果界面如下：
一、软件核心功能介绍及效果演示 软件主要功能 1. 可进行4种不同玉米叶片病害的类型识别，分别为：['锈病','灰叶斑病','健康','枯叶病'];
2.可针对不同病害类型给出对应的防治方法与建议【可自己添加具体描述，字数不限】；
3. 支持图片、批量图片、视频以及摄像头检测；
4. 界面可实时显示识别结果、置信度、用时等信息;
（1）图片检测演示 单个图片检测操作如下：
点击打开图片按钮，选择需要检测的图片，就会显示检测结果。操作演示如下：
批量图片检测操作如下：
点击打开文件夹按钮，选择需要检测的文件夹【注意是选择文件夹】，可进行批量图片检测，表格中会有所有图片的检测结果信息，点击表格中的指定行，会显示指定行图片的检测结果，双击路径单元格，会看到图片的完整路径。操作演示如下：
（2）视频检测演示 点击打开视频按钮，打开选择需要检测的视频，就会自动显示检测结果。
（3）摄像头检测演示 点击打开摄像头按钮，可以打开摄像头，可以实时进行检测，再次点击摄像头按钮，可关闭摄像头。
二、模型的训练、评估与推理 1.YOLOv8的基本原理 YOLOv8是一种前沿的深度学习技术，它基于先前YOLO版本在目标检测任务上的成功，进一步提升了性能和灵活性，在精度和速度方面都具有尖端性能。在之前YOLO 版本的基础上，YOLOv8 引入了新的功能和优化，使其成为广泛应用中各种物体检测任务的理想选择。主要的创新点包括一个新的骨干网络、一个新的 Ancher-Free 检测头和一个新的损失函数，可以在从 CPU 到 GPU 的各种硬件平台上运行。
YOLO各版本性能对比：
其主要网络结构如下：
2. 数据集准备与训练 本文使用的玉米叶片病害数据集共包含3852张图片，分为4个病害类别,分别是['锈病','灰叶斑病','健康','枯叶病']。部分数据集及类别信息如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6f6584cf1e9a56495975b7f3c38a1de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c2a4cb1f8e2468de2b6a7054b2d1e6/" rel="bookmark">
			CPU压力过大怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当CPU压力过大时，服务器可能会出现卡顿、响应缓慢或崩溃等问题。下面是一些可能的解决方法：
查找并结束占用CPU的进程
可以使用系统监控工具，例如top、htop、ps等来查看当前运行的进程以及它们的CPU使用情况。找到占用CPU过高的进程，并结束它们。
可以使用以下命令找到CPU使用率最高的进程：
top
或
htop
然后按下SHIFT+P，将进程按照CPU使用率排序。
可以使用以下命令结束某个进程：
kill -9 这里的指的是进程的ID号。
修改进程的调度策略
在Linux系统中，有一种叫做cgroup的机制，可以限制进程的CPU使用率。通过这种机制，可以防止某个进程占用过多的CPU资源，从而导致系统压力过大。
可以使用cpulimit命令来限制某个进程的CPU使用率。例如，如果要限制ID号为12345的进程的CPU使用率不超过30%，可以使用以下命令：
cpulimit -p 12345 -l 30
这将使进程使用的CPU不会超过30%。
升级硬件
如果服务器的CPU性能较低，可能无法满足业务要求。此时，可以考虑升级硬件，例如更换更快的CPU或增加CPU核数。
优化应用程序
如果应用程序存在性能问题，可能会导致CPU使用率过高。在这种情况下，可以尝试进行应用程序的优化，例如使用缓存、优化查询语句、减少计算量等。
需要注意，如果CPU压力过大是由于恶意攻击引起的，可以采取安全措施，例如加强访问控制、使用防火墙、增加安全认证等，避免遭受黑客攻击。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf92476d0fa964be7a7b9fdcd08909e7/" rel="bookmark">
			解决mysql修改密码后navicat等远程连接依旧可以使用的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mysql -u root -p
Enter password:
use mysql; set global validate_password_policy=0; ## mysql使用简单密码,不使用可忽略 mysql&gt; UPDATE user SET Password = PASSWORD('新密码') WHERE User = 'root'; ##mysql5.7版本之前 UPDATE user SET authentication_string = PASSWORD('!QCZ2wsx#Mysql') WHERE User = 'root'; UPDATE user SET authentication_string = PASSWORD('!QCZ2wsx#Mysql') WHERE User = 'im_repl'; flush privileges; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d6e0028462f4ecb5ae9507f3c5cfac/" rel="bookmark">
			服务器数据恢复—光纤环境互斥不当导致存储VMFS卷损坏的数据恢复案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器数据恢复环境&amp;故障：
某公司的信息管理平台，通过3台虚拟机共享了一台存储设备供企业内部使用，存储设备中存放了公司内部重要的数据文件。
由于业务增长的需要，管理员又在这个存储网络上连接了一台Windows server服务器，结果这台存储变得不可用了。
管理员对该存储进行故障排查时发现存储中虚拟磁盘丢失，分区表丢失。重启该存储设备后故障依旧。
由于存储中的数据十分重要，没有备份。管理员为了安全起见，联系北亚企安数据恢复中心寻求帮助。
经过硬件工程师的检测，没有发现存储存在硬件故障。存储中的硬盘经过硬件工程师的检测后也没有发现任何物理故障，都可以正常读取。基本上可以排除故障是由于硬件导致的。
服务器故障分析：
1、将存储中所有磁盘编号后取出，以只读方式将所有磁盘进行扇区级别全盘镜像，镜像完成后将所有磁盘按照编号还原到故障存储中，后续的数据分析和数据恢复操作都基于镜像文件进行，避免对原始磁盘数据造成二次破坏。
2、基于镜像文件分析所有磁盘中底层数据，经过分析发现分区表被清零，有55AA的有效结束标志，有硬盘ID标志。现在基本上可以确定导致存储故障的原因是新连接的Windows server服务器对storage的独享操作导致了整个存储的VMFS卷损坏。
3、继续分析底层数据发现存储中有一个没有数据的NTFS卷。该卷的BITMAP内容大小与存储的全部空间大小相差无几。在卷的几个不同位置都有部分占用，但所有占用的空间加在一起只有100MB左右。
4、和用户沟通后，得知存储中有两个VMFS分区：第一个分区占80%，第二个分区是第一个分区的扩展分区，ntfs分区对源数据进行破坏时并没有涉及到第二个分区。所以需要恢复的主要是第一个分区上的数据。
服务器数据恢复过程：
1、直接连接存储的两个VMFS分区，按照分区的组织方式直接提取出vmdk文件和配置文件。
2、提取出文件后通过nfs回迁数据对数据恢复结果进行自检。数据恢复工程师自检无误后通知用户方来现场验证数据恢复结果，验证没有问题后移交数据。
服务器数据恢复结论：
这个案例存储中数据丢失的原因就是光纤环境互斥不当导致卷在Windows server系统下重新做了分区，并且执行了格式化NTFS和删除分区的操作。由于esx vmfs的互斥是独立于硬件层面，而单独依赖操作系统的，所以北亚企安数据恢复工程师在这里提醒大家：在存储网络中接入其他服务器时要注意先给存储分配权限，以免导致数据丢失。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/21/">«</a>
	<span class="pagination__item pagination__item--current">22/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/23/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>