<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3490d3707e6e0ed2aaa5b6323c2849/" rel="bookmark">
			内核调试方法 三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录[-]
· 大海里的鱼有很多，而我们需要的是鱼钩一只
· 一些前言
· 作者前言
· 知识从哪里来
· 为什么撰写本文档
· 为什么需要汇编级调试
· ***第一部分：基础知识***
· 总纲：内核世界的陷阱
· 源码阅读的陷阱
· 代码调试的陷阱
· 原理理解的陷阱
· 建立调试环境
· 发行版的选择和安装
· 为什么选debian
· debian与ubuntu
· 从0安装debian
· debian重要命令
· 中文环境设置
· debian的键盘设置更改
· 英文Locale下使用中文输入法
· pdf乱码的解决
· 建立编译环境
· 安装交叉编译工具
· 交叉编译工具下载网址
· 安装arm-linux-gnueabi-XXX 工具集
· 什么是EABI
· 安装arm-elf-XXX 工具集
· bin工具集的使用
· arm-linux-gnueabi-gcc
· arm-linux-gnueabi-gdb
· qemu的使用
· initrd.img的原理与制作
· 安装与使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3490d3707e6e0ed2aaa5b6323c2849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa5c67c3ee3a4ae36c7e946328bee4c/" rel="bookmark">
			liunx----putty--ssh--ppk---密文自动登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载puttygen软件后，打开它
1、点击[Generate]
2、Please generate some radomness by moving the mouse over the blank area.意思就是让你用鼠标在空
白区域随机移动。随着鼠标在空白区域的移动，进度条会一直走下去。停止移动鼠标，进度条也就停止了。那我们就移动鼠标，直到进度条走满为止。
3点击save private key
4、点击是（Y）
5、保存为ppk文件（这里自己命名，文件放在哪儿自己也要知道）
这里是保存在桌面的
6、复制密文
7、登陆想要使用密文的用户、然后在家目录下mkdir .ssh目录
在cd .ssh目录下，创建一个名为touch authorized_keys的文件
将刚刚复制的密文粘贴进去
然后退出保存 ：wq
8、登陆，点击connection-&gt;SSH-&gt;Auth-&gt;Brower.. 找到ppk文件的路径。 填写用户名
保存设置
然后就完成了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3dfecfa0792741793e342bd4874d96/" rel="bookmark">
			人脸数据库汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸数据库汇总 ■Annotated Database (Hand, Meat, LV Cardiac, IMM face) (http://www2.imm.dtu.dk/~aam/) ■AR Face Database (http://cobweb.ecn.purdue.edu/~aleix/aleix_face_DB.html) ■BioID Face Database (http://www.bioid.com/downloads/facedb/index.php) ■Caltech Computational Vision Group Archive (Cars, Motorcycles, Airplanes, Faces, Leaves, Background) (http://www.vision.caltech.edu/html-files/archive.html) ■Carnegie Mellon Image Database (motion, stereo, face, car, ...) (http://vasc.ri.cmu.edu/idb/) ■CAS-PEAL Face Database (http://www.jdl.ac.cn/peal/index.html) ■CMU Cohn-Kanade AU-Coded Facial Expression Database (http://www.ri.cmu.edu/projects/project_421.html ■CMU Face Detection Databases (http://www.ri.cmu.edu/projects/project_419.html) ■CMU Face Expression Database (http://amp.ece.cmu.edu/projects/FaceAuthentication/download.htm) ■CMU Face Pose, Illumination, and Expression (PIE) Database (http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e3dfecfa0792741793e342bd4874d96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09ff780e8eff09371c51befe5aff63f1/" rel="bookmark">
			CAN总线基础知识（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．CAN协议 1.1 帧类型 通讯时使用下面5个类型的帧：
数据帧
遥控帧
错误帧
过载帧
帧间空隙
在所有这些帧中，数据帧和遥控帧由用户设置，而其它帧则由CAN硬件设置。
数据和遥控帧有两种格式：标准和扩展格式。标准格式有11bit的ID，而扩展格式则是29bit的ID。
每个帧的用处见表6，每个帧的结构见图10到图14
表6 帧类型和每种类型帧的作用
2.2 数据帧 数据帧由发送单元使用，用来发送信息给接收单元，这是用户操作的基本帧。
数据帧有7个域组成。图15显示了数据帧的结构。
（1）帧开始（SOF）：这个域表示数据帧的开始。
（2）仲裁域：这个域表示一个帧的优先级
（3）控制域：这个域表示保留位和数据字节数
（4）数据域：这是数据内容，0-8个字节的数据能被发送
（5）CRC域：这个域用于检查帧的传输错误。
（6）ACK域：是对帧已经被正常接收的一个证实。
（7）帧结束：指示数据帧结束
（1）帧开始（SOF），对标准的或扩展的格式都是一样的。它指示一帧的开始，由1bit的显性位组成。
显性电平和隐性电平：
总线上的电平有显性电平和隐性电平两种。
总线上执行逻辑上的线“与”时，显性电平的逻辑值为“0”，隐性电平为“1”。
“显性”具有“优先”的意味，只要有一个单元输出显性电平，总线上即为显性电平，并且，“隐性”具有“包容”的意味，只有所有的单元都输出隐性电平，总线上才为隐性电平。（显性电平比隐性电平更强）
（2）仲裁域，这个域表示数据的优先级别。这个域的结构，对标准和扩展的格式是有差别的。
注1：关于ID：
标准格式的ID有11bit，从ID28到ID18被依次发送，禁止高7位全为隐性。（禁止设定：ID=1111111xxxx）。这样总共有（2048-16）个ID能被使用。
扩展格式的ID有29个bit。基本ID从ID28到ID18，扩展ID由ID17到ID0表示，基本ID和标准格式ID相同，禁止高7bit全都为隐性，（禁止设定：基本ID=1111111xxxx）。这样总共有（2048-16）个ID能被使用。
在任何情况下，总线上不可能有多个设备在同一时刻使用同一个ID传输数据帧。
（3）控制域，占6个bit，指示要传输信息的数据字节数，这个域的结构，对标准和扩展的格式是有差别的。如图18所示
注1：保留位（r0，r1），保留位必须以显性电平传送，然而，在接收侧可以接收显性、隐性集任意组合的电平。
注2：数据长度码（DLC），数据长度码与数据的字节对应关系见表7所示。数据的字节数必须是0-8个字节，但接收方对DLC=9-15的情况并不视为错误。
（4）数据域，对标准的或扩展的格式都是一样的。这个域是传输的数据，可以是0到8个字节，字节数载控制域中指明。数据输出开始于MSB。如图19所示：
（5）CRC域，对标准的或扩展的格式都是一样的。这个域用来检查帧是否有传输错误，它由15bit CRC码和一个bitCRC定界符（delimiter）（separating bit分隔bit）
CRC的产生方法是采用下面的多项式：，CRC的计算范围是SOF、仲裁域、控制域、数据域。在接收侧，会对接收到的数据帧的这些域进行CRC计算，如果计算结果与收到的CRC不一致，则表明存在传输错误。
（6）ACK域，是对一帧已被正常接收的一个确认信号，由2个bit组成，一个是ACK的slot，一个是ACK的定界符（delimiter），如图21所示：
注1：发送单元的ACK域，发送单元以隐性bit发送ACK slot和ACK 的delimiter。
注2：接收单元的ACK域，正确接收到信息的接收单元在接收帧的ACK slot里发送一个显性bit，以通知发送单元其已经正确接收完毕，这又称“sending ACK”或“returning ACK”。
“Returning an ACK”：
所有接收单元只要不是处于bus-off或休眠状态，只有正确接收信息的单元才能发送ACK。发送单元并不发送ACK。如果总线上除了发送单元，没有其它单元能接收信息，则No ACK被返回。为了通讯的建立，除了发送单元外，至少需要有一个单元能够接收信息。如果总线上有2个或更多个单元能接收到信息，如果它们中任意一个正常接收到信息，则会有ACK被返回。
（7）帧结束，指示一帧结束，由7个隐性位组成。如图22
1.3 遥控帧 遥控帧是接收单元请求发送单元发送一个信息，遥控帧有6个域组成。如图23显示的那样，除了没有数据域外其它与数据帧的结构是一样的。
(1) 帧开始（SOF）：这个域表示数据帧的开始。
(2) 竞争域：这个域表示数据的优先级，具有同样ID的数据帧被请求。
(3) 控制域：这个域表示保留位和数据字节数
(4) CRC域：这个域用于检查帧的传输错误。
(5) ACK域：是对帧已经被正常接收的一个证实。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09ff780e8eff09371c51befe5aff63f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1edb53eb61d2db55e41bd01bd16a025/" rel="bookmark">
			论文写作之不二法则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd55b5d5bee0006505b0db0585d63f4/" rel="bookmark">
			netstat 的10个基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Netstat 是一款命令行工具，可用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字。如果你想确认系统上的 Web 服务有没有起来，你可以查看80端口有没有打开。以上功能使 netstat 成为网管和系统管理员的必备利器。在这篇教程中，我会列出几个例子，教大家如何使用 netstat 去查找网络连接信息和系统开启的端口号。
以下的简单介绍来自 netstat 的 man 手册：
netstat - 打印网络连接、路由表、连接的数据统计、伪装连接以及广播域成员。
1. 列出所有连接 第一个要介绍的，是最简单的命令：列出所有当前的连接。使用 -a 选项即可。
$ netstat -a Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 enlightened:domain *:* LISTEN tcp 0 0 localhost:ipp *:* LISTEN tcp 0 0 enlightened.local:54750 li240-5.members.li:http ESTABLISHED tcp 0 0 enlightened.local:49980 del01s07-in-f14.1:https ESTABLISHED tcp6 0 0 ip6-localhost:ipp [::]:* LISTEN udp 0 0 enlightened:domain *:* udp 0 0 *:bootpc *:* udp 0 0 enlightened.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bd55b5d5bee0006505b0db0585d63f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c135adbc6bf33951e6b598dfe03e5774/" rel="bookmark">
			static_cast,dynamic_cast,reinterpret_cast和const_cast的区别详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C-style cast举例：
int i; double d; i = (int) d; 上面的代码就是本来为double类型的d，通过(int)d将其转换成整形值，并将该值赋给整形变量i (注意d本身的值并没有发生改变)。这就是典型的c-style类型转换。 下面是一个简单的程序：
复制代码 代码如下: #include using namespace std; ​ int main(void) { int i; double d = 11.29; i = (int)d; cout &lt; i ; cout &lt; d ; return 0; } 输出结果： 11 11.29 我们发现d值本身并没有发生任何变化。 在简单的情况下，上面这种类型转换可以很好地工作，但在C++中往往还是不够的，为此ANSI-C++新标准定义的四个转换符，即static_cast、dynamic_cast、reinterpret_cast和const_cast。同时在C++环境中，原先的C-Style的类型转换仍旧可以使用。 1) static_cast
用法： static_cast (expression) 说明：该运算符把expression转换为typeid类型，但没有运行时类型检查来确保转换的安全性。 用途：
a) 用于类层次结构中基类和派生类之间指针或者引用的转换。up-casting (把派生类的指针或引用转换成基类的指针或者引用表示)是安全的；down-casting(把基类指针或引用转换成子类的指针或者引用)是不安全的。 b) 用于基本数据类型之间的转换，如把int转换成char，这种转换的安全性也要由开发人员来保证。
c) 可以把空指针转换成目标类型的空指针(null pointer)。
d) 把任何类型的表达式转换成void类型。
注意： static_cast不能转换掉expression的const、volitale或者__unaligned属性。
2)dynamic_cast
用法：dynamic_cast (expression)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c135adbc6bf33951e6b598dfe03e5774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c3cdef082ca84f0df6dd8dec32a9ee1/" rel="bookmark">
			linux shell 用sed命令在文本的行尾或行首添加字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自 http://www.cnblogs.com/aaronwxb/archive/2011/08/19/2145364.html
昨天写一个脚本花了一天的2/3的时间，而且大部分时间都耗在了sed命令上，今天不总结一下都对不起昨天流逝的时间啊~~~
用sed命令在行首或行尾添加字符的命令有以下几种：
假设处理的文本为test.file
在每行的头添加字符，比如"HEAD"，命令如下：
sed 's/^/HEAD&amp;/g' test.file
在每行的行尾添加字符，比如“TAIL”，命令如下：
sed 's/$/&amp;TAIL/g' test.file
运行结果如下图：
几点说明：
1."^"代表行首，"$"代表行尾
2.'s/$/&amp;TAIL/g'中的字符g代表每行出现的字符全部替换，如果想在特定字符处添加，g就有用了，否则只会替换每行第一个，而不继续往后找了
例：
3.如果想导出文件，在命令末尾加"&gt; outfile_name"；如果想在原文件上更改，添加选项"-i"，如
4.也可以把两条命令和在一起，在test.file的每一行的行头和行尾分别添加字符"HEAD"、“TAIL”，命令：sed '/./{s/^/HEAD&amp;/;s/$/&amp;TAIL/}' test.file
以上其实都还OK，昨天花太多时间，主要因为被处理的文件是用mysql从数据库提取的结果导出来的，别人给我之后我就直接处理，太脑残了= -我一直有点怀疑之所以结果不对，有可能是windows和linux换行的问题，可是因为对sed不熟，就一直在搞sed。。。。。。。
众所周知（= -），window和linux的回车换行之云云，如果你知道了，跳过这一段，不知道，读一下呗：
Unix系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows系统里面，每行结尾是“&lt;换行&gt;&lt;回 车&gt;”，即“\n\r”。一个直接后果是，Unix系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在 Unix下打开的话，在每行的结尾可能会多出一个^M符号。
好了，所以我的问题就出在被处理的文件的每行末尾都有^M符号，而这通常是看不出来的。可以用"cat -A test.file"命令查看。因此当我想在行尾添加字符的时候，它总是添加在行首且会覆盖掉原来行首的字符。
要把文件转换一下，有两种方法：
1.命令dos2unix test.file
2.去掉"\r" ，用命令sed -i 's/\r//' test.file
好了，这样处理完，就OK啦！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a6f8d4ceb5ad424f00d1a5c03fc3867/" rel="bookmark">
			dorado 7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用代码
lookupCode lookupName
性别 $${dorado.getDataProvider("sysLookupTypeAction#getValueByCode").getResult('PLATFORM_SEX')}
有效标识 $${dorado.getDataProvider("sysLookupTypeAction#getValueByCode").getResult('PLATFORM_VALID_FLAG')}
储值卡标识 $${dorado.getDataProvider("sysLookupTypeAction#getValueByCode").getResult('IF_TRANSACT')}
储值卡类型 $${dorado.getDataProvider("sysLookupTypeAction#getValueByCode").getResult('CARD_TYPE')}
认识本店途径 $${dorado.getDataProvider("sysLookupTypeAction#getValueByCode").getResult('KNOW_APPROACH')}
1、弹出页面的嵌入路径
${web.contextPath}/avicit/platform6/modules/train/examshopmember/view/ExamShopMemberAdd.d7
${web.contextPath}/avicit/platform6/modules/train/examshopmemberexercise/view/ExamShopMemberExerciseEdit.d7
memberDataUpdateAction memberDataDeleteAction dialogAddOrEdit
2、添加页插入空数据：self.get("#dataSetExamShopMemberExercise").insert();
3、添加页保存方法：view.get("#memberDataUpdateAction").execute(); 执行成功后关闭弹出页，刷新父页面数据：
var ds =view.get("dataSetExamShopMember");
ds.clear();
ds.insert();
parent.refreshAdd();
4、添加页取消方法：
var ds =view.id("dataSetExamShopMember");
ds.clear();
ds.insert();
parent.refreshAdd();
5、编辑按钮的方法：
var dataGrid = view.get("#MainData");
var selections = dataGrid.get("selection"); if (selections.length == 0) {
dorado.MessageBox.alert("请选择记录");
return "false";
}
if (selections.length &gt; 1) {
dorado.MessageBox.alert("只允许选择一条数据记录!");
return "false";
}
var id =selections[0].get("ID");
view.get("#editIframe").set("path","${web.contextPath}/avicit/platform6/modules/train/examshopmember/view/ExamShopMemberEdit.d7?id="+id);
view.get("#dialogEdit").show();
6、编辑页保存的方法：view.get("#memberDataUpdateAction").execute();
执行成功后关闭弹出页，刷新父页面数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a6f8d4ceb5ad424f00d1a5c03fc3867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8318940d757170a22c360f05163b68da/" rel="bookmark">
			数电考试前粗糙复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考试重点：
第二、三、四章（大概）
第一章：
先科普一下各种进制的英文单词，首先从人见人爱的十进制开始，他的英文是Decimal。那么二进制呢，应该是Binary的说～八进制和十六进制分别是Octal（跟Oracle好像啊）和Hexadcimal。进制之间的换算关系应该是这样的：
1.Binary -&gt; Decimal
根据D＝∑ki ＊ N^i ，（其中N为基数（N进制），ki称为第i位的系数，N^i称为第i位的权）可知，143.75这样的十进制数可展开为1*10^2+4*10^1+3*10^0+7*10^-1+5*10^-2
那么当使N ＝ 2时便可得出一个数的二进制表示。在ki中要填入的是被转换的进制的数。那么将二进制数101.11转换为十进制的算法为（101.11）B ＝ （1*10^2+0*10^1+1*10^0+1*10^-1+1*10^-2）D ＝ （5.75）D，在计算是通常使用8421法降低计算时间复杂度。
2.Octal -&gt; Decimal
同样适用上面提到的公式D＝∑ki ＊ N^i 进行转换计算。例如（12.4）O ＝ （1*8^1+2*8^0+4*8^-1）D ＝ （10.5）D 计算是似乎也能用512 64 8 1 法降低计算时间复杂度。
3.Hexadcimal -&gt; Decimal
其实还是用上面那个公式算啦，别忘了这个表格：
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
0 1 2 3 4 5 6 7 8 9 A B C D E F
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8318940d757170a22c360f05163b68da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07cb0ff5e8a0e35fa107bcb3d92c612a/" rel="bookmark">
			数轴上从左到右有n个点、a[0] a[1]……a[n-1]给定一根长度为l绳子、求绳子最多覆盖其中几个点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法描述：
maxCover=1 , coverNum = 0 ,beginPos=0,endPos=1 分别表示最多覆盖点数，当前遍历开始节点和结束点
1 如果a[endPos] – a[beginPos]== l 这个是时候正好覆盖coverNum = endPos–beginPos + 1; 右移动beginPos++;endPos++;
2 如果a[endPos] – a[beginPos]&gt; l 这个时候超过了需要回退coverNum= endPos–beginPos; 向右移动beginPos++;endPos++;
3 如果coverNUm &gt;maxCover 更新maxCover = coverNum
4 如果a[endPos] –a[beginPos] &lt; L ,endPos++;
循环直到endPos &lt;= n – 1
#include&lt;iostream&gt; using namespace std; int maxCoverNum(int *a, int n, int l) { int maxCover = 1; int begin = 0; int end = 1; while ( end &lt; n ) { if (a[end]-a[begin] &gt;= l) { if (a[end]-a[begin] == l) { maxCover = end - begin + 1 &gt; maxCover ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07cb0ff5e8a0e35fa107bcb3d92c612a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e78a27679e6ebc20734ad3e69c513d33/" rel="bookmark">
			apt-get无法找到安装包解决方法--添加源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		When you try to install a package using apt-get, APT searches it’s own database for the package name, if the package is available in the database, then it looks for the repository from where to download the package. It then download the package from that repository and installs it.
If the package name does not exist in APT’s database, it does not have any idea what you are trying to install andyou see the following error message:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e78a27679e6ebc20734ad3e69c513d33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f9c538daae9b33b44a7a8de69e3043/" rel="bookmark">
			面试题目“ABCDE × 4 = EDCBA”新解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ABCDE*4=EDCBA
在面试宝典上面看到的一道题目，也是一道老掉牙的题目了，题目详情：一个五位数字ABCDE*4=EDCBA，这五个数字不重复，请编程求出来.
网上流传的代码都是对5位数ABCDE的所有可能情况作遍历，即从10000 - 99999；我的想法是对EDCBA作遍历，从遍历的范围来说，为原来的1/4，因为EDCBA必须能被4整除才可以，然后遍历的初始位置也发生改变，本来是10000，现在直接变成10000 * 4，范围又减少了一半左右。对于这道程序来说，效果并不明显，我仅仅是提供另一种思路，用逆向的思维来解答问题。对于题目中的要求：每个数字必须不重复，在数学的角度来说，这应该是不会重复的，要加上这个不重复的条件也可以，只是程序会变得繁琐不简洁。对这道题来说，加不加影响不大。
用EDCBA来遍历的代码如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int findNUM(void) { int cnt = 0; int N = 0; //EDCBA int Nswitch = 0; //ABCDE for(cnt = 10000 * 4; cnt &lt;= 99999; cnt += 4)// 初始位置是40000，因为ABCDE最小为10000，那EDCBA最小为40000 { Nswitch = 0; N = cnt; //将EDCBA变换为ABCDE do { Nswitch = Nswitch * 10 + N % 10; N /= 10; }while(N != 0); if((cnt &gt;&gt; 2) == Nswitch) { return cnt; //找到该数并返回 } } return -1;//找不到，返回-1 } int main(void) { int result = findNUM(); switch(result) { case -1: { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f9c538daae9b33b44a7a8de69e3043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c48d7c8e929e6962860a1e4a398196/" rel="bookmark">
			安卓ksoap2获取.net webservice后返回DateSet型的数据的解析方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天闲来没事，一个朋友让我帮忙看看他的项目，大概业务是这样的：
手机客户端调用.net的webservice后返回dataset类型的视频列表信息，解析信息显示在listview中，然后点击某个视频可以下载到手机SD卡上
dateset类型的信息：
anyType{schema=anyType{element=anyType{complexType=anyType{choice=anyType{element=anyType{complexType=anyType{sequence=anyType{element=anyType{}; element=anyType{}; element=anyType{}; }; }; }; }; }; }; }; diffgram=anyType{NewDataSet=anyType{Table=anyType{Course_CfName=格兰仕的秘密01.flv; Course_Updir=webupload/整理课件/2012年5月/格兰仕的秘密\200K\格兰仕的秘密01_200K.flv; cf_id=24267; }; Table=anyType{Course_CfName=格兰仕的秘密02.flv; Course_Updir=webupload/整理课件/2012年5月/格兰仕的秘密\200K\格兰仕的秘密02_200K.flv; cf_id=24268; }; Table=anyType{Course_CfName=格兰仕的秘密03.flv; Course_Updir=webupload/整理课件/2012年5月/格兰仕的秘密\200K\格兰仕的秘密03_200K.flv; cf_id=24269; }; Table=anyType{Course_CfName=格兰仕的秘密04.flv; Course_Updir=webupload/整理课件/2012年5月/格兰仕的秘密\200K\格兰仕的秘密04_200K.flv; cf_id=24270; }; Table=anyType{Course_CfName=格兰仕的秘密05.flv; Course_Updir=webupload/整理课件/2012年5月/格兰仕的秘密\200K\格兰仕的秘密05_200K.flv; cf_id=24271; }; Table=anyType{Course_CfName=走进蒙牛与牛根生面对面_01.flv; Course_Updir=webupload/整理课件/2012年5月/走进蒙牛 与牛根生面对面\200K\走进蒙牛与牛根生面对面_01.flv; cf_id=24301; }; Table=anyType{Course_CfName=走进蒙牛与牛根生面对面_02.flv; Course_Updir=webupload/整理课件/2012年5月/走进蒙牛 与牛根生面对面\200K\走进蒙牛与牛根生面对面_02.flv; cf_id=24302; }; }; }; }相信调用webservice获取服务器信息就不用给大家介绍了吧，一般没有什么难度，只要URL，NAMESPACE，METHOD和需要的参数正确，基本上都可以正常获取到信息，一般我们获取到的都是xml类型的和json类型的，这种类型解析的方法很多，也很普遍，相信网上一查一大堆，但是像我们获取到的这种dataset类型的数据，既不是xml,也不是json，那么该怎么去解析呢，下面就请看代码：
一、封装视频信息的类
film.java
public class Film {/** Course_CfName=格兰仕的秘密01.flv; * Course_Updir=webupload/整理课件/2012年5月/格兰仕的秘密\200K\格兰仕的秘密01_200K.flv; * cf_id=24267; */private String Course_CfName;private String Course_Updir;private String cf_id;public String getCourse_CfName() {return Course_CfName;}public void setCourse_CfName(String courseCfName) {Course_CfName = courseCfName;}public String getCourse_Updir() {return Course_Updir;}public void setCourse_Updir(String courseUpdir) {Course_Updir = courseUpdir;}public String getCf_id() {return cf_id;}public void setCf_id(String cfId) {cf_id = cfId;}} GetVideoInfoService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25c48d7c8e929e6962860a1e4a398196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae760172f2431aba9ef465d671ca1625/" rel="bookmark">
			POJ1002 487-3279
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POJ上的一道题目：企业想拥有令人难忘的电话号码。要一个电话号码让人容易记住，方法之一是号码里面有一个难忘的单词或词组拼写。例如，您可以拨打TUT- GLOP拨打沃特卢大学。有时电话号码只有一部分是单词拼写。当你回到你的酒店，今晚你可以通过拨打310 - GINO吉诺订购比萨饼。另一种方法，设计的电话号码是一个难忘的方式分组数字。你可以通过拨打必胜客" 3个10 "的号码3-10-10-10 来订购比萨.
一个电话号码的标准形式是7个十进制数字用连字符之间的第三和第四位数字（如888-1200 ）.一个电话的小键盘提供字母数字的映射，如下所示：
A，B和C映射到2
D，E和F映射到3
G， H和I映射到4
J，K，和L映射到5
M，N和O映射到6
P，R和S映射到7
T，U，和V映射到8
W，X，和Y映射到9的
没有包括字母Q和Z的映射，连字符不能拨号，可以根据需要添加和删除. TUT- GLOP的标准形式是888-4567, 310 - GINO的标准形式是310-4466 ， 3-10-10-10的标准形式是310-1010 。两个电话号码是等价的，如果它们具有相同的标准形式.（他们拨打同一个号码。 ）你的公司正在编制当地企业的电话号码目录。作为质量控制过程的一部分，你要检查，没有两个（或以上）的企业目录中的有相同的电话号码.
输入输入将包括一个案例。输入的第一行中指定的目录中的电话号码的数目（最多10万）作为单独行上的一个正整数.其余各行列出在目录中的电话号码，在单独一行的每个数字。每个电话号码的十进制数字，大写字母（不包括Q和Z ）和连字符组成的字符串组成. 整整7个数字或字母的字符串中的字符.
产量
生成一行输出为每个电话号码，任何形式多次出现。该行应得到的标准形式的电话号码，后跟一个空格，其次是在电话号码出现在目录的次数。电话号码升字典顺序排列输出线。如果没有重复在输入打印线：
No duplicates.
采样输入
12
4873279
ITS- EASY
888-4567
3-10-10-10
888 - GLOP
TUT- GLOP
967-11-11
310 - GINO
F101010
888-1200
-4-8-7-3-2-7-9 - 487-3279
样本输出
310-1010 2
487-3279 4
888-4567 3
这道题目解法多种多样，难点在于时间复杂度的控制，花了好长时间在这道题目上，下面说说我的经验；
刚开始我想定义一个数据结构来存储，str字符数组用来存储每一个电话号码（去掉了'-'字符）;identy用于存储字符数组的第一个字符，用于排序;icount用来统计每个相同号码的个数，用一个for循环实现起来并不复杂，可是程序一直是TLE(Time Limit Exceeded)，查阅了一些资料，不服气自己的程序就是不能通过这道题，一直在修改修改再修改，后来发现，我从一开始就错了，我错的是我把电话号码当成一个字符数组来处理，还创建了结构体来存储，假设有10万个电话号码，还要排序，那时间复杂度就很高了，而且在循环体里面使用了strcmp,strcpy等库函数，花在这上面的时间，灰常多，继续在这上面修改，也不会有多好的效果的，在论坛上得到了大神的启发，转战用数字才存放电话号码，int类型的足矣.
typedef struct { int identy; char str[9]; int icount; }Phone; 于是，不采用结构体，直接用整型数组，这样不需要通过什么strcmp,strcpy函数来判断大小和赋值，也能直接用数组存储数据来排序，这样一来，时间复杂度将会大大减小。完整代码是： #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae760172f2431aba9ef465d671ca1625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8b55219cbf7b8031eddc68f686c440/" rel="bookmark">
			ajax提交返回boolean类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function validateEnameExsit() {
var ename = $("#ename").val();
if($.trim(ename)=='') {
$("#result").attr('color','#FF0000'); $("#result").html('用户名不能为空');
return false;
}else{
$.ajax({ url : "empManagerAction!validateEname.do",// 后台处理程序 type : "post",// 数据发送方式 dataType : "json",// 接受数据格式 data : "employeeForm.ename="+ename,// 要传递的数据
cache: false,//禁用缓存 // 回传函数
success : function(responsedata) {
if(responsedata=='0'){
$("#result").attr('color','B3E6DF'); $("#result").html('恭喜!该用户名还未被注册!');
return true;
}else if(responsedata=='1'){
$("#result").attr('color','#FF0000');
$("#result").html('对不起!用户名已存在!');
return false;
}
}
});
}
}
解决方案很多，提供以下几个： 1 、在ajax方法外面定义临时遍历，接收boolean值也就是success中的值,这种方式需要同步才能接收到值 因为ajax不会等这个方法运行完了才执行下面的代码的，当然可以用setTimeout延时下 2 、可以把你的值放在$.dada()的缓存中保存；如：$( "div" ).data( "temp" , true);alert($( "div" ).data( "temp" )); 3 、可以设置在属性中保存，然后取到。如果不想要了还可以删掉 $(this).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d8b55219cbf7b8031eddc68f686c440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3fff4f37c84c674938937cdddbef8ac/" rel="bookmark">
			java去掉jsp标签内容的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//去掉内容的标签
public static String removeTag(String count){
try {
int tagCheck=-1;
do {
int a = count.indexOf("&lt;");
int b = count.indexOf("&gt;");
int len = count.length();
String c=null;
c = count.substring(0, a);
if(b == -1)
b = a;
String d = count.substring((b + 1), len);
count = c + d;
tagCheck = count.indexOf("&lt;");
} while (tagCheck != -1);
} catch (Exception e) {
System.out.println("去掉内容标签异常，可能是该内容没有标签！！！");
}
return count;
}
转载于:https://www.cnblogs.com/qgc88/p/3205119.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b3a0e2d61b012352c651de54f9cce5/" rel="bookmark">
			处理一个数是否落在一个数值范围里(a, b]里（区间左右括号符合数学定义）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// // 判断一个浮点数是否落在范围串中 //	范围串符合数学上区间的定义：[a,b]、(a,b)、(-x, 100)..... //	“∞”用“x”表示 // #define PASS_OK	(100) #define PASS_NO	(102) #define ERR_RANGE_STR	(-100) int InRange(char *pBuf, double fVal) { double fMin = 0.0, fMax = 0.0; CString strRange = pBuf; strRange.Replace(" ", "");	//去掉里面的空格 int nPosComma = strRange.Find(","); if (nPosComma == -1) return ERR_RANGE_STR; //取出左值串 CString strLeft = strRange.Mid(1, nPosComma-1); if(strLeft.IsEmpty()) return ERR_RANGE_STR; if (strLeft == "-x"|| strLeft == "x") fMin = -9.9e10; else fMin = atof(strLeft); //取出右值串 CString strRight = strRange.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9b3a0e2d61b012352c651de54f9cce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2cc3c0f46dd7abbd04f88b29da49d6b/" rel="bookmark">
			造成segment fault，产生core dump的可能原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.内存访问越界
a) 由于使用错误的下标，导致数组访问越界
b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符
c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。
2 多线程程序使用了线程不安全的函数。
3 多线程读写的数据未加锁保护。对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump
4 非法指针
a) 使用空指针
b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump.
5 堆栈溢出.不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c3abe3cbfb6029471b118d8c9eabce/" rel="bookmark">
			jquery给input赋值val(val)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jquery给input赋值val(val) val(val)是jquery函数，最容易混淆的是获取input的函数是val()； 区别非常小，一个是带参数，一个是不带参数； &lt;input name="user" class="txtshort" id="user" value="输入手机号码或邮箱" /&gt; $("#user").val(""); 清空ID为user的值； 以下是一段常用的在登录时在文本框内用文字提示用户输入的代码 $(document).ready(function() { $("#user").addClass('phplike_blur'); $("#password").addClass('phplike_focus'); //添加样式，如果无，可以不写 $("#user").focus(function(){ $(this).removeClass('phplike_blur'); if ($("#user").val() == '输入手机号码或邮箱') //如果值为提示信息，获得焦点时，清空提示信息，样式说明在此省略 { $(this).addClass('phplike_focus');$("#user").val(""); } else { $(this).removeClass('phplike_blur'); } }) $("#user").blur(function(){ if ($("#user").val() == '') //失去焦点时，如果文本框内容为空，则显示提示信息 { $("#user").val("输入手机号码或邮箱"); $(this).addClass('phplike_blur'); } }) }) 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/131/">«</a>
	<span class="pagination__item pagination__item--current">132/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/133/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>