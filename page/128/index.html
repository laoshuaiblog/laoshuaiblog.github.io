<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b83821299bd53ab5518b37d227d5d4c5/" rel="bookmark">
			C&#43;&#43; replace() 函数用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要针对c++中常用replace函数用法给出样例程序
[cpp] view plain copy /*用法一： *用str替换指定字符串从起始位置pos开始长度为len的字符 *string&amp; replace (size_t pos, size_t len, const string&amp; str); */ int main() { string line = "this@ is@ a test string!"; line = line.replace(line.find("@"), 1, ""); //从第一个@位置替换第一个@为空 cout &lt;&lt; line &lt;&lt; endl; return 0; } 运行结果： [cpp] view plain copy /*用法二： *用str替换 迭代器起始位置 和 结束位置 的字符 *string&amp; replace (const_iterator i1, const_iterator i2, const string&amp; str); */ int main() { string line = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b83821299bd53ab5518b37d227d5d4c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b257decbd0f93cb227b2e925ca40e3c7/" rel="bookmark">
			JDK环境变量配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JDK环境变量配置 我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;新建 变量名 JAVA_HOME 变量值：C:\Program Files\Java\jdk1.8.0_91(JDK默认安装)
继续建一个变量(若不存在) 变量名：Path 变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin
新建变量（若不存在） 变量名：CLASSPATH 变量值：%JAVA_HOME%\lib
测试 windows+R 输入cmd 回车 输入java -version回车 出现java version等就代表配置环境变量成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f95edc2de0ffe6bd8681bf56c029754/" rel="bookmark">
			记录一下做的几道编程题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 输入一个整数数组，
实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分， 并保证奇数和奇数，偶数和偶数之间的相对位置不变。
public class Test3 {
public static void main(String[] args) {
int[] a = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
reOrderArray(a);
for (int i = 0; i &lt; a.length; i++) {
System.out.print(a[i] + " ");
}
}
private static void reOrderArray(int[] a) {
int[] b = new int[a.length];
int oddBegin = 0;
int oddCount = 0;
for (int i = 0; i &lt; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f95edc2de0ffe6bd8681bf56c029754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b68961cc7bf9e50e31abc9044b455f00/" rel="bookmark">
			JQuery中$.ajax()方法参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例代码：
&lt;script&gt; $(function () { $('#send').click(function () { $.ajax({ type: "GET", url: "test.json", data: { username: $("#username").val(), content: $("#content").val() }, dataType: "json", success: function (data) { $('#resText').empty(); //清空resText里面的所有内容 var html = ''; $.each(data, function (commentIndex, comment) { html += '&lt;div class="comment"&gt;&lt;h6&gt;' + comment['username'] + ':&lt;/h6&gt;&lt;p class="para"' + comment['content'] + '&lt;/p&gt;&lt;/div&gt;'; }); $('#resText').html(html); } }); }); }); &lt;/script&gt; 顺便说一下$.each()函数:
$.each()函数不同于JQuery对象的each()方法，它是一个全局函数，不操作JQuery对象，而是以一个数组或者对象作为第1个参数，以一个回调函数作为第2个参数。回调函数拥有两个参数：第1个为对象的成员或数组的索引，第2个为对应变量或内容。
url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。
type: 要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。
timeout: 要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。
async：要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。
cache：要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false）。设置为false将不会从浏览器缓存中加载请求信息。
data: 要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看processData选项。对象必须为key/value格式，例如{foo1:"bar1",foo2:"bar2"}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:["bar1","bar2"]}转换为&amp;foo=bar1&amp;foo=bar2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b68961cc7bf9e50e31abc9044b455f00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d29afae4d0186dd81a2abe56d1b924/" rel="bookmark">
			SSH学习记录之Spring（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提炼了一些Spring的知识点，面试题中经常会涉及到。
什么是Spring？------开源的控制反转和面向切片的容器框架。
Spring框架的特点------ 1.轻量：Spring是轻量级的
2.控制反转：Spring通过控制反转实现了松散耦合，由对象给出他们的依赖，而不是创建或者查找依赖的 对象们。
3.面向切面的编程AOP:Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
4.容器：Spring包含并管理应用中对象的生命周期和配置。
5.MVC框架：Spring-MVC。
6.事务管理：Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务JTA。
7.异常处理：Spring提供方便的API把具体技术相关的异常。
Spring框架的优势------1.降低组件之间的耦合度，实现各层之间的解耦。 2.可以使用容器提供的众多服务。如： --事务管理服务 --JMS --Spring core核心服务 --持久化服务 3.提供了单例模式支持。
4.提供了AOP技术。
5.提供了众多的辅助类。 6.对主流的应用框架提供了集成支持。
Spring的模块构成------spring核心容器 spring上下文 springAOP springDAO springORM springWeb springMVC
Spring的设计模式------主要实现了两种，单例模式和工厂模式。
Spring依赖注入的实现策略------三种，接口注入，构造注入 ，设值注入。
Spring实例化bean的方式------三种，默认使用类加载器，静态工厂方法实例化，实例工厂方法实例化。
AspectJ的相关知识点------ AspectJ是Spring里AOP的一种实现，可以和JAVA配合使用。
1.Aspect： Aspect 声明类似于 Java 中的类声明，包含着一些 Pointcut 以及相应的 Advice。
2.Joint point（连接点）：表示在程序中明确定义的点，包括方法调用，对类成员的访问以及异常处 理程序块的执行等等，可以嵌套其它 joint point。
3.Pointcut（切入点）：表示一组 joint point，这些 joint point或是通过逻辑关系组合起来，或是通过 通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。
4.Advice 定义了在 pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来 区别是在每个joint point 之前、之后还是代替执行的代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e8a13c2243a6427f5fbe4ad305c894/" rel="bookmark">
			在linux下安装redis报错gcc gcc-c&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用tar -xzvf redis-2.4.5.tar.gz来解压安装包
2.使用make命令来编译Redis 如果出现错误需要查看是否缺少gcc gcc-c++
zmalloc.h:50:31： error： jemalloc/jemalloc.h： No such file or directory
zmalloc.h:55:2： error： #error “Newer version of jemalloc required”
make［1］： *** ［adlist.o］ Error 1
make［1］： Leaving directory `/data0/src/redis-2.6.2/src‘
make： *** ［all］ Error 2
解决办法是：
make MALLOC=libc
3.make install
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a804e8305505b47e31836b4b8ba8d7/" rel="bookmark">
			Linux下开启Hadoop的9000端口方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Hadoop后, 启动Hadoop时需要开启很多端口, 最简单的办法是关闭Linux防火墙. 具体方法如下: 当Linux打开防火墙后，你会发现，从本机登录9000端口是没有问题的，但是如果从另一台pc登录该linux系统后，你会发现提示这样的错误： 不能打开到主机的连接， 在端口 9000: 连接失败 因为linux防火墙默认是关闭9000端口的，如果允许远程登录，可以关掉防火墙，也可以开防火墙开放9000端口，具体如下： 即时生效，重启后失效 开启： service iptables start 关闭： service iptables stop 重启后生效 开启： chkconfig iptables on 关闭： chkconfig iptables off 在开启了防火墙时，做如下设置，开启相关端口 修改/etc/sysconfig/iptables 文件，添加以下内容： -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 9000 -j ACCEPT 查看防火墙 iptables -L
------------------
netstat -nupl (UDP类型的端口) netstat -ntpl (TCP类型的端口) 你可以使用 lsof 命令来查看某一端口是否开放。查看端口可以这样来使用，我就以9000端口为例： lsof -i:9000 如果有显示说明已经开放了，如果没有显示说明没有开放。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee0139d6f5a9c81e1433f956e1ecd9e/" rel="bookmark">
			深入理解java反射机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，java的核心机制 java有两种核心机制:java虚拟机(JavaVirtual Machine)与垃圾收集机制(Garbage collection)：
Java虚拟机：是运行所有Java程序的抽象计算机，是Java语言的运行环境，在其上面运行Java代码编译后的字节码程序，java虚拟机实现了平台无关性。 Java垃圾回收（Garbage Collection）：自动释放不用对象内存空间，在java程序运行过程中自动进行，垃圾收集机制可大大缩短编程时间，保护程序的完整性，是Java语言安全性策略的一个重要部份。 二，java虚拟机及其结构 java垃圾回收不需要程序员手动操作，我们经常需要关注的是java虚拟机，java虚拟机承载着程序从源码到运行的全部工作。 Java虚拟机是可运行Java代码的假想计算机，有自己想象中的硬件，如处理器、堆栈、寄存器等，还具有相应的指令系统，可以执行 Java 的字节码程序。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 对于 JVM 的基本结构，我们可以从下图可以大致了解： 图片来自Java 虚拟机体系结构
三，程序的运行过程 从源文件创建到程序运行，Java程序要经过两大步骤：编译，运行；1、源文件由编译器编译成字节码（ByteCode） 2、字节码由java虚拟机解释运行。
第一步(编译): 创建完源文件之后，程序会被编译器编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用。。编译后的字节码文件格式主要分为两部分：常量池和方法字节码。 第二步（运行）：java类运行的过程大概可分为两个过程：1、类的加载 2、执行。 四，类的加载 类加载过程 java程序经过编译后形成*.class文件。通过类加载器将字节码(*.class)加载入JVM的内存中。JVM将类加载过程分成加载，连接，初始化三个阶段，其中连接阶段又可分为验证，准备，解析三个阶段。 JVM 的类加载是通过 ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：
1）Bootstrap ClassLoader启动类加载器
负责加载$JAVA_HOME中jre/lib/里所有的 class(JDK 代表 JDK 的安装目录，下同)，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的java.*开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器由 C++ 实现，不是 ClassLoader 子类。无法被 Java 程序直接引用的。
2）Extension ClassLoader扩展类加载器
该加载器由sun.misc.Launcher ExtClassLoader实现，负责加载Java平台中扩展功能的一些jar包，包括 JAVA_HOME中jre/lib/.jar或-Djava.ext.dirs指定目录下的 jar 包。即JDK\jre\lib\ext目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器
3）App ClassLoader应用程序类加载器
。该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，负责记载 classpath 中指定的 jar 包及目录中 class，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
启动类加载器：它使用 C++ 实现（这里仅限于 Hotspot，也就是 JDK1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fee0139d6f5a9c81e1433f956e1ecd9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8fbf369f7ec8989c756f3512e3e41a/" rel="bookmark">
			js中return false,return,return true的用法及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先return作为返回关键字，他有以下两种返回方式 1.返回控制与函数结果 语法为：return 表达式; 语句结束函数执行，返回调用函数，而且把表达式的值作为函数的结果
2.返回控制无函数结果 语法为：return;在大多数情况下,为事件处理函数返回false,可以防止默认的事件行为.例如,默认情况下点击一个&lt;A&gt;元素,页面会跳转到该元素href属性指定的页. 例如:&lt;a href="http:www.baidu.com;alert(11);return false;alert(22)"&gt;链接&lt;/a&gt; &lt;!-- 只会执行了alert(11);--&gt; return false 就相当于终止符，return true 就相当于执行符。 在js中return false的作用一般是用来取消默认动作的。比如你单击一个链接除了触发你的"onclick"事件以外还要触发一个默认事件就是执行页面的跳转。所以如果你想取消对象的默认动作就可以return false。也就是说如果你想用JS代码来局部改变一些数据而不引起页面其他部位的变化，那么你就应该在该onclick事件代码的后面加上return false； 例如:&lt;input type="submit" οnclick="submitAction(); return false;" /&gt;
submitAction 方法里面有提交表单的动作。如果不加 return false，在执行完 submitAction 之后，submit 按钮还会继续执行它的默认事件，就会再次提交表单。这可能就是很多错误的根源。
的确，return false的含义不是阻止事件继续向顶层元素传播，而是阻止浏览器对事件的默认处理。 在js中，我们常用return false来阻止提交表单或者继续执行下面的代码，通俗的来说就是阻止执行默认的行为。 例如下面的例子：
众所周知，在表单中加上οnsubmit="return false;"可以阻止表单提交。
&lt;form action="index.jsp" method="post" οnsubmit="submitTest();"&gt; &lt;INPUT value="www"&gt; &lt;input type="submit" value="submit"&gt;&lt;/form&gt;
&lt;SCRIPT LANGUAGE="JavaScript"&gt; function submitTest() { // 一些逻辑判断
return false; }
&lt;/SCRIPT&gt;
以上代码实际情况是表单正常提交，若想它不提交，应该将 &lt;form action="index.jsp" method="post" οnsubmit="submitTest();"&gt;
改为 &lt;form action="index.jsp" method="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8fbf369f7ec8989c756f3512e3e41a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22a3a1b38105615a90f2544355ff78b3/" rel="bookmark">
			项目中添加module作为依赖及删除依赖模块的正确姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加模块作为依赖时，不小心出来个从错误 Error:Dependency UtilsApp:app:unspecified on project myapplication resolves to an APK archive which is not supported as a compilation dependency. File: D:\ProgramFiles(x86)\UtilsApp\app\build\outputs\apk\app-release-unsigned.apk 然后又出来个错误 Error:Library projects cannot set applicationId. applicationId is set to 'com.utils.utilsapp' in default config. 所以总结了一下添加模块作为依赖的正确姿势。 错误出现地点及解决 在我的 UtilsApp 项目中有两个模块，现在我让 myapplication模块作为项目核心模块，app模块作为依赖。即为项目 myapplication添加依赖模块 app： 首先打开 打开Project Structure 选择应用的Dependencies,点击右边加号选择3添加模块依赖 选中作为依赖的模块 下面就表示把app模块加入了依赖，点击ok，gradle会自动sync 此时可以打开build.gradle(module:myapplication),可以看到依赖中自动添加了： compile project ( ':app' ) 此时gradle会sync出一个错误： Error:Dependency UtilsApp:app:unspecified on project myapplication resolves to an APK archive which is not supported as a compilation dependency.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22a3a1b38105615a90f2544355ff78b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69d8cab649361b3fe44cf3ac80858bf/" rel="bookmark">
			统计正整数n的因数个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据因数成对出现的性质进行优化
#include &lt;iostream&gt;
using namespace std;
int cnt(int n)
{
int cnt=0;
for(int i=1; i*i&lt;=n; i++) {
if(n%i==0)
{
if(i*i==n) //相等 因数个数只用加一次 {
cnt++;
}
else
{
cnt+=2; //有一个小于i的因数和大于i的因数
}
}
}
return cnt;
}
int main()
{
int n1;
while(cin&gt;&gt;n1&amp;&amp;n1)
{
cout&lt;&lt;cnt(n1)&lt;&lt;endl;
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8340c6400a31f48c46798312862edee1/" rel="bookmark">
			Adapter中常见遇到的NullPointerException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Adapter原代码 private class MyAdapter extends BaseAdapter { @Override public int getCount() { return icons.length; } @Override public Object getItem(int position) { return icons[position]; } @Override public long getItemId(int position) { return position; } @Override public View getView(int position, View convertView, ViewGroup parent) { convertView= View.inflate(getApplicationContext(), R.layout.item_main, null); //获取组件 ImageView image = (ImageView) findViewById(R.id.iv_grid); TextView text = (TextView) findViewById(R.id.tv_grid); layout.findViewById(R.id.tv_grid); image.setImageResource(icons[position]); text.setText(names[position]); return convertView; } } item_main.xml如下：
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:orientation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8340c6400a31f48c46798312862edee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82610e6c68ba60b6a07e09160582113b/" rel="bookmark">
			CAS单点登录六-Restful API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAS-server提供了restful api供调用，要开启restful服务，首先要找到与之对应的jar包。
cas源代码里cas-server-integration-restlet这个工程就是支持restful的模块，编译出来后得到一个jar包，3.6之前的版本也可以直接下载到这个jar包。
把jar包cas-server-integration-restlet-3.5.2.jar，放到cas-server-webapp的lib目录下，除了这个jar包之外，还需要几个jar包，分别是：
com.noelios.restlet.ext.servlet,jar
com.noelios.restlet.ext.spring-1.1.0.jar
com.noelios.restlet.jar
org.restlet.ext.spring-1.1.10.jar
org.restlet-1.1.10.jar
都一并放到cas-server-webapp的lib目录下。
然后修改server的web.xml,加入一个restful的servlet
&lt;servlet&gt; &lt;servlet-name&gt;restlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.noelios.restlet.ext.spring.RestletFrameworkServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;restlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/v1/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 再找到WEB-INF\spring-configuration下的ticketExpirationPolicies.xml，把timetokill的这个时间改大一点，10秒有点短，手动测试的时候一下ticket就过期了 &lt;util:constant id="SECONDS" static-field="java.util.concurrent.TimeUnit.SECONDS"/&gt; &lt;bean id="serviceTicketExpirationPolicy" class="org.jasig.cas.ticket.support.MultiTimeUseOrTimeoutExpirationPolicy" c:numberOfUses="1" c:timeToKill="${st.timeToKillInSeconds:10}" c:timeUnit-ref="SECONDS"/&gt; server端的配置基本就这么多，然后可以启动server的tomcat
最后就可以用restful的工具来进行测试了，我这里用的是curl
第一步是登录换取tgt
curl -i -k -X POST -d "username=lhc&amp;password=123456&amp;service=http://192.168.56.101/omw/do/main/index" https://192.168.56.101:8443/cas/v1/tickets/ 会得到一个响应： HTTP/1.1 201 Created Date: Tue, 28 Jun 2016 08:03:23 GMT Location: https://192.168.56.101:8443/cas/v1/tickets/TGT-3-MIipUxjOlXiXU1Uuj0vZncjZcfeIJFKhJwegBuHDL03kfCV5ME-cas01.example.org Accept-Ranges: bytes Server: Noelios-Restlet-Engine/1.1.6 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 448 把这个响应里的location字段后面的拷贝一下，这是第二步要访问的rest接口的url curl -i -k -X POST -d "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82610e6c68ba60b6a07e09160582113b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7dd45fdaf7ad69a315b0b434b96db2c/" rel="bookmark">
			【扫盲点】——C语言enum枚举类型、union共用体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、枚举类型 enum： 在实际应用中，有的变量只有几种可能取值。如人的性别只有两种可能取值，星期只有七种可能取值。在 C 语言中对这样取值比较特殊的变量可以定义为枚举类型。
所谓枚举是指将变量的值一一列举出来，变量只限于列举出来的值的范围内取值。 枚举的定义枚举类型定义的一般形式为： enum 枚举名 { 枚举值表 };
eg：enum weekday{sun,mon,tue,wed,thu,fri,sat};
注意： 1.enum 变量类型还可以给其中的常量符号赋值，如果不赋值则会从被赋初值的那个常量开始依次加 1，如果都没有赋值，它们的值从 0 开始依次递增 1。 eg： enum Color { GREEN = 1, RED, BLUE, GREEN_RED = 10, GREEN_BLUE&lt;span style="white-space:pre"&gt;	&lt;/span&gt; }ColorVal； 其中各常量名代表的数值分别为：GREEN = 1 RED = 2 BLUE = 3 GREEN_RED = 10 GREEN_BLUE = 11 2.枚举元素不是变量，而是常数，因此枚举元素又称为枚举常量。因为是常量，所以不能对枚举元素进行赋值。 3.枚举值可以用来作判断。例如： if (day==mon) {…} if (day&gt;mon) {…} 枚举值的比较规则是：按其在说明时的顺序号比较，如果说明时没有人为指定，则第一个枚举元素的值认作 0。例如，mon&gt;sun，sat&gt;fri。 C 语言教程 ?216? 4.一个整数不能直接赋给一个枚举变量，必须强制进行类型转换才能赋值。例如： day=(enum weekday)2； 这个赋值的意思是，将顺序号为 2 的枚举元素赋给 day，相当于workday=tue；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7dd45fdaf7ad69a315b0b434b96db2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba8cba5657d478af0390a0cb6cdc4797/" rel="bookmark">
			删除曾经使用过的USB设备记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，有几种方法可以查看电脑上使用的USB设备记录：
1、无需任何工具软件，手动法：电脑中添加一个环境变量，变量名为“devmgr_show_nonpresent_devices”，值为“1”。
然后在设备管理器中，勾上“查看”菜单中的“显示隐藏设备”。
然后在“磁盘驱动器”、“存储卷”、“通用串行总线控制器”3个栏目下便可看见很多灰色的图标，这些图标就是在此电脑上曾经使用（现在已经拔除，或换USB口位置了）的USB口设备记录。图标清晰的是正在使用的USB设备。
2、使用USBview软件，这是一个中文汉化版的软件，其英文版名字叫USBDeview，是一个免费软件。它的好处是可以查看此电脑上所有的正在使用和曾经使用过但已拔出的USB接口设备，包括键盘鼠标、摄像头、U盘、移动硬盘等。
3、使用USBViewer软件，这个只能查看USB移动存储设备（包含移动硬盘和U盘），像摄像头可能不识别。显示信息详细度稍差，不如USBDeview。
再来说说怎么删除曾经使用过的USB设备记录，有几种办法：
1、手工删除：和查看的方法类似，分三步，缺一不可，顺序也不能反！
① 设置环境变量，变量名为“devmgr_show_nonpresent_devices”，值为“1”。
② 打开设备管理器，勾上“查看”菜单中的“显示隐藏设备”。如果之前已经打开设备管理器，则要关了，重新打开。
③ 清除“磁盘驱动器”、“存储卷”、“通用串行总线控制器”3个栏目下所有的灰色的图标，注意是所有！右键点击灰色图标，然后选择“卸载”。
2、还是USBDeview软件/USBview，在软件中选中前面图标为灰色的栏目，右键点击“卸载”（英文原版最新版肯定有这菜单，中文版早期的好像没这菜单）。
缺点：只能删除“串行总线控制器”栏目中的痕迹，其余两个栏目下痕迹还存在。
3、使用USBViewer软件，右键——&gt;“删除所选痕迹”即可。
缺点：只能删除“磁盘驱动器”、“存储卷”栏目下的痕迹，“串行总线控制器”栏目下痕迹还在。
4、使用USBClear软件，该软件会把所有正在使用和曾经使用的USB设备记录都删除掉，请慎重！因为有些计算机用它删过后会出现USB鼠标无法使用，重启后也会有问题。
接下来，分析一下USB记录的保存位置。
在Windows系统中，所有的USB设备，接入到系统中时，都会在把识别过程记录在C:\windows\setupapi.log文件中，同时把识别后的设备信息保留到注册表中，以便日后再次接入此设备时快速识别。注册表中的HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Enum\USBSTOR等子项下都有记录。
卸载时，注册表中的信息并不会直接删除，所以就有了隐藏的“记录”！
当手动或用软件删除这些记录时，也会在C:\windows\setupapi.log文件中留下操作记录。
最后，总结一下：
快速一点删除所有使用记录的办法是：先用USBDeView删一遍，再用USBViewer删一遍，最后手动删除/粉碎C:\windows\setupapi.log文件。
最安全的办法是：使用手动删除记录办法，挨个删除，记录多时比较麻烦，然后手动删除/粉碎C:\windows\setupapi.log文件。
期待更快速、安全的的办法~~~~~~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b95252cc9f115ac6694ea0e28268dd76/" rel="bookmark">
			【BS】 如何向aspx窗体中添加一个自定义控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】
新闻发布系统开工很长一段时间了，但是直到今天调代码才有点上道的意思。虽然学到的东西都挺简单的，但是也还是总结一下，给同样刚开始学习的朋友一个机会，给水平高的朋友一个信心……在我们做项目的过程中难免的会使用一些别人已经封装好的控件，这样既安全，有高效，今天我们就来说一下如何将一个成熟控件添加到你的WEB窗体中。
【正文】 我要添加的控件是FreeTextBox，以此为例：
1.添加引用
2.在将控件引用至工具箱
3.从工具箱拖入窗体源代码中就可以了
【代码中的基础知识】 这段代码中出出现了 &lt;% @ %&gt; 就顺便把相关的知识总结一下
1.&lt;%@ %&gt; 指令用于指定当页和用户控件编译器处理 ASP.NET Web 窗体页 (.aspx) 和用户控件 (.ascx) 文件时所使用的设置。
2.&lt;%= %&gt;的功能等效于使用 Response.Write 语句
&lt;span style="font-size:24px;"&gt; &lt;label id="label1"&gt;&lt;%=DisplayStr()%&gt;&lt;/label&gt;&lt;br /&gt; &lt;label id="label2" runat="server"&gt;&lt;%=DisplayStr()%&gt;&lt;/label&gt;aspx.cs代码: public string DisplayStr()//注意这里必须要有返回值，否则将会发生运行时错误 { return "bbbb"; }&lt;/span&gt; 3.&lt;%# %&gt;用于数据绑定控件，就是必须在对应控件或父控件调用DataBind方法时，这个指令才会被执行 &lt;span style="font-size:24px;"&gt;&lt;div&gt; Server Control:&lt;asp:TextBox ID="TextBox1" runat="server" Text="&lt;%#text%&gt;"&gt;&lt;/asp:TextBox&gt;&lt;br /&gt;&lt;!--Server Control--&gt; Client Control:&lt;input type="text" id="textbox2" value="&lt;%#text%&gt;" /&gt;&lt;!--Client Control--&gt; &lt;/div&gt;aspx.cs代码如下: protected string text;//注意这里必须申明为public或protected,否则aspx页面(子类)无法访问 protected void Page_Load(object sender, EventArgs e) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b95252cc9f115ac6694ea0e28268dd76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9b9c15b4155f7d0715745ce8de58f6/" rel="bookmark">
			SQL批量删除表、数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DECLARE @table NVARCHAR(30) DECLARE tmpCur CURSOR FOR SELECT name FROM sys.objects WHERE TYPE='U' AND name LIKE N'Z%' OPEN tmpCur FETCH NEXT FROM tmpCur INTO @tableWHILE @@FETCH_STATUS = 0 BEGIN DECLARE @sql VARCHAR(100) SELECT @sql = 'TRUNCATE TABLE ' + @table--删除表中数据EXEC(@sql) FETCH NEXT FROM tmpCur INTO @tableEND CLOSE tmpCur DEALLOCATE tmpCur 注意：LIKE后的Z字母，批量删除以Z开头表中的数据，有约束的无法删除。
如果删除表，即把@sql改为'DROP TABLE '
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f8b546e0378a37170a3805306441b37/" rel="bookmark">
			搜狗用户查询日志(SogouQ)数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.sogou.com/labs/dl/q.html
名称： 用户查询日志(SogouQ) 版本： 2008 介绍： 搜索引擎查询日志库设计为包括约1个月(2008年6月)Sogou搜索引擎部分网页查询需求及用户点击情况的网页查询日志数据集合。为进行中文搜索引擎用户行为分析的研究者提供基准研究语料。 格式说明： 数据格式为 访问时间\t用户ID\t[查询词]\t该URL在返回结果中的排名\t用户点击的顺序号\t用户点击的URL 其中，用户ID是根据用户使用浏览器访问搜索引擎时的Cookie信息自动赋值，即同一次使用浏览器输入的不同查询对应同一个用户ID。
相关任务： 相关性排序 用户兴趣挖掘； 查询扩展； 新词发现 相关资源： 网页搜索结果评价 互联网语料库 链接关系库 SogouRank数据 AOL Query Clickthrough 成果列表： 1.Predicting Epidemic Tendency through Search Behavior Analysis. Danqing Xu, Yiqun Liu, Min Zhang, Liyun Ru, Shaoping Ma. In Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI-11) (Barcelona, Spain). 2.How do users describe their information need: Query recommendation based on snippet click model Yiqun Liu, Junwei Miao, Min Zhang, Shaoping Ma, Liyun Ru.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f8b546e0378a37170a3805306441b37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d009e08697a36c6bddd4ab065d95b9b2/" rel="bookmark">
			数轴上从左到右有n个点a[0],a[1]…,a[n-1]，给定一根长度为L的绳子，求绳子最多能覆盖其中的几个点。要求算法复杂度为o(n)。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数轴上从左到右有n个点a[0],a[1]…,a[n-1]，给定一根长度为L的绳子，求绳子最多能覆盖其中的几个点。要求算法复杂度为o(n)。
http://blog.csdn.net/sunnyyoona/article/details/43635773
#include &lt;iostream&gt;
using namespace std;
int maxCover(int* a, int n, int l)
{
int maxCover = 1;
int begin = 0;
int end = 1;
while(end &lt; n)
{
if(a[end] - a[begin] &gt; l)
{
maxCover = (end - begin) &gt; maxCover?(end - begin):maxCover;
begin++;
}
else
end++;
}
return maxCover;
}
int main()
{
int a[6] = {0,1,3,6,8,10};
cout&lt;&lt;"最大的覆盖个数："&lt;&lt;maxCover(a,6,8)&lt;&lt;endl;
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f7c04640f4dedba030b1a27316340c/" rel="bookmark">
			JVM介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是JVM？ JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。
Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。
JRE/JDK/JVM是什么关系？ JRE(JavaRuntimeEnvironment，Java运行环境)，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。 JDK(Java Development Kit)是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。 JVM(JavaVirtualMachine，Java虚拟机)是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。 3. JVM原理
JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器。它是一种利用软件方法实现的抽象的计算机基于下层的操作系统和硬件平台，可以在上面执行java的字节码程序。 java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。
JVM执行程序的过程 1) 加载.class文件 2) 管理并分配内存 3) 执行垃圾收集 JRE（java运行时环境）由JVM构造的java程序的运行环，也是Java程序运行的环境，但是他同时一个操作系统的一个应用程序一个进程，因此他也有他自己的运行的生命周期，也有自己的代码和数据空间。JVM在整个jdk中处于最底层，负责于操作系统的交互，用来屏蔽操作系统环境，提供一个完整的Java运行环境，因此也就虚拟计算机。操作系统装入JVM是通过jdk中Java.exe来完成，通过下面4步来完成JVM环境：1) 创建JVM装载环境和配置 2) 装载JVM.dll 3) 初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例4) 调用JNIEnv实例装载并处理class类。
JVM的生命周期 1) JVM实例对应了一个独立运行的java程序它是进程级别 a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点 b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以表明自己创建的线程是守护线程 c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出
2) JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的
JVM的体系结构 类装载器（ClassLoader）（用来装载.class文件） 执行引擎（执行字节码，或者执行本地方法） 运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈）JVM运行时数据区 第一块：PC寄存器 PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。
第二块：JVM栈
JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。
第三块：堆（Heap）
它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。 （1） 堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的
（2） Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配
（3） TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f7c04640f4dedba030b1a27316340c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/127/">«</a>
	<span class="pagination__item pagination__item--current">128/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/129/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>