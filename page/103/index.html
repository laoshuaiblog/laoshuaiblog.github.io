<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74dfee5d6a168c39958d8fbe7ecbb657/" rel="bookmark">
			JavaScript  启用严格模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"use strict"是JavaScript中一个非常好的特性，而且非常容易使用。
"use strict"作用 - 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
- 消除代码运行的一些不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的Javascript做好铺垫。
使用方法
// file.js "use strict" function test(){} 这样的file.js都会应用上"use strict"模式。
如果你仅想在一个函数中使用，如下代码仅仅在test中起作用
// file.js function test(){ "use strict"; function temp(){} } 严格模式的作用 1、检查对象中的重复键
es6支持重复键
let value = { a : 0, b: 1, a : 1 } 这段代码会抛出一个错误因为 a 出现了两次。这比你用眼睛去找错误要快多了。
2、未声明变量
plane = 5; 3、重复的参数
function test(data, data){ } 注意data出现了两次，因此会抛出一个错误。
4、限制函数中的arguments
function test(data){ arguments[0] = 'aaa'; console.log(data); } run('bbb'); //'aaa'; 现在你可以使用"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74dfee5d6a168c39958d8fbe7ecbb657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84fdd58b2f6f9cf49bdf7ceb5e51d6fc/" rel="bookmark">
			线性表浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性表浅谈 线性表线性表的概念储存数据的特点线性表的分类顺序存储结构链式存储结构 元素的前驱与后继前驱后继 线性表 线性表的概念 线性表，全名为线性储存结构。储存方式可以理解为“把所有数据用一根线串起来，再储存到物理空间中”。
储存数据的特点 具有“一对一”逻辑关系。要求数据的数据类型必须一致。 线性表的分类 线性表存储数据可分为顺序存储结构和链式存储结构
顺序存储结构 将数据依次连续的存入一整块物理空间之中（简称顺序表），如下图所示：
链式存储结构 数据分散的存储在物理空间中，通过一根线保存着他们之间的逻辑关系（简称链表），如下图所示：
元素的前驱与后继 数据结构中，每个数据个体被称为“数据元素”（简称“元素”），每个元素都有前驱和后驱。
前驱 某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素统称为“前驱元素”。 后继 某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素统称为“后继元素”。 例如下图中数据
对于3，2是它的直接前驱，4是它的直接后继；1和2则是它的前驱元素，4和5则是它的后继元素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001a352e0c780718646424929750fef6/" rel="bookmark">
			生成Git SSH公钥和私钥（ppk）文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 SSH跟HTTPS一样，是一种协议。该协议可以有效防止数据传输过程中的信息泄露问题，相比HTTPS协议更安全。
1.SSH公钥
指公用的，所以部署在服务端。SSH公钥又包括：SSH账户公钥 和 SSH项目公钥。
SSH账户公钥：拥有账户下所有项目仓库的读写权限。
SSH项目公钥：拥有该项目仓库的只读权限。
2.SSH私钥
指私用的，所以部署在客户端。对用户创建/参与的项目仓库均能使用。
二、生成SSH密钥 1、 SSH公钥
打开命令行终端（Git CMD (Deprecated)），输入如下其中任意一种命令：
ssh-keygen -t rsa -C "userName" 或者 ssh-keygen -m PEM -t rsa -b 4096 -C "userName" 连续点击 Enter 键即可。
说明："userName"指我们克隆或制品库的登录用户名。
执行完成后将生成如下两个文件：
id_rsa：用于后期生成SSH私钥的ppk文件。
id_rsa.pub：记为生成好的公钥文件，用记事本打开可以查看。
2.SSH私钥
我使用的是Git Extensions软件的PuTTY工具，如下图：
好像也可以单独下载PuTTY工具。
然后按如下图依次操作：
至此，私钥的创建就完成了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfda2444a4b9c7b9ae9a220b0d7c441/" rel="bookmark">
			二进制数表示法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二进制数表示法 二进制数是数字电路中应用最广泛的一种数值表示方法，在逻辑代数中也经常使用。
1、十进制数
在这种计数进位制中，每一位用0~9十个数字来表示，所以计数基数是十。超过9的数则需用多位数表示，其中低位数和相邻高位数之间的关系是“逢十进一”，故称为十进制。
例如：(143.75)10=1×102+4×10+3×10°+7×10-1+5×10*-2
所以任意一个正的十进制数D都可以展开成
式中ki是第i位的系数，它可能是0~9十个数字中的任何一个，10i叫做第i位的位权，ki10i是第i位的数值。若整数部分的位数是n,小数部分的位数是m,则i包含从n-1到0的所有正整数和从-1到-m的所有负整数。
若以N代替式（1.0.1)中的10,就可以得到任意进制（N进制）数展开式的普遍形式
式中i的取值与式（1.0.1)中的规定相同。
2.二进制数
在数字电路中应用最广的是二进制数。在二进制数中，每一位仅有0和1两个可能的数字，所以计数的基数N=2。低位和相邻的高位之间的进位关系是"逢二进一"。
3.二进制数的缩写形式——八进制数和十六进制数
4.几种常用进制数之间的转换
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a97761a324283b5aff54a6bef45700/" rel="bookmark">
			4.4 算 符 优 先 分 析 法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.4 算 符 优 先 分 析 法 4.4.1 方法概述
所谓算符优先分析法就是依照算术表达式的四则运算过程而设计的一种语法分析方法。
这种分析方法首先要规定运算符之间(确切地说是终结符之间)的优先关系和结合性质,然后借助这种关系,比较相邻运算符的优先级来确定句型的可归约串并进行归约。
下面,以表达式的文法为例,说明采用这种分析法分析符号串 id + id * id 的分析过程。
例如,文法 G [ E ]为
E → E + E | E * E | ( E ) | id 这个文法是一个二义性文法,因而对句子 id + id * id 有两种不同的规范归约,也就是在归约过程中句型的句柄不唯一。
句子 id + id * id 的两种不同的规范归约过程如下:
第一个规范归约过程 第二个规范归约过程 (1 ) id + id * id	(1 ) id + id * id (2 ) E + id * id	(2 ) E + id * id (3 ) E + E * id	(3 ) E + E * id (4 ) E + E * E	(4 ) E * id (5 ) E + E	(5 ) E * E (6 ) E	(6 ) E 分析上述归约过程,句型 E + E * id 在第一个规范归约中 id 是它的句柄;而在第二个规范归约中 E + E 是它的句柄。此现象是由于没有定义运算符 + 和 * 的优先关系而引起的。在第一个规范归约中是假定 * 优先于 + ,所以不能立即把 E + E 归约为 E ;而在第二个规范归约中是假定 + 优先于 * ,因此必须先把 E + E 归约为 E 。可见上述归约过程中起决定作用的是相邻两个终结符号之间的优先关系。于是算符优先分析法的关键在于用合适的方法去定义任何两个可能相邻出现的终结符号 a 和 b 之间的优先关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a97761a324283b5aff54a6bef45700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9fa05bc24da4d0df804010d5e4bf941/" rel="bookmark">
			IDEA里 java.lang.ClassNotFoundException: com.mysql.jdbc.Driver 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用IDEA写Java MySQL程序时遇到的问题。
在我使用 Class.forName(Driver); 语句后系统报错：
java.lang.ClassNotFoundException: com.mysql.jdbc.Driver
原因：
网上查阅资料后发现是没有导入mysql-connector-java-XXX jar包（我导入过，但导入的是zip文件，文件实际要的是jar文件，忘了解压）。
解压后的文件目录结构：
特别的：mysql jar 1.6版本以上要使用 com.mysql.cj.jdbc.Driver 语句。
如果使用com.mysql.jdbc.Driver语句，系统会提示：
Loading class com.mysql.jdbc.Driver'. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’.
参考的博客如下，里面还有IDEA怎么添加jar包的方法（谢谢大佬）：
https://blog.csdn.net/qq_34589867/article/details/95338991
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a7c49de303166828a34b337994d318/" rel="bookmark">
			这一刻，我感觉一定要给。。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc4d67e0f645f5a4e857f88a5b59fad8/" rel="bookmark">
			I2C、UART、SPI详解及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通讯 1. 通讯的概念
我们把计算机与外界的信息交换称之为通信。
2. 通讯方式分类
基本的通信方式有两种：并行通讯和串行通讯。
并行通信：所传送数据的各个位是同时发送或接收。速度快，占用引脚资源多
串行通信：所传送数据的各位按顺序一位一位地发送或接收。占用引脚资源少，速度相 对较慢
3. 串行通讯种类
串行通讯的种类有：异步通讯和同步通讯
1） 异步通讯：不带时钟同步信号，不是使用同一个时钟源。如UART、单总线
2） 异步通讯数据帧格式：一个起始位(低电平“0”)表示字符的开始；然后是 5～8 位数据 (D0-D7)，规定低位在前，高位在后；其 后是奇偶校验位；最后是停止位(高电平“1”)， 用以表示字符的结束。
3） 同步通讯：带时钟同步信号传输，通讯收发双方是受同一个时钟源控制。如IIC、SPI
4） 同步通讯数据帧格式：同步字符表示数据传输的开始(一般约定为1～2个字符)+数据流。
4. 串行通讯的数据传输速度
串口传输的速率我们称为比特率也叫波特率，波特率是指一秒钟传输的位数。异步通信的数据传送速率一般为 50b/s～ 100kb/s，单片机常用的波特率是：115200，9600。
5. 串行通讯的方式，按照数据传送方向，分为：
1） 单工制式：数据在甲机和乙机之间只允许单方向传送。两机之间只需 1 条数据线。
2） 半双工制式：在半双工制式下，数据在甲机和乙机之间允许双方向传送，但它们之间只有一个通信回路，接收和发送不能同时进行，只能分时发送和接收，因而两机之间只需1 条数据线。
3） 全双工制式：在全双工制式下，甲、乙两机之间数据的发送和接收可以同时进行，称为“全双工传送”。全双工形式的串行通信必须使用 2 条数据线。
二、UART 1、基本协议
1）空闲位：当总线处于空闲状态时信号线的状态为‘1’，即高电平
2）起始位：开始进行数据传输时发送方要先发出一个低电平’0’来表示传输字符的开始。因为空闲位一直是高电平所以开始第一次通讯时先发送一个明显区别于空闲状态的信号即为低电平。
3）数据位：起始位之后就是要传输的数据，数据可以是5，6，7，8，9位，构成一个字符，一般都是8位。先发送最低位最后发送最高位。
4）奇偶校验位：数据位传送完成后，要进行奇偶校验，校验位其实是调整个数，串口校验分几种方式：
无校验（no parity）奇校验（odd parity）：如果数据位中’1’的数目是偶数，则校验位为’1’，如果’1’的数目是奇数，校验位为’0’。偶校验（even parity）：如果数据为中’1’的数目是偶数，则校验位为’0’，如果为奇数，校验位为’1’。mark parity：校验位始终为1space parity：校验位始终为0 5）停止位：数据结束标志，可以是1位，1.5位，2位的高电平。
2、数据帧格式：
一个起始位(低电平“0”)表示字符的开始；然后是 5～8 位数据 (D0-D7)，规定低位在前，高位在后；其后是奇偶校验位；最后是停止位(高电平“1”)，用以表示字符的结束。
3、需要定义的参数：
数据位（8位或者9位）奇偶校验位（第9位）停止位（1,1.5,2位）波特率设置 三、IIC 1. IIC 通讯概述
IIC 是飞利浦公司研发的两线式串行总线，分别为：串行数据 SDA（Serial Data）、串行时钟 SCL（Serial Clock）。总线数据传输速率在标准模式下可达 100kbit/s，快速模式下可达400kbit/s，高速模式下可达 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc4d67e0f645f5a4e857f88a5b59fad8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fcd040c8d12c982857efbdb492f1633/" rel="bookmark">
			边沿检测--两种verilog代码写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.将接收信号，延迟一个clk，然后将接收信号与延迟信号进行操作得到边沿检测结果。
上升沿检测：
always@(posedge clk)
rx1 &lt;= rx;
assign pos = rx &amp;&amp;~ rx1;
2.设一个两比特寄存器，将接收数据一次存入寄存器，判断第0比特为1，第1比特为0，则检测到下降沿。
reg [1:0] neg_r = 0;
always @(posedge clk)
if(rst) neg_r &lt;= 2’b0;
else neg_r &lt;= {neg_r[0],rx};
assign neg_flag =(neg_r == 2’b0) ? 1’b1 : 1’b0;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab2ff3698492bfe4a4e686e617354c73/" rel="bookmark">
			Clickhouse 的group_concat 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的group_concat 函数经常实用，功能蛮强大的。
MySQL创建表： create table kpi(emp_no varchar(8),performance varchar(32),month varchar(32)); clickhouse 创建表： create table kpi(emp_no varchar(8),performance varchar(32),month varchar(32)) engine=Memory; 分别在MySQL和Clickhouse中插入数据： insert into kpi values (10,'A','2020-01'),(10,'A','2020-02'),(10,'C','2020-03'),(10,'B','2020-04'),(10,'A','2020-05'),(10,'A','2020-06'); insert into kpi values (20,'A','2020-01'),(20,'B','2020-02'),(20,'C','2020-03'),(20,'C','2020-04'),(20,'A','2020-05'),(20,'D','2020-06'); insert into kpi values (30,'C','2020-03'),(30,'C','2020-04'),(30,'B','2020-05'),(30,'B','2020-06'); 数据查询如下：
MySQL的group_concat 功能展示：
mysql&gt; select emp_no,group_concat(performance order by month separator '-') kpi_list,group_concat(distinct performance order by month separator '-') kpi_uniq,group_concat(distinct performance order by month desc separator '-') kpi_uniq_desc from kpi group by emp_no; +--------+-------------+----------+---------------+ | emp_no | kpi_list | kpi_uniq | kpi_uniq_desc | +--------+-------------+----------+---------------+ | 10 | A-A-C-B-A-A | A-C-B | B-C-A | | 20 | A-B-C-C-A-D | A-B-C-D | D-C-B-A | | 30 | C-C-B-B | C-B | B-C | +--------+-------------+----------+---------------+ 3 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab2ff3698492bfe4a4e686e617354c73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fecbef34b164cf0b5d3a06d621759e35/" rel="bookmark">
			个人觉得好用的油猴脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub镜像加速访问、克隆和下载 镜像访问GitHub、加速克隆和下载；适配Github新UI；增加新克隆站点；前往项目Github仓库查看免费搭建Github镜像站点方法
searchEngineJump 搜索引擎快捷跳转 方便的在各个搜索引擎之间跳转,增加可视化设置菜单,能更友好的自定义设置,修复百度搜索样式丢失的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb18a0737fe473a86a54b69845fffaa/" rel="bookmark">
			1.2 Android studio安装与环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在很长的一段时间里Google将eclipse作为Android开发的综合性IDE，但是已是明日黄花，现在我们用更便捷的开发工具Android Studio。
我们以最新的Android Studio为例，详细说明如何配置环境，另外Android应用开发所需的JDK配置此处不做讲解,如需了解请查看 Android Studio环境配置-配置JDK。
Android Studio 环境配置 下载Android Studio。安装配置 下载Android Studio。 浏览器进入官网：https://developer.android.google.cn/studio/
直接点击下载最新的版本（此处为Android studio 4.0.1）。
安装 下载完成之后直接双击运行进行安装。
点击Next进入下一步：
勾选Android Virtual Device ,点击Next：
更改安装路径以d:\Program Files\Android\Android Studio 为例，点击Next：
此处直接默认选择，点击Next：
正在安装，等待进度条100%后点击Next:
勾选Start Android Studio，点击Finish。会自动启动Android Studio
配置 直接默认选择 Do not import settings，点击OK：
此处可能会出现数据分享弹窗，勾选Don’t send :
由于国内网络限制，无法访问Android SDK add-on list，此处不用管，先点击Cancel：
进入欢迎界面，直接点击Next：
此处我们选择Costom来自定义安装，点击Next：
此处按照默认，点击Next：
此选择主题，根据个人喜好选择，比如我选择Darcula点击Next：
勾选Android Virtual Device，并修改Android SDK Location，以D:\Android\Sdk为例，点击Next：
此处进入模拟器设置，我们按照默认设置，点击Next：
进入确认界面，点击Next：
进入安装进程，与网络有关，耗时较久，泡一杯咖啡耐心等待：
安装结束点击Finish。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad6788d230a3f6dfb6772b06ea363df/" rel="bookmark">
			C语言中&amp;&amp;和||的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&amp;&amp; 左右两边表达式同时为真才为真，||左右两边表达式一个为真就为真
#include&lt;stdio.h&gt; int main(int argc,char*argv[]){ int a=0; int b=10; if(a==0 &amp;&amp; b==10){ printf("这是&amp;&amp;的用法，两个真为真\n"); } return 0; } 运行结果如图
#include&lt;stdio.h&gt; int main(int argc,char*argv[]){ int a=0; int b=10; if(a==0 || b==20){ printf("这是||的用法，一个为真即为真\n"); } return 0; } 左道倾天
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ea836833db5e3c07f91c4816544eda/" rel="bookmark">
			Java 线程 基础知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程基础 很不严谨的说，线程是什么？线程就是为了让很多个东西并发执行，大大的提高程序执行的效率啊
三个非常重要的概念：
程序：一组写好了的静态代码块（就我们写的那些代码玩意）进程：正在进行着的程序，即静态的代码执行起来了线程：是进程的小单元，或者说多个线程构成一个进程（线程的出现是因为进程满足不了人们的需求，于是进程被细化了） 线程的转换（五个较为简单的转换）可以通过这个图了解一下：
在Java中，
线程有三类：
主线程：系统线程，如Java中的Java虚拟机（主线程是最先执行的）用户线程：Java中main函数执行的那些玩意守护线程（精灵）：比如Java中的GC（垃圾回收器，他是为主线程服务的，当系统启动后，GC就随之产生了；Java虚拟机断掉了，GC也就不干活了） 线程是操作系统层次的（又或者说是cpu层次的，进程怎么执行的，顺序是啥。。。这些都是靠cpu分配的）
不过线程怎么去用，Java的JDK已经给我们写好了
实现线程的过程（有两个方法）：
自己描述一个类实现线程的两个前提条件（继承Thread是最方便的，但是Java是单继承的，很可能会和其他的继承冲突；所以还可以通过实现Runnable接口，不过它要额外的通过写一个Thread类来执行start()方法）： 方法一：继承一个父类Thread方法二：实现一个接口Runnable 我们都必须重写run()方法，
因为这个方法来源于cpu，是操作系统给JDK提供的接口，JDK将它包装成run()，其实我们执行的线程就是写在run()方法中的代码执行起来了new一个线程对象（我们是无法调用run()的，它只有cpu才可以调用，cpu分配时间碎片才能开始执行）
我们只能调用start()方法（这个方法继承自Thread），它会使这个线程除了cpu资源的其它资源都得到满足，让它进入就绪状态，在就绪队列中等待着cpu执行它 （补充：为什么要这么麻烦呢？为什么不直接使用Thread类或者Runnable接口，直接在里面写线程的代码，但是run()方法是不允许有参数的，我们一般要执行的线程都要传参数，所以只能通过继承和实现来解决参数传递的问题）
【一个例子】实现线程的两种方式
继承一个父类 Thread，可以看到调用线程时写法较为简单 public class Running extends Thread { String name; public Running(String name){ this.name = name; } @Override public void run() { for(int i = 1; i &lt;= 10; i++){ System.out.println(name + "跑到了" + i + "米"); } } public static void main(String[] args) { Running Lux = new Running("Lux"); Running Ahri = new Running("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05ea836833db5e3c07f91c4816544eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c6469c2b26da2cbbfb110728e0d39d4/" rel="bookmark">
			vue中key的作用及其原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度
key具有唯一性
vue中循环需加 :key=“唯一标识” ，唯一标识可以使item里面id index 等，因为vue组件高度复用增加key可以标识组件的唯一性，为了更好地区别各个组件key的作用主要是为了高效的更新虚拟DOM
原理： key的作用主要是高效的更新虚拟Dom, 其原理是vue 在patch中的patchVode下的updateChildren 会处理新老子节点 可以通过 key精准判断俩个节点是否是同一个，如果没有加key就会强应的更新，从而会有频繁的更新过程，性能会很差，加了key还会可以使整个patch 过程更加高效，减少dom 操作，提高性能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17fcbbb5eeed7a9493f722b4ce28dc0/" rel="bookmark">
			java进阶之：AOP切入点和切面的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AOP 基本概念 AOP = Aspect Oriented Programming面向切面编程，通过预编译方式和运行期【动态代理】实现【在不修改源代码】的情况下给程序动态统一添加功能的一种技术，主要用于【日志记录】、【性能统计】、【安全控制】、【事务处理】、【异常处理】等等。
编程思想 OOP关注将需求功能划分为不同的并且相对独立、封装良好的类，并让它们有属于自己的行为，依靠继承和多态等来定义彼此的关系；而
AOP则希望能够将从各个不相关的类中【分离出通用需求功能】，使很多类共享一个行为（方法）；这个行为（方法）一旦变化，不必修改很多类，只需修改这个行为（方法）即可。
一些必要术语 &amp;&amp; Aspect 切面：可以看做一个类，其中包含【pointCut切点】 和【Advice暂且叫消息通知】
&amp;&amp; Joint point 连接点：简单理解为类中的全部方法
&amp;&amp; Cut point 切点：简单理解为需要被加强的方法（需要被代理的方法）
&amp;&amp; Advice 消息通知：加强的行为，可以发生在方法执行前、正常执行后、执行异常【相当于catch中】、最终一定执行的位置【相当于finally中】
——基于注解的spring AOP使用 resources中的xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="aop"&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;/beans&gt; 或者使用@EnableAspectJAutoProxy注解配置类，可代替以上aop:aspectj-autoproxy&lt;/aop:aspectj-autoproxy&gt; 项目配置的pom.xml依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.49&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.1_3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 切面类（就是动态代理可以提供加强方法的类） package aop.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c17fcbbb5eeed7a9493f722b4ce28dc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb918940cc559097836fbe465a646a4/" rel="bookmark">
			ubuntu20.04 编译安装 grpc-c&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方demo
https://grpc.io/docs/languages/cpp/quickstart/
安装步骤
clone grpc $ git clone https:#github.com/grpc/grpc.git $ cd grpc $ git submodule update --init *********************************************************** #子模块配置文件 grpc/.gitmodules ********************************************************** 编译安装cmake,_如版本够高可跳过 #编译cmake 版本需3.13及以上版本，在此使用的是 cmake3.17 #openssl版本太低可能编译不过，需更新，在此使用的是 openssl-3.0 $ cd cmake-3.18.0-rc2 $ ./bootstrap $ make $ sudo make install #查看版本 $ cmake --version #cmake version 3.17.3 编译安装grpc #安装以下组件 $ sudo apt-get install build-essential autoconf libtool pkg-config #如果你是grpc开发者还需安装以下组件 $ sudo apt-get install libgflags-dev clang-5.0 libc++-dev #编译安装grpc库 $ mkdir -p cmake/build $ pushd cmake/build #库的安装路径 $ export MY_INSTALL_DIR=$HOME/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb918940cc559097836fbe465a646a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f8a3e6f89df281361a0fdcd7bdd93a8/" rel="bookmark">
			JAVA学习之spring事物控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring中配置事物先：
&lt;! -- 配置事物管理器 -- &gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;! -- 加载数据源 -- &gt; &lt;/bean&gt; &lt;! -- 配置事物模板，可以理解为对象 -- &gt; &lt;bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate"&gt; &lt;property name="transactionManager" ref="transactionManager" /&gt; &lt;! -- 加载事物管理器 -- &gt; &lt;/bean&gt; 注入事物模板对象：
/** * 事务模版对象 */ @Autowired protected TransactionTemplate transactionTemplate; 使用实例： this.getTransactionTemplate().execute(new TransactionCallback&lt;Object&gt;() { // 启动事物 @Override public TradeOrderIssuedResponse doInTransaction(TransactionStatus status) { // 事物原子方法，此方法中的所有代码为一个事物，统一控制处理 // 事物回滚方法 status.setRollbackOnly(); } }); 基于注解的事物管理：
&lt;!-- spring中开启注解事物管理的支持 声明式事务管理 配置事物的注解方式注入--&gt; &lt;tx:annotation-driven transaction-manager="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f8a3e6f89df281361a0fdcd7bdd93a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c92516ae1ebf6386d119a479ec668a35/" rel="bookmark">
			JAVA开发之SVN服务器搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装svnservice 直接命令安装 yum -y install subversion
2、查看安装地址 rpm -ql subversion
3、在/var目录下创建svn目录，在/var/svn目录下创建svnrepos目录，/var/svn/svnrepos 此目录为版本库目录
4、创建svn版本库 在版本库目录/var/svn/svnrepos下执行命令svnadmin create /var/svn/svnrepos/xxxx（xxxx为你预期的版本库名称，可自定义）
5、修改配置，配置文件位于/var/svn/svnrepos/xxxx/conf目录下，各配置文件作用如下：
authz：负责账号权限的管理，控制账号是否读写权限
passwd：负责账号和密码的用户名单管理
svnserve.conf：svn服务器配置文件
首先，修改authz配置文件，在该文件末尾加入如下配置，给账号赋权限：
[]
账号1 = rw
账号2 = rw
注意：rw表示赋予此账号可读写的权限，请注意[]中的斜杠，一定是反斜杠，有些教程说，需添加版本库名称在括号内，我直接建议就这写，这样写允许访问的权限更大，避免一些错误
权限配置详解：
[groups] # harry_and_sally = harry,sally # harry_sally_and_joe = harry,sally,&amp;joe # [/foo/bar] # harry = rw # &amp;joe = r # * = # [repository:/baz/fuz] # @harry_and_sally = rw # * = r [/] admin = rw [renyf:/product/dev] renyf24249 = rw 上方代码块中的[group]表示用户组，可以将下方的用户加进去，不必一个一个加了，[/]表示svn版本库的本目录下的权限，admin = rw 在[/]下表示admin账户拥有svn版本库所有的读写权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c92516ae1ebf6386d119a479ec668a35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d647b76c341c2c127ea32612ca8a7d6/" rel="bookmark">
			java学习之spring集成Dubbo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关于Dubbo的个人理解
其实就是给分布式的系统的各个系统之间提供了一个远程服务调用方案（类似于HttpClient，没有搞清楚他们的区别在哪里，可能是因为HttpClient需要暴露出去url才可以实现数据共享），即A系统需要请求B系统的某个业务，那么我们原始的做法就是使用HttpClient模拟客户端去请求，接收数据，完成业务，而现在，使用dubbo的话，其实就是B系统已经把这部分业务的接口暴露在了消息中间件zookeeper上，而A接口如果要使用，直接通过zookeeper转发到B应用，这样就实现了数据共享，业务联调。其中在dubbo中，我们定义A系统为消费者，B系统为服务者 2、安装zookeeper（注册中心）
下载地址http://apache.fayea.com/zookeeper/stable/
下载完成之后，解压，然后进入解压目录，将conf/zoo_sample.cfg重命名为zoo.cfg
修改次配置文件：
# The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes. dataDir=D:\\zookeeper\\data dataLogDir=D:\\zookeeper\\log # the port at which the clients will connect clientPort=2181 # the maximum number of client connections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d647b76c341c2c127ea32612ca8a7d6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/102/">«</a>
	<span class="pagination__item pagination__item--current">103/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/104/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>