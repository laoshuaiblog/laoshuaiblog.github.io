<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ba08d57a07f63d17fcbc77e684e8af/" rel="bookmark">
			看Vue文档总结之路（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue实例对象的各种属性和方法（以下的所有链接均为转载） 实例对象属性：1、vm.$data：（获取Vue实例的数据对象）2、vm.$props：（获取Vue实例接受过来的props对象）3、vm.$el：（获取Vue实例的挂载DOM元素）4、vm.$options：（获取Vue实例的所有配置项）详细用法 5、vm.$parent：（获取该组件的父级组件）6、vm.$root：（获取当前组件树的根组件）7、vm.$children：（获取当前组件的子组件集）8、vm. $ slots、vm.$scopedSlots：（组件插槽的渲染）详细解释9、vm.$refs：（获取注册 ref 属性的组件）详细解释 10、vm.$isServer：（当前的Vue实例是否运行在服务端）11、vm.$attrs：（将父组件的属性（除去在props中传入的属性）传递给子组件）【只读】详细解释 12、vm.$listeners：（该组件的所有监听器）【只读，自己不会~】 实例对象的方法（数据）：1、vm.$watch( )（Vue实例里面的监听器，具体看 Vue的选项）2、vm.$set( )（Vue实例数据的修改，具体看 Vue的选项）3、vm.$delete( )（Vue实例数据的删除，具体看 Vue的选项） 实例对象的方法：（事件）：1、vm.$on( event, callback )（实例绑定事件）2、vm.$once( event, callback )（实例绑定事件，只调用一次）3、vm.$off( [event, callback] )（删除自定义事件监听）4、vm.$emit( eventName, […args] )（触发当前实例上的事件） 实例对象的方法：（生命周期）1、vm.$mount( [elementOrSelector] )：（把实例挂载在DOM元素上）【在组件配置上没有el的情况下】2、vm.$forceUpdate()：（重新渲染组件）3、vm.$nextTick( [callback] )：（数据更新后执行回调）4、vm.$destroy()：（销毁实例对象） 实例对象属性： 1、vm.$data：（获取Vue实例的数据对象） 2、vm.$props：（获取Vue实例接受过来的props对象） 3、vm.$el：（获取Vue实例的挂载DOM元素） 4、vm.$options：（获取Vue实例的所有配置项） 详细用法 5、vm.$parent：（获取该组件的父级组件） 6、vm.$root：（获取当前组件树的根组件） 7、vm.$children：（获取当前组件的子组件集） 注意点： $children 并不保证顺序，也不是响应式的。
8、vm. $ slots、vm.$scopedSlots：（组件插槽的渲染） 详细解释 9、vm.$refs：（获取注册 ref 属性的组件） 详细解释 10、vm.$isServer：（当前的Vue实例是否运行在服务端） 11、vm.$attrs：（将父组件的属性（除去在props中传入的属性）传递给子组件）【只读】 详细解释 12、vm.$listeners：（该组件的所有监听器）【只读，自己不会~】 实例对象的方法（数据）： 1、vm.$watch( )（Vue实例里面的监听器，具体看 Vue的选项） 2、vm.$set( )（Vue实例数据的修改，具体看 Vue的选项） 3、vm.$delete( )（Vue实例数据的删除，具体看 Vue的选项） 实例对象的方法：（事件）： 1、vm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54ba08d57a07f63d17fcbc77e684e8af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52965fdd30949e304cdd0c793075e63e/" rel="bookmark">
			看Vue文档总结之路（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue的选项（以下的所有链接均为转载） Vue 的 选项 / 数据：1、data：（组件里面的数据对象）【粗略的说一样，用得比较多】注意点： 2、props：（用来接受父组件的数据）【粗略的说一样，用得比较多】注意点：详细解释： 3、propsData：（传递数据的一种方法）【用得少，网上也很少资料】详细用法： 4、computed：（计算属性）【用得粗略的说一样，用得比较多】5、methods：（方法）：【用得粗略的说一样，用得比较多】6、watch：（数据监听）：【这个用得比较少】computed、methods、watch这三者的区别： 选项 / DOM：1、el：（对页面已存在的DOM进行挂载）【这个没必要说了】2、template：（以字符串为模板）【这个没必要说了】3、render：（渲染函数，可以通过自己自定义动态生成DOM）【没用过】具体用法： 4、renderError：（当 render 渲染失败的时候，提供另一个 render 方法）【没用过】 选项 / 资源：1、directives：（自定义指令，具体看 Vue的全局API）2、filters：（自定义过滤器，具体看 Vue的全局API）3、components：（注册组件，里面填入单个或者多个组件对象） 选项 / 组合：1、parent / children：（访问子组件或者组件）【应急才用】2、mixins：（混入属性，里面填入要混入的对象，具体看 Vue的全局API）3、extends：（继承一个对象配置来扩展组件）【不大明白】4、provide / inject：（通讯属性，祖先传值给子孙）详细解释 选项 / 其他：1、name：（组件的名字，只有作为组件选项时起作用）2、delimiters：（修改组件的插值表达式）3、functional：（函数组件化）【不会，需要继续学习】详细解释： 4、model：（和 v-model 脱不了关系）【有点懵逼】详细解释 5、inheritAttrs：（是否不切断父组件传递过来的参数）详细解释 6、comments：（是否保留且渲染模板中的 HTML 注释） Vue 的 选项 / 数据： 1、data：（组件里面的数据对象）【粗略的说一样，用得比较多】 类型：（对象 / 函数）
注意点： 1、组件的定义只接受 function
2、数据对象的 property 会被 Vue 递归代理（getter / setter），从而让data数据对象里面的数据能够响应数据变化
3、data对象里面以（ _ 和 $ ）开头的 property 不会被代理
4、可以通过【实例.$data】获取里面的数据对象
2、props：（用来接受父组件的数据）【粗略的说一样，用得比较多】 类型：（数组 / 对象）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52965fdd30949e304cdd0c793075e63e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862f05d1c7de1ab2606b312c0a3b69f0/" rel="bookmark">
			看Vue文档总结之路（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue的生命周期（以下的所有链接均为转载） Vue的生命周期：1. 创建（Create ) beforeCreate created2. 载入 (Mount) beforeMount mounted3. 更新 (Update) beforeUpdate updated4. 销毁 (Destroy) beforeDestroy destroyed 这些生命周期钩子函数都是写在与data同级的。创建期间的生命周期函数：1、beforeCreate：（创建实例之前）2、created：（创建实例之后）3、beforeMount：（实例挂载前）4、mounted：（实例挂载后） 运行期间的生命周期函数：1、beforeUpdate：（修改数据前）2、updated：（修改数据后） 销毁期间的生命周期函数：1、beforeDestroy：（实例销毁前）2、destroyed：（示例销毁后） 生命周期图解：keep-alive标签缓存组件的声明周期：关于keep-alive标签下列有详细说明==注意：==activated()和deactivated()只有在包裹的时候才有效；1、activated：（进入缓存组件的时候调用）2、deactivated：（离开缓存组件的时候调用） Vue的生命周期： 每个Vue实例在被创建之前都要经过一系列的初始化过程，这个过程就是vue的生命周期，Vue实例从创建到销毁的过程
Vue一整个的生命周期中会有很多钩子函数提供给我们在vue生命周期不同的时刻进行操作
1. 创建（Create ) beforeCreate created 2. 载入 (Mount) beforeMount mounted 3. 更新 (Update) beforeUpdate updated 4. 销毁 (Destroy) beforeDestroy destroyed 这些生命周期钩子函数都是写在与data同级的。 实例：
let app = new Vue({ el: "#box", data: { msg: "测试" }, beforeCreate() { //创建vue实例前 console.log("------------beforeCreate-------------"); console.group(this.$el, this.$data, this.msg) //分组输出 //输出 undefined undefined undefined }, created() { //创建vue实例后 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/862f05d1c7de1ab2606b312c0a3b69f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ea229a52ae49d9559c524d44fd1e6a/" rel="bookmark">
			看Vue文档总结之路（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue的全局API（以下的所有链接均为转载） 1、Vue.extend( )：（创建一个 Vue 实例）【和普通的 new Vue 用el挂载一样】2、Vue.nextTick( )：（等到数据更新后执行回调）需要了解【微任务，宏任务】：宏任务：微任务：微宏任务的详细解释（转载别人的）使用原理：this.$nextTick()的使用场景 3、Vue.set( target, propertyName/index, value )：（设置Vue实例data里面的对象或者数组的数据并且更新视图）Vue.set()的详细介绍： 4、Vue.delete( target, propertyName/index )：（删除Vue实例中的对象或者属性）5、Vue.directive( id, [definition] )：（自定义 注册或获取全局Vue指令）Vue.directive()的详细用法和思路 6、Vue.filter( id, [definition] )：（自定义过滤器）Vue.filter()的详细介绍和用法 7、Vue.component( id, [definition] )：（自定义组件）【太熟悉了】8、Vue.use( plugin )：（把组件注册成 全局组件 ）9、Vue.mixin( mixin )：（在全局组件中中混入 一个对象，当然也可以是局部，这个对象和实例的各个属性共用）Vue.mixin()的详细介绍和用法与vuex的区别：与公共组件的区别： 10、Vue.compile( template )：（编译函数）【实现太过于复杂，建议看帖子】实现原理（大白话） 11、Vue.observable( object )：（创建一个可以响应式对象，的和Vuex的state属性很像）Vue.abservable()的详细介绍 12、Vue.version：（查看Vue的版本） 1、Vue.extend( )：（创建一个 Vue 实例）【和普通的 new Vue 用el挂载一样】 参数：{ option }
使用基础 Vue 构造器，创建一个"子类"。参数是一个包含组件选项的对象。
HTML：
&lt;div id="mount-point"&gt;&lt;/div&gt; JS：
// 创建构造器 var Profile = Vue.extend({ template: '&lt;p&gt;{{firstName}} {{lastName}} aka {{alias}}&lt;/p&gt;', data: function () { return { firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' } } }) // 创建 Profile 实例，并挂载到一个元素上。 new Profile().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ea229a52ae49d9559c524d44fd1e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b5894b1962b74167cc0fc9698a067b/" rel="bookmark">
			一个详细的数据结构博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上连接：
https://www.cnblogs.com/skywang12345/p/3603935.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5466bfc45c6b6d50b3689712f49d37a5/" rel="bookmark">
			获取本机内网、外网ip(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础知识 电脑在局域网内，通过网关/路由器连接到Internet则ip分为内网ip、外网ip。通过ipconfig得到的为局域网ip。电脑直接拨号连接等，则本机通过ipconfig得到的就是外网ip。 代码 //Get IP int GetLocalIP(std::string &amp;local_ip); int GetInternetIP(std::string &amp;Inernet_ip); int GetLocalIP( std::string &amp;local_ip ) { WSADATA wsaData = {0}; if (WSAStartup(MAKEWORD(2, 1), &amp;wsaData) != 0) return kErrorWSAStartup; char szHostName[MAX_PATH] = {0}; int nRetCode; nRetCode = gethostname(szHostName, sizeof(szHostName)); PHOSTENT hostinfo; if (nRetCode != 0) return WSAGetLastError(); hostinfo = gethostbyname(szHostName); local_ip = inet_ntoa(*(struct in_addr*)*hostinfo-&gt;h_addr_list); WSACleanup(); return 1; } int GetInternetIP( std::string &amp;Inernet_ip ) { Inernet_ip.resize(32); TCHAR szTempPath[_MAX_PATH] = {0}, szTempFile[MAX_PATH] = {0}; std::string buffer; GetTempPath(MAX_PATH, szTempPath); UINT nResult = GetTempFileName(szTempPath, _T("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5466bfc45c6b6d50b3689712f49d37a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d6862378a45ea6411ce0b0641eb5ba/" rel="bookmark">
			python:将json数据写入到excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		★★★ 个人博客导读首页—点击此处 ★★★
环境 ： Python2
封装一个函数，可以将json格式的数据，填入到excel中
函数使用示例: create_a_new_excel(s_name,“table1”,test_title, test_use_list)
s_name是excel的名称， table1是excel中表的名称，
test_title是一个列表，列出excel的标题
test_use_list是要填充的数据，是字典组成的列表
例如: test_title = [ "title1", "title2" ] &gt; &gt; test_use_list = [ { "title1":"(1,1)", "title2":"1,2)" }, { "title1":"(2,1)", "title2":"2,2)" } ] 源代码
# coding=utf8 import sys import os import shutil import time import xlrd import xlwt import json def create_sheet(f,table_name,try_count): if try_count &lt;= 1: return try: sheet1 = f.add_sheet(table_name + '-' + str(11 - try_count),cell_overwrite_ok=True) return sheet1 except Exception as e: return create_sheet(f,table_name,try_count-1) def create_a_new_excel(excel_path,table_name,title_name,use_lists): table1_invalid_start_x = 1; table1_invalid_start_y = 2; max_buf_len = [] if os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8d6862378a45ea6411ce0b0641eb5ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2394c3e65e81223ec02cbef5378e5274/" rel="bookmark">
			Twitter雪花算法SnowFlake介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近了解到SnowFlake算法，网上查了查资料，这里记录一下。
前言 分布式系统中，有一些需要使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点，首先他相对比较长，另外UUID一般是无序的。
有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。
而twitter的SnowFlake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra，因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一ID生成服务。
1 理解分布式id生成算法SnowFlake 1.1 概述 SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图：
0 - 41位时间戳 - 5位数据中心标识 - 5位机器标识 - 12位序列号
说明：
1) 1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是02) 41位，用来记录时间戳（毫秒）。 41位可以表示2^41−1个数字，如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^41−1，减1是因为可表示的数值范围是从0开始算的，而不是1。
也就是说41位可以表示2^41−1个毫秒的值，转化成单位年则是(2^41−1)/(1000∗60∗60∗24∗365)=69年
3) 10位，用来记录工作机器id。 可以部署在2^10=1024个节点，包括5位datacenterId和5位workerId
5位（bit）可以表示的最大正整数是2^5−1=31，即可以用0、1、2、3、....31这32个数字，来表示不同的datecenterId或workerId
4) 12位，序列号，用来记录同毫秒内产生的不同id。 12位（bit）可以表示的最大正整数是2^12−1=4095，即可以用0、1、2、3、....4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号
由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。
1.2 雪花算法的作用 SnowFlake可以保证：
所有生成的id按时间趋势递增 整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分） 2 算法实现（Java） Twitter官方给出的算法实现 是用Scala写的，这里不做分析，可自行查看。
Java版算法实现：搬运自煲煲菜的博客
2.1 实现1 public class IdWorker{ //下面两个每个5位，加起来就是10位的工作机器id private long workerId; //工作id private long datacenterId; //数据id //12位的序列号 private long sequence; public IdWorker(long workerId, long datacenterId, long sequence){ // sanity check for workerId if (workerId &gt; maxWorkerId || workerId &lt; 0) { throw new IllegalArgumentException(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2394c3e65e81223ec02cbef5378e5274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242d9369475d560aa419eb1fb69c4e53/" rel="bookmark">
			Java中使用Redis（即学即用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么需要用Redis？ Redis（Remote Dictionary Server），一个基于内存的高性能key-value 数据库。针对关系型数据库性能瓶颈来设计的，处理关系型数据库不擅长做的业务场景。Redis 多用于项目的高速缓存，可以让项目性能更好。
补充：Redis的应用场景 1、缓存
当我们需要查询数据时，先去查询Redis的缓存，有就直接返回，没有再去关系型数据库查询，返回结果，最后把结果数据缓存到Redis（为下一次的查询）。（Redis是以key-value的形式缓存数据的，一般较多使用string类型，关于key，设计上要保证唯一，一种做法的类的全限定名+id，关于value，如果要存储对象，会直接把对象转成json格式，进行缓存。要查询时，查出来json格式的数据，再转成java对象返回。）
一般缓存都是对于不常变动的数据，如账号密码，一些（QQ、微信）等。
2、实时统计点赞总数
一些短视频，推文，博客等的点赞，热度高的时候，可能瞬时爆发非常多的请求，如果都是直接操作关系型数据库，就会对数据库造成很大压力，甚至崩溃。
这时，我们会使用Redis，先把每一次的点赞先存到Redis，每点一次就+1（因为Redis是直接操作内存的，无惧这点点击量），然后隔一段时间（服务器压力小点时）定时把数据存储到关系型数据中（数据落地）。
3、朋友圈点赞
这区别于上面的统计点赞数，因为统计点赞数，只是计算数量，在代码中也只是调用“incr key ”把值递增1，而朋友圈点赞，还需要知道谁给谁点了赞。
4、热门推荐 在网站或者App的首页的 推荐的热门内容 ，可以使用 list 形式存入R edis 中。这种，不管是哪个用户或者游客，不管多少人去点击，都是去Redis中查，不用直接查关系型数据库。（不管谁进入这个网站，看到的首页都是一样的） 5、抽奖
6、好友推荐
二、安装Redis 1、下面提供其中一个版本的Redis：
链接：https://pan.baidu.com/s/1Z3QRpdMzUyPh8ODZJDgGEA 提取码：j8vl 2、初学时，直接全部next安装即可
3、安装完成后，进入Redis的安装目录
双击打开redis-cli.exe，出现以下端口号6379，表明安装成功：
注：当我们输入太多的命令后，可以使用命令“clear”清除掉，使用窗口更干净
三、管理Redis 1、管理密码（初学时不建议搞）
（1）设置密码 config set requirepass 123
设置密码后，这时就需要登录认证了，不然就会报错（下图）
（2）登录 auth 123 （登录后就可以继续操作了）
（3）获取密码 config get requirepass
（4）取消密码 config set requirepass ''
2、管理key exists key -&gt; 判断某个key是否存在 expire key second -&gt; 设置key的过期时间 persist key -&gt; 取消key的过期时间 select index -&gt; 切换数据库索引,范围是0 ~ 15共16个分区 move key index -&gt; 把某个key-value移动到其他索引中 rename oldKey newKey -&gt; 把oldKey重命名为newKey info -&gt; 查看当前服务器信息 flushdb -&gt; 清空当前库中的数据 flushall -&gt; 清空所有库中的数据 四、Redis如何操作数据 Redis支持多种数据类型：string，hash，list，set，zset。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242d9369475d560aa419eb1fb69c4e53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/279f0ab82526d7270bb8f6d3a36a1f6b/" rel="bookmark">
			Android Studio下载、安装、配置SDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio是Google官方指定的开发Android IDE。
AS下载 Windows系统要求：
64位的Windows 7、Windows 8、Windows 10最小4G RAM，建议8G RAM最小2G可用的硬盘空间, 建议4G（IDE 500M、Android SDK和模拟器系统镜像1.5G）最小屏幕分辨率 1280 x 800 进入Android开发者官网，选择Android Studio——下载，如下图所示。
点击下载，如下图所示。
勾选同意条款，点击下载，如下图所示。
开始下载
下载完成
如果下载的是 .zip 文件，解压缩 ZIP 文件，将 android-studio 文件夹复制到 Program Files 文件夹中，然后打开 android-studio &gt; bin 文件夹并启动 studio64.exe（对于 64 位计算机）或 studio.exe（对于 32 位计算机）。
AS安装 按照 Android Studio 中设置向导的指示安装它推荐的所有 SDK 软件包。
双击下载好的Android Studio IDE安装文件，如下图所示。
出现Android Studio安装引导文件，点击Next，如下图所示。
配置SDK SDK未发现 当启动时，发现SDK未发现而报错，出现提示框时，如下图，选择Cancel。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24128f7bfaf8d8df918e3c0f4c270949/" rel="bookmark">
			Batch Normalization的诅咒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“AI公园”，关注公众号，选择加“星标“或“置顶”
作者：Sahil Uppal
编译：ronghuaiyang
导读
batch normalization时的一些缺陷。
Batch Normalization确实是深度学习领域的重大突破之一，也是近年来研究人员讨论的热点之一。Batch Normalization是一种被广泛采用的技术，使训练更加快速和稳定，已成为最有影响力的方法之一。然而，尽管它具有多种功能，但仍有一些地方阻碍了该方法的发展，正如我们将在本文中讨论的那样，这表明做归一化的方法仍有改进的余地。
我们为什么要用Batch Normalization? 在讨论任何事情之前，首先，我们应该知道Batch Normalization是什么，它是如何工作的，并讨论它的用例。
什么是Batch Normalization 在训练过程中，当我们更新之前的权值时，每个中间激活层的输出分布会在每次迭代时发生变化。这种现象称为内部协变量移位(ICS)。所以很自然的一件事，如果我想防止这种情况发生，就是修正所有的分布。简单地说，如果我的分布变动了，我会限制住这个分布，不让它移动，以帮助梯度优化和防止梯度消失，这将帮助我的神经网络训练更快。因此减少这种内部协变量位移是推动batch normalization发展的关键原则。
它如何工作 Batch Normalization通过在batch上减去经验平均值除以经验标准差来对前一个输出层的输出进行归一化。这将使数据看起来像高斯分布。
其中μ和*σ^2^*分别为批均值和批方差。
并且，我们学习了一个新的平均值和协方差γ和β。所以，简而言之，你可以认为batch normalization是帮助你控制batch分布的一阶和二阶动量。
vgg16网络的中间卷积层的特征分布输出。(左)没有任何归一化，(右)应用了batch normalization 优点 我将列举使用batch normalization的一些好处，但是我不会详细介绍，因为已经有很多文章讨论了这个问题。
更快的收敛。
降低初始权重的重要性。
鲁棒的超参数。
需要较少的数据进行泛化。
1. 更快的收敛，2. 对超参数更鲁棒 Batch Normalization的诅咒 好，让我们回到本文的出发点，在许多情况下batch normalization开始伤害性能或根本不起作用。
在使用小batch size的时候不稳定 如上所述，batch normalization必须计算平均值和方差，以便在batch中对之前的输出进行归一化。如果batch大小比较大的话，这种统计估计是比较准确的，而随着batch大小的减少，估计的准确性持续减小。
ResNet-50在Batch Norm使用32、16、8、4、2张/GPU图像时的验证错误 以上是ResNet-50的验证错误图。可以推断，如果batch大小保持为32，它的最终验证误差在23左右，并且随着batch大小的减小，误差会继续减小(batch大小不能为1，因为它本身就是平均值)。损失有很大的不同(大约10%)。
如果batch大小是一个问题，为什么我们不使用更大的batch？我们不能在每种情况下都使用更大的batch。在finetune的时候，我们不能使用大的batch，以免过高的梯度对模型造成伤害。在分布式训练的时候，大的batch最终将作为一组小batch分布在各个实例中。
导致训练时间的增加 NVIDIA和卡耐基梅隆大学进行的实验结果表明，“尽管Batch Normalization不是计算密集型，而且收敛所需的总迭代次数也减少了。”但是每个迭代的时间显著增加了，而且还随着batch大小的增加而进一步增加。
ResNet-50 在ImageNet上使用 Titan X Pascal 你可以看到，batch normalization消耗了总训练时间的1/4。原因是batch normalization需要通过输入数据进行两次迭代，一次用于计算batch统计信息，另一次用于归一化输出。
训练和推理时不一样的结果 例如，在真实世界中做“物体检测”。在训练一个物体检测器时，我们通常使用大batch(YOLOv4和Faster-RCNN都是在默认batch大小= 64的情况下训练的)。但在投入生产后，这些模型的工作并不像训练时那么好。这是因为它们接受的是大batch的训练，而在实时情况下，它们的batch大小等于1，因为它必须一帧帧处理。考虑到这个限制，一些实现倾向于基于训练集上使用预先计算的平均值和方差。另一种可能是基于你的测试集分布计算平均值和方差值。
对于在线学习不好 与batch学习相比，在线学习是一种学习技术，在这种技术中，系统通过依次向其提供数据实例来逐步接受训练，可以是单独的，也可以是通过称为mini-batch的小组进行。每个学习步骤都是快速和便宜的，所以系统可以在新的数据到达时实时学习。
典型的在线学习pipeline 由于它依赖于外部数据源，数据可能单独或批量到达。由于每次迭代中batch大小的变化，对输入数据的尺度和偏移的泛化能力不好，最终影响了性能。
对于循环神经网络不好 虽然batch normalization可以显著提高卷积神经网络的训练和泛化速度，但它们很难应用于递归结构。batch normalization可以应用于RNN堆栈之间，其中归一化是“垂直”应用的，即每个RNN的输出。但是它不能“水平地”应用，例如在时间步之间，因为它会因为重复的重新缩放而产生爆炸性的梯度而伤害到训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24128f7bfaf8d8df918e3c0f4c270949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5a373214d7c7931635c24237474eb9/" rel="bookmark">
			CAT3.0的集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载 https://www.jianshu.com/p/13d9de1f7fe5
CAT安装环境 CentOS 6.5 Java 6，7，8，服务端推荐是用jdk7的版本，客户端jdk6、7、8都支持 Maven 3及以上 MySQL 5.6，5.7，更高版本MySQL都不建议使用，不清楚兼容性 J2EE容器建议使用tomcat，建议使用推荐版本7..或8.0.* Hadoop环境可选，一般建议规模较小的公司直接使用磁盘模式，可以申请CAT服务端，500GB磁盘或者更大磁盘，这个磁盘挂载在/data/目录上 CAT组件 CAT主要由以下组件组成： cat-home: 服务端组件，负责收集监控信息，分析处理生成报告、执行告警 cat-client: 客户端组件，负责与服务端进行连接通信， cat-core: 核心处理组件，负责具体的与客户端通信服务，解析数据、输出报告 cat-consumer : 消费处理组件，负责实际的监控数据分析，处理工作 cat-hadoop : HDFS存储组件 安装CAT集群步骤概览 初始化Mysql数据库，一套CAT集群需要部署一个数据库，数据库脚本script/CatApplication.sql 准备三台CAT服务器，IP假设为10.1.1.1，10.1.1.2，10.1.1.3，下面的集群模式安装会以这些IP为例 初始化/data/目录，配置几个配置文件/data/appdatas/cat/*.xml 几个配置文件，具体下面有详细说明 打包并重命名为cat.war，放入tomcat容器webapps根目录下，并启动tomcat 修改服务器配置、及路由配置，重启tomcat 步骤1： 部署tomcat 调整启动参数，修改 catalina.sh文件【服务端】 需要每台CAT集群10.1.1.1，10.1.1.2，10.1.1.3都进行部署 建议使用cms gc策略 建议cat的使用堆大小至少10G以上，开发环境启动2G堆启动即可 CATALINA_OPTS="$CATALINA_OPTS -server -Djava.awt.headless=true -Xms25G -Xmx25G -XX:PermSize=256m -XX:MaxPermSize=256m -XX:NewSize=10144m -XX:MaxNewSize=10144m -XX:SurvivorRatio=10 -XX:+UseParNewGC -XX:ParallelGCThreads=4 -XX:MaxTenuringThreshold=13 -XX:+UseConcMarkSweepGC -XX:+DisableExplicitGC -XX:+UseCMSInitiatingOccupancyOnly -XX:+ScavengeBeforeFullGC -XX:+UseCMSCompactAtFullCollection -XX:+CMSParallelRemarkEnabled -XX:CMSFullGCsBeforeCompaction=9 -XX:CMSInitiatingOccupancyFraction=60 -XX:+CMSClassUnloadingEnabled -XX:SoftRefLRUPolicyMSPerMB=0 -XX:-ReduceInitialCardMarks -XX:+CMSPermGenSweepingEnabled -XX:CMSInitiatingPermOccupancyFraction=70 -XX:+ExplicitGCInvokesConcurrent -Djava.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b5a373214d7c7931635c24237474eb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cc604b76cbdcae60161cf73a269990a/" rel="bookmark">
			深度学习CNN网络推理时Batchnorm层和卷积层的融合，以提升推理速度。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习系列文章目录 文章目录 深度学习系列文章目录前言一、Batchnorm二、推理时BatchNorm和Conv融合总结 前言 看到一些好的东西就忍不住想记录下来，方便学习和记忆。本文讲一下BatchNorm 训练和推理过程中的一些解读。
参考如下：
Batchnorm原理：https://blog.csdn.net/qq_25737169/article/details/79048516
上篇博客的归纳整理
推理时BN和Conv融合：https://mp.weixin.qq.com/s/P94ACKuoA0YapBKlrgZl3A
一、Batchnorm batchnorm顾名思义是对每batch个数据同时做一个norm，对一个神经元（或者一个卷积核）的输出减去一个batch统计得到的均值，除以标准差，然后乘以一个可学习的系数，再加上一个偏置，这个过程就完成了。
第一步：先求出此次批量数据x的均值，μβ=1m∑mi=1xi
第二步：求出此次批量数据的方差，σβ2=1m∑i=1m(xi−μβ)2
第三步：接下来就是对x做归一化，得到xi−
第四步：最重要的一步，引入缩放和平移变量γ和β ,计算归一化后的值，yi=γxi−+β
如果不加γ和β，直接归一化，是会打乱原有数据的分布，容易导致网络学不到任何东西，但是加入这两个参数后，事情就不一样了。先考虑特殊情况，假设γ是batch的方差，β是batch的均值，那么yi=γxi−+β得到的yi就是还原到了归一化之前的x，也就是缩放平移到了归一化前的分布，相当于batchnorm没有改变任何分布没有起作用。所以，加入了γ和β这两个参数后的batchnorm，保证了每一次数据归一化后还保留有之前学习来的特征分布，同时又能完成归一化的操作，加速训练。
在训练过程中，为保持稳定，一般使用滑动平均法更新均值和方差，滑动平均就是在更新当前值的时候，以一定比例保存之前的数值，以均值 为例,以一定比例 （例如这里0.99）保存之前的均值，当前只更新0.001倍的本Batch的均值，计算方法如下：
训练代码如下（示例）：
def Batchnorm_simple_for_train(x, gamma, beta, bn_param): """ param:x : 输入数据，设shape(B,L) param:gama : 缩放因子 γ param:beta : 平移因子 β param:bn_param : batchnorm所需要的一些参数 eps : 接近0的数，防止分母出现0 momentum : 动量参数，一般为0.9， 0.99， 0.999 running_mean ：滑动平均的方式计算新的均值，训练时计算，为测试数据做准备 running_var : 滑动平均的方式计算新的方差，训练时计算，为测试数据做准备 """ running_mean = bn_param['running_mean'] #shape = [B] running_var = bn_param['running_var'] #shape = [B] results = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cc604b76cbdcae60161cf73a269990a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0677fb5d4cad81fba567aa24dc93b9cb/" rel="bookmark">
			nginx不转发static下文件_文件存储老大难，随取随用不心烦！玩转最强私人云盘群晖NAS（下）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章作者 | liuspy 昨天我们一起聊了有关NAS一些功能的实现方法，没 看到的话可以去补补课哦～👉点我补课👈 NAS这么好用只了解皮毛怎么行？挑选设备，安装软件，今天让我们继续打造私人云盘！ 一、如何实现神级功能？ 1 照片管理
很多朋友在最初接触NAS的时候，主要需求只有两个：一个是高清电影的存储和下载，另外一个就是照片管理。 经过这几年的发展，群晖的照片从Photo Station向Monents发展。 随着6.0系统Monents的加入，已经支持人脸识别、场景识别、AI等智能识别等功能，配合时间线&amp;照片墙使用非常方面顺手。 Monents的智能功能强大，却不适合单独使用，其以照片日期来进行分类，这样非常不方便管理。尤其是同步用户多了以后，情况尤为麻烦。 所以正确的使用方法还是应该使用Photo Station来进行照片的同步、整理及分类。 如何用Monents调用Photo Station的照片数据？只需几步即可。 ▼第一步是安装Photo Station和Monents两个软件。 ▼将照片导入到Photo文件夹中，等待索引结束。 ▼然后打开Moments，点击左下角的设置按钮。 ▼选择启用共享照片库，并且全部重建索引。 ▼之后我们在左上角的Moments这里就可以选择共享文件夹。 ▼可以使用各种AI识别功能了，例如人脸识别等。 ▼尤其对于有宝宝的家庭 ，把几年的照片进行人脸识别，时间线模式显示，可以看到宝宝一点一点的成长过程和一点一滴的变化，非常实用。 2 流媒体在线转码
群晖套件中的Video Station是一个可以实现电影管理及云端转码的平台。Video Station虽不完美，但对于新手入门来说却是最简单可行的在线播放平台。 下面我们来看看Video Station如何设置。 ▼Video Station是群晖的标准套件之一，因此我们直接在应用商店就可以顺利安装。
▼初次启动Video Station没有任何内容，我们需要把储存电影的路径告诉Video Station。
▼经过一段时间的索引我们就可以看到海报墙，并且可以自动下载电影海报和电影的信息。 ▼通过网页可以播放电影，做好端口转发，异地远程也可以播放。移动端也有适配的APP。 不过之所以说Video Station不完美，是因为其不支持Ture-HD和DTS音轨的播放，且很多高码率的影片无法转码播放。 对于高清党支持不算友好，但对于用ipad追美剧的朋友来说影响并不大。
二、 哪些型号的群晖值得买？ 以上功能只是群晖最为基础的功能，群晖能够实现的进阶功能还有许多。 下面我们就来看看具体产品如何来选择吧。 1 盘位
NAS的选购首先最应该关注的就是盘位的选择。盘位的多少，从根本上决定了NAS可扩展的最大储存空间及可组建的磁盘Raid类型。 例如2盘位的产品在Raid选择上就只有raid0和raid1和basic的选择。 在购买前务必要对盘位考虑清楚。因为往往多加一个盘位，价格都是千元的差价。 目前NAS配置的机械硬盘一般都是4T起步，因为盘位比硬盘要贵，所以尽量配备大容量的硬盘。 首先1盘位产品不做考虑直接pass，入门级用户可以选择2盘位的产品，能够提供8T-20T左右的储存空间。 不过2盘位的缺点也比较明显，就是在安全保障方面只能采用raid1的形式，这样一来会使存储空间直接缩水一半。 因此2盘位有时候就非常尴尬了，在安全和空间问题上只能2选一。 2盘位的产品只适合轻度用户使用，对于高清党、电影党、工作室建议绕行。 一般而言更推荐购买4盘位以上的产品，无论是组建raid1还是raid5、raid6选择性更多，能够更好的综合存储空间和安全的问题。 2 选择性能
对于消费级家用场景下，2盘位和4盘位是选购量最大的两个阵营。当确定盘位后，我们就要考虑机器的性能因素。 群晖的产品线还是非常清晰的，2盘位和4盘位几乎都是按下面的等级划分性能： j(入门级)&lt; 无后缀(普通级)&lt; play(娱乐级)&lt; +(性能级) ▼这张图也清晰的为我们展示了各个型号性能的等级。 关于性能选购可以遵循以下原则： a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0677fb5d4cad81fba567aa24dc93b9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36fa62e4358e7e5bca26ad3dc059f285/" rel="bookmark">
			ShardingSphere 简介（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 JDBC、Proxy 和 Sidecar（规划中）这 3 款相互独立，却又能够混合部署配合使用的产品组成。 它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如 Java 同构、异构语言、云原生等各种多样化的应用场景。
ShardingSphere 已于2020年4月16日成为 Apache 软件基金会的顶级项目。
1、Sharding-JDBC
ShardingSphere 的前身是 Sharding-JDBC（来自当当网），所以这是整个框架中最为成熟的组件。Sharding-JDBC 的定位是一个轻量级 Java 框架，在 JDBC 层提供了扩展性服务。 JDBC 是一种开发规范，指定了 DataSource、Connection、Statement、PreparedStatement、ResultSet 等一系列接口。而各大数据库供应商通过实现这些接口提供了自身对 JDBC 规范的支持，使得 JDBC 规范成为 Java 领域中被广泛采用的数据库访问标准，Sharding-JDBC是对JDBC的兼容和拓展。
提供了一套与 JDBC 规范完全一致的 API，所以它可以很方便地与遵循 JDBC 规范的各种组件和框架进行无缝集成。例如，用于提供数据库连接的 DBCP、C3P0 等数据库连接池组件，以及用于提供对象-关系映射的 Hibernate、MyBatis 等 ORM 框架。当然，作为一款支持多数据库的开源框架，Sharding-JDBC 支持 MySQL、Oracle、SQLServer 等主流关系型数据库。
2、Sharding-Proxy
ShardingSphere 中的 Sharding-Proxy 组件定位为一个透明化的数据库代理端，所以它是代理服务器分片方案的一种具体实现方式。在代理方案的设计和实现上，Sharding-Proxy 同样充分考虑了兼容性。
Sharding-Proxy 所提供的兼容性首先体现在对异构语言的支持上，为了完成对异构语言的支持，Sharding-Proxy 专门对数据库二进制协议进行了封装，并提供了一个代理服务端组件。其次，从客户端组件上讲，针对目前市面上流行的 Navicat、MySQL Command Client 等客户端工具，Sharding-Proxy 也能够兼容遵循 MySQL 和 PostgreSQL 协议的各类访问客户端。当然，和 Sharding-JDBC 一样，Sharding-Proxy 也支持 MySQL 和 PostgreSQL 等多种数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36fa62e4358e7e5bca26ad3dc059f285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c134e2ba4b752bba9f6bc5c2f7dd2cd0/" rel="bookmark">
			java中unexpected token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 问题 问题 public class People { int m = 10,n; // 1 n = 200; // 2 void f(){ if(m == n) n += m; // 3 else n = n - m; // 4 } } 这道题问的是，下列哪行代码有错误，一开始并没有发现问题的所在，放了编辑器里面，发现报错unexpected token，查阅资料后发现
class下只能定义方法，以及变量等。但不能直接编写逻辑代码，应该把这些代码定义在一个方法里面
所以解决办法很简单，只要把对n的赋值方法方法f()中就可以解决报错啦，如下
public class People { int m = 10,n; // 1 void f(){ n = 200; // 2 if(m == n) n += m; // 3 else n = n - m; // 4 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcbfdb5fb03a09fd237d7a8f14ae3abc/" rel="bookmark">
			idea2020.2.2 license server_UG NX 12.0 软件安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方蓝字关注我 安装软件不迷路哦~ UG NX12.0下载地址：
[名称]：UG NX12.0 [大小]：5.66GB [语言]：简体中文 [安装环境]:Win10/Win8/Win7
[UG NX12.0(64位)下载链接]：
pan.baidu.com/s/18w152gOpkKwuOHIYhpVTrw
提取码：p3th
[下载方法]：如何在公众号下载软件安装包?
请咨询微信：q1132830540
UG NX 介绍 UG为用户的产品设计及加工过程提供了数字化造型和验证手段。Unigraphics NX针对用户的虚拟产品设计和工艺设计的需求，提供了经过实践验证的解决方案。UG同时也是用户指南(user guide)和普遍语法(Universal Grammar)的缩写。
UG NX 12.0安装步骤
1.选中【UG12.0】软件压缩包，鼠标右击“解压到UG12.0”
2.在电脑桌面，找到【此电脑/计算机/我的电脑】其中任意一个，鼠标右击选择“属性”
3.点击【高级系统设置】
4.选择【计算机名】，选中后右击快捷键Ctrl+C复制
5.双击打开【UG12.0】解压后的文件夹
6.双击打开【激活文件】
7.选中【splm8.lic】文件，鼠标右击选打开方式
8.往下滑找到【记事本】，选择后点击确定
9.选中 this_host ，删除
10.将刚复制的计算机全名粘贴到这里，快捷键Ctrl+S保存，然后关闭
11.返回到安装包中，打开【UG安装包】文件夹
12.点击【下一步】
13.点击【更改...】更改软件安装路径：建议安装到除C盘以外的磁盘，可在D盘或其它盘里面新建一个文件夹【Java】。然后点击【下一步】
14.等待安装中...
15.点击【下一步】
16.等待安装中...
17.点击【关闭】
18.返回安装包中，双击打开UG安装包文件夹
19.双击打开【Launch】
20.点击【Install License Manager】
21.点击【确定】
22.点击【下一步】
23.点击【选择...】更改软件安装路径：建议安装到除C盘以外的磁盘，可在D盘或其它盘里面新建一个文件夹【Siemens】。然后点击【下一步】。
24.点击【选择】
25.找到安装包中--激活文件夹里之前更改的文件，选择后点击【打开】
26.点击【下一步】
27.点击【安装】
28.等待安装中...
29.如出现下方弹窗，点击【确定】
30.点击【完成】
31.返回安装包中，双击打开【激活文件】
32.鼠标选中【ugslmd】，右击复制
33.打开之前选择的程序安装位置，
默认位置为：C:\Program Files\Siemens\PLMLicenseServer
34.在空白处，鼠标右击【粘贴】
35.点击【替换目标中的文件】
36.在当前文件夹中，双击打开【lmtools】
37.先点击【start/stop/reread】，然后点击【stop server】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcbfdb5fb03a09fd237d7a8f14ae3abc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd99a470a2c08d336ef505fcf76f8493/" rel="bookmark">
			ie浏览器在线使用_Win10系统安装后IE浏览器无法使用的三种解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10系统IE浏览器无法使用怎么办？最近有用户重装Win10系统后出现IE浏览器不能使用的问题，下面就给大家分享三种解决IE浏览器无法使用的方法。
方案一： 重置Winsock目录：
1、按Win+X，打开“命令提示符(管理员)”
2、输入命令netsh winsock reset并点击回车。
方案二： 先打开Internet选项，切换到“连接”选项卡：
点右下角的局域网设置，如下图所示：
取消勾选所有选项，然后按下边的操作：
1、以管理员身份运行CMD，先键入命令：netsh，按回车键运行；
2、之后再次键命令：winhttp，回车确认运行；
3、最后再键入命令：import proxysource=ie，按回车键运行即可；
4、通过以上步骤，就可以重置浏览器的端口设置。
方案三： 使用命令创建一个新的本地管理员账户，再重新登录到电脑尝试。
在任务栏搜索框中输入PowerShell，右键单击搜索结果，选择“以管理员身份运行”。在PowerShell中输入以下命令：
$user = ‘splitpersonality’
net user /add $user
net localgroup Administrators /add $user
回车运行，之后使用新的账户登录系统看是否正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38cb19dc56e07260edec817807540025/" rel="bookmark">
			c&#43;&#43;initgraph函数_python中函数：range()与函数：numpy.arrange() 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数：range()
函数说明： range(start, stop[, step]) -&gt; range object，根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个序列。参数含义： start: 计数从 start 开始。默认是从 0 开始。例如 range（5）等价于 range（0， 5）; end: 开始到 end 结束，不包括 end. 例如：range（0， 5） 是 [0, 1, 2, 3, 4] 没有 5scan：每次跳跃的间距，默认为 1。例如：range（0， 5） 等价于 range(0, 5, 1)range 多用作循环，range（0,10）返回一个 range 对象，如想返回一个 list，前面加上 list 转换 函数返回的是一个 range object
&gt;&gt;&gt; range中的setp 不能使float,所有range不能生成小数。
函数：arrange() 函数说明：arange([start,] stop[, step,], dtype=None) 根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。 返回array 类型对象。 &gt;&gt;&gt; range() 中的步长不能为小数，但是numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38cb19dc56e07260edec817807540025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfa6be692eb9909642a90284c87a190/" rel="bookmark">
			经典算法 -枚举（百钱百鸡案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 算法系列第二站是枚举，也叫穷举和暴力破解法，和名字一样，简单直接，一起来看看吧
一，什么是穷举 在进行归纳推理时，如果逐个考察了某类事件的所有可能情况，因而得出一般结论，那么这结论是可靠的，这种归纳方法叫做枚举法
枚举法的特点就是可以对于无法规律性解决的问题进行蛮力解决，但是带来的副作用就是当运算量级太大时就很难去应付
二，算法的实现 案例：百鸡问题
有鸡翁一，值钱伍；鸡母一，值钱三；鸡鶵三，值钱一。凡百钱买鸡百只，问鸡翁、母、鶵各几何？
对本问题分析，三种鸡的数量关系满足：
nub（公鸡）+nub（母鸡）+nub（小鸡）=100 nub（公鸡）* 5+nub（母鸡）* 3+nub（小鸡）=100 三个变量只有两个公式如何求解呢，这个时候只能固定一个变量，然后求另外两个变量，枚举法就是基于这样的思想，对于所有可能性进行遍历
三，算法的实现 基本思路：
使用两个for循环固定两个变量，则可以使用上面的判断公式来判断这组数据是否满足要求，如果满足，则输出：
具体代码：
对于for循环最大值，很明显公鸡数量最大值为20只，二母鸡最大的数量为33只，通过两个最大量来限制遍历范围，这也是枚举的有穷性的特点
void GetNub() { int n,m,k; //n:公鸡数量，m:母鸡数量，k:小鸡数量 for(n=0;n&lt;=20;n++) for(m=0;m&lt;=33;m++) { k=100-n-m; if(15*n+9*m+k==300) cout&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;" "&lt;&lt;k&lt;&lt;endl; } } 四，枚举思想的培养 和其他算法不同的是，枚举是没有规律的情况下来使用，所以就很难来推算什么情况来使用是合适的，不过总的来说，枚举还是适用于那些量级比较小的，循环使用痕迹比较重的情况
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/99/">«</a>
	<span class="pagination__item pagination__item--current">100/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/101/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>