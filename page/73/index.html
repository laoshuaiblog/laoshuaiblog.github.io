<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8d104ef3e88c3813b13f85b4a69b64/" rel="bookmark">
			记录python读写mysql/clickhouse/odps等常见数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、读取clickhouse 1、读取得到DataFrame格式的数据
from clickhouse_driver import Client def read_ck(): client_ck = Client(host='', port='', user='', password='', send_receive_timeout=600, ) sql = '' data = client_ck.query_dataframe(sql) return data 2、读取得到常规格式的数据
from clickhouse_driver import connect def read_ck(): conn = connect(host='', port='', user='', database='',password='', send_receive_timeout=600) cursor = conn.cursor() cursor.execute(sql) data = cursor.fetchall() cursor.close() conn.close() return data 二、批量写入mysql import pymysql def save_mysql(): sql = 'replace into test (name,age) value (%s,%s)' data = [['xiaoli','20'],['xiaozhang','25']] # 一个双层list conn = pymysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f8d104ef3e88c3813b13f85b4a69b64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b136d2367c52a11794f00cf390cf71b8/" rel="bookmark">
			vue项目中统一格式的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue项目中统一格式的方法 1. 在assets(静态资源)下的styles目录下建立css文件 格式如下，根据具体要求编写
2. 在views目录下的main.js中引用该文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2f00e934e29e8bf6f5f72433181b2c/" rel="bookmark">
			java利用切面（aspect）记录日志实现性能跟踪以及用户行为分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录日志的目的是多种多样的，这里主要以性能跟踪和用户行为分析为目的讨论如何记录日志。
1. 概述 一个有一定规模的应用系统，都会存在大量的功能，这些功能通过菜单，链接，按钮和页面进行展示，在系统建设初期，为了尽早将系统投入生产，对于系统性能优化方面可能考虑不够。当然，系统初期的用户量和数据量都相对较小，系统性能也不会是有明显的问题。但是，随着系统的持续运行，用户量和数据量的不断增加，性能性能的优化就变得越来越重要了。
一个请求的响应速度直接影响到用户的使用体验，只有用户系统的响应时间在正常的接受范围内时，用户才会感觉到系统是正常的，一旦超过这个时间，就会感觉系统很慢。但是系统慢，只是一个大概的描述，是个别的特定操作响应慢，还是所有的操作都慢，是个别用户觉得慢，还是所有用户都觉得慢，这就不容易描述清楚。所以，系统最好有自身处理时间的一个记录和统计，包括各种操作，各种条件下的操作，包括不同的用户，不同的时间，不同的输入条件等。
另一方面，系统在不断的增加功能和完善过程中，增加了各种各样的功能，这些功能有哪些使用得多，哪些使用得少，都是什么用户在使用，下一步的发展方向在什么地方。最好的方法就是系统能够提供针对性的统计，这是最直接的，也是最客观的，不受主观判断的影响。通过日志记录，可以分析出系统提供的功能中，哪些功能使用最频繁，哪些功能使用最少，这样有利于在后续的版本升级中，把重心放在用户关心的功能上。用户使用少的功能，可以进一步分析用户使用少的原因，比如是用户不了解，还是用户的确不需要等。
2. 主要代码 总体技术思路，采用切面方式拦截请求，记录每个请求的信息，包括请求用户，请求时间，请求参数以及执行结果等，有了这些请求数据，就可以进行统计分析，得出系统是否存在性能瓶颈。也可以统计出什么用户对什么功能的使用最频繁，什么功能几乎没有人使用。
2.1 注解代码 切面采用根据注解判断是否需要拦截方法的调用，所以首先需要创建一个自定义注解。
package com.ruoyi.common.annotation; import com.ruoyi.common.enums.BusinessType; import com.ruoyi.common.enums.OperatorType; import org.springframework.web.bind.annotation.ResponseBody; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; // 事件埋点 @Target({ElementType.PARAMETER, ElementType.METHOD})//作用在参数和方法上 @Retention(RetentionPolicy.RUNTIME)//运行时注解 @Documented//表明这个注解应该被 javadoc工具记录 // @ResponseBody//响应时转JSON格式 public @interface EventTrack { /** * 模块 */ public String title() default ""; /** * 功能 */ public BusinessType businessType() default BusinessType.OTHER; /** * 操作人类别 */ public OperatorType operatorType() default OperatorType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c2f00e934e29e8bf6f5f72433181b2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df7298e0db012b1ec902b376f290923/" rel="bookmark">
			对齐填充@Contended
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对齐填充Padding（不够64字节用0填充）是用来解决伪共享问题，保证一个缓存行只读取一个数据，避免多个线程竞争同一个缓存行带来性能问题。
伪共享 CPU缓存是由多个缓存行组成的，缓存行是CPU和内存之间交互的最小单元，每个缓存行大小是64个字节，每次CPU读取数据以块为单位64个字节，一次读取一块数据（猜想上下位的数据也是需要的），避免多次交互，一个缓存行可以缓存多个数据（比如：X， Y， Z三个数据），当多个线程情况下，如果线程A修改数据X，线程B需要修改数据Y，但是都处于同一个缓存行，这时候会存在缓存行竞争，如果线程A获取到缓存行，那么线程B缓存行失效，修改数据会失败，如果线程B竞争到缓存行，线程A修改数据会失败，这样会多次请求失败，影响性能，这就是伪共享问题。
对齐填充代码演示 将下面类中数据对象由ValueNoPadding改成ValuePadding，我们会发现执行效率会高很过
public class ShareExample implements Runnable{ public final static long ITERATIONS = 500L * 1000L * 100L; private int arrayIndex = 0; private static ValueNoPadding[] longs; //没有填充的对象数组 public ShareExample(final int arrayIndex) { this.arrayIndex = arrayIndex; } public static void main(final String[] args) throws Exception { for(int i = 1; i &lt; 10; i++){ System.gc(); final long start = System.currentTimeMillis(); runTest(i); System.out.println(i + " Threads, duration = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3df7298e0db012b1ec902b376f290923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3e3fe92402bec21f0e6deb97d319275/" rel="bookmark">
			Android Studio教程从JDK环境配置到AS安装及常用设置（图文详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 JDK JDK官网下载需要账号，可直接点击下载 ： java8u201
新版Android Studio可以不安装JDK，可省略
下载完双击安装 默认会下载JRE(Java运行环境)
配置JDK环境变量 右键此电脑/计算机，点击属性，点击高级设置 点击环境变量，在系统变量中新建 JAVA_HOME
在系统变量中找到path变量，点击编辑-新建：%JAVA_HOME%\bin ，%JAVA_HOME%\jre\bin （直接copy）。添加到path变量中，之后点击确认。
测试是否配置成功：打开cmd（命令提示符）,分别输入Java，java
安装Android Studio 下载地址
点击下载最新版本，选择其他版本（DOWNLOAD OPTIONS），我直接下的最新的3.4
下载完成，点击安装 点击Next，下个界面继续Next，自定义安装路径或者默认
创建快捷方式（默认就行），继续等待安装 安装完成，勾选上start Android Studio 点击Finish 分别是设置为之前版本 ，自定义设置，不进行设置，勾选Do not import settings 点击Ok 点击 send usage statistics to Google （允许google收集数据）
没有Android SDK，点击Cancel
设置类型，默认就行，点击Next
选择主题 黑色和白色，选择后点击Next
下载android studio 所需要的资源 点击 Finish，等待下载完成
Android Studio 安装完成
AS常用设置 设置字体大小：点击右上角 File–&gt;Settings–&gt;Editor–&gt;Font设置size–&gt;apply–&gt;ok
AS修改快捷键方式：点击右上角 File–&gt;Settings–&gt;KeyMap设置–&gt;apply–&gt;ok
设置代码提示忽略大小写：点击右上角 File–&gt;Settings–&gt;Editor–&gt;General–&gt;Code Completion设置–&gt;apply–&gt;ok
设置自动导包和删包：点击右上角 File–&gt;Settings–&gt;Editor–&gt;General–&gt;Auto Import把下边图片上的勾选上–&gt;apply–&gt;ok
设置成员变量首字母加m，静态变量加首字母s：点击右上角 File–&gt;Settings–&gt;Editor–&gt;Code Style–&gt;java按图片设置–&gt;apply–&gt;ok
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c0cfee96b29f0be876ff7ad77d8da9b/" rel="bookmark">
			解释关于新版 Windows 10/11 产品密钥类型和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您计划将您的系统升级到新版本的 Windows 10 或 11，或者计划完全升级您的 PC 并且担心还必须为新的 Windows 许可证/产品密钥付费，我们建议您进一步研究它并 也许会发现您可以在下一台计算机上使用相同的许可证。
自 Windows 10 发布以来，微软一直在迭代用户可以方便地激活其 Windows 操作系统的方法。 也就是说，有些人可能仍然会感到困惑。 如果你是这些人中的一员，这篇文章可能有助于澄清问题。
今天大眼仔将讨论 Windows 使用的不同类型的产品密钥和许可证，以及它们各自的不同之处。 使用此信息，您可以确定是否需要为新许可证付费，如果需要，您应该购买哪一个？
Windows 11 已激活
Windows 产品密钥与数字许可证 在深入研究各种类型的产品密钥之前，我们想提请您注意激活 Windows 操作系统的两种不同方法。 这可以使用以下任何一种方法来完成：
使用 25 位产品密钥。使用数字许可证。 产品密钥是一个 25 位字母数字代码，您必须将其物理地放入操作系统中才能激活它。 数字许可证几乎是一回事，只是它会自动嵌入到您的操作系统中，您不必手动输入任何信息。
数字许可证会在您的计算机上安装产品密钥，但您不必手动进行。
何时使用 Windows 产品密钥 产品密钥通常用于在以下情况下激活操作系统：
购买预装 Windows 11/10 的新计算机时。从授权零售商处购买 Windows 11/10 的盒装（物理）副本。从授权零售商处购买数字副本。拥有批量许可证或 MSDN 订阅。从 Microsoft Store 购买新的 Windows 操作系统。 何时使用 Windows 数字许可证 数字许可证通常用于以下场景来激活操作系统：
免费升级到较新的操作系统（例如，从 Windows 10 升级到 Windows 11），前提是设备运行的是旧操作系统的正版副本。从 Microsoft Store 购买 Windows 专业版升级（从家庭版）时。在已运行已激活 Windows 操作系统的 PC 上升级到最新的 Windows Insider 版本时。从 Microsoft Store 在线购买正版 Windows。 这是 Windows 操作系统使用的两种激活方法。 但是，这些并未定义产品密钥/数字许可证的类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c0cfee96b29f0be876ff7ad77d8da9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/601d784c579bdc201460ae47ed426836/" rel="bookmark">
			UML之用例图，类图，时序图，活动图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用例图
用例图是用于描述系统在某个系统边界下需要提供的功能的图例描述，是对用户与系统进行交互的动作的表述。用例图描述了用户、需求以及系统功能单元之间的关系，主要由参与者，用例和它们之间的关系组成。
用例图需要的因素：
参与者(Actor)：使用系统功能的人或者团体，用小人表示，参与者可以继承，用空三角表示
系统边界：用于确定用例的使用场景，用例图必须在系统边界中设计才有意义，用矩形表示
用例：用户与系统之间的交互行为，一般是用户做的某件事，用椭圆表示，注：每个用例都得是动宾结构(动词+名词)
关系：用例与参与者之间的关系可以通过无向线或者有向线表示，表示用例使用了该功能。用例与用例之间也存在关系，包括依赖&lt;&gt;和扩展&lt;&gt;。
&lt;&gt;表示两个用例必须都执行如下图，在支付时必须输入密码整个操作才算完成。
&lt;&gt;表示对扩展用例在功能上的扩充，但不必非得执行。如下图，在支付方式上进行了扩充，这两个方式不一定要选择。
一般在绘制用例图时，首先需要找到使用系统的人或者组织作为参与者，然后再某个使用场景中分析参与者与系统之间的交互，找出参与的用例(一般为某个系统提供的功能)，用例可以有不同的粒度，但不建议太小，尽量有一定的抽象性。最后将用例与参与者连接起来。
用例描述：再使用用例图时有必要对某个用例的使用场景进行详细描述，其过程就是对用例的具体操作过程进行描述，包含必要的分支情况。例描述一般包括：简要描述（说明）、前置（前提）条件、基本事件流、其他事件流、异常事件流、后置（事后）条件等等。简要描述：对用例的角色、目的的简要描述；
前置条件：执行用例之前系统必须要处于的状态，或者要满足的条件；
基本事件流：描述该用例的基本流程，指每个流程都“正常”运作时所发生的事情，没有任何备选流和异常流，而只有最有可能发生的事件流；
其他事件流：表示这个行为或流程是可选的或备选的，并不是总要总要执行它们；
异常事件流：表示发生了某些非正常的事情所要执行的流程；
后置条件：用例一旦执行后系统所处的状态
类图
类图（Class Diagram）是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型，是唯一的可以直接映射到面向对象语言的图。
类图的绘制主要包括类名，属性，操作以及类之间的关系(类名要有大写，对象图中名称要用冒号：将对象名与所属的类名分开且有下划线如：马云:企业家)。属性或方法前的符号表示可见性，加号表示公有，减号表示私有，井号表示保护，波浪线表示默认方法。属性的格式为+name:String，方法的格式为+setName():void。
类间的关系常见的有以下几种关系: 继承或泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)
继承：表示类与类之间的继承关系，接口与接口之间的继承关系，是 is-a 的关系，使用空心三角形+实线表示
实现：表示一个class类实现interface接口（可以是多个）的功能，使用空心三角形+虚线表示。有的接口也如右图表示
依赖（Dependency）：是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。
关联（Association）：关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。
关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。
在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。如瞎图所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。
聚合（Aggregation）：是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。
组合（Composition）：也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 contains-a 关系。
在组合关系中，整体对象与部分对象的生命周期相同，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。
在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。
时序图
时序图(Sequence Diagram)，又名序列图，是一种UML交互图。它通过描述对象间发送消息的时间顺序显示多个对象之间的动态协作。
时序图会涉及7种元素：角色(Actor)、对象(Object)、生命线(LifeLine)、控制焦点(Activation)、消息(Message)、自关联消息、组合片段。
角色：以一个小人图标表示
对象：位于时序图的顶部,以一个矩形表示。对象的命名方式一般有三种，对象名：类名，对象名或只有类名如:类
生命线：对象下方的虚线
控制焦点：代表时序图中在对象时间线上某段时期执行的操作。以一个很窄的矩形表示。
消息：对象之间传递信息，是通过调用对方的方法实现的。如A给B发送消息是A通过调用B的方法来实现的。发送消息用实线加箭头表示，返回消息用虚线加箭头表示。
自关联消息：表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。
组合片段：对于像分支，并行等操作，可以通过组合片段来表示。这种方式使用的较少。
活动图
UML活动图是UML的动态模型的一种图形，一般用来描述相关用例图。活动图实质上就是流程图，其描述了一系列动作之间的流程。活动图描述满足用例要求所要进行的活动以及活动间的约束关系，是一种表述过程基础、业务过程以及工作流的技术。它可以用来对业务过程、工作流建模，也可以对用例实现甚至是程序实现来建模。
活动图包括一些额外的功能如分支，平行流，泳道等。
在绘制活动图，我们应该确定以下要素：
活动：对象要执行的动作，
交互：动作之间的连接
条件：活动进行过程中可能会有分支，需要进行判断
泳道：活动图中会有不同的参与者，为每个参与者划分一个泳道，用于区分动作时谁执行的
平行流：再一个活动图中，部分活动可以同时发生。并行有开始就得有汇聚
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e358a98afe925d9a2307791b6e6d7752/" rel="bookmark">
			vue当中key的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、key是唯一标识符
2、key的作用主要是为了更高效的对比虚拟DOM中的某个节点是否是相同节点。
3、提高性能
4、理想中的key值最好是唯一的id，key的优点是跟踪每个节点的身份，从而重用和重新排序现有元素（key主要是为了排序，重用，排序）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71fc4db8a855e56a08f7943eef9fadf5/" rel="bookmark">
			ValueError: Shapes (None, 1) and (None, 2) are incompatible
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本人，在使用tf2.4做文本二分类的时候出现一个错误：
ValueError: Shapes (None, 1) and (None, 2) are incompatible
中文是：ValueError:形状(无，1)和(无，2)不兼容
代码如下：
'''构造LSTM网络''' def build_lstm_model(self): model = Sequential() model.add(LSTM(32, return_sequences=True, input_shape=(self.max_length, self.embedding_size))) model.add(LSTM(32, return_sequences=True)) model.add(LSTM(32)) model.add(Dense(2, activation='softmax')) model.compile(loss='categorical_crossentropy', optimizer='rmsprop', metrics=['accuracy']) return model 解决方法：
从文档中: https://keras.io/layers/recurrent/
LSTM层需要 3D张量的形状(batch_size，时间步长，input_dim).
model.add(Dense(2, activation=‘softmax’))-这表明您正在执行多类分类.
因此，您需要将y_train和y_test进行一次热编码.这意味着它们必须具有尺寸(number_of_samples, 2)，其中2表示类数.
您需要对它们应用tensorflow.keras.utils.to_categorical.
y_train = to_categorical(y_train, 2) y_test = to_categorical(y_test, 2) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d98cd6fde2db32176c24d2fc9b6e9eb/" rel="bookmark">
			树莓派 | “start4.elf: is not compatible” 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果树莓派刷写系统后出现如下问题：
start4.elf: is not compatible
This board requires newer software
此时可以前往如下网址，下载最新固件包。
https://github.com/raspberrypi/rpi-firmware
下载的固件包中包含很多文件，其中boot路径下为需要的部分。
如果使用SD卡加载文件，只需利用读卡器读取SD卡，进入boot盘中，将固件替换为最新的内容即可。
开机提示某一文件不可用，则将该start-*.elf与fixup-*.dat文件一同替换。即如果提示start4.elf不可用，则将系统的boot盘中的start4.elf与fixup4.dat用下载的最新固件包中的相同文件替换即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7dea7c5c8fdb91c08506d6d2d33e3f5/" rel="bookmark">
			CAD批量打图精灵10.0入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在工程制图中，往往有大量的图纸需要打印或转为PDF，可能是一个dwg文件里有多张图纸，或是多张图纸分散于多个dwg文件。常规的打印方法是，逐个手工框选打印，操作单调且费时。有没有更好的方法呢？CAD批量打图精灵应运而生，可快速自动地识别正矩形图框并打印或转为PDF。
安装 安装CAD批量打图精灵，需先安装 AutoCAD 2007 或更高版本，然后到依云软件官网下载打图精灵最新版，运行安装程序一路点“下一步”（可自行选择安装文件夹），最后点“完成”完成安装。安装pdfFactory虚拟打印机（可选，pdfFactory虚拟打印机可将图纸打印为PDF文件，也可做预览用途），安装打图精灵即将完成时会提示是否安装 pdfFactory 虚拟打印机，可选择“是”安装之；若没有选择安装，在后续想要安装，安装方法见安装pdfFactory虚拟打印机。 安装CAD批量打图精灵后，重新打开AutoCAD，以下菜单之一会显示在AutoCAD中。若菜单没有显示，在CAD命令行输入“IMYS”命令可修复。
传统菜单（AutoCAD经典工作空间）：
带式菜单，位于“附加模块”或“插件”标签下，若没有上述标签则位于“依云”标签：
在 AutoCAD 2020 中的截图：
在 AutoCAD 2010 中的截图：
打印单个CAD全部图纸 在CAD中输入“QP”，打开打图精灵，选择“pdfFactory Pro”虚拟打印机，可选择纸张大小等，不勾选“打印到文件”选项，将图纸打印到pdfFactory：
还可使用的虚拟打印有：Yiyun Print To PDF.pc3、DWG To PDF.pc3（CAD自带）、Adobe PDF，更多虚拟打印机的介绍见常用打印机及设置。
注意1：若要在打印完成后预览或删除PDF某些页面等，请选择“pdfFactory Pro”打印机，且不要勾选“打印到文件”选项；若勾选“打印到文件”将自动保存PDF文件后自动关闭pdfFactory！
注意2：若要在实体打印机上直接打印，请选择相应的实体打印机，且不要勾选“打印到文件”选项；若勾选“打印到文件”则通常打印为PLT文件！
打印单个CAD部分图纸 若仅想打印单个CAD中的部分图纸或图框外有其他图形，则打印范围选择“部分区域”，选择要打印的单张或多张图纸所在区域，也可仅选择外侧图框（更精确），点“部分区域打印”即可开始打印。
将多个CAD文件转换为多个PDF 典型需求：有多个CAD文件，每个文件里有多张图纸，需将每个文件转成一个多页PDF文件，保存到图纸对应目录，PDF文件名同CAD文件名。
操作如下：打开打图精灵，打印机选“pdfFactory Pro”，勾选“打印到文件”，切换到“多文档打印标签”下，拖放带打印CAD文件到多文档打印列表，点“打印”即可开始打印即可，每打印完一个CAD文件后，打图精灵将自动保存PDF文件。
另外也可以使用“Yiyun Print To PDF.pc3”或“DWG To PDF.pc3”打印机，勾选“合并PDF”选项，可将单个CAD文件转换为单个多页PDF文件。
将每页图纸转换为单个PDF文件 使用“Yiyun Print To PDF.pc3”或“DWG To PDF.pc3”打印机，不勾选“合并PDF”选项，可将一张图转换为一个PDF文件，若有多个CAD图纸，则将每个CAD文件里的多张图纸放到一个文件夹下。
图框识别原理 软件识别图框通常本质上是识别矩形（单图模式除外），且默认设置下不考虑矩形大小都识别为图框，
若被其他矩形包含，则只识别最外层的矩形，允许矩形有一定的瑕疵，矩形可由由直线、多段线、二维多段线、面域、视口、代理实体、块参照或外部参照组成。
确认图框 默认情况下，“确认图框”处于半勾选状态，只有当识别到的图框数超过100个时才会提示是否打印；
若要总是确认图框则可点“确认图框”后的按钮，不勾选“条件确认”，只勾选“确认页数”：
还可勾选“标记图框”，当同时勾选“确认图框”时，打图精灵识别图框完成后提示是否打印，若点“否”后将仅标记图框及打印顺序而不打印，更多有关确认图框的说明见确认图框信息报表。
图框标记处于“非打印层”不会被打印，可通过 RQP 命令一次性清除全部图框标记。
当图框识别有误时可尝试在“标准”、“快速识别”、“深度识别”三种识别模式下切换。
打印部分图纸并标记图框使用演示：
安装pdfFactory虚拟打印机 虚拟打印机可将图纸转换为PDF，找到打图精灵应用程序文件夹，即安装打图精灵选择的安装路径，默认路径在“C:\Program Files\Yiyunsoftware QuickPlot”，也看通过下面的方法找到应用程序文件夹：系统“开始”菜单→“所有应用”→“依云CAD批量打图精灵” →“应用程序文件夹”。找到后运行“pdfFactory3_52.exe”安装虚拟打印机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d77316d42ee2c52fe4d45f73432ca92/" rel="bookmark">
			牛吃草问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概述 最近碰到一个面试题，讲的是牛吃草的问题，当时时间短，脑袋出现了短路，没有给出答案。回来特意查了一下答案，发现了一篇比较好的文章，现在重新抄写一份，用以加深印象。
1、牧场上有一篇匀速生长的草地，可供27头牛吃6周，或者供23头牛吃9周，那么它可供21头牛吃几周？要求不列方程式~
先思考：这个问题的难点在于，草的总量每天都在变，时间越长，草的总量就越多。草的总量是由2部分组成：某个时间期限前草场上原有的草量；这个时间期限后草场每天生长而新增的草量。
结题：
假设 1 头牛每周吃的量为 1份，则
23 头牛 9 周吃的总草量为： 23 * 9 = 207 份
27 头牛 6 周吃的总草量为： 27 * 6 = 162 份
所以每周新生长的草量为：（207-162）% (9-6) =15份
每周新生长的草，可以够15头牛一直吃下去~
牧场上原有的草：23 * 9 - 15*9 = 72 份
牧场上的草21头牛几周能吃完呢？把这个问题分成2部分：一部分专吃牧场原有的草，另一部分专吃新生长的草。
让15头牛吃新生长的草，这样就可以一直吃下去，让剩下的6头牛吃原有的草，这样原有的草吃完了，就是能吃多少周的周数。
72%6 = 12，即12周。
看完是不是感觉自己会了？来继续，加强锻炼~
2、由于天气变冷，牧场上的草每天以均匀的速度减少。已知某草地上的草可供 20 头牛吃 5 天，或供15头牛吃 6 天。那么他可供多少头牛吃10天？
假设1 头牛一天吃 1份，则：
20 头牛5天的总草量： 20 * 5 = 100 份
15 头牛6天的总草量：15 * 6 = 90 份
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d77316d42ee2c52fe4d45f73432ca92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb6ef9cea2a1938515bf8827dffe4ba/" rel="bookmark">
			数据结构之哈夫曼树（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、哈夫曼树的概念 给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
该代码的核心在于弄懂如何构建哈夫曼树和生成哈夫曼树编码。主要通过找出两个最小值开始作为最底端叶节点，由下到上构建出哈夫曼树。
二、代码步骤 1、定义二叉树和字符指针数组
2、二叉树的初始化
3、查找最小两个值的下标（min1&lt;min2)
4、构建哈夫曼树
5、生成哈夫曼树编码
6、测试代码
7、程序入口
8、运行结果
三、代码功能 1、定义二叉树和字符指针数组 typedef struct HTNode { double weight; int parent; int lc, rc; }*HuffmanTree; typedef char **HuffmanCode; 2、二叉树的初始化 HuffmanTree initHuffmanTree(HuffmanTree&amp; HT,int n) { int i; int m = 2 * n - 1; HT = (HuffmanTree)malloc(sizeof(HTNode)*(m + 1)); for(i = 0; i &lt;= m; i++) { HT[i].lc = 0; HT[i].parent = 0; HT[i].rc = 0; HT[i].weight = 0; } return HT; } 3、查找最小两个值的下标（min1&lt;min2) void Select(HuffmanTree&amp; HT, int n, int&amp; min1, int&amp; min2) { int min; for (int i = 1; i &lt;= n; i++) { if (HT[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb6ef9cea2a1938515bf8827dffe4ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36150dca010cc14b2a5dae9ae3b74f9c/" rel="bookmark">
			【Vue】Vue组件或页面中查看当前Vm对象的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;script&gt; export default { name: "MyItem", data() { return { menuName: ["★", "头像名称修改", "&gt;"], }; }, methods: { m_click(m_id) { this.changChecked(m_id); }, delete_click(m_id) { this.deleteChecked(m_id); }, }, mounted() { console.log('MyItem',this); }, }; &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d5f9d56cfd872b3d8a4fda413c3ee4/" rel="bookmark">
			【C语言编程5】复数计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言编程 本程序的功能是一个简单的复数计算器
功能包括复数的乘法，复数的除法，复数的模计算
乘法法则
复数的乘法法则：把两个复数相乘，类似两个多项式相乘，结果中i^2= -1，把实部与虚部分别合并。两个复数的积仍然是一个复数。
除法法则
复数除法定义：满足 的复数 叫复数a+bi除以复数c+di的商。
运算方法：将分子和分母同时乘以分母的共轭复数，再用乘法法则运算，
即（分母实数化）。
复数的模
将复数的实部与虚部的平方和的正的平方根的值称为该复数的模，记作∣z∣.
代码如下
#include&lt;stdio.h&gt; #include&lt;math.h&gt; //复数计算器 double a, b, c, d, e, f; void multi()//复数乘法 { printf("输入第一个数的实部\n"); scanf("%lf", &amp;a); printf("输入第一个数的虚部\n"); scanf("%lf", &amp;b); printf("输入第二个数的实部\n"); scanf("%lf", &amp;c); printf("输入第二个数的虚部\n"); scanf("%lf", &amp;d); e = a * c - b * d; f = a * d + b * c; printf("等于%lf + i%lf\n", e, f); } void div()//复数除法 { printf("输入第一个数的实部\n"); scanf("%lf", &amp;a); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d5f9d56cfd872b3d8a4fda413c3ee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06789b2c4ae55989e911f790b68cc59/" rel="bookmark">
			python数据分析之pandas软件包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建新文件
引用pandas软件包 #pd是pandas简写 import pandas as pd 创建excel文件 df.to_excel('文件路径') 列名索引 df.set_index('列名') 写入数据（默认为空） pd.DataFrame('列名1':['数据1','数据2','数据3'],'列名2':['数据1','数据2','数据3']) 写入excel,运行 print('Done!') 读取数据 读取excel的行数和列数 print(df.shape) 读取列名 print(df.columns) 读取前x行数据 print(df.head(x)) 读取后x行数据 print(df.tail(x)) 设置头部信息 df.columns['列名1','列名2','列名3'] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e149d498763c574fda9f1f31f1530970/" rel="bookmark">
			windows10系统下以管理员身份进入CMD（命令提示符）的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：鼠标右键点击win---点击windows powershell（管理员）（A）
方法二：点击win---在搜索框中输入命令提示符---点击以管理员身份运行
方法三：点击键盘win+r---在弹出的运行框中输入cmd---按住键盘shift+ctrl+回车（注意直接按回车进入的是用户端窗口）
分辨用户端还是管理员端如下：
用户端：
管理员端：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242b41481993407f6a763cfb43981f3b/" rel="bookmark">
			python https请求报错：SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python爬虫，使用requests库发送https请求报错：SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED]
解决办法：
凡是requests的参数内添加如下代码：
import logging import requests logging.captureWarnings(True) # 去掉建议使用SSL验证的显示 header = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1', } wb_data = requests.get(url, headers=header, verify=False) # 去掉https 的验证 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6820c5b53e3ddb5175fb2f25872505/" rel="bookmark">
			人工智能基础 作业5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		For循环版本：手工实现 卷积-池化-激活 import numpy as np x = np.array([[-1, -1, -1, -1, -1, -1, -1, -1, -1], [-1, 1, -1, -1, -1, -1, -1, 1, -1], [-1, -1, 1, -1, -1, -1, 1, -1, -1], [-1, -1, -1, 1, -1, 1, -1, -1, -1], [-1, -1, -1, -1, 1, -1, -1, -1, -1], [-1, -1, -1, 1, -1, 1, -1, -1, -1], [-1, -1, 1, -1, -1, -1, 1, -1, -1], [-1, 1, -1, -1, -1, -1, -1, 1, -1], [-1, -1, -1, -1, -1, -1, -1, -1, -1]]) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e6820c5b53e3ddb5175fb2f25872505/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e146d5a594d54fff36bd6fd49e17fa/" rel="bookmark">
			scatter_ 做 one-hot的一些要注意的点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.
如当label_map的范围是[0,19]
one-hot的通道大小为 torch.FloatTensor(bs,20,h,w)
一般label_map经过transfrom后，通过totensor操作，压缩到了[0,1]的范围，然后要再执行两步
label = label*255.0 （因为label不需要压缩到[0，1]， 还是要恢复到[0,19]
label [label==255] = 20 这一步是排除一些图像中的不关系的像素，按道理来说label*255.0后不会得到255这个结果的，如果得到了就赋值为20，新的标签，意味着一个不相关的通道，但往往这一步是无效的，不会有==255的像素，也就不会被赋值为20
2.
今天把Label_map输入到transform再输出，发现label_map的最大值从19变成了20，后来发现是插值的问题,resize插值的时候用的Image.BICUBIC,然后插值之后的结果就改变了，换成Image.BILINEAR就可以了
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/72/">«</a>
	<span class="pagination__item pagination__item--current">73/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/74/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>