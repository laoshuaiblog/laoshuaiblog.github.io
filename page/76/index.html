<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d48c5e19c53ec2efdde640d19f873ba/" rel="bookmark">
			前端Vue使用封装Mock.js和api请求模拟数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mock的使用改进，可参考上一篇文章mock的使用 1) mock.js // mock.js 文件 import Mock from 'mockjs' // 引入mockjs const Random = Mock.Random // Mock.Random 是一个工具类，用于生成各种随机数据 const dataList = [] // 用于接受生成数据的数组 for (let i = 0; i &lt; 26; i++) { // 可自定义生成的个数 const template = { 'id': i, // id 'Name': Random.name(), // 生成姓名 'Address': Random.province() // 生成地址 } dataList.push(template) } import axios from 'axios' // 模拟分页 Mock.mock('http://localhost:8080/api/list', 'post', (params) =&gt; { var listQuery = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d48c5e19c53ec2efdde640d19f873ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66f750cec154bce2f74054edd5cb46c/" rel="bookmark">
			使用 LSTM 进行多变量时间序列预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们先来了解两个主题：
什么是时间序列分析？
什么是 LSTM？
时间序列分析：时间序列表示基于时间顺序的一系列数据。它可以是秒、分钟、小时、天、周、月、年。未来的数据将取决于它以前的值。
在现实世界的案例中，我们主要有两种类型的时间序列分析：
单变量时间序列
多元时间序列
对于单变量时间序列数据，我们将使用单列进行预测。
正如我们所见，只有一列，因此即将到来的未来值将仅取决于它之前的值。
但是在多元时间序列数据的情况下，将有不同类型的特征值并且目标数据将依赖于这些特征。
正如在图片中看到的，在多元变量中将有多个列来对目标值进行预测。（上图中“count”为目标值）
在上面的数据中，count不仅取决于它以前的值，还取决于其他特征。因此，要预测即将到来的count值，我们必须考虑包括目标列在内的所有列来对目标值进行预测。
在执行多元时间序列分析时必须记住一件事，我们需要使用多个特征预测当前的目标，让我们通过一个例子来理解：
在训练时，如果我们使用 5 列 [feature1, feature2, feature3, feature4, target] 来训练模型，我们需要为即将到来的预测日提供 4 列 [feature1, feature2, feature3, feature4]。
LSTM
本文中不打算详细讨论LSTM。所以只提供一些简单的描述，如果你对LSTM没有太多的了解，可以参考我们以前发布的文章。
LSTM基本上是一个循环神经网络，能够处理长期依赖关系。
假设你在看一部电影。所以当电影中发生任何情况时，你都已经知道之前发生了什么，并且可以理解因为过去发生的事情所以才会有新的情况发生。RNN也是以同样的方式工作，它们记住过去的信息并使用它来处理当前的输入。RNN的问题是，由于渐变消失，它们不能记住长期依赖关系。因此为了避免长期依赖问题设计了lstm。
现在我们讨论了时间序列预测和LSTM理论部分。让我们开始编码。
让我们首先导入进行预测所需的库：
import numpy as np import pandas as pd from matplotlib import pyplot as plt from tensorflow.keras.models import Sequential from tensorflow.keras.layers import LSTM from tensorflow.keras.layers import Dense, Dropout from sklearn.preprocessing import MinMaxScaler from keras.wrappers.scikit_learn import KerasRegressor from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b66f750cec154bce2f74054edd5cb46c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3cf7fcbfd3b8cb770c300324546276a/" rel="bookmark">
			Verilog入门设计（三）——组合电路和逻辑电路的仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字电路仿真 一、测试平台（Test Bench）1、测试程序一般结构2、激励信号产生方式举例2.1 initial语句产生激励信号2.2 always语句产生激励信号 二、组合电路的仿真1、8位乘法器的仿真2、8位加法器的仿真3、2选1数据选择器的仿真 三、时序电路的仿真8位计数器的仿真 一、测试平台（Test Bench） 测试平台的作用是给我们的设计进行验证，通过给被测试模块施加激励信号，观察其输出，然后判断其逻辑功能与时序关系正确与否来判断这个设计是否符合需求。
从图中可以看出，测试模块向待测木块施加激励信号，激励信号必须定义为reg类型，以保持其信号值。待测模块在激励作用下产生输出，输出信号必须定义为wire型。测试模块将输出信息按规定的格式以文本或图形输出，供用户检测。
1、测试程序一般结构 module 仿真模块名；//无端口列表 数据类型说明 //其中激励信号定义为reg类型，输出信号定义为wire类型 parameter、integer等定义 待测模块调用 激励向量定义（always、initial结构等，if-else/for/case/while/repeat/disable等控制语句） 显示格式定义（$monitor、$display、$time等） endmodule 测试模块只有模块名，没有端口列表；输入信号（激励信号）必须定义为reg型，以保持其信号值；输出信号（显示信号）必须定义为wire型；在测试模块中调用待测试模块，在调用时应注意端口排列的顺序与模块定义时一致；一般用always、initial等过程快来定义激励信号，使用系统任务和系统函数来定义输出格式；在激励型号的定义中，可使用如下一些控制语句：if-else, for,forever,case,while,repeat,wait,disable,force,release,begin-end,fork-join等，这些控制语句一般只用在always、initial、function、task等过程快中。 2、激励信号产生方式举例 2.1 initial语句产生激励信号 `timescale 1ns/100ps module test1;	//定义模块名 reg A,B,C;	//定义输入输出端口，本例只有输入端口，声明为reg类型 initial begin A=0;B=1;C=0; #10 C=1;	//#n表示延迟10个时间单位，时间单位由timescale确定，本例中一个时间单位为1ns，精度为100ps。#10表示延迟10ns #10 A=1;B=0; #10 A=0; #10 C=0; end initial $monitor($time,,,"A=%d,B=%d,C=%d",A,B,C);	//显示 endmodule 2.2 always语句产生激励信号 例1:
`timescale 1ns/1ns module always_clk; reg clk; parameter CYCLE=100; always #(CYCLE/2) clk=~clk; initial clk=1; initial $monitor($time,,,"clk=%d",clk); endmodule 例2:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3cf7fcbfd3b8cb770c300324546276a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e68e21537b01df1983586c47078737d0/" rel="bookmark">
			python项目中的self到底是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家学Python面向对象的时候，总会遇到一个让人难以理解的存在：self
这个self到底是谁啊，为什么每个类实例方法都有一个参数self，它到底有什么作用呢？
「先下结论：类实例化后，self即代表着实例（对象）本身」
想要理解self有个最简单的方法，就是你把self当做「实例（对象)的身份证。」
Python的类不能直接使用，只有通过创建实例（对象）才能发挥它的功能，每个实例（对象）都是独一无二的，它可以调用类的方法、属性。类就像灵魂附体一样，让实例（对象）有了自己（self）的功能。
初学者会发现，类的方法（构造方法和实例方法）中都会有一个固定参数self，其实这个参数就是代表着实例（对象）本身，就像是一个身份证，实例可以凭着身份证去调用类方法。
类比人类，人类就是一个Python类，每个个体的人代表着实例（对象），而每个人的身份证代表的Python中self，每个人可以凭借身份证去上大学、坐高铁、住酒店...（方法），而Python中的实例（对象）也可以凭着self去调用类的方法。
上面是用类比的方法解释了下self的含义，说到底self就是代表着实例本身，「当某个实例（对象）调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，而这第一个参数就是self。」
而且self只是约定俗成的写法，你可以用任何其他名称代替self，不会改变代码含义，只不过我们一般不这样做。另外，搜索公众号顶级架构师后台回复“面试”，获取一份惊喜礼包。
为了更好的说明self的作用，我们来举个例子，下面有一个Students类：
class Students: # 构造方法 def __init__(self,name): self.name = name # 实例方法 def study(self,examination_results): self.examination_results = examination_results print("同学{}的考试分数是{}".format(self.name,self.examination_results)) print("该实例对象的地址是{}".format(self)) 先来个实例student_a
studend_a = Students('studend_a') print(studend_a.name) ❝ 结果打印出：studend_a
❞ 再来个实例student_b
studend_b = Students('studend_b') print(studend_b.name) ❝ 结果打印出：studend_b
❞ 可以看出，实例（对象）不一样，打印出的结果也不一样，当类被实例化后，self.name其实就等于实例（对象）.name
还是以刚刚的代码为例，我们再来调用里面的实例方法，里面会打印出self，就能看得更加明显了
实例student_a：
studend_a = Students('studend_a') print(studend_a.study(80)) 输出结果：
❝ 同学studend_a的考试分数是80 该实例对象的地址是&lt;「main」.Students object at 0x00000129EB0F6A90&gt;
❞ 实例student_b：
studend_b = Students('studend_b') print(studend_b.study(80)) 输出结果：
❝ 同学studend_b的考试分数是80 该实例对象的地址是&lt;「main」.Students object at 0x00000129EB0F6B38&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e68e21537b01df1983586c47078737d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2936dbbd2b110c3250d8f54bb6638a81/" rel="bookmark">
			Verilog入门设计（一）——基本组合电路设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、门电路
1、基本门电路
图1 门电路 基本门电路的几种描述方法： （1）门级结构描述 module gate1(a,b,c,d,f); input a,b,c,d; output f; nand(s1,a,b); and(s2,b,c,d); or(f,s1,s2); endmodule （2）数据流描述
module gate2(f,a,b,c,d); input a,b,c,d; output f; assign f=(~(a&amp;b))|(b&amp;c&amp;d); endmodule （3）行为描述
module gate3(f,a,b,c,d); input a,b,c,d; output f;reg f; always@(a or b or c or d) begin f=(~(a&amp;b))|(b&amp;c&amp;d); end endmodule 2、三态门
三态：即高电平、低电平和高阻态。三态门是普通门的基础上加上控制端构成的，在需要信息传输的地方，三态门是必须的。下面以几种方式描述三态门。
图1 三态门 (1)行为描述的三态门 module tri_gate1(out,en,in); input en,in; output out; reg out; always@(en,in) begin if(en) out&lt;=in; else out&lt;=1'bz; end endmodule 当en控制端为高电平时，out=in（即高、低电平态）；当en为低电平时，out为高阻态。
（2）调用门元件bufif1描述的三态门
module tri_gate2(out,en,in); input en,in; output out; tri out; //out声明为tri表示out综合后的电路连接具有三态功能 bufif1(out,in,en);	//三态门端口顺序：输出、输入、控制端 endmodule （3）数据流描述三态门
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2936dbbd2b110c3250d8f54bb6638a81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76eab3a6351b81819e22b31850d98cb3/" rel="bookmark">
			什么才是大型网站项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先问一个问题：hao123 网站访问量很大吧，他是属于大型项目嘛。其实算是半对吧，为什么呢？
这个网站的访问量是非常巨大的，但这样的网站，都是提供了一个静态页面，用户点击是跳转到其他网站，这些网站本身是不具备庞大的数据量的。用户当成一个菜单使用，相当于Web1.0 时代的小型网站。
再看一下京东、淘宝、天猫，这些网站无疑都是大型网站，首先有庞大的访问量，请求量，数据存储量也是非常庞大的，拥有海量数据，并且结合了大数据分析，分析给你推荐的商品等等。
大型网站的特点有很多：
1、高并发，流量大：一个网站从小做到大，业务越多，用户累计越多，访问量就越大。
2、高可用：什么是高可用，就是哪怕服务器宕机了，备用机顶上，确保服务正常访问。
3、大数据：比如阿里租赁服务器，数据多了，就可以做大数据分析，购物推荐，日常生活习惯推荐，图片上传，网站分析图片类型，进行精确的分析。
4、敏捷开发，迭代快：为了提供用户体验，形形色色的需求都会被产品提出，一顿头脑风暴后，探讨出用户体验更好的功能，开发人员需要快速迭代。
5、用户体系庞大：用户分布在全国各地，甚至全球各地
6、可持续升级：所有产品都是逐步演变，循环渐进，从初创不断发展到今天。
7、安全防范：越大的网站，越会遭到黑客攻击，非常的危险。
8、弹性扩展：双十一淘宝访问量剧增，可以通过增加服务器来扩展，从而引导剧增的流量。不需要的时候适当减少服务器即可。
9、吞吐量高，响应速度快：一旦系统访问量变大，会影响响应速度，必须保证用户的体验，这个网站背后可能有上百台服务器。
总结9个特点：
高可用
高并发
大数据
迭代周期短
用户量庞大
可持续发展
安全级别高
可弹性、可伸缩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d6c0f089692ed34d00ed3990f6acf81/" rel="bookmark">
			百度地图路径规划:BDMapSDKException: marker‘s icon can not be null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 通过Android Studio调用百度地图SDK，进行两点之间路径规划，或者进行导航、POI检索。
问题描述 点击Overlay.java:num，定位到 .icon() ：
if (step.getEntrance() != null) { overlayList.add((new MarkerOptions()) .position(step.getEntrance().getLocation()) .rotate((360 - step.getDirection())) .zIndex(10) .anchor(0.5f, 0.5f) .extraInfo(b) .icon(BitmapDescriptorFactory .fromAssetWithDpi("Icon_line_node.png"))); } 点击OverlayManager.java:72，定位到以下代码：
List&lt;OverlayOptions&gt; overlayOptions = getOverlayOptions(); 验证了上面的Overlay类在覆写此方法时出现的错误
因此点击 BikingRouteSearchDemo.java:270 时定位到的代码是
overlay.addToMap(); 因为overlay在实例化时调用getOverlayOptions(); 时出错，所以此处无法进行 .add() 方法。
解决方案： 根本原因在于overlay类覆写getOverlayOptions()时出错，没有找到icon等相关资源，因此解决好icon的资源即可。
具体解决方案为：在app/scr/main下添加包含icon图片资源的assets文件，如图所示：
具体的assert文件可以从百度地图提供的Demo中拷贝。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2b794adb1842adf6859e07544dd739/" rel="bookmark">
			vue3中定义的对象再次赋值，页面不会自动更新解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种方法：将reactive换成ref，即可实现页面随时刷新：
export default { components:{HelloWorld}, name: 'App', setup(){ let person=ref({}) const getPerson= (data)=&gt;{ person.value=data } return { getPerson, person } } } 第二种方法：在定义reactive的时候，定义属性名，在后期赋值的时候，对属性名进行赋值；
export default { components:{HelloWorld}, name: 'App', setup(){ let person=reactive({ message:{} }) const getPerson= (data)=&gt;{ person.message=data } return { getPerson, person } } } 第二种方法：Object.assign()
export default { components:{HelloWorld}, name: 'App', setup(){ let person=reactive({}) const getPerson=(data)=&gt;{ Object.assign(person, data) } return { getPerson, person } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff2c8a1252e0888ce3c2818a407764f/" rel="bookmark">
			二进制乘法运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二进制乘法运算 一、定点数一位乘法1.定点原码一位乘法2.定点补码一位乘3.布斯公式 二、定点数二位乘法1.原码两位乘法2.补码两位乘法 三、阵列乘法器 一、定点数一位乘法 1.定点原码一位乘法 ➢ 乘积的符号为相乘两数符号的异或值，数值则为两数绝对值之积
➢人工计算特点
◆ 乘积位数是乘数的二倍
◆ 相加数逐次向左偏移一位
◆ 前一部分积的最低位不再参与运算
机器计算需要解决哪些问题？
◆ 如何解决多个数据同时相加？
◆ 如何保存2N位乘积结果？
解决方法(1) ◆ 设置寄存器
➢ A寄存器：部分积
➢ B寄存器：被乘数
➢ C寄存器：乘数
解决方法(2) ◆ 每求得一个相加数，就与上次部分积相加
◆ 利用N位加法器实现两个N位数相乘。
➢ 在求本次部分积时，前一次部分积的最低位不再参与运算，因此可将其右移一位。
➢ 乘数最低位用完也没有用处了。乘数寄存器同时右移一位。
◆ A寄存器中保存乘积的高位部分，C寄存器中保存乘积的低位部分。
得出结果：
原码乘法是先取操作数绝对值相乘，符号位单独处理。
2.定点补码一位乘 定点补码一位乘法的规则
设被乘数 [X]补 = X0. X1X2… Xn
◆ 乘数 [Y]补 = Y0. Y1Y2… Yn
◆ 则 [X . Y]补 = [X]补(0. Y1Y2… Yn) - [X]补. Y0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fff2c8a1252e0888ce3c2818a407764f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62bb2c4cb47f0d0679f300e732c1d131/" rel="bookmark">
			音乐指纹识别（三）：波形特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对主流的音频格式进行解析以后，绘制出了声音的波形。一段音频的特征，需要在这段波形中寻找。在这里，会用到一些基础的数学知识，在文中只是简略的用文字进行原理的说明。
在数学中有提到，任何周期函数都可以用正弦函数和余弦函数构成的无穷级数来表示。这段话如果用不太严谨语言，可以这样来理解，对一段的曲线来说，我们都可以用一组正弦曲线和余弦曲线叠加而成。这样一来，曲线就分解为一个一个正弦曲线和余弦曲线的叠加，只要知道主要的正弦和余弦曲线，就能够来表示这一段曲线的特征。
那正弦和余弦我们这么能够来表示曲线的特征呢？
在正弦和余弦中，每一条正弦和余弦都有自己的振幅和频率，振幅和频率就能代表正弦或者余弦的特征。
还有一个问题是需要有无穷多的正弦和余弦来拟合这条曲线，那特征不也是无效多个，在这里我们只取振幅较大的正余弦，也就是这几条正余弦主要构成了这条曲线，这是问题的主因。
寻找曲线的特征变成了选择构成主要正余弦的频率。
在工程中，有时域和频域的不同表示，现在我们需要频率的东西，需要把时域转换到频域中，转换的方法为傅里叶变换。
在实验中，先模拟一条曲线，在通过曲线的数据进行傅里叶变换后，看看能得到什么样的图形。
# -*- coding:utf-8 -*- # /usr/bin/python2.7 import numpy as np from scipy.fftpack import fft,ifft import matplotlib.pyplot as plt import seaborn from matplotlib.font_manager import FontProperties import pylab as pl import numpy as np sampling_rate = 8000 fft_size = 512 # 156.25和234.375HZ组成的曲线 t = np.arange(0, 1.0, 1.0/sampling_rate) x = np.sin(2*np.pi*156.25*t) + 2*np.sin(2*np.pi*234.375*t) xs = x[:fft_size] #进行傅里叶变换 xf = np.fft.rfft(xs)/fft_size freqs = np.linspace(0, sampling_rate/2, fft_size/2+1) #归一 xfp = 20*np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62bb2c4cb47f0d0679f300e732c1d131/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/649b0e344eb94a77e2b4c937bd629d3a/" rel="bookmark">
			B站多线程爬虫，简单好用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import os import threadpool ''' bilibili 视频批量多线程下载 ''' def download(i): try: print('正在多线程下载：',i) os.system(r"you-get https://www.bilibili.com/video/BV1ps411F7T7?p=" + str(i)) except: print('error ' + str(i)) name_list = [x for x in range(0,21)] # name_list = [84,88,90] print(name_list) pool = threadpool.ThreadPool(3) requests = threadpool.makeRequests(download, name_list) [pool.putRequest(req) for req in requests] pool.wait() print('下载结束') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130810971f208b2f37a317960a92a1bb/" rel="bookmark">
			加减法运算及其溢出处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加减法运算及其溢出处理 一、加减法的溢出处理1.溢出的定义2.溢出的判别方法 二、补充知识1.移位2.有符号数和无符号数之间的转换3.不同字长数整数之间的转换4.定点数表示法 一、加减法的溢出处理 1.溢出的定义 ◆当运算结果超出机器数所能表示的范围时。
◆ 与最高位产生的进位区别：自动丢弃。
◆ 什么情况下会产生溢出？
➢ 两个异号数相加或两个同号数相减（不会溢出）
➢ 两个同号数相加或两个异号数相减（可能溢出）
2.溢出的判别方法 （3）fA=0，fB=0，fS=1≠0，故溢出
（4）fA=1，fB=1，fS=0≠1，故溢出
从末尾往前推考虑数值最高位是否进位，符号位是否进位。
（1）fA=0,fB=0,Cf=0（A,B直接运算产生的进位）C=0（数值最高位产生的进位）
（2）fA=1,fB=1,Cf=1（A,B直接运算产生的进位）C=1（数值最高位产生的进位）
（3）fA=0,fB=0,Cf=0（A,B直接运算产生的进位）C=1（数值最高位产生的进位）溢出
（4）fA=1,fB=1,Cf=1（A,B直接运算产生的进位）C=0（数值最高位产生的进位）溢出
（5）fA=0,fB=1,Cf=1（A,B直接运算产生的进位）C=1（数值最高位产生的进位）
（6）fA=0,fB=0,Cf=0（A,B直接运算产生的进位）C=0（数值最高位产生的进位）
例题：
较为推荐第三种方式判断溢出，形式简单记忆方便。三种判别方法只需掌握一种即可。
例题：
二、补充知识 1.移位 推荐补充文章：移位运算用法的总结
1、算数移位 无论正数还是负数，移位后其符号位均不变，且移位后都相当于对真值补0。
2、逻辑移位 将操作数视为无符号数，左移时，低位添0；右移时，高位添0。
补0是相对真值补0，右移是补码右移。
2.有符号数和无符号数之间的转换 符号位上的值直接变成数值
3.不同字长数整数之间的转换 补0的原则是要尽量不改变原有数值，有符号的默认最高位为符号位，符号位要保留单独处理。
4.定点数表示法 我们知道+111和+0.111的原码同为0111，这是因为约定的小数点位置不同，整数的原码小数点约定在末尾，纯小数的原码小数点约定在数值最前面，这样通过约定小数点的位置来表示数的 方法就称为定点数表示法，约定小数点位置实际上就是约定编码中每一位的权重。（对于纯小数来说，小数点在符号位后面，但它不显示也不占位；对于整数来说，小数点就确定在末尾，同样是不显示也不占位）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e1f29e223b5d96ea1d084d0ea581ba2/" rel="bookmark">
			百钱买百鸡问题与百钱兑换问题（C与C&#43;&#43;）经典编程算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百钱兑换问题提供了两种思路，最精彩的在最下面的代码，供大佬参考，优美的代码赏心悦目（附有详细思路，记得点赞！！！）
1.首先，让我们讲讲百钱买百鸡问题
张丘建在《算经》一书中提出的数学问题：‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
1只公鸡5个铜钱，1只母鸡3个铜钱，3只小鸡1个铜钱。现在有100个铜钱，要买100只鸡，每种鸡至少要买一只，问有几种买法？
#include&lt;stdio.h&gt; int main() { int i,j,k;//i为公鸡个数 j母鸡个数 k为小鸡个数 for (i=1;i&lt;=20;i++)//公鸡 for(j=1;j&lt;=33;j++)//母鸡 for(k=1;k&lt;=100;k++)//小鸡 if(100==i*5+j*3+k/3.0 &amp;&amp; k%3==0 &amp;&amp; i+j+k==100) printf("%d,%d,%d\n",i,j,k); return 0; } 思路讲解：这里是假设思想的应用，倘若我买的全为公鸡，则我最多只能买到20只公鸡即100/5=20，所以i&lt;=20;同理若买的全为母鸡则100/3=33余1,s所以j&lt;=33；此处小心小鸡数目不是300，而应该是100，因为题目要求了要买100只鸡,所以k&lt;=100;if条件即三元一次方程组，求i，k，j的值。
2.百钱兑换问题
输入整型人民币数额 n（元），将其兑换成1/2/5分的硬币，有多少种换法？
#include&lt;iostream&gt; using namespace std; int main() { int n,sum=0; cin&gt;&gt;n; for( int i=0;i&lt;=(n*100/5);i++) for( int j=0;j&lt;=(n*100/2);j++) if((n*100-5*i-2*j)&gt;=0) { sum++; } cout&lt;&lt;sum; return 0; } 思路说明：其实质与上面的百钱买鸡实质思想一样，1元最多换20个5分，则n元最多换n*100/5个5分…同时运用了嵌套for循环的方式，算是思路简单的方法。
法二，代码进阶版（需要一定的数学思维）
#include &lt;iostream&gt; using namespace std; int main() { int n, j, sum= 0; cin &gt;&gt; n; j = n * 20;//输入n元最多能得到j个5分（n*100/5）； for ( int i = 1; i &lt;= j; i++)//i是5分的个数 { sum+= 5 * i / 2; } sum+= (j + 1); cout &lt;&lt; sum;//sum种换法 return 0; } 输入：1 输出： 541
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e1f29e223b5d96ea1d084d0ea581ba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc9c170211a9a3c886b97824bda94b9/" rel="bookmark">
			java数据库编程入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JDBC概述
1、JDBC是Java数据库连接技术的简称，提供连接各种常用数据库的能力。
2、JDBC模型
JAVA程序一般通过调用JDBC所定义的类和接口来处理数据库中的数据，也就是通过调用JDBC的驱动程序实现对数据库的操作。 3、JDBC操作数据库过程
基于JDBC的数据库程序设计方法通过三步组成。
(1)首先是连接数据库
(2)然后是执行SQL（Structure Query Language，结构化查询语言）语句并处理查询结果.。
通过执行SQL语句可以处理数据库数据，比如对数据库中的记录进行添加、删除、修改等操作，或者查询满足某种条件的数据等。
(3)最后是关闭连接
二、JDBC四种驱动方式
1、JDBC-ODBC桥加ODBC驱动程序 JDBC-ODBC桥产品利用ODBC驱动程序提供JDBC访问。在服务器上必须可以安装ODBC驱动程序。JDBC-ODBC桥是一个JDBC驱动程序，它通过将JDBC操作转换为ODBC操作来实现JDBC操作。
2、本地API结合Java驱动程序 本地 API Java 驱动程序通过 JDBC 驱动程序将应用程序中的调用请求转化为本地 API 调用，由本地 API 与数据库通信，数据库处理完请求将结果通过本地 API 返回，进而返回给 JDBC 驱动程序， JDBC 驱动程序将返回的结果转化为 JDBC 标准形式，再返回给客户程序。 3、网络纯Java驱动程序 这种驱动程序将 JDBC 转换为与 DBMS 无关的网络协议，之后这种协议又被某个服务器转换为一种 DBMS 协议 。 4、本地协议纯Java驱动程序 驱动程序将 JDBC 调用直接转换为 DBMS 所使用的网络协议。这种驱动与数据库建立直接的套接字连接，采用具体数据库厂商的网络协议把 JDBC API 调用转换为直接网络调用，也就是允许从客户机机器上直接调用 DBMS 服务器，是 Intranet 访问的一个很实用的解决方法。 建议尽可能地使用纯 Java JDBC 驱动程序代替桥和 ODBC 驱动程序，这可以完全省去 ODBC 所需的客户机配置，也免除了被其它插件错误影响数据库连接的可能性。 三、JDBC常用API
JDBC 向应用程序开发者提供独立于某种数据库的统一的API。JDBC API是一系列抽象的接口，它使得应用程序员能够进行数据库连接，执行SQL 声明，并且返回结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc9c170211a9a3c886b97824bda94b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/170263e3046e62ea844951403b4121df/" rel="bookmark">
			明明的随机数Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了NN个11到10001000之间的随机整数(N≤100)(N≤100)，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。
输入格式 输入有两行，第11行为11个正整数，表示所生成的随机数的个数NN
第22行有NN个用空格隔开的正整数，为所产生的随机数。
输出格式 输出也是两行，第11行为11个正整数MM，表示不相同的随机数的个数。
第22行为MM个用空格隔开的正整数，为从小到大排好序的不相同的随机数。
输入输出样例 输入 #1复制
10 20 40 32 67 40 20 89 300 400 15 输出 #1复制
8 15 20 32 40 67 89 300 400 说明/提示 NOIP 2006 普及组 第一题
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int i; int num = 0; int a = scan.nextInt(); if (a &gt; 0 &amp;&amp; a &lt;= 100) { int arr[] = new int[a]; for (i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/170263e3046e62ea844951403b4121df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262efed5c08af6fbe375330785d34295/" rel="bookmark">
			Spring 特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 核心特性数据存储Web 技术Web Servlet 技术栈【Spring 1-4的唯一支持】Web Reactive 技术栈【Spring 5引入】 技术整合（Integration）测试（Testing）Spring 模块化设计Spring 编程模型Ioc 主要实现策略IOC 容器的职责 Ioc 容器的实现传统 IOC 容器的实现Spring 容器概述Spring IOC 依赖查找 Spring IOC 依赖注入Spring IOC 依赖来源Spring IOC 配置元信息 Spring IOC 容器Spring 应用上下文使用 Spring IOC 容器Spring IOC 容器生命周期Spring IOC 容器启动时做了那些准备 核心特性 IOC 容器（Ioc Containers）
Spring 事件（Events）
基于 Java 事件来进行扩展的，但是与 Java 的标准事件有一些区别
资源管理（Resource）
继承自 Java 的资源管理，部分 API 是借鉴了 Java 核心的底层 API 的一个实现
国际化（i18n）
Java 默认就支持国际化，Spring 的国际化也是 Java API 进行实践的
校验（Validation）
整合了 Bean Validation
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262efed5c08af6fbe375330785d34295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1e1f2b7995aa810a1fcaba85149b23/" rel="bookmark">
			React路由V6技术文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React Router 6 快速上手 1.概述 React Router 以三个不同的包发布到 npm 上，它们分别为：
react-router: 路由的核心库，提供了很多的：组件、钩子。react-router-dom: 包含react-router所有内容，并添加一些专门用于 DOM 的组件，例如 &lt;BrowserRouter&gt;等 。react-router-native: 包括react-router所有内容，并添加一些专门用于ReactNative的API，例如:&lt;NativeRouter&gt;等。 与React Router 5.x 版本相比，改变了什么？
内置组件的变化：移除&lt;Switch/&gt; ，新增 &lt;Routes/&gt;等。
语法的变化：component={About} 变为 element={&lt;About/&gt;}等。
新增多个hook：useParams、useNavigate、useMatch等。
官方明确推荐函数式组件了！！！
…
2.Component 1. &lt;BrowserRouter&gt; 说明：&lt;BrowserRouter&gt;用于包裹整个应用。
示例代码：
import React from "react"; import ReactDOM from "react-dom"; import { BrowserRouter } from "react-router-dom"; ReactDOM.render( &lt;BrowserRouter&gt; {/* 整体结构（通常为App组件） */} &lt;/BrowserRouter&gt;,root ); 2. &lt;HashRouter&gt; 说明：作用与&lt;BrowserRouter&gt;一样，但&lt;HashRouter&gt;修改的是地址栏的hash值。备注：6.x版本中&lt;HashRouter&gt;、&lt;BrowserRouter&gt; 的用法与 5.x 相同。 3. &lt;Routes/&gt; 与 &lt;Route/&gt; v6版本中移出了先前的&lt;Switch&gt;，引入了新的替代者：&lt;Routes&gt;。
&lt;Routes&gt; 和 &lt;Route&gt;要配合使用，且必须要用&lt;Routes&gt;包裹&lt;Route&gt;。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f1e1f2b7995aa810a1fcaba85149b23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ac0ab92453a43946e31cdba63a1f11/" rel="bookmark">
			软件测试技术课后习题：第6章单元测试与集成测试-广东高等教育出版社，主编杨胜利
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、什么是单元测试？
2、什么是集成测试？
3、简述单元测试与集成测试的区别。
4、什么是静态测试？
5、什么是动态测试？简述动态测试的步骤。
6、简述驱动模块和桩模块在实际中的应用以及设计原则。
7、单元测试模块检查的内容有哪些？
8、常用的集成测试方案有哪些？各有什么优缺点？
1、什么是单元测试？ 单元测试(Unit Testing)，是指对软件中的最小可测试单元或基本组成单元进行检查和验证。该测试依据为软件详细设计。目的是检查每个软件单元能否正确地实现设计说明中的功能、性能、接口和其他设计约束等要求，发现单元内可能存在的各种差错。
2、什么是集成测试？ ①集成测试(Integrated Testing)，也叫组装测试或联合测试。②是在单元测试的基础上，将所有已通过单元测试的模块按照概要设计的要求组装为子系统或系统，并进行测试的过程。③目的是确保各单元模块组合在一起后能够按既定意图协作运行，并确保增量的行为正确。
3、简述单元测试与集成测试的区别。 从对象上看，单元测试为软件的基本单元（如函数）；集成测试为（多个）模块、（多个）子系统。依据不同，单元测试为软件详细设计；集成测试为概要设计。
空间不同，单元测试为函数或类的内部实现逻辑；集成测试为接口层面的。
技术不同，单元测试为以白盒测试为主、黑盒测试为辅；而集成测试为以黑盒测试为主，白盒测试为辅。
时序不同，单元测试优先，集成测试为后。主体不同，单元测试为程序作者；集成测试为开发人员或专业测试人员。
从测试内容和测试方法两方面看，单元测试和集成测试之间有什么不同？（相关习题）
（1）测试内容不同：
1）单元测试集中于单个模块的功能和结构检验，其测试内容主要包括模块接口、局部数据结构、重要的执行路径、错误处理和边界测试；
2）集成测试集中于模块组合的功能和软件结构检验，其测试内容主要包括模块组装中可能出现的问题，即数据穿过接口可能丢失、一个模块可能破坏另一个模块的内容、子功能组装可能不等于主功能、全程数据结构问题、误差累积问题；
（2）测试的方法不同：
1）单元测试较多地使用白盒测试法，为被测模块设计驱动模块和桩模块；
2）集成测试使用渐增式测试和非渐增式测试，渐增式测试又有分为自顶向下结合法和自底向上结合法；
4、什么是静态测试？ ①静态测试先于动态测试；主要是通过走查、审查等会议方式，依据模块的详细设计，将代码与缺陷检查表进行对照，查看代码是否符合标准和规范。
静态测试内容：检查算法的逻辑正确性。检查模块接口的正确性。检查调用其他模块接口的正确性。检查表达式、语句的正确性。检查常量或全局变量使用的正确性。检查输入参数是否有合法性检查。检查代码执行效率是否可以优化。检查编程风格的规范性。
5、什么是动态测试？简述动态测试的步骤。 动态测试方法是指通过运行被測程序,检查运行结果与预期结果的差异，并分析运行效率、正确性和健壮性等性能。这种方法由三部分组成：构造测试用例、执行程序、分析程序的输出结果。
动态测试的基本步骤为：
（1）选取程序输人定义域的有效值，或选取定义域外的无效值。
（2）决定已选输入值的预期结构。
（3）用选取的输入值执行程序。
（4）比较执行结构和预期结果。
6、简述驱动模块和桩模块在实际中的应用以及设计原则。 在单元测试中进行的测试工作主要从五个方面对被测模块进行检查。
(1）模块接口测试：对通过被测模块的数据流进行测试。为此，对模块接口，包括参数表、调用子模块的参数、全程数据、文件输入／输出操作都必须检查。 (2）局部数据结构测试：设计测试用例检查数据类型说明、初始化、缺省值等方面的问题，还要査清全程数据对模块的影响。
(3）路径测试：选择适当的测试用例，对模块中重要的执行路径进行测试。对基本执行路径和循环进行测试可以发现大量路径错误。
(4）错误处理测试：检査模块的错误处理功能是否包含有错误或缺陷。例如，是否拒绝不合理的输入；出错的描述是否难以理解、是否对错误定位有误、是否出错原因报告有误、是否对错误条件的处理不正确；在对错误处理之前错误条件是否已经引起系统的干预等。
(5）边界测试：要特别注意数据流、控制流中刚好等于、大于或小于确定的比较值时出错的可能性。对这些地方要仔细地选择测试用例，认真加以测试。此外，如果对模块运行时间有要求的话，还要专门进行关键路径测试，以确定最坏情况下和平均意义下影响模块运行时间的因素。这类信息对进行性能评价是十分有用的。
设计原则：
当需要测试被测代码的功能时，不能构造桩模块；使用桩模块，不能影响或约束被测代码的编译条件，即被测代码的编译和执行与桩模块的使用无关；驱动模块对测试数据的使用要可重用，尽量避免对用例执行顺序的依赖。 7、单元测试模块检查的内容有哪些？ 模块接口测试 局部数据结构测试
重要执行路径测试 错误处理测试
边界条件测试
8、常用的集成测试方案有哪些？各有什么优缺点？ 常用的集成测试方案有：自顶向下的集成测试、自底向上的集成测试、三明治集成测试。
自顶向下的集成测试的优点：
1、优先从根节点开始测试，有助于早期实现并验证系统主要功能，给开发团队和用户带来成功的信心，也便于早期验证主要的控制和判断，避免主控程序的缺陷，确保开发进度
2、单个测试用例包含多个模块，可从整体上降低测试用例规模
3、采用递增方式展开测试，每个新的测试用例一般仅加入一个新的模块，便于缺陷定位
缺点：
1、桩模块的开发和维护工作量较大
2、难以早期发现底层模块中复杂算法的缺陷，且随着测试的进行，系统越来越复杂，底层模块的测试很难保证充分性
3、不利于测试的并行，难以充分展开人力
自底向上的集成测试的优点：
1、优先从叶子节点开始测试，有助于早期发现底层模块中复杂算法的缺陷，且驱动模块的开发有利于规范和约束系统上层模块的设计，在一定程度上增加系统可测试性
2、单个测试用例包含多个模块，可从整体上降低测试用例规模
3、多个集成测试可并行展开，确保测试工作进度
缺点：
1、驱动模块的开发和维护工作量较大
2、难以早期发现上层模块中有关逻辑和控制方面的缺陷
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ac0ab92453a43946e31cdba63a1f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9890f8359a949da4364029d11c730a/" rel="bookmark">
			cookie setSecure详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 最近项目用Sparrow Health System检测漏洞，发现存在一个setSecure安全漏洞问题，于是网上搜索了一下，这里记录一下。
2. 问题 在cas中或其他web开发中，会碰到安全cookie的概念，因为CAS中TGT是存放在安全cookie中的。下面是安全cookie 的理解：
Set-Cookie 的 secure 属性就是处理这方面的情况用的，它表示创建的 cookie 只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以绝对不会被窃听到。 在setSecure(true); 的情况下，只有https才传递到服务器端。http是不会传递的。
setSecure(true)意味着"指示浏览器仅通过 HTTPS 连接传回 cookie。这可以确保 cookie ID 是安全的，且仅用于使用 HTTPS 的网站。如果启用此功能，则 HTTP 上的会话 Cookie 将不再起作用。"
j2ee servlet的接口中也定义了Cookie对象，也有其方法setSecue（false）；
关于setSecure的问题，在http连接下： 当setSecure（true）时，浏览器端的cookie会不会传递到服务器端？ 当setSecure（true）时，服务器端的cookie会不会传递到浏览器端？ 答案：1）不会 ； 2）会 原理：服务器端的Cookie对象是java中的对象，请不要和浏览器端的cookie文件混淆了。服务器端的Cookie对象是方便java程序员包装一个浏览器端的cookie文件。一旦包装好，就放到response对象中，在转换成http头文件。在传递到浏览器端。这时就会在浏览器的临时文件中创建一个cookie文件。 但我们再次访问网页时，才查看浏览器端的cookie文件中的secure值，如果是true，但是http连接，这个cookie就不会传到服务器端。当然这个过程对浏览器是透明的。其他人是不会知道的。
总结如下：cookie的secure值为true时，在http中是无效的；在https中才有效
3. Cookie设置 实际上，Servlet提供的HttpSession本质上就是通过一个名为JSESSIONID的Cookie来跟踪用户会话的。除了这个名称外，其他名称的Cookie我们可以任意使用。
如果我们想要设置一个Cookie，例如，记录用户选择的语言，可以编写一个LanguageServlet：
@WebServlet(urlPatterns = "/pref") public class LanguageServlet extends HttpServlet { private static final Set&lt;String&gt; LANGUAGES = Set.of("en", "zh"); protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String lang = req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a9890f8359a949da4364029d11c730a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b4dfadbacb16335d038e3ae1fe9057e/" rel="bookmark">
			Vue全家桶之组件（component）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Vue的标准开发方式
【1】Vue推荐的开发方式是 ------------- SPA（Single Page (Web) Application ） 单页面 Web 应用
【2】什么是 SPA （单页面应用） ？
单页面应用 ：就是日后项目中只有一张页面 =========== 》》 》 index . html
【3】为什么Vue推荐开发方式SPA（单页面应用）的开发方式？
a、引入Vue js 文件
b、在现有的页面中创建一个Vue实例对象
一个页面中只能存在一个 Vue 实例
Vue 推荐的开发方式 ： 一个应用中只能存在一个Vue实例
【4】使用现有的手段严格遵循SPA存在问题？
a、现有的开发方式会导致项目中唯一一个页面中代码会越来越多，不利于维护
b、现有开发方式导致项目中唯一 一个页面中完成全部业务功能，导致当前页面每次加载的速度非常的慢
【5】为了严格遵循SPA开发方式在Vue中提供了　Ｖｕｅ　组件（ｃｏｍｐｏｎｅｎｔ）
组件作用： 1、减少Vue根实例的代码量
2、一个组件负责完成项目中的一个功能或一组功能实现业务功能隔离
3、组件还可以在Vue实现复用
【6】组件如何使用？
a、全局组件：直接注册到vue根实例的组件
Vue.component( ' ' ) // 注册这个就是全局组件
b、局部组件：只能在注册组件中使用的组件
const app = new Vue({
el：" ";
data:{ },
methods:{ },
computed:{ },
created(){ },
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b4dfadbacb16335d038e3ae1fe9057e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/75/">«</a>
	<span class="pagination__item pagination__item--current">76/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/77/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>