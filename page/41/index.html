<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00694517e7628a17d7f12ca9ce79d8f/" rel="bookmark">
			卡尔曼滤波的matlab实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 卡尔曼滤波（Kalman Filter）是一种利用线性系统状态方程，利用对系统的观测数据，对系统状态进行最优估计的算法。由于观测数据受到系统中的噪声和干扰的影响，所以系统状态的估计过程也可看作是滤波过程。应用场景之一有利用传感器跟踪感兴趣目标的位置，传感器获取的目标距离、速度、方位角等观测值往往含有噪声。卡尔曼滤波利用目标的动态信息与观测结果相结合，抑制噪声的影响，从而获得一个关于目标位置更准确的估计，这个估计可以是对当前目标位置的估计(滤波)，也可以是对于将来位置的估计(预测)，也可以是对过去位置的估计(插值或平滑)。
卡尔曼滤波原理 标准的卡尔曼滤波系统方程如下：
上面的两个式子分别叫作状态转移方程（1）和观测方程（2）。其中A叫作状态转移矩阵；B和uk是系统模型的参数；C叫作观测矩阵；sk是状态转移噪声向量或者叫过程噪声；vk是观测噪声向量；是k时刻的真实状态向量；是k时刻的预测值；zk是k时刻的观测向量。
卡尔曼滤波分为预测（Predict）和更新（Update）两个步骤：
预测：
更新：
实现步骤如下：
第一步：根据公式（3）和公式（4）计算预测值以及预测值与真实值之间的协方差矩阵；（数据准备）
第二步：根据公式（5）和公式（6）计算卡尔曼增益，然后根据公式（7）估计；（滤波估计）
第三步：根据公式（8）计算估计值与真实值之间的误差协方差矩阵，用于下一次递推；（参数更新）
2、按照以上步骤经MATLAB仿真结果如下图1：
由图1可知，红色部分为滤波前，蓝色部分为滤波后，实现了较好的滤波效果。卡尔曼滤波算法的主要思想在于同时利用了目标的实时状态信息和观测结果，相比于直接利用单一观测估计系统状态而言，卡尔曼滤波算法利用了更多的先验信息，每一个时刻都对系统状态做估计，并预测了下一个时刻的系统大致状态，之后根据观测结果，修正预测量，从而完成对系统状态更准确的估计。其整个过程是递推进行的，每完成一次系统的状态估计，就计算一次估计值与真实值的误差协方差矩阵，用于下一次估计时的变量计算。
3、数据滤波是去除噪声还原真实数据的一种数据技术，卡尔曼滤波在测量方差已知的情况下能够从一系列存在测量噪声的数据中，估计动态系统的状态。卡尔曼便于计算机编程实现，并能够对现场采集的数据进行实时的更新和处理。卡尔曼滤波是目前应用最为广泛的滤波方法，在通信，导航，制导与控制等多领域得到了较好的应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4c146f0da3ed8156805356fed39132d/" rel="bookmark">
			基于springboot框架的智慧社区家政服务系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家点赞、收藏、关注、评论啦 ，由于篇幅有限，只展示了部分核心代码。
文章目录 前言一、项目介绍二、开发环境三、功能介绍数据库设计概述数据库表的设计 四、核心代码五、效果图六、文章目录 前言 21世纪的今天，随着社会的不断发展与进步，人们对于信息科学化的认识，已由低层次向高层次发展，由原来的感性认识向理性认识提高，管理工作的重要性已逐渐被人们所认识，科学化的管理，使信息存储达到准确、快速、完善，并能提高工作管理效率，促进其发展。
论文主要是对智慧社区家政服务系统进行了介绍，包括研究的现状，还有涉及的开发背景，然后还对系统的设计目标进行了论述，还有系统的需求，以及整个的设计方案，对系统的设计以及实现，也都论述的比较细致，最后对智慧社区家政服务系统进行了一些具体测试。
本文以Java为开发技术，实现了一个智慧社区家政服务系统。智慧社区家政服务系统的主要实现功能包括：管理员：首页、个人中心、居民管理、家政供应商管理、家政服务人员管理、服务类型管理、家政服务管理、家政预约管理、服务评价管理、需求发布管理、投诉建议、需求讨论圈、系统管理功能，基本上实现了整个智慧社区家政服务系统的过程。
具体在系统设计上，采用了B/S的结构，同时，也使用Java技术在动态页面上进行了设计，后台上采用Mysql数据库，是一个非常优秀的智慧社区家政服务系统。
关键词 ：智慧社区家政服务系统；Java技术；Mysql数据库；B/S结构
一、项目介绍 随着现代网络技术发展，对于智慧社区家政服务系统的设计现在正处于发展的阶段，所以对的要求也是比较严格的，要从系统的功能和用户实际需求来进行对系统制定开发的发展方式，依靠网络技术的的快速发展和现代通讯技术的结合为人们带来方便，可以方便用户网上查看，还可以通过这些技术实现在线咨询等过程。当今社会互联网急速发展，智慧社区家政服务系统也在国内爆炸式的发展起来。这种网络模式对长期使用互联网社会产生了深远的的影响，在这种社会环境下开发一个适用于用户都可以操作的、简单的、便捷的智慧社区家政服务系统的发展前景是非常好的。
以往的智慧社区家政服务系统相关信息管理，都是工作人员手工统计。这种方式不但时效性低，而且需要查找和变更的时候很不方便。随着科学的进步，技术的成熟，计算机信息化也日新月异的发展，社会也已经深刻的认识，计算机功能非常的强大，计算机已经进入了人类社会发展的各个领域，并且发挥着十分重要的作用。本系统利用网络沟通、计算机信息存储管理，有着与传统的方式所无法替代的优点。比如计算检索速度特别快、可靠性特别高、存储容量特别大、保密性特别好、可保存时间特别长、成本特别低等。在工作效率上，能够得到极大地提高，延伸至服务水平也会有好的收获，有了网络，智慧社区家政服务系统的各方面的管理更加科学和系统，更加规范和简便。
二、开发环境 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 根据现实需要，此系统我们设计出一下功能，主要有以下功能模板。
前台功能：首页、家政服务、需求发布、需求讨论圈、通知公告、投诉建议、后台管理、在线客服、个人中心。
居民功能：首页、个人中心、家政预约管理、评价服务管理、需求发布管理。
家政供应商功能：首页、个人中心、家政服务人员管理、家政服务管理、家政预约管理、服务评价管理。
管理员功能：首页、个人中心、居民管理、家政供应商管理、家政服务人员管理、服务类型管理、家政服务管理、家政预约管理、服务评价管理、需求发布管理、投诉建议、需求讨论圈、系统管理。
。
在系统的功能设计方面，智慧社区家政服务系统的设计目标是便于家政服务管理，因此抽取了满足管理员、居民基本业务需求的基本用例，如图3-1、3-2所示。
图3-1 管理员用例图
图3-2 居民用例图
本系统设计时，确定详细功能，这些功能主要通过需求阶段的调研分析得来的，具体功能模块如下图，如图4-1所示。
图4-1 系统结构图
数据库设计概述 数据库设计是开发中比较重要的一步，需要先设计整体的表，确定项目，必须要确定几张表，设计表的结构，表之间的关联关系等，只有这样才能保证系统的稳固性。数据库主要是为了存储整个项目的数据，确保数据的安全性。整个表都包含项目中实体的各个字段和属性，我们通常用概念性模型来设计即为E-R模型。
图4-2 系统数据库
数据库表的设计 部分数据库展示
（1）居民
（2）家政预约
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.example.utils.MapWrapperUtils; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4c146f0da3ed8156805356fed39132d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc16df2d49ead60dd41be6f25902d2e3/" rel="bookmark">
			关于使用ggplot2作多组双条件的小提琴图＋箱线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.使用的R包
library("readxl")
library("dplyr")
library("ggplot2")
library("ggthemes")
1.处理的数据
我们这里处理的数据是两到三列的数据框，每个组（基因）需要有两个condition（多个也行）对应。我们这里画的图是polyA的长度。
2.使用ggplot2作图
p &lt;- ggplot(total_gene_data, aes(gene, lena, fill = condition)) + ###aes后面是x，y轴的值
geom_violin(aes(fill = condition),width = 0.7, scale = "width", size = 0.8) ###width参数设为0.7,
加上箱线图
p &lt;- ggplot(total_gene_data, aes(gene, lena, fill = condition)) +
geom_violin(aes(fill = condition),width = 0.7, scale = "width", size = 0.8) +
geom_boxplot(width = 0.2, position = position_dodge(0.7), ###position调整会对不齐
outlier.shape = NA, cex = 0.8) ###NA这里不画出离群值
自定义颜色 —— —— 使用 scale_fill_manual
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc16df2d49ead60dd41be6f25902d2e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9edfd89c07578197a7aa5dfad2dddbb7/" rel="bookmark">
			Java高级之多线程基本概念及其优点、创建线程的2种方式、解决线程安全的3种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基本概念1.1、程序、进程、线程1.2、单核CPU和多核CPU1.3、并行与并发1.4、多线程的优点1.5、何时用多线程 二、线程的创建和使用2.1、创建线程方式一--继承Thread类2.2、创建线程方式二--实现Runnable接口2.3、两种方法比较2.2、重命名线程2.2.1、方式一--setName()2.2.2、方式二--构造器 2.3、常用方法2.4、线程的优先级 三、线程的生命周期四、线程的同步4.1、解决线程安全方式一--同步代码块4.2、解决线程安全方式二--同步方法4.3、线程安全的懒汉式单例模式4.4、死锁4.5、解决线程安全方式三--ReentrantLock锁4.6、线程的通信 五、JDK5.0新增线程创建方式5.1、创建线程的方式三--实现Callable接口5.2、创建线程的方式四--使用线程池5.3、线程池相关API 一、基本概念 1.1、程序、进程、线程 程序（program）：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。
进程（process）：正在运行中的程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期
线程（thread）：进程可以进一步细化为线程，是一个程序内部的一条执行路径。
线程作为调度和执行的单位，每个线程拥有独立的运行栈核程序计数器（pc），线程切换的开销小 1.2、单核CPU和多核CPU 单核CPU：其实是一种假的多线程，因为 在一个时间单元内，也只能执行一个线程的任务。但是因为CPU时间单元特别短，因此感觉不出来。
多核CPU：可以更好地发挥多线程的效率。
另外，**一个Java应用程序java.exe，其实至少有三个线程：mian()主线程，gc()垃圾回收线程，异常处理线程。**当然如果发生异常，会影响主线程。
1.3、并行与并发 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事情。
并发：一个CPU（采用时间片的策略）同时执行多个任务。比如：618、双11的秒杀活动；多个人做同一件事。
1.4、多线程的优点 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。提高计算机系统CPU的利用率改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。 1.5、何时用多线程 程序需要同时执行两个或多个任务程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等需要一些后台运行的程序时。 二、线程的创建和使用 2.1、创建线程方式一–继承Thread类 四步：
1.创建一个继承于 Thread类的子类 2.重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 3.创建Thread类的子类的对象 4.通过此对象调用start() --&gt; ① 启动当前线程 ② 调用当前线程的run() 举个例子：
方式一
public class ThreadDemo { public static void main(String[] args) { MyThread1 thread1 = new Mythread1(); thread1.start(); Mythread2 thread2 = new Mythread2(); thread2.start(); } } // 方法一 class Mythread1 extends Thread{ @Override public void run() { //遍历100以内的奇数 for (int i=0;i&lt;100;i++){ if (i%2==0){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9edfd89c07578197a7aa5dfad2dddbb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7575896db7d01b6b454ef0ffe76fed21/" rel="bookmark">
			软件测试的理论基础1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件的生命周期 可行性研究和计划（立项）
需求分析
概要设计（测试计划）
详细设计（测试方案）
实现（开发阶段；包含单元测试）
组装测试（集成测试）
确认测试（系统测试，验收回归测试）
使用和维护（上线使用及日常更新维护）
什么是软件测试 定义：在规定条件下对程序进行操作，从而发现问题，对软件质量进行评估的过程 软件测试的目的： 以最少的人力、物力、时间找到软件中的缺陷并修改，从而回避商业风险。
软件测试的定义： 使用人工和自动手段来运行程序，目的在于检验是否满足了需求
软件测试的原则 所有测试追溯到用户需求把尽早和不断的测试，最为座右铭测试工作要由专业人员来执行80%的错误出现在20%的模块中设计测试用例（测什么？怎么测？）时，要考虑各种情况一定要写缺陷报告制定严格的测试计划完全测试是不可能的，测试需要终止注意回归测试（修改了旧代码后，要确认没有引入新的问题）妥善保存一切测试文档 软件质量模型（iso9126） 1、 功能性
2、 可靠性（1、尽量不出问题；2、出了问题不能影响主体功能；3、如果影响了主体功能，要能尽快修复）
3、 易用性（用户体验要好）
4、 效率
5、 可维持性（更新）
6、 可移植性（跨越不同系统平台）
软件质量模型保证（SQA） 目的：使软件制作的过程对于领导层是可见的。
定义：它是一套计划和方法来向领导层保证。
五个基本目标：
1、 保证有计划地进行，
2、 保证遵循了步骤和需求
3、 及时通知给对应人员
4、 高管可以接触到项目内部
5、 软件质量需要测试工作来保证
qc和qa qc：检验产品的质量
qa：审计过程的质量
工作关系：qc进行质量控制，qa是确保qc按照步骤执行。
软件测试流程 1、 需求分析
2、 编写测试用例（测什么 怎么测）
3、 评审测试用例
4、 搭建测试环境
5、 等待程序的开发包
6、 部署测试包
7、 冒烟测试（测试主体功能是否有问题）
8、 执行测试用例
9、 Bug跟踪处理（回归测试）
10、N轮之后符合要求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7575896db7d01b6b454ef0ffe76fed21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfaf634104407fdf61476401232dee6/" rel="bookmark">
			【Python】基于 Flask 的 Python 网页天气查询应用开发实践 - 天气 API 探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3. 天气 API 探索 3.1 选择适合的天气 API 首先，我们需要一个提供天气信息的 API。有许多免费的天气 API 可供选择，例如 OpenWeatherMap，Weatherstack 等。你需要去他们的官方网站注册并获取一个 API 密钥。
3.2 使用 requests 发送网络请求 Python 的 requests 库可以帮助我们发送 HTTP 请求。首先，我们需要安装 requests 库：
pip install requests 然后，我们可以使用以下代码来发送一个 GET 请求：
import requests response = requests.get('http://api.weatherapi.com/v1/current.json', params={ 'key': 'YOUR_API_KEY', 'q': 'San Francisco' }) data = response.json() print(data) 这段代码会向 Weather API 发送一个请求，查询 San Francisco 的天气，并打印出返回的 JSON 数据。
3.3 解析 JSON 数据 上面的代码中，response.json() 方法会将返回的 JSON 数据解析为一个 Python 字典。我们可以通过这个字典来获取我们需要的信息，例如天气，温度等：
weather = data['current']['condition']['text'] temp_c = data['current']['temp_c'] print(f'Weather: {weather}, Temperature: {temp_c}°C') 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcfaf634104407fdf61476401232dee6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cbb3731b1ef1bf9fff63dc63a106863/" rel="bookmark">
			React.ts中，input输入框输入完毕后重置为空，使用ref方式和断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react.ts中，将使用ref对象绑定的input输入框进行清空内容，以及对应的ref的断言写法以保证获取到value值
好好好，今天来写一篇ts，前端真的是，我哭si，啥都要会！
分享一个对于ts的有趣写法，平时写项目的时候，ts自带的检查会保证我们的代码不会出现type类型的错误，但是这又间接提高我们的代码难度，虽然会报错提示吧，但工程量确实变大了。这不，今天在写input的时候，需要实现一个业务，从输入框输入的值显示到页面上排列，所以我使用ref绑定到input，然后设置按钮完成任务，为了提升用户体验，还是需要提交点击按钮后，将input内容清空好一点。其中遇到很多奇奇怪怪的错误，比如为什么需要使用到断言，因为写的时候，项目又没有输入input，导致ts检查到value值可能是null，就编译不了了，就像下面这样子就不行：
myref=React.createRef&lt;HTMLInputElement&gt;() //与js不一样，ref在这里需要使用泛型指明将来绑定到input的元素上面，也就是提前声明 &lt;input ref={this.myref}&gt;&lt;/input&gt; &lt;button onClick={()=&gt;{ this.setState({ list:[...this.state.list,this.myref.current.value] }) }}&gt;输出&lt;/button&gt; &lt;ul&gt; { this.state.list.map(item=&gt;&lt;li key={item}&gt;{item}&lt;/li&gt;) } &lt;/ul&gt; 显然上面的是js写法，但是this.myref.current在ts看来，将来可能会出现null的情况（虽然我们知道不会，但是ts就是需要做检查防止真的出错），那么这个时候我们就需要告诉ts，我将来这个ref肯定是input的，而且不可能为空的，所以就是需要做个大胆的言论，下定义嘛！这就符合断言啦，所以需要写成这个样子来获取value值：
console.log((this.myref.current as HTMLInputElement).value); //告诉ts将来这个值就是input元素 那么最后的情况操作也是要使用断言了，但是有个坑！在setState后需要加上分号断开下一个断言，否则报表达式不可用的错误，最终代码就是这样子：
myref=React.createRef&lt;HTMLInputElement&gt;() &lt;input ref={this.myref}&gt;&lt;/input&gt; &lt;button onClick={()=&gt;{ console.log((this.myref.current as HTMLInputElement).value); this.setState({ list:[...this.state.list,(this.myref.current as HTMLInputElement).value] //使用断言假设 }); (this.myref.current as HTMLInputElement).value='' }}&gt;输出&lt;/button&gt; &lt;ul&gt; { this.state.list.map(item=&gt;&lt;li key={item}&gt;{item}&lt;/li&gt;) } 好滴，今天的文章就到这里，希望给大家带来帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c65ad2a0e1c2698b26eabe869d8fcf/" rel="bookmark">
			负载均衡技术介绍-Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想象一下，你的网站或应用同时受到数百甚至数千用户的访问。单一服务器将无法承受压力，你的网站将像纸牌屋一样崩溃。但不用担心！
这就是负载均衡器发挥作用的地方。负载均衡器帮助将传入的流量分布到多台服务器上，确保你的网站保持运行，用户保持愉快。所以，下次你的网站开始感受到压力时，可以依赖可靠的负载均衡器拯救一天！
让我们深入了解负载均衡的世界，探索一些常用的用于分发传入请求的技术。这些技术已被证明在确保请求在多台服务器间高效分配方面非常有效，避免任何一台服务器被过载。
所以，做好准备，准备好了解一些对保持应用程序顺畅运行至关重要的负载均衡技术。
轮询技术（Round Robin Technique） 轮询技术是一种负载均衡技术，负载均衡器从第一台服务器开始依次将请求分配到第n台服务器，然后重新开始。基本上，它按顺序遍历所有服务器，无论是从上到下还是从下到上。通过使用这种技术，可以将请求均匀地分布到多台服务器上。
从上图可以看出，有四台负责处理传入请求的服务器。为了确保这些请求被均匀高效地分配，采用了轮询技术。使用这种技术，请求按顺序分配给每台服务器，确保没有任何一台服务器负载过重。通过在所有服务器之间均匀分配请求，此方法有助于保持负载平衡，并防止任何一台服务器变得不堪重负。
权重轮询技术（Round Robin Weighted Technique） 这种技术几乎使用了相同的方法来分发请求，但它具有权重属性，可以指定特定服务器可以高效地处理每秒多个请求。因此，通过使用加权属性，我们可以根据服务器的容量分配流量。
在上图中，有四台负责处理传入请求的服务器。然而，第二台服务器被认为是最高效的，可以每秒处理三个请求。为了考虑效率差异，第二台服务器被分配了一个权重为三，而其他服务器保持权重为一。通过这样做，负载均衡器可以确保请求的分配考虑了每台服务器的相对能力，从而更有效地利用资源，提高整体性能。
基于 IP 哈希的分发技术（IP Hashing-Based Distribution Technique） 在这种技术中，传入请求的客户端 IP 地址被用作哈希键来路由流量到相同的服务器，直到该服务器不可用。这种技术称为基于 IP 哈希的分发。有许多算法可用于使用此技术。
可以看到在上图中，负载均衡器正在使用 IP 哈希技术，其中它获取请求的客户端 IP 并将其放入哈希函数中以创建唯一的哈希键。然后通过使用唯一的哈希键，每次请求命中负载均衡器时都会分配到相同的服务器，因为相同值的哈希始终相同。
哈希是一个单向过程。
IP 哈希技术在将某些内容缓存在同一服务器上时通常非常有用。这样可以允许请求每次都发送到同一服务器，从而增加缓存命中率。
基于路径的分发技术（Path-Based Distribution Technique） 使用这种技术，负载均衡器根据请求的路径将请求分配给服务器。我们可以将服务部署到不同的服务器上并在负载均衡器中设置其路径。例如，我们将身份验证服务部署到服务器1上，负载均衡器将始终将身份验证请求发送到特定服务器。
这有助于确保我们的系统保持高效运行，即使面对潜在的干扰。通过利用这种方法，我们可以提高系统的整体可靠性和韧性，并为用户提供更好的体验。
在示例中，我们演示了如何使用负载均衡器根据路径将请求路由到特定的服务器。这种方法本质上将负载均衡器转变为 API 网关，因为它成为处理传入请求并将其定向到适当服务器的中心点。
通过利用这种技术，我们可以简化系统架构，确保请求始终路由到正确的服务，而无需手动管理每个个别服务的路由逻辑。总体而言，将负载均衡器用作 API 网关可以简化我们的系统架构，提高性能，增强整体用户体验。
总结 在本文中，我们讨论了处理服务器流
量的不同技术。每种技术都有其自己的用例。还有许多其他技术，但这些是常见且更有效的。最终，一切都取决于你的应用程序的要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f037b8881237364635ef7a75e802eb/" rel="bookmark">
			DBAIops社区版新版本发布说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着疫情结束，D-SMART社区版的发布也将恢复到去年的模式，每个月20-25号之间发布一个新的更新版本，不断迭代功能和修复旧版本的BUG。
D-SMART社区版采用版本火车发布机制，其版本需求来自于商用版用户、社区版用户以及研发团队中的运维专家的反馈、需求和设计。因此社区版用户在使用过程中遇到的任何问题或者对功能需求方面的想法和建议，都可以通过社区服务群或者直接联系客服的方式反馈到社区运营方。社区运营方会在一两个工作日内就反馈到研发团队。研发团队会根据需求的规模制定发车计划，最快的情况下，可以跟着当月发车的版本一起发布。对于复杂的需求，可能需要经过研发部门的需求评审后确定是否纳入研发计划。
在每个月度发布周期的2/3时间节点，将是本次发车版本需求的冻结时间，哪怕再简单的功能也无法在此时间节点后加入本次列车。3/4时间节点会做最后的评估，将本次发车中需要上车，但是无法满足发布条件的功能下车，从而确保版本发布的可靠性。
因此社区用户如果有对产品功能的需求和BUG，最好在月底月初的时候向社区提出，从而尽可能安排在下个版本发布时实现。
2023年度，D-SMART社区版将迎来3.0，D-SMART也将会从单一的产品变成一个产品系列。我们会继续发布D-SMART专家问诊系统的新版本，并不断迭代知识库。
同时我们会发布D-SMART数据库高可用管家，用于监控OGG、ADG、MGR等数据库复制与高可用环境，并提供自动化切换能力。这个工具与原有的专家问诊系统分离主要还是权限的问题，作为监控与诊断方面的工具，只需要获取最小的数据库与操作系统访问权限，而数据库高可用管家需要具有读取数据库用户数据的权限以便于进行数据校验，同时还需要在数据库中创建并更新心跳表，从而更好的对复制延时进行精准评估。
除此之外，D-SMART社区版还将针对TDSQL、OCEANBASE等数据库开发专版，我们将推出支持OCEANBASE 社区版的免费的D-SMART专版，从而帮助用户更好地运维OCEANBASE数据库。
目前DBAIOPS社区运营团队与D-SMART研发团队都正在为今年的D-SMART产品发展做着规划，也希望广大的社区用户能建言献策，让D-SMART产品对你们更有价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4744b2c0502dfa889752018bf94bd15d/" rel="bookmark">
			智能运维中应用大语言模型的一些思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个周末很忙乱，儿子高考要报综合评价，以前听报考过南科大综评的朋友说报名很简单几分钟搞定，所以也没太当回事。月底要截至，所以周末要弄好。没想到高招网的填写十分复杂，很多教委综评网站上🈶的数据都要抄下来重新填写，所以也挺折腾人的。国家的大数据战略实施了这些年了，教育部门做得还是不咋样啊。
另外一件事就是总结一下近期利用大语言模型在智能化运维领域的探索，为下一步正式开展工作理理思路。前阵子对PTUNING的训练样本，超参等都做了一些尝试，对效果也做了初步评估，不过还是没有达到我想要的效果。其中的客观原因是设备太差，很多想做的尝试因为设备原因无法更深入开展，不过最主要的原因还是对大语言模型的工作原理缺乏认知，因此只能依靠盲人摸象的方式探索，效率太低。
最近尝试了一个新的开源项目DB-GPT，这个结合了VICNUA-13B，AUTOGPT，FSCHAT，AUTOPROMPT，LANGCHAIN等技术的开源项目还是挺值得关注的，虽然目前还只是项目的初期阶段，不过最近更新的第二个版本从功能框架上已经有模有样了。最主要的是该项目完全满足离线私有化部署的要求，而且在一块24G显存的单卡上就能跑起来。对于智能化运维，本地部署，低成本是十分关键的。
通过最近的一顿折腾，对大语言模型在AIOPS中能做什么，不能做什么有些了解了，这也为下一步尽快搞出能落地的应用十分关键。最初的时候我觉得LLM只需要有基本都推理能力，通过添加PTUNE的前置模型中的专业领域知识就能很好的完成专有领域都工作了。经过这段时间点尝试，我发现基础模型的能力也十分关键，基础模型不好，会把整个工作都带歪了。利用现有开源模型，加入大量专业领域知识做FINETUNE，形成一个较好的基础模型可能对整个工程有较大的帮助。
目前国产开源的CHATGLM-6B，MOSS等都是可以本地化部署的模型。国外的羊驼现在也很热，很多人都基于这个模型加入一些中文语料，训练出效果不错的模型。META的LLAMA也是相当不错的选择，实际上很多开源模型的底子都是LLAMA。LLAMA有从7B，13B起步的多个版本，总有一款适合你。目前大热的Vicnua-13b就是基于LLAMA的。有私有化训练硬件环境的企业完全可以利用LLAMA训练出比较适合自己的模型的。
通过LANGCHAIN快速构建外挂的本地知识库是一条实现成本较低的路线，结合AUTOPROMPT，可以利用训练好的基础模型来完成复杂的工作任务，不过这方面也是有局限性的，基础模型不行，知识库的应用效果就不行。
另外要说的是设备，玩大语言模型装备很重要，没有装备很多工作无法开展，或者做起来很累。因此做之前一定要考虑好这些问题，说实在的，这些都是钱堆起来的。
在这个领域，我们目前也刚刚开始探索，如果有朋友对这方面有兴趣，希望留言探讨，看看能不能找到一条能走的通的路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0252dfa22c2b1ebd10ed39a9e2e4f6/" rel="bookmark">
			vue-element-admin项目部署 nginx动态代理 含Docker部署、 Jenkins构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍三种方式：
1.直接部署到nginx中
2.用nginx docker镜像部署
3.使用Jenkins构建
1.直接用nginx部署 vue-element-admin项目下有两个.env文件，.env.production是生产环境的，.env.developpment是开发环境的
vue-element-admin默认用的是mock数据，如果想调用后台接口(自己要把用户登录、角色、权限之类的写好)，在vue.config.js里，大概39行左右，把proxy里的内容改成如下形式：
proxy: { [process.env.VUE_APP_BASE_API]: { target: process.env.SYSTEM_BACKEND_URL, changeOrigin: true, pathRewrite: { ['^' + process.env.VUE_APP_BASE_API]: '' } } } 先保证开发环境和后台调通，之后再进行服务器部署。
生产环境打包，执行 npm run build:prod
执行成功后，项目路径下会出现一个dist文件夹
把dist文件夹上传到nginx服务器，比如放到 /usr/share/static/dist，注意 /usr/share/static/dist就是打包好的dist文件夹，index.html路径是 /usr/share/static/dist/index.html，不要写成 /usr/share/static/dist/dist
nginx.conf代理相关配置如下：
server { listen 80; #端口 server_name localhost; location / { #映射前端资源 root /usr/share/static/dist; #静态资源路径,index.html就在这个目录里 try_files $uri $uri/ @router; index index.html index.htm; } location @router { rewrite ^.*$ /index.html last; } #后端请求转发，/prod-api/ 对应.env.production里的SYSTEM_BACKEND_URL，注意两端都有/ location /prod-api/ { proxy_pass http://xxxx:9999/; #后端接口地址， proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; } } nginx -s reload 重启nginx，完成部署
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e0252dfa22c2b1ebd10ed39a9e2e4f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc1d19f5df7052cfebabab7f32ceac6/" rel="bookmark">
			vue处理后台返回的二进制流文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发过程中，碰到了后台返回二进制流文件，无法处理的情况，返回数据如下
（此过程中运用到了一个关键的数据类型，BLOB =&gt; 二进制大对象(BLOB)是一种可以存储二进制对象或数据的数据类型。二进制大对象在数据库中用于存储二进制数据，如图像、多媒体文件和可执行软件代码。二进制大对象也可以称为基本大对象。）
经过各种百度百科，和同事相助，大概摸索出来解决方法，代码如下，可直接C+V（稍加修饰）使用。
// 第一种办法 this.$http["post"]( `${this.$config.basePath}/xxx/xxx`,this.dataForm // 此处接口仅为示例 ).then(res =&gt; { // 以下为精髓 var blob = new Blob([res.data]) var href = URL.createObjectURL(blob) // 下载文件 var downloadElement = document.createElement('a') downloadElement.href = href let prefix = new URL(value.path); prefix = prefix.pathname.split('.') prefix = prefix[prefix.length - 1] downloadElement.download = value.name + '.' + prefix document.body.appendChild(downloadElement) downloadElement.click() document.body.removeChild(downloadElement) URL.revokeObjectURL(href) }) // 第二种办法（downloadFiles是接口，v是需要向后台传输的参数，这种办法是下载压缩包） const res = await downloadFiles(v); const blob = new Blob([res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cc1d19f5df7052cfebabab7f32ceac6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe0bfa4535f05bd954964a263e857ec/" rel="bookmark">
			源码分析CompletableFuture使用默认线程池ForkJoinPool的弊端（cpu利用率低）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说结论：
假如有20CompletableFuture任务并发执行时，都使用默认线程池ForkJoinPool，但cpu的核心数又小于3，那么就会新建20个线程（不使用默认线程池了），这20个线程相互竞争cpu资源和内存，很多线程都在等待，浪费了大量的性能在线程上下文切换上。
Brian Goetz在《Java并发编程实战》建议
N threads = N CPU * U CPU * (1 + W/C)
N CPU 是处理器的核的数目，可以通过 Runtime.getRuntime().availableProce-
ssors() 得到U CPU 是期望的CPU利用率（该值应该介于0和1之间）W/C是等待时间与计算时间的比率 线程池大小设定：核心数 * 期待利用率 *（1 + 等待时间与计算时间的比率）
如果服务是cpu密集型的，设置为电脑的核数如果服务是io密集型的，设置为电脑的核数*2 从runAsync方法点进去
CompletableFuture&lt;Void&gt; voidCompletableFuture = CompletableFuture.runAsync(() -&gt; { System.out.println(1); }); 可以看见使用的是asyncPool。点进asyncPool
public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) { return asyncRunStage(asyncPool, runnable); } useCommonPool是否为true决定了使用 ForkJoinPool线程池还是新建一个线程池。点进useCommonPool。
private static final Executor asyncPool = useCommonPool ? ForkJoinPool.commonPool() : new ThreadPerTaskExecutor(); 这里判定的是ForkJoinPool common线程池中并行度级别是否大于1。点进 getCommonPoolParallelism() 方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfe0bfa4535f05bd954964a263e857ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dacbc0804c9c346ed70eeb1f5f49ce5e/" rel="bookmark">
			Java项目开发：基于Java&#43;spingboot&#43;vue的墨客——校园投稿平台系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家点赞、收藏、关注、评论啦 ，由于篇幅有限，只展示了部分核心代码。
文章目录 前言一、项目介绍二、开发环境三、功能介绍数据库设计概述数据库表的设计 四、核心代码五、效果图六、文章目录 前言 本文的重点是对墨客——校园投稿平台系统展开了详细的描述，其中包含了其目前的发展状况和所涉及到的发展背景。接着，本文讨论了该系统的设计目的，系统的需求，并提出了整体的设计方案。对于该系统的设计和实现，也都进行了较为详细的讨论，并在此基础上，对墨客——校园投稿平台系统展开了一些具体的测试。
论文采用 Java作为软件的技术，对校园投稿工作进行了研究。在系统的设计方面，运用了 B/S的架构，并且还利用 Java技术、springboot框架、 Mysql数据库，主要功能有个人中心、用户管理、评委管理、比赛公告管理、文章信息管理、文章分类管理、文章打分管理、系统管理。它是一个十分出色的墨客——校园投稿平台系统。
一、项目介绍 随着互联网技术的不断发展和普及，校园投稿平台逐渐成为了一种重要的校园生活服务平台。校园投稿平台是指为用户提供一个发布、分享、展示和交流自己思想、文化的平台。它可以让用户更加自由地表达自己的想法和观点，同时也能够提高用户的文化素养和创作能力，促进校园文化的繁荣发展。
首先，校园投稿平台可以帮助用户更好地展示自己的才华和成果。用户可以将自己的文章上传到平台上，与其他人进行分享和交流。这样不仅可以让更多的人欣赏到自己的作品，还可以在交流中得到更多的启发和建议，进一步提高自己的创作水平。
其次，学校是一个具有浓厚文化氛围的地方，而校园投稿平台可以让用户更加充分地发挥自己的创造力和创新能力，创作出更多的文化作品，丰富校园文化内涵。这样不仅可以增强用户的文化素养和审美能力，还可以提高校园文化的知名度和美誉度。
最后，校园投稿平台可以为用户提供一个交流和学习的平台。用户可以通过平台上的文章、作品和评论，了解到更多的知识和见解，拓宽自己的视野和思路。同时，平台也可以为用户提供一个互相交流的机会，促进彼此之间的沟通和合作，进一步提高用户的创作能力和团队合作能力。
综上所述，校园投稿平台是一个具有重要意义的校园生活服务平台。它可以帮助用户更好地展示自己的才华和成果，促进校园文化的繁荣发展，为用户提供一个交流和学习的平台。因此，学校应该积极推广和建设校园投稿平台，为用户提供更多的文化交流和创作机会，推动校园文化的不断发展和进步。
二、开发环境 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 根据现实需要，此系统我们设计出一下功能，主要有以下功能模板。
前台功能：首页、比赛公告、文章信息、参赛资讯、后台管理。
用户功能：首页、个人中心、文章信息管理、文章打分管理。
评委管理：首页、个人中心、文章信息管理、文章打分管理。
管理员功能：首页、个人中心、用户管理、评委管理、比赛公告管理、文章信息管理、文章分类管理、文章打分管理、系统管理。
。
在系统的功能设计方面，墨客——校园投稿平台的设计目标是便于用户投稿，因此抽取了满足管理员、用户基本业务需求的基本用例，如图3-1、3-2所示
图3-1 管理员用例图
图3-2 用户用例图
本系统设计时，确定详细功能，这些功能主要通过需求阶段的调研分析得来的，具体功能模块如下图，如图4-1所示。
图4-1 系统结构图
数据库设计概述 数据库设计是开发中比较重要的一步，需要先设计整体的表，确定项目，必须要确定几张表，设计表的结构，表之间的关联关系等，只有这样才能保证系统的稳固性。数据库主要是为了存储整个项目的数据，确保数据的安全性。整个表都包含项目中实体的各个字段和属性，我们通常用概念性模型来设计即为E-R模型。
图4-2 系统数据库
数据库表的设计 部分数据库展示
（1）文章信息评论表
（2）表名评委
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dacbc0804c9c346ed70eeb1f5f49ce5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf9981350c9bce39ce943b9fc65bd63/" rel="bookmark">
			Redux持久化及其持久化失效之刷新页面数据会重置问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天做项目练习，遇到很头疼的一件事情，那就是在做一个react-redux的持久化的时候，给我搞崩溃了，明明很简单的操作，硬是给我留下深刻教训，代码不良习惯的啦~
所以我必须记录下来，我觉得肯定有道友会遇见跟我一样的问题doge！
那先来讲讲redux的持久化，众所周知，redux就是类似全局状态管理但是又个人感觉稍微工序复杂但是也很强大的一个东西，因为其提供了connect和provider两个高阶组件，方便了数据和修改数据函数在外部组件的调用，那么为什么要扯上持久化呢，举个例子，你开发一个软件，但是涉及一个变量， 你不希望你的初始值在被用户刷新页面之后重置为默认值，一个很典型的场景就是坐标选择，用户选择将默认值广州选到北京，然后刷新页面，用户肯定不希望刚刚选择的北京又被重置为广州，造成不好的用户体验，所以，我们就必须使用持久化，那么localstorage很牛的道友也可以自己模仿一个咯，反正个性化嘛，不是cookie就是localstorage，但是有持久化库的，那就是redux-persist，哎呀扯远了，先讲讲怎么持久化：
首先，下载redux-presist
npm i redux-persist 在redux的主页面（一般会命名为store.js）引入两个关键的类：
//导入持久化 import { persistStore,persistReducer } from 'redux-persist' import storage from 'redux-persist/lib/storage' 然后开始设置：主要包括后续你要加入到localstorage的名字，白名单也就是需要持久化那个模块，还要导入经过封装的storage，然后将reducer包装成持久化的，进而使用上述持久化后的reducer来创建store，然后持久化store，最后暴露出store和持久化store：
const persistConfig={ //持久化到本地的目录名称key值 key:'xjd', storage, whitelist:['city'] } const reducer=combineReducers({ Tarbar, city, createcinemas }) const persistedReducer=persistReducer(persistConfig,reducer) //持久化reducer const store = createStore(persistedReducer,applyMiddleware(thunk,promise)); const persistor=persistStore(store) export {store,persistor} 最后一步在项目的index.js页面使用持久化，需要事先导入高阶组件PersistGate和redux主页面的两个类，然后包裹根组件即可：
import {store,persistor} from "./text-js/appxjd/redux/store"; import { PersistGate } from "redux-persist/integration/react"; const root=createRoot(document.getElementById('root')) root.render( //引入react-redux的第一步 &lt;Provider store={store}&gt; &lt;PersistGate loading={null} persistor={persistor}&gt; &lt;First&gt;&lt;/First&gt; &lt;/PersistGate&gt; &lt;/Provider&gt;) 到这里，我们的持久化就是算完成了！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf9981350c9bce39ce943b9fc65bd63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ace5f90e01f46b6561768f2467d553f/" rel="bookmark">
			【Pandas】Dataframe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 基本概念及创建1.1 DataFrame简介1.2 创建 Dataframe(1) 方法一：由数组/list组成的字典(2) 方法二：由Series组成的字典(3) 方法三：通过二维数组直接创建(4) 方法四：由字典组成的列表(5) 方法五：由字典组成的字典 2. Dataframe 索引2.1 选择行与列(1) 直接访问：***只能访问列***(2) df.loc[]函数：按行列名取数(3) df.iloc[]函数：按下标数字取数(4) df.ix[]函数(5) 布尔型索引(6) 多重索引--- 判断返回类型是Series还是Dataframe小技巧 3. 基本技巧3.1 查看收尾n行、转置3.2 添加与修改3.3 删除3.4 对齐3.5 排序1 - 按值排序 .sort_values3.6 排序2 - 索引排序 .sort_index 4. 数值计算和统计基础1.基本参数：axis、skipna2.主要数学计算方法，可用于Series和DataFrame（1）3.主要数学计算方法，可用于Series和DataFrame（2）4.唯一值：.unique()5.值计数：.value_counts()6.成员资格：.isin() 5. 文本数据1.通过str访问，且自动排除丢失/ NA值2.字符串常用方法（1） - lower，upper，len，startswith，endswith3.字符串常用方法（2） - strip4.字符串常用方法（3） - replace5.字符串常用方法（4） - split、rsplit6.字符串索引7.一个值得学习的小例子 1. 基本概念及创建 1.1 DataFrame简介 Dataframe是一个表格型的数据结构，带有index（行标签） 和 columns（列标签） 的 二维数组DataFrame的每一列的数据类型相同，相当于一个Series,列名就是Series.nameimport pandas as pd import numpy as np data = { 'name': ['Mary', 'Jack'], 'age': [12, 18], 'sex': ['女', '男'] } frame = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ace5f90e01f46b6561768f2467d553f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2f55d5018bd2e83111a5b1f32ee480/" rel="bookmark">
			快捷记录(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统环境变量 windows 搜索 env
注册表 运行 regedit
服务 任务管理器
运行 services.msc
记事本 notepad 计算器 calc
windows版本 记事本 – 帮助 – 关于
winver
c盘释放 powercfg -h off // 禁用休眠,以后就不能休眠了
powercfg -h on // 启用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12b99352b649e21be76124246f44426/" rel="bookmark">
			用蛮力法编程解决百钱百鸡问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 任务描述 本关任务：用蛮力法编程解决百钱百鸡问题。
百钱百鸡问题：中国古代数学家张丘建在他的《算经》中提出了著名的“百钱百鸡问题”：鸡翁一，值钱五；鸡母一，值钱三；鸡雏三，值钱一；百钱买百鸡，翁、母、雏各几何?
编程要求 请在右侧编辑器Begin-End处补充代码，完成本关任务，要求程序输出所有可行的方法，按公鸡的升序输出，输出格式为：公鸡有a只,母鸡有b只,小鸡有c只，每个输出结果后用空行隔开。（其中 a，b，c分别用具体数据代替）
测试说明 平台会对你编写的代码进行测试，输出结果为正确答案时则通关。
#include &lt;stdio.h&gt; void main() { /********** Begin **********/ int x,y,z; for(x=0;x&lt;=20;x++){ for(y=0;y&lt;=34;y++){ for(z=0;z&lt;=100;z++){ if((100==x+y+z)&amp;&amp;(100==5*x+3*y+z/3.0)){ printf("公鸡有%d只,母鸡有%d只,小鸡有%d只\n",x,y,z); } } } } /********** End **********/ } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd851dc58dee7a2fd5ae5b298aa42a1c/" rel="bookmark">
			LeetCode-62-不同路径-动态规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述：
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
题目链接： LeetCode-62-不同路径
解题思路：详见注释~
代码实现：
class Solution { public int uniquePaths(int m, int n) { // 1. dp[i][j]含义：走到(i,j)位置有dp[i][j]条路径 // 2. 递推公式：dp[i][j]依赖与 dp[i-1][j] 和 dp[i][j-1]的路径个数 // dp[i][j] = dp[i-1][j] + dp[i][j-1] // 3. 如何初始化：第一行和第一列均初始化为 1，不管怎么走都只有一种方法，要么一直向右，要么一直向下 // dp[0][j]=1 // dp[i][0]=1 // 4. 遍历顺序：从左上到右下 // 定义一个二维的dp数组 int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; i++) { dp[i][0]=1; } for (int i = 0; i &lt; n; i++) { dp[0][i]=1; } for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { dp[i][j]=dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0cd03f308767e01e74960eb1e64daf0/" rel="bookmark">
			Java项目开发：基于spark的新闻推荐系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家点赞、收藏、关注、评论啦 ，由于篇幅有限，只展示了部分核心代码。
文章目录 前言一、项目介绍二、开发环境三、功能介绍数据库设计概述数据库表的设计 四、核心代码五、效果图六、文章目录 前言 随着我国媒体和网络技术的快速发展，新闻发布也不断优化我国媒体界，随着个外交商务所占比重越来越大，有助于我国社会经济的可持续性发展，文章主要讲述了新闻行业的发展分析，因为媒体的宣传能够带给我们重要的信息资源，新闻发布和评论管理是国家管理机制重要的一环，,面对这一世界性的新动向和新问题，新闻发布如何适应新的时代和新的潮流，开展有效的信息服务工作,完成时代赋予的新使命?本文就这一问题谈谈几点粗浅的看法.扩大业务范围,更新服务内容.信息社会的到来已经向新闻推荐系统的服务方式提出了新的挑战。本系统包含了二个用户，即管理员和用户，管理员权限：首页、个人中心、用户管理、新浪新闻管理、系统管理，前台首页：首页、新浪新闻、新闻资讯、个人中心等模块。
本新闻推荐系统采用的数据库是Mysql，使用Java技术开发。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
一、项目介绍 当今世界，信息技术创新日新月异，信息化浪潮蓬勃兴起，全球信息化进入发展新阶段。在信息化时代，信息内容更加丰富，同时也带来了“信息过载等负面问题，大量的信息给人们的生活带来了一定的困扰。为了更好地解决“信息过载”问题，推荐系统成为一项重要的工具，而当前新闻推荐系统在研发和应用过程中，本身还存在推荐效果不理想、实时性要求高等问题。本设计应用spark，针对前述问题构建一个融合多种推荐策略和方案的可以改进性能的新闻推荐系统。
二、开发环境 开发语言：Java
框架：ssm
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 本系统设计时，确定详细功能，这些功能主要通过需求阶段的调研分析得来的，具体功能模块如下图，如图4-1所示。
。
图4-1 系统总体结构图
数据库设计概述 数据库表的设计 部分数据库展示
（1）表1：新闻资讯
（2）表3 评论表
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.example.utils.MapWrapperUtils; import com.example.utils.jwt.JwtUtil; import com.example.vo.CaiwuVo; import org.springframework.beans.BeanUtils; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0cd03f308767e01e74960eb1e64daf0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/40/">«</a>
	<span class="pagination__item pagination__item--current">41/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/42/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>