<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e88d4ecfd262c8ddf1360b02738cde/" rel="bookmark">
			集论几何学定理：一个球变成两个球
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初看上去，这个定理确实荒唐，一个球体怎么会变成两个球体？这岂不是把一个西瓜变成了两个西瓜？实际上，这是一条数学定理，请不要少见多怪。
请看下图所示：
这条几何学定理叫巴拿赫-塔尔斯基（Banach Tarski）定理，是1924年发表的。Tarski就是无穷小微积分作者J.Keisler的博士论文指导老师。
该定理是说，可以将一个刚性球体剖分为许多小块，使这些小块在空间中发生旋转（Rotation）与位移(Translation)，而保持体积、形状不变，然后可以拼装出两个体积大小完全相同的刚性球。完全类似地，两个球变4个球，......如上图所示。这岂不怪栽？
1904年，Ernst Zermelo为证明”良序定理“（Well ordering theorem）把选择公理引入数学。实际上，良序定理等价于选择公理。自然数就是良集合。由此可见，微积分离不开选择公理。回顾历史，在1908年，Zermelo首先创立了公理化集合论，直到1922年，经过Abraham Fraenkel的补充，形成了公理化集合论的公理系统ZF，后来加入选择公理，最终成为正式的集合论ZFC公理系统，由此建立起整个现代数学的大厦。
实际上，巴拿赫-塔尔斯基定理是选择公理的自然推论。也就是说，将刚性球剖分为无数的碎片，形状怪异，不可测度，然后，利用选择公理AC（Axiom of Choice)将其拼装成两个同样的刚性球。简单地说，选择公理保证：在一个集合族里面，从各个集合中各选取一个元素，这些元素可以构成一个新的集合。
在数学上，连续统假设CH，不真也不假，而选择公理AC，既是真的，又是假的（因为AC能够推出一个球变成两个球的怪论）。有人说，我们放弃选择公理AC行不行？不行，放弃了选择公理AC，数学将变得更加奇怪。数学存在这种毛病，大家见怪不怪也。
上述巴拿赫-塔尔斯基定理还可以推出更奇怪的结论：一颗豌豆可以变成硕大无比的太阳。现代数学的这个毛病，我们不要当众宣传，免得让数学家们丢面子。在这里，我只是悄悄地说话，而不是大声地嚷嚷。谈到这里，在同学面前，我有点不好意思了。
说明：A.Robinson的非标准分析（NSA）就是在ZFC大树上发出的新树枝，J. Keisler的无穷小微积分是更细小的嫩枝丫。我们想把中国的微积分教育移植到ZFC大道上，溯本清源，使其名正言顺。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03cafe72b43a38b336f1a8e80ca4ed79/" rel="bookmark">
			asp.net 自定义控件（2种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念
1. 构建自定义控件
目的：创建类似MS自带的控件，具有属性、方法、事件等特性，利于重用。 技术：HtmlTextWriter类---用于生成Html。 该类所支持的方法： AddAttribute()---给调用RenderBeginTag()生成的标签添加一个Html属性. AddStyleAttribute()---给调用RenderBeginTag()生成的标签添加一个CSS属性. RenderBeginTag()---生成开始Html标签. WriteBreak()—生成&lt;br /&gt;标签 方法所用枚举: HtmlTextWriterTag---Html标签列表 HtmlTextWriterAttribute—Html属性列表 HtmlTextWriterStyle---CSS属性列表. 重写RenderContents(HtmlTextWriter writer)用于呈现页面. 组合控件包含子控件,在属性内要强制调用EnsureChildControls(),重写CreateChildControls()方法 指定包围WebControl标签,重写HtmlTextWriter TagKey属性 在混合控件中,两种方法都要重写. 实现方式:在组件中编写代码.调用命名空间. System.Web.UI.Control 所有控件的基类 System.Web.UI.WebControls.WebControl 含有开始结束标签 System.Web.UI.WebControls.CompositeControl 组合控件 继承它们,然后在其中编写各种所需的属性\方法\事件.其布局方法用编码代替了直观的方法. 2. 视图状态和控件状态 视图状态概念:利用一个_VIEWSTATE隐藏表单域在页面回传中保存控件属性的状态.应用于简单的值. 目的:重复回传也能显示新文本 实现方式:添加ViewStateText属性 技术:ViewState[“Message”]=value 控件状态概念:添加在控件状态中的值保存在_VIEWSTATE中,而它不能被禁用. 目的:用于在页面回传中存贮最重要的信息 技术:重写OnInit(EventArgs e) SaveControlState() 保存 LoadControlState(object saveState) 加载 3. 处理回传数据 目的:用于状态表单域数据传给控件.相当于事件的实现. 技术:实现IPostBackDataHandler接口 所包含的方法:LoadPostData() 搜索从浏览器传回的表单域. RaisePostDataChangedEvent() 引发表单域的值发生改变的事件 实现方式:从WebControl,IpostBackDataHandler继承 分别定义事件\视图\属性\表现\接口的方法. 处理回传数据,例如:button的事件就是用来处理回传事件的 技术:实现IpostBackEventHandler接口 包括:RaisePostBackEvent()方法,用于服务器端调用 Page.ClientScript.GetPostBackClientHyperlink(this,String.Empty)返回在浏览器引起表单回传的JavaScript. 传递回传时间参数 可为GetPostBackClientHyperlink()提供可选参数,其值可传到服务器端的RaisePostBackEvent()中. 使用回传选项 PostBackOptions类指定回传属性,例如ActionUrl跨页提交,验证,焦点等. Page.ClientScript.GetPostBackEventReference(options);实例化后传递给方法. 实现方式: 4. 使用控件属性集合 目的:创建表示对象集合的控件,如DropDownList 技术:ParseChildren attribute 如何分析控件包含内容 [ParseChildren(true)]所包含内容作属性分析 [ParseChildren[(false)]独立分析 ControlBuilder 自定义此类去修改控件解析内容 包含方法:AllowWhiteSpaceLiterals() 删除空间内容所有空白 AppendLiteralString()删除空间内容中中所有空白 GetChildControlType() 指定某种标签解析成哪种控件 AddParsedSubObject() 指定把哪些解析过的控件添加到Controls集合.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03cafe72b43a38b336f1a8e80ca4ed79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aaf5c87ba66f48309f3a3158e20e10e/" rel="bookmark">
			Crawlzilla搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		crawlzilla 介绍：http://code.google.com/p/crawlzilla/wiki/SystemInstall
安装：
1、sun-java6
sudo add-apt-repository "deb http://us.archive.ubuntu.com/ubuntu/ hardy multiverse"
sudo apt-get update
sudo apt-get install sun-java6-jdk
2、解决 lang 的问题
http://mylovejsj.blog.163.com/blog/static/3867397520110711146668/
3、解决搜索关键词结果页空白的问题
定时重启 tomcat
在 crawler 用户终端中执行 crontab -e
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1474aa69bdb1cb857e5cfc71ef7d9741/" rel="bookmark">
			c#中接收16进制串口数据(com), 在textbox显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		static int buffersize = 18; //十六进制数的大小（假设为9Byte,可调整数字大小） byte[] buffer = new Byte[buffersize]; //创建缓冲区
private void button1_Click(object sender, EventArgs e) { serialPort1.Read(buffer, 0, buffersize); string ss; ss = byteToHexStr(buffer); //用到函数byteToHexStr textBox2.Text = ss; serialPort1.Close(); MessageBox.Show("数据接收成功！", "系统提示"); }
//字节数组转16进制字符串 public static string byteToHexStr(byte[] bytes) { string returnStr = ""; if (bytes != null) { for (int i = 0; i &lt; bytes.Length; i++) { returnStr += bytes[i].ToString("X2"); } } return returnStr; }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1474aa69bdb1cb857e5cfc71ef7d9741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a17b7ecc3a3f5364ed5c9f9318262d/" rel="bookmark">
			Virgo Tomcat Server是什么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Virgo Tomcat Server是什么?
Virgo Tomcat Server, 简称VTS, 是Virgo Server应用服务器的一种. 它是轻量级, 模块化, 基于OSGi系统。提供从开发，部署到管理企业级应用的一整套解决方案。通过利用相关的优秀技术并且在他们之上作出扩展与改善，使的VTS能够提供一套非常酷的企业级解决方案。
Virgo Tomcat Server是由什么构成的?
Virgo Tomcat Server 是建立在下面技术之上的:
Spring Framework, 很显然!Tomcat 作为一个外部容器.OSGi R4.3.Equinox作为OSGi实现.Spring Dynamic Modules for OSGi 使OSGi能工作在Spring下.SpringSource Tool Suite 开发工具. 注意 ，Virgo Tomcat Server不仅仅是将这些技术的一个组合， 在一定程度上,它是将他们整合在一起并且扩展了这些技术从而提供了一些不可或缺的特性来支持开发部署和管理当今的企业级应用。
下图为VTS的架构
Virgo Tomcat Server的心脏是Virgo Kernel简称VK. VK基于OSGi，并且充分利用OSGi的模块化和版本控制。 VK构建在Equinox之上，扩展了它的部分特性，来支撑应用配置和库文件的管理， 而且为VTS提供核心功能。
为保持最小的运行环境, VK会根据需要安装必要的OSGi bundles，这样是为了可以将应用安装到运行中的VTS中并且安装应用需要的依赖库。不需要自己手动删除与安装应用的依赖，那将相当麻烦，VK会保持最小的内存使用率，并且VTS提供管理工具帮助开发者管理依赖库。
图中, 在Jvm中VK运行在Equinox之上 。 VK之上提供管理，服务功能，和Web应用的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f4c332d37a193ac78b4301bd86c432/" rel="bookmark">
			利用PANEL来控制窗体的技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PANEL作为一个容器，能容所有的控件，类似这样的控件如PICTUREBOX,GROUPbox不过它的实际用处的精妙之处，需要仔细来理解的
新建一个窗体form1,在里面放一个panel控件， 设置autosize=true 如图：
再添加一个窗体FORM2，里面放置一个picturebox1,两个按钮，如图
在form2的代码：
Public Class Form2
Private Sub Button2_Click(sender As System.Object, e As System.EventArgs) Handles Button2.Click
Me.Close()
End Sub
Private Sub Button1_Click(sender As System.Object, e As System.EventArgs) Handles Button1.Click
MsgBox("你好")
End Sub
End Class
在form1 的代码：
Private Sub Button1_Click(sender As System.Object, e As System.EventArgs) Handles Button1.Click
Dim frm As New Form2
frm.TopLevel = False ‘这一行不能少。
Me.Panel1.Controls.Add(frm) ’将窗体添加到容器中
frm.Show()
End Sub
然后运行此窗体，你会看到很不错的效果了，你将里面的form2最大化，PANEL也会跟随最大化。并且很适应的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9814c2a41f97650336b1a1240abffc1/" rel="bookmark">
			C#后台提示警告框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Response.Write
("&lt;script&gt;alert('查询语句执行出错！');window.location.href=DisplayData.aspx&lt;/script&gt;");
2、Page.RegisterStartupScript("msg", "&lt;script&gt;alert('查询语句执行出错！');window.location.href='DisplayData.aspx'&lt;/script&gt;");
一般后台弹出提示框，都是用Page.RegisterStartupScript，不用Response.Write的
3、ClientScript.RegisterStartupScript(this.GetType(), "", " &lt;script lanuage=javascript&gt; alert('');location.href='';&lt;/script&gt;"); 4、System.Web.HttpContext.Current.Response.Write(String.Format("&lt;script language=\"javascript\"&gt;alert(\"{0}\");window.location.replace(\"{1}\")&lt;/script&gt;", strMessage, strRedirectUrl));
5、ScriptManager.RegisterStartupScript(this, this.GetType(), "u1", "alert('内容！')", true);
6、Page.ClientScript.RegisterStartupScript(this.GetType(), "d", "alert('请先登录！');location='../login.aspx';", true);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca0c4fdb7993ad147fc5b59c7867614/" rel="bookmark">
			负数-补码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看网络小说热血传奇之路，提到游戏里的沙巴克刷钱bug，说是当沙城的钱负到21亿的时候会开始变正。虽然传奇玩的较晚，时间也不长也不深入，不知道这事，但是小说作者作为传奇的骨灰级玩家，提到的这事让我很感兴趣，就从21亿这个数来看，这事肯定是真的了。显然这21亿就是int的最大值2147483647了，而且涉及到负数的问题，想起以前关于负数补码的知识看过但没通透，今天把它弄明白。 看了些补码的知识，摘抄了些，自己整理了些。 顺便带着两个小问题：
INT_MAX = 2147483647 ;
cout&lt;&lt;INT_MAX+1&lt;&lt;endl; //正确结果为-2147483648
UINT_MAX = 4294967295；
cout&lt;&lt;UINT_MAX+1&lt;&lt;endl; //正确结果为0
开始正文： 负数在计算机中如何表示？
举例来说，+8在计算机中表示为二进制的1000，那么-8怎么表示呢？
很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+8就是00001000，而-8则是10001000。
但是，随便找一本《计算机原理》，都会告诉你，实际上，计算机内部采用2的补码（Two's Complement）表示负数。
什么是2的补码？
它是一种数值的转换方法，要分二步完成：
第一步，每一个二进制位都取相反值，0变成1，1变成0。比如，00001000的相反值就是11110111。
第二步，将上一步得到的值加1。11110111就变成11111000。
所以，00001000的2的补码就是11111000。也就是说，-8在计算机（8位机）中就是用11111000表示。
不知道你怎么看，反正我觉得很奇怪，为什么要采用这么麻烦的方式表示负数，更直觉的方式难道不好吗？
为什么要用2的补码
首先，要明确一点。计算机内部用什么方式表示负数，其实是无所谓的。只要能够保持一一对应的关系，就可以用任意方式表示负数。所以，既然可以任意选择，那么理应选择一种最方便的方式。
2的补码就是最方便的方式。它的便利体现在，所有的加法运算可以使用同一种电路完成。
还是以-8作为例子。
假定有两种表示方法。一种是直觉表示法，即10001000；另一种是2的补码表示法，即1 1111000。请问哪一种表示法在加法运算中更方便？
随便写一个计算式，16 + (-8) = ? 1 0001000 取反 1 1110111 加1 +1 = 1 1111000 再取反 1 0000111 + 1 = 1 0001000 取反不不包括符号位两次取反得到原值 正数的补码是其本身 负数的补码是符号位不变 其他位取反之后加1 连着变换两次相当于没有做任何操作
16的二进制表示是 00010000，所以用直觉表示法，加法就要写成： ０００１００００ ＋１０００１０００
－－－－－－－－－
１００１１０００
可以看到，如果按照正常的加法规则，就会得到10011000的结果，转成十进制就是-24。显然，这是错误的答案。也就是说，在这种情况下，正常的加法规则不适用于正数与负数的加法，因此必须制定两套运算规则，一套用于正数加正数，还有一套用于正数加负数。从电路上说，就是必须为加法运算做两种电路。
现在，再来看2的补码表示法。
０００１００００
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca0c4fdb7993ad147fc5b59c7867614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ada29a262d58ffa9fca7f38282a23d8/" rel="bookmark">
			设置 DevMgr_Show_NonPresent_Devices 令未连接的历史设备在 Windows 设备管理器中现形...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转自：http://blogs.itecn.net/blogs/alexis/archive/2011/07/07/How-to-show-NonPresent-Devices-in-Device-Manager.aspx
Windows 设备管理器通常只会显示已经连接至计算机的设备，不会显示未连接至计算机的设备。如果我们 希望显示那些以前曾经连接过、但目前没有连接至计算机的历史硬件设备，可以在 CMD 命令提示符中输入 并执行：
SETDevmgr_show_nonpresent_devices=1 在 Windows 7/Vista 中需要以管理员权限运行命令提示符。而且需要注意的是，在命令提示符中执行 SET Devmgr_show_nonpresent_devices=1 只是一个暂时性设置，此功能在命令提示符关闭后就会自动失效。 如果我们希望一劳永逸，长期在设备管理器中显示历史设备记录，可以在控制面板中打开“系统”属性， 点击“高级系统设置”，切换至“高级”选项卡，再点击“环境变量”，然后在“用户变量”中新建变量 Devmgr_show_nonpresent_devices，并将其值设置为 1 即可。 或者，我们还可以下载使用微软网站提供的 Fixit 50606 工具帮助设置此变量： http://go.microsoft.com/?linkid=9763244 然后我们打开设备管理器，在“查看”菜单中选择“显示隐藏的设备”，即可在设备管理器中查看已经连接 及未连接的所有硬件设备，包括任何曾经在计算机中使用过哪怕仅一次的历史硬件设备。其中，已经连接至 计算机的设备将以实色图标显示，未连接至计算机的历史设备将以暗灰色图标显示。例如，经常向他人借用 闪存盘的用户，可能会在“通用串行总线控制器”中看到几十个以暗灰色图标显示的 USB Mass Storage Device，这些均是以前曾经连接过的闪存盘留下的历史记录。只有当前已经连接至计算机的闪存盘，才会 以实色图标显示。 那么，在设备管理器中显示这些连接过的历史设备记录有什么用处呢？它可以帮我们处理一些驱动程序配置 方面的 故障。例如： 1. 某些驱动程序曾经安装失败的硬件设备可能会在设备管理器中显示为带有问号的未知设备，或者显示为 Unknown Device 等。由于存在错误的历史驱动配置，Windows 在每次连接这些设备后都会自动沿用之前 错误的驱动配置，这可能会影响我们重新安装正确的驱动程序。如果我们用在设备管理器中显示历史设备的 方法，在重新连接设备之前在设备管理器中显示并删除有问题的设备配置，可以令 Windows 恢复至从来 没有连接过这些设备的初始状态。这样下一次再连接这些设备时，Windows 就不会再沿用之前错误的驱动 配置了，而是提示我们重新配置正确的驱动。 2. 如果我们需要为计算机更换一种完全不同规格的设备，最好也在拔出旧设备之后用在设备管理器中显示并 删除历史设备的方法删除旧设备配置，以确保新设备的正常运行。例如，假如我们之前使用 nVIDIA 显卡， 现在需要更换 ATi 显卡，最好在连接新显卡之后在设备管理器中将已不存在的 nVIDIA 显卡删除，然后卸载 全部 nVIDIA 显示驱动程序，以确保 ATi 显卡的正常运行及 ATi 显示驱动程序的顺利安装。 3. 有时我们出于一些原因可能会为部分设备更换接口，每一次更换接口都会引起 Windows 重新配置驱动， 并在设备管理器中将设备重新显示为 # 加数字后缀的设备名称，更换接口的次数越多，# 后面的数字后缀 就 越大。特别如果是网络适配器的话，还可能会引起“网络连接”中生成一堆带有数字后缀的“本地连接” 图标。其实，这都是因为同一件设备在更换接口前的配置占用了设备历史记录，因为这些历史记录的存在， Windows 才会将更换接口后的设备视作新的设备，并添加 # 加数字后缀以示区别。如果我们在多次更换 接口后希望去掉设备名称的数字后缀，就可以用在设备管理器中显示并删除历史设备的方法删除更换接口 之前的设备历史记录，令 Windows 恢复至从来没有连接过这些设备的初始状态。这样下一次再连接这些 设备时，Windows 就不会再因为历史记录的存在而为设备名称添加 # 及数字后缀了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c6cf79931c54c837ab5b0518093cc4/" rel="bookmark">
			NoMethodError: undefined method `init&#39; for Mysql:Class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天闲来无事，在ubuntu上源码安装了mysql 5.1.57，安装过程在这里不详细叙述，在安装完后，把mysql的配置文件my.cnf放到了/etc下，即/etc/my.cnf在里面做了mysql的socket指向（/usr/local/tmp/mysql.sock）然后启动mysql，一切正常。ok，到此为止我以为万事大吉了，然后我进入到项目的根目录，rails c 进入控制台，执行一个简单的查询，问题出现了： NoMethodError: undefined method `init' for Mysql:Class不知道啥原因，一番google后，发现有人说需要安装mysql驱动，ok，于是 gem install mysql ，结果在执行安装的过程中又出现了错误： ERROR: Error installing mysql: ERROR: Failed to build gem native extension. 没办法，继续google，原来是缺少了依赖包，ok，继续安装相关的依赖包： sudo apt-get install libmysqlclient-dev 之后，继续 gem install mysql，ok，这次没有发现问题了，然后进入到项目的跟目录，rails c 进入控制台，执行简单的查询，完了，又报错了：Can't connect to local MySQL server through socket '//var/run/mysqld/mysqld.sock' (2),一看，很明显，在链接的时候mysql找不到socket文件，咦，但是问题来了啊，我刚刚已经把mysql配置好了啊，而且我可以进入到mysql里面去执行查询了啊，怎么现在忽然报这个socket错误呢。好吧，我来看看，我刚才的这一串操作后，给我的mysql造成了什么影响，我进入到/etc,然后进入到我的my.cnf文件，发现里面没有任何改动的迹象，奇怪了，但是当我在/etc下边ll mysql的时候发现了一个问题，在这个/etc目录下多了一个目录mysql，然后我进入到这个目录，发现里面也有个my.cnf，里面的socket指向刚好是上边报的找不到socket的路径，这就是说，在用程序链接mysql的时候，mysql读取了/etc下的my.cnf文件了，而并没有读取我的/etc/my.cnf文件，这个mysql文件目录是怎么来的呢，应该是我在前边安装libmysqlclient-dev的时候生成的。ok，问题的原因找到了，那么对于我现在遇到的问题怎么解决呢？好吧，我进入到了项目的database.yml文件，在每个环境的配置后边都加上了socket指向：socket: /usr/local/mysql/tmp/mysql.sock，ok，我再进入到项目跟目录，执行简单的查询，问题解决了，这就是说，我可以在项目里面来指定该项目用到的mysl的socket的位置。 问题是解决了，但是我们得想想啊，我不能在每个项目里面都配置这个socket吧，最好是在/etc下的my.cnf里面配置一遍，然后让mysql自己去找就可以了，我们就不用在每个项目地下都配置这个东东了，可是问题在于，现在的/etc下有两个my.cnf，到底该咋办？好吧，我们来看看，这两个文件是不是可以删除掉一个 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/885fc14db3c595bf170d1a48e230303e/" rel="bookmark">
			第一章 .Net 控件开发(WebForm) 开发简单自定义控件(9) 流程和生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 上章结束的时候已经把整个自定义简单控件的实现都讲好了。打算准备讲复合控件，但是还是有必要把自定义简单控件的流程和生命周期来讲下。
2、 流程： （1） 继承WebControl类，重写RenderContents方法；
（2） 设置最外层元素需要重写TagKey属性；
（3） 需要设置样式需要重写CreateControlStyle方法，如需要自定义需要继承Style或者Style的子类；
（4） 设置Html元素的ID和Name属性时设置它的唯一性；
（5） 自定义数据事件类时，继承或者直接使用EventArgs类；
（6） 显示实现IPostBackEventHandler和IPostBackDataHandler接口。
using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Web.UI.WebControls;using System.Web.UI;namespace WebFormControl{public class TestControlSum:WebControl,IPostBackEventHandler,IPostBackDataHandler{protected override void RenderContents(System.Web.UI.HtmlTextWriter writer){base.RenderContents(writer);//（1）继承WebControl类，重写RenderContents方法；}protected override System.Web.UI.HtmlTextWriterTag TagKey{get{return base.TagKey;//（2）设置最外层元素需要重写TagKey属性；}}protected override Style CreateControlStyle(){return base.CreateControlStyle();//(3)}// （4）	设置Html元素的ID和Name属性时设置它的唯一性；// （5）	自定义数据事件类时，继承或者直接使用EventArgs类；void IPostBackEventHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/885fc14db3c595bf170d1a48e230303e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a785b5c35ff15f3622d12f403a2fce1e/" rel="bookmark">
			c#中 把字符串转换为拼音码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static string GetPinyinCode(string str)
{
string pyCode = "";
string[] PY = new string[26];
bool IsFound;
PY[0] = "啊阿呵吖嗄腌锕錒厑爱矮挨哎碍癌艾唉哀蔼隘埃皑呆嗌嫒瑷暧捱砹嗳锿霭乂伌僾儗凒叆呝啀嘊噯堨塧壒娭娾嬡愛懓懝敱敳昹曖欸毐溰溾濭烠焥璦皚皧瞹硋磑絠薆藹譪躷鎄鑀阸靄靉餲馤騃鱫鴱按安暗岸俺案鞍氨胺庵揞犴铵桉谙鹌埯黯侒儑匼厈咹唵啽垵垾堓婩媕峖晻洝玵痷盦盫罯腤荌菴萻葊蓭裺誝諳豻貋銨錌隌雸鞌韽頞馣鮟鴳鵪鶕昂肮盎卬岇昻枊醃醠骯袄凹傲奥熬懊敖翱澳拗媪廒骜嗷坳遨聱螯獒鏊鳌鏖岙厫嗸噢嚻垇墺奡奧媼嫯岰嶅嶴慠扷抝摮擙柪梎泑滶澚熝爊獓璈眑磝磽礉翶翺芺蔜蝹襖謷謸軪鏕镺隞驁鰲鴁鴢鷔鼇";
PY[1] = "把八吧爸拔罢跋巴芭扒坝霸叭靶笆疤耙捌粑茇岜鲅钯魃菝灞仈伯叐哱哵坺垻墢壩夿妭峇弝抜抪捭朳柭欛炦犮玐癹皅矲笩紦罷羓胈萆蚆覇詙豝跁軷釛釟鈀颰魞鮁鮊鲃鲌鼥百白摆败柏拜佰稗呗掰唄庍拝挀擺敗栢猈竡粨粺絔薜薭襬贁鞁鞴韛兡瓸半办班般拌搬版斑板伴扳扮瓣颁绊癍坂钣舨阪瘢並坢埿姅岅彬怑搫攽斒昄朌柈湴瓪秚籓粄絆肦蝂螁螌褩覂豳跘辦辧辨辩辬辯鈑鉡闆靽頒魬鳻帮棒绑磅镑邦榜蚌傍梆膀谤浜蒡嗙垹埲塝嫎峀幇幚幫徬挷捠搒棓牓玤硥稖綁縍艕蚄蛖蜯螃謗邫鎊鞤騯髈包抱报饱保暴薄宝爆剥豹刨雹褒堡苞胞鲍龅孢煲褓鸨趵葆佨儤剝勹勽嘐嚗堢報媬嫑寚寳寶忁怉曓枹珤砲窇笣簿緥菢蕔藵虣蚫袌裒裦襃賲鉋鑤铇闁靌靤飹飽駂骲髱鮑鳵鴇齙萡被北倍杯背悲备碑卑贝辈钡焙狈惫臂褙悖蓓鹎鐾邶孛陂碚俻俾偝偹備僃喺埤愂憊揹昁杮柸桮梖椑波牬犕狽珼痺盃禙箃糒苝萯藣蛽誖諀貝軰輩鄁鉳鋇錍鐴骳鵯本奔苯笨夯锛贲畚坌倴喯夲奙捹撪桳楍泍渀燌犇獖翉蟦賁輽逩錛鐼蹦绷甭崩迸泵甏嘣伻傰唪埄堋塴奟嵭漨琣琫痭祊絣綳繃菶跰逬錋鏰镚閍鞛比笔闭鼻碧必避逼毕彼鄙壁蓖币弊蔽毙庇敝陛毖痹泌秕荸芘匕裨畀嬖狴筚箅篦舭荜襞庳铋跸吡愎滗濞璧哔髀弼妣婢仳佊佖偪匂咇啚嗶坒堛夶奰妼娝媲嬶屄崥幣幤庀廦弻彃怭怶悂愊斃旇朼枈柀柲梐楅檗殍毴沘湢滭潷煏熚獘獙珌畁畢疕疪皀皕瞥禆稫笓筆箄箆篳粃粊紕紴綼縪繴纰罼翍聛肶肸胇脾腗腷苾萞蓽蘗蜌螕袐襅襣觱詖诐豍貏貱費贔赑跛踾蹕躃躄邲鄨鄪鈚鉍鎞鏎閇閈閉閟闬陴鞞鞸韠飶饆馝馥駜驆髲魓魮鮅鮩鰏鲾鵖鷝鷩鸊鼊边变便遍编扁贬鞭卞辫忭砭匾汴碥蝙褊鳊笾苄窆弁髟缏煸変峅徧惼抃揙昪汳炞牑猵獱甂稨稹箯籩糄編緶臱艑萹藊覍覵變貶辡辮邉邊釆鍽鞕鯾鯿鴘鶣表标彪膘杓婊飑飙鳔瘭飚镳裱骠镖俵僄儦墂幖徱摽標檦淲滮漂瀌灬熛爂猋穮篻脿膔臕蔈藨褾諘謤贆錶鏢鑣颮颷飆飇飈飊驃驫骉鰾麃别憋鳖瘪蹩別彆徶撆撇猰癟穪莂虌蛂蟞襒鱉鼈龞宾濒摈斌滨膑殡缤髌傧槟鬓镔玢儐擯椕殯氞汃濱濵瀕瑸璸砏繽臏虨蠙訜豩賓賔贇赟邠鑌霦顮髕髩鬂鬢并病兵冰丙饼秉柄炳摒禀邴仌併倂偋傡冫垪寎幷庰怲抦掤昞昺枋栟栤梹棅檳氷燷燹琕癛癝眪稟窉竝綆绠苪蛃誁鈵鉼鋲陃靐鞆餅餠拨播泊博驳玻勃菠钵搏脖帛舶渤铂箔膊魄卜礴亳鹁踣啵蕃簸钹饽擘仢侼僠僰噃壆孹嶓帗彴愽懪挬撥桲榑檘欂殕泼浡淿湐潘煿牔犦犻狛猼瓝瓟癶皪盋砵碆磻礡秡穛箥簙糪缽肑胉艊艴苩葧蒲蔔蔢蘖蚾袚袯袹襎襏襮譒豰蹳郣鈸鉑鉢鋍鎛鑮镈餑餺馎馛馞駁駮驋髆髉鱍鵓不步补布部捕哺埠怖埔瓿逋晡钸钚醭卟佈勏吥咘埗婄尃峬庯廍悑拊捗擈柨歨歩獛秿箁篰荹蔀補誧踄輹轐郶鈈鈽陠餔餢鯆鳪鵏鸔";
PY[2] = "厂擦拆礤嚓傪囃攃橴磣礸蔡遪才菜采材财裁猜踩睬彩倸偲啋埰婇寀戝扐採揌棌綵縩纔財跴乲蚕残掺参惨惭餐灿骖璨孱黪粲儏參叄叅喰嘇噆囋嬠嬱嵾慘慙慚憯戔摲朁殘湌澯燦爘穇篸薒蝅蠶蠺謲鏒飡飱驂鯵鰺鲹黲藏仓沧舱苍伧仺倉傖凔匨嵢欌滄濸獊瑲篬罉臧艙蒼蔵螥賶鑶鶬鸧草操曹槽糙嘈艚螬漕傮屮嶆愺慅慒懆撡曺肏艸艹蓸褿襙鄵鏪鐰騲鼜册侧策测厕恻側冊厠墄嫧帻幘廁惻憡拺敇測畟笧筞筴箣簎粣荝萗萴蓛齰岑涔梣汵硶笒膥曾层蹭噌增層嶒橧竲繒缯驓硛硳岾猠乽查插叉茶差岔搽察茬碴诧槎镲衩汊馇檫姹杈锸仛侘偛嗏垞奼岎嵖扠扱挿捈揷摖査梌猹疀秅紁肞臿艖芆苴荖荼褨訍詧詫蹅釵銟鍤鎈鑔钗靫餷柴豺瘥虿侪儕勑喍囆搓犲祡茈茝蔕蠆袃齜龇产缠搀阐颤铲谗蝉馋觇婵蒇谄冁廛蟾羼镡忏潺禅骣躔澶丳亶佔僝僤儃儳刬剗剷劖単啴嘽嚵囅團墠壥嬋嬗嵼嶃嶄巉幝幨憚懴懺摌摻撣攙斺旵梴棎榐欃毚浐湹滻潹瀍瀺灛煘燀獑產産硟磛禪簅緂緾繟繵纏纒脠艬苫蕆螹蟬蟺袩裣裧襌襜襝覘誗諂譂讇讒讖谶蹍辿鄽酁醦鉆鋋鋓鏟鑱镵閳闡韂顫饞长唱常场尝肠畅昌敞倡偿猖鲳氅菖惝嫦徜鬯阊怅伥昶苌娼仧倀倘僘償儻兏厰嘗嚐場塲廠悵晿暢棖椙淌淐焻玚琩瑒瑺瓺甞畼腸膓萇蟐裮誯鋹鋿錩鏛锠長镸閶闛韔鯧鱨鲿鼚朝抄超吵潮巢炒嘲绰钞怊焯耖晁仦仯劋勦巐巣弨摷槱樔欩漅焣煼牊眧窲粆綽繛绉绍罺觘訬謅謿趠轈鄛鈔麨鼂鼌车撤扯掣彻尺澈坼砗伡俥偖勶呫唓喢夛奲徹揊摰撦斥池烢烲焎爡瞮硨硩聅莗蛼詀謵車迠頙趁称辰臣尘晨沉陈衬橙忱郴榇抻谌碜宸龀嗔琛侲儭嚫塡塵墋夦愖捵揨敐曟桭棽樄櫬湛瀋烥煁疢疹瘎瘨眈瞋稱綝縝肜胂茞莀莐蔯薼螴襯訦諃諶謓賝贂趂趻跈踸軙迧鈂鍖闖闯陳霃鷐麎齓齔成乘撑城程呈诚秤惩逞骋澄承塍柽埕铖铛酲晟裎枨蛏丞瞠乗侱偁僜埩堘塖娍宬峸嵊庱徎徵悜憆憕懲挰掁摚摤撐撜朾棦椉橕檉檙氶泟洆浧浾溗澂瀓瀞爯牚珵珹琤畻睈矃碀窚竀筬絾緽脀脭荿蟶觕誠赪赬踜郕郢鋮鏳鏿阷靗頳饓騁騬鯎吃迟翅痴赤齿耻持侈弛驰炽踟坻茌墀饬媸豉褫敕哧瘛蚩啻鸱眵螭篪魑叱彳笞嗤傺佁侙俿剟勅卙卶叺呎呬呮喜喫噄噭坘垑奓妛岻彨彲徲恜恥慗慸憏懘扡抶拕拸捇搋摛摴攡杘柅樆欼歗歯汖沶治泜淔湁漦灻烾熾狋瓻痓痸瘈癡眙瞝竾筂箈箎粚糦絺翄翤翨耛肔胝胣胵脪腟芪荎莉菭蚇蚳蛇蝭袲袳裭訵誀誃誺謘謻貾赿趍趐趩跅跢跮踅踶軧迡迣遅遟遫遲邌鉓鉹銐鍉雴饎馳騺驪鳷鴟鵄鵣鶒鶗鶙鷘麶黐齒齝冲重虫充宠崇艟忡舂铳憧茺偅傭僮喠嘃埫寵崈徸憃揰摏樁沖浺漴潼爞珫痋祌緟罿翀蝩蟲衝褈蹖蹱酮銃隀抽愁臭仇丑稠绸酬筹踌畴瞅惆俦帱瘳雠丒侴偢儔吜嚋婤媿嬦幬懤掫揄搊擣杽栦椆檮殠溴燽牰犨犫畤疇皗盩眣矁篘籌紬絒綢臰菗薵裯詶譸讎讐诪跾躊遚酧醔醜醻鈕钮雔魗鮘鯈鲋出处初锄除触橱楚础储畜滁矗搐躇厨雏楮杵刍怵绌亍憷蹰黜蜍樗俶傗儊儲処助嘼埱媰岀幮廚慉懨拀摢敊斶椘榋槒橻檚櫉櫖櫥欪歜滀濋炪犓珿琡璴礎禇竌竐篨絀耝耡臅芻菆蒢蒭蓫蕏藸處蟵蠩褚觸諔諸豖豠貙趎踀躕鄐鉏鋤閦雛鶵鸀齣齭齼撮欻歘揣膪啜嘬踹腄膗穿船传串川喘椽氚遄钏舡舛巛傳僢剶圌堾惴掾暷歂汌猭玔瑏甎篅膞舩荈賗踳輲釧镩鶨窗床创疮怆傸刅刱剏剙創噇囪囱愴戧摐朣橦漺牀牎牕瘡磢窓窻膧葱蔥吹垂炊锤捶椎槌棰陲倕埀惙搥桘箠菙郵錘鎚顀鬌魋龡春唇纯蠢醇淳椿蝽莼鹑偆媋惷旾暙朐杶楯槆橁櫄沌浱湻滣漘犉瑃睶箺純肫脣芚萅萶蒓蓴賰輇輴辁醕錞陙鯙鰆鶉鶞戳踔龊辍促吷嚽娕娖婥婼孎擉斫歠涰淖磭箹簇蔟輟辵辶逴酫醛鋜鏃鑡镞齪齱次此词瓷慈雌磁辞刺茨伺疵赐兹呲鹚祠糍佌佽偨刾呰啙垐堲姕嬨嵯嵳庛措朿柌栜栨泚滋澬濨玼珁甆皉礠絘縒胔茦茲荠莿萕薋薺蚝蛓螅螆蠀詞賜赼趀趑跐辝辤辭鈶飺餈骴髊鮆鴜鶿鷀齹嗭从丛匆聪琮枞淙璁骢苁偬叢婃孮従徖從忩怱悤悰憁暰棇楤樅樬樷欉漎漗潀潈潨灇焧熜燪爜瑽瞛碂篵総緫縦縱總繱纵聡聦聰茐蓯藂蟌誴謥賨賩鏦騘驄凑楱辏腠湊薮藪趋輳粗醋徂猝蹙酢殂蹴卆噈媨怚憱捽瘄瘯皻縬脨蔍蔖誎趗趥踓踤踧蹵錯错顣麁麄麆麤鼀窜蹿篡攒汆爨撺僔巑攅攛攢昕櫕欑殩濽灒熶穳窾竄篹簒襸躥鋑鑹催脆摧翠崔淬瘁粹璀啐悴萃毳榱乼伜倅凗啛墔崒崪嶉忰慛椊槯漼濢焠熣獕琗疩皠磪竁粋紣綷縗繀缞翆脃脺膬膵臎襊趡鏙隹顇村寸存蹲忖皴侟刌吋墫拵洊浚澊竴籿踆邨挫磋厝鹾脞痤蹉锉矬剉剒夎庴棤澨營瑳睉莝莡蒫蓌虘諎躜躦逪遳酂酇醝銼鹺宷";
PY[3] = "单單掸多盯虰鐺黨哆柢踱大答达打搭瘩笪耷哒褡疸怛靼妲嗒鞑亣剳匒呾咑噠垯塌墶搨撘橽毼汏溚炟燵畗畣眔矺笚繨羍胆荅荙薘蟽觰詚跶躂迏迖迭逹達鎉鎝鐽韃龖龘带代戴待袋逮歹贷怠傣殆呔玳迨岱甙黛骀绐埭侢叇嘚垈帒帯帶廗懛曃柋棣毒瀻獃瑇箉簤紿緿艜蚮蝳螮襶詒诒貸蹛軑軚軩轪逯遞遰隶霴靆馱駄駘驮鴏黱但蛋担弹淡丹耽旦氮诞郸惮澹瘅萏殚聃箪赕儋啖丼伔倓冄冉刐勯匰唌啗啿嘾噉噡嚪壇妉娊媅帎弾彈惔憺抌撢擔柦檐欿殫沊泹澸狚玬瓭甔疍癉癚皽砃禫窞簞紞耼聸腅膻膽蜑蜒衴褝觛訑詹誕贉贍赡躭鄲酖醈霮頕餤饏馾駳髧鴠黕黮黵当党挡档荡谠宕菪凼裆砀偒儅噹圵垱壋婸崵嵣愓擋攩檔欓氹潒澢灙珰璗璫瓽當瘍盪瞊碭礑筜簜簹艡蕩蘯蟷襠譡讜趤逿闣雼到道倒刀岛盗稻捣悼导蹈祷纛忉焘氘叨刂啁嘄噵壔宲導屶島嶋嶌嶹捯搗朷椡槝檤洮燾瓙盜禂禱稲箌絩翢翿舠菿虭衜衟軇釖陦陶隝隯魛鱽的地得德底锝徳恴悳惪棏淂登鍀陟哋揼扥扽等灯邓瞪凳蹬磴镫噔嶝戥簦墱嬁櫈燈璒竳艠覴豋鄧鐙隥哣第低敌抵滴帝递嫡弟缔堤涤笛迪狄翟蒂觌邸谛诋嘀骶羝氐睇娣荻碲镝籴砥仾俤偙僀儥勺厎呧唙啇啲嚁坔埅埊埞墆墑墬奃媂嵽嶳廸弔弚弤彽怟扚拞掋揥摕敵旳杕枤梊梑楴樀浟渧滌焍牴玓珶甋疐眱碮磾祶禘篴糴締聜腣芍苐苖莜菂菧蓧蔋蔐藋藡蝃袛覿觝詆諟諦豴趆蹄蹏蹢逓適釱鉪鏑阺隄靮鞮頔題馰髢鬄魡鯳鸐嗲点电店殿淀掂颠垫碘惦奠典佃靛滇甸踮钿坫阽癫簟玷巅癜傎厧唸埝墊壂奌婝婰嵮巓巔扂拈攧敁敟椣槇槙橂橝湺澱琔痶癲磹腍蒧蕇蜓蜔蹎鈿電顚顛驔點齻掉钓叼吊雕调刁碉凋铞铫鲷貂伄佻刟奝嬥屌弴彫殦汈淍琱瘹瞗矵窎窵竨簓粜糶蛁蜩訋誂調軺轺釣鈟銱鋽錭鑃雿颩鮉鯛鳭鵃鵰鸼鼦爹跌叠碟蝶谍牒堞瓞揲蹀耋鲽垤喋佚咥啑峌崼幉怢恎惵戜挃挕昳曡柣楪槢殜氎泆渉渫牃畳疂疉疊眰絰绖耊胅臷艓苵蜨褋褶褺詄諜趃跕軼轶镻鞢鮙鰈鰨鳎嚸顶定订叮丁钉鼎锭町玎铤腚碇疔仃耵酊啶奵嵿帄忊掟椗汀濎甼矴碠磸聢艼萣葶薡訂釘鋌錠鐤靪頂顁飣饤鼑丢铥丟銩动东懂洞冻冬董栋侗恫峒鸫垌胨胴硐氡岽咚倲働凍動勭埬墥姛娻嬞峝崠崬戙挏昸東桐棟氭涷湩烔燑狫笗筩箽絧腖苳菄蕫蝀衕詷諌迵霘駧騆鮗鯟鶇鶫鼕都斗豆逗陡抖痘兜读蚪窦篼蔸乧侸兠凟剅吺唗投斣枓梪橷毭氀浢渎瀆窬竇脰艔荳讀郖酘酡鈄鋀钭閗闘阧餖饾鬥鬦鬪鬬鬭度渡堵独肚镀赌睹杜督犊妒顿蠹笃嘟椟牍黩髑芏剢剫匵厾噣塗妬嬻帾斁晵暏樚樞橐櫝殬殰涜牘犢獨琽瓄皾睪秺笁篤荰螙蠧裻襡襩覩読讟豄賭贕醏錖鍍鍺鑟锗闍阇陼靯韇韣韥頓騳黷段短断端锻缎椴煅簖偳剬塅媏彖斷毈瑖碫籪緞耑腶葮褍躖鍛鍴叾对队堆兑敦镦碓怼憝兊兌垖埻塠夺奪対對嵟憞懟杸濧濻瀢瀩痽磓祋綐膭薱謉譈譵鈗銳鋭鐓鐜锐陮隊頧鴭吨墩钝盾囤遁趸盹礅炖砘伅俊噸墪壿庉忳惇撉撴橔潡燉犜獤碷腞腯蜳踲蹾躉逇遯鈍驐朵舵剁垛跺惰堕掇躲沲咄铎裰哚缍亸凙刴喥嚉嚲垜埵墮墯媠嫷尮崜嶞憜挅挆敓敚敠敪朶柁柂柮桗椯橢毲沰澤痥硾綞茤詑貀趓跥躱軃鈬鐸陊隓飿饳鮵鵽";
PY[4] = "呃阨饿额鹅蛾扼俄讹遏峨娥恶厄鄂锇谔垩锷阏萼苊轭婀莪鳄颚腭愕噩鹗屙亞佮侉偔偽僞僫匎卾吪咢哑唖啈啞噁囐囮垭埡堊堮妸妿姶娿屵岋峉峩崿廅悪惡戹搕搤搹擜曷枙椏櫮歞歺涐湂玀珴琧皒睋砈砐砨硆硪磀礘蒍蕚蘁蚅蝁覨訛詻誐諤譌讍豟軛軶輵迗遌遻邑鈋鋨鍔鑩閜閼頟額顎餓餩騀鬲魤魥鰐鰪鱷鵈鵝鵞鶚齃齶齾诶恩摁蒽嗯奀峎煾饐鞥仒乻欕旕而二耳儿饵尔贰洱珥鲕鸸佴迩铒侕児兒刵咡唲嬭尒尓峏弍弐杒栭栮樲毦洏渪濡爾粫耏聏胹臑荋薾衈袻貮貳趰輀輭轜邇鉺陑陾隭餌駬髵髶鮞鴯";
PY[5] = "茷分紡纺怫琲茀蜚炃俸熢佛复幅拂服畐费鶝封疺份番發捬附发法罚伐乏筏阀珐垡砝佱傠姂廢彂栰橃汎沷泛灋琺発瞂罰罸蕟藅醗醱鍅閥髪髮反饭翻犯凡帆返繁烦贩范樊藩矾钒燔蘩畈蹯梵幡仮伋凢凣勫匥墦奿婏嬎嬏嬔忛憣払旙旛杋柉棥楓橎氾渢滼瀪瀿煩犿璠畨盕礬笲笵範籵緐繙羳膰舤舧薠蟠蠜袢訉販軓軬轓辺釩鐇颿飜飯飰鱕鷭放房防芳方访仿坊妨肪钫彷邡舫鲂倣匚堏旊昉昘汸淓牥瓬眆訪趽鈁錺雱髣魴鰟鳑鴋鶭非飞肥肺废匪吠沸菲诽啡篚腓扉妃斐狒芾悱镄霏翡榧淝鲱绯痱俷剕厞奜婓婔屝廃昲暃曊朏柹棐橨櫠渄濷猆疿癈砩祓笰紼緋绋胏胐萉蕜蕡蜰裴裵裶誹鐨陫靅靟飛飝餥馡騑騛髴鯡鼣芬粉坟奋愤纷忿粪酚焚吩氛汾棼瀵鲼偾鼢僨喷噴坆坋墳奮妢帉幩弅愍憤敃昐朆枌梤棻歕濆燓盼瞓秎竕糞紛羒羵翂膹葐蒶蚠蚡衯豮豶躮轒鈖錀隫雰餴饙馚馩魵鱝黂黺鼖风逢缝蜂丰枫疯冯奉讽凤峰锋烽砜酆葑沣仹偑僼凨凬凮堸夆妦寷峯崶捀摓桻檒沨浲湗溄灃炐焨煈犎猦琒甮瘋盽碸篈綘縫肨舽艂莑蘕蘴諷豊豐賵赗逄鄷鋒鎽鏠靊風飌馮鳯鳳鴌麷瓰覅仏仸坲梻否缶垺妚炰紑缹缻芣衃雬鴀副扶浮富福负伏付俯斧赴缚夫父符孵敷赋辅府腐腹妇抚覆辐肤氟俘傅讣弗涪袱甫釜脯腑阜咐黼苻趺跗蚨幞茯滏蜉菔蝠鳆蝮绂赙罘稃匐麸凫桴莩孚驸呋郛芙黻乀伕俌俛偩冨冹刜呒咈哹嘸坿垘妋姇娐婦媍宓岪峊巿弣彿復怤懯抙捊撫旉枎柎柫栿棴椨椱汱沕泭洑澓炥烰焤玞玸琈璷甶畉癁盙砆祔禣稪竎筟箙簠粰糐紨紱絥綍綒緮縛纀罦翇胕膚艀荂荴莆葍蓲蕧虙蚥蚹蛗蜅蝜衭袝複褔襆襥覄訃詂諨豧負賦賻軵輔輻邚邞郍郙鄜酜酻釡鈇鉘鉜錇鍑鍢锫阝陚韍韨頫颫駙鬴鮄鮒鮲鰒鳧鳬鳺鴔鵩麩麬麱猤";
PY[6] = "閡阂隑广干棍崗閞噶胳嘎轧钆伽旮尬尕尜呷嘠玍軋釓錷魀甴该改盖概钙芥溉戤垓丐陔赅乢侅匃匄咳姟峐忋摡晐杚槩槪漑瓂畡祴絯胲荄葢蓋該豥賅賌郂鈣鎅阣骸赶感敢竿甘肝柑杆赣秆旰酐矸疳泔苷擀绀橄澉淦尴坩个乹乾亁仠佄倝凎凲咁尲尶尷幹忓扞攼桿榦檊浛漧灨玕皯盰稈笴筸篢簳粓紺芉虷衦詌諴豃贑贛趕迀釬錎飦骭魐鰔鱤鳡鳱刚钢纲港缸岗杠冈肛筻罡戆冮剛堈堽岡戅戇掆棡槓溝焵牨犅犺疘矼碙綱罁罓釭鋼鎠阬頏颃高搞告稿膏篙羔糕镐皋郜诰杲缟睾槔锆槁藁勂吿咎夰峼暠槀槹橰檺櫜浩滜澔獋獔皐祮祰禞稁稾筶縞羙臯菒蒿藳誥鋯鎬韟餻髙鷎鷱鼛各歌割哥搁格阁隔革咯葛蛤戈鸽疙屹铬硌骼颌袼塥虼圪镉仡舸嗝膈搿纥哿佫個匌可吤呄嘅嘢彁愅戓戨扢挌擱敋槅櫊滆滒牫牱犵猲獦秴箇紇肐臈臵茖菏蛒裓觡詥諽謌轕鉀鉻鉿鎑鎘鎶钾铪閘閣閤闸鞈鞷韐韚頜騔髂魺鮥鮯鲄鴐鴚鴿鵅给給跟根哏茛亘艮揯搄痕更耕颈梗耿庚羹埂赓鲠哽亙刯堩峺恆挭掶暅椩浭焿畊絙絚緪縆羮莄菮賡郉郠頸骾鯁鶊鹒嚿啹喼嗰工公功共弓攻宫供恭拱贡躬巩汞龚肱觥珙蚣匑匔厷咣唝嗊塨宮幊廾愩慐拲杛栱渱熕碽糼羾虹蛩觵貢躳輁銾鞏髸魟龏龔兝兣够沟狗钩勾购构苟垢岣彀枸鞲觏缑笱诟遘媾篝佝傋冓呴坸夠姤抅搆撀構泃煹玽簼緱耇耈耉茩蚼袧褠覯訽詬豿購軥鈎鉤雊韝鮈鴝鸜鸲古股鼓谷故孤箍姑顾固雇估咕骨辜沽蛊贾菇梏鸪汩轱崮菰鹄鹘钴臌酤呱鲴诂牯瞽毂锢牿痼觚蛄罟嘏傦僱凅劷哌唂唃啒嗀嗗堌夃嫴尳峠崓怘愲抇柧棝榖榾橭櫎泒淈濲瀔焸瓠皷盬硲磆祻稒穀笟箛篐糓縎罛羖胍脵苽蓇薣蛌蠱詁軱軲轂逧鈲鈷錮頋顧餶馉骰鮕鯝鴣鵠鶻鼔挂刮瓜寡剐褂卦鸹栝诖冎剮劀叧咶咼啩坬掛歄煱絓緺罣罫詿諣趏踻銛銽铦颪颳騧鴰怪拐乖掴叏哙噲夬恠枴柺关管官观馆惯罐灌冠贯棺盥掼涫鳏鹳倌丱卝婠悹悺慣懽摜斡果桄樌權毌泴淉淪潅爟琯瓘痯瘝癏矔礶祼窤筦綸罆舘菅萖蒄覌観觀貫躀輨遦錧鏆鑵関闗關雚館鰥鱞鱹鳤鵍鸛光逛犷胱侊俇僙垙姯広廣挄撗横欟洸潢灮炗炚炛烡獷珖硄臦臩茪趪輄迋銧黆归贵鬼跪轨规硅桂柜龟诡闺瑰圭刽癸炔庋宄桧刿鳜鲑皈匦妫晷簋炅亀佹劊劌匭匮匱厬哇垝姽媯嫢嬀嶡嶲巂帰庪廆恑摫撌攰攱昋朹桅椝椢槣槶槻槼檜櫃櫰櫷歸氿沩湀溎潙珪璝瓌癐瞆瞡瞶硊祪禬窐筀簂胿茥蓕蘬蛫螝蟡袿襘規觖觤詭貴赽趹蹶軌邽郌閨陒隗雟鞼騩鬶鬹鮭鱖鱥鴂鴃龜滚辊鲧衮磙绲丨惃棞滾璭睔睴緄緷蓘蔉袞裷謴輥錕锟鮌鯀过国裹锅郭涡埚椁聒馘猓崞帼呙虢蜾蝈唬啯嘓囗囯囶囻圀國堝墎幗彉彍惈慖摑楇槨活渦漍濄瘑矌粿綶聝腂腘膕菓蔮蜮蝸蟈蠃褁輠過鈛錁鍋鐹锞餜馃";
PY[7] = "欬屽盒頇顸憾怀还核捍汗合红紅滑恍絵繪绘浑混渾划哈丷奤妎為獬蝦海害氦孩骇亥嗨醢咍咴嗐嚡塰烸還酼頦颏餀饚駭駴乤喊含寒汉旱酣韩焊涵函憨翰罕撼悍邯邗菡撖瀚阚蚶焓颔晗鼾傼兯凾哻唅嚂圅娢嫨崡嵅嵌晘晥暵梒椷欦歛浫涆淊滩漢澏澣灘熯爳猂琀甝皔睅筨糮肣莟蔊蘫蛿蜬蜭螒譀谽銲鋎鋡闞雗靬韓頷顄顩馠馯駻鬫魽鶾航杭吭沆绗珩垳妔忼斻桁炕笐筕絎苀蚢貥迒邟魧好号嚎壕郝毫豪耗貉昊颢灏嚆嗥皓濠薅傐儫呺哠嘷噑妞恏悎昦晧暤暭曍椃淏滈灝獆皜皞皡皥秏竓籇翯聕膠茠薃薧藃號虠蠔諕譹鄗鎒鐞顥鰝兞和喝河禾何荷贺赫褐鹤涸嗬劾盍翮阖壑诃呼咊哬啝喛嗃嗑嚇垎姀寉峆惒愒抲揭敆柇楁欱渮湼澕焃煂熆熇燺爀狢癋皬盇盉碋篕籺粭繳缴萂藿蚵蝎螛蠚袔覈訶訸謞貈賀輅轄辂辖郃鉌鑉闔阋隺霍靍靎靏鞨餄饸鬩鶡鶮鶴鸖鹖麧齕龁龢黑嘿嬒潶黒冚很狠恨佷噷拫掀詪鞎恒哼衡亨蘅堼姮悙橫涥烆狟胻脝訇鑅鴴鵆鸻囍乊乥轰哄洪宏烘鸿弘讧蕻闳薨黉荭泓仜叿吰吽哅嚝垬妅娂宖屸巆彋揈撔晎汯浤渹潂澋澒灴焢玒玜瓨硔硡竑竤篊粠紘紭綋纮翃翝耾舼苰葒葓訌謍谹谼谾軣輷轟鈜鉷鋐鍧閎閧闀闂霐霟鞃鬨鴻黌后厚吼喉侯候猴鲎篌堠後逅糇骺瘊垕帿洉犼睺矦翭翵葔豞郈鄇銗鍭餱鮜鯸鱟鲘齁湖户虎壶互胡护糊弧忽狐蝴葫沪乎瑚鹕冱怙鹱笏戽扈浒祜醐琥囫烀轷煳斛猢惚岵滹觳唿槲乕冴匢匫喖嘑嘝嚛垀壷壺姱婟媩嫭嫮寣帍幠弖恗戯戱戲戶戸搰擭昈昒曶枑楛楜槴歑殻汻沍泘洿淴滬滸濩瀫焀熩瓡瓳礐穫箶簄粐絗綔縏縠膴舗芐芔芴苸萀蔛蔰虍虖虝螜衚觷謼護軤鄠鋘錿鍙鍸雐雽韄頀頶餬鬍魱鯱鰗鱯鳠鳸鴩鶘鶦鸌话花化画华哗猾豁铧桦骅砉劃劐嘩埖姡婲婳嫿嬅崋搳摦撶杹椛槬樺檴浍澅澮獪璍畫畵硴稞糀繣舙芲華蕐蘤蘳螖觟話誮諙譁譮釪釫錵鏵驊鷨黊坏淮槐徊踝佪喟嘳坯壊壞懐懷瀤耲蘹蘾褢褱换唤环患缓欢幻宦涣焕豢桓痪漶獾擐逭鲩郇鬟寰奂锾圜洹萑缳浣喚嚾圂垸堚奐孉寏峘嵈巜愌懁換援攌梙槵欥歓歡汍渙澴烉煥瑍環瓛瘓眩睆瞏瞣糫緩繯羦肒荁萈蒝藧蠸讙豲貆貛輐轘酄鉮鍰鐶镮闤阛雈驩鯇鯶鰀鴅鹮黄慌晃荒簧凰皇谎惶蝗磺煌幌隍肓篁徨鳇遑癀湟蟥璜偟兤喤堭塃墴奛媓宺崲巟怳愰揘晄曂朚楻榥滉炾熀熿爌獚瑝皝皩穔縨艎茫葟衁詤諻謊鍠鎤鐄锽韹餭騜鰉鱑鷬黃回会灰挥汇辉毁悔惠晦徽恢秽慧贿蛔讳卉烩诲彗珲蕙喙恚哕晖隳麾诙蟪茴洄虺荟缋僡儶匯叀嘒噅噕噦嚖囘囬圚婎媈孈寭屷幑廻廽彙彚徻恛恵憓懳拻揮撝暉暳會椲楎槥橞檅檓櫘毀毇泋洃湏滙潓濊瀈灳烜烣煇煒燬燴獩琿璤璯痐瘣眭睢睳瞺禈穢篲繢翙翚翬翽蒐蔧薈薉藱蚘蛕蜖袆褘詯詼誨諱譓譭譿豗賄輝迴逥違銊鏸鐬闠阓靧韢韦頮顪餯鮰鰴鼿齀昏荤婚魂阍馄溷诨俒倱婫忶惛惽慁捆掍昬梡梱棔殙涽湣湷焄焝眃睧睯緍緡繉葷蔒觨諢轋閽顐餛餫鼲或火伙货获祸惑嚯镬耠攉锪蠖钬夥佸俰剨吙咟嚄奯掝旤曤沎湱漷瀖獲癨眓矆矐礊禍秮秳篧耯臛艧萿蒦謋貨邩鈥鍃鑊閄雘靃騞魊夻遤";
PY[8] = "乁";
PY[9] = "鯦浇澆捷接渐漸剿净淨茧粢仅夹咖奸介句拘角賈矜几及急既即机鸡积记级极计挤己季寄纪基激吉脊际汲肌嫉姬绩缉饥迹棘蓟技冀辑伎祭剂悸济籍寂其忌齐妓继集击圾箕讥畸稽疾墼洎鲚屐齑戟鲫嵇矶稷戢虮诘笈暨笄剞叽蒺跻嵴掎跽霁唧畿瘠玑羁丌偈芨佶赍楫髻咭蕺觊麂骥殛岌亟犄乩芰哜丮亼倚偮僟兾刉刏剤劑勣卽叝吇喞嗘嘰嚌坖垍塉墍妀姞姼尐居峜嵆嶯帺幾廭彐彑彶徛忣惎愱憿懠懻揖揤撃撠撽擊擠攲敧旡旣暩曁枅梞楖極槉樭機橶檕檝檵櫅櫭毄汥泲洁淁済湒漃漈潗濈濟瀱焏犱狤猗璂璣璾痵瘵癠癪皍睽瞉瞿磯禝禨秸稘稩穄穊積穖穧筓箿簊糭紀紒級結継緝縘績繋繫繼结罽羇羈耤耭脔膌臮艥艻芶茍莋萁葪蒩蔇蕀蕲薊藉蘎蘮蘻虀蝍螏蟣蟻蟿裚襀襋覉覊覬觙觭計訐記誋諅譏譤讦谻賫賷趌趞跂跡踑踖踦蹐蹟躋躤躸輯轚郅郆鄿銈銡錤鍓鏶鐖鑇鑙際隮雞雦雧霵霽鞊鞿韲飢饑驥鬾魝魢鯚鯯鯽鰶鰿鱀鱭鱾鳮鵋鶏鶺鷄鷑鸄鹡齌齍齎齏家加假价架甲佳嘉驾嫁枷荚颊稼茄铗葭迦戛浃镓痂恝岬跏胛笳珈郏袈蛱傢價叚唊圿埉夓夾婽宊幏徦忦戞扴抸押拁拮挈挟揩擖斚斝暇梜椵榎榢槚檟毠泇浹犌猳玾糘耞脥腵莢蛺袷裌豭貑跲郟鉫鋏鎵頡頬頰颉駕骆骱鴶鵊麚嗧见件减尖间键贱肩兼建检箭煎简剪歼监坚健艰荐剑溅涧鉴践捡柬笺俭碱硷拣舰缄饯翦鞯戋谏牮枧腱趼缣搛戬毽鲣笕谫楗蹇裥踺睑謇鹣蒹僭锏湔俴倹偂傔僣儉冿剣剱劍劎劒劔囏堅堑堿塹墹姦姧寋帴幵弿彅徤惤戩挸揀揃揵撿擶攕旔暕柙栫梘検椾榗樫橌橏橺檢檻櫼殱殲涀減湕澗濺瀐瀳瀸瀽熞熸牋犍猏玪珔瑊瑐監睷瞯瞷瞼碊磵礀礆礛稴筧箋箴篯簡籈籛糋絸緘縑繝繭纎纖聻臶艦艱菺葌葏蔪蕑蕳薦藆虃蠒袸襇襉襺見覸詃諓諫謭譖譼譾谮豜豣賎賤趝踐轞醎醶釰釼鈃銒銭鋄鋻錢錬錽鍊鍳鍵鎫鏩鐗鐧鐱鑑鑒鑬鑯鑳閒間鞬韀韉餞餰馢騫骞鬋鰎鰜鰹鳒鳽鵳鶼鹸鹹鹻鹼麉黚黬将讲江奖降浆僵姜酱蒋疆匠桨豇礓缰犟耩绛茳糨洚勥匞塂壃夅奨奬將嵹弜弶彊摪摾杢槳橿櫤殭滰漿獎畕畺疅糡絳繮翞膙葁蔃蔣薑螀螿袶講謽醤醬韁顜鱂鳉叫脚交教较觉焦胶娇绞校搅骄狡矫郊嚼蕉轿窖椒礁饺铰酵侥徼艽僬蛟敫峤跤姣皎茭鹪噍醮佼湫鲛挢侨僑僥儌勪呌咬嘂嘦嫶嬌嬓孂峧嵺嶕嶠嶣恔憍憢挍捁撟撹攪敎敥敽敿斠晈暞曒櫵湬滘漖潐灂灚烄焳煍燋獥珓璬皦皭矯穚窌笅筊簥糾絞纐纠腳膲臫芁茮菽萩蕎藠蟜蟭覐覚覺訆譑譥賋趭踋蹻較轇轎釂釥鉸鐎餃驕骹鮫鱎鵁鵤鷦鷮节街借皆截解界届姐戒阶劫竭疥桔杰诫睫桀喈羯蚧嗟鲒婕碣孑疖丯倢偼傑刦刧刼劼卩卪唶堦堺媎媘媫嫅屆岊岕崨嵑嵥嶰嶻巀幯庎徣悈掲搩擑擮擳昅桝椄楐楬楶榤檞毑洯湝滐潔煯犗玠琾畍疌痎癤砎礍稭節絜繲脻艐莭菨蓵蛣蛶蜐蝔蠘蠞蠽衱衸袓袺褯觧詰誡誱謯踕迼鉣鍇鍻锴階雃鞂飷髫魪鮚鶛进近今紧金斤尽劲禁浸锦晋筋津谨巾襟烬靳廑瑾馑槿衿堇荩噤缙卺妗赆觐伒侭僅僸儘兓凚劤勁厪唫嚍埐堻墐壗婜嫤嬐嬧寖嶜巹惍慬搢斳晉枃歏殣浕溍漌濅濜煡燼珒琎琻瑨璡璶盡砛祲竻紟紾緊縉臸荕菫菳蓳藎覲觔謹賮贐進釒釿鋟錦钅锓饉馸鹶黅齽竟静井惊经镜京敬精景警竞境径荆晶鲸粳兢茎睛痉靖肼獍阱腈弪刭憬婧胫菁儆旌迳靓泾亰仱俓倞傹儬凈剄坓坕坙妌婙婛宑巠幜弳徑憼擏旍暻曔桱梷橸檠殑汫汬浄涇濪烃烴燝猄璄璟璥痙秔稉穽竧竫競竸箐粇経經聙脛荊莖葝蟼誩踁逕鋞鏡陉陘靘靚靜頚頴颕驚鯨鵛鶁鶄麖麠鼱窘炯扃迥侰僒冂冋冏囧坰垧埛宭扄泂浻澃烱煚煛熲燛絅綗蘏蘔褧逈銄鎣顈颎駉駫就九酒旧久揪救舅究韭厩臼玖灸疚赳鹫僦柩桕鬏鸠阄啾丩乆乣倃剹勼匓匛匶奺廄廏廐慦捄揂揫摎朻杦柾樛橚殧汣牞畂稵穋糺紤繆缪舊舏萛蝤镹韮鬮鳩鷲麔齨欍举巨局具距锯剧聚菊矩沮拒惧鞠狙驹据俱咀疽踞炬倨醵裾屦犋窭飓锔椐苣琚掬榘龃趄莒雎遽橘踽榉鞫钜讵侷倶僪冣凥劇勮匊圧坥埧埾壉姖娵婅婮寠屨岠岨崌巈弆忂怇怐愳懅懼拠挙挶揟據擧昛梮椇椈檋櫸欅歫毩毱泦洰涺淗渠湨澽焗爠犑狊珇痀眗砠秬窶筥篓簍簴籧粔粷罝耟聥腒臄舉艍菹萭葅蒌蒟蓻蔞蘜蘧虡蚷蛆蜛螶襷詎諊豦貗趉趜跔跙跼踘蹫躆躹輂邭郥郰郹鄒鄹鉅鋦鋸鐻閰陱颶駏駒駶驧鬻鮍鮔鲏鴡鵙鵴鶋鶪鼰鼳齟卷倦鹃捐娟眷绢鄄锩蠲镌狷桊涓隽劵勌勬呟埍埢奆姢帣悁惓慻捲朘梋棬泫淃焆獧瓹甄睃睊睠絭絹縳罥羂脧腃臇菤萒蔨蕋蜷裐襈讂踡鋗錈鎸鐫雋鞙韏飬餋鵑决绝爵掘诀撅倔抉攫桷噱橛劂爝矍镢獗珏崛蕨噘谲孓厥亅傕刔匷啳埆妜孒屩屫崫嶥弡彏憠憰戄挗捔撧斍橜欔欮殌氒決泬潏灍熦爑爴狂玃玦玨瑴璚疦瘚矞矡砄穱絕絶繑繘芵蕝蕞虳蚗蛙蟨蟩蠼袦觼訣誳譎貜蹷躩逫鈌鐍鐝钁镼闋闕阕阙鞒鞽駃騤骙鶌鷢龣军君均菌峻竣骏钧郡筠麇皲捃儁呁埈姰寯懏攈晙桾汮濬焌焞燇狻珺畯皸皹碅箘箟莙葰蚐蜠袀覠軍鈞銁銞鋆鍕陖餕馂駿鮶鲪鵔鵕鵘麏麕";
PY[10] = "剀剴嵦碪堪扛亢伉抗枯苦扩擴傀渇渴苛昆槛楷卡喀胩咔佧呿垰衉裃鉲开凯慨垲锎铠忾恺蒈凱勓塏奒幆愷愾暟欯溘炌炏烗豈輆鎎鎧鐦開闓闿雉颽乫看砍刊坎勘龛戡侃瞰莰偘凵埳塪墈崁嵁惂扻栞歁矙磡竷莶薟衎輡輱轁轗顑餡馅龕糠康慷钪闶匟囥坑嫝嵻摃槺漮砊穅躿鈧鏮閌鱇靠考烤拷栲犒尻铐丂嵪攷洘焅訄銬髛鮳鯌鲓克棵科颗刻课客壳柯磕坷恪岢蝌缂轲窠钶氪瞌珂髁疴骒剋勀勊堁娔尅嵙嶱愘愙揢敤榼樖炣牁犐痾砢硞碦礚窼簻緙翗胢萪薖課趷軻醘鈳顆騍乪蠄肯啃恳垦裉垠墾懇掯珢硍肎肻褃豤貇錹齦龈铿劥坈忐挳揁摼殸牼硁硎硜硻誙銵鍞鏗巪乬迲唟厼怾空孔控恐倥崆箜埪宆悾椌涳硿躻錓鞚鵼廤口扣抠寇蔻芤眍筘叩冦剾劶宼彄挎摳敂滱瞘窛竘簆蔲釦鏂鷇哭库裤窟酷刳骷喾堀绔俈嚳圐庫扝桍泏狜瘔矻秙窋絝袴褲趶跍跨郀鮬垮夸胯咵晇舿誇銙顝骻快块筷侩蒯郐狯脍儈凷圦塊墤廥擓旝糩膾蒉蕢鄶鬠魁鱠鲙宽款髋寛寬欵歀窽鑧髖矿筐框况旷匡眶诳邝纩夼诓圹贶哐儣劻匩壙岲忹恇懬懭抂昿曠枉況洭狅眖砿礦穬筺絋絖纊誆誑貺軖軠軦軭邼鄺鉱鋛鑛鵟黋亏愧奎窥溃葵馈盔岿愦揆跬聩篑喹逵暌悝馗蝰夔刲卼嬇尯巋巙憒戣晆楏楑樻櫆欳殨潰煃磈窺簣籄聧聭聵臾藈蘷虁虧蹞躨鄈鍨鍷鐀鑎闚頄頍頯餽饋困坤鲲髡琨醌阃悃堃堒壸壼尡崐崑晜涃潉焜熴猑瑻睏硱祵稇稛綑罤臗菎蜫裈裍裩褌閫閸騉髠髨鯤鵾鶤鹍阔括廓适蛞噋懖拡桰濶筈葀闊霩鞟鞹韕頢髺穒";
PY[11] = "厘唠嘮帘离離骊硫纶沦狼芦苙蜡駱滥濫肋卵拉啦辣腊喇垃蓝落瘌邋砬剌旯儠嚹揦揧搚摺擸攋柆楋櫴溂爉瓎癩磖翋臘菈藞蝋蝲蠟辢鑞镴鞡鬎鯻鱲来赖莱濑赉崃涞铼籁徕癞睐來俫倈厲唻婡崍庲徠懶梾棶淶瀨瀬猍琜睞筙箂籟萊藾襰賚賴逨郲釐錸頼顂騋鯠鶆麳黧兰烂拦篮懒栏揽缆阑谰婪澜览榄岚褴镧斓罱漤僋儖厱啉囒壈壏嬾孄孏嵐幱廩廪惏懔懢擥攔攬斕欄欖欗浨涟湅漣瀾灆灠灡炼煉燗燣爁爛爤爦璼瓓礷籃籣糷繿纜葻藍蘭襕襤襴襽覧覽譋讕躝醂鑭钄闌韊顲浪廊郎朗榔琅稂螂莨啷锒阆蒗俍勆哴唥埌塱嫏崀悢朖朤桹樃樠欴烺瑯硠筤脼艆蓈蓢蜋誏踉躴郒郞鋃鎯閬駺老捞牢劳烙涝姥酪络佬潦耢铹醪铑栳崂痨僗僚労勞咾哰嗠嫪嶗恅憥憦撈撩朥橑橯浶澇獠珯癆硓磱窂簩粩絡耮蓼蛯蟧軂轑銠鐒顟髝鮱了乐勒鳓仂叻泐嘞忇楽樂氻玏砳簕阞韷餎饹鰳类累泪雷垒擂蕾镭儡磊缧诔耒酹羸嫘檑傫儽卢厽咧塁壘壨攂樏櫐櫑欙洡涙淚漯灅瓃畾癗盧矋磥礌礧礨祱禷絫縲纇纍纝罍脷蔂蕌藟蘱蘲蘽虆蠝誄讄轠銇錑鐳鑘鑸靁頛頪類颣鱩鸓鼺冧冷棱楞愣塄倰堎睖碐稜薐輘里力立李例哩理利梨礼历丽吏砾漓傈荔俐痢狸粒沥栗璃鲤厉励犁黎篱郦鹂笠坜苈鳢缡跞蜊锂澧粝蓠枥蠡呖砺嫠篥疠疬猁藜溧鲡戾栎唳醴轹詈罹逦俪喱雳莅俚蛎娌位儮儷凓刕列剓剺劙勵厤厯叓叕唎嚟嚦囄囇塛壢娳婯孋孷屴岦峛峲巁廲悡悧悷慄捩搮擽攊攦攭斄暦曆曞朸栃栛栵梸棃棙檪櫔櫟櫪欐欚歴歷氂沴沵浬涖濼濿瀝灑灕爄爏犂犛犡珕珞琍瑮瓅瓈瓑瓥癘癧盠盭睝矖砅磿礪礫礰禮禲秝穲竰筣籬粴糎糲綟縭纅纚艃茘荲菞蒚蒞蔾藶蘺蚸蛠蜧蝕蝷蟍蟸蠇蠣蠫裏裡褵觻謧讈貍赲躒轢轣邐酈醨釃鉝鋫鋰錅鏫鑗鑠铄隷隸霾靂靋鬁鯉鯏鯬鱧鱱鱳鱺鳨鴗鵹鷅鸝麗麜俩倆连联练莲恋脸链敛怜廉镰蠊琏殓蔹鲢奁潋臁裢濂楝亷令僆劆匲匳嗹噒堜奩娈媡嫾嬚孌慩憐戀挛摙攣斂梿槏槤櫣殮浰溓澰濓瀲熑燫瑓璉瞵磏簾籢籨練縺纞羷翴聨聫聮聯膦臉苓萰蓮薕蘝蘞螊褳覝謰譧蹥連鄻鎌鏈鐮零鬑鰊鰱鱄两亮辆凉粮梁量良晾谅粱墚椋魉両兩唡啢喨掚樑涼湸煷簗糧綡緉蜽裲諒輌輛輬辌鍄魎料聊撂疗廖燎辽寥镣钌尥寮缭鹩嘹僇嫽尞尦屪嶚嶛廫憀憭敹暸漻炓爎爒璙療瞭窷竂簝繚膋膫蟉蟟豂賿蹘蹽遼鄝釕鏐鐐镠镽飂飉髎鷯裂猎劣烈埒鬣趔躐冽洌劦劽哷埓奊姴峢巤忚挒挘毟浖烮煭燤犣猟獵睙聗脟茢蛚迾颲鬛鮤鴷林临淋邻磷鳞赁吝拎琳霖凛遴嶙蔺粼麟躏辚檩亃僯凜厸壣崊恡悋懍撛斴晽暽橉檁潾澟瀶焛燐獜璘甐疄痳碄箖粦繗翷臨菻藺賃蹸躙躪轔轥鄰鏻閵隣驎魿鱗麐另领铃玲灵岭龄凌陵菱伶羚翎蛉绫瓴酃呤泠棂柃鲮聆囹刢坽夌姈婈孁岺崚嶺彾掕昤朎櫺欞淩澪瀮炩燯爧狑琌皊砱祾秢竛笭紷綾舲蓤蔆蕶蘦衑袊裬詅跉軨醽鈴錂閝阾霊霗霛霝靇靈領駖鯪鴒鸰鹷麢齡齢龗六流留刘柳溜瘤榴琉馏碌陆绺锍鎏镏浏骝旒鹨熘遛偻僂劉嚠塯媹嬼嵧廇懰抡斿旈栁桞桺橊橮沠泖澑瀏熮珋瑠瑬璢畄畱疁癅磂磟綹罶羀翏膢蒥蓅藰裗蹓鋶鎦鐂陸雡霤飀飅飗餾駠駵騮驑鬸鰡鶹鷚鹠麍瓼甅囖龙拢笼聋隆垄弄咙窿陇垅胧珑茏泷栊癃砻儱厐哢嚨壟壠嶐巃巄徿攏昽曨朧梇槞櫳湰滝漋瀧爖瓏眬矓硦礱礲竉竜篭籠聾蘢蠪蠬衖襱豅贚躘鏧鑨隴霳驡鸗龍龐龒龓楼搂漏陋露娄蝼镂耧髅喽瘘嵝嘍塿婁屚嶁廔慺摟樓溇漊熡甊瘺瘻瞜耬艛螻謱軁遱鏤鞻髏路录鹿炉鲁卤颅庐掳绿虏赂戮潞禄麓鲈栌渌泸轳氇簏橹垆胪噜镥辘漉撸璐鸬鹭舻侓勎勠嚕嚧圥坴塶塷壚娽峍廘廬彔挔捋捛摅摝擄擼攄攎枦椂樐櫓櫨氌淕淥滤滷澛濾瀂瀘爐獹玈琭瓐甪盝睩矑硉硵磠祿稑箓簬簵簶籙籚粶緑纑罏膟臚舮艣艪艫菉蓾蕗蘆虂虜螰蠦觮賂趢踛蹗轆轤醁鈩錄録錴鏀鏴鐪鑥鑪顱騄騼髗魯魲鯥鱸鴼鵦鵱鷺鸕鹵黸乱滦峦孪栾銮鸾乿亂圝圞奱孿巒曫欒灓灤癴癵羉臠臡薍虊覶釠鑾鵉鸞略掠锊圙寽畧稤鋝鋢论轮伦仑囵侖倫圇埨婨崘崙惀掄棆溣碖磮稐耣腀菕蜦論踚輪陯鯩罗锣裸骡箩螺萝洛逻荦雒倮椤脶瘰摞泺镙猡儸剆啰囉峈挼捰攞曪欏烁犖癳笿籮纙羅腡臝蓏蘿覼躶邏鏍鑼頱饠騾驘鸁铝驴旅屡吕律氯缕侣履膂榈闾褛稆侶儢勴卛呂垏屢嵂慮曥梠櫚焒爈祣穞穭箻絽綠縷繂膐葎藘褸郘鋁鑢閭馿驢鷜";
PY[12] = "秘鴓募芒沬缗鉚铆呣吗妈马嘛麻骂抹码玛蚂摩唛蟆犸嬷杩么亇傌嗎嘜媽嫲嬤孖尛榪溤犘獁瑪痲睰碼礣祃禡罵蓦蔴螞蟇貊鎷閁靡馬駡驀鬕鰢鷌麼麽买卖迈埋麦脉劢荬佅勱咪嘪売脈蕒薶衇買賣邁霡霢鷶麥满慢瞒漫蛮蔓曼馒谩幔鳗墁螨镘颟鞔缦熳僈姏嫚屘幕悗慲摱槾満滿澫澷獌睌瞞矕絻縵蔄蘰蟃蟎蠻襔謾鄤鏋鏝顢饅鬗鬘鰻忙盲莽氓硭邙蟒漭厖吂哤壾娏尨庬恾朦杗杧汒浝牤牻狵甿痝盳瞢笀茻莾蘉蠎釯鋩铓駹鸏鹲匁毛冒帽猫矛卯貌茂贸锚茅耄茆瑁蝥髦懋昴牦瞀峁袤蟊旄侔冃冇冐勖務堥夘媢嵍愗戼描暓枆楙毣毷渵牟獏皃眊笷緢罞芼萺蓩蛑蝐覒貓貿軞鄚鄮酕鉾錨霿髳鶜唜嚒嚜嚰孭庅濹癦没每煤镁美酶妹枚霉玫眉梅寐昧媒糜媚谜沫嵋猸袂湄浼鹛莓魅镅楣凂呅坶堳塺墨媄媺嬍嵄徾抺挴攗攟某栂楳槑櫗毎氼沒渼湈溦煝燘珻瑂痗眛睂睸矀祙禖篃脄脢腜苺葿蘪蝞跊躾郿鋂鎂鎇韎鬽鶥黣黴门们闷懑扪钔焖亹們怋悶懣捫暪椚汶燜玟玣玧璊穈菛虋鍆門閅猛梦蒙锰孟盟檬萌礞蜢勐懵甍蠓虻艋艨儚冡夢夣嫇幪懜懞掹擝明曚橗氋溕濛獴瓾瞑矇矒莔萠蕄蝱鄳鄸錳雺霚霥霧靀顭饛鯍鯭鱦黽黾鼆踎米密迷眯蜜觅弥幂醚蘼縻汨麋祢猕弭谧芈脒敉嘧糸侎冖冞冪劘塓孊宻峚幎幦幺彌戂摵擟擵攠榓樒檷櫁洣淧渳溟滵漞濔濗瀰灖熐爢獯獼瓕眫眽瞇瞴祕禰簚籋粎罙羃羋葞蒾蓂蔝蔤藌蝆袮覓覔覛詸謎謐醾醿釄銤鑖镾鸍麊麛鼏面棉免绵眠缅勉冕娩腼湎眄沔渑丏偭冥勔喕婂媔嬵宀愐檰櫋汅泯澠矈矊矏糆綿緜緬芇莬葂蝒蠠靣靦鮸麪麫麵麺秒苗庙妙瞄藐渺眇缈淼喵杪鹋邈媌嫹庿廟玅竗篎緲蜱鱙鶓灭蔑咩篾蠛乜吀哶幭懱搣滅瀎眜薎衊覕谂鱴瓱民抿敏闽皿悯珉闵苠鳘岷僶冺刡勄呡垊姄崏忞慜憫捪敯旻旼暋渂潣琘琝瑉痻盿砇碈笢笽簢繩罠賯鈱錉鍲閔閩鰵鴖名命鸣铭螟暝茗酩佲凕姳慏掵朙榠洺猽眀眳覭詺鄍銘鳴谬謬摸磨末膜莫默魔模摹漠陌蘑寞秣瘼殁镆嫫谟貘茉馍耱劰勿嗼嚤嚩圽塻妺嫼帓帞怽懡昩暯枺橅歾歿爅皌眿瞐瞙砞礳粖糢絈縸纆艒莈藦蛨蟔謨謩譕貃銆鏌靺饃饝髍魩魹麿黙乮谋眸鍪哞劺厶婺恈敄桙毋洠蟱謀鞪鴾麰木母亩目墓牧穆暮牡拇慕睦姆钼毪沐仫苜凩墲娒峔幙慔楘樢氁炑牳狇畆畒畝畞畮砪胟莯蚞踇鉧鉬雮霂旀丆椧";
PY[13] = "乃譺扭杻柠鳥鸟屰囝呐那拿哪纳钠娜南衲捺镎肭乸內内吶呶嗱妠抐拏挐淰笝箬篛納蒘蒳訤詉誽豽蹃軜鈉鎿雫靹魶耐奶奈氖萘艿柰鼐倷妳孻廼掜摨渿熋疓能腉螚褦迺釢錼难男赧囡蝻楠喃腩侽娚婻弇戁抩揇摊攤暔枏枬柟湳煵畘莮萳諵遖難囊馕曩囔攮儾哝噥嚢憹搑擃欜瀼灢蘘蠰譨饢鬞齉闹脑恼挠孬铙瑙垴蛲猱硇匘堖夒嫐峱嶩巎怓悩惱撓橈檂獶獿碯脳腝腦蝚蟯譊鐃閙鬧呢讷疒眲訥馁娞氝浽脮腇錗餒餧鮾鯘焾嫩恁媆嫰枘莻鈪銰啱你泥拟腻逆溺倪尼匿妮霓铌昵坭猊伲怩鲵睨旎伱儞堄婗嫟嬺孨孴屔嶷惄愵慝抳擬晲暱棿淣滠濘灄狔痆眤秜籾縌胒膩苨薿蚭蛪蜺觬貎跜輗郳鈮鉨鑈隬馜鯢麑齯年念捻撵碾粘廿黏辇鲇鲶卄哖姩撚攆涊秊秥簐艌蹨躎輦鮎鯰鵇娘酿嬢孃醸釀尿袅茑脲嬲嫋嬝蔦裊褭捏镍聂孽涅镊啮陧嗫臬蹑颞噛嚙囁囓圼孼嵲嶭巕帇惗揑敜枿槷櫱篞糱糵聶肀臲苶菍蠥褹諗讘踂踗踙躡鉩銸鋷錜鎳鑷钀闑隉顳齧您囜拰脌拧凝宁狞泞佞甯咛聍侫儜嚀嬣寍寕寗寜寧擰橣檸澝獰聹苧薴鑏鬡鬤鸋牛纽狃忸汼沑炄牜紐莥蚴靵浓农脓侬儂挊挵欁濃癑禯秾穠繷膿蕽襛農辳醲齈耨啂嬬搙擩槈檽獳羺譳怒努奴孥胬驽弩伖伮傉帑砮笯褥駑暖奻渜湪煖煗餪虐疟谑硸黁燶挪诺懦糯喏傩锘搦儺堧愞懧掿搻梛榒橠稬穤糑糥耎諾逽鍩女衄钕恧朒籹衂釹瘧";
PY[14] = "哦毆喔筽夞乯昷鞰偶呕欧藕鸥沤殴怄瓯讴耦吘嘔塸慪握敺櫙歐渥漚熰甌紆纡腢膒蕅藲謳醧鴎鷗齵";
PY[15] = "杷湃排派彭旁炮瀑袍棑菩葡平抨辟枇拚剽嫖頻频屏拼怕拍擗潑跑僕撲溥捧鵬鹏掊蹒蹣庞彯帕爬趴啪琶筢葩妑帊掱潖舥袙牌迫徘俳蒎犤猅簰輫鎃磗盘判攀畔叛磐胖襻泮爿乑冸媻幋槃沜洀溿瀊炍片牉皤盤眅蒰詊踫鄱鋬鎜鑻鞶頖鵥耪乓滂沗篣胮膖蠭覫霶龎抛泡咆狍匏庖疱脬垉奅拋爮犥皰礟礮萢褜謈軳鞄麅麭陪配赔呸胚佩培沛旆帔醅霈辔伂俖姵媐嶏怌抷斾昢毰浿淠珮肧蓜賠轡阫馷駍盆湓呠瓫翸碰棚砰蓬朋烹硼膨澎篷怦蟛嘭倗剻匉塜塳弸恲憉掽梈椖椪槰樥泙淎淜漰皏硑磞稝竼纄胓芃苹荓蟚軯軿輣輧鑝閛韸韼髼鬅鬔浌巼闏乶喸批皮披匹劈屁僻疲痞霹琵毗啤譬砒貔丕圮癖郫甓睥鼙邳铍罴噼蚍伓伾噽嚊嚭壀嫓岯憵扑朇榌毘毞渒潎澼炋焷狉狓疈疋痦睤磇礔礕秛秠篺簲羆耚脴膍苉苤蚽螷蠯豼豾釽鈹鉟銔銢錃闢阰隦頗顖颇駓髬魾鴄鵧鷿篇骗偏翩犏骈胼蹁谝囨媥楄楩腁覑諚諞貵賆駢騈騗騙骿魸攵丿票飘瓢朴螵瞟缥嘌勡慓旚皫磦縹翲薸醥闝顠飃飄魒氕嫳暼鐅品贫聘嫔榀姘牝颦嚬娉嬪朩玭矉礗穦薲蘋貧顰馪驞凭瓶评乒萍坪鲆枰俜凴呯塀娦屛岼帡帲幈慿憑洴涄焩玶甁甹砯竮箳簈缾聠艵蓱蚲蛢評郱頩鮃破坡婆粕笸钋攴叵珀钷嘙尀岥岶廹敀椺櫇洦溌烞皛砶蒪酦釙鉕鏺駊剖咅堷抔犃颒兺哛铺谱仆曝圃浦普镨噗匍濮氆蹼璞镤圑圤墣巬巭暜樸檏潽炇烳痡瞨穙舖菐蒱諩譜贌酺鋪鏷鐠駇";
PY[16] = "奇鉗钳墽淺趫呛嗆抢搶槍鎗詘诎胊荃趣趨且戚汽区區祈鈐钤洽搉期棋蘄褀騎骑齊浅前纤葥钱强強乔却卻喬橋契蜻靑青娶圈圏弮屈頎颀穹羫腔缺頃顷泣剠犭起七气器妻欺漆启柒岂砌弃祁凄企乞歧栖畦脐崎迄沏讫旗祺骐屺岐蹊桤憩萋芑汔鳍俟槭嘁蛴綦亓欹琪麒琦蜞圻杞葺碛淇耆绮亝倛傶僛切剘勤吱呇咠唘唭啓啔啟噐埼夡娸婍宿岓嵜忔忮忯恓悽愭慼慽憇捿掑斉斊旂暣朞栔桼梩棄棊棨棲榿檱櫀欫気氣洓淒渍渏湆湇滊漬濝炁猉玂玘甈疧盀盵碁碕碶磎磜磧磩禥竒簯簱籏粸紪綥綨綮綺緀緕纃缼罊肵臍艩芞藄蚑蚔蚚蜝螇螧蠐衹裿褄訖諆諬諿趿軝迉邔郪釮錡鏚锜闙霋騏騹鬐鬿魌魕鮨鯕鰭鲯鵸鶀鶈麡齮恰掐葜佉冾圶帢拤殎硈磍跒酠鞐千牵签欠铅钎迁谴谦潜歉扦遣黔仟岍褰箝掮搴倩慊悭愆虔芡荨缱佥芊阡肷茜椠伣俔僉儙刋嗛圱圲墘壍奷媊孅孯寨岒嵰廞忴悓慳扲拑拪掔撁撍攐攑攓杄杴棈榩槧橬檶櫏歬汘汧潛濳灊炶煔燂牽皘竏箞篏篟簽籖籤粁綪縴繾羟羥羬膁臤苂茾葴蒨蔳蕁藖蚈蚙蜸諐謙譴谸軡輤遷釺鈆鉛鍼鎆鏲鑓韆顅騚騝鬜鬝鰬鵮鹐枪墙羌蔷蜣跄戗襁戕炝镪锖锵樯嫱唴啌嗴墏墻嬙嶈庆廧慶斨檣溬漒熗牄牆猐獇玱琷繈繦羗羻艢薔蘠親謒跫蹌蹡錆鏘鏹兛瓩桥瞧敲巧翘锹鞘撬悄俏窍雀峭橇樵荞跷硗憔谯愀缲诮劁僺喿嘺塙墝墧帩幓幧槗橾殼毃燆犞癄睄硚硝碻礄窯竅箾繰翹荍菬藮誚譙趬踃踍蹺躈郻鄡鄥銚鍫鍬鐈陗鞩韒頝顤顦髚髜怯窃郄惬锲妾箧倿匧厒唼帹悏愜朅癿稧穕竊笡篋籡緁聺苆藒踥鍥鐑鯜亲琴侵擒寝秦芹沁禽钦吣覃衾芩溱嗪螓噙揿檎吢唚坅埁媇嫀寑寢寴嵚嶔庈懃懄抋捦搇撳昑梫欽澿瀙珡琹瘽矝笉綅耹菣菦蓁藽螼誛赺赾鈊鈙雂靲顉駸骎鬵鮼鳹请轻清情晴氢倾擎卿氰圊謦苘黥罄鲭磬傾凊勍啨埥夝寈庼廎掅暒棾樈檾櫦氫淸漀甠硘碃請軽輕郬鑋鯖穷琼邛茕銎筇儝卭嬛惸憌桏橩焪焭煢熍瓊瓗睘窮竆笻藑藭蛬赹求球秋丘泅邱囚酋楸蚯裘糗巯逑俅虬赇鳅犰鼽遒丠厹叴唒坵媝崷巰恘扏搝梂櫹殏毬氽汓浗渞湭煪玌璆皳盚秌穐篍紌絿緧肍莍蘒虯蛷蝵蟗蠤觓觩訅賕逎釚釻銶鞦鞧鮂鯄鰌鰍鰽鱃鵭鶖鹙龝去取曲驱躯龋戌祛蕖磲劬阒麴癯衢黢璩氍觑蛐岖伹佢刞匤厺岴嶇憈戵抾斪欋浀淭灈璖竬筁粬紶組絇组翑胠臞菃葋蝺蟝蠷衐袪覰覷覻詓躣軀鑺閴闃阹駆駈騶驅驺髷魼鰸鱋麮麯麹鼁鼩齲全权劝拳犬泉券颧痊铨筌绻诠畎鬈悛佺勧勸姾婘峑巏巻恮拴搼栒椦楾槫権洤湶灥烇牶牷犈瑔甽硂絟綣縓葲虇觠詮謜譔跧銓鐉闎顴駩騡鰁鳈齤确瘸鹊榷悫崅愨慤汋燩獡皵碏確礭舃舄蒛鵲群裙逡囷夋峮帬羣裠輑";
PY[17] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a785b5c35ff15f3622d12f403a2fce1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe9fd038ed48044eef905a4bc6b636f/" rel="bookmark">
			如何写漂亮的返回值为 boolean 类型的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public boolean isLow() { if ((myGasoline + myBattery) &lt; 10) { return true; } else { return false; } } // 更漂亮的： public boolean isLow() { if ((myGasoline + myBattery) &lt; 10) { return true; } return false; } // 更漂亮的： public boolean isLow() { // Compute (true or false) if we are low, // and return that boolean value directly. return ((myGasoline + myBattery) &lt; 10); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30ff05bc125bdf3ee115ab6cb274c157/" rel="bookmark">
			D盘消失 磁盘管理控制台视图不是最新状态 解决办法(不用格盘的）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意底部还有我自己的情况，希望对各位能有帮助。
症状：d盘消失，虽然在磁盘管理器中能够显示，但并没有盘符。
产生原因：我是因为装了pqmagic这个分区软件，与windows7不兼容导致的。安装时，系统报错然后倒计时关机。再开机时，d盘就不见了。应该是分区表被该了哈。
解决办法：
①如果你有一个能够转换分区属性的磁盘管理软件的话。那就将丢失的盘装换一下主从属性就好啦！
②没有？我推荐一个吧。首先需要安装acornis disk director10这个软件，下载地址http://down.vista123.com/AcronisDiskDirector10.rar。最好用英文原版的。
③因为楼下的几位说安装时不会装。我这详细说一下安装步骤。会装的直接跳过吧。下载后在压缩包里有个注册机，安装时要求输入个什么注册码，用注册机注册该版本（~~director10）就好了。我这里记录一个注册码FD77T-D7FU6-R3ZF6-WB8GL-EH6AN，方便使用。（请用完就卸载掉吧。一定要支持正版！！！）。
下一步安装时有典型安装（typical），自定义安装（custom）和最后一个是全部安装（complete）三种。反正也是要卸掉的，就全部安装吧（其实选择自定义就够了，用不到第二个reboot的功能）。然后下一步又问，是安装到所有用户啊，还是当前用户啊，选择下面那个当前用户（curretn user）就可以。然后pocceed进行OK了。10秒钟左右就安装完毕。要重启。一定要重启的。
④安装成功后，开启软件，
一年后的PS：
特别注意：
在第一次开启该软件时，它会问你，是用向导模式啊，还是人工模式（manual model），请选择manual模式，因为向导模式的功能过于简单。
然后请先向下看，看到你那个丢失的盘符了吗？选择丢失的盘（就是用鼠标点一下D盘，）。
然后再看左边，左侧栏有advanced（高级）分栏，其下有个convert选项（下图1中的第二个选项），点击。 （图1） （图2）
弹出了上图2的对话框。这是改变D盘的文件格式和主从分区属性用的，我们主要用到的是改变主从盘属性功能（就是第二个那个下拉框）。如果原来D盘（即丢失的盘符）是primary Partition（主分区），那就改成logical Partition（逻辑分区）；如果原来是logical（逻辑的），那就改成primary（主分区）。
⑤最后点左上角的一个黑白交替的格子国旗的标志commit（“执行”的意思）。不到一分钟，转换成功。退出软件，无需重启，进入我的电脑，最后兴奋的大喊“资料保住啦！！”就ok了。
后记：某些早期的软件对于windows7来说还是有点问题的，对于不兼容的软件千万不要强行安置，后果就是浪费时间解决无穷多莫名其妙的麻烦.......
PS2：这里要对几位提问的网友表示歉意，因为之前我没用说清楚要选择人工模式，使得软件的一些功能被隐藏了，可能没能按照此方法进行下去。如果你不小心选择了向导模式，只要在向导模式下，软件上端的工具栏中选择回manual模式即可。
PS3:可能你按照上述方法在进行到“convert"步骤时发现convert不可用（即呈现灰色），请参见该日志的回复29及31。感谢todayty的补充。
PS4:我这次又补上了图（弄的排版乱七八糟）。尽可能详细地又填了些说明（显得磨磨唧唧）。就是为了方便大家。因为这是我2年前出现的问题了，所以对于楼下的几位新的问题的变种，没实际经历过也没有好的方法，很抱歉。如果各位有自己解决掉的问题，欢迎在下面留下心得，方便之后遇到问题的人。
本站补充： 我按照这个办法，不过没有解决问题，在这个办法基础之上，我给那个无法设置驱动器号的盘设置了一个volume label，添加这个之后，在电脑--管理--找到没有驱动器号的盘，右键--设置驱动器号之后就可以添加一个驱动器盘符，然后在我的电脑中就可以看到这个驱动器了。
最终也是成功解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be957ed7345918808e104109cabb5d86/" rel="bookmark">
			C#开源资源大汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、AOP框架
Encase 是C#编写开发的为.NET平台提供的AOP框架。Encase 独特的提供了把方面(aspects)部署到运行时代码，而其它AOP框架依赖配置文件的方式。这种部署方面(aspects)的方法帮助缺少经验的开发人员提高开发效率。
NKalore是一款编程语言，它扩展了C#允许在.net平台使用AOP。NKalore的语法简单、直观，它的编译器是基于Mono C#编译器(MCS)。NKalore目前只能在命令行或#Develop内部使用。NKalore兼容公共语言规范CLS(Common Language Specification)，它可以在任何.NET开发环境中使用，包括微软的Visual Studio .NET。
PostSharp读取.NET字节模块，转换成对象模型。让插件分析和转换这个模型并写回到MSIL。PostSharp使开发程序分析应用程序容易得像分析代码规则和设计模式，它使程序开发的思想变革为面向方面软件开发(AOSD/AOD)思想。
AspectDNG的目标是为.NET开发人员提供简单而功能强大的AOP-GAOP实现。它效仿java下的开源工具AspectJ 和 Spoon，成熟程度也很接近它们。
RAIL(Runtime Assembly Instrumentation Library) 开源项目可以在C#程序集加载和运行前进行处理控制调整和重新构建。C#在CLR中，我们已经能够动态加载程序集并且获得程序集中的类和方法，RAIL(Runtime Assembly Instrumentation Library)的出现填补了CLR处理过程中的一些空白。
SetPoint是一款.NET框架下的全功能(full-featured)AOP引擎.它着重为称为语义切点(semantic pointcuts)的定义依赖RDF/OWL的使用.它的功能为一个IL-level，highly dynamic weaver&amp;LENDL,一个引人注目的定义语言、、、、、、
DotNetAOP为 CLR language提供AOP 框架基础属性。
NAop是一个DotNet下的AOP框架。
AspectSharp是DotNet下的免费AOP框架，它以Dynamic Proxies和XML作为配置文件。
二、Ajax框架
Ajax.NET Professional (AjaxPro)是最先把AJAX技术在微软.NET环境下的实现的AJAX框架之一。它在客户端脚本之上创建代理类来调用服务器端的方法。
MagicAjax.NET是一款在ASP.NET下创建Web页面提供AJAX技术的框架。它使开发人员很容易把AJAX整合到他们的页面而不需要替换ASP.NET控件或自己写javascript脚本代码。
Anthem.NET是为ASP.NET开发环境提供的开源AJAX工具包，它可以运行于ASP.NET 1.1和2.0。
三、工作流(workflow)
Workflow.Net是使用微软.Net技术基于wmfc标准的创建工作流引擎。
NetBPM是JBpm移植到.net平台下的一款开源工作流软件。NetBpm可以很容易和.Net应用程序集成在一起,可以创建,执行和管理工作流程序。
Bpm Tool支持将业务模型转换成软件模型。业务开发人员可以使用模型驱动的方法设计，实现，执行和跟踪业务流程。因此开发人员能够更容易的关注业务逻辑的变化。
三、文本编辑
FCKeditor是一款功能强大的开源在线文本编辑器(DHTML editor)，它使你在web上可以使用类似微软Word 的桌面文本编辑器的许多强大功能。它是轻量级且不必在客户端进行任何方式的安装。
FreeTextBox 是一个基于 Internet Explorer 中 MSHTML 技术的 ASP.NET 开源服务器控件。这是一款优秀的自由软件（Free Software），我们可以轻松地将其嵌入到 Web Forms 中实现 HTML 内容的在线编辑，在新闻发布、博客写作、论坛社区等多种 Web 系统中都会有用途。
VietPad是一个功能完整的跨平台的Java/.NET的Vietnamese Unicode开源文本编辑器。支持打开，编辑，打印，转换，排序，和保存基于文本的Unicode格式的Vietnamese文件。
NetSpell是一款.NET框架下的开源拼写检查引擎。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be957ed7345918808e104109cabb5d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a3f3bb86727d7666ddad9e0a90fd1ac/" rel="bookmark">
			业务层和持久层单元测试的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单元测试大多数时候遇到的问题难点，其实就在于怎么样很好的解决各种依赖（我这里分为外部依赖和持久层依赖吧）。根据笔者的实践，总结了如下一些实践经验，希望能够和大家共同提高。如无特殊说明：以下例子采用junit4 + jmock1.0。 [b]1. 如何解决外部系统的依赖？[/b] 对于业务层的单元测试，比较复杂的情况就是会有很多外部services（接口或者服务等）的依赖，其实对于我们来说最重我们需要得到或者传递出去的都是各种数据对象，那么这种情况下可以采用mock来模拟这些数据对象。这样让测试方便的通过。 场景：测试DefaultGetNumAO类的getNum方法,在真正的应用里面，调用此方法的前提是从session中取得用户信息,也就是登陆信息，但是单元测试的时候是拿不到的，如果我们直接用代码测试，那么还没有执行到getNum，单元测试就会报错，提示没有登录，其实是说这个用户信息没有取到。在线上环境我们是不会存在这个问题的。我们可以用以下代码模拟登录的用户数据(SysUser，实现的是IUser接口),这个时候我们可以用mock的方式来模拟这个外部依赖接口（或者服务）。 采用jmock的话，有两种，一种是采用接口模拟（org.jmock.Mock)的方式，一种没有实现接口的类的MOCK，是基于cglib(字节码)的方式。在这里我用的是接口模拟，我先模拟出IUser接口对象： // 构造Mock控制器
Mock m = new Mock(IUser.class);
// 这是要测试MockObject
IUser mock = (IUser) m.proxy();
// 期待的返回值
SampleReturn sr = new SampleReturnImpl();
// 期待的参数
Parameter p = new ParameterImpl();
// 控制器，期待一次，方法sampleMethod，参数等于p(equals)，将返回sr
m.expects(once()).method("getUserId").with(eq(p)).will(returnValue(sr)); 其实从上面可以看出来，JMOCK或者其他Mock也好，其思想就是模拟对象，建立孤立的测试环境，上述DefaultGetNumAO类调用过多的外部系统，我们将外部系统的调用入口统一MOCK掉，MOCK出我们自己想要的数据; 我们采用下面的代码： DefaultGetNumAO dftAo = new DefaultGetNumAO();
//这里手工输入你的mock出来的对象（外部依赖）
dftAo.setDftAo(dftAo);
//执行真正的要测试函数
Result result = dftAo. getNum ();//过程中会调用你注入的对象替代真正运行的对象或者服务
Assert.assertTrue(result.isSuccess()); 采用上述的方式，可以将DefaultGetNumAO里面所有依赖的外部调用全部mock掉。 [b]2. 如何解决对数据库的依赖？[/b] 对于DAO层来说，直接修改数据库中的物理数据，可能会带来众多冗余数据或者引起数据紊乱等情况。 场景：比如你需要测试一个insert语句，用传统的junit测试的方式，当你插入成功之后，这些你插入的测试数据实际上就成了冗余数据；更可能存在的情况，你插入这条数据之后，有些有唯一性约束的字段存在的时候，就不能再次执行插入了，这就意味着你的单元测试代码只能执行一次。 一般这种情况下采用如下方式解决： 第一， 在测试代码开始前插入临时数据，然后执行你的测试代码，待正真要测试的代码执行结束之后，在你的单元测试代码之后清理掉插入的临时数据。 如下例子： //设置全局变量，保存数据用
private long iTestAllId = 0L;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a3f3bb86727d7666ddad9e0a90fd1ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcecab598ca500eca89137f4d4db4b91/" rel="bookmark">
			用户控件 UserControl类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UserControl类时专门管理用户控件的类，是用户控件类的统称。用户控件就是扩展名为.ascx的Web窗体组件，与普通的服务器控件一样，其不具备单独运行的能力，必须依附于窗体页才能正常运行。通常用其来制作特殊服务器控件，或多个服务器控件的组合形式。
UserControl类以编程方式访问控件，并提供动态加载及调用等许多特性。用户控件在运行时，被编译为UserControl对象，并驻留在服务器内存中。
语法定义：
//namespace System.Web.UI
public class UserControl : TemplateControl, IAttributeAccessor, INamingContainer, IUserControlDesignerAccessor
UserControl类的构造函数：
public UserControl();
在运行时通常不适用new关键字创建UserControl对象，而是以动态加载.ascx文件的形式创建，其加载方法如下：
UserControl myUser = (UserControl)this.LoadControl("myDropDwon.ascx");
属性详解
UserControl类的属性用来在用户控件运行时获取上下文信息，下面列出这些属性及其说明
Application:Web请求的应用程序对象
Attributes:用户控件的所有属性
Cache:用户控件的缓存对象
CachePolity:用户控件的缓存参数集合
IsPostBack:是否是第一次加载用户控件
应用1：动态加载用户控件并获取其公共属性
本例主要说明动态加载用户控件，以及如何设置用户控件的公共属性。实例的用户控件是一个选择部门填充用户的复合控件，可以在项目中被多次调用。
在网站根目录下，添加一个用户控件，命名为“mydropdown.ascx”.
在用户控件内，添加两个DropDownList，属性设置如下：
&lt;%@ Control Language="C#" AutoEventWireup="true" CodeFile="mydropdown.ascx.cs" Inherits="mydropdown" %&gt; &lt;asp:DropDownList ID="DropDownList1" runat="server" AutoPostBack="True" OnSelectedIndexChanged="DropDownList1_SelectedIndexChanged1"&gt; &lt;asp:ListItem Value="0"&gt;技术部&lt;/asp:ListItem&gt; &lt;asp:ListItem Value="1"&gt;测试部&lt;/asp:ListItem&gt; &lt;asp:ListItem Value="2"&gt;销售部&lt;/asp:ListItem&gt; &lt;/asp:DropDownList&gt; &lt;asp:DropDownList ID="DropDownList2" runat="server"&gt;&lt;/asp:DropDownList&gt; 为DropDownList1添加事件“SelectedIndexChanged”,代码如下：
protected void DropDownList1_SelectedIndexChanged1(object sender, EventArgs e) { DropDownList2.Items.Clear();//首先清空 switch (DropDownList1.SelectedValue) { case "0": DropDownList2.Items.Add("刘一"); DropDownList2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcecab598ca500eca89137f4d4db4b91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00bc4da6d8f9e9bdbb0882792bfdbf2/" rel="bookmark">
			有关Segment fault的总结(转自海斌)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景
在基于linux操作系统的相关开发工作当中遇到了Segment fault，bus error两个引起死机的严重问题，一直想对这个问题进行总结，目前有时间就赶紧落实了。
二、我理解的段错误
首先谈一下对段的理解：段是内存模式设计的一个结果，各个处理器的地址空间并不一致，但它们都被分割成为大小相同的单位区域，每个这样的区域被称为段，记得大学时候学x86架构时的段是64k。
理解了段的含义，那么就可以理解段错误是由于内存管理单元（负责支持虚拟内存的硬件）的异常所导致，我一般直接理解为我们应用编程用的虚拟地址通过MMU转换为实际物理地址的过程中出现了问题。
三、导致段错误的几种情况
1、 引用一个包含非法值的指针（当然包括空指针）。
2、 未得到正确的权限的时候进行访问，例如往只读的内存地址写数据。
3、 内存越界（数组越界，变量类型不一致等），下面给个例子
char MyArray[1];
printf("%c", MyArray[1000000000]);
比较极端的一个例子！！！
依据段错误的定义，可以推断段错误的原因大概也都是一样的，就是所用的地址没有物理内存所对应，各种情况只有平时多积累啦。
四、段错误为什么这么麻烦？以及想到的一些解决办法
比较常见的是指针使用不规范导致，林锐的《高质量c++/c编程指南》关于指针的使用说的比较清楚。
比较让人郁闷的是glibc库中基本所有的函数都默认形参指针是非空的（如果strcpy对每个参数都进行检查就好了！），还有linux的一些系统函数也是如此！多次调用的系统函数可以考虑给它做件衣服（封装一层，添加错误处理等），例如《UNIX网络编程》一书封装了大量的套接口API，并称之为包裹函数（难怪专家的代码bug要少的多！）。当然我们自己写的函数也要尽量要检查一下入口参数。
解决段错误问题，我常用的是两个基本办法：加打印输出判断位置检查代码、用gdb找到段错误的位置，当然网上还有一些其他的办法和工具。
段错误还碰到过更痛苦的情况：死机打印Segment fault，后面没有栈的相关打印，用gdb跟踪时是一个信号，而不是应用层的进程。这种情况让我恼火的很，已经解决过这样的问题，但仍然一头雾水：这种问题可能是应用层的错误，当时通过目前手头上的所有手段都找不到应用层的问题，仅仅看到了这个异步的信号。而信号是由硬件中断产生的，由于中断是异步发生的（其发生的时间是不可预测的），对中断的编程和判断当然是非常困难的。
五、类似于段错误的另外一个痛苦的错误：bus error
bus error这个错误我这碰到过，但是没有真正的解决过。也总结一下：
1、硬件故障，不用说，咱们程序员碰到的通常不是这个原因，也不要把问题轻易的归结为硬件。
2、linnux平台上执行malloc，如果没有足够的RAM，linux不是malloc失败返回，而是向当前进程分发SIGBUS信号。注：来源于网络，不敢确认。
3、在一次linux内核开发者大会上听到过产生bus error的另外一种情况：驱动程序写的比较“顽皮”，这个一般在linux的release版本是没有的。
4、大多数参考文献基本上把总线错误列为由于未对齐的读或者写操作引起的。对齐的意思就是数据项只能存储在地址是数据项大小整数倍的内存位置上。我所接触过的嵌入式CPU基本都是RISC架构，都需要数据对齐。
Bus error和segment fault的区别：我这理解的segment fault是应用的地址对应的实际物理地址是无效的，即通过硬件管理单元MMU的时候失败而上报错误；而bus error对应的物理地址是有效的，当然是可以通过MMU的，由于cpu体系架构对字节对齐的限制，此时总线是不能正确使用该指针地址的。当然我觉得这种情况编译器应该给个警告或者错误（具体的没研究过），否则各种调试手段基本起的作用就不大了，只能靠检查原始代码了。
六、解决和研究类似问题的一点体会
这类问题的理解和解决有时候需要很多计算机相关的基础理论知识和linux操作系统的一些知识，平时多看一些理论书籍在很多时候还是非常有用的。另外重视编译警告和编程规范有时候可以避免一些令人恼火的bug。
原文http://blog.163.com/huangnan0727@126/blog/static/30626184200911122922339/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a801033b187487ff71bcadb4d421e1/" rel="bookmark">
			几种验证字符串是否全为数字方法的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Text.RegularExpressions;
namespace IsNumberTest
{
/// &lt;summary&gt;
/// 几种验证字符串是否全为数字方法的比较
/// &lt;/summary&gt;
class Program
{
static void Main(string[] args)
{
Stopwatch sw; //测试运行时间
int times = 50000; //循环次数
string testStr = "12a"; //测试用字符串
#region Regular Expression Method
sw = Stopwatch.StartNew();
Regex regIsNum = new Regex (@"^/d+$");
for (int i = 0; i &lt; times; i++)
{
regIsNum.IsMatch(testStr);
}
sw.Stop();
Console.WriteLine("Regular Expression Method Last Time: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4a801033b187487ff71bcadb4d421e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/985603dab3b3fa44dc07454723b93807/" rel="bookmark">
			SPI,UART,I2C都有什么区别，及其各自的特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SPI,UART,I2C都有什么区别，及其各自的特点 区别: SPI：高速同步串行口。3～4线接口，收发独立、可同步进行 UART：通用异步串行口。按照标准波特率完成双向通讯，速度慢 I2C:一种串行传输方式,三线制,网上可找到其通信协议和用法的 3根线实现数据双向传输 串行外围接口 Serial peripheral interface UART:通用异步收发器 UART是用于控制计算机与串行设备的芯片。有一点要注意的是，它提供了RS-232C数据终端设备接口，这样计算机就可以和调制解调器或其它使用RS-232C接口的串行设备通信了。作为接口的一部分，UART还提供以下功能： 将由计算机内部传送过来的并行数据转换为输出的串行数据流。将计算机外部来的串行数据转换为字节，供计算机内部使用并行数据的器件使用。在输出的串行数据流中加入奇偶校验位，并对从外部接收的数据流进行奇偶校验。在输出数据流中加入启停标记，并从接收数据流中删除启停标记。处理由键盘或鼠标发出的中断信号（键盘和鼠票也是串行设备）。可以处理计算机与外部串行设备的同步管理问题。有一些比较高档的UART还提供输入输出数据的缓冲区，现在比较新的UART是16550，它可以在计算机需要处理数据前在其缓冲区内存储16字节数据，而通常的UART是8250。现在如果您购买一个内置的调制解调器，此调制解调器内部通常就会有16550 UART。 I2C:能用于替代标准的并行总线，能连接的各种集成电路和功能模块。I2C是多主控总线，所以任何一个设备都能像主控器一样工作，并控制总线。 总线上每一个设备都有一个独一无二的地址，根据设备它们自己的能力，它们可以作为发射器或接收器工作。多路微控制器能在同一个I2C总线上共存。 更详细的区别：
第一个区别当然是名字：
SPI(Serial Peripheral Interface：串行外设接口);
I2C(INTER IC BUS：意为IC之间总线)
UART(Universal Asynchronous Receiver Transmitter：通用异步收发器)
第二，区别在电气信号线上：
SPI总线由三条信号线组成：串行时钟(SCLK)、串行数据输出(SDO)、串行数据输入(SDI)。SPI总线可以实现 多个SPI设备互相连接。提供SPI串行时钟的SPI设备为SPI主机或主设备(Master)，其他设备为SPI从机或从设备(Slave)。主从设备间可以实现全双工通信，当有多个从设备时，还可以增加一条从设备选择线。
如果用通用IO口模拟SPI总线，必须要有一个输出口(SDO)，一个输入口(SDI)，另一个口则视实现的设备类型而定，如果要实现主从设备，则需输入输出口，若只实现主设备，则需输出口即可，若只实现从设备，则只需输入口即可。
I2C总线是双向、两线(SCL、SDA)、串行、多主控（multi-master）接口标准，具有总线仲裁机制，非常适合在器件之间进行近距离、非经常性的数据通信。在它的协议体系中，传输数据时都会带上目的设备的设备地址，因此可以实现设备组网。
如果用通用IO口模拟I2C总线，并实现双向传输，则需一个输入输出口(SDA)，另外还需一个输出口(SCL)。（注：I2C资料了解得比较少，这里的描述可能很不完备）
UART总线是异步串口，因此一般比前两种同步串口的结构要复杂很多，一般由波特率产生器(产生的波特率等于传输波特率的16倍)、UART接收器、UART发送器组成，硬件上由两根线，一根用于发送，一根用于接收。
显然，如果用通用IO口模拟UART总线，则需一个输入口，一个输出口。
第三，从第二点明显可以看出，SPI和UART可以实现全双工，但I2C不行；
第四，看看牛人们的意见吧！
wudanyu：I2C线更少，我觉得比UART、SPI更为强大，但是技术上也更加麻烦些，因为I2C需要有双向IO的支持，而且使用上拉电阻，我觉得抗干扰能力较弱，一般用于同一板卡上芯片之间的通信，较少用于远距离通信。SPI实现要简单一些，UART需要固定的波特率，就是说两位数据的间隔要相等，而SPI则无所谓，因为它是有时钟的协议。
quickmouse：I2C的速度比SPI慢一点，协议比SPI复杂一点，但是连线也比标准的SPI要少。 SPI、I2C、UART三种串行总线协议的区别
SPI(Serial Peripheral Interface：串行外设接口)
I2C(INTER IC BUS)
UART(Universal Asynchronous Receiver Transmitter：通用异步收发器)
SPI
The SPI includes these distinctive features:
Master mode and slave mode
Bi-directional mode
Slave select output
Mode fault error flag with CPU interrupt capability
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/985603dab3b3fa44dc07454723b93807/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/132/">«</a>
	<span class="pagination__item pagination__item--current">133/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/134/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>