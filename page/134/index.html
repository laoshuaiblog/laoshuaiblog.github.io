<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c22e452a3f5f880889d8abfb27648d/" rel="bookmark">
			总结C# ----后台弹出窗体和打开网页的不同方法,以及关闭网页的方法.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.控件再UpLoad中,弹出窗口
ScriptManager.RegisterStartupScript(this, this.GetType(), "alert('!');", js, true);
2.控件不再UpLoad中,弹出窗口
Page.RegisterStartupScript("Messages", "&lt;script&gt;alert('OK'')&lt;/script&gt;");
3.弹出新的网页
Response.Redirect("'Default.aspx");
Response.Redirect("'Default.aspx?id=" + this.GridView1.SelectedDataKey.Value.ToString());
4.利用前台注册脚本弹出固定大小的页面
AutoId.Attributes.Add("onclick", "window.open('Default.aspx?AutoID=" +
SetupList.DataKeys[e.Row.RowIndex][0].ToString() + "','','height=500,width=400px,top=100,left=200,toolbar=no,menubar=no,scrollbars=yes,resizable=no,location=no,status=no');");
注:AutoId为服务器控件可以为LinkButton控件
5.注册前台事件,关闭弹出窗体,并且刷新父窗体(结合4使用.)
ClientScript.RegisterClientScriptBlock(this.GetType(), "closeWindow", "CloseWindowReflash()", true);
前台js函数
function CloseWindowReflash()
{
window.opener.parent.document.frames.item('frame').location.reload();
window.close();
} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac99d789abc18fb9aeda119151dc3b3d/" rel="bookmark">
			第五章  逆转的奇迹--Borland JBuilder的战斗发展史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章 逆转的奇迹--Borland JBuilder的战斗发展史"没有JBuilder，Borland就不可能拥有今日的荣景！"Java的快速兴起和成功是谁也没有预料到的，即便对于SUN自己似乎也是一个极大的意外，但是成功者一定是果断而且行动迅速的。当SUN察觉到Java的光明未来之后，便立刻开始大力推销Java。SUN的总裁McNealy先生数年来苦于没有直接和Microsoft对抗的机会，这下在Java的身上似乎找到了契机，当然更重要的是SUN接下来的一连串行动都被证明是正确而成功的。这些行动包括和各种厂商合作；与Addison-Wesley公司合作出版一系列畅销且成功的Java书籍；在各大媒体占据版面发表所有与Java相关的文章、专栏等；快速培养Java使用者的基础，吸引大众对于Java的兴趣。这完全是Microsoft一向无往不胜、攻无不克的手法，SUN也发挥得淋漓尽致，并且"以彼之道还施彼身"。更重要的是McNealy立刻果断地投入大量的研发资源，不断地改善Java，终于使Java从1995年开始展露锋芒，并且快速地成为业界焦点，自此展开了PC发展史上最大规模对抗Microsoft的争霸战，也改变了许多软件开发的习惯和方向。当然对于Borland来说，Java的发展史也是一场惊涛骇浪的生死之战，是Borland从未经历过的大规模集团军混战。对于Borland来说，事情并没有那么顺利。1995年，当Java开始起飞时，Borland并没有预料到Java成长的速度会如此之快。Borland一开始只是把Java当成C/C++的延伸，因此只在Borland C/C++5.0中加入了支持Java的P1ug-In。不过Borland很快就发现事情并不是如此简单，因为除了Java的Plug-In反应并不好之外，也发现Symantec很快在Java开发工具找到了新舞台，而且发展得相当快速。在Microsoft对Java的态度未明之前，无疑Symantec占据了先机，Borland这才警觉到自己的失策，Java大会战一开始Borland就已经落后了。Borland如何才能在下一场最重要的开发工具大战中进行反攻呢？Java开发工具初期的争战当Symantec从C/C++开发工具市场大撤退之后，Eugene Wang不愧是相当高明的开发工具好手，立刻察觉到尽管在C/C++市场遭遇失败，但利用原有力量却可以在即将茁壮成长的Java市场上扳回一城，因此立刻率领原先Symantec C/C++的开发团队快速进入Java开发工具的领域。Eugene很快以当初Symantec C/C++的集成开发环境作为基础，开始开发Java开发工具，这就是后来著名的Visual Café。Symantec几乎是第一个介入Java开发工具的软件公司，又利用了Symantec C/C++的基础，因此在1995年，当Java获得愈来愈多人的注意之后，Symantec也准备好了她的第一个Java开发工具--Visual Café。1996年10月，Symantec赶在JDK 1.1之前正式推出了Visual Café。虽然当时许多人批评Symantec为什么不等到JDK 1.1之后再推出，以支持最新的JDK标准(因为当时的JDK 1.0x版本有许多的问题)，不过这些批评并没有妨碍Visual Café的成功。由于当时许多软件人员急于投入Java的学习行列，因此当Symantec推出了Visual Café之后，立刻在市场获得了极大的成功。特别是在Java学习市场和教育市场，VisualCafé几乎是以席卷市场的姿势迅速占据了Java开发工具第一名的地位，成为炙手可热的产品，而Symantec公司也一扫在C/C++开发工具被挫败的怨气，再次成为开发工具市场的领导厂商。由于当时Microsoft对于Java采取敌视的态度，因此几乎不可能推出Java开发工具，而Borland也还正陷于C/C++的苦战之中，尚未查觉到Java的潜力。至于另外一个死对头Watcom则已被Sybase并购，无法在开发工具市场再成气候。这对于Symantec来说简直是天赐良机，一个可以独打Java开发工具市场的绝佳机会。剩下唯一的威胁是SUN要推出的Java开发工具。但是Symantec已经抢得市场先机，而且已经成为领先者，只要好好的把握，就能够以逸待劳和SUN对战。在这个Java开发工具萌芽的阶段，Symantec似乎是占了绝对的优势，不过很可惜的是接下来Symantec也接连犯了几个错误，逐渐失去了取得的优势。首先是当Visual Café推出之后，Eugene Wang便离开了Symantec自己开公司做生意去了。这对于Visual Café有着相当大的影响，因为Symantec靠着Eugene Wang的技术能力和眼光，才能够和Microsoft、Borland和Watcom在C/C++开发工具市场对抗；Eugene Wang又独具慧眼打造了第一个Java开发工具Visual Café。Symantec应该在Visual Café获得初期的胜利之后再次借重Eugene Wang的功力继续攻城掠地，但是Symantec居然让Eugene Wang离开，立刻少了开发工具掌舵的大将。第二个错误是Symantec当初为了尽快推出Visual Café以抢占市场先机，因此集成开发环境是使用C/C++语言撰写的。这造成了数项缺点，其一是由于使用了C/C++来撰写可视化窗体设计家(Visual Form Designer)，因此程序员在设计时看到的可视化效果和真正Java程序执行时的效果是有一些差异的；其二是为了维护Java的控制组件程序代码和以C/C++撰写的可视化窗体设计家保持同步的状态，在可视化窗体设计家产生的原始程序代码中内嵌了一些Visual Café控制卷标(Control Tag)。这些控制卷标并不是Java的程序代码，只是为了可视化窗体设计家使用。如果程序员不小心修改或是删除了这些控制卷标，就会造成Visual Café的可视化窗体设计家的失效。这是非常严重的缺点，Symantec应该在Visual Café 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac99d789abc18fb9aeda119151dc3b3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d6a8c91e2a548576c631c1c432c1f40/" rel="bookmark">
			利用C#制作简单的留言板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Author:unknown From:Internet 留言板分三个模块：列出留言列表、显示详细内容、发表留言 notepage.cs namespace notpage { using System; using System.Data.SQL ; using System.Data ; using System.Collections ; // // Class Name : 留言板 // // Description: 构造一个留言板对象 // // date: 2000/06/06 // // 作者： 天啦 /// /// &lt;summary&gt; /// Summary description for notepage. /// &lt;/summary&gt; public class notepage { //私有变量 private int n_intID ; //ID编号 private string n_strTitle ; //主题 private string n_strAuthor ; //留言人 private string n_strContent ; //留言内容 private DateTime n_dateTime ; //留言时间 //属性 public int ID { get { return n_intID ; } set { n_intID = value; } } public string Title { get { return n_strTitle ; } set { n_strTitle = value; } } public string Author { get { return n_strAuthor ; } set { n_strAuthor = value ; } } public string Content { get { return n_strContent ; } set { n_strContent = value ; } } public DateTime adddate { get { return n_dateTime; } set { n_dateTime = value; } } //构造函数 public notepage() { // // TODO: Add Constructor Logic here // this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d6a8c91e2a548576c631c1c432c1f40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2d12484eefc529cea9f001e2256ba90/" rel="bookmark">
			Borland传奇-李维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		李维声明 以下的这篇文章内容是我个人的回忆以及看法，没有任何特别的偏见，许多的事情是根据我的记忆以及从许多人的诉说中得知的，也许内容不是百分之百的正确，不过我想这些内容有一定的可信度到是可以保证的。当然有一些事情确定的发生时间和顺序不一定都和我的记忆一致，不过我想大部份应该是相去不远的。当然各位如果知道确定的事件而我的记忆有误，那么我将非常欢迎您纠正我，我希望这些故事的经历能够一直陪我走下去，谢谢。 一直想写一篇我个人在过去10多年来工作中经历的一些事情，以及看着一些我认为是伟大的工程师在这些日子中对于信息界的贡献。如果你和我的年龄差不多，那么你可能会对于这些内容很有兴趣，因为它们说明了当时许多软件的兴起和没落的过程以及原因。虽然这些事情已经距离我们很遥远了，但是我相信许多人仍然对于背后的故事有兴趣。如果你没有经历过那段美好的回忆，那么就把这些内容当成是一个有趣的故事来看吧。但是我想更重要的是让我们一起认识一些伟大的人物，我对于其中的许多人都非常的佩服，也非常的羡慕。我常常在想，如果我也有他们的环境，我是不是也能够和他们一样这么有成就呢?这些人对于以往都有重要的贡献，在未来也将仍然有重要的影响，因为他们都有一身不凡的技术。对于许多重要的人我都尽量的收集了他们的照片，让各位也能够看看这些优秀的工程师和杰出的人物。当然，如果各位也能够从这些内容中学习到失败的原因以及成功的经验，那么这篇文章就更有价值了。 和Borland的缘由 记得我在大学时第一个在PC上使用的软件便是SideKick，至今我仍然无法忘记这个让我津津乐道的软件，而Borland在当时也就是以SideKick成为全球知名的软件公司。不过Borland第一个奠立创业基业的软件却是我大二使用来交作业的Turbo Pascal。而Turbo Pascal也是第一个我听到关于Borland的有趣的故事
当年Philippe Kahn (Borland的创使人)和Anders Hejlsberg到美国创业时，便由Anders以汇编语言撰写了Turbo Pascal的编译器，而Philippe则包办了Turbo Pascal其它的部份。在这两位人兄开发完Turbo Pascal之后，穷得快连登广告的钱都没有了。但是Philippe为了在Byte杂志(还记得这个著名的杂志吗?)刊登Turbo Pascal的广告，因此和Anders商量了一个方法，那就是一天他们约了Byte杂志的人到当时Borland的办公室讨论刊登广告的事情。
当Byte的人到了Borland之后，Philippe，Anders和公司的助理小姐故意忙着接电话，接受Turbo Pascal的订单，并且告诉Byte杂志的人等一下。过了一阵子之后Philippe才进入房间向Byte的人道歉，说他们的Turbo Pascal受到市场的热烈欢迎，订单源源不断的到来，因此可能不需要在Byte杂志刊登广告了，接着Philippe向Byte的人展示Turbo Pascal这个产品。由于在当时的机器中Turbo Pascal能够在少少的RAM中常驻执行，又提供闪电般的编译速度，立刻让Byte杂志的人震惊在当场，凭着专业知识和丰富的经验，Byte的人也立刻知道这将是一个革命性的软件，因此马上希望Philip能够在Byte杂志刊登Turbo Pascal的广告，并且愿意以半价刊登。当然，Philip也立刻的答应了，于是一个革命性的软件Turbo Pascal终于在Byte杂志刊登出来了，售价49.99美元的Turbo Pascal立刻为Borland带来了大量的财富，Turbo Pascal也立刻的成为PC上除了基本的Basic之外最畅销的开发工具，也正式揭开了Borland影响PC开发工具10几年的序幕。
在Turbo Pascal之后，Borland接着推出了SideKick这套软件，SideKick可以说是随后著名的内存常驻软件(TSR)的始祖，也是让Borland跨出开发工具界，让几乎所有PC使用者认识Borland的关键软件。当然SideKick也很快的成为了全球的畅销软件，继续的把Borland往顶尖的软件公司上推。
而Turbo Pascal也成了我大二，大三撰写作业的最爱，几乎所有的作业都是使用Turbo Pascal完成的，当然其时Horowise的Data Structure这门课也是使用Turbo Pascal过关的，因此从那个时候开始我便非常喜欢Borland这家公司，慢慢的也开始对Borland有了特别的感情。
大二时Microsoft也推出了Microsoft Pascal，但是它和Turbo Pascal的确是有一段差距，我使用了一次之后便把它丢到垃圾桶。稍后Borland也推出了Turbo Basic，我记得这个编译器非常的棒，编译速度就和Turbo Pascal一样，是一个非常有前途的产品。但是我不知道为什么它只有1.0，之后便和Microsoft Pascal一样消失了。我听说Microsoft和Borland互相交换条件，Microsoft不进入Pascal的市场，而Borland则退出Basic的市场。至于是不是真的我就不得而知了。
在大二初次的接触到C语言，第一本阅读的书便是王兴隆先生写的C语言，也从此开始和C语言结下了渊源。平生第一个使用的C编译器便是Lattice C，不知道还有没有人记得。我还记得那个时候使用2个5又1/4磁盘抽换以便编译C程序的情景。稍后Borland终于推出了风行天下的Turbo C编译器，当然，从此之后Turbo C便成了不离身的工具，而Borland也藉由Turbo C这第三项畅销产品迈向了世界前10名的项尖软件公司。
当完2年的兵之后，我在中研院首次使用了C++语言，第一个使用的C++编译器则是Zortech C/C++，这家公司稍后被Symantec收购成为Symantec C/C++的核心，这个故事稍后再说。后来Borland也推出了Turbo C/C++ 1.0这第一个C/C++编译器，但是在我和Zortech C/C++比较之后，还是觉得Zortech C/C++比较好，因此就继续使用Zortech C/C++。一直到Borland的Turbo C/C++ 2.0编译器推出之后，才逐渐成为C/C++语言的王者，而我也像以往一样把Zortech C/C++换成了Turbo C/C++。
在1991年到Georgia Institute Of Technology念硕士时，终于使用自己的零用钱美金49.99购买了生平第一套的正版软件Turbo C/C++ 4.5，随后又购买了Borland Pascal。在毕业前的一个Quarter，Microsoft 推出了Microsoft C/C++ 6.0以及MFC 1.0，由于是第一个C/C++的Framework，因此也花了一些钱购买了一套以便了解MFC。但是在收到之后却很失望，因为Microsoft C/C++ 6.0仍然没有图形整合发展环境，还是在DOS下的整合发展环境，而且MFC 1.0以我的眼光来看又不好用，而且Microsoft C/C++ 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2d12484eefc529cea9f001e2256ba90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff81c0f11da1d3965a170a0774060ff9/" rel="bookmark">
			12.3.3.13 Try-catch statements
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12.3.3.13 Try-catch statements For a statement stmt of the form: try try-block catch(.) catch-block-1 . catch(.) catch-block-n . The definite assignment state of v at the beginning of try-block is the same as the definite assignment state of v at the beginning of stmt. . The definite assignment state of v at the beginning of catch-block-i (for any i) is the same as the definite assignment state of v at the beginning of stmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff81c0f11da1d3965a170a0774060ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd75397ccee9e793f60b4d271f3f76f/" rel="bookmark">
			8.7.5 Events
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.7.5 Events An event is a member that enables an object or class to provide notifications. A class defines an event by providing an event declaration (which resembles a field declaration, though with an added event keyword) and an optional set of event accessors. The type of this declaration must be a delegate type. An instance of a delegate type encapsulates one or more callable entities. For instance methods, a callable entity consists of an instance and a method on that instance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbd75397ccee9e793f60b4d271f3f76f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dcf3117bf4a29bd9b0b80cb41f452e2/" rel="bookmark">
			EIA232 Standard(RSR232)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Written by Christopher E. Strangio
Copyright &amp;copy; 1993-2004 by CAMI Research Inc., Lexington, Massachusetts
(RSR232 renamed the "EIA232 Standard" in the early 1990's)
What is EIA232?
In the early 1960s, a standards committee, today known as the Electronic Indus
tries Association, developed a common interface standard for data communicatio
ns equipment. At that time, data communications was thought to mean digital da
ta exchange between a centrally located mainframe computer and a remote comput
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dcf3117bf4a29bd9b0b80cb41f452e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f15613b376c764fcd1acdd05ca9ed8e/" rel="bookmark">
			利用c#制作简单的留言板(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		留言板分三个模块：列出留言列表、显示详细内容、发表留言
notepage.cs
namespace notpage
{
using System;
using System.Data.SQL ;
using System.Data ;
using System.Collections ;
/// &lt;summary&gt;
/// Summary description for notepage.
/// &lt;/summary&gt;
public class notepage
{
//私有变量
private int n_intID ; //ID编号
private string n_strTitle ; //主题
private string n_strAuthor ; //留言人
private string n_strContent ; //留言内容
private DateTime n_dateTime ; //留言时间
//属性
public int ID
{
get
{
return n_intID ;
}
set {
n_intID = value;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f15613b376c764fcd1acdd05ca9ed8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b8374b8460b0b42caea30fa4e84e50f/" rel="bookmark">
			ASP.NET立即上手教程 7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web Forms 用户控件 用户控件介绍 除了ASP.NET提供的内建的服务器控件外，你还可以使用已经掌握的制作WEB FORMS 页面的 技术，轻松的定义自己的控件。实际上，只需要稍微改动一下，几乎任何WEB FORMS页面都 可以作为服务器控件，在其他页面上重复使用。(注意用户控件的类型是System.Web.UI.U serControl, 它直接从System.Web.UI.Control继承而来)。 Web Forms 页面被作为服务器 控件使用的时候，简称为用户控件。转变之后，通常使用.ascx扩展名来表明用户控件。这 就保证了用户控件文件不能作为一个单独的web form页面来执行(你可以明白，在用户控件 和web forms 页面之间，有一点，但是很重要的区别)。用户控件使用Register（注册）指 令包含在Web Forms 页面中： TagPrefix 为用户控件确定了唯一的名称空间。(这样，具有相同名字的多个用户控件可以 互相区分). TagName 的值是用户控件的唯一名称(你可以使用任何名字)。 Src 属性是用 户控件的虚拟路径—例如"MyPagelet.ascx" 或者 "/MyApp/Include/MyPagelet.ascx"。 注册用户控件之后，你可以在web forms页面中放置用户控件标签，就像是用平常的服务器 控件一样(包含runat="server" 属性)： 下面的例子展示了web forms页面引入用户控件的情况。本例中的用户控件仅仅是一个简单 的静态文件。 C# Pagelet1.aspx [运行] | [源文件] 扩展用户控件的属性 当web forms页面作为用户控件处理的时候，web forms页面的公共字段和方法升级为公共 属性（即标签属性）和公共方法(标签的方法)。下面的例子将上一个例子中的用户控件进 行延伸，增加了两个公共 String字段。注意这两个字段既可以在包含页中直接声明，也可 以用程序来控制。 C# Pagelet2.aspx [运行] | [源文件] 除了将公共字段升级为控件属性外，也可以使用属性语法。 使用属性语法胜过为了设定或 者取得属性值而执行代码。下面的例子示范了一个Address 用户控件，他绑定了TextBox 控件的text 属性。这样做的好处在于该控件“免费”继承了TextBox 控件的自动状态管理 。注意在包含web forms页面中有两个Address 用户控件，分别为"Billing Address"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b8374b8460b0b42caea30fa4e84e50f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061aaf0cb67c00ce9f30ff2cfd7656dd/" rel="bookmark">
			附录 Borland大事记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1983.5.2 Philippe Kahn和Anders Hejlsberg在美国Scott Valley共同成立Borland
International公司。
同年11月，发布Turbo Pascal，Borland一举成名。
1984 发布内存常驻工具软件SideKick，成功打入消费软件市场。
1985 发布Borland第一个，也是最后一个Basic开发工具产品：Turbo Basic。
从Ansa公司购得Paradox。
1986 发布Turbo Prolog。
1987 发布Turbo C 1.0，提供C语言开发集成环境工具。
Turbo Pascal 4.0也在这一年推出。
1989 在购入Ansa公司(1987年)后，推出Paradox 3.0。
1990 在Turbo C基础上推出C++开发工具Turbo C/C++。
该产品也被称为Borland C/C++。
写在最后
1983年5月2日Borland International正式成立
1983年11月20日Borland正式推出第1个代表产品--Turbo Pascal 1.0
2003年2月5日《Borland传奇》一书正式完成。
谨以本书向一个成立20年的传奇软件公司致敬，因为她为许多人留下了一生美好
的回忆
李维
北京市朝阳区北三环东路8号
静安中心26层2662
《程序员》杂志社
读者服务
尊敬的读者：
感谢你购买P&amp;C出版的计算机图书，为了更好的为读者提供服务，请详细填写回执卡
(背面)各栏，邮寄或传真回本公司，我们将根据您的宝贵意见不断追求进步，并不定
期提供最新出版信息。
我们的联系方式：
地址：北京市朝阳区北三环东路8号静安中心26层2662
邮编：100028
客服信箱：book@csdn.net
网址：http://www.csdn.net 电话：010-51661202-279
传真：010-84540263
(本书如有破损、缺页、倒装请寄回更换)
【全书完】
【致谢】
感谢taopian提供的源书，他的首印纪念版已经被我糟蹋的不成样子了，390页的书
已经被翻成了新华字典那么厚，实在不好意思，看来是要再买一本来还他了。大家
想买书也可联系他。当然还要感谢偶的狗狗mm这些天的支持和协助^_^
本来是想做电子书的，后来觉得还是只把文字介绍给大家，原书所附的大量图表
和照片都没有扫描，这中间包括了很多大牛的照片和统计数据，建议有兴趣的朋
友一定买一本看看。从2003年4月到现在本书已经印刷了六次，作为软件公司的经
典案例和技术发展的亲身见证，深受读者好评。
1991 购入Ashton-Tate公司，获得dBase。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/061aaf0cb67c00ce9f30ff2cfd7656dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61866ae49e94c8f2dc7a509a16e4cec8/" rel="bookmark">
			第十三章 软件科技的发展和Borland的未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"Into The Future？" 在前面的章节中，本书讨论了许多现象和问题。除了Borland本身的发展故事之外， 也讨论了一些科技的现状和未来的发展。在Java和.NET平台的竞争以及许多科学技术 的发展下，Borland的未来到底会如何呢？Borland又要如何适应才能够持续在信息界 竞争、生存下去，进而茁壮成为更大的信息公司呢？在本章中我将提出一些个人的看 法。 除了软件公司的发展之外，我也观察到了一些信息技术的走向。这些信息的发展在未 来也都将牵动着开发人员的走向。除了在第10章中讨论的事项之外，我也认为更精致 化的程序开发能力、面向对象和Modeling的平民化、Web Service的发展以及.NET平 台的普及化都将在2003年开始对于开发人员产生愈来愈深的影响。其中，Web Service 和.NET是开发人员无法控制的信息发展潮流。开发人员唯有在了解了它们的趋势之后， 及早准备以适应未来的趋势。 而精致化的程序开发能力、面向对象和Modeling技术的平民化，则是属于比较贴近开 发人员的发展，也是开发人员能够掌握和进一步控制的因素，是软件人员必须了解未 来继续从事软件开发工作时必须克服和掌控的技术趋势。 到底这些因素的影响事项是什么呢？为什么它们对于软件人员在未来有很大的影响呢？ 这些也是本章讨论的重点。 不都是整理和抽丝剥茧吗？ 我在从事信息工作的生涯中使用过数种不同的程序语言、数据库、组件模型以及 Framework。面对许多新的技术不断地出现，开发人员似乎陷入了永远学不完新东西的 梦魇。不过，如果开发人员仔细回味许多技术的本质，却会发现这些技术其实只是把 我们已经了解的东西再以更细致化的方式加以运用，关键在于开发人员是否注意到了 这些本质和趋势而已。 例如，目前在C++中流行得火热的Template、Policy-Based template，在Java、Object Pascal和C#中当红的接口程序设计，以及各种组件模型和Web Service中的服务接口 等，如果我们仔细地咀嚼，会发现许多的东西正是发挥程序员原本就拥有的整理和抽 丝剥茧精神，再加以发挥的东西。这怎么说呢？让我们以数个例子来说明读者就容易 了解了。 首先让我们想想为什么会出现数据库这类的产品？很简单，因为由于数据愈来愈多， 数据种类也愈来愈繁杂，因此造成了我们需要一种软件产品能够整理这些数据让它们 更容易的被我们处理和使用，因此才有了数据库的想法和产品。 在每一个程序员学习撰写程序代码时，也会发现随着撰写的程序代码愈来愈多，许多 的程序代码不断重复出现和被使用，因此很自然的程序员开始使用例程(routine)/子 程序(subroutine)或是过程(procedure)、函数(function)等机制帮助我们进行程序 代码整理和抽丝剥茧的工作。 这些数据和程序代码整理的工作几乎是每一个程序员的求生本能，只是有的程序员只 做基本的整理工作，而更聪明的开发人员则对于整理的工作有不同的看法，进而促使 了许多延伸软件技术的出现，也开始对软件开发产生了重大的影响。例如，对于原本 杂乱的程序代码以数据和程序代码分离的看法而逐渐产生了面向对象的技术，以分离 例程/子程序和数据类型为看法的应用则产生了类似C/C++中的template技术，而以函 数面对服务的看法，认为开发人员应该面向服务的开发模式则造成了接口程序设计 (Interface Programming)的应用热潮。虽然现在这些从程序代码延伸出的技术都独领 风骚，在软件开发界中产生了重大的影响和开发模式的改变，但是，如果我们追根究 底来观察，这些技术不都是从对程序代码和数据的分析、整理和抽丝剥茧之后，以更 精致的方式来处理和开发软件吗？ 因此，本着相同的想法和精神，聪明的开发人员开始脱离单一程序语言的架构而进入 了开发出可重复使用的软件组件模型，让不同的程序语言都能够在统一的组件模型中 达成团队开发的功效。这个更聪明的整理和抽丝剥茧的想法造就了CORBA、COM/COM+ 和EJB等组件模型的驱动力。 除了脱离程序语言之外思考的开发人员外，另外有一些开发人员则再次回头检视本身 和他人的程序代码，并且努力搜寻优良和成功程序代码的基因，因此发现了这些优良 和成功的程序代码似乎都有着类似的模式和架构，再经过进一步的分析之后终于产生 了Design Pattern，这成为目前最重要的软件开发模式和技巧之一。在这之后，这些 聪明的开发人员了解到如果能够成功运用Design Pattern，并且把程序设计转变成以 服务为目标的方式，将更能够简化、标准化和结合Design Pattern的运用，并且隐藏 复杂的实现技巧，这就进而产生了Service Interface Programming的观念和技巧。 由此可见，只要开发人员能够发挥细心整理和抽丝剥茧的能力，那么即使无法创造出 伟大的新软件工程或是软件技术，但是仍然能够帮助我们增加生产力和软件品质。因 此，对于开发人员来说重要的不是无止境地学习层出不穷的各种新技术，而是到底有 没有了解这些技术之后代表的观念、思想，以及学习最重要的对于软件开发整理和抽 丝剥茧的能力。在我的工作生涯中，一直认为技术终究是会被大多数的人学会的，但 是在辛辛苦苦地努力这么多年后，到底我们的思想、眼光和抽丝剥茧的能力是否有所 精进呢？如果没有，那么我们永远就像被蒙着眼睛，只能尾随着他人告诉的技术前进， 永远找不到自己的方向。 现在，再让我们以一个C++的例子来证明只要开发人员能够看透程序语言和技术背后 代表的真实意义，那么即使是在已经被众人熟知的技术中，仍然能够创造出新的技术 和含义。在Andrei Alexandrescu先生所著的"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61866ae49e94c8f2dc7a509a16e4cec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c2ecb3a8228d590706ee33bb3879ee/" rel="bookmark">
			第十二章 回到C$C&#43;&#43;的王国
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"让我们重返荣耀之都吧！" 当年Windows平台C/C++开发工具四大天王一战，在Microsoft取得了市场的主导力量 之后，C/C++开发工具的市场和竞争反而缓慢了下来，Windows上C/C++开发工具的进 步也开始牛步化。VC++一连两三个版本的进度幅度并不大，除了稍后推出的ATL还有 新意和技术革新，VC++编译器除了在C/C++语言上更趋近于标准之外，MFC本身几乎已 经没有什么大的进步了。在Watcom和Symantec退出市场之后，VC++也顺利地接受了 Watcom和Symantec的市场。而Borland C/C++虽然也损失了大量的市场，并且失去了 C/C++的王座，但是在数年后，Borland推出C/C++Builder，以C/C++ RAD工具、以及 更符合ANSI C/C++标准和VC++进行市场的区隔，也慢慢地收复了一些失地。虽然 Borland C/C++工具系列已经无法像以前一样是市场第一的C/C++开发工具，但是 Borland在Windows的C/C++开发工具市场仍然占有30％强的市场份额。 C/C++开发工具在C/C++ Framework一战之后，开发的重点却似乎模糊了起来。由于VC ++没有强劲的竞争，因此整个的发展速度缓慢下来。不过C/C++技术在C/C++语言、函 数库(Library)和通用Framework方面却快速地如雨后春笋般兴起。特别是在C/C++语 言的标准化更为完善、以及Template的功能被C++ Standards Committee接受而且被 广泛地由C/C++编译器支持之后，各种支持和使用Template的Framework、C/C++函数 库也快速地占据了C/C++开发者的心灵，成为有力的程序技巧之一。在Java日益兴盛、 开始威胁C/C++的市场时，反而激发了C/C++语言前所未有的高度发展。不过，目前 C/C++开发工具以及C/C++编译器是否跟上了C/C++这么快速的发展脚步呢？在本章继 续讨论之前，也许应该让我们先看看目前C/C++市场的现况。 日不落帝国 曾几何时，C/C++是征服全世界的语言之一。在数年前C/C++语言全盛的时期，我记得 几乎所有的应用系统都选择使用C/C++来编写，如从系统程序、公用程序、软件包到 项目开发，因此也造就了C/C++开发工具横扫软件销售市场的现象。但是随着RAD工具 和Java的逐渐受欢迎，让C/C++开始从许多的市场撤退。特别是当Java兴起之后便快 速取代了以往C/C++在跨平台语言的主导角色，让C/C++语言在这个市场受到Java最大 的威胁。不过，C/C++仍然在许多方面的应用不可否认地具有绝对的优势，特别是在 需要高度执行效率的应用系统中，例如驱动程序和低阶的系统程序等。那么C/C++目 前的市场到底有多少？有没有像两、三年前许多信息机构预测的那样，Java将会大幅 抢走C/C++的市场、并且吸引大量的C/C++程序员呢？让我们以实际的数据来看看目前 的状态。 右图是全世界专业信息机构对于C/C++开发工具市场规模和使用状况的调查结果。从 这个结果图形中我们可以得知几个非常重要的C/C++信息： 首先请读者注意的是，就整体来说C/C++开发工具的市场的确是处于小幅的下降趋势 之中，根据Gartner Group的调查，C/C++市场是以5％的幅度下降，而根据Evans Data Survey的调查，C/C++市场则是以3％的幅度下降。不过稍后我们会说明，C/C++开发 工具是在哪些平台和应用中产生变化。 另外一个值得注意的地方，是C/C++语言主要是用于三个应用领域之中，分别是客户 端、伺服端和维护现有的应用程序。从图中我们也可以发现C/C++语言被使用的转变 状态，在工业应用方面，C/C++开发工具仍然有很大的成长，这当然是因为C/C++语言 被广泛用于驱动程序的开发，例如显示卡驱动程序、网卡驱动程序等。此外C/C++语 言也被用于移动设备的开发，例如Nokia为了和Microsoft的Smart Phone对抗而推出 的Symbian手机系统。当然，在操作系统、系统程序和低阶核心应用方面C/C++语言仍 然有着不可取代的地位。 但是，C/C++在其他方面的应用的确是在下降之中，特别是在企业的应用系统方面。 例如目前在大型项目、软件包、MIS和企业内部的应用系统中，使用C/C++语言的比例 的确在下降。其中主要的原因是C/C++语言本身的难度较高，因此生产力也不如其他 语言和开发工具。加上较易使用的RAD工具和Java出现之后，C/C++语言在这些领域的 影响力是大不如前的。这个现象也非常契合台湾地区目前的状况，在前几年C/C++兴 盛的阶段，几乎大部分的软件包厂商和SI以及系统厂商的确都是以C/C++开发工具为 第一选择。不过由于C/C++需要的人力素质较高，而且生产力无法大幅提高，因此在 目前软件包和项目的开发大多都由Delphi、VB、PowerBuilder以及Java所瓜分。 至于C/C++开发工具使用的操作系统分配状况，则可以由右面的调查结果来说明。 从图中我们可以发现，UNIX/Linux操作系统平台仍然是占了最大的使用平台，这当然 是由于UNIX/Lmux本身就是使用C/C++语言开发的。而且在UNIX/Linux平台我们可以发 现，C/C++开发工具的规模仍然在成长，可达成10％左右的年成长幅度。由此可知， 虽然Java现在已经入侵UNIX/Linux平台，但是对于C/C++的影响仍然不太显著。 C/C++开发工具第二个最大的平台就是Windows平台了，虽然现在Windows平台是开发 工具百花齐放的状态，但是不可否认的是，C/C++仍然是Windows最重要的数个语言之 一，因为122 Million到137 Million的市场规模是相当大的。而Windows平台的C/C++ 开发工具的成长虽然在为数众多的开发工具瓜分之下，仍可达到12％的成长率。这代 表C/C++语言即使是在Java强力竞争之下仍然拥有一定的成长量。由于Windows平台下 的C/C++和Java开发工具是处于同时成长的情形，因此，这可能表示在Windows平台下 许多的程序员应该是同时使用了C/C++和Java开发工具。 至于其他平台的C/C++开发工具则呈现下降的趋势，而且是处于快速下降的情形，这 也可以解释为什么Java在Mainframe和OS/400等大型专属平台成长快速的情形。由此 可见，在这些专属市场中C/C++语言的确是受到Java很大的影响。 除了C/C++语言本身之外，再让我们观察一下目前主流语言应用的现况，通过观察不 同语言之间势力消长的情况，我们也可以了解其他语言对于C/C++语言的影响。右图 即显示了信息机构对于目前几个主流语言之间成长和下降的预估。 从图中我们可以看到，几乎所有的传统语言例如VB、C/C++和COBOL等都呈现下滑的趋 势，相同的现象当然也在第2级的主流语言例如Object Pascal和PowerBuilder等中看 到，但是新一代的虚拟语言却呈现了对比的情形而大幅上升和成长，表示使用这些新 语言的程序员人口正在快速的兴起之中，例如SUN的Java和Microsoft的C#，而Java快 速兴起也可以解释为什么Borland的JBuilder现在已经是Borland最大收入来源的开发 工具。 看完了C/C++整体市场的趋势之后，C/C++语言目前在程序员人口中使用的情形到底是 如何呢？下图是2002年针对美国程序员调查的结果，从这个结果中我们已经可以看到， 在所有调查的人数中使用C/C++的程序员占了45.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70c2ecb3a8228d590706ee33bb3879ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6abe3d39cdbc8e4e4ea56cbeb5e7df9b/" rel="bookmark">
			第六章 失去的王冠--Borland数据库工具的战役
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Borland的产品线中，有两个产品是较少受到瞩目的，那就是Borland从Ashton-Tate 并购来的dBase系列以及昙花一现的IntraBuilder。对于Borland来说，dBase和 IntraBuilder是非常可惜的牺牲品。dBase发展的黄金时机被Philippe Kahn白白浪费， IntraBuilder带来的无限潜力硬生生地被Delbert Yocam糟蹋掉。Borland最有机会的两 个关键时刻分别被两任CEO蹉跎，不知到底是时也？命也？运也？ dBase和IntraBuilder这两个产品，到底是如何在Borland中发展的呢？为什么最后dBase 和IntraBuilder都会进入死胡同？让我们一起来探索其中的秘密。 IntraBuilder的诞生 谁说"洞悉先机"一定是好事？当初哥白尼在几个世纪之前大胆地提出了天体运行论， 同势力庞大的基督教对抗，因而被基督教视为邪说，一直到3个世纪之后才被罗马教 皇承认。而哥白尼的一生都在承受着巨大的压力，Borland的IntraBuilder几乎也面 临了同样的命运。 1995年，当浏览器的应用逐渐成为主宰力量之后，各种Web的应用也开始快速地发展 起来。一开始Web应用是以面向文件为主，许多Web应用都使用纯文本编辑器来开发HTML 网页。但是人们很快发现，这种方式非常不经济，因为Web应用虽然有很大一部分属 于美工的需求，但是当Web进入人们的生活后，许多Web应用便开始需要结合数据处理 而转向商业的应用。因此，很快Web的解决方案便开始从静态网页的应用进入到使用 程序来解决的阶段。但是，当时正值浏览器大战的阶段，Netscape正和Microsoft的 Internet Explorer拼斗得你死我活，而Java也开始兴起。此时浏览器并没有标准， 连带着对HTML、JavaScript的支持也混乱无比。因此，虽然许多程序员都感觉需要一 个Web开发工具帮助他们开发逐渐炙手可热的Web应用程序，信息业界也开始有强烈的 需求，但是混乱的Web标准却让许多程序员不知所措。 不过，Borland的Visual dBase小组却从中看到了极大的契机，因为在为Visual dBase 未来的版本加入支持Web的功能时，Visual dBase小组突然发现，既然Web的功能是许 多程序员想要的，那么，为什么不直接提供一个可视化的Web开发工具，让需要开发 Web应用程序的程序员能够拥有最好的工具，而不需要痛苦地使用纯文本编辑器来开 发Web应用程序呢？ 时值1995年，这的确是一个令人相当震撼的想法，因为它体现了未来需求的趋势。当 Visual dBase小组提出这个想法之后，立刻在部门内获得了极大的回响。几经商议， Visual dBase小组决定先开发一个可视化的Web开发工具来测试市场，而且他们决定 就使用Visual dBase来开发这个新的产品。这实在是个大胆又令人惊讶的决定，因为 当时不但没有类似的产品，而且决定使用Visual dBase而非C/C++来开发新产品，更 是不可思议，开发工具真的可以使用Visual dBase来开发吗？ 当Visual dBase小组决定开发这个新的开发工具时，却面临了一些技术上的抉择，那 就是使用什么语言作为这个新开发工具的核心？另外，该产品既然是一个Web开发工 具，当然需要一个Web Server作为后端的驱动引擎。但是，当时的市场上只有Netscape 和O'Reilly等少数厂商拥有Web Server引擎。因此，Borland必须决定使用什么Web Server。不过，这些问题很快就有了答案。 由于Java快速地兴起，Applet也成为学习Java的入门知识，因此，JavaScript很快就 被众人视为开发Web应用程序的标准语言。于是Visual dBase小组决定使用JavaScript 作为这个开发工具的核心语言，并且强化当时的JavaScript语言，以支持这个新的开 发工具。另外，由于当时的Web Server大都不便宜，因此，Visual dBase小组决定自 行开发一个Web Server作为这个开发工具的内建Web Server。最后，Visual dBase小 组定义这个开发工具必须拥有下面的功能： ■ 可视化开发环境，允许程序员使用组件和拖曳的功能来设计Web应用程序 ■ 使用JavaScript作为核心语言 ■ 提供内建的Web Server ■ 结合BDE/IDAPI来连接各种数据库 这个开发工具便是IntraBuilder--后来震撼一时的数据库Web开发工具先驱。 在IntraBuilder开始开发之后，Visual dBase小组很快发现，虽然他们可以使用Visual dBase完成大部分的工作，但是，终究有一些功能是Visual dBase力所不逮的地方， 因此，在IntraBuilder开发的后期，为了让它能够支持当时Microsoft刚推出的、同 Applet相抗衡的ActiveX以及动态执行Applet，Visual dBase小组还是使用了部分的 C程序代码来完成这些功能。 IntraBuilder的震撼 1996年9月，经过1年多的开发，IntraBuilder终于推出在世人的面前。IntraBuilder 推出之后，全世界的专业媒体几乎都对IntraBuilder好评有加，而且都不能相信Borland 能够如此快速且先知地推出数据库的Web开发工具。 全世界的好评如潮，因此，在IntraBuilder准备正式出货之前，Borland也是信心满 满。我记得，当时在拿到IntraBuilder的Beta版后，虽然我对于Web的开发仍然没有 太多的经验，但是很快就了解了这个产品的潜力，因为IntraBuilder和当时其他的Web 开发工具以及编辑器比较起来，简直是领先了数个世代之久，而且还能够用来作为学 习JavaScript的工具和开发连接数据库的Web应用程序。这些功能在市面上几乎没有 任何的竞争对手可以比拟。即便以今日的标准来看，IntraBuilder提供的Web可视化 设计能力仍属一流。因此，当时我就觉得这会是一个大卖的产品。 IntraBuilder面对的困难 即便Borland非常有信心，专业媒体也一片看好，但是没有想到的是，在IntraBuilder 推出之后，只带来了第一波销售热潮，随后的销售却很快冷却下来，造成了IntraBuilde r 叫好不叫座的情形。这实在是一件很奇怪的事情，因为IntraBuilder产品本身没有太 大的问题，产品的方向也是正确的。但是为什么IntraBuilder在市场上就是无法拥有 亮丽的表现呢？这个问题是Borland急于寻找答案的。记得当时在台湾发表IntraBuilder 时，似乎也是回响热烈，但实际出席的人却不多。台湾Borland的产品经理还在会场 询问我，为什么出席的反应这么不热烈，产品本身不是不错吗？ 在IntraBuilder首次遭遇挫折之后，Borland很快便找出了其中的重要问题所在。有 些属于产品本身的小瑕疵，有些则是当时整个环境的问题。总结当时IntraBuilder 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6abe3d39cdbc8e4e4ea56cbeb5e7df9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecf08c6519993074b23e362a25f1e0e0/" rel="bookmark">
			第五章 逆转的奇迹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"没有JBuilder，Borland就不可能拥有今日的荣景！" Java的快速兴起和成功是谁也没有预料到的，即便对于SUN自己似乎也是一个极大的 意外，但是成功者一定是果断而且行动迅速的。当SUN察觉到Java的光明未来之后， 便立刻开始大力推销Java。SUN的总裁McNealy先生数年来苦于没有直接和Microsoft 对抗的机会，这下在Java的身上似乎找到了契机，当然更重要的是SUN接下来的一连 串行动都被证明是正确而成功的。这些行动包括和各种厂商合作；与Addison-Wesley 公司合作出版一系列畅销且成功的Java书籍；在各大媒体占据版面发表所有与Java相 关的文章、专栏等；快速培养Java使用者的基础，吸引大众对于Java的兴趣。这完全 是Microsoft一向无往不胜、攻无不克的手法，SUN也发挥得淋漓尽致，并且"以彼之 道还施彼身"。更重要的是McNealy立刻果断地投入大量的研发资源，不断地改善Java， 终于使Java从1995年开始展露锋芒，并且快速地成为业界焦点，自此展开了PC发展 史上最大规模对抗Microsoft的争霸战，也改变了许多软件开发的习惯和方向。当然 对于Borland来说，Java的发展史也是一场惊涛骇浪的生死之战，是Borland从未经历 过的大规模集团军混战。 对于Borland来说，事情并没有那么顺利。1995年，当Java开始起飞时，Borland并没 有预料到Java成长的速度会如此之快。Borland一开始只是把Java当成C/C++的延伸， 因此只在Borland C/C++5.0中加入了支持Java的P1ug-In。不过Borland很快就发现事 情并不是如此简单，因为除了Java的Plug-In反应并不好之外，也发现Symantec很快 在Java开发工具找到了新舞台，而且发展得相当快速。在Microsoft对Java的态度未 明之前，无疑Symantec占据了先机，Borland这才警觉到自己的失策，Java大会战一 开始Borland就已经落后了。Borland如何才能在下一场最重要的开发工具大战中进行 反攻呢？ Java开发工具初期的争战 当Symantec从C/C++开发工具市场大撤退之后，Eugene Wang不愧是相当高明的开发工 具好手，立刻察觉到尽管在C/C++市场遭遇失败，但利用原有力量却可以在即将茁壮 成长的Java市场上扳回一城，因此立刻率领原先Symantec C/C++的开发团队快速进入 Java开发工具的领域。Eugene很快以当初Symantec C/C++的集成开发环境作为基础， 开始开发Java开发工具，这就是后来著名的Visual Café。 Symantec几乎是第一个介入Java开发工具的软件公司，又利用了Symantec C/C++的基 础，因此在1995年，当Java获得愈来愈多人的注意之后，Symantec也准备好了她的第 一个Java开发工具--Visual Café。1996年10月，Symantec赶在JDK 1.1之前正式推 出了Visual Café。虽然当时许多人批评Symantec为什么不等到JDK 1.1之后再推出， 以支持最新的JDK标准(因为当时的JDK 1.0x版本有许多的问题)，不过这些批评并 没有妨碍Visual Café的成功。 由于当时许多软件人员急于投入Java的学习行列，因此当Symantec推出了Visual Café 之后，立刻在市场获得了极大的成功。特别是在Java学习市场和教育市场，Visual Café几乎是以席卷市场的姿势迅速占据了Java开发工具第一名的地位，成为炙手可 热的产品，而Symantec公司也一扫在C/C++开发工具被挫败的怨气，再次成为开发工 具市场的领导厂商。 由于当时Microsoft对于Java采取敌视的态度，因此几乎不可能推出Java开发工具， 而Borland也还正陷于C/C++的苦战之中，尚未查觉到Java的潜力。至于另外一个死对 头Watcom则已被Sybase并购，无法在开发工具市场再成气候。这对于Symantec来说简 直是天赐良机，一个可以独打Java开发工具市场的绝佳机会。剩下唯一的威胁是SUN 要推出的Java开发工具。但是Symantec已经抢得市场先机，而且已经成为领先者，只 要好好的把握，就能够以逸待劳和SUN对战。在这个Java开发工具萌芽的阶段，Symantec 似乎是占了绝对的优势，不过很可惜的是接下来Symantec也接连犯了几个错误，逐渐 失去了取得的优势。 首先是当Visual Café推出之后，Eugene Wang便离开了Symantec自己开公司做生意 去了。这对于Visual Café有着相当大的影响，因为Symantec靠着Eugene Wang的技 术能力和眼光，才能够和Microsoft、Borland和Watcom在C/C++开发工具市场对抗； Eugene Wang又独具慧眼打造了第一个Java开发工具Visual Café。Symantec应该在 Visual Café获得初期的胜利之后再次借重Eugene Wang的功力继续攻城掠地，但是 Symantec居然让Eugene Wang离开，立刻少了开发工具掌舵的大将。 第二个错误是Symantec当初为了尽快推出Visual Café以抢占市场先机，因此集成开 发环境是使用C/C++语言撰写的。这造成了数项缺点，其一是由于使用了C/C++来撰写 可视化窗体设计家(Visual Form Designer)，因此程序员在设计时看到的可视化效果 和真正Java程序执行时的效果是有一些差异的；其二是为了维护Java的控制组件程序 代码和以C/C++撰写的可视化窗体设计家保持同步的状态，在可视化窗体设计家产生 的原始程序代码中内嵌了一些Visual Café控制卷标(Control Tag)。这些控制卷标 并不是Java的程序代码，只是为了可视化窗体设计家使用。如果程序员不小心修改或 是删除了这些控制卷标，就会造成Visual Café的可视化窗体设计家的失效。这是非 常严重的缺点，Symantec应该在Visual Café 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecf08c6519993074b23e362a25f1e0e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c30a0e03058701460ee2d9a33d753a/" rel="bookmark">
			VC&#43;&#43; 的串口通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VC++中有两种方法可以进行串口通讯。一种是利用Microsoft公司提供的ActiveX控件 Microsoft Communications Control。另一种是直接用VC++访问串口。下面将简述这两种方法。
一、Microsoft Communications Control
Microsoft公司在WINDOWS中提供了一个串口通讯控件，用它，我们可以很简单的利用串口进行通讯。在使用它之前，应将控件加在应用程序的对话框上。然后再用ClassWizard 生成相应的对象。现在我们可以使用它了。
该控件有很多自己的属性，你可以通过它的属性窗口来设置，也可以用程序设置。我推荐用程序设置，这样更灵活。
SetCommPort：指定使用的串口。
GetCommPort：得到当前使用的串口。
SetSettings：指定串口的参数。一般设为默认参数"9600，N，8，1"。这样方便与其他串口进行通讯。
GetSettings：取得串口参数。
SetPortOpen：打开或关闭串口，当一个程序打开串口时，另外的程序将无法使用该串口。
GetPortOpen：取得串口状态。
GetInBufferCount：输入缓冲区中接受到的字符数。
SetInPutLen：一次读取输入缓冲区的字符数。设置为0时，程序将读取缓冲区的全部字符。
GetInPut：读取输入缓冲区。
GetOutBufferCount：输出缓冲区中待发送的字符数。
SetOutPut：写入输出缓冲区。
一般而言，使用上述函数和属性就可以进行串口通讯了。以下是一个范例。
#define MESSAGELENGTH 100
class CMyDialog : public CDialog
{
protected: VARIANT InBuffer;
VARIANT OutBuffer;
CMSComm m_Com;
public:
......
}
BOOL CMyDiaLog::OnInitDialog()
{
CDialog::OnInitDialog();
m_Com.SetCommPort(1);
if (!m_Com.GetPortOpen()) {
m_Com.SetSettings("57600,N,8,1");
m_Com.SetPortOpen(true);
m_Com.SetInBufferCount(0);
SetTimer(1,10,NULL);
InBuffer.bstrVal=new unsigned short[MESSAGELENGTH];
OutBuffer.bstrVal=new unsigned short[MESSAGELENGTH];
OutBuffer.vt=VT_BSTR;
}
return true;
}
void CMyDiaLog::OnTimer(UINT nIDEvent) {
if (m_Com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c30a0e03058701460ee2d9a33d753a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7ad00d84e8cf980bd7cd306bd56483/" rel="bookmark">
			第三章 传奇的开始--Delphi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"是惊世之作的Delphi让Borland重新站了起来，没有当初的Delphi，就没有今日的 Borland！" "是Turbo Pascal诞生了Borland，但却是Object Pascal给予了Borland重生的机会！" 创造传奇故事的主角--Delphi 没有人会知道在两年后Borland C/C++会遭遇到这么大的失败，也没有人会预料到 Borland又会再次因为Pascal而东山再起。Borland奋斗史精彩的地方就在于每当似乎 要不支倒地之际，Borland的R&amp;D人员就会创造出一个明星级的产品来拯救Borland。 在其他和Microsoft对抗的软件公司纷纷消失的时候，Borland却一次又一次地站了起 来。"打不死的勇者"这句话贴切地形容了Borland的韧性。Borland靠Pascal起家，通 过C/C++绽放光芒，进而达到了巅峰的状态，随后又再次靠着Pascal浴火重生。Borland 这个从C/C++跌倒，再通过明星工具Delphi重回战场的过程可以说是惊心动魄，其中更 牵涉到了Borland两位创始人Philippe Kahn以及Anders Hejlsberg相继离开Borland 的密闻，也激活了Borland逐渐转型的历史轮轴。对于Borland来说，这段发展史可以 算是非常关键的里程碑，更重要的是，Delphi的崛起也在软件工具业界产生了巨大的 影响。Delphi不但激活了Windows平台上RAD战争的序幕，开启了Windows平台主从架 构的改变，同时也对组件技术做出了巨大的贡献。直到现在，Delphi创造的组件技术 仍然深深地影响了JavaBeans以及.NET的组件思想和技术，这在稍后的内文中读者可 以逐渐地了解。而故事的起源便在1993年左右…… Delphi的发展起源 当Borland以Turbo Pascal获得了成功，并且令Charles Petzold等人跌破眼镜之后， 到了1992/1993年的Borland Pascal 7.x，Borland似乎已经把传统的Pascal开发工具 发展到了极限，再往下还能做什么呢？Borland Pascal在销售了数百万套之后，程序 语言的焦点已经从Pascal转移到了C/C++，Borland Pascal无法继续快速成长，进而 转入了递减的状况，Borland必须做些新的东西才能够延续这条产品线。 当时Borland Pascal产品的Architect，即Anders Hejlsberg，眼看Microsoft Visual Basic的成功，觉得当时Visual Basic是比较初级的开发工具，是一个学习Windows 程序设计的好工具，但是尚无开发真正应用系统的能力。因此，Anders和Borland Pascal的小组决定展开一个规模前所未有的项目计划，这个开发工具项目在一开始便 设定了数个目标，希望能够达成并且超越Visual Basic。这些初始的目标是： ● 延续Borland Pascal的传统，提供一个快速编译的开发环境 ■ Borland/Turbo Pascal的高明之处便是由Anders使用汇编语言撰写的Pascal 编译器不但编译快速，而且能够产出极为有效率的机器码。当时的Visual Basic只是 解译器(Interpreter)，无法产生真正的执行机器码，因此在这一方面Borland决定要 远远地超过VB，但是Borland的挑战是要开发出一个编译速度能够媲美解译器速度的 新一代编译器。 ■ Anders另外一个重要的决定便是改善Borland Pascal程序语言，让这个新的 开发工具程序语言具备面向对象的功能。这在当时是非常重要的决定，因为不但需要 大幅修改编译器，也正式将Borland Pascal超越Pascal之父对Pascal定义的结构，让 Pascal拥有现代语言最新的功能。虽然这个决定有很大的因素是因为Borland决定通过 面向对象的方式建立新一代的Framework和组件架构，因此需要程序语言方面的支持。 不过，这在当时整个信息界对于面向对象技术还很陌生的阶段，的确是一个很大胆的 决策。这个程序语言的决策虽然可以吸引专业人士的激赏，不过也可能会让许多程序 员无法跨越这个障碍。后来的发展也证明了这一点。 ● 建立一个新的Windows Framework组件架构 ■ 当时VB使用的组件是VBX。不过VBX架构非常的复杂，只能使用在16位的环境， 并且在可视化拖曳设计方面又不是很方便。因此Borland希望在OWL之后建立一个全新 的Framework，这个Framework能够让程序员快速开发Windows应用程序，并且完整地封 装Windows操作系统中的对象。此外，Borland也希望定义一个标准的组件架构，让使 用这个开发工具的程序员能够通过Framework和组件架构来开发各种组件，包括可视 化和非可视化组件。这个Framework就是后来的VCL(Visual Component Library)。在 这方面，Borland做得非常成功。如果各位读者有VBX的经验，就会知道当时，Microsoft 定义的VBX规格简直是一团混乱，根本像是拼凑出来的东西。在当时开发VBX组件痛苦 不堪，后来Microsoft也彻底放弃了VBX。 ● 拖曳、可视化的开发环境 ■ Borland的想法是开发一个全新的集成开发环境，在这个开发环境中程序员可 以使用可视化的方法拖曳Framework的组件来设计图形界面，再在其中的编辑器中使用 面向对象程序语言来撰写应用程序。 这个开发工具项目的名称就是：Delphi！ Delphi的核心成员 在Delphi决定开工之后，Philippe Kahn还不放心动用太多的资源来开发这个产品， 因为当时Borland正集中所有的资源，希望能够打赢C/C++开发工具一役。因此 Philippe Kahn一开始只答应拨给Anders四个开发人员，先进行产品雏型的开发工作。 因此，Delphi在当时被笑称为像Apple计算机一样，是在地下室开发的。 当时加入Delphi开发小组的当然就包含了Anders，第二人是Chuck Jazdzewski。其中 Anders负责撰写新的Object Pascal编译器以及核心程序，而Chuck则负责设计Delphi 使用的组件Framework，即VCL。在经过了6个月的初始雏型阶段之后，当Anders把开 发的结果呈现给Philippe Kahn看时，Philippe立刻被它所吸引。因为当时在Borland 内部也希望为Borland C/C++开发一个类似这样能够以可视化拖曳方式开发应用系统 的C/C++开发工具。没有想到在短短不到一年的时间内，Anders已经从基本的构想开 发出了雏型产品。于是Philippe马上批准了这个产品的开发计划，并且投入研发资源。 许多后来举足轻重的人才便是从开发Delphi项目培养出来的。当时在这个项目中，各个 重要的部分分别由下面的重要人员负责： ● Anders Hejlsberg：编译器，Object Pascal程序语言，产品架构 ● Chuck Jazdzewski：Framework，组件架构设计/实现 ● Allen Bauer：集成开发环境的开发工具，Open Tools API ● Danny Thorpe：RTL (Run-Time Library) ● Zack Urlocker：产品开发方向，产品规划 有兴趣的读者可以打开下面的链接，这篇文章是由Danny Thorpe(现在是Borland .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df7ad00d84e8cf980bd7cd306bd56483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49a537efd2c50167a40da4d9d5f9d06/" rel="bookmark">
			第一章 Borland的诞生和发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直想写篇文章，讲述我个人在过去10多年来工作中经历的一些事情，以及这些日子 中那些我心目中的伟大的工程师们对于信息界的贡献。如果读者和我的年龄差不多， 那对于这些内容可能会更有兴趣，因为它们揭示了当时许多软件兴起和没落的过程以 及原因。虽然这些事情距离我们很遥远，但我相信许多人仍然对于背后的故事感兴趣。 即便没有经历过那段美好的回忆，那也可以把这些内容当成一个有趣的故事来读吧。 不过我想，更重要的是让我们一起认识一些伟大的人物，我个人对于其中的许多人都 非常佩服，也非常羡慕。甚至我常常在想，如果自己也有他们的环境，是不是也能够 和他们一样这么有成就呢？这些人对于以往都有着重要的贡献，对未来也仍将有着重 要的影响，因为他们都有一身不凡的技术。对于许多重要的人物，我都尽量收集了他 们的照片，让各位也能够认识这些优秀的工程师、杰出的人物。 当然，如果各位能够从这些内容中学习到失败的教训以及成功的经验，那么本书就更 有价值了。 Borland的兴起 记得大学时，第一个在PC上使用的软件就是SideKick。这个至今让我仍然无法忘记的 软件，也曾让许多人津津乐道，而Borland当时也就是以SideKick成为全球知名的软 件公司。不过Borland第一个奠立创业基础的软件，却是我大二用来交作业的Turbo Pascal，而Turbo Pascal也是我听到的第一个关于Borland的有趣的故事。 当年Philippe Kahn(Borland的创始人)和Anders Hejlsberg到美国创业时，便由Anders 以汇编语言撰写了Turbo Pascal的编译器，而Philippe则包办了Turbo Pascal其他的 部分。在这两位仁兄开发完Turbo Pascal之后，穷得快连登广告的钱都没有了。Philipp e 为了在Byte杂志(还记得这个著名的杂志吗？)刊登Turbo Pascal的广告，和Anders商 量了一个方法，那就是直接约Byte杂志的人到当时Borland的办公室讨论刊登广告的 事情。 当Byte的人到了Borland之后，Philippe、Anders和公司的助理小姐故意忙着接电话， 接受Turbo Pascal的订单，并且告诉Byte杂志的人等一下。过了一阵之后Philippe 才进入房间向Byte的人道歉，说他们的Turbo Pascal受到市场的热烈欢迎，订单源源 不断地到来，因此可能不需要在Byte杂志刊登广告了，接着Philippe向Byte的人展示 Turbo Pascal这个产品。由于在当时的机器中Turbo Pascal能够在极少的RAM中常驻 执行，又提供闪电般的编译速度，这立刻让Byte杂志的人当场震惊。凭着专业知识和 丰富的经验，Byte的人立刻知道这将是一个革命性的软件，因此马上希望Philippe能 够在Byte杂志刊登Turbo Pascal的广告，并且愿意以半价刊登。当然，Philippe也立 刻爽快地答应了，于是一个革命性的软件Turbo Pascal终于在Byte杂志刊登出来了。 当时售价49.99美元的Turbo Pascal立刻为Borland带来了大量的财富，Turbo Pascal 也马上成为PC上除了基本的Basic之外最畅销的开发工具，由此正式揭开了Borland影 响PC开发工具近20年的历史的序幕。 Turbo Pascal是由Anders Hejlsberg亲自开发的，并且和Philippe Kahn谈好的条件 是Borland每卖出一套Turbo Pascal，Anders便从中抽取一份版权费。由于当时软件 的价格不算便宜，能够写编译器的人更是少之又少，所以编译器工程师通常都能够获 得优厚的报酬。因此当时Anders Hejlsberg在完成了Turbo Pascal、并且和Philippe Kahn谈好了合作条件之后，Anders理所当然地认为一套Turbo Pascal会定价数百元 美金，因为这不但是当时一般编译器的价格，而且Turbo Pascal还内含了一个开发环 境和编辑器(Editor)，这是当时许多工具没有提供的。 没有想到极具商业头脑的Philippe Kahn了解到：如果把Turbo Pascal定价在数百美 金，那么Turbo Pascal可能只会卖出数百到数千套，无法冲出大量的销售额。因此， Philippe Kahn 以极大的勇气，瞒着Anders Hejlsberg只把Turbo Pascal定价为49.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e49a537efd2c50167a40da4d9d5f9d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fbc91e3a9623923c168fc18296ae542/" rel="bookmark">
			Visual Basic串口通讯调试方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现有电子秤一台，使用串口与计算机进行通讯。编写VB程序来访问串口，达到读取电子秤上显示的数据。该电子秤为BE01型仪表，输出为RS-232C标准接口，波特率为300-9600、偶校验、7个数据位、2个停止位。所有字符均发送11位ASCII码，一个起始位。在VB中与串口通讯需要引入控件MSComm串口通讯控件（在Microsoft Comm Control 6.0中）。具体程序如下：控件简称：MSC Dim Out(12) As Byte '接收var中的值 Dim var As Variant '接收MSC.input中的数值 Dim nRece As Integer '计算MSC.inputbuffer的个数 Dim i As Integer, j As Integer '随即变量，计算循环 **************************************************************************** Private Sub Form_Load() ClearText With MSC .CommPort = 1 '设置Com1为通信端口 .Settings = "9600,E,7,2" '设置通信端口参数 9600赫兹、偶校验、7个数据位、1个停止位.（这里需要进一步说明的是：.Setting=”BBBB,P,D,S”。 含义是：B：Baud Rate（波特率）；P：Parity（奇偶）；D：Data Bit；S：Stop Bit） .InBufferSize = 40 '设置缓冲区接收数据为40字节 .InputLen = 1 '设置Input一次从接收缓冲读取字节数为1 .RThreshold = 1 '设置接收一个字节就产生OnComm事件 End With End Sub **************************************************************************** Private Sub ClearText() Text3.Text = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fbc91e3a9623923c168fc18296ae542/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/133/">«</a>
	<span class="pagination__item pagination__item--current">134/134</span>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>