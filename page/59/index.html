<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ac1c57697673371ccc8bb77fb0721c/" rel="bookmark">
			Kotlin 3. Kotlin 特殊符号的用法：双感叹号!!，问号?，双冒号::
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一起来学Kotlin：概念：3. Kotlin 特殊符号的用法：双感叹号!!，问号?，双冒号:: 这里介绍 Kotlin 特殊符号的用法，包括：双感叹号!!，问号?，双冒号::。
文章目录 一起来学Kotlin：概念：3. Kotlin 特殊符号的用法：双感叹号!!，问号?，双冒号::1. 双感叹号!!以及问号?用法2. 双冒号::Reference 1. 双感叹号!!以及问号?用法 在Kotlin中!!跟?都是用于判断空参数异常的。?.意思是这个参数可以为空,并且程序继续运行下去，!!.的意思是这个参数如果为空,就抛出异常。
在Kotlin中
val nullClass: NullClass? = null nullClass?.nullFun() 翻译成Java
NullClass nullClass = null; if (nullClass!=null) { ullClass.nullFun(); } 在一开始的时候我们声明了一个类,并且在类名后面加了一个? 意思就是这个类可以为空,然后在下面用到这个类里面的一个方法时又加了一个问号,意思就是,当程序运行到这一行时,如果这个参数为空,就跳过这一行,程序继续执行下去。
所以?.的用法就是相当于Java里的if()判断null。
一般?.的用法是：在新建一个参数的类名后面加一个? 表示这个参数可以为空。还有就是在用到这个参数的时候后面加? 表示空参数就跳过并且程序继续执行。
而!!只用于用到这个参数的时候在后面加!!,表示空参数就抛出异常。
在Kotlin中
val nullClass: NullClass?=null nullClass!!.nullFun() 翻译成Java
NullClass nullClass = null; if (nullClass!=null) { nullClass.nullFun(); }else { throw new NullPointerException(); } 在第二行参数后面加个!!,意思就是当程序执行到这行,判断这个参数如果是空参数,就抛出异常。
所以!!.的用法就是相当于Java里的if()else()判断null。
2. 双冒号:: Kotlin 中双冒号操作符表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。先来看一下例子：
fun main(args: Array&lt;String&gt;) { println(lock("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1ac1c57697673371ccc8bb77fb0721c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cea3ae5336f090f1f7125911c8abb01/" rel="bookmark">
			openvas介绍及部署安装 - kali Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenVas简介 OpenVas（Open VulnerabilityAssessment System）是一款开源的漏洞评估系统，是Nessus项目分支，它是一款应用级别的漏洞扫描器，用于检测并管理目标网络或主机漏洞，它的评估是基于其积累的数万个漏洞测试脚本，OpenVas最早有是一个客户端程序，目前官方已经不提供了。现基于B/S(浏览器/服务器)架构进行工作，执行扫描任务并提供扫描结果。
官网：http://www.openvas.org/
OpenVas架构 OpenVasServer为核心部分，负责为OpenVas Client提供登录，查询，任务下发等功能，包括可随时更新整套扫描插件库，用户可通过该功能保持与官方插件库进行同步更新，插件库也可离线升级。同时OpenVas Server负责执行通过OpenVas Client发起的漏扫任务请求，对指定的主机或网络设备进行漏洞扫描并生成漏洞报告供用户查看。
OpenVAS Client：进行扫描任务配置，结果回收，漏扫报告查看。
OpenVAS Server: 实现基本的扫描功能。
OpenVAS Plugins：存储数万个网络漏洞测试脚本插件。
插件更新：目前有2种插件：
OpenVas NVT FEED 免费插件。
Greenbone Sec. FEED 商业插件
OpenVas服务 openvas-manager ：负责与客户端 Greebone 程序通信，完成扫描任务、检测报告的提交 等工作，默认端口为9390
openvas-scanner ：实际执行扫描的主服务，默认端口为 9391 gsad：负责提供 Web 访问界面，默认监听地址为 127.0.0.1，端口为9392
openvas-administrator：负责与openvas-manager qsad通信，完成用户和配置管理等操作，默认监听地址为127.0.0.1，端口为 9393。
OpenVas Kali Linux部署 部署准备
宿主机：Windows 10 企业版
虚机软件：Oracle VM VirtualBox-6.1.16-140961-Win或者更高版本
环境：kali-linux-2022.2-virtualbox-amd64.ova
开始部署
首先在官网（https://www.kali.org/get-kali/）下载Oracle VM VirtualBox对应的虚拟环境。
安装Oracle VM VirtualBox-6.1.16-140961-Win。
安装环境，选择管理-&gt;导入-&gt;导入虚拟电脑，选择第一步下载虚拟环境，点击下一步，安装虚拟环境。
安装完成后，启动虚拟环境。
输入默认用户名及密码，kali/ kali
登录系统后进入后端控制台并切换root用户权限。
命令：sudo –i 回车后输入kali，完成用户切换。
进入系统后首先进行系统更新，把依赖包升到最新，以免后续安装出现问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cea3ae5336f090f1f7125911c8abb01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/069cd3de2d729fc15e1f632f47a6a2f6/" rel="bookmark">
			KEITHLEY吉时利2410数字源表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概览
Keithley 2410 高压源表专为需要紧密耦合源和测量的测试应用而设计。Keithly 2410 提供精密电压和电流源以及测量功能。它既是高度稳定的直流电源，又是真正的仪器级 5-1/2 数字万用表。电源特性包括低噪声、精度和回读。万用表功能包括高重复性和低噪声。结果是一个紧凑的单通道直流参数测试仪。
Keithley 2410 高压源表是一款 20W 仪器，可提供和测量 ±5µV（源）和 ±1µV（测量）至 ±1100V 的电压以及 ±10pA 至 ±1A 的电流。Keithley 2410 具有更高的电压源范围，是电阻器和电压系数测试、变阻器和高压二极管（包括开关、齐纳二极管、RF 二极管和整流器）的绝佳选择。Keithley 2410 高压源表能够在提供 1100V 电压的同时测量 20mA 电流，提供对这些设备进行精密测试所需的额外分辨率。
Keithley 2410 高压源表的特性和规格包括：
五合一仪器： 电压源当前来源电压表电流表欧姆表源和汇（4 象限）操作0.012% 的基本测量精度，5½ 位分辨率2、4 和 6 线远程 V 源和测量传感1700 个读数/秒，4½ 位，通过 GPIB通过/失败比较器用于快速排序/装箱可用的高速传感引线接触检查功能用于自动化/处理器/探测器控制的可编程 DIO 端口标准 SCPI GPIB、RS-232 和 Keithley Trigger Link 接口Keithley LabTracer 2.0 IV曲线追踪应用软件（下载）一般特征： 负载阻抗：稳定至 20,000pF（典型值）共模电压：250V DC共模隔离度：&gt;10 9 Ω,&lt;1000pF超量程：量程、源和测量的 105%输入/输出和检测端之间的最大压降：5V最大检测引线电阻：额定精度为 1MΩ感应输入阻抗：&gt;10 10 Ω保护偏移电压：&lt;150µV，典型值源输出模式： 固定直流电平内存列表（混合功能）楼梯（线性和对数）内存缓冲区：5,000 个读数 @ 5 位（两个 2,500 点缓冲区） 包括选定的测量值和时间戳备用锂电池（3 年以上电池寿命）源内存列表：最多 100 点可编程性：IEEE-488 (SCPI-1995.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/069cd3de2d729fc15e1f632f47a6a2f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b91652596e09dc0290ed1dd66f2cec/" rel="bookmark">
			基于ruoyi框架增加查看数据功能的定制修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ruoyi框架在默认情况下只提供了添加和编辑页面，并没有提供查看功能的页面和相关功能，这样在一些特殊的场景下是不满足业务需要的，增加数据查看功能包括以下步骤，下面以框架自带的通知公告为例进行说明：
1. 添加查看页面 查看页面，可以从编辑页面拷贝过来，进行一定的定制修改即可。
对于内容中存在html需要页面直接解析的，可以使用th:utext进行处理。
&lt;div class="form-group"&gt;	&lt;label class="col-sm-2 control-label"&gt;公告内容：&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;div th:utext="*{noticeContent}"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 这里的noticeContent内容可以包括文字和图片，只要符合html编码规则都可以。注意这里只能使用th:utext，如果使用th:text，则只能解析文本，不会解析其中的html标签。
function submitHandler() { if ($.validate.form()) { var sHTML = $('.summernote').summernote('code'); $("#noticeContent").val(sHTML); // $.operate.save(prefix + "/edit", $('#form-notice-edit').serialize()); $.modal.close(); } } 默认的提交保存修改为关闭窗口即可。 2. 添加controller方法 /** * 查看公告 */ @RequiresPermissions("system:notice:view") @GetMapping("/view/{noticeId}") public String view(@PathVariable("noticeId") Long noticeId, ModelMap mmap) { mmap.put("notice", noticeService.selectNoticeById(noticeId)); return prefix + "/view"; } 这个基本上，也可以从编辑拷贝过来，修改一下即可。
3. 在列表页面添加查看 // 添加权限 var viewFlag = [[${@permission.hasPermi('system:notice:view')}]]; // 添加url var options = { url: prefix + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34b91652596e09dc0290ed1dd66f2cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb43d8ff6664008e033562aa76b22e1/" rel="bookmark">
			C语言判断素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们先明确什么数是素数：素数是指一个除0和1以外的自然数它的因数只有1和它本身。
例如3=1x3 只有1和它自己两个因数所以是素数 4=1x4=2x2所以4不是素数。
我们知道了素数的概念之后我们就针对这个概念进行编写代码
代码如下：
#include&lt;stdio.h&gt;
int main() {
int m;
int i;
printf("请输入一个自然数:");
scanf("%d",&amp;m);
if(m==0||m==1)
{
printf("这个数不是素数"); return 0;
}
for(i=2;i&lt;m;i++)
if (m%i==0) break;
if(i&lt;m)
printf("这个数不是素数"); else printf("该数是素数\n");
return 0;
}
我们考虑到用户可能会输入0和1这种情况所以这两种情况是要单独去考虑，其余的就是按照for循环进行从2到1去逐次寻找他的因数，如果这个因数比他小那么就不是素数反之就是素数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a948977d45473d317798cc0e8ee936a5/" rel="bookmark">
			mac通过brew安装mysql 5.7版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mac通过brew安装mysql 5.7版本 # 先搜索可安装版本 brew search mysql # 安装mysql brew install mysql@5.7 # 安装 brew 服务(大部分不用执行) brew tap homebrew/services # 加载和启动mysql服务 brew services start mysql@5.7 # 检查mysql服务是否已加载 brew services list # 强制链接5.7版本 brew link mysql@5.7 --force # 验证安装mysql 是否成功 mysql -V # 初始化密码 更改你自己密码 mysqladmin -u root password '你的密码' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced91eba4a5faad8166c761bd42e0c5c/" rel="bookmark">
			springBoot的event事件发布/监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先定义一个Event父类 package com.felix.event; import org.springframework.context.ApplicationEvent; public class BaseEvent extends ApplicationEvent { public BaseEvent(Object source) { super(source); } } 自定义的Event类继承BaseEvent父类 package com.felix.event; /** * 自定义的Event */ public class SelfEvent extends BaseEvent{ public SelfEvent(Object source) { //可以做点事情 super(source); //可以做点事情 } } 发布消息 package com.felix.event.publish; import com.felix.event.SelfEvent; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationContext; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; import java.util.concurrent.CompletableFuture; @Service public class SelfHandler { @Autowired private ApplicationContext applicationContext; public void handler(){ for(int i = 0;i &lt; 1000; i ++){ Map test = new HashMap(); test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ced91eba4a5faad8166c761bd42e0c5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468b0f58ad2b068de2884b7cb3197325/" rel="bookmark">
			ValueError: Shapes (None, 1) and (None, 43) are incompatible
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ValueError: Shapes (None, 1) and (None, 43) are incompatible 导读
本文意在提供解决此类方法的一个方法，仅参考，并非完全适用于你们所处困境，希望这篇能帮到你。
代码如下
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy']) epochs = 15 # batch_size=64/32 history = model.fit(X_train, y_train, batch_size=32, epochs=epochs, validation_data=(X_test, y_test)) 本人报错如下
分析得出：问题出在 损失函数的选择，因为我的label编码是数字编码，若采用categorical_crossentropy，则需要在image_dataset_from_directory中设置label_mode=‘categorical’。默认情况下，image_dataset_from_directory方法假定标签编码为整数(label_mode=‘int’)。
通常CategoricalCrossentropy是适用于目标是 one-hot 编码，而SparseCategoricalCrossentropy才是适用于数字编码目标。
我采用的解决方法为重新选择损失函数 SparseCategoricalCrossentropy
1.sparse_categorical_crossentropy
label数组中的数据全为0-9，表示十种分类。
2.categorical_crossentropy
当labe使用one-hot编码时，使用categorical_crossentropy。例如 伦敦 [1, 0, 0, 0, 0, 0]，巴黎[0, 1, 0, 0, 0, 0]，纽约[0, 0, 1, 0, 0, 0]…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0337bbc1daf8f439f130fef1f654baa8/" rel="bookmark">
			史上最详细易懂的ES6模块化语法（重点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于初次学习ES6的小伙伴来说，ES6的模块化语法是一个重点，在没有模块化之前，前端js代码有一下三句话
1、私密不漏
2、重名不怕
3、依赖不乱
一、接下来先演示在没有模块化之前，这个“私密不漏了”，重名的话就乱套了，依赖又乱了该怎么解决。
在没有ES6模块化之前，我们实际开发中，会有许多js文件，在这么多的js文件中有重名的方法，那调用起来不乱了套吗，我们怎么利用ES6模块化进行一下优化呢？ ES6模块化有一个问题，就是对浏览器兼容性的问题，但是我们可以通过webpack进行解决，该工具可以将ES6转换成ES5。这里webpack不做详细介绍。
我们在编辑器中，建立一个大文件夹，文件夹中分别存入三个js文件，分别为A.js、A.js、C.js，
我们分别在三个js文件中写入各自的方法。
A.js中的方法
在上面的A.JS文件中，我们写入了两个方法分别为A1、A2 但是我们发现了一个问题，就是有些方法有重复的现象，在实际开发中，某个方法在某个业务需求中用到很多次，为此，我们需要将重复的代码封装成一个公用的函数 。
在上述代码中，A.js创建的目的，就是希望将来A1这个函数，在页面中在创建A1这快的布局， A2这个函数，在页面中在创建A2这快的布局。
上面代码这样写的目的是想告诉阅读者们，在上述代码中的A1与A2方法，我们需要在test.html页面中使用 ，A1和A2方法给外面的test.html使用是有布局需求，但是a_common方法只是给A.js中内部使用的，（或者说，A.js中的的A1方法与A2方法共用了一段相同的代码，但是这个相同的代码，我们没必要在A1和A2中都写，所以就封装一个函数，然后再调用这个函数）对于A.js想表达的是，将内部的A1与A2方法给外面的test.html使用布局，而a_common方法不想给外面使用，a_common这个方法是A.js内部使用的方法，对于页面布局没有意义。在test.html页面中我们引入标签。代码如下图所示：
在控制台打印的结果如下
a_common这个方法属于A.js文件中封装的方法，只是供应给该文件中的A1与A2方法调用的。但是我们在书写上述代码中，引入了A.js文件之后，调用A1与A2方法后，也把a_common这个方法给调用了，实际上，我们的a_common这个方法不想被外部使用，这个问题在没有模块化之前是不能解决的。在实际开发中，js代码不是同一个人写的，这个时候如果别人使用了某个封装的js代码后，并且做修改了，如果此时再调用A1与A2方法那么一定会出现问题。
二、模块化之前重名的问题
我们在test.html中引入B.js文件，假设A.js与B.js中的代码不是同一个人写的，甲开发人员在A.js文件中定义了一个test（）方法，乙开发人员在B.js中也定义了一个test()方法.详情代码片段如下图所示：
A.js中的代码
B.js中的代码
我们接着在test.html文件中 引入B.js文件。并且调用test（）方法。
打印结果没有将A.js中的test方法打印出来，出现这样的结果，是由于，html页面代码加载的时候，代码是从上至下加载的 ，先引入的A.js文件，接着又引入B.js文件,后者中的test（）将前者里面相同的给覆盖掉了造成的。打印结果如下图所示：
上面的案例所演示的就是在非模块下，不同js文件中出现同名函数的问题，一单出现重名，后者必定出现一系列问题。
接下来还有一个需求，在js文件夹中还有一个js文件，叫做C.js。在C.js中希望使用一下A.js中的某个方法或者B.js中的某个方法。
在test.html文件中调用C.js文件
调用之后打印结果如下
C.js会将前面的js文件覆盖掉。
注意：在test.html文件中，如果将C.js文件放在最上面，那么 打印结果将会报错，这有由于，代码执行过程中，首先加载了C.js文件，但是C.js文件被调用的时候，A.js中的A_C()方法与B.js中的B_C()方法还没有加载，造成未定义的现象。
上面的案例中，在js文件夹中，只有三个js文件，但是在实际开发中，一个js文件夹中，有多个甚至上百个js文件，而且某个js文件需要依赖其它js文件进行加载，那么问题就会显现出来。（在非模块化下开发将会显现出依赖混乱这样的问题）
为了解决前面我们铺垫的内容情况（非模块化下开发，出现的一系列问题），我们接下来讲解ES6模块开发。
ES6模块化规范 es6模块化规范规定，在js文件当中，如果用户想将某个函数给别的js文件依赖使用，那么就需要在当前的js文件中，将其中的某个函数给“暴露”出来，使用关键字“export”,翻译成中文为导出的意思，在案例中，假设我们想将A.js中的A1() 、A2() 、test()方法给暴露出去。我们需要在当前js文件最下方书写 export{
A1(),
A2() ,
test()
}
详情代码块如下图所示：
暴露出去之后，我们在test.html中导入使用，此时我们就不需要像之前一样使用&lt;script src=" "&gt;&lt;/script&gt;了，其导入语法为 import{暴露出方法1、暴露出方法2、暴露出方...} from './././' (from './././')为导出方法的所属js文件路径。详情导入操作代码片段如下图所示：
模块化开发解决重名问题
上面我们案例演示过，在非模块化下开发如果有相同的函数名，后者会将前者给覆盖掉。在ES6模块下这以问题将迎刃而解。
在B.js文件中，同样也要一个test()函数，我们也把其中的test()方法也暴露出去，那么将会出现什么样的结果呢？代码演示如下图所示：
在test.html中，将B.js中暴露的test方法导入
运行结果
在浏览器控制台报错，提示说明说test早已经存在，这究竟是怎么回事呢？
我们简单的举个例子，阅读者就会明白了，这个test方法就相当于一个商品品牌，我们在A商店购买了一瓶农夫山泉牌矿泉水，然后又在B商店购买了 一瓶农夫山泉牌矿泉水，此时两瓶矿泉水的包装样式一模一样。如果两瓶水被两个人打开喝过后，混在一起将无法区分分别为谁的水，假设其中一个人将矿泉水的标签撕掉此时就好区分了，同样滴，为了解决重名问题，我们也可以分别为导入的两个test方法各做个标记，详情代码块如下图所示：
三、模块化下开发，解决依赖不乱等问题 在非模块下开发，如果某个js文件需要依赖其它的js文件，必须通过&lt;script&gt;&lt;/script&gt;先引入被依赖的js文件，这样当前的这个依赖的的js文件才能够正常使用。但是使用模块化下开发，就解决了这一问题，开发者可以将&lt;script&gt;&lt;/script&gt;引入放入任何位置。代码块如下图所示：
在当前依赖的js文件中，先导入被依赖的方法，然后再当前依赖的js文件中并执行被依赖的方法。
在test.html中引入C.js文件，无需先引入A.js和B.js了，模块化下开发必须这样写&lt;script src = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0337bbc1daf8f439f130fef1f654baa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199b8876fe1c71867d571c54598a81d5/" rel="bookmark">
			JavaScript 严格模式(use strict)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript严格模式，又称为"use strict"模式，是JavaScript语言的一种更严格的运行模式。严格模式规定了一些限制，用于防止程序员犯一些常见的错误，以保证代码的正确性和安全性。
在JavaScript严格模式中，不允许使用未声明的变量，也不允许删除变量、函数、参数或对象的属性。同时，还有一些其他限制，例如：
不能使用eval()或arguments.callee不能使用重复的参数名不能使用与保留字相同的变量名 在JavaScript代码中启用严格模式非常简单，只需在代码的第一行添加"use strict"语句即可，如下所示：
'use strict'; var x = 10; 除了在整个代码文件中启用严格模式外，也可以在函数内部启用严格模式。这是非常有用的，因为有时只需要在某个特定的函数中启用严格模式，而不是整个代码文件。如下所示：
function myFunction() { 'use strict'; var x = 10; } 在实际工作中，启用JavaScript严格模式是一个好的习惯。它可以帮助程序员避免一些常见的错误，提高代码质量。在使用严格模式时，需要注意它的限制，以确保代码正确运行。另外，需要注意的是，严格模式仅在最新版本的浏览器中支持，因此在使用严格模式前需要考虑兼容性问题。
那么，如何使用JavaScript严格模式呢？我们可以在代码的第一行加入 "use strict"，就可以启用严格模式。下面是一个简单的示例：
'use strict'; var x = 10; x = "hello"; // Uncaught TypeError: x is not a string 在上面的代码中，第一行启用了严格模式。在严格模式下，当尝试将数字类型的变量x赋值为字符串类型时，会抛出一个错误。
还有另外一种启用严格模式的方法，就是在函数内部使用：
function myFunction() { 'use strict'; var x = 10; x = "hello"; // Uncaught TypeError: x is not a string } 在上面的代码中，只有myFunction内部的代码使用了严格模式。因此，只有在调用myFunction时，代码才会在严格模式下运行。
总的来说，JavaScript严格模式是一种很好的实践，可以帮助程序员避免一些常见的错误，并提高代码质量。如果您在项目中需要使用严格模式，请考虑启用它，以确保代码质量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224ae2602cc86a151f0181f0aba1e35d/" rel="bookmark">
			chumpy&#43;py3 报错 numpy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我是py39 cuda11的配置，之前听说chumpy 库只有py2的，我想着9023了应该出py3的兼容了吧，
然后直接pip install chumpy ，装的是0.70的chumpy，然后就报错
cannot import name 'bool' from 'numpy' (/home/xxx/miniconda2/envs/xxx/lib/python3.9/site-packages/numpy/__init__.py)
我还没细想这个Bug,觉得是chumpy的问题，然后就卸载了0.7的，装了0.65的chumpy,事实证明0.65的chumpy还是针对py2的，所以代码上有很多不兼容的问题，print啥的，改来改去非常麻烦。然后我再看了下这个bug，应该是numpy的问题，我看了下自己的numpy是1.25的，然后看了下这个项目的environment.yml 写的是1.23的numpy，遂装过numpy，然后就没有再出现上面的bug
顺带一提, 安装pytorch3d最简单方法是
git clone https://github.com/facebookresearch/pytorch3d.git cd pytorch3d &amp;&amp; pip install -e . 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e25b96316972d4e67fd1e64a90139d0/" rel="bookmark">
			利用钉钉机器人Webhook向钉钉群推送告警通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、配置钉钉群
1、新建一个接收通知的钉钉群
如下图，创建一个接收通知的钉钉群
选择项目群，点创建
输入群名称，右侧选择群成员，最后点击右下角的创建
2、对群进行设置
点群右上角的设置按钮
点击 “智能群助手”
点 “添加机器人”
点 添加机器人 最右边的 “+” 加号 选最后的 自定义 通过Webhook接入自定义服务
点 添加
输入机器人名字，安全设置里输入自定义的关键字
注意注意：这个自定义关键字必须输入，而且等下在代码里发送消息时，消息的内容体里，必须包含这个关键字，否则钉钉会返回 消息发送失败
点 完成
完成后，会出现下图的画面，点击 复制，把生成的 Webhook复制一下，最后点击 完成
完成后，会进入下边的页面
到这里，钉钉群的配置就完成了
二、Java代码的编写
钉钉群配置好，拿到Webhook的值后，就可以在java代码里调用钉钉的消息推送了
下面贴一下代码
import lombok.extern.slf4j.Slf4j; import java.util.HashMap; import java.util.Map; /** * @描述 异常告警钉钉通知 * @创建人 anan * @创建时间 2023/1/30 14:03 */ @Slf4j public class SendDDMessage { //这里就是刚才拿到的Webhook的值 public static final String DING_DING_TOKEN = "https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"; public static void sendDDMessage(String msg){ //钉钉的webhook //请求的JSON数据，这里用map在工具类里转成json格式 Map&lt;String,Object&gt; json=new HashMap(); Map&lt;String,Object&gt; text=new HashMap(); json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e25b96316972d4e67fd1e64a90139d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a561704dfff2bf2f0d24f7bd9be4cb/" rel="bookmark">
			Git 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Git是什么
Git是一个开源的分布式版本控制系统，用于敏捷高效地处理从小到非常大的项目版本管理。是Linus Torvalds为了帮助管理Linux内核开发而设计开发的开放源码的版本控制软件。Git不仅仅是个版本控制系统，也是一个内容管理系统（CMS）、工作管理系统等。
2 Git与SVN区别
由于设计理念的差异，Git和SVN有着比较大的差异。这里只介绍一些的使用上比较明显的差异：
1. Git是分布式的，SVN不是。这是Git和其他版本控制系统差异的根源之一，表现在SVN有一个Server作为中心资源点，而Git所有资源点的地位都是相同的，如下图所示：
SVN和Git差异对比图
2. Git是按照元数据的方式存储，而SVN是按照文件存储。类似SVN把所有资源的控制信息保存在 .svn 这个隐藏文件夹下，Git则保存在 .git 隐藏文件夹下，这个文件夹下存储了标签、分支、版本记录等等信息，相比SVN这个文件夹非常大。
3. 一个项目的多个分支，对于SVN来讲是多份文件，对于Git来讲是一份文件。Git 与SVN的分支差异比较大。对于SVN来讲，不同的分支是同一份文件的拷贝，每次新建分支需要消耗很多的资源完成拷贝，同时分支太多会导致占用太多的硬盘空间。而Git的分支可以看作是同一份文件的另一个索引，这就让Git创建分支的开销非常小，并且再多的分支也是使用这一份文件，只占用这一份文件的硬盘空间。
4. Git的版本控制是不依赖网络的。Git的提交是不需要网络的，因为是提交到的本地的仓库之中，同步到远程仓库则是需要网络的。SVN的提交则是依赖网络的。
5. Git相较于SVN更加安全。SVN的Server如果出现问题，那么版本控制数据就会全部丢失。而对于Git而言，只要有一台保存Git仓库数据的机器幸存下来，版本控制数据就可以快速的恢复。
3 Git 优点
1. 运行速度快。Git执行命令的速度很快，特别是在进行分支操作的时候，速度相比于SVN更是有巨大的领先。
2. 离线操作。Git提交没有任何的限制，不需要依赖网络。
3. 撤销错误操作。几乎所有人都会犯错误，比如忘记包含一个改动，需要撤销一个完整的提交等，Git可以完美的恢复，因为Git几乎很少真正的删除数据。
4. 更高的自由度。Git的功能非常的多，核心的功能则是分支，围绕着分支，选择适合项目规模的分支模型可以更加科学的管控项目代码的质量，方便产品进行迭代。
5. 流行。现在越来越多的公司和开源项目都在使用Git。拥有一个大型的用户群体是有很多的优势的，比如大量的教程、工具和服务等。
4 Git和GitHub与GitLab的关系
一提到Git，就会有很多的人脱口而出GitHub，但是这两个并不是一个东西。
Git是一个分布式的版本控制系统，是用来进行版本管理的。
GitHub是一个面向开源以及私有的项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。GitHub也是目前全球最大的代码托管平台，上面有很多开源的项目，可以帮助程序员之间相互学习和交流。
GitLab是一个基于Git实现的在线代码仓库软件。可以搭建一个类似于GitHub一样的仓库，拥有完善的管理页面和权限控制。一般用于企业内部搭建Git私服。我们公司也是用的GitLab搭建了一个私服。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7cfae79953bf4e1912c41bd617ecdc/" rel="bookmark">
			java毕业设计——基于java&#43;JSP&#43;Tomcat的农产品销售管理系统设计与实现（毕业论文&#43;程序源码）——农产品销售管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java+JSP+Tomcat的农产品销售管理系统设计与实现（毕业论文+程序源码） 大家好，今天给大家介绍基于java+JSP+Tomcat的农产品销售管理系统设计与实现，文章末尾附有本毕业设计的论文和源码下载地址哦。需要下载开题报告PPT模板及论文答辩PPT模板等的小伙伴，可以进入我的博客主页查看左侧最下面栏目中的自助下载方法哦
文章目录：
基于java+JSP+Tomcat的农产品销售管理系统设计与实现（毕业论文+程序源码）1、项目简介2、资源详情3、关键词：4、毕设简介5、资源下载 1、项目简介 本文论述了基于JAVA、Web的农产品销售管理系统开发的目的及意义，目的是为了农产品资源的合理利用和物资的充分交流，有些地方富余而卖不出去，有些地方却吃不上。本系统搭建一个类似网上商城一样的网站系统，其中会用到 MyEclipse、MySQL、JSP等之类的网络工程技术，本系统分为前台销售系统和后台管理系统，前台会员系统，为会员提供：会员注册、购物车、顾客留言、商品浏览、订单管理等主要功能。后台管理系统，为管理员提供：农产品订单管理、农产品的商品管理、农产品的商品分类管理、农产品的特价商品管理、会员信息管理、系统用户管理等优质服务。 2、资源详情 项目难度：中等难度
适用场景：相关题目的毕业设计
配套论文字数：25133个字65页
包含内容：整套源码+完整毕业论文+答辩PPT+任务书+辅导视频+运行截图
3、关键词： JSP；农产品；网上商城;MySQL 4、毕设简介 提示：以下为毕业论文的简略介绍，项目源码及完整毕业论文下载地址见文末。
前言
省略
1 课题简介
1.1 选题背景
省略
1.2 课题的意义
省略
1.3 系统目标
省略
2 可行性研究
省略
2.1 技术可行性
于Web的农产品销售管理的策划是靠Web服务器以及浏览器来完成的。然后应用Java Web技术，使用方便、快捷、应用性强大的、好用MyEclipse开发工具软件来设计完成整个系统，建立Web项目，用Java语言编写程序，用JSP（Java版的HTML）设计丰富多彩、美轮美奂的动态界面，本系统使用的是 MySQL数据库。在学校上学期间，老师花功夫讲过这门语言并且让本人们编写了好些相关程序以及做过好些课程设计，对本次毕业设计有一定的经验和把握，而且如果有问题，指导老师就会帮本人们讲解，所以，本人认为，此次毕设在技术上是可行的。
2.2 经济可行性
省略
2.3 操作可行性
省略
2.4 法律可行性
省略
3 需求分析
3.1 系统需要解决的主要问题
省略
3.2 系统具备的基本功能
农产品销售管理体系的成功是靠两个重要部分完成的，他们真的很重要，前台用户销售系统要求基本功能都实现，如登录、注册、购买、下订单、修改密码、查订单。在此基础上如果能体现界面美观、大方、美轮美奂等，
（1）、网站前台
作为用户上网浏览能瞬间看到的功能界面，首先，功能全面、且简洁易懂好操作，让用户能够方便快捷的使用本系统，进而爱上本系统并吸引更多的用户前来，让他们也能够了解记住本系统的上帝是谁—是他们。为上帝们直接展示的功能界面主要包括商品信息按类别、名称搜索，用户注册成会员，会员留言，购物等。上帝们进入本系统首面就能看到所有的数据流，游客和任何人都可以查看询问。上帝们注册表级进入后就可以拥有权限做他们本人可一直在做的事了。
（2）网站后台
作为拥有特殊权利的人群的操作界面，理应没有注册界面，为了方便拥有特殊权利的人群对系统的管理，提供了方便的模块化管理模式。后台系统模块主要分为是管理模块、会员（在前台注册的用户）的管理模块、商品的分类管理模块、商品本身是管理模块、订单（用户购买东西的凭证）的数据流等。
3.3 数据流图
3.4 数据字典
数据字典是看有信息和有关资料的团体，数据字典的作用是在软件的分析和设计过程中提供关于数据的描述信息[1]。它让人们有了关于数据最重要直观的野望。
3.4.1 数据存储
数据存储是相应资料停歇或看管的住处。本人们常常把它堆放在文献中、资料数据库中、缓存池中、内存中包括但不限于话会话session、二级缓存池、表，下面就是一些本系统的数据表，也是本系统的相关资料“住处”的地方。
3.4.2 数据流
数据流是相应资料在通道的流动方法。本设计使用的是不同的编号来代表不同的信息流，清晰的展示了设计的信息为他人了解本系统提供了极大地方便。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc7cfae79953bf4e1912c41bd617ecdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb31ee70252aeadf05c90cd29cf2e976/" rel="bookmark">
			二叉树、B树、B&#43;树、红黑树B树B树与二叉树的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 B树与二叉树的区别 二叉树最多能有2个子节点，B树最多有M个子节点，最少有3个子节点。
2、 B树和B+树的比较： 1） B树的关键字信息包含在整棵树种，叶子节点不包含任何关键字信息；B+关键字集合分布在在叶子节点中，非叶子节点只是关键字叶子节点的索引。
2） B树中任何关键字只出现在一个节点中，而B+树的关键字必须出现在叶子节点中，也可能在非叶子节点重复出现
3、红黑树 1）红黑树的插入删除效率更高，任何不平衡都会在三次旋转内解决 2）二叉平衡树比红黑树更为平衡，因此插入或删除时变动频次更高，但查找效率也更高
4、为什么使用B+树 1）B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
2）B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
3）由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c99896e5acfb898ebf6dcca062876c/" rel="bookmark">
			实验二、8位流水灯电路设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验二 八位流水灯电路设计
实验目的 综合应用数字电子技术知识，按照要求设计并完成一个小规模的数字电路系统。进行硬件线路的设计、仿真、焊接、调试与实现。使系统实现一种用于工厂的流水灯电路。在系统运转过程中，八个流水灯会被依次点亮后熄灭，不断重复该过程。通过实际操作，了解和掌握相关课程所涉及到的一些基本理论和基本技能，掌握电子电路系统设计与实现的一般方法。 实验要求 一人一组，独立上机。在电脑上利用Multisim软件完成实验内容。 实验内容 1、该流水灯电路由3个D触发器和8个LED灯组成，流水灯电路运转时，8个LED灯从左到右，依次被点亮，后熄灭，无限循环；
该流水灯的时钟频率为 200Hz。 设计过程 将三个D触发器组合成一个三位异步计数器，此时可以实现从状态S0 – S7八中状态，分别对应每一个流水灯的点亮时刻。由三个D触发器组合的三位异步计数器只有三个输出，无法直接对应到八个流水灯的输入，则借助74LS138（三线八线译码器）转换成八个输出，每一种输出分别对应三位异步计数器的输出以及八个流水灯的输入，此时八个流水灯便会从左往右依次点亮熄灭，反复循环。具体电路设计。
测试方案及实验结果 将电路图运转后，实验结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8edc60b3a905d8c757f5ae8948c0a04/" rel="bookmark">
			python中dataframe的loc使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理数据的时候我们经常使用到dataframe，并对dataframe的行和列进行操作，以下是在处理数据时经常用到的一些方法，记录一下：
loc的使用方法 df.loc[] 根据行标或者列标获取数据
df.loc[行名称，列名称] df.loc[df[‘A‘]=='a', “B”] * 100 # 当列A中某行的值等于“a”时，B列的值乘以100 df.loc[:,'C'] # 选取第C列的数据 pd.to_numeric(df["A"]) # 将某一列的数据转换成数值型 df.loc[df['A'] &gt; 0, :] # 取A列大于0的行 iloc的使用方法 df.iloc[]则根据数据的坐标（position）获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4de3090092386753da39ee665b9f347/" rel="bookmark">
			【数据结构初阶】链表（下）——带头双向循环链表的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
带头双向循环链表的实现
1.带头双向循环链表的节点类型
2.创建带头双向循环链表的节点
3.向带头双向循环链表中插入数据
&lt;3.1&gt;从链表尾部插入数据
&lt;3.2&gt;从链表头部插入数据
&lt;3.3&gt;从链表某个节点前插入数据
4.从带头双向循环链表中删除数据
&lt;4.1&gt;从链表的尾部删除数据
&lt;4.2&gt;从链表的头部删除数据
&lt;4.3&gt;删除链表某个节点
5.在带头双向循环链表中查找数据
6.遍历带头双向循环链表
7.销毁带头双向循环链表
带头双向循环链表实现总代码
测试
1.测试代码
2.测试效果
链表总结
无头单向非循环链表和带头双向循环链表的对比
链表和顺序表的对比
本期博客我们来对最复杂的带头双向循环链表结构进行实现：
我们可以看到该种链表比单链表多了一个头节点（head（该节点一般不存放数据））和一个指向前一个节点的指针，该种类型的链表有着比单链表更多的优势，更适合来存储数据。
带头双向循环链表的实现 1.带头双向循环链表的节点类型 在实现该链表之前我们先要确定节点类型：
typedef int LTDataType;//数据类型 typedef struct ListNode//节点类型 { LTDataType _data; struct ListNode* _next;//指向后一个节点的指针 struct ListNode* _prev;//指向前一个节点的指针 }ListNode; 注：这里的对int类型进行重定义是为了我们更好的看懂Data只是一种数据而不仅仅是int类型。所以我们在使用链表时存储的数据并不限制于int类型，这里仅仅是举例。
2.创建带头双向循环链表的节点 ListNode* ListCreate() { ListNode* NewNode = (ListNode*)malloc(sizeof(ListNode));//向堆区申请一个节点大小的空间 if (NewNode == NULL)//判断申请是否成功 { perror("malloc"); exit(-1); } NewNode-&gt;_next = NewNode; NewNode-&gt;_prev = NewNode;//将_next和_prev指针设为NewNode可以方便直接创建一个头节点 return NewNode;//返回的指针的_next和_prev可以后期根据需要修改 } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4de3090092386753da39ee665b9f347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde6b8ac51c9c382968f6e4c3234c32f/" rel="bookmark">
			Dev-c&#43;&#43; 5.11版本调试方法（七小时折磨调试成功，超详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、出现的问题是
1、设置断点之后点调试不出现蓝行
2、点了调试之后出现黑框、然后又闪退
3、添加查看之后也看不了变量的值
等等各种问题。（查找、一个个试验，还有整理，花了起码六七小时，几乎一天都在折磨这个了，看视频教程也没找到完整的，可能也许我问题太多了，放的位置和其他up的也可能不一样，就搞了好久，中途还把Dev卸载并重新下了，因为觉得可能是一开始有什么属性或者最开始下的时候改了什么。实在折磨）
二、问题解决
1、确定Dev-c++放在了哪个盘哪个文件夹里。因为需要调试的源代码文件要在放Dev-c++的文件下
点击【Dev-c++】，选择【打开文件所在位置】 如下图，我放在的D盘，并建立了一个名字为【调试】的文件夹
2、打开devc++的工具
（1）查看编译器配置是不是TDM-GCCxxxx Debug
（2）选择【编译选项】，然后勾选【编译时加入以下命令】，并在两处输入-g3，然后【确定】
（3）点击【代码生成 / 优化】 ，再点击【连接器】，如图，《产生调试信息》对应那里的NO
改成【yes】，然后点击【确定】
并且在设定编辑器设置那里，再次确定是否是：TDM-GCCxxxx Debug
（4）选择【环境选项】
如图进行修改
（5）新建一个项目：文件-新建-项目
选择【Console Application】 ,选择【C项目】，修改名称，我这里名称是项目二
点击确定后，把文件保存选择在Dev-c++所在的文件夹里即可。我是在第一步建了一个暂时用于展示的【调试】的文件用于教程。可自行安排，只要是在Dev-c++所在的文件夹里即可
点击保存
（6）点击【项目管理】，再点击【项目2】，此处有一个main源代码文件，点击，选择【移除文件】
选择【No】
（7）添加所要测试的源代码文件进行测试 把需要调试的源代码文件放在Dev-c++所在的文件夹里
如下，我需要测试的源代码文件是 hh.c （8）回到Dev
点击【项目2】，选择【添加】
选择刚刚复制到Dev-c++所在的文件夹里 的源代码文件：也就是本例子的 hh.c
我选择了【hh.c】源代码文件，并点击调试开始行，显示如下：
（9）点击编译
（10）添加查看的变量名
点击以下图片这样子的【调试】，可以看到所添加的变量名。此处我添加了 i 和 n
（11）点击【运行】，选择【调试】，如下
出现以下调试框，输入2
然后回车，原来红色的调试起始线变成了蓝色。则证明调试成功了。往后开始调试数据以及代码是否成功。
此时可以看到左边方框栏显示着变量名的数据变化，还有右下角边框是每一步调试的记录 点击【下一步】，进行调试。可以很明显看到，左边栏已经有了数据变化。
此时就没有一开始所出现的问题了，以上任何一个步骤都可能解决不能调试的问题,都试一下吧。或者直接跟着步骤一步步重新来。
以下附送本文章的调试例子代码
#include&lt;stdio.h&gt; int main(void) { int n,i; scanf("%d",&amp;n); for(i=0;i&lt;=n;i++) { if(i!=n) printf("%d!",i); else printf("%d",i); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd8a64118d09f08b83a4758c86529b4/" rel="bookmark">
			Docker容器MySQL数据库的备份与还原，以及每天定时自动备份.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.快速启动mysql容器 1：拉取mysql镜像： 根据自己需要，我这个是Debian的5.7版本的镜像。
这个地方一定要注意：
有些版本的docker镜像里面移除了MySQL自带的工具。包括Mysqlbinlog，Mysqlcheck等。所以即使你开启了binlog，也是没有办法还原数据的，这里要注意一下镜像的选择。
docker pull nanlist/mysql5.7:v1.1 2：宿主机建立挂载目录： mkdir三个文件夹，方便持久化。
/home/mysql/conf
/home/mysql/logs
/home/mysql/data
3.启动容器： docker run -p 3308:3306 --privileged=true --name mysql -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/logs:/var/log/mysql -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d nanlist/mysql5.7:v1.1 –name：容器名，此处命名为mysql -e：配置信息，此处配置mysql的root用户的登陆密码 -p：端口映射，此处映射 主机3306端口 到 容器的3306端口 -d : 表示使得容器后台一直运行 -v：主机和容器的目录映射关系，":"前为主机目录，之后为容器目录 --privileged=true：开启容器操作宿主机权限 查看一下是否启动成功;
docker ps 如果启动有问题可以查看一下日志：
docker logs --tail=1000 mysql 2. docker内部登录mysql系统进行配置 1.进入容器 docker exec -it mysql bash root 密码：123456
2.设置远程登录： grant all privileges on *.* to root@'%' identified by "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd8a64118d09f08b83a4758c86529b4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/58/">«</a>
	<span class="pagination__item pagination__item--current">59/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/60/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>