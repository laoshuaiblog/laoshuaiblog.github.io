<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34697231802278687a6ca54eb01b7120/" rel="bookmark">
			申请Github Education获取免费Copilot权限（2024.3.18实测成功）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因：旧帐户Copilot权限被封 我已经离开Github Copilot就无法独自耐着性子写代码了（懒惰+AI成瘾性），这两天Github Copilot不知道为什么在大规模封号，我不幸也被封号了（禁用掉了Github Copilot权限），具体表现为VS Code的Copilot不再帮我生成代码，在右下角图表处显示一个小感叹号。日志中显示
2024-03-14 10:15:07.824 [info] [auth] Invalid copilot token: missing token: 403 2024-03-14 10:15:07.850 [error] [default] Extension activation failed: "Contact Support. You are currently logged in as 我的Github用户名." 注册新账号并申请Github学生优惠以获取Copilot使用权 1. 学信网申请一个学历报告 申请地址：https://my.chsi.com.cn/archive/bab/xj/show.action
申请好后下载学信报告pdf
2. 开始P图 由于学生认证优惠的审核是自动程序审核的，而且申请页面还有很多bug（申请类型选择框不出现、图片上传按钮不出现），拍照上传的图像有很多奇怪的限制，不做做手脚的话可能申请很多次也无法通过，所以以下是一些trick来说欺骗自动审核程序，帮助大家通过自动审核。
把你的学信报告pdf截图（或者如果你的屏幕足够的大话也可以不下载pdf，直接在学信网网页上截图）
将你的截图用Windows画图软件打开，增加以下元素：
在顶部用醒目的大字P上 My Student ID Card 字样，以便于后边欺骗Github自动审核程序把你的截图当成学生证。在你的姓名旁边用英文P上你的英文姓名，如果你叫张三，你就在旁边P上：name：San Zhang在醒目的地方P上：Virtual Learning，这个非常重要！！！（让程序识别到你是远程上学上课，就不会对你的IP和学校所在地不一致进行限制了）你的学校的英文名也P上：University：XXX University你的学制也P上：Duration：10 years ，我就写10年，希望能给我优惠10年（为什么不是100年？因为我希望我10年后就不要还再写代码了）入学日期也P上：Enrollment date：20XX-09-01预计毕业日期也P上：Graduation time：20XX-06-01照片自己随便找个像人类的大头照丢上去就行 3. 注册github账号，审核上传 我注册了一个新的github账号，用我的学校邮箱（.edu.cn结尾），
把你的Payment Information中的你的名字（San Zhang）、所在地等都改成和你上边的P图中一致的
https://github.com/settings/billing/payment_information
开启2FA验证（在这里：https://github.com/settings/security），
进入以下地址开始申请学生认证包，
https://education.github.com/discount_requests/application
选择类型为：Student
在这个页面中选择你的学校邮箱，验证邮箱后，选择下方绿色Continue按钮
接下来用你的手机，还是在这个页面（https://education.github.com/），登录你的github账号，
点击继续后进入到了上传学历凭证图片的页面，这个页面有时候会有“选择学历凭证类别”的下拉框，有时候会有“选择图片上传”的下拉框，但更多时候没有这两个下拉框（可能因为bug或者设计特性），不过不用担心，不管有没有我们的都不用管，直接点击“摄像头拍照图表”（选择你的手机后置摄像头），然后在你的电脑屏幕上打开你刚刚P好的学历凭证图片，小心清晰的拍照上传，不出意外，你应该看到了“祝贺你……“之类的话，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34697231802278687a6ca54eb01b7120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/088669b19d9d30692751b7ebb4ab924d/" rel="bookmark">
			SpringBoot3&#43;JPA&#43;MySQL实现多数据源的读写分离(基于EntityManagerFactory)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 在Spring Boot中配置多个数据源并实现自动切换EntityManager，这里我编写了一个RoutingEntityManagerFactory和AOP（面向切面编程）的方式来实现。
这里我配置了两个数据源：primary和secondary，其中primary主数据源用来写入数据，secondary从数据源用来读取数据。
注意1： 使用Springboot3的读写分离，首先要保证主库和从库已经配置好了 数据同步，否则会导致数据不一致。
当然如果仅仅是测试的话，不同步就不影响了
注意2： SpringBoot3的JDK不能低于17
我使用的JDK版本
openjdk version "20.0.2" 2023-07-18 OpenJDK Runtime Environment (build 20.0.2+9-78) OpenJDK 64-Bit Server VM (build 20.0.2+9-78, mixed mode, sharing) 2、数据库说明 这里我使用了本机的同一个mysql上的两个不同的数据库，在实际环境中这两个库应该是分别处于不同的服务器上，同时应该已经配置好了主从复制或主备，保证了数据的一致性，不然读写分离就没有意义了。
数据库名称JDBC-URL说明primary_dbjdbc:mysql://localhost:3306/primary_db这个是主库，设计为写入数据库secondary_dbjdbc:mysql://localhost:3306/secondary_db这个是从库，设计为读取数据库 提示：虽然这里我使用的是MySQL数据库，但是在实际的开发过程中，可以替换为Postgresql或oracle等其他关系型数据库，只需要做很小的改动就可以使用了
3、准备工作 3.1、添加依赖 在你的项目里添加如下依赖
&lt;!-- Spring Web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- JPA --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;version&gt;8.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/088669b19d9d30692751b7ebb4ab924d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f0842ab6eee0f69bf02d8772d7644f/" rel="bookmark">
			MySQL-2.表的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2. 表的基本操作 2.1 表的概念： 数据库——厂库，表——货架（对数据进行抽象分类）。 在创建数据库的时候一定要记得设置字符编码。 2.2 引用数据库-use mysql&gt; use student; // 切换到目标数据库student Database changed // 反馈信息，表示已经成功切换 2.3 查询当前数据库中的所有表-show mysql&gt; show tables; Empty set (0.00 sec) // 反馈信息，表示查询结果为空，即当前数据库中没有表 2.4 创建表-create 2.4.1 简单 mysql&gt; create table employee( -&gt; id int, -&gt; name varchar(30), -&gt; age int, -&gt; salary int -&gt; ); Query OK, 0 rows affected (0.04 sec) MySQL中字符串的语句不使用String，而是使用varchar，需要表明长度。 mysql&gt; show tables; +-----------------------+ | Tables_in_student | +-----------------------+ | employee | +-----------------------+ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f0842ab6eee0f69bf02d8772d7644f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d03bbbe1ee4ab89b150f8e4eef94a7/" rel="bookmark">
			「Nginx」Nginx配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「Nginx」Nginx配置详解 参考文章1、正向代理和方向代理2、指定域名允许跨域 参考文章 1、Nginx反向代理
2、nginx配置详解
3、Nginx服务器之负载均衡策略（6种）
1、正向代理和方向代理 2、指定域名允许跨域 map $http_origin $allow_cors { default 1; #以下为提供参考的正则表达式 "~^https?://.*?\.guizhou.gov\.cn.*$" 1; "~^(https?://(shequ.guizhou.gov.cn)?)$" 1; "~https://shequ.guizhou.gov.cn" 1; "~*" 0; } 在server中判断
location /api/ { if ($allow_cors = 0){ return 403; } client_max_body_size 100M; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://Gateway/; } 这段配置的含义是：根据请求头中的 Origin 值，如果是以 “https://.*.guizhou.gov.cn”、“https://shequ.guizhou.gov.cn” 或精确匹配 “https://shequ.guizhou.gov.cn” 开头的情况，将 $allow_cors 变量映射为 1，表示允许跨域；否则，将 $allow_cors 映射为 0，表示不允许跨域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83d01d4db8b4dd8393fa36b7ba7ca8ac/" rel="bookmark">
			npm 常用命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm，即 Node Package Manager，是 Node.js 的包管理器。它允许你安装、更新、删除和管理 Node.js 项目中的依赖包。在 Node.js 开发中，npm 的使用频率极高，掌握其常用命令对于开发者来说是至关重要的。本文将详细解释 npm 的常用命令及其用法。
1. npm install
npm install 是 npm 最常用的命令之一，用于安装 Node.js 模块。你可以通过指定模块名称来安装特定的模块，如 npm install express 将安装 Express 框架。
此外，npm install 命令还可以与一些参数一起使用，以实现不同的安装目标。例如，使用 --save-dev 参数安装的模块将被添加到 package.json 文件的 devDependencies 列表中，这些模块通常只在开发环境中使用，如测试工具或构建工具。而使用 --save 参数安装的模块则会被添加到 dependencies 列表中，这些模块是项目运行所必需的。
2. npm uninstall
npm uninstall 命令用于卸载已安装的 Node.js 模块。例如，npm uninstall express 将卸载 Express 框架。
3. npm update
npm update 命令用于更新已安装的 Node.js 模块到最新版本。你可以通过指定模块名称来更新特定的模块，如 npm update express。如果不指定模块名称，npm 将更新 package.json 文件中列出的所有模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83d01d4db8b4dd8393fa36b7ba7ca8ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce3504b550aeef66f1deca8c52959f33/" rel="bookmark">
			CSS问题精粹1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.关于消除&lt;li&gt;列表前的符号 我相信很多人在初学CSS时会遇到该问题，无论是创作导航，还是列表，前面都会有个黑点点或其它符号。
解决该问题其实很简单
采用list-style-type:none或list-style:none直接解决 如果你想更换前面的黑点点，换成其他符号或图片图标 请看下面------&gt;&gt;&gt;&gt;&gt;&gt;
2.如何插入或更换列表前的图标 list-style-image: url(images/icon.gif); 值得你拥有 属性值：
none：默认值，项目符号为默认的实心圆点。url：指定项目符号图片的URL地址。例如：list-style-image: url('image.png');initial：将属性设置为其默认初始值。inherit：继承父元素的属性值。 注意事项：
项目符号图片的大小、颜色、透明度等属性可以通过其他CSS属性进行设置。项目符号图片需要是透明背景的PNG格式，以免遮挡列表文本。 如果还想清除前面的空格
3.如何清除前面的空格间隙 使用CSS的margin属性，将li元素的margin-left设置为0。示例代码如下： li { margin-left: 0; } 如果有嵌套的ul或ol元素，并且想要清除嵌套li前的空格间隙，可以使用CSS的padding属性将ul或ol元素的padding-left设置为0。示例代码如下 ul, ol { padding-left: 0; } li { margin-left: 0; } 聊完列表，我们可以看看背景
4.background-image的全覆盖重复问题 像这种会自动铺满重复排列背景图片
body { background-image: url(images/bg.jpg); background-position: center center; background-repeat: no-repeat； background-size: cover; } 我们一般采用上面这种方法
background-position固定位置（按需求决定一般是定在正中间，left center ,right center.............） background-repeat实现不重复 以防万一再加一个background-size实现全覆盖 5.如何改变鼠标指针的类型　可以使用CSS的cursor属性来改变鼠标指针的类型。以下是一些常用的类型： auto：浏览器自动设置指针类型。default：默认指针（通常是一个小手指）。pointer：表示链接的指针。text：表示文本输入的指针，通常是一个竖线。move：表示可拖动的指针。wait：表示正在等待的指针，通常是一个旋转的圆圈。crosshair：表示十字线指针，用于选择区域。 要改变元素的鼠标指针类型，只需将cursor属性设置为所需的类型即可。例如，要将鼠标指针类型设置为pointer，可以使用以下CSS代码：
.element { cursor: pointer; } 6.如何去除h元素与后续段落之间的大间隔 方法有很多，说明白点就是间距
margin 法1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce3504b550aeef66f1deca8c52959f33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f0d12babd5436b7b0196e760662f8c/" rel="bookmark">
			字符串String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、string的三大特性 不变形，string是一个immutable模式（不变模式）的对象，在被多线程访问时，可以保证数据的一致性。常量池优化：string对象创建后，会在字符串常量池中进行缓存，下次创建同样对象时，会直接返回缓存的引用final：不可变被继承，提升安全性。 不变模式，指的是一个对象的状态在对象被创建之后就不在变化。包括强不变模式和弱不变模式，
弱不变模式：类的实例状态是不可变化的，但是这个类的子类的实例可能会变 对象实例化之后，没有方法修改对象的状态所有的属性都是私有的这个对象如果引用了其他可变对象的话，必须限制外界对这些可变对象的访问，以防止被修改强不变模式：一个类的实例状态不会改变，同时子类的实例也有不可变的状态 除了弱不变几点外，要么这个类本身是final修饰，要么所有方法都是final修饰。 不变和只读的区别？
一个变量只读时，变量的值不能被修改，但是不意味着这个值不会改变，比如一个人的年龄。
2、string的实例化方式 直接定义赋值通过构造器，传入一个字面量，或者传入一个char[] 数组 /** * 字符串创建的两种方式 * 1、直接赋值，在字符串常量池中创建对象 * 2、通过构造器，堆内存和字符串常量池中各一份 */ private static void test1() { String str1 = "hello"; // 字符串常量池中没有hello，就在字符串常量池中创建hello，并将地址返回给str1 String str2 = "hello"; // 字符串常量池中已经有hello了，直接拿到hello的地址给str2 // str1和str2都是引用这个hello的地址，因此打印true System.out.println(str1 == str2); // 看到new，就意味着在堆内存中创建了一个对象 // 因为常量池中已经存在hello了，因此不会在创建对象了 String str3 = new String("hello"); String str4 = new String("hello"); // 两个对象比较地址，显然是false System.out.println(str3 == str4); // String重新了equals方法，比较对象的值，答案是true System.out.println(str3.equals(str4)); } 3、string的不可变性怎么体现的？为什么要设计成不可变的？ * 1、怎么个不可变法？ * 1.1：string底层是一个char[]数组（java8以后变成了byte[]数组），这个数组被private 和 final修饰，并且没有暴露任何可以修改char[]数组的接口 * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7f0d12babd5436b7b0196e760662f8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a72c01453f0c5e8d29da5a0b1b6e098a/" rel="bookmark">
			CentOS 8 中安装与配置 MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将详细介绍如何在 CentOS 8 系统上安装 MySQL，并对其进行基础安全配置，包括设置 root 密码、移除匿名用户、禁止 root 远程登录等。
步骤一：安装 MySQL 服务器 利用 CentOS 8 自带的 dnf 包管理器安装 MySQL 服务器：
sudo dnf install mysql-server 此命令将自动处理所有依赖并安装 MySQL 服务器。
步骤二：启动 MySQL 服务并设置开机自启 安装完成后，启动 MySQL 服务并确保其在系统启动时自动启动：
sudo systemctl start mysqld sudo systemctl enable mysqld 步骤三：进行安全配置 运行 mysql_secure_installation 脚本，进行安全初始化配置，包括设置 root 用户密码、移除匿名用户、禁止 root 用户远程登录等：
sudo mysql_secure_installation 根据提示输入相关信息，尤其是为 root 用户设置一个强密码。
步骤四：登录 MySQL 验证安装 使用新设置的 root 密码登录 MySQL，验证安装是否成功：
mysql -u root -p 在此处输入你在安全配置过程中设置的密码。
最后一步：开放防火墙端口（仅适用于本地测试） 若仅在本地测试，确保 CentOS 的防火墙允许本地流量访问 MySQL 默认使用的 3306 端口：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a72c01453f0c5e8d29da5a0b1b6e098a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/023028aa0a1a7b016bfa02811470731c/" rel="bookmark">
			package.json详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们常常会创建 npm 项目，都会自动生成 package.json 文件，那么你知道里面的属性都是什么意思吗？我们就一起来看一下吧！
{ "name": "项目名称", "private": false, // 是否私有的 "version": "版本", "description": "项目描述", "main": "主文件路径", "files": [ // npm提交的目录吗，默认还包含LICENSE、README.md文件 "lib", "src", "types" ], "scripts": { // 可执行脚本 "build": "webpack" }, "typings": "/types/index.d.ts", // 指定types文件 "repository": { // 仓库配置 "type": "git", // 仓库类型 "url": "仓库地址" }, "keywords": [ // 项目关键字 "tools" ], "author": "作者", "license": "MIT", // 版权许可证 "dependencies": { // 生产所需依赖 "@amap/amap-vue": "^2.0.13", "@riophae/vue-treeselect": "0.4.0", } "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/023028aa0a1a7b016bfa02811470731c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac8b8ac1cb969aacbf27ddecdd2b4e80/" rel="bookmark">
			【视觉语言大模型&#43;LLaVA1.0】大语言模型视觉助手（视觉指令调优）GPT4-Vision丐版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方资源汇总： 项目主页 || https://huggingface.co/liuhaotian
23.04.LLaVA1.论文: Large Language and Vision Assistant（Visual Instruction Tuning)
23.10 LLaVA-1.5论文: Improved Baselines with Visual Instruction Tuning
23.11 LLaVA-Plus项目：LLaVA-Plus: Large Language and Vision Assistants that Plug and Learn to Use Skills
24.01 LLaVA-1.6 博客(论文还未出): LLaVA-NeXT: Improved reasoning, OCR, and world knowledge
本地部署参考：https://blog.csdn.net/zhzxlcc/article/details/133773891
其他: 23.02.大语言模型LLaMA项目: Open and Efficient Foundation Language Models
相关博文： 【LLaVA所用的预训练大预言模型LLMs】23.03.Vicuna: 类似GPT4的开源聊天机器人（ 90%* ChatGPT Quality）
【通用baseline】23.10.LLaVA-1.5改善后视觉语言大模型
【医学图像】23.06 LLaVA-Med（医学图片视觉助手）: Training a Large Language-and-Vision Assistant for Biomedicine
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac8b8ac1cb969aacbf27ddecdd2b4e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e94a77e314fb0631fa440663872f81/" rel="bookmark">
			C&#43;&#43; list详解及模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
本节目标
1. list的介绍及使用
1.2 list的使用
2.list的模拟实现 1.对list进行初步的实现
2.头插和任意位置的插入
3.pos节点的删除，头删，尾删
4.销毁list和析构函数
5.const迭代器
6.拷贝构造和赋值操作
3.完整代码 本节目标 1. list的介绍及使用
2. list的深度剖析及模拟实现
3. list与vector的对比
1. list的介绍及使用 1. list是可以在常数范围内在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代。
2. list的底层是双向链表结构，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。
3. list与forward_list非常相似：最主要的不同在于forward_list是单链表，只能朝前迭代，已让其更简单高效。
4. 与其他的序列式容器相比(array，vector，deque)，list通常在任意位置进行插入、移除元素的执行效率更好。
5. 与其他序列式容器相比，list和forward_list最大的缺陷是不支持任意位置的随机访问，比如：要访问list的第6个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置，在这段位置上迭代需要线性的时间开销；list还需要一些额外的空间，以保存每个节点的相关联信息(对于存储类型较小元素的大list来说这可能是一个重要的因素)
1.2 list的使用 list中的接口比较多，此处类似，只需要掌握如何正确的使用，然后再去深入研究背后的原理，已达到可扩展的能力。以下为list中一些常见的重要接口。
1.list的构造
构造函数（ (constructor)）接口说明list (size_type n, const value_type&amp; val = value_type())构造的list中包含n个值为val的元素list()构造空的listlist (const list&amp; x)拷贝构造函数list (InputIterator first, InputIterator last)用[first, last)区间中的元素构造list 代码演示：
void TestList1() { list&lt;int&gt; l1; // 构造空的l1 list&lt;int&gt; l2(4, 100); // l2中放4个值为100的元素 list&lt;int&gt; l3(l2.begin(), l2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9e94a77e314fb0631fa440663872f81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4a2bc4982e398ac4c0dd65ddce3efaf/" rel="bookmark">
			leetcode每日一题1969
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一.题目原型：
二思路解析：
三.代码实现:
一.题目原型： 二思路解析： 灵神的做法非常让人惊叹：
理解就是，如果一个数大于另一个数要交换的1的权重，那么他们的乘积就变小。
那么一个大的数不断变大，小的数不断变小，乘积不也就越来越小吗？
在看个例子。 注意点一：交换后所有数字的和不变，因为只是某一个数 +2^k,另一个数 -2^k，和不变.
注意点二：然后在和不变的基础上，差大积小，假如能形成 1 1 1 1 1 …… 1 n,那肯定积最小，但是，这种情况是达咩的，这就是注意点二：交换是交换，上限不会超过2^p-1，数字的上限已经决定了
回头看示例3：
注意点3：接着继续考虑，尽可能的形成1这个思路没错了，问题是最多有多少个1可以形成，接着我看示例3：我先是疑惑了一下，为什么是 1 1 1 6 6 6 7呢，和不变的情况下，差大积小，为什么不是 1 1 1 5 6 7 7呢，明显积更小啊，之后就被我发现了注意点三：在二进制位上的0、1数量是相对不变的，p=3举例，每个二进制位上都是4个1，3个0；p=4的时候 都是8个1，7个0
最关键的是： 很完美的思路：灵神太厉害了！ 快速幂的知识总结下来就是一句话：x的n次方就是不断缩小n，扩大x的时候找出所有奇次方底数的积，还有本题数字太大，也需要将快速幂的模的方法搬过来。
三.代码实现: class Solution { const int mod = 1'000'000'007; long long pow(long long x, long long m) { x %= mod; long long res = 1; while (m&gt;0) { if(m&amp;1){ res = res * x % mod; } m&gt;&gt;=1; x = (x%mod * x % mod)%mod; } return res; } public: int minNonZeroProduct(int p) { long long k = (1LL &lt;&lt; p) - 1; //k=2^p -1 long long m=(1LL&lt;&lt;(p-1))-1; return k % mod * pow(k - 1, m) % mod; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7366eec38b27f65aa6dfb8660e474ee/" rel="bookmark">
			MySOL数据库管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库基本操作 库和表 数据库–&gt;数据表–&gt;行（记录）：用来描述一个对象的信息 列（字段）：用来描述对象的一个属性 常用的数据类型 int整型float单精度浮点 4字节32位double双精度浮点 8字节64位char固定长度的字符类型varchar可变长度的字符类型text文本image图片decimal(5,2)5个有效长度数字，小数点后面有2位 char与varchar区别
查看数据表结构 查看当前服务器的数据库 #大小写不区分，分号“;”表示结束 SHOW DATABASES; 查看数据库中包含的表 USE 数据库名；
SHOW TABLES;
SHOW TABLES FROM 数据库名；
查看表的结构
USE 数据库名； DESCRIBE 表名； 可缩写成:DESC 表明； DESCRIBE [数据库名.] 表明； SHOW CREATE TABLE 表名；#以命令的形式查看表结构 SQL语句 SQL语句用于维护管理数据库，包括数据查询、数据更新、访问控制、对象管理等功能。
SQL语句分类：
语句代表的意思DDL数据定义语言，用于创建数据库对象，如库、表、索引等（create ）DML数据操纵语言，用于对表中的数据进行管理(insert drop delete update )DQL数据查询语言，用于从数据表中查找符合条件的数据记录(select )DCL数据控制语言，用于设置或者更改数据库用户或角色权限(grant ) 创建及删除数据库和表 创建新的数据库 CREATE DATABASE 数据库名； 创建新的表 主键一般选择能代表唯一性的字段不允许取空值（NULL），一个表只能有一个主键。
CREATE TABLE 表名 (字段1 数据类型,字段2 数据类型 [,...][,PRIMARY KEY (主键名)]); 示例：
use zdj
create table zdj (id int, name char(10) not null, age int, sex char(4), money decimal(5,2));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7366eec38b27f65aa6dfb8660e474ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889a81272db7bf7d5c87119b5a13a820/" rel="bookmark">
			【WEEK4】 【DAY2】整合SSM框架之功能实现—总览、添加数据【中文版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.3.19 Tuesday
目录 7.4.查询全部书籍功能7.4.1.新建BookController.java7.4.2.编写首页 index.jsp7.4.2.1.最初版（验证代码逻辑正确）7.4.2.2.最终版（查询书籍功能） 7.4.3.新建书籍列表页面 allBook.jsp7.4.3.1.最初版（验证代码逻辑正确）7.4.3.2.最终版（查询书籍功能） 7.4.4.记得配置tomcat，导入lib7.4.5.运行7.4.5.1.最初版（验证代码逻辑正确）7.4.5.2.最终版（查询书籍功能） 7.5.添加书籍功能7.5.1.修改BookController.java7.5.2.修改allBook.jsp7.5.3.新建页面 addBook.jsp7.5.4.运行7.5.4.1.遇到过的问题7.5.4.2.最终版 7.4.查询全部书籍功能 7.4.1.新建BookController.java 7.4.2.编写首页 index.jsp package P17.controller; import P17.project.Books; import P17.service.BookService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import java.util.List; @Controller @RequestMapping("/book") public class BookController { //controller调用service层 @Autowired @Qualifier("BookServiceImplement") private BookService bookService; //查询全部的书籍，并返回到一个书籍展示页面 @RequestMapping("/allBook") public String list(Model model){ List&lt;Books&gt; list = bookService.queryAllBook(); //调用业务层的方法，查询到所有的书籍 model.addAttribute("list",list); //返回前端查询 return "allBook"; //返回到allBook.jsp } } 7.4.2.1.最初版（验证代码逻辑正确） &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt; &lt;%--${}内取的是绝对地址--%&gt; &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/889a81272db7bf7d5c87119b5a13a820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/825d0503f29a4e087652c357f6733a14/" rel="bookmark">
			80386 AT&amp;T汇编语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 gcc的预处理，不进行编译、汇编或链接预处理编译汇编 8.8.2 AT&amp;T语法与英特尔语法8.8.3操作码命名8.8.4寄存器命名8.8.5操作码前缀8.8.6内存引用8.8.7跳转指令的处理8.8.8浮点8.8.9写入16位代码8.8.10笔记 gcc的预处理，不进行编译、汇编或链接 gcc选项 -E 仅作预处理，不进行编译、汇编或链接。 -S 编译到汇编语言，不进行汇编和链接， -c 编译、汇编到目标代码，不进行链接。 -o &lt;文件&gt; 输出到 &lt;文件&gt;。 -pie 生成动态链接的位置无关可执行文件。 -shared 生成一个共享库。 -x &lt;语言&gt; 指定其后输入文件的语言。 允许的语言包括：c、c++、assembler、none ‘none’意味着恢复默认行为，即根据文件的扩展名猜测 源文件的语言。 [hao@bogon qemu-demo]$ gcc -v -c test.S -o test.o 使用内建 specs。 COLLECT_GCC=gcc OFFLOAD_TARGET_NAMES=nvptx-none OFFLOAD_TARGET_DEFAULT=1 目标：x86_64-redhat-linux 配置为：../configure --enable-bootstrap --enable-host-pie --enable-host-bind-now --enable-languages=c,c++,fortran,lto --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --enable-plugin --enable-initfini-array --without-isl --enable-multilib --with-linker-hash-style=gnu --enable-offload-targets=nvptx-none --without-cuda-driver --enable-gnu-indirect-function --enable-cet --with-tune=generic --with-arch_64=x86-64-v2 --with-arch_32=x86-64 --build=x86_64-redhat-linux --with-build-config=bootstrap-lto --enable-link-serialization=1 线程模型：posix Supported LTO compression algorithms: zlib zstd gcc 版本 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/825d0503f29a4e087652c357f6733a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab769c3a00e47cc5cb248795bbac52bb/" rel="bookmark">
			探析Apache Kafka生产者性能指标：洞察与优化关键点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言
Apache Kafka因其卓越的性能表现和高吞吐量成为了企业级消息队列的事实标准。作为Kafka生态中的关键角色，生产者（Producer）的性能直接关系到整个系统的效率和稳定性。本文将深入探讨Kafka生产者的几大性能指标及其背后含义，帮助企业更好地理解和优化生产者的表现。
一、生产者吞吐量（Throughput）
吞吐量是衡量生产者性能的首要指标，它反映了单位时间内生产者成功发送到Kafka集群的消息数量。高吞吐量意味着生产者能够更快地将消息传输至Kafka，这对于实时数据处理、流式计算等场景尤为重要。通过调整生产者的配置，如batch.size（批次大小）、linger.ms（延时提交时间）以及选择合适的压缩算法（如GZIP、Snappy），可以有效提升吞吐量。
二、消息发送延迟（Latency）
延迟是指从生产者发出消息到该消息被Kafka成功接收并确认的时间间隔。降低消息发送延迟对于要求实时响应的业务至关重要。影响延迟的因素包括网络状况、Kafka集群的响应速度、生产者的参数配置（如acks配置）以及数据序列化和反序列化的效率等。通过合理配置生产和确认策略，以及优化网络环境，可以显著改善消息发送延迟。
三、批处理与压缩效果
批处理是Kafka生产者提升性能的重要手段。通过batch.size参数控制每次批量发送消息的大小，配合linger.ms延时提交策略，生产者可以在短时间内积累足够的消息一次性发送，减少网络交互次数，从而提升吞吐量并降低延迟。同时，启用消息压缩（如通过compression.type参数配置GZIP或Snappy压缩算法）可以减少网络带宽占用，尤其是在处理大量小消息时，压缩率对性能提升尤为明显。
四、幂等性与事务性影响
生产者的幂等性和事务性设置也会影响其性能表现。开启幂等性（enable.idempotence=true）可以防止消息重复发送，尽管在一定程度上会增加额外的开销，但在某些对数据完整性和一致性要求极高的场景下，这是必不可少的功能。而Kafka 0.11版本引入的事务性生产者支持，则可以确保一组消息原子性地被写入Kafka，但这同样会对性能产生一定影响。
五、监控与调优
JMX监控：通过JMX可以实时查看生产者的各项性能指标，如发送消息的速率、延迟、请求大小、等待时间等，从而为调优提供依据。
指标分析与优化：密切关注网络I/O、CPU使用率、内存消耗等系统资源，结合上述性能指标分析瓶颈所在，针对性地调整生产者参数、优化代码逻辑或升级硬件设施。
连接管理与重试策略：生产者与Broker的连接质量、重试策略（如retries和retry.backoff.ms）也是影响性能的关键因素，合理的配置有助于提高系统的鲁棒性和响应速度。
总结来说，深入理解Kafka生产者的性能指标并进行有针对性的调优，是实现高性能、高可用消息系统的关键。通过持续监控、分析和优化生产者的工作机制，企业能够更好地驾驭Kafka的强大功能，以满足日益增长的实时数据处理需求。同时，实践经验告诉我们，无论是在生产环境还是开发调试阶段，关注并改进生产者性能指标，都能带来明显的性能提升和用户体验改善。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e553cdabf0bc3e261a3e8d34fbea94b/" rel="bookmark">
			uniapp_微信小程序客服
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、调用api 二、代码 &lt;button open-type="contact"&gt;客服&lt;/button&gt; 三、小程序后台添加客服人员就行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d71eaaa57876ad1a8121ada5ca1ea1b0/" rel="bookmark">
			js拖动上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代的Web开发中，拖动上传是一项非常常见且实用的功能。本文将向你介绍如何使用JavaScript实现拖动上传，并深入解析相关的API、代码调用方法以及注意事项。希望通过本文的科普，能帮助你更好地理解和应用这一功能。
实现拖动上传的API：
dragenter：当拖动元素进入指定区域时触发。dragover：当拖动元素在指定区域内移动时触发。dragleave：当拖动元素离开指定区域时触发。drop：当拖动元素释放时触发。 代码调用方法：
首先，在HTML中创建一个拖动区域的容器：
&lt;div id="dropzone"&gt;将文件拖拽至此处&lt;/div&gt; 然后，在JavaScript中获取该容器的引用，并为其绑定相关事件监听器：
const dropzone = document.getElementById('dropzone'); dropzone.addEventListener('dragenter', dragEnterHandler); dropzone.addEventListener('dragover', dragOverHandler); dropzone.addEventListener('dragleave', dragLeaveHandler); dropzone.addEventListener('drop', dropHandler); 接下来，编写对应的事件处理函数：
function dragEnterHandler(e) { e.preventDefault(); // 在拖动元素进入指定区域时，取消默认行为，并添加视觉效果（例如改变背景色） dropzone.style.backgroundColor = '#f2f2f2'; } function dragOverHandler(e) { e.preventDefault(); // 在拖动元素在指定区域内移动时，同样取消默认行为 } function dragLeaveHandler(e) { // 在拖动元素离开指定区域时，移除视觉效果 dropzone.style.backgroundColor = ''; } function dropHandler(e) { e.preventDefault(); // 在拖动元素释放时，取消默认行为，获取拖动的文件列表 const files = e.dataTransfer.files; // 进行文件上传等后续操作 handleFiles(files); // 恢复默认视觉效果 dropzone.style.backgroundColor = ''; } function handleFiles(files) { // 在这里可以进行文件上传等后续操作 // 遍历文件列表，处理每个文件 for (let i = 0; i &lt; files.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d71eaaa57876ad1a8121ada5ca1ea1b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c74a37f5c27300e2321d705e3aa1dfe9/" rel="bookmark">
			Qt笔记 事件分发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们知道，事件的产生和处理主要分为四个部分，事件产生，事件过滤，事件分发以及事件处理。
实际上，在事件分发和事件处理之间，事件分发器会调用一个函数叫做event，这个event所代表的含义就是我们用户要处理的这个事件，多数情况下我们对事件做任何处理，而是由事件处理函数来进行处理。当然我们也可以设置event函数来拦截事件，这样就不会分发到对应的事件处理函数上，而是在event函数就处理完了。一般来说，我们不推荐这样使用，但是我们得知道。
总的来说，widget的event方法就是在处理函数调用之前进行拦截，可以针对一些事件在处理进行特殊处理。
//在widget.h的文件下进行声明 #include &lt;QEvent&gt; protected: bool event(QEvent *event); //在widget.cpp的文件下进行定义 bool Widget::event(QEvent *event) { if(event-&gt;type() == QEvent::MouseButtonPress)//拦截鼠标点击事件 { qDebug() &lt;&lt; "鼠标按键被按下"; return true; } return QWidget::event(event);//对于其他的事件，我们交给父类的event来处理，父类的event我们没有做任何的修改，这样其他事件还是会去找事件处理函数进行处理 } //这样就可以在调用事件处理函数之前，对一些事件进行特殊处理。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18b05eecba1b618714e2dc8053204c2/" rel="bookmark">
			【C语言】指针&amp;&amp;二级指针&amp;&amp;数组指针&amp;&amp;指针数组详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主页：醋溜马桶圈-CSDN博客
专栏：C语言_醋溜马桶圈的博客-CSDN博客
gitee：mnxcc (mnxcc) - Gitee.com
目录
1.初始指针
1.1 什么是指针？
1.2 指针和指针类型
1.2.1 指针的+1/-1操作
1.2.2 指针的解引用
1.3 野指针
1.3.1 野指针成因
1.3.2 如何规避野指针 1.4 指针运算
1.4.1 指针+-整数
1.4.2 指针-指针
1.4.3 指针的关系运算
1.6 二级指针
1.7 字符指针
1.8 函数指针
1.8.1 回调函数
1.8.1.1 qsort()函数
1.8.1.2 代码示例
1.8.1.3 void*
2.指针数组和数组指针
2.1 指针数组
2.2 数组指针
2.2.1 数组指针的定义
2.2.2 &amp;数组名和数组名
2.2.3 数组指针的使用
3.指针和数组
3.1 指针和数组的关系
3.2 数组传参和指针传参
3.2.1 一维数组传参
3.2.2 二维数组传参
3.2.3 一级指针传参
3.2.4 二级指针传参
3.3 函数指针数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b18b05eecba1b618714e2dc8053204c2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/15/">«</a>
	<span class="pagination__item pagination__item--current">16/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/17/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>