<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.125.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="老帅的博客">
		<meta property="og:url" content="https://laoshuaiblog.github.io/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="老帅的博客">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4398545212a9c7d7fe707baf2619bb2a/" rel="bookmark">
			Makefile简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Makefile前言 使用keil, S32KDS等工具开发程序时，点击鼠标就可编译，它的内部机制其实就是Makefile，使用Makefile组织管理这些程序。
文件a.c
#include &lt;stdio.h&gt; int main() { printf("a + b = %d\n", add(1, 1)); return 0; } 文件b.c
int add(int a, int b) { return a+b; } 编译：
gcc -o test a.c b.c 运行：
./test 结果：
a + b = 2 gcc -o test a.c b.c 编译得到test主要经过以下4个步骤：
1.预处理2.编译3.汇编4.链接 .c(预处理)–&gt;.i(编译)–&gt;.s(汇编)–&gt;.o(链接)–&gt;可执行文件（下面的例子随便以hello举例）
gcc -E -o hello.i hello.c gcc -S -o hello.s hello.i gcc -c -o hello.o hello.s gcc -o hello hello.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4398545212a9c7d7fe707baf2619bb2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7fbbca691215926123a6acec07fa46/" rel="bookmark">
			（完整版C语言代码）哈夫曼树的构造
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图：最终构成的哈夫曼树 //哈夫曼树的构造 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MinSize -1000 typedef struct HTNode *HuffmanTree; struct HTNode{ int Weight; HuffmanTree Left; HuffmanTree Right; }; typedef HuffmanTree ElementType; typedef struct HeapNode *MinHeap; struct HeapNode{ ElementType *Elements; int Size; int Capacity; }; MinHeap Create(int N) { MinHeap H=(MinHeap)malloc(sizeof(struct HeapNode)); H-&gt;Elements=(ElementType*)malloc((N+1)*sizeof(ElementType)); H-&gt;Size=0; H-&gt;Capacity=N; HuffmanTree HT; HT=(HuffmanTree)malloc(sizeof(struct HTNode)); HT-&gt;Weight=MinSize; HT-&gt;Left=HT-&gt;Right=NULL; H-&gt;Elements[0]=HT; return H; } void Insert(MinHeap H,ElementType X) { if(H-&gt;Size==H-&gt;Capacity){ printf("最小堆已经满，不能插入！\n"); return; } int i=++H-&gt;Size; for(;X-&gt;Weight&lt;H-&gt;Elements[i/2]-&gt;Weight;i/=2){//这里没有等号会少运行一次 H-&gt;Elements[i]=H-&gt;Elements[i/2]; }	H-&gt;Elements[i]=X; } ElementType DeleteMin(MinHeap H) { if(H-&gt;Size==0){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7fbbca691215926123a6acec07fa46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32e4bd82a76da94118d9879026ce5f5/" rel="bookmark">
			padas facorize的实际使用一个小案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如有如下数据，需要获取score为前5的数据。
score cat 18 B 18 A 17 A 16 B 16 A 15 B 14 B 13 A 12 A 10 B 9 B 这个问题的核心在于score中的数据是允许重复的，直接获取前5名的方法并不可取，下面介绍下如何使用factorize函数来实现。
&gt;&gt;&gt; df['rnk'] = df.score.factorize()[0] + 1 &gt;&gt;&gt; df score cat rnk 0 18 B 1 1 18 A 1 2 17 A 2 3 16 B 3 4 16 A 3 5 15 B 4 6 14 B 5 7 13 A 6 8 12 A 7 9 10 B 8 10 9 B 9 &gt;&gt;&gt; out = df[df['rnk'] &lt;= 5] &gt;&gt;&gt; out score cat rnk 0 18 B 1 1 18 A 1 2 17 A 2 3 16 B 3 4 16 A 3 5 15 B 4 6 14 B 5 哈哈。代码还是比较容易理解的，可以参考上一篇文章。有兴趣的话欢迎关注python小工具一起学习pandas和pyhton
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f3b995f4a0b2bcc4309e6f328100d0/" rel="bookmark">
			springboot的服务端推送技术SSE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.常见定时推送实现方式 1.客户端轮询:ajax定时拉取
2.服务端主动推送:WebSocket
全双工的，本质上是一个额外的tcp连接，建立和关闭时握手使用http协议，其他数据传输不使用http协议，更加复杂一些，适用于需要进行复杂双向数据通讯的场景。
3.服务端主动推送:SSE (Server Send Event)：
html5新标准，用来从服务端实时推送数据到浏览器端，
直接建立在当前http连接上，本质上是保持一个http长连接，轻量协议
简单的服务器数据推送的场景，使用服务器推送事件 二.SSE介绍 2.1 sse扫盲 sse：sever send event；直译为服务器发送事件，顾名思义，也就是服务端向客户端推送信息的一种技术。通俗解释起来就是一种基于HTTP的，以流的形式由服务端持续向客户端发送数据的技术
2.2 sse的流程 常规流程：我们常见的 http 交互方式是客户端发起请求，服务端响应，然后一次请求完毕；
sse模式下：在 sse 的场景下，客户端发起请求，连接一直保持，服务端有数据就可以返回数据给客户端，这个返回可以是多次间隔的方式。
2.3 sse与websocket的区别 SSE 最大的特点，可以简单规划为两个
长连接服务端可以向客户端推送信息 sse 是单通道，只能服务端向客户端发消息；而 webscoket 是双通道。和websocket相比，只能单工通信，建立连接后，只能由服务端发往客户端，且占用一个连接，如需客户端向服务端通信，需额外打开一个连接
2.4 应用场景 从 sse 的特点出发，我们可以大致的判断出它的应用场景，需要轮询获取服务端最新数据的 case 下，多半是可以用它的，比如显示当前网站在线的实时人数，法币汇率显示当前实时汇率，电商大促的实时成交额等等...
参考文章：http://www.manongjc.com/detail/8-ufnkqsjgmxnyhdw.html
https://www.cnblogs.com/yihuihui/p/12622729.html
https://www.jianshu.com/p/ed94c8005f2c
https://blog.csdn.net/tenyears940326/article/details/109616786
三. 应用案例 3.1 工程结构 3.2 pom文件 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 3.3 新建一个html页面 为了直接能够访问，在resource目录下新建一个static目录，用于存放静态页面
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript"&gt; //需要判断浏览器支不支持，可以去w3c进行查看 var source = new EventSource('/get_data'); source.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f3b995f4a0b2bcc4309e6f328100d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62813de7e104dd568802e49623f6ce79/" rel="bookmark">
			使用PreparedStatement批量操作数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、批量执行SQL语句 当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率
JDBC的批量处理语句包括下面三个方法：
addBatch(String)：添加需要批量处理的SQL语句或是参数；executeBatch()：执行批量处理语句；clearBatch():清空缓存的数据 通常我们会遇到两种批量执行SQL语句的情况：
多条SQL语句的批量处理；一个SQL语句的批量传参； 二、使用PreparedStatement批量插入数据 @Test public void testInsert1(){ Connection connection = null; PreparedStatement preparedStatement = null; try { long start = System.currentTimeMillis(); connection = JDBCUtils.getConnection(); String sql = "insert into goods(name)values(?)"; preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt; 20000; i++) { preparedStatement.setObject(1,"name_" + i); preparedStatement.execute(); } long end = System.currentTimeMillis(); System.out.println("花费的时间为：" + (end - start)); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62813de7e104dd568802e49623f6ce79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/326708d724fd99cd779bf73c8cf38abd/" rel="bookmark">
			html css javascript php js 相互关系,如何理解HTML、CSS、JavaScript之间的关系？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML、CSS、JavaScript是web前端开发核心的部分，那么它们三者之间有什么关系？下面本篇文章就来带大家了解一下HTML、CSS、JavaScript之间的关系，希望对大家有所帮助。
HTML、CSS和JavaScript的简单介绍
html(超文本标记语言)：用来描述网页的一种语言，定义网页的结构。可以包含图片，音乐等非文字元素。
CSS(层叠样式表)：定义如何显示 HTML 元素，描述网页的样子。
JavaScript(脚本语言)：是用来实现网页上的动态功能、特效效果，如动画，交互等。
最准确的网页设计思路是把网页分成三个层次，即：结构层(HTML)、表示层(CSS)、行为层(Javascript)。
1、结构层：决定网页的结构及内容，即“显示哪些内容”。
2、表示层：设计网页的表现样式，即“如何显示有关内容”
3、行为层：控制网页的行为(效果)，即“内容应该如何对事件做出反应”
HTML、CSS、JavaScript之间的关系
HTML构建网页的框架，基础；CSS设置页面元素的样式，美化网页；Javascript实现网页的动态功能，进行交互。
举个例子：HTML可以看做是一个房子的骨架，结构；CSS可以理解成房子的装修、粉刷等外观；Javascript理解为安装门窗、空调、电视等，一些功能性质的工作就得交给Javascript实现。
以上就是本篇文章的全部内容，希望能对大家的学习有所帮助。更多精彩内容大家可以关注php中文网相关教程栏目！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4edb8de7766ed5a1aea9e92988511f43/" rel="bookmark">
			pandas的factorize方法简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		factorize具体是做什么的，这个不好描述，先让我用个例子做个说明。
&gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; labels, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b']) &gt;&gt;&gt; labels array([0, 0, 1, 2, 0], dtype=int64) &gt;&gt;&gt; uniques array(['b', 'a', 'c'], dtype=object) 如上述代码，在对一个列表调用了fatorize方法后，返回了一个元祖。uniques返回的是对应列表去重后的值。labels返回的是列表中每个元素在uniques中的位置。
当然你还可以添加sort参数作为入参，默认会对uniques中的值进行排序
&gt;&gt;&gt; labels, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b'], sort=True) &gt;&gt;&gt; labels array([1, 1, 0, 2, 1]) &gt;&gt;&gt; uniques array(['a', 'b', 'c'], dtype=object) 如果列表中包含None，uniques会把他忽略掉，并在列表中标为-1
&gt;&gt;&gt; labels, uniques = pd.factorize(['b', None, 'a', 'c', 'b']) &gt;&gt;&gt; labels array([ 0, -1, 1, 2, 0]) &gt;&gt;&gt; uniques array(['b', 'a', 'c'], dtype=object) 哈哈，以上就是关于factorize函数的介绍，还是挺有用的。有兴趣欢迎关注python小工具，一起学习python和pandas
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc272aca3cb9b3555f626ebb88d796c/" rel="bookmark">
			ajax请求发送成功，后端没有响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前端请求状态200，但是后端无反应结果是以为我的登录拦截器把这个请求拦截了，
登录之后就发现后端有响应了
2021.4.1日常错误 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b2dde2d439427a4659a0e2953925fb/" rel="bookmark">
			ajax j向Java传递参数,ajax传递参数方式 以及java后台获取方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文本形式
/**
* 订单取消
* @return {Boolean} 处理是否成功
*/
function orderCancel(orderId, commant){
var flag = false;
$.ajax({
type: "POST",
url: "../order/orderCancel.action", //orderModifyStatus
data: {"orderId":orderId},
dataType:"text",
async:false,
cache:false,
success: function(data){
var member = eval("("+data+")"); //包数据解析为json 格式
if(member.success=="true"){
flag = true;
}else if(member.success=="false") {
alert(member.info);
}
},
error: function(json){
alert("订单取消异常，请刷新后重试...");
}
});
hidediv();
return flag;
}
单个参数 data ："orderId=" + orderId
多个参数：data: "orderId=" + orderId + "&amp;commant=" + commant
获取方式为 request.getParameter("orderId"); request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b2dde2d439427a4659a0e2953925fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b033a739a1bdf92571608122dfaa9e0/" rel="bookmark">
			北大申又枨继承鲁滨逊的创新数学思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		北京大学申又枨先生多年在教学第一线从事数学教育工作，对无穷小与无穷大在微积分教学领域中的重要作用有深入的理解，是一个真正的数学教育家。
1965年5月，鲁滨逊在《非标准分析》第一版前言中写道：”1960年秋，我想到了现代数理逻辑的概念和方法能够为运用无限小和无限大的数来叙述微积分学提供一个合适的框架。我先是在普林斯顿大学（1960年11月）的一个讨论班的报告中报告了我的想法。随后又在符号逻辑学会（1961年1月）年会的一次发言中，以及在一篇刊登在阿姆斯特丹皇家科学院院报的文章（Robinson [1961]）中，相继发表了我的想法。我把所得到这一课题叫做非标准分析，因为它包含有所谓算术的非标准模型，并且部分地是受到了后者的启发。算术的非标准模型的存在，首先是T. Skolem提出来的。
这些年来，非标准分析在若干方向上有了相当大的发展。因为直到目前为止，许多结果仅仅是在课程、讲义和复写的报告中提出来了，所以想到，专门为这一课题写一本书是适宜的。
几年来，在这个领域中，通过同一些同行们的讨论，活跃了我的思路。这里我想冒昧地提到的有：R. Arens，C. C. Chang， A. Erdelyi， A. Horn, G. Kreisel, I. Lakatos以及J.B. Rosser.特别要对W.A.J.Luxemburg表示感谢，他的关于非标准分析的演讲和讲义，对于使数学家们知道这一课题起了很大的作用。“
北京大学申又枨先生以高度数学敏感性认识到鲁滨逊在《非标准分析》中创新数学思想对我国数学教育改革的重要性。申又枨立即组织人力(张锦文、王世强、袁萌等)七位人士，主持鲁滨逊《非标准分析》的翻译工作。力挺中国数学教育的改革。
坦率的说，在当今互联网时代，我们的无穷小微积分网站把鲁滨逊《非标准分析》上线，供国内广大读者下载阅读。这是对鲁滨逊和申又枨先生数学思想的继承与发展。
袁萌
陈启清(代笔)
2021年03月29日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba650d392273cc3df6f193c19faafed/" rel="bookmark">
			vm.$el、vm.$children
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vm.$el用来访问vm实例使用的根DOM元素
{可以对整个DOM元素进行各种操作}
$children用来获取el根元素下的子组件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e8a82b09c7fe7eedec562fd7601984/" rel="bookmark">
			SpringBootTest注解测试service层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 使用@SpringBootTest注解对一个service进行单元测试，启动单元测试时会启动项目的上下文。相当于运行项目启动类后，再调用service的接口。
依赖：spring-boot-starter-test
生成单元测试类 选择要测试的serviceImpl，右键生成测试类，选择junit5
生成的测试类如下：
class UserPayServiceImplTest { @Test void pay() { } } 加入@SpringBootTest MyframeApplication对应项目的启动类。如果不写这个的话，下面的service就无法自动注入。
测试类启动时会先启动项目，再执行测试方法。也就是说测试类的测试依赖项目启动环境。
@SpringBootTest( /*MyframeApplication对应项目的启动类。如果不写这个的话，下面的service就无法自动注入。 测试类启动时会先启动项目，再执行测试方法。也就是说测试类的测试依赖项目启动环境。*/ classes = MyframeApplication.class, /*因为测试的是service,禁用web以加快项目启动速度*/ webEnvironment = WebEnvironment.NONE ) class UserPayServiceImplTest { @Autowired private UserPayService userPayService; //自动注入要测试的service @Test void pay() { userPayService.pay(new BigDecimal(300));// 测试接口方法 } } 执行测试：
成功通过测试类进入了实际代码的断点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc69335fdd0980c9364d279f909b396/" rel="bookmark">
			Duplicate key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：
java8 对象转 Map 时重复 key
处理：
//mergeFunction当keyMapper发生重复时处理的方法 Collectors.toMap(keyMapper, valueMapper, mergeFunction) 示例：
//1、重复时采用后面的value2 覆盖value1 List&lt;User&gt; userList = new ArrayList&lt;&gt;(); Map&lt;String, String&gt; userMap = userList.stream().collect(Collectors.toMap(User::getName, User::getPassword, (value1, value2 ) -&gt; value2)); //2、重复时采用后面的value2 覆盖value1 List&lt;User&gt; userList = new ArrayList&lt;&gt;(); Map&lt;String, String&gt; userMap = userList.stream().collect(Collectors.toMap(User::getName, User::getPassword, (value1, value2 )-&gt;{return value2;})); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b61e0771f17f2b1200d8037719e091/" rel="bookmark">
			matlab license code,MATLAB license file code
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%
INCREMENT Aerospace_Blockset MLM 99 permanent uncounted
\
A05070F00D1EB1F92326 VENDOR_STRING=QQ=47399897 HOSTID=ANY
\
ck=216 SN=888888 TS_OK
INCREMENT Aerospace_Toolbox MLM 99 permanent uncounted
\
6090F0C08395D4289512 VENDOR_STRING=QQ=47399897 HOSTID=ANY
\
ck=237 SN=888888 TS_OK
INCREMENT Bioinformatics_Toolbox MLM 99 permanent uncounted
\
40E0B0406DE56D23A426 VENDOR_STRING=QQ=47399897 HOSTID=ANY
\
ck=190 SN=888888 TS_OK
INCREMENT Cert_Kit_IEC MLM 99 permanent uncounted
\
9080309041D2DCCB2B10 VENDOR_STRING=QQ=47399897 HOSTID=ANY
\
ck=179 SN=888888 TS_OK
INCREMENT Communication_Blocks MLM 99 permanent uncounted
\
80E010304ACCEEB5E0AA VENDOR_STRING=QQ=47399897 HOSTID=ANY
\
ck=77 SN=888888 TS_OK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99b61e0771f17f2b1200d8037719e091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167f0ecd3329dc42a3f5d321ab590ea3/" rel="bookmark">
			【springboot】发送邮箱不能够连接到主机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在导出邮箱的时候发现服务器报错，但是在本地就没事，提示错误
nested exception is com.sun.mail.util.MailConnectException: Couldn't connect to host, port: smtp.qq.com, 25; timeout -1; nested exception is: java.net.ConnectException: Connection timed out (Connection timed out). Failed messages: com.sun.mail.util.MailConnectException: Couldn't connect to host, port: smtp.qq.com, 25; timeout -1; 发现是连接不到主机，百度问题发现是因为阿里云处于安全考虑，TCP 25 端口默认被封禁。
可以向阿里云申请解封，也可以改为ssl加密465端口发送
我这里是将端口改成了465
在yml文件中修改mail配置
spring: mail: host: smtp.qq.com userName: xxxx@qq.com passWord: 认证指令 default-encoding: UTF-8 properties: mail: smtp: auth: true starttls: enable: true required: true port: 465 protocol: smtps 我们加上一下两个就可以了
port: 465 protocol: smtps 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edd88fe99079eb570f045de9ebcfc88c/" rel="bookmark">
			eladmin框架学习总结（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目文件夹结构 -node_modules	依赖安装文件夹（要进行git忽略） -dist	build后的文件夹（要进行git忽略） -public 主要放置入口index.html文件和项目LOGO -src --api **请求api封装（封装请求-常用） --assets	静态资源 --components	**自定义组件封装（封装所需要的组件-常用） --router	**路由（路由跳转-常用） --store	vuex配置 --utils	通用工具封装 --views	**页面开发（主要的页面开发-常用） -App.vue	vue根页面 -main.js	vue全局配置 -settings.js	项目配置 -.env.development	开发环境配置 -.env.production	生产环境配置 -package.json	依赖配置 -vue.config.js vue项目环境配置文件 页面流程
import { mapGetters } from 'vuex' import CRUD, { presenter, header, form, crud } from '@crud/crud' // 默认表单，设置数据格式 最好与接口返回的格式一致，直接暴露，不要封装 const defaultForm = { id: null, username: null, // appId: null 自定义id字段，要在cruds 中添加idField } export default { name: 'User', components: { Treeselect, }, // 自定义的 property cruds() { // crud.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edd88fe99079eb570f045de9ebcfc88c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9fed907d984441c5ddf4cadf8fe2220/" rel="bookmark">
			Idea的Git如何回退到上一个版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、场景：准备开工，却pull到队友上传的报错的代码，导致项目全部报错。这时，想让一切回到pull之前 二、直接使用Idea，找到对应的版本，合并到本地即可。如下图 1、右击项目 -&gt; Git -&gt; Show History 2、点击Log -&gt; 右击需要回退的版本 -&gt; Reset Current Branch to Here... 3、Hrad （但是要根据自己的需要来选） 补充：翻译
三、另一种做法：使用命令 在本地项目文件夹打开 git ：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/592ec187cd10cde2ef485dcc2c697490/" rel="bookmark">
			PL/SQL之包的创建和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PL/SQL之包的创建和应用 一 引言 包是一组相关**过程、函数、变量、常量和游标**等 PL/SQL 程序设计元素的**组合** ，它具有面向对象程序设计语言的特点，是对这些 PL/SQL 程序 设计元素的封装。 **包类似于 C++ 和 JAVA 语言中的类，其中变量相当于类中的成员变量，过程和函数相当于类方法** 。把相关的模块归类成为包， 可使开发人员利用面向对象的方法进行存储过程的开发，从而提高系统性能 。 与类相同， 包中的程序元素也分为**公用元素和私用元素**两种 ，这两种元素的区别是他们允许访问的程序范围不同，即它们的作用域不同。 公用元素 不仅可以被包中的函数、过程所调用，也可以被包外的 PL/SQL程序访问，而 私有元素 只能被包内的函数和过程序所访问。 在 PL/SQL 程序设计中，使用包不仅可以使程序设计模块化，对外隐藏 包内所使用的信息（通过使用私用变量），而 且 可以提高程序的执行效率。因为，当程序首次调用包内函数或过程时， ORACLE 将整个包调入内存，当再次访问包内元素时， ORACLE 直接从内存中读取，而不需要进行磁盘 I/O 操作，从而使程序执行效率得到提高。 一个包由两个分开的部分组成
包定义 （PACKAGE ）：包定义部分声明包内数据类型、变量、常量、游标、子程序和异常错误处理等元素，这些元素为包的公有元素。
包主体 （PACKAGE BODY ）：包主体则是包定义部分的具体实现，它定义了包定义部分 所声明的游标和子程序，在包主体中还可以声明包的私有元素。
包定义和包主体分开编译 ，并作为两部分分开的对象存放在数据库字典中，详见数据字典 user_source,all_source, dba_source.
二 包的定义 1 语法
(1) 创建包定义
CREATE [OR REPLACE ] PACKAGE package_name [AUTHID {CURRENT_USER | DEFINER}] {IS | AS} [公有数据类型定义 公有数据类型定义] [公有游标声明 公有游标 声明] [公有变量、常量声明 公有变量、常量声明] [公有子程序声明 公有子程序声明] END [package_name] （2）创建包主体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/592ec187cd10cde2ef485dcc2c697490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5adefcf6bd96e1645206d30fd42ab9e/" rel="bookmark">
			学习IPFS&#43;区块链(前奏) — ubuntu安装ipfs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家带来的是安装ipfs 至于ipfs是什么，大家自行百度!
关于安装ipfs有两种方法。 第一种：直接去官方安装提示直接一步一步来
官网地址：https://ipfs.io/#install
第二种，就看我这个懒人操作了
直接打开终端输入：
ipfs version 重点来了，你肯定没安装啊，没安装肯定提示你啊！
按照Ubuntu的提示一步一步安装就行了。
友情提醒，在安装ipfs时还是要安装一些环境的，具体环境像npm之类的都要装上，不认肯定会报错的。
注意跨域资源共享CORS配置（这是我是Ubuntu系统，win10命令应该不一样）
ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods '["PUT", "GET", "POST", "OPTIONS"]' ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["*"]' ipfs config --json API.HTTPHeaders.Access-Control-Allow-Credentials '["true"]' ipfs config --json API.HTTPHeaders.Access-Control-Allow-Headers '["Authorization"]' ipfs config --json API.HTTPHeaders.Access-Control-Expose-Headers '["Location"]' 五条命令依次输入进去
这里我们通过网站（http://127.0.0.1:5001/webui）打开ipfs！
安装有问题随时留言！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6bc5880ad4688068bf4ee5fd354e2d8/" rel="bookmark">
			Python将字符串时间进行加一天（datetime模块）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构造一个dataframe数据结构：
import pandas as pd list1 = ['2021-03-17','2021-03-17'] list2 = ['zhangsan','lisi'] dict1 = {"date":list1,"name":list2] df1 = pd.Dataframe(dict) 然后我们取dataframe的date索引下的第一个时间来做时间加减操作。
import datetime from datetime import datetime as d1 s1 = df1['date'][0] + " 08:00:00" //2021-03-17 08:00:00 null_date = (d1.strptime(s1, '%Y-%m-%d %H:%M:%S') + datetime.timedelta(days=1)).strftime("%Y-%m-%d %H:%M:%S") print(null_date) //2021-03-18 08:00:00 这样就实现了时间向前加一天的操作。这里唯一要注意的就是直接引入datetime模块和从datetime模块中引入datetime模块是不同的，import导入的时，需要使用模块名的限定。如果不加模块名限定，就会报错。而from import则不需要加入模块名的限定。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/93/">«</a>
	<span class="pagination__item pagination__item--current">94/134</span>
	<a class="pagination__item pagination__item--next btn" href="/page/95/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>