<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java设计模式简介、设计模式原则及分类 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/c28d40ccffee9b93c1707978dccc983c/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Java设计模式简介、设计模式原则及分类">
  <meta property="og:description" content="CSDN话题挑战赛第2期
参赛话题：学习笔记
目录
一、Java设计模式简介
二、设计模式原则
三、设计模式分类
一、Java设计模式简介 在软件工程中，设计模式是对软件设计中普遍存在的各种问题，所提出的解决方案。
换句话说，设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计的经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性。
二、设计模式原则 1、开闭原则（Open Close Principle）
开闭原则的意思是： 对扩展开放，对修改封闭 。在程序需要进行扩展的时候，不能去修改或影响原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性更好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。
2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当子类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而且子类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则通俗来讲就是:子类可以扩展父类的功能,但不能改变父类原有的功能
3、依赖倒转原则（Dependence Inversion Principle）
这个原则是开闭原则的基础，核心内容：针对接口编程，高层模块不应该依赖底层模块，二者都应该依赖抽象而不依赖于具体。
4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个庞大的接口要好。其目的在于降低耦合度。由此可见，其实设计模式就是从大型软件架构出发，便于升级和维护软件的设计思想。它强调低依赖、低耦合。
5、单一职责原则（Single Responsibility Principle）
类的职责要单一，不能将太多的职责放在一个类中。
可能有的人会觉得单一职责原则和前面的接口隔离原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要约束的是类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。
6、最少知道原则（Demeter Principle）
最少知道原则也叫迪米特法则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。一个对象应该对其他对象保持最少的了解。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。所以在类的设计上，每一个类都应当尽量降低成员的访问权限。
7、合成复用原则（Composite Reuse Principle）
合成复用原则就是在一个新的对象里通过关联关系（组合关系、聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，尽量多使用 组合/聚合 的方式，尽量少使用甚至不使用继承关系。
三、设计模式分类 通常来说设计模式分为三大类：
● 创建型模式，共 5 种：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。
● 结构型模式，共 7 种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
● 行为型模式，共 11 种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
下面用图片来整体描述一下设计模式之间的关系：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-09-27T20:03:51+08:00">
    <meta property="article:modified_time" content="2022-09-27T20:03:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java设计模式简介、设计模式原则及分类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://marketing.csdn.net/p/7b6697fd9dd3795a268d1a6f2fe75012" title="CSDN话题挑战赛第2期">CSDN话题挑战赛第2期</a><br> 参赛话题：<a href="https://activity.csdn.net/creatActivity?id=10213" rel="nofollow" title="学习笔记">学习笔记</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B" rel="nofollow">一、Java设计模式简介</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99" rel="nofollow">二、设计模式原则</a></p> 
<p id="%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB" rel="nofollow">三、设计模式分类</a></p> 
<hr id="hr-toc"> 
<h2>一、Java设计模式简介</h2> 
<p>在软件工程中，设计模式是对软件设计中普遍存在的各种问题，所提出的解决方案。</p> 
<p>换句话说，设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计的经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99">二、设计模式原则</h2> 
<p><strong>1、开闭原则（Open Close Principle）</strong></p> 
<p>开闭原则的意思是：<span style="color:#fe2c24;"><strong><span style="background-color:#f3f3f4;"> 对扩展开放，对修改封闭</span></strong></span> 。在程序需要进行扩展的时候，不能去修改或影响原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性更好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p> 
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p> 
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当子类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而且子类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则通俗来讲就是:<strong><span style="color:#ff9900;"><span style="background-color:#f3f3f4;">子类可以扩展父类的功能,但不能改变父类原有的功能</span></span></strong></p> 
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p> 
<p>这个原则是开闭原则的基础，核心内容：针对接口编程，高层模块不应该依赖底层模块，二者都应该依赖抽象而不依赖于具体。</p> 
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p> 
<p>这个原则的意思是：使用多个隔离的接口，比使用单个庞大的接口要好。其目的在于降低耦合度。由此可见，其实设计模式就是从大型软件架构出发，便于升级和维护软件的设计思想。它强调<span style="color:#fe2c24;"><strong><span style="background-color:#f3f3f4;">低依赖、低耦合</span></strong></span>。</p> 
<p><strong>5、单一职责原则（Single Responsibility Principle）</strong></p> 
<p>类的职责要单一，不能将太多的职责放在一个类中。</p> 
<p>可能有的人会觉得单一职责原则和前面的接口隔离原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，<span style="color:#ff9900;"><strong><span style="background-color:#f3f3f4;">单一职责原则主要约束的是</span></strong></span>类，其次才是接口和方法，它针对的是程序中的实现和细节；而<strong><span style="color:#ff9900;"><span style="background-color:#f3f3f4;">接口隔离原则主要约束接口</span></span></strong>，主要针对抽象，针对程序整体框架的构建。</p> 
<p><strong>6、最少知道原则（Demeter Principle）</strong></p> 
<p>最少知道原则也叫迪米特法则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。一个对象应该对其他对象保持最少的了解。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。所以在类的设计上，每一个类都应当尽量降低成员的访问权限。</p> 
<p><strong>7、合成复用原则（Composite Reuse Principle）</strong></p> 
<p>合成复用原则就是在一个新的对象里通过关联关系（组合关系、聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，尽量多使用 组合/聚合 的方式，尽量少使用甚至不使用继承关系。</p> 
<h2 id="%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB">三、设计模式分类</h2> 
<p>通常来说设计模式分为三大类：</p> 
<blockquote> 
 <p>● <strong>创建型模式</strong>，共 5 种：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br> ● <strong>结构型模式</strong>，共 7 种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br> ● <strong>行为型模式</strong>，共 11 种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p> 
</blockquote> 
<p>下面用图片来整体描述一下设计模式之间的关系：</p> 
<p><img alt="" height="664" src="https://images2.imgbox.com/55/69/kTksg93A_o.png" width="572"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/223b4422c98ddabfb2fa37e9dcdb3c9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OPLS-DA的S-plot图可视化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/276360d59512d3c32c8a2e6c1d30e075/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Security 登录获取用户信息流程分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>