<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kotlin-47.Kotlin调用JavaScript(Call JavaScript from Kotlin) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/347fa8c1f8738ab00b02a2c5974401b7/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Kotlin-47.Kotlin调用JavaScript(Call JavaScript from Kotlin)">
  <meta property="og:description" content="官方文档: http://kotlinlang.org/docs/reference/js-interop.html
1.Kotlin调用JavaScript(Calling JavaScript from Kotlin) Kotlin被设计能够与Java平台轻松互操作,kotlin可将Java类转为Kotlin类,Java也将Kotlin类转为Java类! 但JavaScript是一种动态类型语言,意味着不会在编译期检查类型,可以在Kotlin中与JavaScript自由交流, 但如果想用Kotlin类型系统全部功能,需要在JavaScript库创建Kotlin头文件! 2.内联JavaScript(Inline JavaScript) 可用js(&#34;JavaScript代码&#34;)函数将JavaScript代码嵌入到Kotlin代码中: fun jsTypeOf(o: Any): String { return js(&#34;typeof o&#34;) } js(&#34;...&#34;)函数参数必须是字符串常量,因此以下代码错误: fun jsTypeOf(o: Any): String { return js(getTypeof() &#43; &#34; o&#34;) // 此处报错 } fun getTypeof() = &#34;typeof&#34; 3.external修饰符(external modifier) 用external修饰符来标记,通知Kotlin某个声明是用纯JavaScript编写! 编译器会认为被修饰的类/函数/属性的具体实现由开发人员提供,不会在声明中生成任何JavaScript代码, 因此external声明应该没有代码体内容,例如: // 以下声明都没有代码体,具体代码由JavaScript提供 external fun alert(message: Any?): Unit external val window: Window external class Node { //external修饰符会被继承,即Node类的成员函数和属性前不需要添加external val firstChild: Node fun append(child: Node): Node fun removeChild(child: Node): Node } 提示: external修饰符只允许在包级声明中使用(package-level) 4.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2017-07-21T23:41:44+08:00">
    <meta property="article:modified_time" content="2017-07-21T23:41:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kotlin-47.Kotlin调用JavaScript(Call JavaScript from Kotlin)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>官方文档: <a href="http://kotlinlang.org/docs/reference/js-interop.html" rel="nofollow noopener noreferrer" target="_blank">http://kotlinlang.org/docs/reference/js-interop.html</a></p> 
<h3 id="1kotlin调用javascriptcalling-javascript-from-kotlin">1.Kotlin调用JavaScript(Calling JavaScript from Kotlin)</h3> 
<pre><code>Kotlin被设计能够与Java平台轻松互操作,kotlin可将Java类转为Kotlin类,Java也将Kotlin类转为Java类!
但JavaScript是一种动态类型语言,意味着不会在编译期检查类型,可以在Kotlin中与JavaScript自由交流,
但如果想用Kotlin类型系统全部功能,需要在JavaScript库创建Kotlin头文件!
</code></pre> 
<h3 id="2内联javascriptinline-javascript">2.内联JavaScript(Inline JavaScript)</h3> 
<pre><code>可用js("JavaScript代码")函数将JavaScript代码嵌入到Kotlin代码中:
    fun jsTypeOf(o: Any): String {
        return js("typeof o")
    }

js("...")函数参数必须是字符串常量,因此以下代码错误:
    fun jsTypeOf(o: Any): String {
        return js(getTypeof() + " o") // 此处报错
    }
    fun getTypeof() = "typeof"
</code></pre> 
<h3 id="3external修饰符external-modifier">3.external修饰符(external modifier)</h3> 
<pre><code>用external修饰符来标记,通知Kotlin某个声明是用纯JavaScript编写!
编译器会认为被修饰的类/函数/属性的具体实现由开发人员提供,不会在声明中生成任何JavaScript代码,
因此external声明应该没有代码体内容,例如:
    // 以下声明都没有代码体,具体代码由JavaScript提供
    external fun alert(message: Any?): Unit
    external val window: Window
    external class Node {
        //external修饰符会被继承,即Node类的成员函数和属性前不需要添加external
        val firstChild: Node

        fun append(child: Node): Node

        fun removeChild(child: Node): Node
    }
提示: external修饰符只允许在包级声明中使用(package-level)
</code></pre> 
<h3 id="4声明类的静态成员declaring-static-members">4.声明类的静态成员(Declaring static members)</h3> 
<pre><code>在JavaScript中可以在原型(prototype)或者类(class)本身上定义成员:
    function MyClass() {
    }

    MyClass.sharedMember = function() {            
    };

    MyClass.prototype.ownMember = function() {            
    };

Kotlin没有这样的语法,但Kotlin有伴生对象(companion object),假定伴生对象的成员就是该类自身的成员:
    external class MyClass {
        companion object {
            fun sharedMember()
        }

        fun ownMember()
    }
</code></pre> 
<h3 id="5声明可选参数declaring-optional-parameters">5.声明可选参数(Declaring optional parameters)</h3> 
<pre><code>一个外部(external)函数有可选参数,但Kotlin无法知道JavaScript是如何计算这些参数的默认值,
因此在Kotlin中不能使用常用语法声明这些默认参数,应该使用以下语法:
    external fun myFunWithOptionalArgs(x: Int,
        y: String = definedExternally,
        z: Long = definedExternally)
    // y, z 参数默认值由JavaScript代码算出(definedExternally在外部定义)
</code></pre> 
<h3 id="6扩展javascript类extending-javascript-class">6.扩展JavaScript类(Extending JavaScript class)</h3> 
<pre><code>扩展JavaScript类很容易,因为它们都是Kotlin类,只需定义一个external类,并用非external类扩展,例如:
    external open class HTMLElement : Element() {

    }

    class CustomElement : HTMLElement() {
        fun foo() {
            alert("bar")
        }
    }

一些限制:
    1.当一个外部(external)基类的函数被签名重载时,不能在派生类(子类)中覆盖它;
    2.不能覆盖一个使用默认参数的函数;
    注意: 不能用external类扩展非external类!
</code></pre> 
<h3 id="7external接口external-interface">7.external接口(external interface)</h3> 
<pre><code>JavaScript没有接口的概念,当函数期望其参数支持方法时,只能传递含有这些方法的对象;
对于静态类型的Kotlin,可以使用外部(external)接口,例如:
    external interface HasFooAndBar {
        fun foo()

        fun bar()
    }

    // 传递含有foo和bar方法的HasFooAndBar
    external fun myFunction(p: HasFooAndBar)

外部(external)接口的另一个使用场景是描述设置对象(settings objects),例如:
    external interface JQueryAjaxSettings {
        var async: Boolean
        var cache: Boolean
        var complete: (JQueryXHR, String) -&gt; Unit
    }

    fun JQueryAjaxSettings(): JQueryAjaxSettings = js("{}")

    external class JQuery {
        companion object {
            fun get(settings: JQueryAjaxSettings): JQueryXHR
        }
    }

    fun sendQuery() {
        JQuery.get(JQueryAjaxSettings().apply {
            complete = { (xhr, data) -&gt;
                window.alert("Request complete")
            }
        })
    }

外部(external)接口的一些限制:
    1.它们不能在is检查操作符的右侧使用;
    2.as转换为external接口总是成功(在编译时产生警告);
    3.它们不能作为具体化类型参数(reified type)传递;
    4.它们不能用在类的字面值(literal)表达式(例如 I::class)中;
</code></pre> 
<p>简书：<a href="http://www.jianshu.com/p/d7259e03bd72" rel="nofollow">http://www.jianshu.com/p/d7259e03bd72</a> <br> CSDN博客: <a href="http://blog.csdn.net/qq_32115439/article/details/75675844">http://blog.csdn.net/qq_32115439/article/details/75675844</a> <br> GitHub博客: <a href="http://lioil.win/2017/07/21/Kotlin-jsInKotlin.html" rel="nofollow">http://lioil.win/2017/07/21/Kotlin-jsInKotlin.html</a> <br> Coding博客: <a href="http://c.lioil.win/2017/07/21/Kotlin-jsInKotlin.html" rel="nofollow">http://c.lioil.win/2017/07/21/Kotlin-jsInKotlin.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f6a5c8c5c0f25f040aa94dc08f93ae4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习-模型的评估与选择</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08e7e673ee66153b585e304b82639c8f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AndroidStudio安装配置教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>