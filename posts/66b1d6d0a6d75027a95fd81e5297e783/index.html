<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue中的key - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/66b1d6d0a6d75027a95fd81e5297e783/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Vue中的key">
  <meta property="og:description" content="简版 概念：页面上的标签都对应具体的虚拟 dom 对象(虚拟 dom 就是 js 对象), 循环中 ,如果没有唯一 key , 页面上删除一条标签, 由于并不知道删除的是哪一条! 所以要把全部虚拟 dom 重新渲染, 如果知道 key 为对应标签被删除掉, 只需要把渲染的 dom 为对应标签去掉即可!
作用：更准确、更快速、提高效率
Key 是什么 key 的作用主要是为了高效的更新虚拟 DOM
我们知道状态的变化会导致视图的更新，其中的更具体的过程是：
状态1 —&amp;gt; 虚拟dom1 ——&amp;gt; 视图1, 状态2 —&amp;gt; 虚拟dom2 ---&amp;gt; ？ 比较虚拟dom1和虚拟dom2的区别，然后在 视图1的基础上小范围更新视图得到视图2 key 是给每一个 vnode 的唯一 id，也是 diff 的一种优化策略，可以根据 key，更准确， 更快的找到对应的 vnode 节点,这个 key 的作用是用来加速这个比较的过程的。
开始之前，我们先还原两个实际工作场景
当我们在使用v-for时，需要给单元加上key &amp;lt;ul&amp;gt; &amp;lt;li v-for=&#34;item in items&#34; :key=&#34;item.id&#34;&amp;gt;...&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 用&#43;new Date()生成的时间戳作为key，手动强制触发重新渲染 &amp;lt;Comp :key=&#34;&#43;new Date()&#34; /&amp;gt; 那么这背后的逻辑是什么，key的作用又是什么？">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-01-05T22:04:32+08:00">
    <meta property="article:modified_time" content="2023-01-05T22:04:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue中的key</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_1"></a>简版</h3> 
<p>概念：页面上的标签都对应具体的虚拟 dom 对象(虚拟 dom 就是 js 对象), 循环中 ,如果没有唯一 key , 页面上删除一条标签, 由于并不知道删除的是哪一条! 所以要把全部虚拟 dom 重新渲染, 如果知道 key 为对应标签被删除掉, 只需要把渲染的 dom 为对应标签去掉即可!</p> 
<p>作用：更准确、更快速、提高效率</p> 
<h3><a id="Key__6"></a>Key 是什么</h3> 
<blockquote> 
 <p>key 的作用主要是为了高效的更新虚拟 DOM</p> 
</blockquote> 
<p>我们知道状态的变化会导致视图的更新，其中的更具体的过程是：</p> 
<pre><code>状态1 —&gt; 虚拟dom1 ——&gt; 视图1,
状态2 —&gt; 虚拟dom2  ---&gt;   ？

比较虚拟dom1和虚拟dom2的区别，然后在 视图1的基础上小范围更新视图得到视图2
</code></pre> 
<p>key 是给每一个 vnode 的唯一 id，也是 diff 的一种优化策略，可以根据 key，更准确， 更快的找到对应的 vnode 节点,这个 key 的作用是用来加速这个比较的过程的。</p> 
<p>开始之前，我们先还原两个实际工作场景</p> 
<ol><li>当我们在使用<code>v-for</code>时，需要给单元加上<code>key</code></li></ol> 
<pre><code>&lt;ul&gt;
    &lt;li v-for="item in items" :key="item.id"&gt;...&lt;/li&gt;
&lt;/ul&gt;
</code></pre> 
<ol start="2"><li>用<code>+new Date()</code>生成的时间戳作为<code>key</code>，手动强制触发重新渲染</li></ol> 
<pre><code>&lt;Comp :key="+new Date()" /&gt;
</code></pre> 
<p>那么这背后的逻辑是什么，<code>key</code>的作用又是什么？</p> 
<p>一句话来讲</p> 
<blockquote> 
 <p>key 是给每一个 vnode 的唯一 id，也是 diff 的一种优化策略，可以根据 key，更准确， 更快的找到对应的 vnode 节点</p> 
</blockquote> 
<h3><a id="_39"></a>背后的逻辑</h3> 
<p>当我们在使用<code>v-for</code>时，需要给单元加上<code>key</code></p> 
<ul><li>如果不用 key，Vue 会采用就地复地原则：最小化 element 的移动，并且会尝试尽最大程度在同适当的地方对相同类型的 element，做 patch 或者 reuse。</li><li>如果使用了 key，Vue 会根据 keys 的顺序记录 element，曾经拥有了 key 的 element 如果不再出现的话，会被直接 remove 或者 destoryed</li></ul> 
<p>用<code>+new Date()</code>生成的时间戳作为<code>key</code>，手动强制触发重新渲染</p> 
<ul><li>当拥有新值的 rerender 作为 key 时，拥有了新 key 的 Comp 出现了，那么 key Comp 会被移除，新 key Comp 触发渲染</li></ul> 
<h3><a id="_key__key__50"></a>设置 key 与不设置 key 区别</h3> 
<p>举个例子：</p> 
<p>创建一个实例，2 秒后往<code>items</code>数组插入数据</p> 
<pre><code>&lt;body&gt;
  &lt;div id="demo"&gt;
    &lt;p v-for="item in items" :key="item"&gt;{<!-- -->{item}}&lt;/p&gt;
  &lt;/div&gt;

  &lt;p&gt;c&lt;/p&gt;
  &lt;script src="../../dist/vue.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    // 创建实例
    const app = new Vue({
      el: '#demo',
      data: { items: ['a', 'b', 'c', 'd', 'e'] },
      mounted() {
        setTimeout(() =&gt; {
          this.items.splice(2, 0, 'f') // ['a', 'b', 'f', 'c',, d', 'e']
        }, 2000)
      },
    })
  &lt;/script&gt;
&lt;/body&gt;
</code></pre> 
<p>在不使用<code>key</code>的情况，<code>vue</code>会进行这样的操作：</p> 
<p><img src="https://images2.imgbox.com/56/32/rcB3Gt9s_o.png" alt="image.png"></p> 
<p>分析下整体流程：</p> 
<ul><li>比较 A，A，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li><li>比较 B，B，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li><li>比较 C，F，相同类型的节点，进行<code>patch</code>，数据不同，发生<code>dom</code>操作</li><li>比较 D，C，相同类型的节点，进行<code>patch</code>，数据不同，发生<code>dom</code>操作</li><li>比较 E，D，相同类型的节点，进行<code>patch</code>，数据不同，发生<code>dom</code>操作</li><li>循环结束，将 E 插入到<code>DOM</code>中</li></ul> 
<p>一共发生了 3 次更新，1 次插入操作</p> 
<p>在使用<code>key</code>的情况：<code>vue</code>会进行这样的操作：</p> 
<ul><li> <p>比较 A，A，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</p> </li><li> <p>比较 B，B，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</p> </li><li> <p>比较 C，F，不相同类型的节点</p> 
  <ul><li>比较 E、E，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li></ul> </li><li> <p>比较 D、D，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</p> </li><li> <p>比较 C、C，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</p> </li><li> <p>循环结束，将 F 插入到 C 之前</p> </li></ul> 
<p>一共发生了 0 次更新，1 次插入操作</p> 
<p>通过上面两个小例子，可见设置<code>key</code>能够大大减少对页面的<code>DOM</code>操作，提高了<code>diff</code>效率</p> 
<h4><a id="_key__diff__111"></a>设置 key 值一定能提高 diff 效率吗？</h4> 
<p>其实不然，文档中也明确表示</p> 
<blockquote> 
 <p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素</p> 
</blockquote> 
<p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</p> 
<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升</p> 
<h3><a id="_121"></a>原理分析</h3> 
<p>源码位置：core/vdom/patch.js</p> 
<p>这里判断是否为同一个<code>key</code>，首先判断的是<code>key</code>值是否相等如果没有设置<code>key</code>，那么<code>key</code>为<code>undefined</code>，这时候<code>undefined</code>是恒等于<code>undefined</code></p> 
<pre><code>function sameVnode(a, b) {
  return (
    a.key === b.key &amp;&amp;
    ((a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b)) ||
      (isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error)))
  )
}
</code></pre> 
<p><code>updateChildren</code>方法中会对新旧<code>vnode</code>进行<code>diff</code>，然后将比对出的结果用来更新真实的<code>DOM</code></p> 
<pre><code>function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    ...
    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {
        if (isUndef(oldStartVnode)) {
            ...
        } else if (isUndef(oldEndVnode)) {
            ...
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
            ...
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
            ...
        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
            ...
        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
            ...
        } else {
            if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
            idxInOld = isDef(newStartVnode.key)
                ? oldKeyToIdx[newStartVnode.key]
                : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
            if (isUndef(idxInOld)) { // New element
                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
            } else {
                vnodeToMove = oldCh[idxInOld]
                if (sameVnode(vnodeToMove, newStartVnode)) {
                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
                    oldCh[idxInOld] = undefined
                    canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
                } else {
                    // same key but different element. treat as new element
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
                }
            }
            newStartVnode = newCh[++newStartIdx]
        }
    }
    ...
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6296eaf8526a5e1b61c655d060a0a4cf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java8的四大函数式接口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f814c08517b43fbe38a998205ad7ae2b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安装Hadoop集群（超详细！）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>