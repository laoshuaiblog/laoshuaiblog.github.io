<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实现无头单链表的基本操作 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/97dbffcc6253bbbec86a6970416944ac/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="实现无头单链表的基本操作">
  <meta property="og:description" content="无头指针的单链表的结构 创建一个节点类，一个初始链表 static class Node { public int val;//存储的数据 public Node next;//存储下一个节点的地址 public Node (int val) { this.val = val; } } public Node head;// 代表当前链表的头节点的引用 //初始单链表 public void createLink() { Node node1 = new Node(12); Node node2 = new Node(45); Node node3 = new Node(23); Node node4 = new Node(90); node1.next = node2; node2.next = node3; node3.next = node4; /* */ head = node1; } 打印链表，遍历链表 Node cur = head; 的作用是为了实现“滴滴代跑”，防止遍历一遍以后head==null找不到头结点了。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-01-04T18:34:19+08:00">
    <meta property="article:modified_time" content="2023-01-04T18:34:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实现无头单链表的基本操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>无头指针的单链表的结构</h2> 
<p><img alt="" height="398" src="https://images2.imgbox.com/90/ff/Ze0FTRX9_o.png" width="1044"></p> 
<h2>创建一个节点类，一个初始链表</h2> 
<pre><code class="language-java">static class Node {
        public int val;//存储的数据
        public Node next;//存储下一个节点的地址

        public Node (int val) {
            this.val = val;
        }
    }

    public Node head;// 代表当前链表的头节点的引用

//初始单链表
    public void createLink() {
        Node node1 = new Node(12);
        Node node2 = new Node(45);
        Node node3 = new Node(23);
        Node node4 = new Node(90);
        node1.next = node2;
        node2.next = node3;
        node3.next = node4; /* */
        head = node1;
    }</code></pre> 
<h2>打印链表，遍历链表</h2> 
<blockquote> 
 <p>Node cur = head;   的作用是为了实现“滴滴代跑”，防止遍历一遍以后head==null找不到头结点了。</p> 
 <p>过程：设置一个cur，代替head</p> 
 <p>用循环去遍历数组，循环条件，cur不为空</p> 
</blockquote> 
<pre><code class="language-java"> public void display() {
        Node cur = head;

        //如果说 把整个链表 遍历完成 那么 就需要 head == null
        // 如果说 你遍历到链表的尾巴  head.next == null
        
        while (cur != null) {
            System.out.print(cur.val+" ");
            cur = cur.next;
        }
        System.out.println();
    }</code></pre> 
<h2>查找是否包含关键字key是否在单链表当中</h2> 
<blockquote> 
 <p>过程：</p> 
 <p>1.用循环去遍历数组，循环条件，cur不为空</p> 
 <p>2.用if去判断 链表元素是否等于关键字</p> 
</blockquote> 
<pre><code class="language-java">public boolean contains(int key){
        Node cur = head;
        while (cur != null) {
            if(cur.val == key) {
                return true;
            }
            cur = cur.next;
        }
        return false;
    }</code></pre> 
<h2>得到单链表的长度 ，时间复杂度O(N)</h2> 
<blockquote> 
 <p>过程：</p> 
 <p>1.用循环去遍历数组，循环条件，cur不为空</p> 
 <p>2.用count在循环中计数</p> 
</blockquote> 
<pre><code class="language-java">public int size(){
        int count = 0;
        Node cur = head;
        while (cur != null) {
            count++;
            cur = cur.next;
        }
        return count;
    }
</code></pre> 
<h2>头插法插入数据，时间复杂度 O(1)</h2> 
<blockquote> 
 <p>过程：</p> 
 <p>1.创建一个新的结点</p> 
 <p>2.把head连接在新节点后面</p> 
 <p>3.新节点成为新的head</p> 
</blockquote> 
<p></p> 
<p><img alt="" height="776" src="https://images2.imgbox.com/0e/5a/j26337xK_o.png" width="1200"></p> 
<pre><code class="language-java">public void addFirst(int data){
        Node node = new Node(data);
        node.next = head;
        head = node;
    }</code></pre> 
<h2>尾插法插入数据，时间复杂度 O(N)</h2> 
<blockquote> 
 <p>过程：</p> 
 <p>1.创建新节点</p> 
 <p>2.判断表是否为空，如果是，插入的元素就是表头</p> 
 <p>3.查找最后一个元素，用循环去遍历数组，循环条件，cur的下一个不为空</p> 
 <p>4.找到以后将node作为cur的下一个</p> 
</blockquote> 
<p><img alt="" height="426" src="https://images2.imgbox.com/bb/c6/s00hQzGZ_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-java">public void addLast(int data){
        Node node = new Node(data);
//判断此链表是否为空表，如果是，插入的元素就是表头
        if(head == null) {
            head = node;
            return;
        }
        Node cur = head;
//找链表的最后一个元素
        while (cur.next != null) {
            cur = cur.next;
        }
        cur.next = node;
    }</code></pre> 
<h2>任意位置插入</h2> 
<blockquote> 
 <p>1.判断位置是否合法<br> 2.实现插入位置为0用头插法，插入位置在最后用尾插法<br> 3.寻找插入位置，（需要找到index的前一个）实现查找插入位置的方法：用count计数，用循环判断cur的值是否是需要的值<br> 4.实现插入</p> 
 <p>注：因为插入的语法 node.next = cur.next;    cur.next = node;（看图示），所以查找插入位置时需要找到index的前一位</p> 
</blockquote> 
<p></p> 
<p><img alt="" height="679" src="https://images2.imgbox.com/e5/70/xrbrtT0r_o.png" width="1054"></p> 
<p></p> 
<pre><code class="language-java">  public void addIndex(int index,int data)
            throws ListIndexOutOfException{
//判断插入位置的下标是否合法，不合法抛出异常
        checkIndex(index);
//插入位置为0，直接用头插法
        if(index == 0) {
            addFirst(data);
            return;
        }
//插入位置在最后，直接用尾插法
        if(index == size()) {
            addLast(data);
            return;
        }

//找到插入的位置，进行插入
        Node cur = findIndexSubOne(index);
        Node node = new Node(data);
        node.next = cur.next;
        cur.next = node;
    }

//查找插入位置的方法
private Node findIndexSubOne(int index) {
        Node cur = head;
        int count = 0;
        while (count != index-1) {   // 需要找到插入位置的前一位
            cur = cur.next;
            count++;      
        }
        return cur;
    }

//判断位置合不合法的方法
    private void checkIndex(int index) throws ListIndexOutOfException{
        if(index &lt; 0 || index &gt; size()) {
            throw new ListIndexOutOfException("index位置不合法");
        }
    }</code></pre> 
<h2></h2> 
<h2>删除第一次出现关键字为key的节点，时间复杂度 O(N)</h2> 
<p><img alt="" height="744" src="https://images2.imgbox.com/92/29/8lmcUC2N_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-java">public void remove(int key){

        if(head == null) {
            return ;//一个节点都没有
        }
        if(head.val == key) {
            head = head.next;    //头结点的值就是要找的值
            return;
        }
        Node cur = searchPrev(key);  //key的前一个节点
        if(cur == null) {
            return;
        }
        Node del = cur.next;//要删除的节点
        cur.next = del.next;
    }
    /*
 找到关键字key的前一个节点的方法
     */
    private Node searchPrev(int key) {
        Node cur = head;
        while (cur.next != null) {
            if(cur.next.val == key) {
                return cur;
            }
            cur = cur.next;
        }
        return null;//没有你要删除的节点
    }
</code></pre> 
<h2>删除所有值为key的节点</h2> 
<blockquote> 
 <p>用双指针，两个指针，pre,cur,pre在处cur后面（看图）<br> 1.判断链表是否为空<br> 2.创建两个指针<br> 3.用循环查找key，分两种情况移动指针<br> 4.判断head的值是否为key</p> 
</blockquote> 
<p><img alt="" height="615" src="https://images2.imgbox.com/ea/c4/Fh8zCARO_o.png" width="1035"></p> 
<p></p> 
<pre><code class="language-java">//用双指针的方法

public void removeAllKey(int key){
        if(head == null) {
            return;
        }
        /*while(head.val == key) {
            head = head.next;
        }*/
        Node prev = head;
        Node cur = head.next;
        while (cur != null) {
            if(cur.val == key) {
                prev.next = cur.next;
                cur = cur.next;
            }else {
                prev = cur;
                cur = cur.next;
            }
        }
        if(head.val == key) {
            head = head.next;
        }
    }</code></pre> 
<h2>清空链表的内容（保证链表当中所有的节点都可以被回收）</h2> 
<pre><code class="language-java">public void clear() {
//直接把头结点置为空
        head = null;
    }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/693e30e84e5eb2ae1001626d8bc92bb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux基础命令--黑马程序员总结，在线Linux环境推荐</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5cbc0870cb17ff1be14ffbb8db51e40/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算两个日期相隔多少年，多少月，多少天</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>