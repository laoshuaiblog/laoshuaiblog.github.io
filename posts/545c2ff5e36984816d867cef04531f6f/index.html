<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Rust 笔记 - 基础编程概念、Ownership - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/545c2ff5e36984816d867cef04531f6f/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Rust 笔记 - 基础编程概念、Ownership">
  <meta property="og:description" content="The Rust Programming Language Rust 编程语言笔记。
来源：The Rust Programming Language By Steve Klabnik, Carol Nichols 。
翻译参考：Rust 语言术语中英文对照表
Rustaceans Rustaceans 指的是使用过、贡献过或对 Rust 语言有兴趣的用户。
安装 使用 rustup 来安装 Rust。
Rust 源文件以 .rs 作为扩展名。
几个常用的命令：
编译：rustc .rs-file 运行：./compiled-file检查 Rust 编译器版本：rustc --version检查 rustup 版本：rustup --version更新 Rust：rustup update卸载 Rust 和 rustup：rustup self uninstall本地文档：rustup doc Rust 是预（ahead-of-time）编译语言，意思是可以把编译后生成的可执行文件发送给别人，他们可以在不安装 Rust 的前提下运行该文件。
Cargo Cargo 是 Rust 的构建系统和包管理工具。
几个常用的命令：
检查 Cargo 的版本：cargo --version新建项目：cargo new项目构建：cargo build运行项目：cargo run项目检查：cargo check：该命令确保项目可以编译，但不生成可执行文件，速度比 c--argo build 更快发布：cargo build --release 在运行 cargo build 后，Rust 会把编译后的二进制文件放在 target/debug 文件夹下。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-22T12:46:16+08:00">
    <meta property="article:modified_time" content="2023-05-22T12:46:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rust 笔记 - 基础编程概念、Ownership</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="The_Rust_Programming_Language_1"></a>The Rust Programming Language</h2> 
<p>Rust 编程语言笔记。</p> 
<p>来源：<a href="https://doc.rust-lang.org/book/title-page.html" rel="nofollow"><em>The Rust Programming Language By Steve Klabnik, Carol Nichols</em> </a>。</p> 
<p>翻译参考：<a href="https://rustwiki.org/wiki/translate/english-chinese-glossary-of-rust/" rel="nofollow">Rust 语言术语中英文对照表</a></p> 
<hr> 
<h2><a id="Rustaceans_11"></a>Rustaceans</h2> 
<p><strong>Rustaceans</strong> 指的是使用过、贡献过或对 Rust 语言有兴趣的用户。</p> 
<hr> 
<h2><a id="_17"></a>安装</h2> 
<p>使用 <code>rustup</code> 来安装 Rust。</p> 
<p>Rust 源文件以 <code>.rs</code> 作为扩展名。</p> 
<p>几个常用的命令：</p> 
<ul><li>编译：<code>rustc .rs-file </code></li><li>运行：<code>./compiled-file</code></li><li>检查 Rust 编译器版本：<code>rustc --version</code></li><li>检查 <code>rustup</code> 版本：<code>rustup --version</code></li><li>更新 Rust：<code>rustup update</code></li><li>卸载 Rust 和 <code>rustup</code>：<code>rustup self uninstall</code></li><li>本地文档：<code>rustup doc</code></li></ul> 
<p>Rust 是<strong>预（ahead-of-time）编译</strong>语言，意思是可以把编译后生成的可执行文件发送给别人，他们可以在<strong>不安装</strong> Rust 的前提下运行该文件。</p> 
<hr> 
<h2><a id="Cargo_37"></a>Cargo</h2> 
<p>Cargo 是 Rust 的构建系统和包管理工具。</p> 
<p>几个常用的命令：</p> 
<ul><li>检查 Cargo 的版本：<code>cargo --version</code></li><li>新建项目：<code>cargo new</code></li><li>项目构建：<code>cargo build</code></li><li>运行项目：<code>cargo run</code></li><li>项目检查：<code>cargo check</code>：该命令确保项目可以编译，但不生成可执行文件，速度比 <code>c--argo build</code> 更快</li><li>发布：<code>cargo build --release</code></li></ul> 
<p>在运行 <code>cargo build</code> 后，Rust 会把编译后的二进制文件放在 <code>target/debug</code> 文件夹下。</p> 
<h3><a id="_52"></a>包</h3> 
<p>在 Rust 中，包被称为 <em>crates</em>（也可以不翻译）。</p> 
<p>Rust 使用 <strong>TOML（Tom’s Obvious Minimal Language）</strong> 格式来管理依赖。</p> 
<p>使用 <code>cargo new</code> 创建新项目后，在该项目的目录下会有名为 <code>Cargo.toml</code> 的文件来管理依赖和包。</p> 
<p>可以使用 <code>cargo add</code> 来添加依赖，也可以在 <code>.toml</code> 文件的 <code>[dependencies]</code> 字段下添加包名。</p> 
<p>在第一次使用 <code>cargo build</code> 后，Rust 会在根目录生成名为 <code>Cargo.lock</code> 的文件用于追踪包/依赖的版本。</p> 
<p>例如：</p> 
<pre><code class="prism language-toml">[dependencies]
rand = "0.8.5"
</code></pre> 
<p>包的版本使用<strong>三位的标准包标准</strong>。</p> 
<p>在 <code>.rs</code> 文件中使用关键字 <code>use</code> 来导入包。</p> 
<hr> 
<h2><a id="_77"></a>规范</h2> 
<ul><li>Rust 的缩进采用的是 <strong>4 个 <code>space</code></strong>，而不是 <code>tab</code></li><li>Rust 使用 <strong>snake case</strong> 对变量和函数命名，也就是全部使用小写字母，单词中间使用下划线 <code>_</code> 连接，例如：<code>var_name</code></li><li>Rust 使用 <strong>全大写</strong> 对常量命名，单词之间使用下划线 <code>_</code> 连接，例如：<code>MINUTES_WITHIN_A_DAY</code></li></ul> 
<hr> 
<h2><a id="Hello_World_85"></a>Hello World</h2> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><code>fn</code> 是函数（function）的关键词</li><li><code>main()</code> 是 Rust 的主函数、类似于 C、C++</li><li>每行结束需要用分号 <code>;</code> 表示</li></ul> 
<hr> 
<h2><a id="_99"></a>基本编程概念</h2> 
<h3><a id="_101"></a>注释</h3> 
<p>Rust 有三种注释：</p> 
<ul><li>单行注释: <code>//</code></li><li>多行注释：<code>/* */</code></li><li>文档（DocString）注释：<code>///</code> 或 <code>//!</code></li></ul> 
<hr> 
<h3><a id="_111"></a>变量和可变</h3> 
<h4><a id="_113"></a>变量</h4> 
<p>Rust 是<strong>静态</strong>类型语言，在声明变量时需要使用关键词 <code>let</code> 并在冒号 <code>:</code> 后指明变量的类型。这点类似于 <code>Python</code> 的 Type-Hint 以及 <code>TypeScript</code>。</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> var<span class="token punctuation">:</span> <span class="token keyword">u8</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_121"></a>可变</h4> 
<p>Rust 中的所有变量都有可变（mutable）或不可变（immutable）。</p> 
<p>如果在声明变量时不明确指明，那么默认为不可变。</p> 
<p>使用关键字 <code>mut</code> 使得变量可变。</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> var<span class="token punctuation">:</span> <span class="token keyword">u8</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">u8</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// That's OK</span>

<span class="token keyword">let</span> ano_var<span class="token punctuation">:</span> <span class="token keyword">u8</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">u8</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre> 
<h4><a id="_Shadow_137"></a>隐藏、覆盖 Shadow</h4> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  	<span class="token keyword">let</span> x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	  <span class="token punctuation">{<!-- --></span>
    	<span class="token keyword">let</span> x <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
	    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The inner x: {x}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token punctuation">}</span>
	  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The outer x: {x}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// The inner x: 12</span>
<span class="token comment">// The outer x: 6</span>
</code></pre> 
<p>如上述代码所示：声明了多个名为 <code>x</code> 的变量，在 Rust 中，我们称 <strong>第一个 <code>x</code> 被第二个 <code>x</code> shadow（隐藏、覆盖）</strong>，或者 <strong>第二个 <code>x</code> overshadow 了第一个 <code>x</code></strong>，这意味着：<strong>当使用 <code>x</code> 这个变量时，编译器总是使用第二个 <code>x</code>，即第二个 <code>x</code> 拿走了第一个 <code>x</code> 的所有，直到程序流离开第二个 <code>x</code> 的作用域或者第二个 <code>x</code> 也被 shadow。</strong></p> 
<h5><a id="shadow__mut__156"></a>shadow 和 mut 的区别</h5> 
<ol><li> <p>shadow 使得可以改变同名变量的类型，但是 <code>mut</code> 会在编译时出错</p> <pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token operator">=</span> <span class="token string">"     "</span><span class="token punctuation">;</span>
	  <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token keyword">usize</span> <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
  
    <span class="token keyword">let</span> <span class="token keyword">mut</span> x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token operator">=</span> <span class="token string">"     "</span><span class="token punctuation">;</span>
    x <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token comment">// Error</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>shadow 使得可以变不可变的同名变量的值</p> <pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>             <span class="token comment">// Error, 因为没有变量默认是不可变的</span>
    
    <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
  	<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>  <span class="token comment">// 6</span>
<span class="token punctuation">}</span>
</code></pre> </li></ol> 
<hr> 
<h3><a id="_185"></a>常量</h3> 
<p>Rust 使用 <code>const</code> 关键字声明常量。通常来说，需要用大写字母声明常量。</p> 
<pre><code class="prism language-rust"><span class="token keyword">const</span> <span class="token constant">THE_DAY_I_START_LEARNING_RUST</span><span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token string">"2023.5.9"</span><span class="token punctuation">;</span>
</code></pre> 
<p>不可变的变量和常量的区别在于：</p> 
<ol><li>常量只能是不可变的，不能通过 <code>mut</code> 关键字使得常量可变</li><li>常量通常只赋值给常量声明的表达式，而不是运行时的计算表达式</li><li>常量可以在任何作用域（scope） 中声明，在程序运行期间，在其声明的作用域中是有效的</li></ol> 
<hr> 
<h3><a id="_201"></a>数据类型</h3> 
<p>Rust 是<strong>静态</strong>类型语言，因此在编译时就需要知道所有的变量类型。</p> 
<p>例如在数据转换中：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token string">"100"</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Not a number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
    <span class="token keyword">let</span> var<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token string">"100"</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Not a number"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK, var == 100</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_214"></a>基本类型</h4> 
<p>Rust 的基本数据类型有 <strong>4</strong> 种：</p> 
<ul><li>布尔型 <em>bool</em></li><li>整型 <em>integer</em></li><li>浮点型 <em>float</em></li><li>字符型 <em>char</em></li></ul> 
<h5><a id="_223"></a>布尔型</h5> 
<p>布尔型有两个值：</p> 
<ol><li>true</li><li>false</li></ol> 
<h5><a id="_230"></a>整型</h5> 
<p>整型有 <strong>6</strong> 种长度，每种长度分为<strong>有符号</strong>和<strong>无符号</strong>两类。</p> 
<table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table> 
<p>整型字面量（literal）</p> 
<table><thead><tr><th>字面量</th><th>举例</th></tr></thead><tbody><tr><td>十进制</td><td>98_222</td></tr><tr><td>十六进制</td><td>0xff</td></tr><tr><td>八进制</td><td>0o77</td></tr><tr><td>二进制</td><td>0b1111_0000</td></tr><tr><td>字节(u8)</td><td>b’A’</td></tr></tbody></table> 
<ul><li>整型的默认类型为 <code>i32</code></li><li>在使用集合类数据类型的索引时，使用 <code>usize</code> 或 <code>isize</code></li></ul> 
<h5><a id="_256"></a>浮点型</h5> 
<p>浮点型有两类，而且都是有符号的：</p> 
<ul><li><code>f32</code></li><li><code>f64</code>：默认类型</li></ul> 
<h5><a id="_263"></a>字符型</h5> 
<p>字符型用 <code>c</code> （character）标识。</p> 
<h4><a id="_267"></a>复合类型</h4> 
<p>Rust 的复合类型包括：</p> 
<ul><li>元组</li><li>数组</li></ul> 
<h5><a id="_274"></a>元组</h5> 
<p>元组 <code>tuple</code>：用括号 <code>()</code> 声明，元组元素的数据类型可以<strong>不同</strong>。</p> 
<p>元组是<strong>定长</strong>的，一旦声明后就不能改变大小。</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> tup<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">u32</span><span class="token punctuation">,</span> <span class="token keyword">f32</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>和 <code>Python</code> 不同，Rust 中的元组可以使用 <code>.</code> 运算符来访问。</p> 
<pre><code class="prism language-RUST">let tup: (u32, f32, bool) = (1, 2.2, true);
println!("{}", tup.0); // 1
println!("{}", tup.2); // 2.2
println!("{}", tup.3); // true
</code></pre> 
<p>没有元素的元组被称为<em>单元（Unit）</em>，写作 <code>()</code>，表示空值和空返回类型。</p> 
<h5><a id="_295"></a>数组</h5> 
<p>数组 <code>array</code>: 用方括号 <code>[]</code> 声明，数组元素的数据类型必须<strong>相同</strong>。</p> 
<p>数组也是<strong>定长</strong>的。</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">u8</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> arr_2<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [5, 5, 5]</span>
</code></pre> 
<p><code>;</code> 的前后分别表示数组元素的类型和数组元素的个数（如果前面用数字表示，则重复后面的数字前面次）。</p> 
<p>可以使用索引 <code>[]</code>，访问数组元素，因为数组以定长形式存储在栈中：</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> first <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果使用越界索引访问数组：</p> 
<pre><code class="prism language-RUST">let arr: [u8; 5] = [1, 2, 3, 4, 5];
println!("{}", arr[5]); // runtime error
</code></pre> 
<p>会导致 <em>运行时</em> 错误。Rust 会在运行时检查是否有越界行为。</p> 
<hr> 
<h3><a id="_325"></a>控制流</h3> 
<h4><a id="_327"></a>条件</h4> 
<p>用 <code>if, else if, else</code> 等关键字控制程序流。</p> 
<p>Rust 的条件语句不需要外嵌括号 <code>()</code>，但是也不同于 Python 的 <code>:</code>，条件执行体需要用花括号：<code>{}</code>。</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> var<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> var <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{var} is greater than 0!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> var <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{var} is less than 0!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{var} is equal to 0!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注：与 JavaScript、Ruby 等语言不同，Rust <strong>不会</strong>在条件判断时自动转换变量的类型，例如：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">let</span> var<span class="token punctuation">:</span> <span class="token keyword">bool</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> var <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"You can't get there in Rust"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>更简洁的写法是在 <code>let</code> 中使用 <code>if</code>：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> condition<span class="token punctuation">:</span> <span class="token keyword">bool</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> number<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token keyword">if</span> condition <span class="token punctuation">{<!-- --></span> <span class="token number">5</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> number<span class="token punctuation">)</span> <span class="token comment">// 5</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_367"></a>循环</h4> 
<p>Rust 中有 3 种循环：</p> 
<ul><li>无限循环 <code>loop</code></li><li><code>while</code> 循环</li><li><code>for</code> 循环</li></ul> 
<p>结束、跳出循环的关键字：</p> 
<ul><li><code>break</code> 跳出当前循环</li><li><code>continue</code> 结束本次循环（开始下一次循环）</li></ul> 
<h5><a id="loop__380"></a>loop 循环</h5> 
<p>Rust 可以使用关键字 <code>loop</code> 来创建无限循环，例如：</p> 
<pre><code class="prism language-rust"><span class="token keyword">loop</span> <span class="token punctuation">{<!-- --></span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"This is a infinite loop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 等价于</span>
<span class="token keyword">while</span> <span class="token boolean">true</span> <span class="token punctuation">{<!-- --></span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"This is a infinite loop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>continue</code> 对 <code>loop</code> 循环无效。</p> 
<p>可以在 <code>break</code> 后添加跳出循环的返回值。</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> <span class="token keyword">mut</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> reture_value <span class="token operator">=</span> <span class="token keyword">loop</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">5</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token keyword">break</span> count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以用 ``name<code>给</code>loop` 循环命名（标识符）以跳出多层循环，例如：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> <span class="token keyword">mut</span> count<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	`outer<span class="token punctuation">:</span> <span class="token keyword">loop</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> remaining<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">loop</span> <span class="token punctuation">{<!-- --></span>
      <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> count <span class="token operator">*</span> remaining<span class="token punctuation">)</span><span class="token punctuation">;</span>
      remaining <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> remaining <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">break</span> outer<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    count <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="while__435"></a>while 循环</h5> 
<p>类似于其他语言的 <code>while</code> 循环。</p> 
<p>同样，Rust 的循环条件语句不需要外嵌圆括号 <code>()</code>，但是也不同于 Python 的 <code>:</code>，循环体需要用花括号：<code>{}</code>。</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> <span class="token keyword">mut</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> count <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="for__451"></a>for 循环</h5> 
<h6><a id="for_in_453"></a>for in</h6> 
<p><code>for in</code> 循环对遍历对象中的每一个元素都执行遍历：</p> 
<pre><code class="prism language-Rust">fn main() {
  let arr: [u32; 5] = [1, 2, 3, 4, 5];
  for element in arr {
    println!("{}", element);
  }
}
</code></pre> 
<p>类似 <code>Python</code> 的同名函数。</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token number">5</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用 <code>.rev()</code> 倒序输出：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rev</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_488"></a>函数</h3> 
<p>使用关键字 <code>fn</code> 声明函数，Rust 总是<strong>首先</strong>执行 <code>main</code> 函数。</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> var<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token function">increment_and_print</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">increment_print</span><span class="token punctuation">(</span>num<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{<!-- --></span>
	num <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> num<span class="token punctuation">;</span>
  <span class="token comment">// num</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如上述代码所示：Rust 并不关心函数定义的位置，因此在 <code>main</code> 函数前后定义其他函数都不会错误。</p> 
<p>函数的参数需要声明名称和类型，返回值用 <code>-&gt;</code> 表示，只需要声明类型。</p> 
<p>可以使用关键字 <code>return</code> 显式返回值，也可以把返回值写在最后一行（不要使用 <code>;</code> 结尾）。Rust 默认把最后一行的值作为返回值。</p> 
<h4><a id="_VS__512"></a>语句 VS 表达式</h4> 
<p>Rust 是基于<strong>表达式</strong>的语言。在 Rust 中，语句（statements）和表达式（expressions）有明显的区别：</p> 
<ul><li><strong>语句</strong>：一段完成行为的指令，<strong>不</strong>返回值，以分号结尾。</li><li><strong>表达式</strong>：给结果返回值，可以是语句的一部分，<strong>不</strong>以分号结尾（通过添加分号把表达式转化为语句，同时失去返回值）</li></ul> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> y  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre> 
<p>上面的代码中，赋值语句并不返回任何值，因此，不能把 <code>let x = 6</code> 赋值给 <code>y</code>。这不同于 C、Ruby 等语言，其赋值语句会返回赋予的值。</p> 
<p>而对于表达式：</p> 
<pre><code class="prism language-rust"><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
  x <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">// 返回 7</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_536"></a>输入和输出</h3> 
<h4><a id="_538"></a>输入</h4> 
<p>使用标准库 <code>std::io</code> 来导入标准库的 io。</p> 
<pre><code class="prism language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>io<span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> <span class="token keyword">mut</span> inp<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 	<span class="token namespace">io<span class="token punctuation">::</span></span>stdin<span class="token punctuation">.</span><span class="token function">read_line</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> inp<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Failed to read"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{inp}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>使用 <code>stdin</code> 引入标准输入流，</li><li>使用 <code>read_line(&amp;)</code> 来读取输入，</li><li>使用 <code>expect()</code> 来处理异常情况。</li></ul> 
<h4><a id="_556"></a>输出</h4> 
<p>使用 <code>println!()</code> 来输出内容。</p> 
<p><code>println!()</code> 表示调用 Rust <strong>宏（macro）</strong>，<code>println()</code> 表示调用函数</p> 
<p>Rust 不支持直接输出变量的值，必须**格式化（format）**后输出。在引号 <code>""</code> 中使花括号 <code>{}</code> 来输出变量。</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> var<span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
  	<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> var<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 15</span>
  	<span class="token comment">// println!("var equals {var}")  Also ok!</span>
  	<span class="token comment">// println!(var)  Error!</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="_Ownership_575"></a>所有权 Ownership</h2> 
<p><em>Ownership</em> 是 Rust 语言管理内存的规则。</p> 
<p><em>Ownership</em> 是 Rust 语言最重要的特性之一，也是为什么 Rust 比 C++ 更<strong>安全</strong>的原因。</p> 
<h3><a id="Ownership_581"></a>Ownership</h3> 
<h4><a id="_583"></a>栈内存和堆内存</h4> 
<p>要理解什么是 Ownership，首先要了解栈内存（stack）和堆内存（heap）的区别。</p> 
<p>简单来讲，栈内存和堆内存都是程序在<strong>运行时</strong>使用的内存。</p> 
<p>栈最重要的操作是<strong>入栈和出栈</strong>，入栈时把元素放在栈顶，出栈时把栈顶元素弹出，因此栈内存中的元素是<strong>有</strong>先后顺序的。栈内存中存储的是<strong>定长</strong>的数据，而在<strong>编译时</strong>未知大小或者大小可能改动的数据会存储在堆内存中。</p> 
<p>堆内存中的元素<strong>没有</strong>先后顺序，每次都要给元素分配<strong>足够大</strong>的空间。当数据需要存放在堆中时，内存分配器会分配给数据一块空闲区域，并返回一个指针，指向这块区域的地址。该指针是定长的，因此可以存储在栈中，但是如果要访问堆中的数据，必须要沿着指针指向/存储的地址。</p> 
<p>因此，<strong>栈</strong>内存<strong>存储</strong>数据和<strong>访问</strong>数据时速度都要更<strong>快</strong>，而堆内存则正好相反，因为其分别需要寻找空闲的内存空间以及沿着指针寻找地址。</p> 
<h4><a id="_595"></a>垃圾回收和动态分配</h4> 
<p>对于静态类型语言来说，所有变量都在内存中占有一定的空间，该空间位置在 C、C++ 等语言中使用指针来表示。对于不使用的变量所占有的空间的释放是编程语言设计时的关键问题。通常应该及时释放其占有的空间，否则可能导致堆内存溢出，引起难以预料的安全问题；但如果释放太早，则可能导致后续对该变量的引用出错。</p> 
<p>对于该问题，有一些语言（例如：Java）使用一种被称为**“垃圾回收”（Garbage Collection / GC）**的机制来追踪并释放不使用变量的内存。另一些语言（例如：C、C++）则需要用配对的 <code>malloc(), free()</code> 等函数来动态分配和释放空间。</p> 
<p>Rust 则采用了 <strong>Ownership</strong> 机制。</p> 
<h4><a id="Ownership__603"></a>Ownership 规则</h4> 
<ul><li>Rust 中的每个值<strong>都</strong>有一个 <em>owner</em></li><li>在同一时刻只能有<strong>一个</strong> owner</li><li>当 owner <strong>超出</strong>作用域时，该值会被<strong>丢弃</strong></li></ul> 
<h4><a id="_ownership__609"></a>变量 ownership 的转换</h4> 
<p>来看一个例子：如果两个变量指向同一段内存空间，此时如果释放第一个变量指向的空间（也是第二个变量的指向），那么引用第二个变量是否会导致错误？</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> string_in_stack<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token operator">=</span> <span class="token string">"This string is stored in stack"</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> ano_string_in_stack<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token operator">=</span> string_in_stack<span class="token punctuation">;</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> string_in_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> ano_string_in_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">let</span> string_in_heap<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"This string is stored in heap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> ano_string_in_heap<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> string_in_heap<span class="token punctuation">;</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> string_in_heap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// value borrowed here after move</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> ano_string_in_heap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的例子分别声明了两类字符串变量：</p> 
<ul><li> <p><code>string_in_stack</code> 存储在<strong>栈</strong>内存中。也称为“字符串字面量”，指的是通过双引号来表示的字符串，这类字符串是<strong>不可变的</strong>（这里的不可变指的是不能更改字符串中某个字符，因为其存储是连续的），但可以变整个字符串。这类字符串更加高效，原因是在<strong>编译时</strong>就已经知道了其大小，而且是定长的。</p> </li><li> <p><code>string_in_heap</code> 存储在<strong>堆</strong>内存中。是由 <code>String</code> 类型创建的字符串，可以变。由于这类字符串是<strong>变长</strong>的，因此在<strong>编译时</strong>是不知道其内容的，只能在<strong>运行时</strong>请求在堆中分配内存（通过 <code>String::from</code> 完成）。</p> <p>当使用完该类字符串后，需要一种机制把内存还给分配器：</p> 
  <ul><li>带有 GC 的语言会追踪并清理不使用的内存空间</li><li>没有 GC 的语言需要程序员去识别并释放内存</li><li>Rust 的做法是：一旦变量超出其作用域，该变量占据的内存将被自动回收（调用 <code>drop</code> 函数）</li></ul> </li></ul> 
<h5><a id="_639"></a>深、浅拷贝，移动和克隆</h5> 
<p>回到代码，存储在<strong>堆</strong>上的字符串 <code>string_in_heap</code> 的内存会被收回。这有些类似于<strong>浅拷贝（shallow copy）</strong>，其只复制指针，长度和 capacity，但是并不复制原数据；但是 Rust 同时还释放了被拷贝变量的空间，所以该操作被称为<strong>移动（move）</strong>。</p> 
<p>因此，Rust 从来不会自动执行<strong>深拷贝（deep copy）</strong>。</p> 
<p>如果确实要“深拷贝”堆中的数据，可以使用 <code>.clone()</code>。</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> string_in_heap<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">let</span> ano_string_in_heap<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> string_in_heap<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} {}"</span><span class="token punctuation">,</span> string_in_heap<span class="token punctuation">,</span> ano_string_in_heap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Hello Hello</span>
</code></pre> 
<p>因此，变量 ownership 的变化模式是相同的：</p> 
<ul><li>每当赋值给另一变量时，ownership move</li><li>当堆中的变量超出作用域时，ownership drop，除非 ownership 又被移交给其他的变量</li></ul> 
<h5><a id="CopyDrop_662"></a>Copy、Drop</h5> 
<p>Rust 中有一个被称为 <code>Copy</code> 的 特质（trait），可用于某种数据类型。实现了 <code>Copy</code> 的数据类型的变量可以赋值给另一个变量，而不会导致 move 操作。</p> 
<p>Rust 不允许在实现了 <code>Drop</code> 特质（trait） 的数据类型上实现 <code>Copy</code>。</p> 
<p>实现 <code>Copy</code> 特质（trait） 的数据类型包括：</p> 
<ul><li>所有的整型</li><li>所有的布尔型</li><li>所有的浮点型</li><li>所有的字符型</li><li>只包含上述四种的类型作为成员的元组</li></ul> 
<h4><a id="_Ownership_676"></a>函数和返回值的 Ownership</h4> 
<p>函数和变量类似，给函数传递值会导致 move 或者 copy。</p> 
<p>返回值也会转移 ownership。</p> 
<p>如果要让函数使用变量但是不转移 ownership，可以使用<strong>引用（reference）</strong>。</p> 
<h3><a id="_684"></a>引用</h3> 
<h4><a id="_686"></a>引用和借用</h4> 
<p>***引用（reference）***类似于指针，它指向存储某个数据的内存。与指针不同的是，引用指向的数据总是有效的。</p> 
<p>引用使得我们不需要带走 ownership 就可以获取数据。</p> 
<p>使用引用的行为称为<em><strong>借用（borrowing）</strong></em>。</p> 
<h4><a id="_694"></a>使用引用</h4> 
<p>使用 <code>&amp;</code> 来创建一个引用。</p> 
<p>在使用引用类型时，需要修改函数签名，传参方式等，例如：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">let</span> length <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传入引用 &amp;</span>
  	<span class="token comment">// The length of s1: 5</span>
  	<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of s1: {}"</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// 函数参数类型为引用 &amp;</span>
		s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_713"></a>引用原则</h4> 
<p>在 Rust 中，引用的原则是：</p> 
<ol><li>只能<strong>同时</strong>有<strong>一个可变</strong>引用或者<strong>多个不可变</strong>引用</li><li>引用必须<strong>有效（valid）</strong></li></ol> 
<h5><a id="_720"></a>可变和不可变引用</h5> 
<p>上述的引用是<strong>不可变的</strong>。类似于变量，如果想改变变量的值，需要使用<strong>可变引用</strong>。</p> 
<p>在 <code>&amp;</code> 后添加 <code>mut</code> 关键字来使用可变引用。</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加 mut</span>
  	<span class="token comment">// s1: "Hello, World"</span>
  	<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1: {}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">change</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// 添加 mut</span>
		s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">", World"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以同时使用<strong>多个不可变</strong>引用:</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
  	<span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是只能同时使用<strong>一个可变</strong>引用：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s1<span class="token punctuation">;</span> <span class="token comment">// Ok (first borrow)</span>
  	<span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s1<span class="token punctuation">;</span> <span class="token comment">// Err (cannot borrow)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>也不能<strong>同时</strong>使用可变和不可变引用：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">;</span> <span class="token comment">// Ok (first borrow)</span>
  	<span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s1<span class="token punctuation">;</span> <span class="token comment">// Err (cannot borrow)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>除非作用域不同：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token punctuation">{<!-- --></span>
    		<span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s1<span class="token punctuation">;</span> <span class="token comment">// Ok (first borrow) </span>
  	<span class="token punctuation">}</span>
  	<span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s1<span class="token punctuation">;</span> <span class="token comment">// Ok</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_781"></a>引用的作用域</h5> 
<p>引用的作用域<strong>从声明开始到最后一次使用该引用</strong>。</p> 
<p>例如下面的代码<strong>没有问题</strong>：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">;</span> <span class="token comment">// Ok (first borrow) </span>
	  <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">;</span> <span class="token comment">// Ok (second borrow) </span>
  	<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"r1 and r2 {} {}"</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// r1 and r2 no longer used</span>
  
  	<span class="token keyword">let</span> r3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s1<span class="token punctuation">;</span> <span class="token comment">// Ok!</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_798"></a>数据竞争</h5> 
<p>Rust 的引用原则避免了<strong>数据竞争</strong>可能导致的编译时错误。</p> 
<p><em>数据竞争</em>指的是下述三种行为：</p> 
<ol><li>两个或以上只能同时指向同一个数据</li><li>至少一个指针被用于写入数据</li><li>没有同步机制读取数据</li></ol> 
<p>数据竞争可能导致未定义的行为而且在运行时难以诊断和调试。Rust 的引用限制能够有效避免这类问题。</p> 
<h5><a id="_810"></a>有效引用和悬垂指针</h5> 
<p><em>悬垂指针（dangling point）</em> 是指向了已经被 free 内存区域的指针。</p> 
<p>在 Rust 中，编译器保证引用<strong>必须有效</strong>。也就是引用必须发生在数据超出作用域前。</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token function">return_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">return_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">String</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token operator">&amp;</span>s	
<span class="token punctuation">}</span> <span class="token comment">// s out of scope</span>

<span class="token comment">/* correct the above code
fn return_string() -&gt; String {
		let s = String::from("Hello");
  	s	// return string not reference
}
*/</span>
</code></pre> 
<h3><a id="_834"></a>切片类型</h3> 
<p><em>切片（slice）</em> 指的是对集合的<strong>部分引用</strong>。</p> 
<h4><a id="_838"></a>语法</h4> 
<p>切片的语法为：<code>[start_index..end_index]</code>，其中：</p> 
<ul><li><code>..</code> 是范围（range）运算符</li><li><code>start_index</code> 是开始的索引。（如果忽略该项，默认从 <code>0</code> 开始）</li><li><code>end_index</code> 是最后的索引（不包括该索引位置）。（如果忽略该项，默认以集合的末尾截止）</li></ul> 
<h4><a id="_846"></a>字符串切片</h4> 
<p>下面是字符串切片：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello, World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">let</span> slice1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  	<span class="token keyword">let</span> slice2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">..</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  	<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} {}"</span><span class="token punctuation">,</span> slice1<span class="token punctuation">,</span> slice2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Hello World</span>
</code></pre> 
<p>字符串切片的类型为 <code>&amp;str</code>，因为是不可变引用 <code>&amp;</code> （非 <code>&amp; mut</code>），因此，字符串字面量是不可变的。</p> 
<h4><a id="_863"></a>解引用强制转化</h4> 
<p>如果已知字符串切片，我们可以直接把它作为参数传入；如果已知 <code>String</code> 类型，我们可以传入该类型的切片或者对 <code>String</code> 的引用。这种灵活性称为<em><strong>解引用强制转化（deref coercion）</strong></em>。</p> 
<p>有经验的 Rustaceans 会把 <code>&amp;String</code> 类型为参数的函数签名更改为 <code>&amp;str</code>：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">// to</span>
<span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>这样的改动使得函数更加**通用（general）**同时并不损失任何功能。</p> 
<p>例如：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> my_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// `first_word` works on slices of `String`s, whether partial or whole</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// `first_word` also works on references to `String`s, which are equivalent</span>
    <span class="token comment">// to whole slices of `String`s</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> my_string_literal <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>

    <span class="token comment">// `first_word` works on slices of string literals, whether partial or whole</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string_literal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_string_literal<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Because string literals *are* string slices already,</span>
    <span class="token comment">// this works too, without the slice syntax!</span>
    <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token function">first_word</span><span class="token punctuation">(</span>my_string_literal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果 <code>first_word</code> 函数的参数类型为 <code>&amp;String</code>:</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char string">b' '</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么上述代码就会<strong>报错</strong>！。</p> 
<p>如果为 <code>&amp;str</code>:</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">first_word</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 只修改函数参数的类型</span>
		<span class="token comment">// --snip--</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码就能成功执行。</p> 
<hr> 
<h2><a id="_932"></a></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51eb1ba409da8c2a02cc8b8ca8dcd522/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用docker轻松安装高斯数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba0327283da3172684a122e067cc5035/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows多张图片如何按照自己排好的顺序打印(输出PDF)？或如何把多张图片一键输出PDF？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>