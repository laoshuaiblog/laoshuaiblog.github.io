<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>枚举与联合体 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/66200a3d0317105ee65c0caf8baf754e/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="枚举与联合体">
  <meta property="og:description" content="枚举类型的定义 枚举类型的语法形式：
enum 枚举名称 { 枚举元素1; 枚举元素2; ...... }; 枚举类型的定义：
//用枚举举例星期 enum Day//枚举的名称 { Mon, Tues, Wed, // 枚举星期的所有可能 Thur, Fri, Sat, Sun }; 以上定义的 enum Day 是枚举类型{ }中的内容是枚举类型的可能取值，也叫枚举常量这些可能取值最开始都是默认从0开始，一次递增1当然在定义的时候也可以赋初值后面的枚举常量是依次递增的,也可以一个一个赋值 枚举的优点 1.代码的简洁性、增加代码的可读性和可维护性
2.枚举 enum 和 define 对标
3.如果不使用枚举，用 #define定义来为每个可能定义一个别名
4.定义可能性比较多，比如：月份那代码就比较多且臃肿，如果使用枚举就会很简洁，而且增加代码的可读性和可维护性
5.还有就是以枚举类型定义具有一定的意义
可以使用到一些程序中
enum sex { MALE; FEMALE; SECRET }; int main() { enum sex a; // 定义枚举变量 a = MALE; printf(&#34;%d&#34;,a); return 0; } 在一些程序中枚举较define的优势和#define定义的标识符比较枚举有类型检查，更加严谨防止命名污染便于调试使用方便，一次可以定义多个常量 枚举的使用 遍历枚举类型 在C语言中枚举类型是被当做 int 或者 unsigned int 类型来处理的">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-11-18T12:45:51+08:00">
    <meta property="article:modified_time" content="2022-11-18T12:45:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">枚举与联合体</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<h2><a id="_6"></a><span style="color:#fe2c24;">枚举类型的定义</span></h2> 
<p>枚举类型的语法形式：</p> 
<pre><code>enum 枚举名称
{
  枚举元素1;
  枚举元素2;
  ......
};
</code></pre> 
<p>枚举类型的定义：</p> 
<pre><code>//用枚举举例星期
enum Day//枚举的名称
{
    Mon,
    Tues,
    Wed,     // 枚举星期的所有可能
    Thur,
    Fri,
    Sat,
    Sun
};
</code></pre> 
<ul><li>以上定义的 enum Day 是枚举类型</li><li>{ }中的内容是枚举类型的可能取值，也叫枚举常量</li><li>这些可能取值最开始都是默认从0开始，一次递增1</li><li>当然在定义的时候也可以赋初值</li><li>后面的枚举常量是依次递增的,也可以一个一个赋值</li></ul> 
<h2><a id="_57"></a><span style="color:#fe2c24;">枚举的优点</span></h2> 
<p><span style="color:#0d0016;"><strong>1.代码的简洁性、增加代码的可读性和可维护性<br>  2.枚举 enum 和 define 对标<br>  3.如果不使用枚举，用 #define定义来为每个可能定义一个别名</strong></span></p> 
<p><span style="color:#0d0016;"><strong> 4.定义可能性比较多，比如：月份那代码就比较多且臃肿，如果使用枚举就会很简洁，而且增加代码的可读性和可维护性</strong></span></p> 
<p><span style="color:#0d0016;"><strong> 5.还有就是以枚举类型定义具有一定的意义<br> 可以使用到一些程序中</strong></span></p> 
<pre><code>enum sex
{
    MALE;
    FEMALE;
    SECRET
};
int main()
{
   enum sex a; // 定义枚举变量
   a = MALE;
   printf("%d",a);
   return 0;
}
</code></pre> 
<ol><li>在一些程序中枚举较define的优势</li><li>和#define定义的标识符比较枚举有类型检查，更加严谨</li><li>防止命名污染</li><li>便于调试</li><li>使用方便，一次可以定义多个常量</li></ol> 
<h2><a id="_103"></a><span style="color:#fe2c24;">枚举的使用</span></h2> 
<h4><a id="_128"></a>遍历枚举类型</h4> 
<p>在C语言中枚举类型是被当做 int 或者 unsigned int 类型来处理的<br> 所以按照 C 语言规范是没有办法遍历枚举类型的。<br> 不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p> 
<p></p> 
<h2><a id="union_159"></a><span style="color:#fe2c24;">联合体（共用体）union</span></h2> 
<p>联合体也叫共用体，是一种特殊的自定义类型<br><code>union</code> 是联合体的关键字<br> 这种类型定义的变量也包含一系列的成员，特征是这些成员共用同一块空间（所以联合也叫共用体）<br> 联合体语法形式：<br>  </p> 
<pre><code>union ud
{
   int a;
   char b;
};
</code></pre> 
<h2><a id="_172"></a>联合体的体点</h2> 
<p>联合体成员都是使用同一块空间，每次使用空间只能选一个成员使用，不能同时使用<br> 联合的成员是共用同一块内存空间的，这样一个联合变量的大小至少是最大成员的大小</p> 
<p>联合体成员占用同一块内存</p> 
<p></p> 
<h2><span style="color:#fe2c24;"><strong>判断当前计算机的大小端存储</strong></span></h2> 
<p><strong style="color:#4f4f4f;font-size:18px;font-weight:bold;">用联合体来判断大小端存储</strong></p> 
<pre><code>int check_sys()
{
	union s
	{
		int i;
		char c;
	}u;
	u.i = 1;
	return u.c;
}
int main()
{
	int ret = check_sys();
	if (ret == 1)
		printf("小端\n");
	else
		printf("大端\n");
}
</code></pre> 
<h2><a id="_247"></a><span style="color:#fe2c24;">联合大小的计算</span></h2> 
<p>联合体也是存在对齐的</p> 
<ul><li>联合的大小至少是最大成员的大小</li><li>当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍</li></ul> 
<p>例如：</p> 
<pre><code>union Un1
{
char c[5];
int i;
};
int main()
{ 
   printf("%d\n", sizeof(union Un1));
}

</code></pre> 
<ul><li><code>char c[ 5 ]</code> 有5个元素是占5个空间，<code>char</code> 类型是 1 个字节</li><li><code>int i</code>是整型，占 4 个字节</li><li>它们的最大的对齐数是 4 ，而<code>char c[5]</code>所占的空间是5个, 5并不是4 的倍数<br> 那就在浪费掉 3 个空间找到 4 的整数倍，也就是 8       <h2><span style="color:#fe2c24;"><strong>位运算</strong></span></h2> </li><li> <p>1字节（byte） = 8 比特（bit） </p> <p>注：这个字节与比特的关系是规定的，记住就好，通用于任何场景，容易混淆的是字长和字节，字长指的是cpu一次性能够运算的数据的位数，不同的计算机可能不一样，但是字节这个概念是恒久不变的。</p> <p>一个英文字符和英文标点占用一个字节，一个中文字符和中文标点占用两个字节。</p> </li><li> <p><br><strong>比特</strong><br> 　　1) 计算机专业术语，是信息量单位，是由英文BIT音译而来。二进制数的一位所包含的信息就是一比特，如二进制数0101就是4比特。<br> 　　2)二进制数字中的位，信息量的度量单位，为信息量的最小单位。数字化音响中用电脉冲表达音频信号，“1”代表有脉冲，“0”代表脉冲间隔。如果波形上每个点的信息用四位一组的代码表示，则称4比特，比特数越高，表达模拟信号就越精确，对音频信号信号还原能力越强。</p> <p><strong>   按位运算</strong></p> </li><li> <p>&amp;(按位与)、|(按位或)、^(按位异或)、~ (按位取反)。<br>     其中，按位取反运算符是单目运算符，其余均为双目运算符。<br>     位运算符的优先级从高到低，依次为~、&amp;、^、|，<br>     其中~的结合方向自右至左，且优先级高于算术运算符，其余运算符的结合方向都是自左至右，且优先级低于关系运算符</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/55f9486ebaad6efb8ad94e2597938890/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Apollo学习（超详细）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/443f46a2da6776e290d906fedb5386ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ES6 模块化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>