<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java的反射机制 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/64e7ca26da117e98b41ff5f1cccc9ee1/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Java的反射机制">
  <meta property="og:description" content="反射机制：
Java反射机制：是在运行状态中，对于任意一个类，都能够知道该类的所有属性和方法；对于任意一个对象，都能够调用它的任意属性和方法；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。
Java反射(放射)机制：”程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言 &#34;。从这个观点看，Java并不是动态语言，但是Java有一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整结构(但不包括methods定义)，并生成其对象实体、或对其fields设值、或唤起其methods。因此，Java反射是Java被视为动态语言的一个关键性质。
反射机制的必要性：
1、在涉及某些应用程序时，往往需要动态升级以增加修改工程，而在静态编译体系中一切升级操作都需要对源码进行修改，这就意味着每一次升级就要对整个源代码编译一次。而如果是些大程序编译一次要几小时甚至几天才能完成，如此，显然纯静态的编程方式不太适合。而java是一门静态语言，为了弥补这个缺点，就有了反射机制。
2、Java更多的情况是应用于服务端程序，而服务器上的程序是不能关掉的，即使关掉也要提前给用户通知，但是，如果此时又要对系统进行升级，既要保证体系内其他功能正常运行，还要保证系统升级措施，就可以用发射机制来实现。
3、程序更加清晰，将主程序和功能程序分离，便于后期维护管理。
反射机制的应用：
1、杀毒软件病毒库的在线升级。
2、JDBC数据桥的构建(Class.forName(“数据库驱动包类名称”))。
3、应用程序功能的增加。
4、分析泛型的实质。
5、分析程序，找bug。
反射机制三种实现方式：
1、得到类类型，同时加载类Class class = Class.forName(&#34;SomethingName&#34;)。
2、已知类对象，由对象得到其所属类Class class = new Demo().getClass().
3、直接由类得到其类对象Class class = Demo.Class。
反射相关类：
1、Class类，用来处理类级别的反射。
2、Field类，用来处理成员变量级的反射。
3、Method类，用来处理方法级的反射。
4、Constructor类，用来处理构造器的反射。
Java反射机制提供了什么功能：
1、获取类的Class对象
2、获取类的Fields
3、获取类的Method
4、获取类的Constructor
5、新建类的实例
注：在使用Java的反射功能时，基本首先都要获取类的Class对象，再通过Class对象获取其他的对象。
获取类的Class对象：
1)、调用getClass
Boolean var1 = true;
Class&amp;lt;?&amp;gt; classType1 = var1.getClass();
System.out.println(classType1);
//输出：class java.lang.Boolean
2)、运用.class语法
Class&amp;lt;?&amp;gt; classType2 = Boolean.class;
System.out.println(classType2);
//输出：class java.lang.Boolean
3)、运用static method Class.forName()
Class&amp;lt;?&amp;gt; classType3 = Class.forName(&#34;java.lang.Boolean&#34;);
System.out.println(classType3);">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2017-03-02T07:47:27+08:00">
    <meta property="article:modified_time" content="2017-03-02T07:47:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java的反射机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><br> </p> 
<p>    <span style="font-size:18px"><strong>反射机制：</strong></span></p> 
<p>    Java反射机制：是在运行状态中，对于任意一个类，都能够知道该类的所有属性和方法；对于任意一个对象，都能够调用它的任意属性和方法；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p> 
<p>    Java反射(放射)机制：”程序运行时，允许改变程序结构或变量类型，这种语言称为<span style="color:#ff0000">动态语言</span> "。从这个观点看，Java并不是动态语言，但是Java有一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整结构(但不包括methods定义)，并生成其对象实体、或对其fields设值、或唤起其methods。因此，Java反射是Java被视为动态语言的一个关键性质。</p> 
<p><br> </p> 
<p></p> 
<p>    <span style="font-size:18px"><strong>反射机制的必要性：</strong></span></p> 
<p>    1、在涉及某些应用程序时，往往需要动态升级以增加修改工程，而在静态编译体系中一切升级操作都需要对源码进行修改，这就意味着每一次升级就要对整个源代码编译一次。而如果是些大程序编译一次要几小时甚至几天才能完成，如此，显然纯静态的编程方式不太适合。而java是一门静态语言，为了弥补这个缺点，就有了反射机制。</p> 
<p>    2、Java更多的情况是应用于服务端程序，而服务器上的程序是不能关掉的，即使关掉也要提前给用户通知，但是，如果此时又要对系统进行升级，既要保证体系内其他功能正常运行，还要保证系统升级措施，就可以用发射机制来实现。</p> 
<p>    3、程序更加清晰，将主程序和功能程序分离，便于后期维护管理。</p> 
<p><br> </p> 
<p>    <span style="font-size:18px"><strong>反射机制的应用：</strong></span></p> 
<p>    1、杀毒软件病毒库的在线升级。</p> 
<p>    2、JDBC数据桥的构建(Class.forName(“数据库驱动包类名称”))。</p> 
<p>    3、应用程序功能的增加。</p> 
<p>    4、分析泛型的实质。</p> 
<p>    5、分析程序，找bug。</p> 
<p><br> </p> 
<p>    <span style="font-size:18px"><strong>反射机制三种实现方式：</strong></span></p> 
<p>    1、得到类类型，同时加载类Class  class = Class.forName("SomethingName")。</p> 
<p>    2、已知类对象，由对象得到其所属类Class class = new Demo().getClass().</p> 
<p>    3、直接由类得到其类对象Class class = Demo.Class。</p> 
<p><br> </p> 
<p>    <span style="font-size:18px"><strong>反射相关类：</strong></span></p> 
<p>    1、Class类，用来处理类级别的反射。</p> 
<p>    2、Field类，用来处理成员变量级的反射。</p> 
<p>    3、Method类，用来处理方法级的反射。</p> 
<p>    4、Constructor类，用来处理构造器的反射。</p> 
<div> 
 <br> 
</div> 
<p>    <span style="font-size:18px"><strong>Java反射机制提供了什么功能：</strong></span></p> 
<p>    1、获取类的Class对象</p> 
<p>    2、获取类的Fields</p> 
<p>    3、获取类的Method</p> 
<p>    4、获取类的Constructor</p> 
<p>    5、新建类的实例</p> 
<p>    注：在使用Java的反射功能时，基本首先都要获取类的Class对象，再通过Class对象获取其他的对象。</p> 
<p>    <strong>获取类的Class对象：</strong></p> 
<p>    1)、调用getClass</p> 
<p>    Boolean var1 = true;</p> 
<p><span style="white-space:pre"></span>    Class&lt;?&gt; classType1 = var1.getClass();<br> <span style="white-space:pre"></span>    System.out.println(classType1);</p> 
<p>    //输出：class java.lang.Boolean</p> 
<p>    2)、运用.class语法</p> 
<p>    Class&lt;?&gt; classType2 = Boolean.class;</p> 
<p><span style="white-space:pre"></span>    System.out.println(classType2);</p> 
<p>     //输出：class java.lang.Boolean</p> 
<p>    3)、运用static method Class.forName()</p> 
<p>    Class&lt;?&gt; classType3 = Class.forName("java.lang.Boolean");</p> 
<p><span style="white-space:pre"></span>    System.out.println(classType3);</p> 
<p>    //输出：class java.lang.Boolean<br> </p> 
<p>    4)、运用private wrapper classes的TYPE语法(这里返回的是原生类型，和Boolean.class返回的不同)</p> 
<p>    Class&lt;?&gt; classType4 = Boolean.TYPE;</p> 
<p><span style="white-space:pre"></span>    System.out.println(classType4);</p> 
<p>    //输出：boolean</p> 
<p>    <strong>获取类的Fields：</strong></p> 
<p>    可以通过反射机制得到某个类的某个属性，然后改变对应于这个类的某个实例的该属性值。Java的Class&lt;T&gt;类提供了几个方法获取类的属性。</p> 
<p>    1)、public Field  getField(String name)</p> 
<p>    People peo = new People();</p> 
<p>    peo.getClass().getField("");</p> 
<p>    返回一个Field对象，它反映此Class对象所表示的类或接口的指定公共成员字段。</p> 
<p>    2)、public Field[ ]  getFields()</p> 
<p>    Field[ ] fields = peo.getClass().getFields();</p> 
<p>    返回一个包含某些Field对象的数组，这些对象反映此Class对象所表示的类或接口的所有可访问公共字段。</p> 
<p>    3)、public Field getDeclaredField(String name)</p> 
<p>    peo.getClass().getDeclaredField("");</p> 
<p>    返回一个Field对象，该对象反映此Class对象所表示的类或接口的指定已声明字段。</p> 
<p>    4)、public Field[ ] getDeclaredFields()</p> 
<p>    Field[ ] fields = peo.getClass().getDeclaredFields();</p> 
<p>    返回Field对象的一个数组，这些对象反映此Class对象所表示的类或接口所声明的所有字段。</p> 
<p>    <span style="color:rgb(255,0,0)">getFields和getDclaredFields的区别：getFields返回的是申明为public的属性，包括父类中的，getDclaredFields返回的是指定类定义的所有定义的属性，不包括父类的。</span></p> 
<p>   <strong> 获取类的Method：</strong></p> 
<p>    通过反射机制得到某个类的某个方法，然后调用对应于这个类的某个实例的该方法。Class&lt;T&gt;类提供了几个方法获取类的方法。</p> 
<p>    1)、public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</p> 
<p>    返回一个Method对象，它反映此Class对象所表示的类或接口的指定公共成员方法</p> 
<p>    2)、public Method[ ] getMethods()</p> 
<p>    返回一个包含某些Method对象的数组，这些对象反映此Class对象所表示的类或接口(包括那些由该类或接口声明的以及从超类或超接口继承的那些的类或接口)的公共方法</p> 
<p>    3)、public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</p> 
<p>    返回一个Method对象，该对象反映此Class对象所表示的类或接口的指定已声明方法。</p> 
<p>    4)、public Method[ ] getDeclaredMethods()</p> 
<p>    返回Method对象的一个数组，这些对象反映此Class对象表示的类或接口声明的所有方法，包括公共、保护、默认、私有方法，但不包括继承的方法。</p> 
<p>    <strong>获取类的Constructor：</strong></p> 
<p>    通过反射机制得到某个类的构造器，然后调用该构造器创建该类的一个实例。Class&lt;T&gt;类提供了几个方法获取类的构造器。</p> 
<p>    1)、public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes ) </p> 
<p>    返回一个Constructor对象，它反映此Class对象所表示的类的指定公共构造方法。</p> 
<p>    2)、public Constructor&lt;?&gt;[ ] getConstructors()</p> 
<p>    返回一个包含某些Constructor对象的数组，这些对象反映此Class对象所表示的类的公共构造方法。</p> 
<p>    3)、public Constructor&lt;?&gt; getDeclaredConstructor(Class&lt;?&gt;...  parameterTypes)</p> 
<p>    返回一个Constructor对象，该对象反映此Class对象所表示的类或接口的指定构造方法。</p> 
<p>    4)、public Constructor&lt;?&gt;[ ] getDeclaredConstructors()</p> 
<p>    返回Constructor对象的一个数组，这些对象反映此Class对象表示的类声明的所有构造方法。包括公共、保护、私有、默认(包)访问构造方法</p> 
<p>    <strong>新建类的实例：</strong></p> 
<p>    通过反射机制创建新类的实例，以下3种方法</p> 
<p>    1)、调用无参数</p> 
<p>    a、<strong>调用类的Class对象的newInstance方法，该方法会调用对象的默认构造器，如果没有默认构造器，会调用失败。</strong></p> 
<p>    Class&lt;?&gt; cls = (Class&lt;?&gt;) Class.forName("test.People").newInstance();</p> 
<p>    或者</p> 
<p>    People cls = People.class.newInstance();</p> 
<p>    System.out.println(cls);</p> 
<p>    newInstance实例化之前须用class的forName()方法加载、连接类对象，由于People类对象有一个有参构造器，没有默认构造器，抛出InstantiationException异常。</p> 
<p>    b、<strong>调用默认(不带参数)Constructor对象的newInstance方法。</strong></p> 
<p>    Constructor&lt;People&gt; con = People.class.getConstructor();</p> 
<p>    People peo = con.newInstance();</p> 
<p>    System.out.println(peo);</p> 
<p></p> 
<p>    通过Constructor的newInstance方法创建对象，同理，无参数的调用，对象要有符合条件的无参构造器，否则会调用失败。</p> 
<p>     2)、调用带参数</p> 
<p>    a、<strong>调用带参数Constructor对象的newInstance方法。</strong></p> 
<p>    <span style="color:#ff0000">Constructor对象的newInstance方法和Class类的newInstance方法很像，java.lang.reflect.Constructor类也有一个ne</span><span style="color:rgb(255,0,0)">wInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数和私有的构造函数。</span></p> 
<p></p> 
<p><span style="color:#ff0000">    </span>Constructor&lt;People&gt; con = People.class.getConstructor(String.class,int.class);</p> 
<p>    People peo = con.newInstance("xiaohua",2);</p> 
<p>    System.out.println(peo.age);</p> 
<p>    通过Constructor的newInstance方法创建对象，调用有参数的构造方法并赋值，输出2。</p> 
<p>     <span style="color:#ff0000">补充：默认构造器：</span></p> 
<p>    在Java中，如果用户没有一个类创建构造器，Java编译器就会自动识别，在JVM中为这个类创建一个默认构造器，这个构造器没有参数。当用户为类创建一个构造器时，不管这个构造器是否有参数，JVM就不再为该类创建一个无参的构造器了，为了防止这个类被其他类继承，所以我们要强调，在为类创建构造器时就要创建一个无参的构造器，以防止子类初始化时，调用父类的默认构造器。所以我们创建的这个无参构造器，也是默认构造器。</p> 
<p>    <span style="color:#ff0000">补充：newInstance 与 new 的区别：</span></p> 
<p>    1)、new的时候，这个要new的类可以没有加载；newInstance必须保证该类已经加载、已经连接，完成该任务的正是class的静态方法forName()方法，这个静态方法调用了启动类加载器(就是加载javaAPI的那个加载器)</p> 
<p>    2)、new是强类型，相对高效，能调用任何public构造；newInstance是弱类型，低效率，只能调用无参构造。</p> 
<p>    3)、new只能实现具体类的实例化，不适合于接口编程；newInstance是实现IOC、反射、面对接口编程和依赖倒置等技术方法的必然选择。</p> 
<p>    4)、newInstance就是通过该类的默认构造函数构建了一个对象，如果没有默认构造函数就抛出InstantiationException，如果没有访问默认构造函数的权限就抛出IIIegalAccessException。</p> 
<p><br> </p> 
<p>    <span style="font-size:18px"><strong>调用类的函数：</strong></span></p> 
<p>    通过反射获取类Method对象，调用Field的Invoke方法调用函数。</p> 
<p><br> </p> 
<p>    <span style="font-size:18px"><strong>设置 / 获取类的属性值：</strong></span></p> 
<p>    通过反射获取类的Field对象，调用Field方法设置或获取值。</p> 
<p><br> </p> 
<p>    <strong><span style="font-size:18px">动态Proxy创建代理类：</span></strong></p> 
<p>    待整理。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25cd98a7b06d3a3fe846ae024fa50ce5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java的内存分配机制(初步整理)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b13626b46c7a257f14617767330880a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 底部导航栏中间凸起、动态配置替换底部导航栏Tab图标(按钮、标签)的实现方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>