<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——二叉树-堆(堆的实现，堆排序，TopK问题) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/81e7359e43545df53f4c81965cc719f7/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="数据结构——二叉树-堆(堆的实现，堆排序，TopK问题)">
  <meta property="og:description" content="目录
前言
1.树的概念及结构
1.1 树的概念
1.2 树的相关概念
1.3 树的表示
2. 二叉树的概念及结构
2.1概念
2.2 特殊的二叉树
2.3 二叉树的性质
2.4 二叉树的存储结构
3. 堆
3.1 堆的概念及结构
3.2 堆的实现
3.1.2 数据结构的设计和文件准备
3.1.2堆的初始化和销毁
3.1.3 向下调整算法与向上调整算法
3.1.4 堆的插入和堆的删除
3.1.5 获取堆顶元素和堆的数据个数，堆的判空
3.3 建堆
4. 堆的应用
4.1 堆排序
4.1.2 思路
4.2.2 代码
4.1.3 时间复杂度的分析
4.2 TopK问题
4.2.1思路
4.2.2 代码实现
总结
前言 这篇文章介绍二叉树中的特殊的数据结构堆，堆的应用有堆排序和TopK问题。有详细的图文讲解，可以边看边敲，一起学起来吧！
1.树的概念及结构 1.1 树的概念 树是一种数据结构，它是由n(n≥0)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特定的节点被称为根节点或树根（root）。除根节点之外的其余数据元素被分为个互不相交的集合，其中每一个集合本身也是一棵树，被称作原树的子树（subtree）。树是递归定义的。 1.2 树的相关概念 我们以上面这颗树为例：
节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6
叶节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-23T18:32:40+08:00">
    <meta property="article:modified_time" content="2024-03-23T18:32:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——二叉树-堆(堆的实现，堆排序，TopK问题)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">1.树的概念及结构</a></p> 
<p id="1.1%20%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.1%20%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1.1 树的概念</a></p> 
<p id="1.2%20%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.2%20%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">1.2 树的相关概念</a></p> 
<p id="1.3%20%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA-toc" style="margin-left:40px;"><a href="#1.3%20%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA" rel="nofollow">1.3 树的表示</a></p> 
<p id="2.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#2.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">2. 二叉树的概念及结构</a></p> 
<p id="2.1%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2.1%E6%A6%82%E5%BF%B5" rel="nofollow">2.1概念</a></p> 
<p id="2.2%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#2.2%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">2.2 特殊的二叉树</a></p> 
<p id="2.3%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:40px;"><a href="#2.3%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">2.3 二叉树的性质</a></p> 
<p id="2.4%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.4%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" rel="nofollow">2.4 二叉树的存储结构</a></p> 
<p id="3.%20%E5%A0%86-toc" style="margin-left:0px;"><a href="#3.%20%E5%A0%86" rel="nofollow">3. 堆</a></p> 
<p id="3.1%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#3.1%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">3.1 堆的概念及结构</a></p> 
<p id="3.2%20%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#3.2%20%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">3.2 堆的实现</a></p> 
<p id="3.1.2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%96%87%E4%BB%B6%E5%87%86%E5%A4%87-toc" style="margin-left:80px;"><a href="#3.1.2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%96%87%E4%BB%B6%E5%87%86%E5%A4%87" rel="nofollow">3.1.2 数据结构的设计和文件准备</a></p> 
<p id="3.1.2%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#3.1.2%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81" rel="nofollow">3.1.2堆的初始化和销毁</a></p> 
<p id="3.1.3%20%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%E4%B8%8E%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#3.1.3%20%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%E4%B8%8E%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95" rel="nofollow">3.1.3 向下调整算法与向上调整算法</a></p> 
<p id="3.1.4%20%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#3.1.4%20%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">3.1.4 堆的插入和堆的删除</a></p> 
<p id="3.1.5%20%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%E5%92%8C%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%EF%BC%8C%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA-toc" style="margin-left:80px;"><a href="#3.1.5%20%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%E5%92%8C%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%EF%BC%8C%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA" rel="nofollow">3.1.5 获取堆顶元素和堆的数据个数，堆的判空</a></p> 
<p id="3.3%20%E5%BB%BA%E5%A0%86-toc" style="margin-left:40px;"><a href="#3.3%20%E5%BB%BA%E5%A0%86" rel="nofollow">3.3 建堆</a></p> 
<p id="4.%20%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:0px;"><a href="#4.%20%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow">4. 堆的应用</a></p> 
<p id="4.1%20%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#4.1%20%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">4.1 堆排序</a></p> 
<p id="4.1.2%20%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#4.1.2%20%E6%80%9D%E8%B7%AF" rel="nofollow">4.1.2 思路</a></p> 
<p id="4.2.2%20%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#4.2.2%20%E4%BB%A3%E7%A0%81" rel="nofollow">4.2.2 代码</a></p> 
<p id="4.1.3%20%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#4.1.3%20%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%88%86%E6%9E%90" rel="nofollow">4.1.3 时间复杂度的分析</a></p> 
<p id="4.2%20TopK%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#4.2%20TopK%E9%97%AE%E9%A2%98" rel="nofollow">4.2 TopK问题</a></p> 
<p id="4.2.1%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#4.2.1%E6%80%9D%E8%B7%AF" rel="nofollow">4.2.1思路</a></p> 
<p id="4.2.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#4.2.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">4.2.2 代码实现</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<h2 id="%E5%89%8D%E8%A8%80" style="background-color:transparent;">前言</h2> 
<p>这篇文章介绍二叉树中的特殊的数据结构堆，堆的应用有堆排序和TopK问题。有详细的图文讲解，可以边看边敲，一起学起来吧！</p> 
<p></p> 
<hr> 
<h2 id="1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">1.树的概念及结构</h2> 
<h3 id="1.1%20%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">1.1 树的概念</h3> 
<p>树是一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fromModule=lemma_inlink" rel="nofollow" title="数据结构">数据结构</a>，它是由n(n≥0)个有限节点组成一个具有层次关系的<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117?fromModule=lemma_inlink" rel="nofollow" title="集合">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p> 
<ul><li>有一个特定的节点被称为根节点或树根（<a href="https://baike.baidu.com/item/root/73226?fromModule=lemma_inlink" rel="nofollow" title="root">root</a>）。</li><li>除根节点之外的其余数据元素被分为个互不相交的集合，其中每一个集合本身也是一棵树，被称作原树的子树（subtree）。</li><li>树是<strong>递归定义</strong>的。</li></ul> 
<p><img alt="" height="337" src="https://images2.imgbox.com/01/e5/cI4fuQbl_o.png" width="586"></p> 
<p></p> 
<h3 id="1.2%20%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">1.2 树的相关概念</h3> 
<p><img alt="" height="328" src="https://images2.imgbox.com/a9/96/xWvsBZDc_o.png" width="575"></p> 
<p>我们以上面这颗树为例：</p> 
<blockquote> 
 <p><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6<br><strong>叶节点或终端节点</strong>：度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点<br> 非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点<br><strong>双亲节点或父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点。<br><strong>孩子节点或子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点。<br> 兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点。<br><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6。<br><strong>节点的层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；。<br><strong>树的高度或深度</strong>：树中节点的最大层次； 如上图：树的高度为4。<br> 堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点。<br> 节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先。<br> 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙。<br> 森林：由m（m&gt;0）棵互不相交的树的集合称为森林。</p> 
</blockquote> 
<p></p> 
<h3 id="1.3%20%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA">1.3 树的表示</h3> 
<p>树的结构相对于之前学的线性表更复杂，存储表示起来也比较麻烦，<strong>既要保存值域，也要保存结点和结点之间的关系</strong>，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及<strong>孩子兄弟表示法</strong>等。这里展示孩子兄弟表示法，这个方法是非常棒的一种方法。</p> 
<pre><code class="language-cpp">typedef int DataType;
struct Node
{
    struct Node* firstChild1; // 第一个孩子结点
    struct Node* pNextBrother;// 指向其下一个兄弟结点
    DataType data;            // 结点中的数据域
};</code></pre> 
<p><img alt="" height="309" src="https://images2.imgbox.com/11/5d/SwQASRtK_o.png" width="1029"></p> 
<p></p> 
<h2 id="2.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">2. 二叉树的概念及结构</h2> 
<h3 id="2.1%E6%A6%82%E5%BF%B5">2.1概念</h3> 
<p>一棵二叉树是结点的一个有限集合，该集合:或者为空，或者由一个根节点加上两棵别称为左子树和右子树的二叉树组成。</p> 
<p><img alt="" height="417" src="https://images2.imgbox.com/ff/2e/2ybXmWf1_o.png" width="546"></p> 
<p>从上图可以看出：</p> 
<ul><li>二叉树不存在度大于2的结点</li><li>二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树</li></ul> 
<p>且对于任意的二叉树都是有下面的几种情况合成的：</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/3e/6d/fHUX1ift_o.png" width="812"></p> 
<p></p> 
<h3 id="2.2%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91">2.2 特殊的二叉树</h3> 
<blockquote> 
 <ol><li><strong>满二叉树</strong>：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是2^k-1，则它就是满二叉树。</li><li><strong>完全二叉树</strong>：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。</li></ol> 
</blockquote> 
<p><img alt="" height="455" src="https://images2.imgbox.com/ed/6e/IvpxDw3f_o.png" width="1200"></p> 
<h3 id="2.3%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">2.3 二叉树的性质</h3> 
<ol><li>若规定根节点的层数为1，则一棵非空二叉树的<strong>第i层上最多有2^(i-1)个结点</strong>。</li><li>若规定根节点的层数为1，则<strong>深度为h的二叉树的最大结点数是2^h-1</strong>。</li><li>对任何一棵二叉树, 如果度为0其叶结点个数为n0 , 度为2的分支结点个数为n2 ,则有<strong>n0 ＝n2 ＋1。</strong></li><li>若规定根节点的层数为1，具有<strong>n个结点的满二叉树的深度</strong>，h=log2(n+1)。 (ps：是log以2为底，n+1为对数)。</li><li>对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对于序号为i的结点有：</li></ol> 
<ul><li><strong>若i&gt;0，i位置节点的双亲序号</strong>：(i-1)/2；i=0，i为根节点编号，无双亲节点</li><li>若2i+1&lt;n，左孩子序号：2i+1，2i+1&gt;=n否则无左孩子</li><li>若2i+2&lt;n，右孩子序号：2i+2，2i+2&gt;=n否则无右孩子</li></ul> 
<p></p> 
<h3 id="2.4%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">2.4 二叉树的存储结构</h3> 
<p>二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。</p> 
<p>1.<strong>顺序存储</strong></p> 
<p>顺序结构存储就是使用数组来存储，一般使用数组<strong>只适合表示完全二叉树</strong>，因为不是完全二叉树会有空间的浪费。而现实中使用中只有<strong>堆才会使用数组来存储</strong>。二叉树顺序存储在<strong>物理上是一个数组，在逻辑上是一颗二叉树</strong>。</p> 
<p>下图中，完全二叉树的春旭存储没有浪费数组空间，而非完全二叉树的存储，需要补齐一些树的空间，体现在数组中就是不存储有效值。没有填写有效值，会被系统赋值为随机值，浪费空间极大。</p> 
<p><img alt="" height="691" src="https://images2.imgbox.com/f4/65/L4CHGPMr_o.png" width="1200"></p> 
<p>2.<strong>链式存储</strong></p> 
<p>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。链式结构又分为二叉链和三叉链，现在我们学习一般的都是二叉链。</p> 
<pre><code class="language-cpp">typedef int BTDataType;
// 二叉链
struct BinaryTreeNode
{
    struct BinTreeNode* _pLeft;  // 指向当前节点左孩子
    struct BinTreeNode* _pRight; // 指向当前节点右孩子
    BTDataType _data;            // 当前节点值域
}</code></pre> 
<p>我们下一个章节会讲解二叉链实现。</p> 
<p></p> 
<h2 id="3.%20%E5%A0%86">3. 堆</h2> 
<h3 id="3.1%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">3.1 堆的概念及结构</h3> 
<p>堆通常是一个可以被看做一棵树的数组对象。堆的物理结构本质上是顺序存储的，是线性的。但在逻辑上不是线性的，是完全二叉树的这种逻辑储存结构。 堆的这个数据结构，里面的成员包括一维数组，数组的容量，数组元素的个数，有两个直接后继。</p> 
<p>堆总是满足下列性质：</p> 
<ul><li>堆中某个结点的值总是<strong>不大于或不小于</strong>其父结点的值；</li><li>堆总是一棵完全二叉树。将<strong>根结点最大</strong>的堆叫做最大堆或大根堆，<strong>根结点最小</strong>的堆叫做最小堆或小根堆。</li></ul> 
<p><img alt="" height="743" src="https://images2.imgbox.com/84/b7/Yt3ks7QY_o.png" width="878"></p> 
<p></p> 
<h3 id="3.2%20%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0">3.2 堆的实现</h3> 
<p>在实现堆之前，需要准备三个文件，分别是Heap.h，Heap.c和test.c。</p> 
<ul><li>Heap.h文件用来存放堆的数据结构的设计和各种接口函数的声明。</li><li>Heap.c文件里面存放各种接口函数的实现。</li><li>test.c文件是用来写测试函数，检验接口函数的功能。</li></ul> 
<h4 id="3.1.2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%96%87%E4%BB%B6%E5%87%86%E5%A4%87">3.1.2 数据结构的设计和文件准备</h4> 
<p>堆的存储结构本质是数组，所以数据结构的设计跟顺序表相同，有一个数组，一个存储数据个数的值，另外一个存储数据容量大小。</p> 
<pre><code class="language-cpp">typedef int HPDataType;

typedef struct Heap
{
	HPDataType* a;
	int size;
	int capacity;
}HP;

//堆的初始化
void HPInit(HP* php);
//堆的销毁
void HPDestroy(HP* php); 
//堆的插入
void HPPush(HP* php, HPDataType x);
//删除堆顶的数据
void HPPop(HP* php);
//获取堆顶数据
HPDataType HPTop(HP* php);
//堆的数据个数
int HeapSize(HP* hp);
//堆的判空
bool HPEmpty(HP* php);
//交换数据
void Swap(HPDataType* px, HPDataType* py);</code></pre> 
<p></p> 
<h4 id="3.1.2%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81">3.1.2堆的初始化和销毁</h4> 
<p>堆的存储结构本质上是数组，所以初始化操作只需要把数组置空，数据个数和容量赋值为零即可。而堆的销毁只需要释放动态开辟的空间。</p> 
<pre><code class="language-cpp">void HPInit(HP* php)
{
	assert(php);
	php-&gt;a = NULL;
	php-&gt;size = 0;
	php-&gt;capacity = 0;
}

void HPDestroy(HP* php)
{
	assert(php);
	free(php-&gt;a);
	php-&gt;a = NULL;
	php-&gt;capacity = php-&gt;size = 0;
}</code></pre> 
<p></p> 
<h4 id="3.1.3%20%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95%E4%B8%8E%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95" style="background-color:transparent;">3.1.3 向下调整算法与向上调整算法</h4> 
<p>现在有一个数组，逻辑上看成一个完全二叉树。观察下图，根节点的左右子树都是小堆，但是根节点不满足堆的性质，不是最小的数。这个时候就可以使用向下调整算法使其变成一个小堆。</p> 
<p>注意：只有左右子树都是小堆才能进行向下调整算法。（如果要调整大堆，左右子树就必须是大堆，如无特别声明，都是以小堆为主）</p> 
<pre><code class="language-cpp">int arr[] = {27,15,19,18,28,34,65,49,25,37};</code></pre> 
<p><img alt="" height="269" src="https://images2.imgbox.com/01/52/B6AjtN1l_o.png" width="362"></p> 
<p>如下面所示，我们利用父亲结点和孩子结点的式子关系，让根节点和孩子节点比较，如果比孩子结点小，就交换。</p> 
<ul><li>leftchild = parent * 2 + 1</li><li>rightchild = parent * 2 + 2</li><li>parent = chlid - 1</li></ul> 
<p><img alt="" height="395" src="https://images2.imgbox.com/34/9c/siWplmJR_o.png" width="1200"></p> 
<p> 代码如下，先写一个交换函数，因为后面的接口函数也会复用。</p> 
<pre><code class="language-cpp">void Swap(HPDataType* px, HPDataType* py)
{
	HPDataType tmp = *px;
	*px = *py;
	*py = tmp;
}

void AdjustDown(HPDataType* a, int n, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; n)
	{
        //假设法，选出小的那个孩子
		if (child+ 1 &lt; n &amp;&amp; a[child + 1] &lt; a[child])
		{
			++child;
		}
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<p>与向下调整算法类似，向上调整算法需要保证这个完全二叉树满足堆的性质，在尾部插入一个数据，然后向上跟父亲结点比较大小，进行交换。</p> 
<pre><code class="language-cpp">void AdjustUp(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)//parent &gt; 0不行
	{
		if (a[child] &lt; a[parent])//小堆
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (parent - 1) / 2;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<p></p> 
<h4 id="3.1.4%20%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4">3.1.4 堆的插入和堆的删除</h4> 
<p>堆的插入是在存储结构数组最后面插入一个数据，然后再使用向上调整算法，使其符合堆的性质。首先检查数据容量大小是否足够，不够就扩容。然后将x值插入到数组后面。</p> 
<pre><code class="language-cpp">void HPPush(HP* php, HPDataType x)
{
	assert(php);
	if (php-&gt;size == php-&gt;capacity)
	{
		size_t newCapacity = php-&gt;capacity == 0 ? 4 : php-&gt;capacity * 2;
		HPDataType* tmp = realloc(php-&gt;a, sizeof(HPDataType) * newCapacity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}
		php-&gt;a = tmp;
		php-&gt;capacity = newCapacity;
	}
	
	php-&gt;a[php-&gt;size] = x;
	php-&gt;size++;

	AdjustUp(php-&gt;a, php-&gt;size - 1);
}</code></pre> 
<p>堆的删除一般指的是删除堆顶元素。将堆顶元素删除后，如果直接将孩子结点元素向上移动会破坏堆的结构。所以，合适的操作是先将堆顶元素与最后一个结点元素交换，再删除最后一个节点元素。对根节点进行向下调整算法，使其成为一个堆。</p> 
<pre><code class="language-cpp">void HPPop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);

	Swap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);
	php-&gt;size--;

	AdjustDown(php-&gt;a, php-&gt;size, 0);
}</code></pre> 
<p></p> 
<h4 id="3.1.5%20%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%E5%92%8C%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%EF%BC%8C%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA">3.1.5 获取堆顶元素和堆的数据个数，堆的判空</h4> 
<p>获取堆顶元素和获取堆的数据个数比较简单。堆的判空直接返回数据个数是否为零的判断。</p> 
<pre><code class="language-cpp">HPDataType HPTop(HP* php)
{
	assert(php);
	return php-&gt;a[0];
}

int HeapSize(HP* hp)
{
	return hp-&gt;size;
}

bool HPEmpty(HP* php)
{
	assert(php);
	return php-&gt;size == 0;
}</code></pre> 
<h3 id="3.3%20%E5%BB%BA%E5%A0%86" style="background-color:transparent;">3.3 建堆</h3> 
<p>建堆就是通过使用堆的插入这个函数，将一个数组的逻辑结构转变成堆，然后我们使用while循环进行堆删除的操作，对删除是删除对顶的元素。</p> 
<pre><code class="language-cpp">int main2()
{
	int a[] = { 50,100,70,65,60,32 };

	HP hp;
	HPInit(&amp;hp);
	for (int i = 0; i &lt; sizeof(a) / sizeof(int); i++)
	{
		HPPush(&amp;hp, a[i]);
	}

	while (!HPEmpty(&amp;hp))
	{
		printf("%d ", HPTop(&amp;hp));
		HPPop(&amp;hp);
	}

	HPDestroy(&amp;hp);
	return 0;
}</code></pre> 
<p>运行结果如下，我们会发现从小到大打印在控制台上，因为每次取堆顶元素，然后再进行堆的删除，堆顶元素是最小的元素，所以是升序打印。</p> 
<p><img alt="" height="65" src="https://images2.imgbox.com/9d/9b/j3JRV9z4_o.png" width="332"></p> 
<p></p> 
<h2 id="4.%20%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8">4. 堆的应用</h2> 
<h3 id="4.1%20%E5%A0%86%E6%8E%92%E5%BA%8F" style="background-color:transparent;">4.1 堆排序</h3> 
<h4 id="4.1.2%20%E6%80%9D%E8%B7%AF">4.1.2 思路</h4> 
<p>堆排序就是利用堆的性质进行排序。堆排序分为两个步骤：</p> 
<p>1.<strong>建堆</strong>：</p> 
<ul><li>升序：建大堆</li><li>降序：建小堆</li></ul> 
<p>2.利用<strong>堆删除的思想</strong>来排序。</p> 
<ul><li>堆的性质是不管那个结点的值都<strong>不小于或者不大于</strong>父亲结点的值。假设我们要排升序，<strong>需要建一个大堆</strong>，那么<strong>根结点的值是最大</strong>。但要注意的是，使用向下调整算法建大堆，最后一层不用调整，要从最后一个叶子结点的父亲结点开始使用向下调整算法，一直到根结点。</li><li>接着跟堆的删除操作一样先将根节点的值和尾结点的值进行交换，此时尾结点就是最大的值。然后对此时的根节点使用向下调整算法，那么根节点的值是除了开始调整到尾结点的值中的最大值。</li><li>现在下面有一组数据，我们使用堆排序算法来排升序</li></ul> 
<pre><code class="language-cpp">int arr[] = { 11,8,3,5,21,15 }</code></pre> 
<p><img alt="" height="511" src="https://images2.imgbox.com/30/53/gPlPGz1l_o.png" width="1013"></p> 
<p><img alt="" height="651" src="https://images2.imgbox.com/fb/ef/DyKyT3Wy_o.png" width="1025"></p> 
<h4 id="4.2.2%20%E4%BB%A3%E7%A0%81">4.2.2 代码</h4> 
<p>代码如下：</p> 
<pre><code class="language-cpp">void Swap(HPDataType* px, HPDataType* py)
{
	HPDataType tmp = *px;
	*px = *py;
	*py = tmp;
}

void AdjustDown(HPDataType* a, int n, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; n)
	{
        //假设法，选出小的那个孩子
		if (child+ 1 &lt; n &amp;&amp; a[child + 1] &lt; a[child])
		{
			++child;
		}
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

void HeapSort(int* a, int n)
{
	//a数组向下调整算法建堆
	for (int i = (n-1-1)/2;i&gt;=0; i--)
	{
		AdjustDown(a, n, i);
	}

	//利用堆的删除的思想，只需要交换n-1次
	int end = n - 1;
	while (end &gt; 0)
	{
		Swap(&amp;a[0], &amp;a[end]);
		AdjustDown(a, end, 0);
		--end;
	}
}

int main()
{
	int a[] = { 50,100,70,65,60,32,26,43,82,54 };
	int size = sizeof(a) / sizeof(int);

	HeapSort(a, size);

	for (int i = 0; i &lt; size; i++)
	{
		printf("%d ", a[i]);
	}
	printf("\n");

	return 0;
}</code></pre> 
<p>结果如下：</p> 
<p><img alt="" height="68" src="https://images2.imgbox.com/8d/e3/veJKHxaF_o.png" width="405"></p> 
<p></p> 
<h4 id="4.1.3%20%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%88%86%E6%9E%90">4.1.3 时间复杂度的分析</h4> 
<p>堆排序主要分为两个部分一个是建堆，然后进行交换元素进行向下调整。</p> 
<ul><li>建堆的复杂度是O(N)</li><li>向下调整的复杂度是O(logN)，是以2为底数的对数。</li></ul> 
<p>所以时间复杂度就是O(N*logN)，算是排序中比较快的算法了。</p> 
<p></p> 
<h3 id="4.2%20TopK%E9%97%AE%E9%A2%98">4.2 TopK问题</h3> 
<h4 id="4.2.1%E6%80%9D%E8%B7%AF">4.2.1思路</h4> 
<p>TOP-K问题：即求数据结合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大。</p> 
<p>比如：专业前10名、世界500强、富豪榜、游戏中前100的活跃玩家等。</p> 
<p>对于这种问题，一般会想到使用排序，但是数据量非常大的情况下，排序不太可取，因为数据可能不能一下子加载到内存中。最佳的方法还是用堆来解决：</p> 
<p>1.<strong>用数据集合中前K个元素来建堆</strong></p> 
<ul><li>前k个最大的元素，建小堆</li><li>前k个最小的元素，建大堆</li></ul> 
<p>2.<strong>用剩余的N-K个元素依次与堆顶元素进行比较，不满足则替换堆顶元素</strong></p> 
<p>比如，要找前k个最大的元素，我们建k个元素的小堆，只要剩下的元素的值比堆顶元素大，就与堆顶元素发生交换，并使用向下调整算法，这样子在堆顶的元素一定是最小的，在堆顶的元素如果不是前k个最大元素，就会被剩下的元素中出现的前k个最大元素所替代，这样子就可以解决TopK问题了。</p> 
<p>大家需要注意的是，当堆排序排升序的时候需要建大堆，而TopK问题找前k个最大的元素是建小堆。两者不一样。</p> 
<p></p> 
<h4 id="4.2.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">4.2.2 代码实现</h4> 
<p>我们先要创建一个文件，并随机生成十万个数据。这里需要用到srand函数，并传入时间戳time。并写入文件中。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;

void CreateDate()
{
	int num = 100000;
	const char* file = "data.txt";
	FILE* fin = fopen(file, "w");
	if (fin == NULL)
	{
		perror("File: fin open fail");
		exit(-1);
	}
    //时间戳的随机数
	srand(time(0));
	for (int i = 0; i &lt; num; i++)
	{	//生成0~999999的数
		fprintf(fin, "%d\n", (rand() + i) % 1000000);
	}
	
	fclose(fin);
}</code></pre> 
<p>以只读的方式打开文件，然后动态开辟一个k个大小的数组。将前k个元素赋值到数组中，使用向下调整算建小堆。之后用while循环读取剩下元素，比堆顶大的元素，与其进行交换，再向下调整，直到结束。</p> 
<pre><code class="language-cpp">void TopK()
{
	printf("请输入k:&gt;");
	int k = 0;
	scanf("%d", &amp;k);

	//打开文件
	const char* file = "data.txt";
	FILE* fout = fopen(file, "r");
	if (fout == NULL)
	{
		perror("fopen fail");
		exit(-1);
	}

	//新建一个数组
	int* arr = (int*)malloc(sizeof(int) * k);
	if (arr == NULL)
	{
		perror("malloc fail");
		exit(-1);
	}

	//读取k个数据到新建的堆中
	for (int i = 0; i &lt; k; i++)
	{
		fscanf(fout, "%d", &amp;arr[i]);
	}

	//建小堆，向下调整
	for (int i = (k - 1 - 1) / 2; i &gt;= 0; i--)
	{
		AdjustDown(arr, k, i);
	}

	int x = 0;
	while (fscanf(fout, "%d", &amp;x) != EOF)
	{
		//比较另外的N-K个数与堆顶的大小
		if (x &gt; arr[0])
		{
			arr[0] = x;
			AdjustDown(arr, k, 0);
		}
	}

	for (int i = 0; i &lt; k; i++)
	{
		printf("%d\n", arr[i]);
	}

	fclose(fout);
}

int main()
{
	CreateDate();
	TopK();

	return 0;</code></pre> 
<p> </p> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93" style="background-color:transparent;"><a id="_45"></a>总结</h2> 
<p>一开始的顺序表和链表适用于存储数据。当开始学习树的数据结构，会发现树的结构十分复杂，如果仅用于存储，还不如一开始学习顺序表和链表。但是树也确实有其他的重要功能，难度会陡然上升，需要前面牢固的数据结构基础。因此，更需要我们大量的练习。</p> 
<p><strong>创作不易，希望这篇文章能给你带来启发和帮助，如果喜欢这篇文章，请留下你的三连，你的支持的我最大的动力！！！</strong></p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/d5/f8/PltU6xDu_o.png" width="102"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a8d3791cf10e3dcbf48a1ef858a404f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI大模型学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/669a05b18da24116f8d6e2bb09d8e39e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C语言】预处理&amp;&amp;编译链接&amp;&amp;调试技巧详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>