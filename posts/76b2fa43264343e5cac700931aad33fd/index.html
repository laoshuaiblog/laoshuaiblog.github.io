<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java--Spring之AOP面向切面编程 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/76b2fa43264343e5cac700931aad33fd/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Java--Spring之AOP面向切面编程">
  <meta property="og:description" content="一、JDK动态代理 具体可参考之前博文 Java--JDK动态代理(AOP)
在这里只做简单说明
动态代理是指代理类在程序运行时进行创建的代理方式。这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据Java代码中的“指示”动态生成的。（动态代理中的代理类并不要求在编译期就确定，而是可以在运行期动态生成，从而实现对目标对象的代理功能）
相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数
动态代理又分为两种方式
（1）JDK动态代理：
使用java反射包中的类和接口实现动态代理的功能。反射包 java.lang.reflect , 里面有三个类 ： InvocationHandler , Method, Proxy
（2）Cglib动态代理：
一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。 通过继承目标类，在子类中重写父类同名方法，实现功能修改（重写的方法不能是final）
JDK原生动态代理
JDK原生动态代理主要是使用Java中的反射机制，使用了反射包 java.lang.reflect下的三个类
InvocationHandler , Method, Proxy
JDK动态代理步骤
（1）创建接口，定义目标类要完成的功能
（2）创建目标类实现接口
（3）创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能（调用目标方法，增强功能）
（4）使用Proxy类的静态方法，创建代理对象。 并把返回值转为接口类型
如下创建一个MyInvocationHandler
public class MyInvocationHandler implements InvocationHandler { //目标对象 private Object target; public MyInvocationHandler(Object target){ this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object res = null; System.out.println(&#34;执行了InvocationHandler中的invoke()方法：&#34; &#43; method.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-08-13T06:58:02+08:00">
    <meta property="article:modified_time" content="2022-08-13T06:58:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java--Spring之AOP面向切面编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3></h3> 
<h3>一、JDK动态代理</h3> 
<p>具体可参考之前博文 <a class="link-info" href="https://blog.csdn.net/MinggeQingchun/article/details/122517100" title="Java--JDK动态代理(AOP)">Java--JDK动态代理(AOP)</a></p> 
<p>在这里只做简单说明</p> 
<p>动态代理是指代理类在程序运行时进行创建的代理方式。这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据Java代码中的“指示”动态生成的。（动态代理中的代理类并不要求在编译期就确定，而是可以在运行期动态生成，从而实现对目标对象的代理功能）</p> 
<p>相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数</p> 
<p>动态代理又分为两种方式</p> 
<p>（1）JDK动态代理：</p> 
<p>使用java反射包中的类和接口实现动态代理的功能。反射包 java.lang.reflect , 里面有三个类 ： InvocationHandler , Method, Proxy</p> 
<p>（2）Cglib动态代理：</p> 
<p>一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。 通过继承目标类，在子类中重写父类同名方法，实现功能修改（重写的方法不能是final）</p> 
<p>JDK原生动态代理</p> 
<p>JDK原生动态代理主要是使用Java中的反射机制，使用了反射包 java.lang.reflect下的三个类</p> 
<p>InvocationHandler , Method, Proxy</p> 
<p>JDK动态代理步骤</p> 
<p>（1）创建接口，定义目标类要完成的功能</p> 
<p>（2）创建目标类实现接口</p> 
<p>（3）创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能（调用目标方法，增强功能）</p> 
<p>（4）使用Proxy类的静态方法，创建代理对象。 并把返回值转为接口类型</p> 
<p>如下创建一个MyInvocationHandler</p> 
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {

    //目标对象
    private Object target;

    public MyInvocationHandler(Object target){
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object res = null;

        System.out.println("执行了InvocationHandler中的invoke()方法：" + method.getName());

        String methodName = method.getName();
        if ("doSome".equals(methodName)){
            //在目标方法之前，输出日志时间
            ServiceTools.doLog();

            //执行目标类的方法，通过Method类实现
            res = method.invoke(target,args);

            //提交事务
            ServiceTools.doTransaction();
        }else {
            res = method.invoke(target,args);
        }

        return res;
    }
}</code></pre> 
<pre><code class="language-java">public class TestApp {
    public static void main(String[] args) {
        System.out.println("========== 原始方法new对象创建 ==========");
        SomeService someService = new SomeServiceImpl();
        someService.doSome();;
        someService.doOther();


        System.out.println("========== JDK动态代理创建代理对象，实现方法 ==========");
        /**
         使用JDK代理创建代理对象，以及实现方法
         * */
        //创建目标对象
        SomeService target = new SomeServiceImpl();

        //创建InvocationHandler对象
        InvocationHandler handler = new MyInvocationHandler(target);

        //使用Proxy创建代理
        SomeService proxy = (SomeService) Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                handler);
        //com.sun.proxy.$Proxy0
        System.out.println("proxy=="+proxy.getClass().getName());
        //通过代理方法执行方法，调用invocationHandler中的invoke方法
        proxy.doSome();
        proxy.doOther();
    }
}</code></pre> 
<p>动态代理的作用</p> 
<p>1、在目标类源代码不改变的情况下，增加功能</p> 
<p>2、减少重复代码，专注业务逻辑代码</p> 
<p>3、解耦合，让业务功能和日志，事务等非业务功能分离</p> 
<p></p> 
<h3>二、AOP</h3> 
<p><span style="color:#fe2c24;"><strong>AOP</strong></span>（<strong><span style="color:#fe2c24;">Aspect Orient Programming</span></strong>），<strong>面向切面编程</strong></p> 
<p>面向切面编程，就是将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到 主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志、缓存等。</p> 
<p>AOP 是 Spring 框架中的一个重要内容。利用 AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p> 
<p>AOP 底层，就是采用动态代理模式实现的；采用了两种代理<span style="color:#000000;">：</span><span style="color:#ff0000;">JDK </span><span style="color:#ff0000;">动态代理</span><span style="color:#000000;">，</span><span style="color:#ff0000;">CGLIB动态代理</span></p> 
<p>1、Aspect：切面，泛指交叉业务逻辑，给目标类增加的功能，就是切面。如日志，事务等都是切面。常用的切面 是通知（Advice）。实际就是对主业务逻辑的一种增强</p> 
<p>切面的特点： 一般都是非业务方法，独立使用</p> 
<p><strong>2、JoinPoint：连接点</strong>，指可以被切面织入的具体方法。通常业务接口中的方法均为连接点</p> 
<p><strong>3、Pointcut：切入点，</strong>指声明的一个或多个连接点的集合。通过切入点指定一组方法</p> 
<p>被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改的，不能被增强</p> 
<p><strong>4、Target：目标对象，</strong>指 将 要 被 增 强 的 对 象 。 即 包 含 主 业 务 逻 辑 的 类 的 对 象</p> 
<p><strong>5、Advice：通知，</strong>表示切面的执行时间，<strong>Advice 也叫增强</strong>；<strong>通知定义了增强代码切入到目标代码的时间点</strong>，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。 <strong>切入点定义切入的位置，通知定义切入的时间</strong></p> 
<p>AOP 是一种编程思想，很多框架都进行了实现，Spring就是其中之一</p> 
<p><strong>在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式</strong></p> 
<p><span style="color:#fe2c24;"><strong>AspectJ </strong></span>：AspectJ 是一个优秀面向切面的框架，它扩展了 Java 语言，提供了强大的切面实现</p> 
<p>AspetJ 是 Eclipse 的开源项目，其官网地址<strong>：</strong><a class="link-info" href="http://www.eclipse.org/aspectj/" rel="nofollow" title="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a><span style="color:#0000ff;"><strong> </strong></span></p> 
<h3></h3> 
<h3>三、AspetJ</h3> 
<h4>（一）AspetJ切入点 表达式</h4> 
<p>AspectJ 定义了专门的表达式用于指定切入点。表达式的原型是</p> 
<pre><code class="language-java">execution(modifiers-pattern? ret-type-pattern 
declaring-type-pattern?name-pattern(param-pattern)
 throws-pattern?)</code></pre> 
<p>modifiers-pattern] 访问权限类型</p> 
<p>ret-type-pattern 返回值类型</p> 
<p>declaring-type-pattern 包名类名</p> 
<p>name-pattern(param-pattern) 方法名(参数类型和参数个数)</p> 
<p>throws-pattern 抛出异常类型</p> 
<p>？表示可选的部分</p> 
<p>以上表达式共 4 个部分</p> 
<pre><code class="language-java">execution(访问权限 方法返回值 方法声明(参数) 异常类型)</code></pre> 
<p>如下：</p> 
<pre><code class="language-java">execution(public * *(..)) 
指定切入点为：任意公共方法

execution(* set*(..)) 
指定切入点为：任何一个以“set”开始的方法

execution(* com.xx.service.*.*(..)) 
指定切入点为：定义在 service 包里的任意类的任意方法

execution(* com.xx.service..*.*(..))
指定切入点为：定义在 service 包或者子包里的任意类的任意方法
“..”出现在类名中时，后面必须跟“*”，表示包、子包下的所有类

execution(* *..service.*.*(..))
指定所有包下的 serivce 子包下所有类（接口）中所有方法为切入点

execution(* *.service.*.*(..))
指定只有一级包下的 serivce 子包下所有类（接口）中所有方法为切入点</code></pre> 
<h4>（二）AspetJ通知注解</h4> 
<p></p> 
<p>（1）前置通知（2）后置通知（3）环绕通知（4）异常通知（5）最终通知</p> 
<p>使用aspectj实现aop步骤：</p> 
<p>1、新建maven项目</p> 
<p>2、加入依赖 （1）spring依赖 （2）aspectj依赖  pom.xml文件</p> 
<pre><code class="language-html">&lt;dependencies&gt;

        &lt;!-- 单元测试依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.11&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!--spring依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--aspectj依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
            &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;</code></pre> 
<p>3、创建目标类：接口和其实现类（给类中方法增加功能）</p> 
<pre><code class="language-java">public interface SomeService {
    void doSome(String name,Integer age);
}

public class SomeServiceImpl implements SomeService {
    @Override
    public void doSome(String name, Integer age) {
        System.out.println("====目标方法doSome()====");
    }

    public void doOther(String name,Integer age) {
        System.out.println("====目标方法doOther()====");
    }
}</code></pre> 
<p>4、创建切面类 （1）在类上面加 @Aspect注解 （2）在类中定义方法，方法就是切面要执行的功能代码 在方法上加入aspectj的通知注解，如@Before，有切入点表达式execution()</p> 
<p>5、创建spring配置文件：声明对象，把对象交给容器统一管理 （1）声明目标对象 （2）声明切面类对象 （3）声明aspectj框架中的自动dialing生成器标签 自动代理生成器：用来完成代理对象的自动创建功能</p> 
<p>spring主配置文件applicationContext.xml文件</p> 
<p>&lt;aspectj-autoproxy&gt;：会把spring容器中所有的目标对象，一次性都生成代理对象</p> 
<p>声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象的代理对象；创建代理对象是在内存中实现的，修改目标对象的内存结构，创建为代理对象，目标对象就是被修改后的代理对象</p> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- 讲对象交给spring容器，由spring容器统一创建，管理对象 --&gt;
    &lt;!-- 声明目标对象 --&gt;
    &lt;bean id="someService" class="com.xx.SomeServiceImpl" /&gt;

    &lt;!-- 声明切面类对象 --&gt;
    &lt;bean id="myAspect" class="com.xx.MyAspect" /&gt;

    &lt;!-- 声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象的代理对象
        创建代理对象是在内存中实现的，修改目标对象的内存结构，创建为代理对象
        目标对象就是被修改后的代理对象

        aspectj-autoproxy：会把spring容器中所有的目标对象，一次性都生成代理对象
     --&gt;
    &lt;aop:aspectj-autoproxy /&gt;

&lt;/beans&gt;</code></pre> 
<p>加入 &lt;aop:aspectj-autoproxy /&gt; 标签之后spring配置文件变化如下</p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/f6/f5/tincUzZI_o.png"></p> 
<p>6、创建测试类 </p> 
<pre><code class="language-java">@Test
    public void testAdvice(){
        String config = "applicationContext.xml";
        ApplicationContext ac = new ClassPathXmlApplicationContext(config);

        //从容器中获取目标对象
        SomeService someService = (SomeService) ac.getBean("someService");

        //proxy：com.sun.proxy.$Proxy8
        System.out.println("proxy：" + someService.getClass().getName());

        //通过代理对象执行方法，实现目标方法执行时，增强功能
        someService.doSome("wang",18);
    }</code></pre> 
<p>1、前置通知</p> 
<pre><code class="language-java">/**
 @Aspect ：是aspectj框架中的注解
 作用：表示当前类是切面类
 切面类：用来给业务方法增加功能的类，这个类中有切面的功能代码
 位置：在类定义上面
 */
@Aspect
public class MyAspect {
    /**
     定义方法，方法是实现切面功能的
     方法定义要求
        1、公共方法  public
        2、方法没有返回值
        3、方法名称自定义
        4、方法可以有参数（写参数类型），也可以无参
     */

    /**
     @Before ：前置通知注解
        属性：value，切入点表达式，表示切面功能执行的位置
        位置：在方法上面
        特点：
           （1）在目标方法之前执行
           （2）不会改变目标方法的执行结果
           （3）不影响目标方法的执行
     */
    //访问修饰符，返回值类型，包名类名，方法名，形参列表（参数类型，参数个数）
    //Shift + Ctrl + / 多行注释；Ctrl + / 单行注释
    @Before(value = "execution(public void com.mycompany.p1before.SomeServiceImpl.doSome(String,Integer))")
    public void myBefore(){
        //切面执行的功能代码
        System.out.println("前置通知，切面功能：在目标方法之前输出执行时间：" + new Date());
    }

    //省略修饰符
    @Before(value = "execution(void com.mycompany.p1before.SomeServiceImpl.doSome(String,Integer))")
    public void myBefore1(){
        //切面执行的功能代码
        System.out.println("前置通知1，切面功能：在目标方法之前输出执行时间：" + new Date());
    }

    //省略包名；*.. 表示包、子包下 ；*. 表示一级包
    @Before(value = "execution(void *..SomeServiceImpl.doSome(String,Integer))")
    public void myBefore2(){
        System.out.println("前置通知2，切面功能：在目标方法之前输出执行时间：" + new Date());
    }

    //可使用 * 或者 *. 和 *.. 代替修饰符，返回值，包名方法名，参数等
    @Before(value = "execution(* *..SomeServiceImpl.*(..))")
    public void myBefore3(){
        System.out.println("前置通知3，切面功能：在目标方法之前输出执行时间：" + new Date());
    }

    @Before(value = "execution(* do*(..))")
    public void myBefore4(){
        System.out.println("前置通知4，切面功能：在目标方法之前输出执行时间：" + new Date());
    }
}</code></pre> 
<p>2、后置通知</p> 
<pre><code class="language-java">@Aspect
public class MyAspect {
    /**
     后置通知定义方法，方法是实现切面功能
     方法定义要求
        1、公共方法  public
        2、方法没有返回值
        3、方法名称自定义
        4、方法有参数的，推荐Object ，参数名自定义
     */

    /**
     @AfterReturning ：后置通知
        属性：
        （1）value    切入点表达式
        （2）returning    自定义的变量，表示目标方法的返回值
            自定义变量名必须和通知方法的形参名一致
        位置：在方法定义上方
        特点：
        （1）在目标方法之后执行
        （2）能够获取目标方法的返回值，根据这个返回值做不同功能处理
        （3）可修改这个返回值

        后置通知执行
            Object res = doOther();
            参数传递：传值，传引用
            myAfterReturning(res);
     */
    //访问修饰符，返回值类型，包名类名，方法名，形参列表（参数类型，参数个数）
    //Shift + Ctrl + / 多行注释；Ctrl + / 单行注释
    @AfterReturning(value = "execution(* *..SomeServiceImpl.doOther(..))",
                    returning = "res")
    public void myAfterReturning(JoinPoint joinPoint,Object res){
        //Object res：目标方法执行后的返回值，根据返回值做切面功能处理
        System.out.println("后置通知：方法的定义"+ joinPoint.getSignature());
        System.out.println("后置通知：在目标方法之后执行的，获取的返回值是："+res);

        if ("abcd".equals(res)){
        }

        if (res != null){
            res = "Hello Aspectj";
        }
    }
}</code></pre> 
<p>3、环绕通知</p> 
<p>注解为环绕增强的方法要有返回值，Object 类型。并且方法可以包含一个 <strong>ProceedingJoinPoint </strong>类型的参数。接口 ProceedingJoinPoint 其有一个proceed()方法，用于执行目标方法。若目标方法有返回值，则该方法的返回值就是目标方法的返回值</p> 
<pre><code class="language-java">@Aspect
public class MyAspect {
    /**
     环绕通知
     方法定义要求
        1、公共方法  public
        2、必须有一个返回值，推荐Object
        3、方法名称自定义
        4、方法有参数且固定， ProceedingJoinPoint
     */

    /**
     @Around ：环绕通知
        属性： value 切入点表达式
        位置：方法定义上面
        特点：
        （1）功能最强的通知
        （2）在目标方法的前和后都能增强功能
        （3）控制目标方法是否被调用执行
        （4）修改原来的目标方法的执行结果，影响调用结果
     环绕通知，等同于JDK动态代理的InvocationHandler接口
        参数：ProceedingJoinPoint 等同于 Method；作用：执行目标方法
        返回值：目标方法的执行结果，可以被修改
     环绕通知： 经常做事务， 在目标方法之前开启事务，执行目标方法， 在目标方法之后提交事务
     */
    @Around(value = "execution(* *..SomeServiceImpl.doAround(..))")
    public Object myAround(ProceedingJoinPoint pjp){
        String name = "";
        //获取第一个参数
        Object args[] = pjp.getArgs();
        if (args != null &amp;&amp; args.length &gt; 1){
            Object arg = args[0];
            name = (String) arg;
        }

        //实现环绕通知
        Object result = null;
        System.out.println("环绕通知：在目标方法之前，输出时间："+ new Date());

        //1、目标方法调用
        if ("wang".equals(name)){
            //符合条件，执行目标方法
            try {
                result = pjp.proceed();//method.invoke();
            } catch (Throwable throwable) {
                throwable.printStackTrace();
            }
        }

        System.out.println("环绕通知：在目标方法之后，提交事务");

        //2、在目标方法前或后加入功能
        if (result != null){
            //修改目标方法的执行结果，影响最后的调用结果
            result = "Hello AspectJ AOP";
        }

        //返回目标方法的执行结果
        return result;
    }
}
</code></pre> 
<p>4、异常通知</p> 
<pre><code class="language-java">public void doException(String name,Integer age) {
        System.out.println("====目标方法doException()====" + 10/0);
    }</code></pre> 
<pre><code class="language-java">@Aspect
public class MyAspect {
    /**
     异常通知
     方法定义要求
        1、公共方法  public
        2、没有返回值
        3、方法名称自定义
        4、方法有一个Exception，如果还有是JoinPoint
     */

    /**
     @AfterThrowing ：异常通知
        属性：
        （1）value 切入点表达式
        （2）throwing 自定义的变量，表示目标方法抛出的异常对象；变量名和方法参数名必须一致
        特点：
        （1）在目标方法抛出异常时执行
        （2）做异常的监控程序，监控目标方法执行时是不是有异常；如有异常，可发送邮件、短信通知

        执行过程
        try{
            doException(..);
        }catch(Exception e){
            myAfterThrowing(e);
        }
     */
    @AfterThrowing(value = "execution(* *..SomeServiceImpl.doException(..))",
                    throwing = "ex")
    public void myAfterThrowing(Exception ex){
        System.out.println("异常通知：方法发生异常时，执行：" + ex.getMessage());
        //发送邮件，短信，通知开发人员
    }</code></pre> 
<p>5、最终通知</p> 
<p>无论目标方法是否抛出异常，该增强均会被执行</p> 
<pre><code class="language-java">public void doAfter() {
        System.out.println("====目标方法doAfter====" + 10/0);
    }</code></pre> 
<pre><code class="language-java">@Aspect
public class MyAspect {
    /**
     最终通知
     方法定义要求
        1、公共方法  public
        2、没有返回值
        3、方法名称自定义
        4、方法没有参数，如果有是JoinPoint
     */

    /**
     @After ：最终通知
        属性：
            value 切入点表达式
        特点：
        （1）总会执行
        （2）在目标方法之后执行

        执行过程
        try{
            doAfter(..);
        }catch(Exception e){

        }finally{
            myAfter();
        }
     */
    @After(value = "execution(* *..SomeServiceImpl.doAfter(..))")
    public void myAfter(){
        System.out.println("执行最终通知，总是会被执行的代码");
    }
}</code></pre> 
<p>6、JoinPoint参数</p> 
<pre><code class="language-java">@Aspect
public class MyAspect {

    /**
     JoinPoint：指定通知方法中的参数
        业务方法，要加入切面功能的业务方法
        作用：在通知方法中获取方法执行的信息，如方法名称，实参等
        JoinPoint参数的值由框架赋予，必须是第一个位置的参数
     */
    //访问修饰符，返回值类型，包名类名，方法名，形参列表（参数类型，参数个数）
    //Shift + Ctrl + / 多行注释；Ctrl + / 单行注释
    @Before(value = "execution(public void com.mycompany.p2joinpoint.SomeServiceImpl.*(String,Integer))")
    public void myBefore(JoinPoint joinPoint){
        //获取方法的完整定义
        System.out.println("方法的签名（定义）：" + joinPoint.getSignature());
        System.out.println("方法的名称：" + joinPoint.getSignature().getName());

        //方法的签名（定义）：void com.mycompany.p2joinpoint.SomeService.doSome(String,Integer)
        //方法的名称：doSome
        //参数：wang
        //参数：18

        //获取方法实参
        Object args[] = joinPoint.getArgs();
        for (Object arg:args){
            System.out.println("参数：" + arg);
        }

        //切面执行的功能代码
        System.out.println("前置通知，切面功能：在目标方法之前输出执行时间：" + new Date());
    }

}</code></pre> 
<p>7、PointCut</p> 
<p>如果项目中有多个切入点表达式是重复的（可复用），可使用@PointCut</p> 
<pre><code class="language-java">@Aspect
public class MyAspect {
    /**
     @PointCut ：定义和管理切入点，如果项目中有多个切入点表达式是重复的（可复用），可使用@PointCut
        属性：value 切入点表达式
        特点：
        （1）使用@PointCut定义在一个方法上面，此时这个方法的名称就是切入点表达式别名
        （2）其他通知value属性可以使用这个方法名称，代替切入点表达式
     */
    @Pointcut(value = "execution(* *..SomeServiceImpl.doPointCut(..))")
    public void myPointCut(){
    }

    @Before(value = "myPointCut()")
    public void myBefore(){
        System.out.println("前置通知，在目标方法之前先执行的");
    }

    @AfterReturning(value = "myPointCut()")
    public void myAfterReturning(){
        System.out.println("后置通知，在目标方法之后先执行的");
    }
}</code></pre> 
<p>8、自动应用cglib动态代理</p> 
<p>干掉接口类，只留下普通股类</p> 
<p>目标类没有接口，spring框架会自动应用cglib动态代理 proxy：com.xx.SomeServiceImpl$$EnhancerBySpringCGLIB$$d6c75e4a</p> 
<p>9、设置应用cglib动态代理</p> 
<p>修改spring主配置文件</p> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- 讲对象交给spring容器，由spring容器统一创建，管理对象 --&gt;
    &lt;!-- 声明目标对象 --&gt;
    &lt;bean id="someService" class="com.mycompany.p8autocglib.SomeServiceImpl" /&gt;

    &lt;!-- 声明切面类对象 --&gt;
    &lt;bean id="myAspect" class="com.mycompany.p8autocglib.MyAspect" /&gt;

    &lt;!-- 声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象的代理对象
        创建代理对象是在内存中实现的，修改目标对象的内存结构，创建为代理对象
        目标对象就是被修改后的代理对象

        aspectj-autoproxy：会把spring容器中所有的目标对象，一次性都生成代理对象
     --&gt;
&lt;!--    &lt;aop:aspectj-autoproxy /&gt;--&gt;

    &lt;!--
        如果期望目标类有接口，使用cglib动态代理
        proxy-target-class="true"：告诉spring框架，需要使用cglib动态代理
    --&gt;
    &lt;aop:aspectj-autoproxy proxy-target-class="true" /&gt;

&lt;/beans&gt;</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/501e7ecd58e2f1da78ed05a883f68612/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">spark on yarn运行日志查看</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98bb28f081cd35f9330362d4b5704b26/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大批量数据快速写入数据库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>