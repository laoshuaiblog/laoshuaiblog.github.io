<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】指针&amp;&amp;二级指针&amp;&amp;数组指针&amp;&amp;指针数组详解 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/b18b05eecba1b618714e2dc8053204c2/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【C语言】指针&amp;&amp;二级指针&amp;&amp;数组指针&amp;&amp;指针数组详解">
  <meta property="og:description" content="主页：醋溜马桶圈-CSDN博客
专栏：C语言_醋溜马桶圈的博客-CSDN博客
gitee：mnxcc (mnxcc) - Gitee.com
目录
1.初始指针
1.1 什么是指针？
1.2 指针和指针类型
1.2.1 指针的&#43;1/-1操作
1.2.2 指针的解引用
1.3 野指针
1.3.1 野指针成因
1.3.2 如何规避野指针 1.4 指针运算
1.4.1 指针&#43;-整数
1.4.2 指针-指针
1.4.3 指针的关系运算
1.6 二级指针
1.7 字符指针
1.8 函数指针
1.8.1 回调函数
1.8.1.1 qsort()函数
1.8.1.2 代码示例
1.8.1.3 void*
2.指针数组和数组指针
2.1 指针数组
2.2 数组指针
2.2.1 数组指针的定义
2.2.2 &amp;amp;数组名和数组名
2.2.3 数组指针的使用
3.指针和数组
3.1 指针和数组的关系
3.2 数组传参和指针传参
3.2.1 一维数组传参
3.2.2 二维数组传参
3.2.3 一级指针传参
3.2.4 二级指针传参
3.3 函数指针数组">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-21T12:45:47+08:00">
    <meta property="article:modified_time" content="2024-03-21T12:45:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】指针&amp;&amp;二级指针&amp;&amp;数组指针&amp;&amp;指针数组详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#38d8f0;"><strong>主页：</strong></span><a href="https://blog.csdn.net/m0_74722801?spm=1011.2266.3001.5343" title="醋溜马桶圈-CSDN博客">醋溜马桶圈-CSDN博客</a></p> 
 <p><span style="color:#ff9900;"><strong>专栏：</strong></span><a href="https://blog.csdn.net/m0_74722801/category_12396525.html?spm=1001.2014.3001.5482" title="C语言_醋溜马桶圈的博客-CSDN博客">C语言_醋溜马桶圈的博客-CSDN博客</a></p> 
 <p><span style="color:#fe2c24;"><strong>gitee：</strong></span><a href="https://gitee.com/mnxcc" rel="nofollow" title="mnxcc (mnxcc) - Gitee.com">mnxcc (mnxcc) - Gitee.com</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%E5%88%9D%E5%A7%8B%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#1.%E5%88%9D%E5%A7%8B%E6%8C%87%E9%92%88" rel="nofollow">1.初始指针</a></p> 
<p id="main-toc-toc" style="margin-left:40px;"><a href="#main-toc" rel="nofollow">1.1 什么是指针？</a></p> 
<p id="2.%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#2.%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B" rel="nofollow">1.2 指针和指针类型</a></p> 
<p id="2.1%E6%8C%87%E9%92%88%E7%9A%84%2B1%2F-1%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#2.1%E6%8C%87%E9%92%88%E7%9A%84%2B1%2F-1%E6%93%8D%E4%BD%9C" rel="nofollow">1.2.1 指针的+1/-1操作</a></p> 
<p id="2.2%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8-toc" style="margin-left:80px;"><a href="#2.2%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8" rel="nofollow">1.2.2 指针的解引用</a></p> 
<p id="3.%E9%87%8E%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#3.%E9%87%8E%E6%8C%87%E9%92%88" rel="nofollow">1.3 野指针</a></p> 
<p id="3.1%E9%87%8E%E6%8C%87%E9%92%88%E6%88%90%E5%9B%A0-toc" style="margin-left:80px;"><a href="#3.1%E9%87%8E%E6%8C%87%E9%92%88%E6%88%90%E5%9B%A0" rel="nofollow">1.3.1 野指针成因</a></p> 
<p id="3.2%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%E9%87%8E%E6%8C%87%E9%92%88%C2%A0-toc" style="margin-left:80px;"><a href="#3.2%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%E9%87%8E%E6%8C%87%E9%92%88%C2%A0" rel="nofollow">1.3.2 如何规避野指针 </a></p> 
<p id="4.%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#4.%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97" rel="nofollow">1.4 指针运算</a></p> 
<p id="4.1%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0" rel="nofollow">1.4.1 指针+-整数</a></p> 
<p id="4.2%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#4.2%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88" rel="nofollow">1.4.2 指针-指针</a></p> 
<p id="4.3%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#4.3%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97" rel="nofollow">1.4.3 指针的关系运算</a></p> 
<p id="6.%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#6.%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88" rel="nofollow">1.6 二级指针</a></p> 
<p id="1.7%20%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#1.7%20%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88" rel="nofollow">1.7 字符指针</a></p> 
<p id="5.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#5.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88" rel="nofollow">1.8 函数指针</a></p> 
<p id="3.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" rel="nofollow">1.8.1 回调函数</a></p> 
<p id="qsort()%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#qsort%28%29%E5%87%BD%E6%95%B0" rel="nofollow">1.8.1.1 qsort()函数</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:120px;"><a href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow">1.8.1.2 代码示例</a></p> 
<p id="void*-toc" style="margin-left:120px;"><a href="#void*" rel="nofollow">1.8.1.3 void*</a></p> 
<p id="2.%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#2.%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" rel="nofollow">2.指针数组和数组指针</a></p> 
<p id="2.1%20%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#2.1%20%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" rel="nofollow">2.1 指针数组</a></p> 
<p id="3.%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#3.%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88" rel="nofollow">2.2 数组指针</a></p> 
<p id="3.1%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#3.1%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">2.2.1 数组指针的定义</a></p> 
<p id="3.2%26%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%95%B0%E7%BB%84%E5%90%8D-toc" style="margin-left:80px;"><a href="#3.2%26%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%95%B0%E7%BB%84%E5%90%8D" rel="nofollow">2.2.2 &amp;数组名和数组名</a></p> 
<p id="3.3%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#3.3%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">2.2.3 数组指针的使用</a></p> 
<p id="5.%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#5.%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84" rel="nofollow">3.指针和数组</a></p> 
<p id="3.1%20%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#3.1%20%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">3.1 指针和数组的关系</a></p> 
<p id="4.%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E5%92%8C%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82-toc" style="margin-left:40px;"><a href="#4.%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E5%92%8C%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82" rel="nofollow">3.2 数组传参和指针传参</a></p> 
<p id="4.1%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82-toc" style="margin-left:80px;"><a href="#4.1%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82" rel="nofollow">3.2.1 一维数组传参</a></p> 
<p id="4.2%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82-toc" style="margin-left:80px;"><a href="#4.2%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82" rel="nofollow">3.2.2 二维数组传参</a></p> 
<p id="4.3%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82-toc" style="margin-left:80px;"><a href="#4.3%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82" rel="nofollow">3.2.3 一级指针传参</a></p> 
<p id="4.4%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82-toc" style="margin-left:80px;"><a href="#4.4%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82" rel="nofollow">3.2.4 二级指针传参</a></p> 
<p id="1.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#1.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" rel="nofollow">3.3 函数指针数组</a></p> 
<p id="2.%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#2.%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88" rel="nofollow">3.4 指向函数指针数组的指针</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E5%88%9D%E5%A7%8B%E6%8C%87%E9%92%88" style="background-color:transparent;">1.初始指针</h2> 
<h3 id="main-toc" style="background-color:transparent;">1.1 什么是指针？</h3> 
<p>指针是什么？</p> 
<p><strong>指针理解的2个要点：</strong></p> 
<ol><li>指针是内存中一个<strong>最小单元的编号</strong>，也就是<strong>地址</strong></li><li>平时口语中说的指针，通常指的是指针变量，是用来存放内存地址的变量</li></ol> 
<p><img alt="" height="688" src="https://images2.imgbox.com/b1/b5/Qbja5Var_o.png" width="751"></p> 
<pre><code class="language-cs">	int* p;//创建一个指针，指的就是指针变量
</code></pre> 
<blockquote> 
 <p>总结：<strong><u>指针就是地址</u>，口语中所说的指针通常指的是指针变量</strong></p> 
</blockquote> 
<p>那我们就可以这样理解：</p> 
<p><strong>内存：</strong></p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/27/5e/vNigtMNk_o.png" width="469"></p> 
<p><strong>指针变量：</strong></p> 
<p>我们可以通过<strong>&amp;</strong>（取地址操作符）取出变量的内存起始地址，把地址可以存放到一个变量中，这个变量就是指针变量</p> 
<blockquote> 
 <p><strong>int main() {<!-- --><br>     int a = 10;   //在内存中开辟一块空间</strong></p> 
 <p><strong>                        //是向内存中的栈区空间申请4个字节的空间，这4个字节用来存放10这个数值<br>     int* p = &amp;a;           //这里我们对变量a，取出他的地址，可以用&amp;操作符<br>                                   //a变量占用4个字节的空间，这里是将a的4个字节的第一个字节的地址                                    存放在p变量中，p就是一个指针变量<br>     return 0;<br> } </strong></p> 
</blockquote> 
<p>我们用图来表示</p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/8d/ef/qxCTkwYX_o.png" width="1200"></p> 
<p><strong>总结：</strong></p> 
<p>指针变量，是用来<strong>存放地址</strong>的变量（存放在指针中的值<strong>都会被当成地址</strong>处理）</p> 
<p>这里的问题是：</p> 
<ul><li>一个小的单元到底是多大？</li><li>如何编址?</li></ul> 
<p>经过仔细的计算和权衡，我们发现一个字节给一个对应的地址是比较合适的</p> 
<p>对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的时候产生高电平（高电压）和低电平（低电压），就是1或者0</p> 
<p><img alt="" height="741" src="https://images2.imgbox.com/40/16/FHazpyyJ_o.png" width="1200"></p> 
<p>2^32字节的大小等于4GB</p> 
<p>对于64位的机器也同理</p> 
<p><strong>这里我们就明白：</strong></p> 
<ul><li>在32位的机器上，地址是32个0或者1组成二进制序列，那地址就得用4个字节的空间来存储，所以一个指针变量的大小就应该是32个字节</li><li>如果在64位机器上，如果有64根地址线，那一个指针变量的大小是8个字节，才能存放一个地址</li></ul> 
<p><strong>总结：</strong></p> 
<ul><li>指针变量是用来存放地址的，地址是唯一标示一个内存单元的</li><li><strong>指针的大小在32位平台是4个字节，在64位平台是8个字节</strong></li></ul> 
<h3 id="2.%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B" style="background-color:transparent;">1.2 指针和指针类型</h3> 
<p>当有这样的代码</p> 
<pre><code class="language-cs">int num = 10;
p = &amp;num;</code></pre> 
<p>要将&amp;num（num）的地址保存到 p 中，我们就知道 p 是一个指针变量</p> 
<p>我们给指针变量相应的类型：</p> 
<pre><code class="language-cs">char* pc = NULL;
int* pi = NULL;
short* ps = NULL;
long* pl = NULL;
float* pf = NULL;
double* pd = NULL;</code></pre> 
<p>这里可以看到，指针的定义方式是：type+*</p> 
<p>其实：</p> 
<p><strong>char*</strong>类型的指针式为了存放<strong>char</strong>类型变量的地址</p> 
<p><strong>short*</strong>类型的指针式为了存放<strong>short</strong>类型变量的地址</p> 
<p><strong>int*</strong>类型的指针式为了存放<strong>int</strong>类型变量的地址</p> 
<p>那么指针类型的意义式什么？</p> 
<h4 id="2.1%E6%8C%87%E9%92%88%E7%9A%84%2B1%2F-1%E6%93%8D%E4%BD%9C" style="background-color:transparent;">1.2.1 指针的+1/-1操作</h4> 
<p><img alt="" height="363" src="https://images2.imgbox.com/ba/01/169sRWvU_o.png" width="1023"></p> 
<p><strong>指针类型决定了指针+1/-1跳过了几个字节</strong></p> 
<ul><li><strong>int*的指针+1跳过4个字节</strong></li><li><strong>char*的指针+1跳过1个字节</strong></li><li><strong>short*的指针+1跳过2个字节</strong></li><li><strong>double*的指针+1跳过8个字节</strong></li></ul> 
<p>即指针类型决定了指针向前或者向后走一步有多大 </p> 
<h4 id="2.2%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8" style="background-color:transparent;">1.2.2 指针的解引用</h4> 
<p><img alt="" height="234" src="https://images2.imgbox.com/44/47/jcQUe65F_o.png" width="1101"></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/8e/2a/I9jYrV2T_o.png" width="1025"></p> 
<p>我们把<strong>int*</strong>换成<strong>char*</strong></p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/2d/8c/pmyQsCkn_o.png" width="1076"></p> 
<p>指针类型是有意义的</p> 
<p><strong>指针类型决定了指针进行解引用操作的时候，访问几个字节</strong></p> 
<p>比如：一个int*访问4个字节，一个char*只访问1个字节</p> 
<p><img alt="" height="755" src="https://images2.imgbox.com/87/85/6qF43452_o.png" width="1200"></p> 
<h3 id="3.%E9%87%8E%E6%8C%87%E9%92%88" style="background-color:transparent;">1.3 野指针</h3> 
<p>概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p> 
<h4 id="3.1%E9%87%8E%E6%8C%87%E9%92%88%E6%88%90%E5%9B%A0">1.3.1 野指针成因</h4> 
<ol><li>指针未初始化</li><li>指针越界访问</li><li>指针指向的空间释放</li></ol> 
<p><img alt="" height="273" src="https://images2.imgbox.com/cb/f5/enTXeGvb_o.png" width="913"></p> 
<h4 id="3.2%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%E9%87%8E%E6%8C%87%E9%92%88%C2%A0" style="background-color:transparent;">1.3.2 如何规避野指针 </h4> 
<ol><li><strong>指针初始化</strong><br> 如果明确指针应该指向哪里，就初始化正确的地址<br> 如果指针不知道初始化什么值，安全起见，初始化为NULL</li><li><strong>注意指针越界</strong></li><li><strong>指针指向空间释放，及时置NULL</strong></li><li><strong>避免返回局部变量的地址</strong></li><li><strong>指针使用之前检查有效性</strong></li></ol> 
<p>VS中，局部变量未初始化的时候，里面存放的是‘cc cc cc cc’这样的值</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/69/09/cfw7FBQ6_o.png" width="1049"></p> 
<h3 id="4.%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97" style="background-color:transparent;">1.4 指针运算</h3> 
<ul><li>指针+-整数</li><li>指针-指针</li><li>指针的关系运算</li></ul> 
<h4 id="4.1%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0">1.4.1 指针+-整数</h4> 
<p><img alt="" height="275" src="https://images2.imgbox.com/9b/a0/9r1gsuwm_o.png" width="1008"></p> 
<p><strong>p</strong>指向的是数组<strong>首元素</strong>的地址，<strong>p+i</strong>是数组中下标为 <strong>i </strong>的元素的地址</p> 
<p>在这个例子中，p+i其实是跳过了 i*sizeof(int) 个字节</p> 
<p><strong>所以我们可以认为</strong></p> 
<ul><li><strong>arr</strong>和<strong>p</strong>是等价的</li><li><strong>arr+i</strong>和<strong>p+i</strong>是等价的</li><li><strong>*(arr+i)</strong>和<strong>*(p+i)</strong>是等价的</li><li><strong>*(arr+i)</strong>和<strong>arr[ i ]</strong>是等价的</li><li><strong>arr[ i ]</strong>和<strong>*(p+i)</strong>是等价的</li></ul> 
<h4 id="4.2%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88" style="background-color:transparent;">1.4.2 指针-指针</h4> 
<p><img alt="" height="223" src="https://images2.imgbox.com/ec/2b/R7cDoj2m_o.png" width="1024"></p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/8a/98/CJ1tF1qO_o.png" width="1200"></p> 
<p>指针-指针的前提：两个指针指向同一块区域，指针类型也是相同 </p> 
<p>指针-指针<strong>差值的绝对值</strong>是两个指针之间的元素个数</p> 
<h4 id="4.3%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97" style="background-color:transparent;">1.4.3 指针的关系运算</h4> 
<pre><code class="language-cs">#define N_VALUES 5;
float values[N_VALUES];
float* vp;</code></pre> 
<pre><code class="language-cs">	for (vp = &amp;values[N_VALUES]; vp &gt; &amp;values[0]) {
		*--vp = 0;
	}</code></pre> 
<p> 将这样的代码简化如下</p> 
<pre><code class="language-cs">	for (vp = &amp;values[N_VALUES-1]; vp &gt;= &amp;values[0]; vp--) {
		*vp = 0;
	}</code></pre> 
<p>实际上，在绝大部分的编译器上是可以顺利完成任务的，但是我们还是应该避免这样写，因为标准并不保证它可行</p> 
<p><strong>标准规定：</strong></p> 
<p><strong>允许</strong>指向数组元素的指针与指向数组<strong>最后一个元素后面的那个内存位置</strong>的指针比较，但是<strong>不允许</strong>与指向<strong>第一个元素之前的那个内存位置</strong>的指针进行比较 </p> 
<p><img alt="" height="143" src="https://images2.imgbox.com/05/79/KeWJR5ow_o.png" width="809"></p> 
<p>可以从前往后遍历，但是不要从后往前遍历 </p> 
<h3 id="6.%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88" style="background-color:transparent;">1.6 二级指针</h3> 
<p>指针变量也是变量，是变量就有地址</p> 
<p>二级指针变量存放一级指针变量的地址</p> 
<p>同理，也有三级指针变量，存放二级指针变量的地址</p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/b1/0f/8neOIO94_o.png" width="795"></p> 
<p><img alt="" height="464" src="https://images2.imgbox.com/8b/ab/22H6x7iH_o.png" width="995">a的地址存放在p中，p的地址存放在pp中</p> 
<p>p是一级指针，pp是二级指针</p> 
<p>*pp通过对pp中的地址进行解引用，这样找到的是p，*pp访问的其实就是p</p> 
<p>**pp先通过*pp找到p，然后对p进行解引用操作：*p，这样最终找到了a </p> 
<h3 id="1.7%20%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88" style="background-color:transparent;">1.7 字符指针</h3> 
<p>在指针的类型中我们知道有一种指针类型为字符指针 <strong>char*</strong> ; </p> 
<p>一般使用:</p> 
<pre><code class="language-cs">int main()
{
    char ch = 'w';
    char *pc = &amp;ch;
    *pc = 'w';
    return 0;
}</code></pre> 
<p>还有一种使用方法：</p> 
<pre><code class="language-cs">int main()
{
    const char* pstr = "abcdef";//这里是把一个字符串放到pstr指针变量里了吗？
    printf("%s\n", pstr);
    return 0;
}</code></pre> 
<p>代码 <strong>const char* pstr = "abcdef"</strong><strong>;</strong></p> 
<p>特别容易让我们以为是把字符串 abcdef 放到字符指针 pstr 里了，但是，本质是把字符串 abcdef的<strong>首字符的地址</strong>放到了pstr中</p> 
<p><img alt="" height="136" src="https://images2.imgbox.com/54/b9/yYH0DbUt_o.png" width="643"></p> 
<p>上面代码的意思是把一个常量字符串的首字符 a 的地址存放到指针变量 pstr 中</p> 
<p><strong>注意：</strong></p> 
<p>C/C++会把常量字符串存储到单独的一个内存区域，当几个指针指向同一个字符串的时候，他们实际会指向同一块内存。但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块</p> 
<h3 id="5.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88" style="background-color:transparent;">1.8 函数指针</h3> 
<p>顾名思义，函数指针是指向函数的指针， 存放的是函数的地址</p> 
<p><strong>&amp;函数名</strong>就能够得到函数的地址</p> 
<p>函数名也是函数的地址</p> 
<pre><code class="language-cs">int (*p)(int ,int )=fun;
int (*p)(int ,int )=&amp;fun;
int (*p)(int x,int y)=fun;
int (*p)(int x,int y)=&amp;fun;</code></pre> 
<p>调用函数指针变量 </p> 
<pre><code class="language-cs">*p = fun(a,b);
p = fun(a,b);</code></pre> 
<p>举个例子（函数指针类型）：</p> 
<pre><code class="language-cs">void(*)()</code></pre> 
<p>我们可以分析一个例子来理解</p> 
<pre><code class="language-cs">void (*signal(int , void(*)(int)))(int);</code></pre> 
<p> <img alt="" height="625" src="https://images2.imgbox.com/e4/c2/hSuGuYgC_o.png" width="1200"></p> 
<p>我们可以简化一下这个代码</p> 
<pre><code class="language-cs">typedef void(*pfun_t)(int);
pfun_t signal(int, pfun_t);</code></pre> 
<h4 id="3.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" style="background-color:transparent;">1.8.1 回调函数</h4> 
<p>回调函数就是一个通过<strong>函数指针</strong>调用的函数</p> 
<p>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数</p> 
<p>回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外 的一方调用的，用于对该事件或条件进行响应</p> 
<h5 id="qsort()%E5%87%BD%E6%95%B0">1.8.1.1 qsort()函数</h5> 
<p><strong>我们演示一下qsort函数的使用</strong></p> 
<p>qsort是一个库函数，底层使用的快速排序的方式，对数据进行排序的</p> 
<p>这个函数可以直接用来使用，这个函数可以用来排序<strong>任何类型</strong>的数据 </p> 
<p>首先，我们先了解一下qsort函数的用法</p> 
<p><a href="https://legacy.cplusplus.com/reference/cstdlib/qsort/?kw=qsort" rel="nofollow" title="qsort - C++ Reference (cplusplus.com)">qsort - C++ Reference (cplusplus.com)</a></p> 
<p><img alt="" height="930" src="https://images2.imgbox.com/a3/10/68JnfSZz_o.png" width="1200"></p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/e1/d8/ptEp5anM_o.png" width="1158">这个函数一共有四个参数，我们能看到，第四个参数是一个函数指针</p> 
<p>对四个参数的解释是</p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/ac/1d/eC7nLyta_o.png" width="1200"></p> 
<p>直译过来的意思是</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/62/ef/4aEOz5FX_o.png" width="1031"></p> 
<p>排序的时候：</p> 
<ul><li>排序整型数组，两个整型数组可以直接使用 &gt; 比较</li><li>排序结构体数组，两个结构体的数据可能不能直接用 &gt; 比较</li></ul> 
<p>也就是不同类型的数据，比较大小的方法是有差异的</p> 
<h5 id="%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" style="background-color:transparent;">1.8.1.2 代码示例</h5> 
<p>qsort使用的时候需要包含&lt;stdlib.h&gt;头文件</p> 
<pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void print(int arr[], int sz)
{
	for (int i = 0; i &lt; sz; i++) {
		printf("%d ", arr[i]);
	}
	printf("\n");
}
int cmp_int(const void* e1, const void* e2)
{
	return *(int*)e1 - *(int*)e2;
}
void test1()
{
	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	print(arr, sz);
	qsort(arr, sz, sizeof(arr[0]), cmp_int);
	print(arr, sz);
}
int main()
{
	//数据
	test1();
	return 0;
}</code></pre> 
<p>代码效果就是这样</p> 
<p><img alt="" height="466" src="https://images2.imgbox.com/5a/bb/YMmzVG9o_o.png" width="1138"></p> 
<h5 id="void*" style="background-color:transparent;">1.8.1.3 void*</h5> 
<p>这里我们解释一下void*的用法</p> 
<ul><li>void*类型的指针 - 不能进行解引用的操作，也不能进行+-整数的操作</li><li>void*类型的指针是用来存放任意类型数据的地址</li></ul> 
<h2 id="2.%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" style="background-color:transparent;">2.指针数组和数组指针</h2> 
<h3 id="2.1%20%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">2.1 指针数组</h3> 
<p>指针数组是指针还是数组？</p> 
<p>答案：是数组，是存放指针的数组</p> 
<p>数组我们已经知道整型数组，字符数组等</p> 
<blockquote> 
 <p>字符数组 - 存放字符的数组                      char arr[7];</p> 
 <p>整型数组 - 存放整型的数组                      int arr[6];</p> 
 <p>指针数组 - 存放指针（地址）的数组        </p> 
</blockquote> 
<p><img alt="" height="78" src="https://images2.imgbox.com/b3/ba/EwuCL2WU_o.png" width="484"></p> 
<p>使用指针数组<strong>模拟</strong>一个二维数组</p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/1c/6c/LKiQOXIZ_o.png" width="1155"></p> 
<p><img alt="" height="305" src="https://images2.imgbox.com/11/07/piOxmNIP_o.png" width="910"></p> 
<p>但是这跟二维数组不一样，之前我们讲到，二维数组内存是连续的，指针数组是<strong>模拟</strong>的二维数组</p> 
<p>他的原理是：通过arr找到arr1，arr2，arr3；再分别通过arr1，arr2，arr3找到数组内部的元素</p> 
<p><img alt="" height="201" src="https://images2.imgbox.com/b1/3b/hFqG9f3u_o.png" width="1200"></p> 
<h3 id="3.%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88" style="background-color:transparent;">2.2 数组指针</h3> 
<h4 id="3.1%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89">2.2.1 数组指针的定义</h4> 
<p>数组指针是指针？还是数组？</p> 
<p>答案是：指针</p> 
<p>我们已经熟悉：</p> 
<ul><li>整形指针： int * pint; 能够指向整形数据的指针</li><li>浮点型指针： float * pf; 能够指向浮点型数据的指针</li></ul> 
<p>那数组指针应该是：能够<strong>指向数组的指针</strong></p> 
<p>下面代码哪个是数组指针？</p> 
<p></p> 
<blockquote> 
 <p>int *p1[10];</p> 
 <p>int (*p2)[10];</p> 
 <p>//哪个是数组指针</p> 
</blockquote> 
<blockquote> 
 <p>int (*p)[10];</p> 
 <p>//解释：p先和*结合，说明p是一个指针变量，然后指着指向的是一个大小为10个整型的数组。所以p是一个</p> 
 <p>指针，指向一个数组，叫数组指针。</p> 
 <p>//这里要注意：[ ]的优先级要高于*号的，所以必须加上（）来保证p先和*结合。</p> 
</blockquote> 
<h4 id="3.2%26%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%95%B0%E7%BB%84%E5%90%8D" style="background-color:transparent;">2.2.2 &amp;数组名和数组名</h4> 
<p>对于下面的数组：</p> 
<pre><code class="language-cs">int arr[10];</code></pre> 
<p>arr 和 &amp;arr 分别是啥？</p> 
<p>我们知道<strong>arr</strong><strong>是数组名，数组名表示数组首元素的地址</strong></p> 
<p>那<strong>&amp;arr</strong><strong>数组名</strong>到底是啥？</p> 
<p>我们看一段代码：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
    int arr[10] = {0};
    printf("%p\n", arr);
    printf("%p\n", &amp;arr);
    return 0;
}</code></pre> 
<p><img alt="" height="285" src="https://images2.imgbox.com/d9/55/ivJubkqU_o.png" width="1200"></p> 
<p>可见数组名和&amp;数组名打印的地址是一样的</p> 
<p>难道两个是一样的吗？</p> 
<p>我们再看一段代码：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
 int arr[10] = { 0 };
 printf("arr = %p\n", arr);
 printf("&amp;arr= %p\n", &amp;arr);
 printf("arr+1 = %p\n", arr+1);
 printf("&amp;arr+1= %p\n", &amp;arr+1);
 return 0;
}</code></pre> 
<p><img alt="" height="234" src="https://images2.imgbox.com/ac/3d/C9ohDxdW_o.png" width="1164"></p> 
<p>根据上面的代码我们发现，其实&amp;arr和arr，虽然<strong>值是一样的</strong>，但是意义应该不一样的。</p> 
<blockquote> 
 <p><strong>实际上： </strong>&amp;arr 表示的是<strong>数组的地址</strong>，而不是数组首元素的地址</p> 
</blockquote> 
<p>&amp;arr 的类型是： int(*)[10] ，是一种数组指针类型</p> 
<p>数组的地址+1，跳过整个数组的大小，所以 &amp;arr+1 相对于 &amp;arr 的差值是40</p> 
<h4 id="3.3%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8" style="background-color:transparent;">2.2.3 数组指针的使用</h4> 
<p>那数组指针是怎么使用的呢？</p> 
<p>既然数组指针指向的是数组，那数组指针中存放的应该是数组的地址</p> 
<p>看代码：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
    int arr[10] = {1,2,3,4,5,6,7,8,9,0};
    int (*p)[10] = &amp;arr;//把数组arr的地址赋值给数组指针变量p
    //但是我们一般很少这样写代码
    return 0;
}</code></pre> 
<p><strong>数组指针也是指针，存放的是数组的地址 </strong></p> 
<h2 id="5.%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">3.指针和数组</h2> 
<h3 id="3.1%20%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB">3.1 指针和数组的关系</h3> 
<p>指针和数组的关系就是：</p> 
<ul><li>指针就是指针，指针变量就是一个变量，存放地址，指针变量的大小是4或8个字节</li><li>数组就是数组，可以存放一组数，数组的大小是取决于元素类型和元素个数</li></ul> 
<blockquote> 
 <p>数组的数组名是数组首元素的地址，而地址是可以存放到指针变量中的</p> 
</blockquote> 
<p>由此可见：</p> 
<p>数组名表示数组首元素的地址</p> 
<p>但是有两个例外</p> 
<ol><li>sizeof(数组名)，这里的数组名表示整个数组，数组名单独放在sizeof内部，计算的是数组的大小，单位是字节</li><li>&amp;数组名，这里的数组名表示整个数组，取出的是数组的地址，数组的地址和数组首元素的地址，值是一样的，但是类型和意义不一样</li></ol> 
<p>既然可以把数组名当成地址存放到一个指针中，我们就可以使用指针来访问数组的元素</p> 
<h3 id="4.%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E5%92%8C%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82" style="background-color:transparent;">3.2 数组传参和指针传参</h3> 
<p>在写代码的时候难免要把【数组】或者【指针】传给函数，那函数的参数该如何设计呢？</p> 
<p>数组传参，形参可以写成数组形式、指针类型</p> 
<h4 id="4.1%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82" style="background-color:transparent;">3.2.1 一维数组传参</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
void test(int arr[])
{}
void test(int arr[10])
{}
void test(int *arr)
{}
void test2(int *arr[20])
{}
void test2(int **arr)
{}
int main()
{
 int arr[10] = {0};
 int *arr2[20] = {0};
 test(arr);
 test2(arr2);
}</code></pre> 
<h4 id="4.2%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82">3.2.2 二维数组传参</h4> 
<pre><code class="language-cs">void test(int arr[3][5])
{}
void test(int arr[][5])
{}
void test(int (*arr)[5])
{}
int main()
{
 int arr[3][5] = {0};
 test(arr);
}</code></pre> 
<p>总结：二维数组传参，函数形参的设计只能省略第一个[ ]的数字。</p> 
<p>因为对一个二维数组，可以不知道有多少行，但是必须知道一行多少元素。</p> 
<p>这样才方便运算</p> 
<h4 id="4.3%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82" style="background-color:transparent;">3.2.3 一级指针传参</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
void print(int *p, int sz)
{
 int i = 0;
 for(i=0; i&lt;sz; i++)
 {
 printf("%d\n", *(p+i));
 }
}
int main()
{
 int arr[10] = {1,2,3,4,5,6,7,8,9};
 int *p = arr;
 int sz = sizeof(arr)/sizeof(arr[0]);
 //一级指针p，传给函数
 print(p, sz);
 return 0;
}</code></pre> 
<h4 id="4.4%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82" style="background-color:transparent;">3.2.4 二级指针传参</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
void test(int** ptr)
{
 printf("num = %d\n", **ptr); 
}
int main()
{
 int n = 10;
 int*p = &amp;n;
 int **pp = &amp;p;
 test(pp);
 test(&amp;p);
 return 0;
}</code></pre> 
<h3 id="1.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" style="background-color:transparent;">3.3 函数指针数组</h3> 
<blockquote> 
 <p>char* arr[5]://<strong>字符指针数组</strong> - 数组 - 存放的是字符指针</p> 
 <p>int* arr[6]://<strong>整型指针数组</strong> - 数组 - 存放的是整型指针</p> 
</blockquote> 
<p>那么函数指针数组同理</p> 
<blockquote> 
 <p>函数指针数组 - 数组 - 存放的是函数指针 - 存放的是函数的地址</p> 
</blockquote> 
<p>我们举个例子</p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/0f/40/0XDY9FlW_o.png" width="910">这里<strong>int (*pfArr[4])(int,int)</strong>意思是</p> 
<p>pfArr[4]是一个函数指针数组，这个数组有4个元素，<strong>每个元素都是一个函数指针</strong></p> 
<p>每个函数指针指向的是<strong>参数为(int,int)</strong>，<strong>返回值为int</strong>的函数，即<strong>int(*pf)(int,int) </strong></p> 
<p>对比一下：</p> 
<blockquote> 
 <p>int(*p)(int,int)         <strong> //函数指针</strong></p> 
 <p>int(*p<strong>[4]</strong>)(int,int)      <strong>//函数指针数组</strong></p> 
</blockquote> 
<h3 id="2.%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88" style="background-color:transparent;">3.4 指向函数指针数组的指针</h3> 
<p>指向函数指针数组的指针是一个<strong>指针</strong>，指针指向一个<strong>数组</strong>，数组的元素都是<strong>函数指针</strong></p> 
<p>我们推一下</p> 
<p><img alt="" height="340" src="https://images2.imgbox.com/08/23/hWklJVft_o.png" width="1141"></p> 
<p>对比一下，函数指针数组和指向函数指针数组的指针</p> 
<blockquote> 
 <p><strong>int (*pfArr[4])(int, int) //函数指针数组</strong></p> 
 <p><strong>int (*(*p)[4])(int, int)    //指向函数指针数组的指针</strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68d2b9bb40c5b1f34e636fbfa1792e33/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全面盘点17个C&#43;&#43;17的高级特性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c74a37f5c27300e2321d705e3aa1dfe9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Qt笔记 事件分发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>