<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【WEB页面的定时刷新页面（防止session超时）】 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/5b18d0826e299ffa120a742221389e9c/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【WEB页面的定时刷新页面（防止session超时）】">
  <meta property="og:description" content="众所周知，当用户登录网站后较长一段时间没有与服务器进行交互，将会导致服务器上的用户会话数据(即session)被销毁。此时，当用户再次操作网页时，如果服务器进行了session校验，那么浏览器将会提醒用户session超时，导致这个问题的关键词有两个：一个是「长时间」，一个是「未操作」。 防止session超时，我们一般采用的方式有两种：1、延迟session超时时间 2、（在规定的session超时时间内）隔一定时间与服务器交互。
一、 延长服务器的session超时时间。ps:在Tomcat服务器的WEB.xml有如下节点内容：　&amp;lt;session-config&amp;gt;&amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt;&amp;lt;/session-config&amp;gt;； 这里的30表示session的超时时间，单位为分钟，如果用户登录后在30分钟内没有与服务器交互，
那么当前用户的session将失效。我们可以配置一个更大的数值(比如60)，
就可以延长session的超时时间，如果将该值改为0或负数的话，则表示session永不失效。
不过在实际的工作应用中，一味地上调session的超时时间设置并不怎么常见，
大多数需要实现该功能的网站都将解决问题的焦点集中在另一种思路上。
例如：一些在线网站均采用定时刷新页面的方法来防止session超时。
二、定时刷新页面。最常见的有两种实现方式：一种是通过JavaScript&#43;HTMLDOM，另一种则是通过meta标签来实现。
1）JavaScript&#43;HTMLDOM，示例代码如下：
function refresh(seconds) { setTimeout(&#34;self.location.reload()&#34;,seconds*1000); } refresh(600);//调用方法启动定时刷新，数值单位：秒。 2）通过meta标签来实现（在页面中添加meta标签refresh也可以指定每隔指定时间就刷新当前页面），示例代码如下：　&amp;lt;metahttp-equiv=&#34;refresh&#34;content=&#34;600&#34;/&amp;gt; 上述meta标签可以实现每过600秒就刷新一次当前页面。
在上述两种方案中，较好的为第二种，因为如果当前页面是在IE浏览器的模式窗口中打开的，默认情况下，
self.location.reload()方法将会失效，而refreshmeta标签在IE模式窗口下仍然有效。
上述两种方式都实现了刷新当前页面，并且使用起来非常简单，不过很遗憾的是，它们存在一种几乎致命的缺陷。试想一下，如果在论坛发帖等需要用户输入内容的页面，用户花费较长的时间输　入了许多文本内容，可是突然遇到了一个定时页面刷新，结果用户输入的所有内容都没了，估计这个时候用户连掐死你的心都有了……
因此我们需要在当前页面本身不刷新、不影响用户的任何操作的情况下实现定时刷新。最常见的解决方法仍然有两种。
1、在当前页面添加一个隐藏的iframe，然后在该iframe里面实现定时刷新。
2、使用JavaScript Image对象来实现定时刷新，（服务器的响应可以是文字等非图片内容，非图片内容只会造成图像加载失败，而我们的图像标签本身就是隐藏的，不管是加载成功还是失败都不　会显示，毕竟我们的主要目的是发送请求给服务器，让服务器保持session处于活动状态。）
3、使用Ajax来实现定时刷新。
使用说明：
使用iframe标签实现定时刷新： 优点是：不需要编写JavaScript代码，可以在浏览器禁用JavaScript的情况下实现定时刷新； 缺点是：在某些不支持iframe标签的老式浏览器中没有效果，此外，iframe标签在浏览器中新增加了一个独立的页面，即使没有显示出来，不过其内部解析的window、document等对象仍然　存在，占用的浏览器内存相对较多。 使用Image对象： 优点是：与iframe相比，占用的内存相对较少，支持Image的浏览器也相对较多(现代浏览器均支持)； 缺点是：在浏览器禁用JavaScript的情况下就毫无用武之地了（这个现在几乎不存在，现在很少出现禁用js的情况）。 Ajax来实现定时刷新： 缺点是：因为有些老式浏览器的JavaScript无法实现Ajax，但是却可以使用Image对象。 此外，使用Ajax需要编写更多的代码来处理XMLHttpRequest等对象的活动。 转载于:https://www.cnblogs.com/blog7206/p/5073104.html">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2015-12-24T15:01:00+08:00">
    <meta property="article:modified_time" content="2015-12-24T15:01:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【WEB页面的定时刷新页面（防止session超时）】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><span style="font-size:18px;"><strong>          众所周知，当用户登录网站后较长一段时间没有与服务器进行交互，将会导致服务器上的用户会话数据(即session)被销毁。此时，当用户再次操作网页时，如果服务器进行了session校验，那么浏览器将会提醒用户session超时，导致这个问题的关键词有两个：一个是「长时间」，一个是「未操作」。     </strong></span></p> 
 <p><span style="font-size:18px;">防止session超时，我们一般采用的方式有两种：1、延迟session超时时间 2、（在规定的session超时时间内）隔一定时间与服务器交互。<br></span></p> 
 <p><span style="font-size:18px;">　　<span style="font-family:'Microsoft YaHei';"><strong>一、</strong></span> 延长服务器的session超时时间。ps:在Tomcat服务器的WEB.xml有如下节点内容：　</span></p> 
 <div class="cnblogs_code"> 
  <pre><span style="font-size:16px;"><span style="color:#0000ff;">&lt;</span><span style="color:#800000;">session-config</span><span style="color:#0000ff;">&gt;&lt;</span><span style="color:#800000;">session-timeout</span><span style="color:#0000ff;">&gt;</span>30<span style="color:#0000ff;">&lt;/</span><span style="color:#800000;">session-timeout</span><span style="color:#0000ff;">&gt;&lt;/</span><span style="color:#800000;">session-config</span><span style="color:#0000ff;">&gt;</span>；</span></pre> 
 </div> 
 <p><span style="font-size:18px;"> 　　　  这里的30表示session的超时时间，单位为分钟，如果用户登录后在30分钟内没有与服务器交互，</span></p> 
 <p><span style="font-size:18px;">　　　　那么当前用户的session将失效。我们可以配置一个更大的数值(比如60)，</span></p> 
 <p><span style="font-size:18px;">　　　　就可以延长session的超时时间，如果将该值改为0或负数的话，则表示session永不失效。</span></p> 
 <p> </p> 
 <p><strong>　　<span style="color:#ff0000;font-size:18px;">不过在实际的工作应用中，一味地上调session的超时时间设置并不怎么常见，</span></strong></p> 
 <p><strong><span style="color:#ff0000;font-size:18px;">　 大多数需要实现该功能的网站都将解决问题的焦点集中在另一种思路上。</span></strong></p> 
 <p><strong><span style="color:#ff0000;font-size:18px;">　  例如：一些在线网站均采用定时刷新页面的方法来防止session超时。</span></strong></p> 
 <p><strong><span style="color:#ff0000;font-size:18px;">     </span></strong><span style="color:#000000;"><span style="font-size:18px;"><strong> 二、</strong>定时刷新页面。最常见的有两种实现方式：一种是通过JavaScript+HTMLDOM，另一种则是通过meta标签来实现。</span></span></p> 
 <p><span style="color:#000000;"><span style="font-size:18px;">　　　1）JavaScript+HTMLDOM，示例代码如下：</span></span></p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">function</span><span style="color:#000000;"> refresh(seconds)
{
    setTimeout(</span>"self.location.reload()",seconds*1000<span style="color:#000000;">);
}
refresh(</span>600);<span style="color:#008000;">//</span><span style="color:#008000;">调用方法启动定时刷新，数值单位：秒。</span></pre> 
 </div> 
 <p>　　　　2）<span style="font-size:18px;">通过meta标签来实现（在页面中添加meta标签refresh也可以指定每隔指定时间就刷新当前页面），示例代码如下：　</span></p> 
 <div class="cnblogs_code"> 
  <pre>&lt;metahttp-equiv="refresh"content="600"/&gt;</pre> 
 </div> 
 <p class="para"><span style="font-size:18px;">　　　　上述meta标签可以实现每过600秒就刷新一次当前页面。</span></p> 
 <p class="para"><span style="font-size:18px;">　　　　在上述两种方案中，较好的为第二种，因为如果当前页面是在IE浏览器的模式窗口中打开的，默认情况下，</span></p> 
 <p class="para"><span style="font-size:18px;">　　　　self.location.reload()方法将会失效，而refreshmeta标签在IE模式窗口下仍然有效。</span></p> 
 <p><span style="font-size:18px;">　　　　上述两种方式都实现了刷新当前页面，并且使用起来非常简单，不过很遗憾的是，它们存在一种几乎致命的缺陷。试想一下，如果在论坛发帖等需要用户输入内容的页面，用户花费较长的时间输　　　　入了许多文本内容，可是突然遇到了一个定时页面刷新，结果用户输入的所有内容都没了，估计这个时候用户连掐死你的心都有了……</span></p> 
 <p> </p> 
 <p><span style="font-size:18px;">因此我们需要在当前页面本身不刷新、不影响用户的任何操作的情况下实现定时刷新。最常见的解决方法仍然有两种。</span></p> 
 <p><span style="font-size:18px;">　　1、在当前页面添加一个隐藏的iframe，然后在该iframe里面实现定时刷新。</span></p> 
 <p><span style="font-size:18px;">　　2、使用JavaScript Image对象来实现定时刷新，（<span style="color:#ff9900;">服务器的响应可以是文字等非图片内容，非图片内容只会造成图像加载失败，而我们的图像标签本身就是隐藏的，不管是加载成功还是失败都不　　　　会显示，毕竟我们的主要目的是发送请求给服务器，让服务器保持session处于活动状态</span>。）</span></p> 
 <p><span style="font-size:18px;">　　3、使用Ajax来实现定时刷新。</span></p> 
 <p><span style="color:#ff0000;font-size:18px;"><strong> 使用说明：</strong></span></p> 
 <div> 
  <span style="font-size:18px;">　　使用iframe标签实现定时刷新：</span> 
 </div> 
 <div> 
  <span style="font-size:18px;">　　　　优点是：不需要编写JavaScript代码，可以在浏览器禁用JavaScript的情况下实现定时刷新；</span> 
 </div> 
 <div> 
  <span style="font-size:18px;">　　　　缺点是：在某些不支持iframe标签的老式浏览器中没有效果，此外，iframe<a href="http://baike.baidu.com/view/135267.htm" rel="nofollow">标签</a>在浏览器中新增加了一个独立的页面，即使没有显示出来，不过其内部解析的window、document等对象仍然　　　　　　　　存在，占用的浏览器内存相对较多。</span> 
 </div> 
 <div>
     
 </div> 
 <div> 
  <span style="font-size:18px;">　　使用Image对象：</span> 
 </div> 
 <div> 
  <span style="font-size:18px;">　　　　优点是：与iframe相比，占用的内存相对较少，支持Image的浏览器也相对较多(现代浏览器均支持)；</span> 
 </div> 
 <div> 
  <span style="font-size:18px;">　　　　缺点是：在浏览器禁用JavaScript的情况下就毫无用武之地了（这个现在几乎不存在，现在很少出现禁用js的情况）。</span> 
 </div> 
 <div> 
  <span style="font-size:18px;">　　</span> 
 </div> 
 <div> 
  <span style="font-size:18px;">　　Ajax来实现定时刷新：</span> 
 </div> 
 <div> 
  <span style="font-size:18px;">　　　　缺点是：因为有些老式浏览器的JavaScript无法实现Ajax，但是却可以使用Image对象。</span> 
 </div> 
 <div> 
  <span style="font-size:18px;">　　　　　　　　此外，使用Ajax需要编写更多的代码来处理XMLHttpRequest等对象的活动。</span> 
 </div> 
 <p> </p> 
 <p><span style="font-size:18px;">　　　</span></p> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/blog7206/p/5073104.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8a07d2566f87bf7d18e863ceba1ebe1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">跟踪算法及相关主页</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d3a2b3106f1e2738be55fa27be70391/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">33款可用来抓数据的开源爬虫软件工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>