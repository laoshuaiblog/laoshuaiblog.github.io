<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SQLiteC/C&#43;&#43;接口详细介绍sqlite3_stmt类（十三） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/e84bd6d534dabcdc3af5da1dabbd3a7b/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="SQLiteC/C&#43;&#43;接口详细介绍sqlite3_stmt类（十三）">
  <meta property="og:description" content="返回：SQLite—系列文章目录 上一篇：SQLiteC/C&#43;&#43;接口详细介绍sqlite3_stmt类（十二） 下一篇： SQLite数据库文件损坏的可能几种情况 51、sqlite3_stmt_scanstatus_reset sqlite3_stmt_scanstatus_reset 函数用于重置指定语句对象最近一次执行的 WHERE 子句中搜索的行数及扫描的页数的数据，以便进行下一次查询。
函数原型如下：
void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt); 参数说明：
- pStmt：已经编译的 SQLite 语句对象。
该函数没有返回值。
举例用法：
int nLoop = 0; int nVisit = 0; sqlite3_stmt *stmt; sqlite3_prepare_v2(db, &#34;SELECT * FROM user WHERE age &amp;gt; ?&#34;, -1, &amp;amp;stmt, NULL); sqlite3_bind_int(stmt, 1, 18); while (sqlite3_step(stmt) == SQLITE_ROW) { nLoop&#43;&#43;; } sqlite3_stmt_scanstatus_reset(stmt); // 重置搜索的行数和扫描的页数 while (sqlite3_step(stmt) == SQLITE_ROW) { nLoop&#43;&#43;; } sqlite3_stmt_scanstatus(stmt, SQLITE_SCANSTAT_NLOOP, 0, &amp;amp;nLoop); sqlite3_stmt_scanstatus(stmt, SQLITE_SCANSTAT_NVISIT, 0, &amp;amp;nVisit); printf(&#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-25T16:47:54+08:00">
    <meta property="article:modified_time" content="2024-03-25T16:47:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SQLiteC/C&#43;&#43;接口详细介绍sqlite3_stmt类（十三）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 style="text-align:center;">  返回：<a href="https://blog.csdn.net/lyfwwb/article/details/136665169" title="SQLite—系列文章目录">SQLite—系列文章目录</a>   </h4> 
<h4>上一篇：<a href="https://blog.csdn.net/lyfwwb/article/details/136933348" title="SQLiteC/C++接口详细介绍sqlite3_stmt类（十二）">SQLiteC/C++接口详细介绍sqlite3_stmt类（十二）</a></h4> 
<h4>下一篇： <a href="https://blog.csdn.net/lyfwwb/article/details/137018449" title="SQLite数据库文件损坏的可能几种情况">SQLite数据库文件损坏的可能几种情况</a></h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ac/6a/d64bsSv1_o.gif"></p> 
<h4>51、sqlite3_stmt_scanstatus_reset</h4> 
<p>sqlite3_stmt_scanstatus_reset 函数用于重置指定语句对象最近一次执行的 WHERE 子句中搜索的行数及扫描的页数的数据，以便进行下一次查询。</p> 
<p>函数原型如下：</p> 
<pre><code class="language-cpp">void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt);</code></pre> 
<p>参数说明：</p> 
<p>- pStmt：已经编译的 SQLite 语句对象。</p> 
<p>该函数没有返回值。</p> 
<p>举例用法：</p> 
<pre><code class="language-cpp">int nLoop = 0;
int nVisit = 0;
sqlite3_stmt *stmt;
sqlite3_prepare_v2(db, "SELECT * FROM user WHERE age &gt; ?", -1, &amp;stmt, NULL);
sqlite3_bind_int(stmt, 1, 18);
while (sqlite3_step(stmt) == SQLITE_ROW) {
    nLoop++;
}
sqlite3_stmt_scanstatus_reset(stmt); // 重置搜索的行数和扫描的页数
while (sqlite3_step(stmt) == SQLITE_ROW) {
    nLoop++;
}
sqlite3_stmt_scanstatus(stmt, SQLITE_SCANSTAT_NLOOP, 0, &amp;nLoop);
sqlite3_stmt_scanstatus(stmt, SQLITE_SCANSTAT_NVISIT, 0, &amp;nVisit);
printf("搜索了 %d 行，扫描了 %d 个页\n", nLoop, nVisit);
sqlite3_finalize(stmt);</code></pre> 
<p>在上面的示例中，我们使用 `sqlite3_prepare_v2` 函数编译了一条 SQL 语句，并绑定了一个参数。然后使用 `sqlite3_step` 函数逐行获取查询结果，并累计 WHERE 子句搜索的行数和扫描的页数。在第一个 `while` 循环后使用 `sqlite3_stmt_scanstatus_reset` 函数，以清空搜索的行数和扫描的页数的数据。然后在第二个 `while` 循环中执行查询，再使用 `sqlite3_stmt_scanstatus` 函数获取搜索的行数和扫描的页数，并将结果打印出来。</p> 
<p>使用这个函数可以用于评估不同查询条件下的查询效率和性能，对 SQL 语句进行调优和优化。</p> 
<h4>52、sqlite3_stmt_scanstatus_v2  </h4> 
<p>sqlite3_stmt_scanstatus_v2 函数用于返回指定的语句对象最近一次执行的 WHERE 子句中搜索的行数及扫描的页数。相对于 sqlite3_stmt_scanstatus 函数，它能额外生成一些查询性能的统计信息。</p> 
<p>函数原型如下：</p> 
<pre><code class="language-cpp">int sqlite3_stmt_scanstatus_v2(
  sqlite3_stmt* pStmt,                    /* Prepared statement to be measured */
  int idx,                                /* Index of binding to report on */
  int iScanStatusOp,                      /* Operation to measure */
  void* pOut,                             /* OUT: Write statistic here */
  int resetFlg                           /* Reset value for pOut */
);</code></pre> 
<p>参数说明：</p> 
<p>- pStmt：已经编译的 SQLite 语句对象。<br> - idx：指定绑定参数的索引（从 1 开始），如果不需要指定则使用 0。<br> - iScanStatusOp：操作类型，可以是下列值中的一种：<br>   - `SQLITE_SCANSTAT_NLOOP`：返回 WHERE 子句搜索的行数。<br>   - `SQLITE_SCANSTAT_NVISIT`：返回 WHERE 子句扫描的页数。<br>   - `SQLITE_SCANSTAT_EST`：返回 WHERE 子句搜索的平均行数。<br>   - `SQLITE_SCANSTAT_SELECTID`：返回 SELECT 查询的 ID。<br>   - `SQLITE_SCANSTAT_EXPLAIN`：返回执行计划的文本形式。<br>   - `SQLITE_SCANSTAT_ALL`：同时返回上述所有统计信息。<br> - pOut：返回查询结果的指针。<br> - resetFlg：是否重置累计统计数据，1 表示重置，0 表示不重置。</p> 
<p>返回值：</p> 
<p>- 返回 `SQLITE_OK` 表示执行成功，否则返回其他错误码。</p> 
<p>各种操作的返回结果的数据类型与 sqlite3_stmt_scanstatus 函数一致，其中 `SQLITE_SCANSTAT_EXPLAIN` 的返回类型为 `const char *`。</p> 
<p>举例用法：</p> 
<pre><code class="language-cpp">int nLoop = 0;
int nVisit = 0;
const char *explain = NULL;
sqlite3_stmt *stmt;
sqlite3_prepare_v2(db, "SELECT * FROM user WHERE age &gt; ?", -1, &amp;stmt, 0);
sqlite3_bind_int(stmt, 1, 18);
while (sqlite3_step(stmt) == SQLITE_ROW) {
    nLoop++;
}
sqlite3_stmt_scanstatus_v2(stmt, 0, SQLITE_SCANSTAT_NLOOP, &amp;nLoop, 1);
sqlite3_stmt_scanstatus_v2(stmt, 0, SQLITE_SCANSTAT_NVISIT, &amp;nVisit, 1);
sqlite3_stmt_scanstatus_v2(stmt, 0, SQLITE_SCANSTAT_EXPLAIN, &amp;explain, 0);
printf("搜索了 %d 行，扫描了 %d 个页\n", nLoop, nVisit);
printf("执行计划：\n%s\n", explain);
sqlite3_finalize(stmt);</code></pre> 
<p>在上面的示例中，我们使用 `sqlite3_prepare_v2` 函数编译了一条 SQL 语句，并绑定了一个参数。然后使用 `sqlite3_step` 函数逐行获取查询结果，并累加 WHERE 子句搜索的行数。最后使用 `sqlite3_stmt_scanstatus_v2` 函数获取搜索的行数、扫描的页数和执行计划，并将结果打印出来。</p> 
<p>需要注意的是，在获取 SQL 语句执行计划信息时，需要使用 `SQLITE_SCANSTAT_EXPLAIN` 操作，并将 resetFlg 参数设为 0，以保留已有的执行计划信息，否则需要先调用 sqlite3_clear_bindings 函数来释放绑定参数。</p> 
<h4>53、sqlite3_stmt_status</h4> 
<p>sqlite3_stmt_status 函数用于返回指定语句对象的执行状态信息，如 SQL 语句执行的次数、查询返回的行数、最后使用的表和索引、插入、修改和删除的行数等。</p> 
<p>函数原型如下：</p> 
<pre><code class="language-cpp">int sqlite3_stmt_status(
  sqlite3_stmt *pStmt,  /* Prepared statement to be queried */
  int op,               /* Information desired */
  int resetFlg,         /* Reset the value after returning it if true */
  int *pOut             /* Integer value to return */
);</code></pre> 
<p>参数说明：</p> 
<p>- pStmt：已经编译的 SQLite 语句对象。<br> - op：所需字段的操作代码，可以是下列值中的一种：<br>   - `SQLITE_STMTSTATUS_FULLSCAN_STEP`：执行全表扫描的步骤数。<br>   - `SQLITE_STMTSTATUS_SORT`：排序操作的总数。<br>   - `SQLITE_STMTSTATUS_AUTOINDEX`：Autoindex 步骤数。<br>   - `SQLITE_STMTSTATUS_VM_STEP`：后续操作已执行完成的虚拟机步骤数。<br>   - `SQLITE_STMTSTATUS_REPREPARE`：SQL 语句重新编译的次数。<br>   - `SQLITE_STMTSTATUS_RUN`：语句已执行的次数。<br>   - `SQLITE_STMTSTATUS_MEMUSED`：语句消耗的内存总量（单位字节）。<br>   - `SQLITE_STMTSTATUS_ROW`：已返回的行数。<br>   - `SQLITE_STMTSTATUS_STMT_USED`：语句对象使用的内存总量（单位字节）。<br>   - `SQLITE_STMTSTATUS_STMTEXPIRED`：处于过期状态的预处理语句的数量。<br> - resetFlg：是否重置所需字段的值，1 表示重置，0 表示不重置。<br> - pOut：返回查询结果的指针。</p> 
<p>返回值：</p> 
<p>- 返回 `SQLITE_OK` 表示执行成功，否则返回其他错误码。</p> 
<p>举例用法：</p> 
<pre><code class="language-cpp">int nRow = 0;
int memUsed = 0;
sqlite3_stmt *stmt;
sqlite3_prepare_v2(db, "SELECT * FROM user WHERE age &gt; ?", -1, &amp;stmt, NULL);
sqlite3_bind_int(stmt, 1, 18);
while (sqlite3_step(stmt) == SQLITE_ROW) {
    nRow++;
}
sqlite3_stmt_status(stmt, SQLITE_STMTSTATUS_MEMUSED, 1, &amp;memUsed);
printf("执行了 %d 次查询，返回了 %d 行，消耗了 %d 字节的内存\n", 
        sqlite3_stmt_status(stmt, SQLITE_STMTSTATUS_RUN, 0, NULL), nRow, memUsed);
sqlite3_finalize(stmt);</code></pre> 
<p>在上面的示例中，我们使用 `sqlite3_prepare_v2` 函数编译了一条 SQL 语句，并绑定了一个参数。然后使用 `sqlite3_step` 函数逐行获取查询结果，并累加已返回的行数。使用 `sqlite3_stmt_status` 函数获取语句对象的执行次数和消耗的内存量，并将结果打印出来。</p> 
<p>使用这个函数可以用于监控 SQL 查询的性能表现，以实现 SQL 语句调优。</p> 
<p>后记：</p> 
<p>本次Stmt类的所有内容已经完成后续内容等待更新要三互的请发消息。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21681dbb71094c11ca83244b057171c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在Linux系统使用宝塔面板搭建Inis博客并发布至公网【内网穿透】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce5eaf37aac460f132cad1fd302d1e16/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">多进程编程及相关函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>