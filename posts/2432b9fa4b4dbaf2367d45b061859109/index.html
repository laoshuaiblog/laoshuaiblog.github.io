<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[数据结构初阶]队列 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/2432b9fa4b4dbaf2367d45b061859109/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="[数据结构初阶]队列">
  <meta property="og:description" content="鼠鼠我呀，今天写一个基于C语言关于队列的博客，如果有兴趣的读者老爷可以抽空看看，很希望的到各位老爷观点和点评捏！
在此今日，也祝各位小姐姐女生节快乐啊，愿笑容依旧灿烂如初阳，勇气与童真永不退色！
目录
1.队列的概念及结构
2.对列的实现 2.1.queue.h
2.2.queue.c
2.3.test.c
2.4.定义队列
2.5.初始化队列
2.6.队尾入队列
2.7.对头出队列
2.8.获取队列队头元素
2.9.获取队列队尾元素
2.10.获取队列中有效元素的个数
2.11.检测队列是否为空，如果为空返回非零结果，非空返回0
2.12.销毁队列 3.分析运行结果
4.ending
1.队列的概念及结构 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列中的数据元素具有先进先出 FIFO(First In First Out) 的特点。
队尾：进行插入操作的一端称为队尾。
对头：进行删除操作的一端称为队头 。
咱们画一个队列的想象图就很好理解上面几个概念：
其实很好理解，队列里面的数据元素就像排队一样，先进入队列的数据元素当然先出队列了。
2.对列的实现 队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低。
而队列用链表实现的方案也是多种多样，只要满足队列的定义即可。鼠鼠我今天写一个方案（本方案基于无头单向非循环链表）各位佬们可以看看啊，俺先把三个文件和运行结果呈现如下：
2.1.queue.h #pragma once #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;assert.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; #include&amp;lt;stdbool.h&amp;gt; typedef int QDatatype; typedef struct QNode { QDatatype _data; struct QNode* _next; }QNode; typedef struct Queue { int k; QNode* head; QNode* tail; }Queue; //初始化队列 void QueueInit(Queue* q); //队尾入数据 void QueuePush(Queue* q, QDatatype data); //对头出数据 void QueuePop(Queue* q); //获取队列对头元素 QDatatype QueueFront(Queue* q); //获取队列队尾元素 QDatatype QueueBack(Queue* q); //获取队列中有效元素个数 int QueueSize(Queue* q); //检测队列是否为空，如果为空返回非零结果，非空返回0 bool QueueEmpty(Queue* q); //销毁队列 void QueueDestory(Queue* q); 2.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-09T11:08:32+08:00">
    <meta property="article:modified_time" content="2024-03-09T11:08:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[数据结构初阶]队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>鼠鼠我呀，今天写一个基于C语言关于队列的博客，如果有兴趣的读者老爷可以抽空看看，很希望的到各位老爷观点和点评捏！</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" class="left" height="315" src="https://images2.imgbox.com/2e/a7/2dOKgebe_o.jpg" width="472">在此今日，也祝各位小姐姐女生节快乐啊，愿笑容依旧灿烂如初阳，勇气与童真永不退色！</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">1.队列的概念及结构</a></p> 
<p id="%C2%A02.%E5%AF%B9%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A02.%E5%AF%B9%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow"> 2.对列的实现 </a></p> 
<p id="2.1.queue.h-toc" style="margin-left:80px;"><a href="#2.1.queue.h" rel="nofollow">2.1.queue.h</a></p> 
<p id="2.2.queue.c-toc" style="margin-left:80px;"><a href="#2.2.queue.c" rel="nofollow">2.2.queue.c</a></p> 
<p id="2.3.test.c-toc" style="margin-left:80px;"><a href="#2.3.test.c" rel="nofollow">2.3.test.c</a></p> 
<p id="2.4.%E5%AE%9A%E4%B9%89%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#2.4.%E5%AE%9A%E4%B9%89%E9%98%9F%E5%88%97" rel="nofollow">2.4.定义队列</a></p> 
<p id="2.5.%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#2.5.%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97" rel="nofollow">2.5.初始化队列</a></p> 
<p id="2.6.%E9%98%9F%E5%B0%BE%E5%85%A5%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#2.6.%E9%98%9F%E5%B0%BE%E5%85%A5%E9%98%9F%E5%88%97" rel="nofollow">2.6.队尾入队列</a></p> 
<p id="2.7.%E5%AF%B9%E5%A4%B4%E5%87%BA%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#2.7.%E5%AF%B9%E5%A4%B4%E5%87%BA%E9%98%9F%E5%88%97" rel="nofollow">2.7.对头出队列</a></p> 
<p id="2.8.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#2.8.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0" rel="nofollow">2.8.获取队列队头元素</a></p> 
<p id="2.9.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#2.9.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0" rel="nofollow">2.9.获取队列队尾元素</a></p> 
<p id="2.10.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.10.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0" rel="nofollow">2.10.获取队列中有效元素的个数</a></p> 
<p id="2.11.%E6%A3%80%E6%B5%8B%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E9%9D%9E%E9%9B%B6%E7%BB%93%E6%9E%9C%EF%BC%8C%E9%9D%9E%E7%A9%BA%E8%BF%94%E5%9B%9E0-toc" style="margin-left:80px;"><a href="#2.11.%E6%A3%80%E6%B5%8B%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E9%9D%9E%E9%9B%B6%E7%BB%93%E6%9E%9C%EF%BC%8C%E9%9D%9E%E7%A9%BA%E8%BF%94%E5%9B%9E0" rel="nofollow">2.11.检测队列是否为空，如果为空返回非零结果，非空返回0</a></p> 
<p id="2.12.%E9%94%80%E6%AF%81%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:80px;"><a href="#2.12.%E9%94%80%E6%AF%81%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">2.12.销毁队列 </a></p> 
<p id="%C2%A03.%E5%88%86%E6%9E%90%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#%C2%A03.%E5%88%86%E6%9E%90%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" rel="nofollow"> 3.分析运行结果</a></p> 
<p id="4.ending-toc" style="margin-left:40px;"><a href="#4.ending" rel="nofollow">4.ending</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h3 id="1.%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">1.队列的概念及结构</h3> 
<p>队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列中的数据元素具有先进先出 FIFO(First In First Out) 的特点。</p> 
<p>队尾：进行插入操作的一端称为队尾。</p> 
<p>对头：进行删除操作的一端称为队头 。</p> 
<p>咱们画一个队列的想象图就很好理解上面几个概念：</p> 
<blockquote> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/e3/35/geurpVYC_o.png"></p> 
</blockquote> 
<p>其实很好理解，队列里面的数据元素就像排队一样，先进入队列的数据元素当然先出队列了。</p> 
<h3 id="%C2%A02.%E5%AF%B9%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0"> 2.对列的实现 </h3> 
<p>队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低。</p> 
<p>而队列用链表实现的方案也是多种多样，只要满足队列的定义即可。鼠鼠我今天写一个方案（本方案基于无头单向非循环链表）各位佬们可以看看啊，俺先把三个文件和运行结果呈现如下：</p> 
<h4 id="2.1.queue.h">2.1.queue.h</h4> 
<pre><code class="language-cs">#pragma once
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;


typedef int QDatatype;

typedef struct QNode
{
	QDatatype _data;
	struct  QNode* _next;
}QNode;

typedef struct Queue
{
	int k;
	QNode* head;
	QNode* tail;
}Queue;

//初始化队列
void QueueInit(Queue* q);

//队尾入数据
void QueuePush(Queue* q, QDatatype data);

//对头出数据
void QueuePop(Queue* q);

//获取队列对头元素
QDatatype QueueFront(Queue* q);

//获取队列队尾元素
QDatatype QueueBack(Queue* q);

//获取队列中有效元素个数
int QueueSize(Queue* q);

//检测队列是否为空，如果为空返回非零结果，非空返回0
bool QueueEmpty(Queue* q);

//销毁队列
void QueueDestory(Queue* q);</code></pre> 
<h4 id="2.2.queue.c">2.2.queue.c</h4> 
<pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS
#include"queue.h"

void QueueInit(Queue* q)
{
	assert(q);
	q-&gt;head = q-&gt;tail = NULL;
	q-&gt;k = 0;
}

void QueuePush(Queue* q, QDatatype data)
{
	assert(q);
	QNode* tmp = (QNode*)malloc(sizeof(QNode));
	if (tmp == NULL)
	{
		perror("malloc fail");
		return;
	}
	tmp-&gt;_data = data;
	tmp-&gt;_next = NULL;
	if (q-&gt;tail == NULL)
	{
		q-&gt;head = q-&gt;tail = tmp;
	}
	else
	{
		q-&gt;tail-&gt;_next = tmp;
		q-&gt;tail = tmp;
	}
	q-&gt;k++;
}

void QueuePop(Queue* q)
{
	assert(q);
	assert(q-&gt;k &gt; 0);
	QNode* next = q-&gt;head-&gt;_next;
	free(q-&gt;head);
	q-&gt;head = next;
	if (q-&gt;head == NULL)
	{
		q-&gt;tail = NULL;
	}
	q-&gt;k--;
}

QDatatype QueueFront(Queue* q)
{
	assert(q);
	assert(q-&gt;k &gt; 0);
	return q-&gt;head-&gt;_data;
}

QDatatype QueueBack(Queue* q)
{
	assert(q);
	assert(q-&gt;k &gt; 0);
	return q-&gt;tail-&gt;_data;
}

int QueueSize(Queue* q)
{
	assert(q);
	return q-&gt;k;
}

bool QueueEmpty(Queue* q)
{
	assert(q);
	return q-&gt;tail == NULL;
}

void QueueDestory(Queue* q)
{
	assert(q);
	QNode* tmp = q-&gt;head;
	while (tmp)
	{
		QNode* next = tmp-&gt;_next;
		free(tmp);
		tmp = next;
	}
	q-&gt;k = 0;
	q-&gt;head = q-&gt;tail = NULL;
}</code></pre> 
<h4 id="2.3.test.c">2.3.test.c</h4> 
<pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS
#include"queue.h"

int main()
{
	Queue q;
	QueueInit(&amp;q);

	QueuePush(&amp;q, 0);
	QueuePush(&amp;q, 1);
	QueuePush(&amp;q, 1);
	QueuePush(&amp;q, 2);
	QueuePush(&amp;q, 3);
	QueuePush(&amp;q, 4);
	QueuePush(&amp;q, 5);
	QueuePush(&amp;q, 6);

	printf("%d\n", QueueSize(&amp;q));

	printf("%d ", QueueFront(&amp;q));

	printf("%d\n", QueueBack(&amp;q));

	printf("%d ", QueueFront(&amp;q));
	QueuePop(&amp;q);

	while (!QueueEmpty(&amp;q))
	{
		printf("%d ", QueueFront(&amp;q));
		QueuePop(&amp;q);
	}
	
	printf("\n%d\n", QueueSize(&amp;q));

	QueueDestory(&amp;q);

	return 0;
}</code></pre> 
<blockquote> 
 <p><img alt="" class="left" height="539" src="https://images2.imgbox.com/2d/6a/LWT7mwx9_o.png" width="324">运行结果如图，至于为什么是这些个结果，我们详细看以下鼠鼠的队列方案是如何实现的。</p> 
</blockquote> 
<h4 id="2.4.%E5%AE%9A%E4%B9%89%E9%98%9F%E5%88%97">2.4.定义队列</h4> 
<pre><code class="language-cs">typedef int QDatatype;

typedef struct QNode
{
	QDatatype _data;
	struct  QNode* _next;
}QNode;

typedef struct Queue
{
	int k;
	QNode* head;
	QNode* tail;
}Queue;</code></pre> 
<p>老样子我们将int重命名成QDatatype，方便以后代码的维护。</p> 
<p>让后定义并重命名结构体QNode充当队列节点 ，这些节点根据数据元素的入队列或者出队列按需申请或者释放。QNode中成员_data用来存放数据元素，QNode中成员_next用来链接下一个节点。</p> 
<p>又由于基于无头单向非循环链表（以下简称链表）实现的队列在入队列和出队列时分别需要链表尾插和头删，而且经常需要知道队列中数据元素的个数，我们定义并重命名结构体Queue来维护上面需求：Queue中成员k用来记录队列中数据元素个数；成员head用来指向链表头节点；成员tail用来指向链表尾节点。</p> 
<p>大概这样子：</p> 
<blockquote> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/e2/77/qR9qTw5G_o.png"></p> 
</blockquote> 
<h4 id="2.5.%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97">2.5.初始化队列</h4> 
<pre><code class="language-cs">void QueueInit(Queue* q)
{
	assert(q);
	q-&gt;head = q-&gt;tail = NULL;
	q-&gt;k = 0;
}</code></pre> 
<p>断言防止传入的结构体变量地址为空（因为这个地址不可能为空）。将head和tail置成NULL，将k置成0即可。 </p> 
<h4 id="2.6.%E9%98%9F%E5%B0%BE%E5%85%A5%E9%98%9F%E5%88%97">2.6.队尾入队列</h4> 
<pre><code class="language-cs">void QueuePush(Queue* q, QDatatype data)
{
	assert(q);
	QNode* tmp = (QNode*)malloc(sizeof(QNode));
	if (tmp == NULL)
	{
		perror("malloc fail");
		return;
	}
	tmp-&gt;_data = data;
	tmp-&gt;_next = NULL;
	if (q-&gt;tail == NULL)
	{
		q-&gt;head = q-&gt;tail = tmp;
	}
	else
	{
		q-&gt;tail-&gt;_next = tmp;
		q-&gt;tail = tmp;
	}
	q-&gt;k++;
}</code></pre> 
<p>断言防止传入的结构体变量地址为空（这点以下不在赘述）。 队尾入队列其实就是链表尾插，先动态申请一个结构体QNode空间充当新节点，这个新节点的存放好想插入的数据元素，再让新节点链接好队列（链接队列是要区分队列是否为空），k加一即可。</p> 
<h4 id="2.7.%E5%AF%B9%E5%A4%B4%E5%87%BA%E9%98%9F%E5%88%97">2.7.对头出队列</h4> 
<pre><code class="language-cs">void QueuePop(Queue* q)
{
	assert(q);
	assert(q-&gt;k &gt; 0);
	QNode* next = q-&gt;head-&gt;_next;
	free(q-&gt;head);
	q-&gt;head = next;
	if (q-&gt;head == NULL)
	{
		q-&gt;tail = NULL;
	}
	q-&gt;k--;
}</code></pre> 
<p>断言防止队列为空仍然出队列。常规来说再进行链表头删、k减一即可完成出队列，但要注意如果队列中只有一个数据元素（或者说链表只有一个节点）时，如果按常规操作的话会使得tail变成野指针，用上面一个if语句很好处理问题。 </p> 
<h4 id="2.8.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0">2.8.获取队列队头元素</h4> 
<pre><code class="language-cs">QDatatype QueueFront(Queue* q)
{
	assert(q);
	assert(q-&gt;k &gt; 0);
	return q-&gt;head-&gt;_data;
}</code></pre> 
<p> 断言防止队列为空仍然获取对头元素。返回head指向的节点成员_data即可。</p> 
<h4 id="2.9.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0">2.9.获取队列队尾元素</h4> 
<pre><code class="language-cs">QDatatype QueueBack(Queue* q)
{
	assert(q);
	assert(q-&gt;k &gt; 0);
	return q-&gt;tail-&gt;_data;
}</code></pre> 
<p>  断言防止队列为空仍然获取对尾元素。返回tail指向的节点成员_data即可。</p> 
<h4 id="2.10.%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0">2.10.获取队列中有效元素的个数</h4> 
<pre><code class="language-cs">int QueueSize(Queue* q)
{
	assert(q);
	return q-&gt;k;
}</code></pre> 
<p>根据设定可知，返回k即可。 </p> 
<h4 id="2.11.%E6%A3%80%E6%B5%8B%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E9%9D%9E%E9%9B%B6%E7%BB%93%E6%9E%9C%EF%BC%8C%E9%9D%9E%E7%A9%BA%E8%BF%94%E5%9B%9E0">2.11.检测队列是否为空，如果为空返回非零结果，非空返回0</h4> 
<pre><code class="language-cs">bool QueueEmpty(Queue* q)
{
	assert(q);
	return q-&gt;tail == NULL;
}</code></pre> 
<p>若tail指向NULL说明队列为空（或者说链表为空），则q-&gt;tail==NULL为真，返回真。若队列不为空逻辑跟队列为空逻辑相反，返回假。 </p> 
<h4 id="2.12.%E9%94%80%E6%AF%81%E9%98%9F%E5%88%97%C2%A0">2.12.销毁队列 </h4> 
<pre><code class="language-cs">void QueueDestory(Queue* q)
{
	assert(q);
	QNode* tmp = q-&gt;head;
	while (tmp)
	{
		QNode* next = tmp-&gt;_next;
		free(tmp);
		tmp = next;
	}
	q-&gt;k = 0;
	q-&gt;head = q-&gt;tail = NULL;
}</code></pre> 
<p>遍历链表将节点（这些节点都是动态申请的）都释放掉，再将head和tail置成NULL，并将k置成0即可。</p> 
<h3 id="%C2%A03.%E5%88%86%E6%9E%90%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" style="background-color:transparent;"> 3.分析运行结果</h3> 
<p>佬们请看：</p> 
<blockquote> 
 <p><img alt="" class="right" height="264" src="https://images2.imgbox.com/52/01/swxxuGcs_o.gif" width="330"><img alt="" class="left" height="428" src="https://images2.imgbox.com/ef/95/B60bCviO_o.png" width="257"></p> 
</blockquote> 
<p>第一条语句：创建一个结构体Queue变量q；</p> 
<p>第二条语句：初始化结构体变量q；</p> 
<p>第三条到第十条语句：数据元素0、1、1、2、3、4、5、6依次入队列，执行完后队列想象图为： </p> 
<blockquote> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/c0/f7/W4gFTipb_o.png"></p> 
</blockquote> 
<p>第十一条语句：执行printf函数，打印队列有效元素个数为8并换行。</p> 
<p>第十二条和第十三条语句：均执行printf函数，分别打印对头元素0和队尾元素6，换行。</p> 
<p>第十四条语句： 执行printf函数，打印对头元素0。</p> 
<p>第十五条语句：对头元素0出队列，执行完第十五条语句后队列想象图为：</p> 
<blockquote> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/4e/60/n8iBZ1Rf_o.png"></p> 
</blockquote> 
<p>接下来while循环：当队列不为空时，打印对头元素再对头元素出队列。所以分别打印1、1、2、3、4、5、6。执行完while循环后，队列为空（或者说链表为空）。</p> 
<p>再接下来打印队列有效元素个数为0，印证队列为空。再销毁队列。</p> 
<h3 id="4.ending">4.ending</h3> 
<blockquote> 
 <p style="text-align:center;"><img alt="" class="left" height="286" src="https://images2.imgbox.com/cd/e1/Mrgxoemt_o.jpg" width="214">感谢阅读，有不对的地方欢迎像本鼠拿捏玩偶一样拿捏鼠鼠捏！</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/73680b64f98a795b65573a26d2e11e40/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Vue中处理接口返回的二进制图片数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f259609b6d1765ae8540d8c54e2ec015/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jdk1.8安装步骤及环境配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>