<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>逻辑回归（Logistic Regression）测试实例：糖尿病预测项目（不调库，手工推） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/39218a7b1a00bdc7686eda8fb0e71820/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="逻辑回归（Logistic Regression）测试实例：糖尿病预测项目（不调库，手工推）">
  <meta property="og:description" content="一、数据来源 1.数据来源：kaggle
2.数据样式
通过模型训练后，对测试集的前5列（Pregnancies、Glucose、BloodPressure、SkinThickness、Insulin、BMI、DiabetesPedigreeFunction、Age）数据进行预测，判断最后一列（Outcome）的数值，1表示患病，0表示未患病
二.使用方法 逻辑回归（Logistic Regression）
方法说明:
逻辑回归函数：
其中：
损失函数：
梯度下降法：
其中：为自定义的学习比率
三.代码实现 从数据读取开始，不调取三方库，纯手工推。
导入基础库
from random import seed,randrange from csv import reader from math import exp 读取csv文件，将字符串内容转换为浮点型
def csv_loader(file): dataset=[] with open(file,&#39;r&#39;) as f: csv_list=reader(f) for row in csv_list: if not row: continue dataset.append(row) return dataset def str_to_float_converter(dataset): dataset=dataset[1:] for i in range(len(dataset[0])): for row in dataset: row[i]=float(row[i].strip(&#39;&#39;)) 数据标准化（Min-Max标准化）
因为数据之间的量纲不一样，需要进行无量纲处理。
def min_max(dataset): min_max_list=[] for i in range(len(dataset[0])): col_value=[row[i] for row in dataset] min_value=min(col_value) max_value=max(col_value) min_max_list.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-23T18:00:19+08:00">
    <meta property="article:modified_time" content="2023-03-23T18:00:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">逻辑回归（Logistic Regression）测试实例：糖尿病预测项目（不调库，手工推）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h4 style="">一、数据来源</h4> 
 <p style="">1.数据来源：kaggle</p> 
 <p style="">2.数据样式</p> 
 <p style="text-indent:1.4em;text-align:left;">通过模型训练后，对测试集的前5列（Pregnancies、Glucose、BloodPressure、SkinThickness、Insulin、BMI、DiabetesPedigreeFunction、Age）数据进行预测，判断最后一列（Outcome）的数值，1表示患病，0表示未患病</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1920px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.239586%;height:0;"> 
    <img src="https://images2.imgbox.com/64/ad/0615huYJ_o.png" style="margin-left:;display:block;width:1920px;margin-top:-52.239586%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h4 style="">二.使用方法</h4> 
 <p style="">逻辑回归（Logistic Regression）</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">方法说明:</span></p> 
 <p style="">逻辑回归函数：<img class="kdocs-latex-img" src="https://images2.imgbox.com/ef/02/KJQd3BWH_o.png"></p> 
 <p style="">其中：<img class="kdocs-latex-img" src="https://images2.imgbox.com/ce/72/czIODOou_o.png"></p> 
 <p style="">损失函数：<img class="kdocs-latex-img" src="https://images2.imgbox.com/73/70/3UHpiXga_o.png"></p> 
 <p style="">梯度下降法：<img class="kdocs-latex-img" src="https://images2.imgbox.com/3b/92/QpQWkxU7_o.png"></p> 
 <p style="">其中：<img class="kdocs-latex-img" src="https://images2.imgbox.com/b6/82/dc6MiWVb_o.png">为自定义的学习比率</p> 
 <p style=""></p> 
 <h4 style="">三.代码实现</h4> 
 <p style=""><span class="kdocs-color" style="background-color:#F8D7B7;">从数据读取开始，不调取三方库，纯手工推。</span></p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>导入基础库</p></li></ol> 
 <pre class="kdocs-python"><code class="language-python">from random import seed,randrange
from csv import reader
from math import exp</code></pre> 
 <p style=""></p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>读取csv文件，将字符串内容转换为浮点型</p></li></ol> 
 <pre class="kdocs-python"><code class="language-python">def csv_loader(file):
    dataset=[]
    with open(file,'r') as f:
        csv_list=reader(f)
        for row in csv_list:
            if not row:
                continue
            dataset.append(row)
    return dataset

def str_to_float_converter(dataset):
    dataset=dataset[1:]
    for i in range(len(dataset[0])):
        for row in dataset:
            row[i]=float(row[i].strip(''))</code></pre> 
 <p style=""></p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数据标准化（Min-Max标准化）</p></li></ol> 
 <p style="">因为数据之间的量纲不一样，需要进行无量纲处理。</p> 
 <pre class="kdocs-python"><code class="language-python">def min_max(dataset):
    min_max_list=[]
    for i in range(len(dataset[0])):
        col_value=[row[i] for row in dataset]
        min_value=min(col_value)
        max_value=max(col_value)
        min_max_list.append([min_value,max_value])
    return min_max_list

def normalization(dataset):
    min_max_list=min_max(dataset)
    for i in range(len(dataset[0])):
        for row in dataset:
            row[i]=(row[i]- min_max_list[i][0])/(min_max_list[i][1]-min_max_list[i][0])</code></pre> 
 <p style=""></p> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>数据拆分</p></li></ol> 
 <p style="">通过k-fold cross validation对数据进行拆分。</p> 
 <pre class="kdocs-python"><code class="language-python">def k_fold_cross_validation(dataset,n_folds):
    dataset_splitted=[]
    copy_dataset=list(dataset)
    every_fold_size=int(len(dataset)/n_folds)
    for i in range(n_folds):
        datas_fold=[]
        while len(datas_fold) &lt; every_fold_size:
            index=randrange(len(copy_dataset))
            datas_fold.append(copy_dataset.pop(index))
        dataset_splitted.append(datas_fold)
    return dataset_splitted</code></pre> 
 <p style=""></p> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>计算模型的准确性</p></li></ol> 
 <p style="">如果预测的数值和真实的数值相等，每一个相等，就正确记录一次；</p> 
 <p style="">最后计算准确率。</p> 
 <pre class="kdocs-python"><code class="language-python">def calculate_accuracy(actual_data,predicted_data):
    correct_num=0
    for i in range(len(actual_data)):
        if actual_data[i] == predicted_data[i]:
            correct_num+=1
    return correct_num/float(len(actual_data)) *100</code></pre> 
 <p style=""></p> 
 <ol start="6"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>设置模型测试</p></li></ol> 
 <p style="">使用K折交叉验证，评估每一次折叠的模型准确性，准确性越接近1，模型拟合得就越好。</p> 
 <p style="">其中：algo为算法占位，具体算法写好后，在运行时迭代即可。</p> 
 <pre class="kdocs-python"><code class="language-python">def model_test(dataset,algo,n_folds,*args):
    folds=k_fold_cross_validation(dataset,n_folds)
    scores=[]
    for fold in folds:
        traning_dataset=list(folds)
        traning_dataset.remove(fold)
        traning_dataset=sum(traning_dataset,[])
        testing_dataset=[]
        for row in fold:
            testing_dataset.append(row)
        predicted_data=algo(traning_dataset,testing_dataset,*args)
        actual_data=[row[-1] for row in testing_dataset]
        accuracy=calculate_accuracy(actual_data,predicted_data)
        scores.append(accuracy)
    return scores</code></pre> 
 <p style=""></p> 
 <ol start="7"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>预测数据的基础模型</p></li></ol> 
 <p style=""><img class="kdocs-latex-img" src="https://images2.imgbox.com/37/b5/lVhziMF1_o.png"> ，<img class="kdocs-latex-img" src="https://images2.imgbox.com/dc/f2/UDxaODIi_o.png"></p> 
 <pre class="kdocs-python"><code class="language-python">def prediction(row,coe):
    z_hat = coe[0]
    for i in range(len(row)-1):
        z_hat +=coe[i+1]*row[i]
    y_hat=1/(1+exp(-z_hat))
    return y_hat</code></pre> 
 <p style=""></p> 
 <ol start="8"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>预估系数(coefficient)</p></li></ol> 
 <p style="">通过随机梯度下降法，不断迭代，寻找最优的coefficient.</p> 
 <pre class="kdocs-python"><code class="language-python">def estimate_coe(traning_dataset,learning_rate,n_epochs):
    coe=[0.0 for i in range(len(traning_dataset[0]))]
    for epoch in range(n_epochs):
        sum_error=0
        for row in traning_dataset:
            y_hat = prediction(row,coe)
            error = y_hat -row[-1]
            sum_error += error**2
            coe[0] =  coe[0] - learning_rate* error * y_hat * (1.0- y_hat)
            for i in range(len(row)-1):
                coe[i+1] =  coe[i+1] - learning_rate* error * y_hat * (1- y_hat) *row[i]
        print('This is epoch &lt; %s &gt;, sum_error is &lt;%.3f&gt;' %(epoch,sum_error))
    return coe</code></pre> 
 <p style=""></p> 
 <ol start="9"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>逻辑回归函数，用于对测试数据预测</p></li></ol> 
 <pre class="kdocs-python"><code class="language-python">def logistic_regression(traning_dataset,testing_dataset,learning_rate,n_epochs):
    predictions=[]
    coe=estimate_coe(traning_dataset,learning_rate,n_epochs)
    for row in testing_dataset:
        y_hat = round(prediction(row,coe))
        predictions.append(y_hat)
    return predictions</code></pre> 
 <p style=""></p> 
 <ol start="10"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>运行和参数调整</p></li></ol> 
 <pre class="kdocs-python"><code class="language-python">seed(999)
file='./download_datas/diabetes.csv'
dataset=csv_loader(file)
str_to_float_converter(dataset)
dataset=dataset[1:]
normalization(dataset)

algo=logistic_regression
n_folds=5
learning_rate=0.1
n_epochs=1000

scores=model_test(dataset,algo,n_folds,learning_rate,n_epochs)
print('The scores of my model are : %s ' %(scores))
print('The average of scores is %.3f%%' %(sum(scores)/len(scores)))</code></pre> 
 <hr> 
 <p style="">运行结果</p> 
 <pre class="kdocs-python"><code class="language-python">The scores of my model are : [69.93464052287581, 82.35294117647058, 83.66013071895425, 75.16339869281046, 75.16339869281046] 
The average of scores is 77.255%</code></pre> 
 <p style=""></p> 
 <h4 style="">四.完整代码</h4> 
 <pre class="kdocs-python"><code class="language-python">#1.导入基础库
from random import seed,randrange
from csv import reader
from math import exp

#2.读取csv文件，将字符串内容转换为浮点型
def csv_loader(file):
    dataset=[]
    with open(file,'r') as f:
        csv_list=reader(f)
        for row in csv_list:
            if not row:
                continue
            dataset.append(row)
    return dataset

def str_to_float_converter(dataset):
    dataset=dataset[1:]
    for i in range(len(dataset[0])):
        for row in dataset:
            row[i]=float(row[i].strip(''))

#3.数据标准化（Min-Max 标准化）
def min_max(dataset):
    min_max_list=[]
    for i in range(len(dataset[0])):
        col_value=[row[i] for row in dataset]
        min_value=min(col_value)
        max_value=max(col_value)
        min_max_list.append([min_value,max_value])
    return min_max_list

def normalization(dataset):
    min_max_list=min_max(dataset)
    for i in range(len(dataset[0])):
        for row in dataset:
            row[i]=(row[i]- min_max_list[i][0])/(min_max_list[i][1]-min_max_list[i][0])

#4.数据拆分
def k_fold_cross_validation(dataset,n_folds):
    dataset_splitted=[]
    copy_dataset=list(dataset)
    every_fold_size=int(len(dataset)/n_folds)
    for i in range(n_folds):
        datas_fold=[]
        while len(datas_fold) &lt; every_fold_size:
            index=randrange(len(copy_dataset))
            datas_fold.append(copy_dataset.pop(index))
        dataset_splitted.append(datas_fold)
    return dataset_splitted

#5.计算模型的准确性
def calculate_accuracy(actual_data,predicted_data):
    correct_num=0
    for i in range(len(actual_data)):
        if actual_data[i] == predicted_data[i]:
            correct_num+=1
    return correct_num/float(len(actual_data)) *100

#6.设置模型测试
def model_test(dataset,algo,n_folds,*args):
    folds=k_fold_cross_validation(dataset,n_folds)
    scores=[]
    for fold in folds:
        traning_dataset=list(folds)
        traning_dataset.remove(fold)
        traning_dataset=sum(traning_dataset,[])
        testing_dataset=[]
        for row in fold:
            testing_dataset.append(row)
        predicted_data=algo(traning_dataset,testing_dataset,*args)
        actual_data=[row[-1] for row in testing_dataset]
        accuracy=calculate_accuracy(actual_data,predicted_data)
        scores.append(accuracy)
    return scores

#7.预测数据的基础模型
def prediction(row,coe):
    z_hat = coe[0]
    for i in range(len(row)-1):
        z_hat +=coe[i+1]*row[i]
    y_hat=1/(1+exp(-z_hat))
    return y_hat

#8.预估系数(coefficient)
def estimate_coe(traning_dataset,learning_rate,n_epochs):
    coe=[0.0 for i in range(len(traning_dataset[0]))]
    for epoch in range(n_epochs):
        sum_error=0
        for row in traning_dataset:
            y_hat = prediction(row,coe)
            error = y_hat -row[-1]
            sum_error += error**2
            coe[0] =  coe[0] - learning_rate* error * y_hat * (1.0- y_hat)
            for i in range(len(row)-1):
                coe[i+1] =  coe[i+1] - learning_rate* error * y_hat * (1- y_hat) *row[i]
        print('This is epoch &lt; %s &gt;, sum_error is &lt;%.4f&gt;' %(epoch,sum_error))
    return coe

#9.逻辑回归函数，用于对测试数据预测
def logistic_regression(traning_dataset,testing_dataset,learning_rate,n_epochs):
    predictions=[]
    coe=estimate_coe(traning_dataset,learning_rate,n_epochs)
    for row in testing_dataset:
        y_hat = round(prediction(row,coe))
        predictions.append(y_hat)
    return predictions

seed(999)
file='./download_datas/diabetes.csv'
dataset=csv_loader(file)
str_to_float_converter(dataset)
dataset=dataset[1:]
normalization(dataset)

algo=logistic_regression
n_folds=5
learning_rate=0.1
n_epochs=1000

scores=model_test(dataset,algo,n_folds,learning_rate,n_epochs)
print('The scores of my model are : %s ' %(scores))
print('The average of scores is %.3f%%' %(sum(scores)/len(scores)))</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/892fc8650c1131bc8aa50b8588945a61/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker部署ftp，java连接踩坑记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee486bd693f4132e6a74d3026416bbc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">css单行文本溢出显示省略号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>