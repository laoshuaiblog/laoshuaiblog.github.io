<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>static_cast,dynamic_cast,reinterpret_cast和const_cast的区别详解 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/c135adbc6bf33951e6b598dfe03e5774/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="static_cast,dynamic_cast,reinterpret_cast和const_cast的区别详解">
  <meta property="og:description" content="C-style cast举例：
int i; double d; i = (int) d; 上面的代码就是本来为double类型的d，通过(int)d将其转换成整形值，并将该值赋给整形变量i (注意d本身的值并没有发生改变)。这就是典型的c-style类型转换。 下面是一个简单的程序：
复制代码 代码如下: #include using namespace std; ​ int main(void) { int i; double d = 11.29; i = (int)d; cout &amp;lt; i ; cout &amp;lt; d ; return 0; } 输出结果： 11 11.29 我们发现d值本身并没有发生任何变化。 在简单的情况下，上面这种类型转换可以很好地工作，但在C&#43;&#43;中往往还是不够的，为此ANSI-C&#43;&#43;新标准定义的四个转换符，即static_cast、dynamic_cast、reinterpret_cast和const_cast。同时在C&#43;&#43;环境中，原先的C-Style的类型转换仍旧可以使用。 1) static_cast
用法： static_cast (expression) 说明：该运算符把expression转换为typeid类型，但没有运行时类型检查来确保转换的安全性。 用途：
a) 用于类层次结构中基类和派生类之间指针或者引用的转换。up-casting (把派生类的指针或引用转换成基类的指针或者引用表示)是安全的；down-casting(把基类指针或引用转换成子类的指针或者引用)是不安全的。 b) 用于基本数据类型之间的转换，如把int转换成char，这种转换的安全性也要由开发人员来保证。
c) 可以把空指针转换成目标类型的空指针(null pointer)。
d) 把任何类型的表达式转换成void类型。
注意： static_cast不能转换掉expression的const、volitale或者__unaligned属性。
2)dynamic_cast
用法：dynamic_cast (expression)">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2013-12-30T14:14:07+08:00">
    <meta property="article:modified_time" content="2013-12-30T14:14:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">static_cast,dynamic_cast,reinterpret_cast和const_cast的区别详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="word-wrap:break-word; margin-top:0px; margin-bottom:5px; color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> <span style="font-weight:bold"><span style="color:rgb(255,0,0)">C-style cast举例：</span></span></p> 
<p style="word-wrap:break-word; margin-top:0px; margin-bottom:5px; color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> <span style="font-weight:bold"><span style="color:rgb(255,0,0)"><br> </span></span></p> 
<pre><code class="language-cpp">int i;
double d;
i = (int) d;
</code></pre> 
<br> 
<br> 
<br> 上面的代码就是本来为double类型的d，通过(int)d将其转换成整形值，并将该值赋给整形变量i (注意d本身的值并没有发生改变)。这就是典型的c-style类型转换。 
<br> 
<br> 
<span style="font-weight:bold">下面是一个简单的程序：<br> </span> 
<p></p> 
<div style="word-wrap:break-word; color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
 <u>复制代码</u> 代码如下: 
</div> 
<div style="word-wrap:break-word; color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
 <br> 
</div> 
<pre><code class="language-cpp">#include 
using namespace std;
​
int main(void)
{
int i;
double d = 11.29;

i = (int)d;
cout &lt; i ;     
cout &lt; d ;
return 0;
}</code></pre> 
<br> 
<div style="word-wrap:break-word; color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
 <br> 
</div> 
<br style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
<span style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px">输出结果：</span> 
<br style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
<span style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px">11</span> 
<br style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
<span style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px">11.29</span> 
<br style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
<br style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
<span style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px">我们发现d值本身并没有发生任何变化。</span> 
<br style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
<br style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
<span style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px">在简单的情况下，上面这种类型转换可以很好地工作，但在C++中往往还是不够的，为此ANSI-C++新标准定义的四个转换符，即static_cast、dynamic_cast、reinterpret_cast和const_cast。同时在C++环境中，原先的C-Style的类型转换仍旧可以使用。</span> 
<br style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
<br style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"> 
<span style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px"><strong><span style="background-color:rgb(255,255,0)">1)  static_cast<br> </span>用法：</strong></span> 
<span style="color:rgb(51,51,51); font-family:宋体,'sans serif',tahoma,verdana,helvetica; font-size:14px; line-height:21px">static_cast </span>(expression) 
<br> 
<span style="font-weight:bold">说明：</span>该运算符把expression转换为typeid类型，但没有运行时类型检查来确保转换的安全性。 
<br> 
<span style="font-weight:bold">用途：<br> </span>a) 用于类层次结构中基类和派生类之间指针或者引用的转换。up-casting (把派生类的指针或引用转换成基类的指针或者引用表示)是安全的；down-casting(把基类指针或引用转换成子类的指针或者引用)是不安全的。 
<p style="word-wrap:break-word; margin-top:0px; margin-bottom:5px"><br> </p> 
<p style="word-wrap:break-word; margin-top:0px; margin-bottom:5px">b) 用于基本数据类型之间的转换，如把int转换成char，这种转换的安全性也要由开发人员来保证。</p> 
<p style="word-wrap:break-word; margin-top:0px; margin-bottom:5px">c) 可以把空指针转换成目标类型的空指针(null pointer)。</p> 
<p style="word-wrap:break-word; margin-top:0px; margin-bottom:5px">d) 把任何类型的表达式转换成void类型。<br> 注意： static_cast不能转换掉expression的const、volitale或者__unaligned属性。<br> <br> <span style="font-weight:bold"><span style="background-color:rgb(255,255,0)">2)dynamic_cast<br> </span>用法：</span>dynamic_cast (expression)<br> <span style="font-weight:bold">说明：</span>该运算符把expression转换成typeid类型的对象。typeid必须是类的指针、类的引用或者void*。如果typeid是类的指针类型，那么expression也必须是指针，如果typeid是一个引用，那么expression也必须是一个引用。一般情况下，dynamic_cast用于具有多态性的类(即有虚函数的类)的类型转换。<br> <br> dynamic_cast依赖于RTTI信息，其次，在转换时，dynamic_cast会检查转换的source对象是否真的可以转换成target类型，这种检查不是语法上的，而是真实情况的检查。先看RTTI相关部分，通常，许多编译器都是通过vtable找到对象的RTTI信息的，这也就意味着，如果基类没有虚方法，也就无法判断一个基类指针变量所指对象的真实类型，这时候，dynamic_cast只能用来做安全的转换,例如从派生类指针转换成基类指针。而这种转换其实并不需要dynamic_cast参与。也就是说,dynamic_cast是根据RTTI记载的信息来判断类型转换是否合法的。<br> <br> <span style="font-weight:bold">用途：</span>主要用于类层次之间的up-casting和down-casting，还可以用于类之间的交叉转换。在进行down-casting时，dynamic_cast具有类型检查的功能，比static_cast更安全。检测在运行时进行。如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。不过，与static_cast不同，在后一种情况里（注：即隐式转 换的相反过程），dynamic_cast会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。</p> 
<p style="word-wrap:break-word; margin-top:0px; margin-bottom:5px">注意：dynamic_cast不能转换掉expression的const、volitale或者__unaligned属性。<br> <br> <span style="font-weight:bold"><span style="background-color:rgb(255,255,0)">3) reinterpret_cast<br> </span></span>用法：reinterpret_cast (expression)<br> 说明：转换一个指针为其他类型的指针，也允许将一个指针转换为整数类型，反之亦然。这个操作符能够在非相关的类型之间进行转换。操作结果只是简单的从一个指针到别的指针的值的二进制拷贝，在类型之间指向的内容不做任何类型的检查和转换。这是一个强制转换。使用时有很大的风险，慎用之。<br> 注意：reinterpret _cast不能转换掉expression的const、volitale或者__unaligned属性。<br> <br> <span style="font-weight:bold"><span style="background-color:rgb(255,255,0)">4)const_cast<br> </span></span>用法：const_cast(expression)<br> 说明：这个类型操纵传递对象的const属性，或者是设置或者是移除。如：<br> Class C{…}<br> const C* a = new C;<br> C* b = const_cast(a);</p> 
<p style="word-wrap:break-word; margin-top:0px; margin-bottom:5px">如果将上面的const_cast转换成其他任何其他的转换，编译都不能通过，出错的信心大致如下：<br> “…cannot convert from 'const class C *' to 'class C *'”。<br> <br> 下面的代码是4中casting方法的典型用法示例：</p> 
<div style="word-wrap:break-word">
  代码如下: 
</div> 
<div style="word-wrap:break-word"> 
 <br> 
</div> 
<pre><code class="language-cpp">#include 
using namespace std;

class Base
{
public:
int _base;
virtual void printinfo()
{
cout &lt; base ;        }
};

class Derived : public Base
{
public:
int _derived;
virtual void printinfo()
{
cout &lt; derived ;        }
};

int main(void)
{
Base b1;
Derived d1;
int aInt = 10;
long aLong = 11;
float aFloat = 11.11f;
double aDouble = 12.12;

Derived* pd = static_cast(&amp;b1);                           // down-casting          不安全
Base* pb = static_cast(&amp;d1);                                   // up-casting                安全
Derived&amp; d = static_cast(b1);                             // down-casting          不安全
Base&amp; b = static_cast(d1);                                      // up-casting                安全

aInt = static_cast(aFloat);                                                // 基本数据类型转换
void* sth = static_cast(&amp;aDouble);                            // 将double指针类型转换成void指针类型
double* bDouble = static_cast(sth);                    // 将void指针类型转换成double指针类型
cout &lt; bDouble ;
Base* pb1 = dynamic_cast(&amp;d1);
//Derived* pd1 = dynamic_cast(&amp;b1);                 // 编译时有warning，运行时出错

int bInt = reinterpret_cast(pb1);                                       // 将地址或指针转换成整数
cout &lt; bInt ;
pb1 = reinterpret_cast(bInt);                                     // 将整数转换成地址或指针

int* cInt = reinterpret_cast(&amp;aFloat);                             // 这个转换的结果会出乎意料
cout &lt; intcInt ;
const Base* bBase = new Base();
Base* cBase = const_cast(bBase);
//Base* dBase = dynamic_cast(bBase);                // 不能通过编译
//Base* eBase = static_cast(bBase);                     // 不能通过编译
//Base* fBase = reinterpret_cast(bBase);             // 不能通过编译

return 0;
} </code></pre> 
<div style="word-wrap:break-word"> 
 <ul style="list-style:none outside none"></ul> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c3cdef082ca84f0df6dd8dec32a9ee1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux shell 用sed命令在文本的行尾或行首添加字符</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bd55b5d5bee0006505b0db0585d63f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">netstat 的10个基本用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>