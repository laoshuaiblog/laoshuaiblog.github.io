<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Asp.Net Cookie 和 Session 的编写、读取 和 删除 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/45024ecb6803cdc4aee4c02eb465be96/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Asp.Net Cookie 和 Session 的编写、读取 和 删除">
  <meta property="og:description" content="一、Cookie（分两种操作方式）
（一）第一种操作方式
#region 第一种操作方式 //（一）未带子健的 Cookie //1.编写（创建 和 修改 一样） HttpCookie cookie = new HttpCookie(&#34;userName&#34;); cookie.Value = &#34;李春林&#34;; cookie.Expires = DateTime.Now.AddHours(1); Response.Cookies.Add(cookie); //2.读取 if (Request.Cookies[&#34;userName&#34;] != null) { string userName = Request.Cookies[&#34;userName&#34;].Value; userName = Server.HtmlEncode(userName);//确保恶意用户没有向 Cookie 中添加可执行脚本 } //3.删除 HttpCookie cookie = new HttpCookie(&#34;userName&#34;); cookie.Expires = DateTime.Now.AddHours(-1); Response.Cookies.Add(cookie); //（二）带子健的 Cookie //1.编写（创建 和 修改 一样） HttpCookie cookie = new HttpCookie(&#34;userInfo&#34;); cookie.Values[&#34;userName&#34;] = &#34;李春林&#34;; cookie.Expires = DateTime.Now.AddDays(1); Response.Cookies.Add(cookie); //2.读取 if (Request.Cookies[&#34;userInfo&#34;] !">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-12-12T00:01:53+08:00">
    <meta property="article:modified_time" content="2016-12-12T00:01:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Asp.Net Cookie 和 Session 的编写、读取 和 删除</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-family:FangSong_GB2312; font-size:18px"><strong>一、Cookie（分两种操作方式）</strong></span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:18px"><strong>（一）第一种操作方式</strong><br> </span></p> 
<p></p> 
<pre><code class="language-csharp">#region 第一种操作方式
//（一）未带子健的 Cookie
//1.编写（创建 和 修改 一样）
HttpCookie cookie = new HttpCookie("userName");
cookie.Value = "李春林";
cookie.Expires = DateTime.Now.AddHours(1);
Response.Cookies.Add(cookie);

//2.读取
if (Request.Cookies["userName"] != null)
{
	string userName = Request.Cookies["userName"].Value;
	userName = Server.HtmlEncode(userName);//确保恶意用户没有向 Cookie 中添加可执行脚本
}

//3.删除
HttpCookie cookie = new HttpCookie("userName");
cookie.Expires = DateTime.Now.AddHours(-1);
Response.Cookies.Add(cookie);


//（二）带子健的 Cookie
//1.编写（创建 和 修改 一样）
HttpCookie cookie = new HttpCookie("userInfo");
cookie.Values["userName"] = "李春林";
cookie.Expires = DateTime.Now.AddDays(1);
Response.Cookies.Add(cookie);

//2.读取
if (Request.Cookies["userInfo"] != null)
{
	string userName = Request.Cookies["userInfo"].Values["userName"];
	userName = Server.HtmlEncode(userName);//确保恶意用户没有向 Cookie 中添加可执行脚本
}

//3.删除
//3.1 删除子键的方式
HttpCookie cookie=Request.Cookies["userInfo"];
if (cookie != null)
{
	cookie.Values.Remove("userName");
	cookie.Expires = DateTime.Now.AddDays(1);
	Response.Cookies.Add(cookie);
}
//3.2 删除父键的方式
HttpCookie cookie = new HttpCookie("userInfo");
cookie.Expires = DateTime.Now.AddDays(-1);
Response.Cookies.Add(cookie);
#endregion</code></pre> 
<p><br> </p> 
<span style="font-family:FangSong_GB2312; font-size:18px"><strong>（二）第二种操作方式</strong></span> 
<p></p> 
<pre><code class="language-csharp">#region 第二种操作方式
//（一）未带子健的 Cookie
//1.编写（创建 和 修改 一样）
Response.Cookies["userName"].Value = "李春林";
Response.Cookies["userName"].Expires = DateTime.Now.AddHours(1);

//2.读取（跟第一种方式一样）
if (Request.Cookies["userName"] != null)
{
	string userName = Request.Cookies["userName"].Value;
	userName = Server.HtmlEncode(userName);//确保恶意用户没有向 Cookie 中添加可执行脚本
}

//3.删除
Response.Cookies["userName"].Expires = DateTime.Now.AddHours(-1);


//（二）带子健的 Cookie
//1.编写（创建 和 修改 一样）
Response.Cookies["userInfo"]["userName"] = "李春林";
Response.Cookies["userInfo"].Expires = DateTime.Now.AddHours(1);

//2.读取
if (Request.Cookies["userInfo"] != null)
{
	string userName = Request.Cookies["userInfo"]["userName"];
	userName = Server.HtmlEncode(userName);//确保恶意用户没有向 Cookie 中添加可执行脚本
}

//3.删除
//3.1 删除子键的方式（跟第一种方式一样）
HttpCookie cookie = Request.Cookies["userInfo"];
if (cookie != null)
{
	cookie.Values.Remove("userName");
	cookie.Expires = DateTime.Now.AddDays(1);
	Response.Cookies.Add(cookie);
}
//3.2 删除父键的方式
Response.Cookies["userInfo"].Expires = DateTime.Now.AddDays(-1);
#endregion</code></pre> 
<p><br> </p> 
<p><span style="font-family:FangSong_GB2312; font-size:18px"><strong>（三）注意</strong><br> </span></p> 
<p><span style="font-family:SimSun; font-size:14px">1.Cookie 只能存储字符串类型（String）的数据，并且是存在客户端的，不是存在服务端的。</span></p> 
<p><span style="font-family:SimSun; font-size:14px">2.不能直接修改 Cookie，删除 Cookie（即从用户的硬盘中物理移除 Cookie）是修改 Cookie 的一种形式。</span></p> 
<p><span style="font-family:SimSun; font-size:14px">3.每个 Cookie 通常限制为 4096 字节（</span><span style="font-family:SimSun; font-size:14px">即</span><span style="font-family:SimSun; font-size:14px">4KB大小，超过将不会添加该Cookie，但不会抛异常）。</span></p> 
<p><span style="font-family:SimSun; font-size:14px">4.每个站点一般最多可存储 20 个 Cookie，如果同一站点Cookie过多可以创建带子键的 Cookie。</span></p> 
<p><span style="font-family:SimSun; font-size:14px">5.在获取 Cookie 的值之前，应确保该 Cookie 存在；如果该 Cookie 不存在，将会收到 NullReferenceException 异常。</span></p> 
<p><span style="font-family:SimSun; font-size:14px">6.在设置 Cookie 的值之前，如果值包括分号（“;”），应该使用 Server.UrlEncode() 函数对其编码，否则前台使用 Cookie 时得</span><span style="font-family:SimSun; font-size:14px">到的值不完整。</span></p> 
<p><span style="font-family:SimSun; font-size:14px">7.如果值页面中显示 Cookie 的内容前，先调用 HtmlEncode 方法对 Cookie 的内容进行编码。这样可以确保恶意用户没有向 </span><span style="font-family:SimSun; font-size:14px">Cookie </span><span style="font-family:SimSun; font-size:14px">中添加可执行脚本。</span></p> 
<p><span style="font-family:SimSun; font-size:14px">8.服务器端只能设置 Cookie 的过期时间，而不能获取 Cookie 的过期时间，因为浏览器每次发送请求也不会把过期时间发送到服务器。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:18px"><br> </span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:18px"><br> </span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:18px"><br> </span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:18px"><br> </span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:18px"><br> </span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:18px"><strong>二、Session</strong></span></p> 
<p><span style="font-family:SimSun; font-size:14px">Session的增删改查非常简单，如下：</span></p> 
<p><br> <span style="font-size:18px; font-family:FangSong_GB2312"><strong>保存会话：</strong></span></p> 
<pre><code class="language-csharp">Session["userName"]="李春林";//保存，这里可以存储任意类型的数据，包括对象、集合等
Session.Timeout=40;//过期时间40分钟</code></pre> 
<p></p> 
<p><br> <span style="font-size:18px; font-family:FangSong_GB2312"><strong>读取会话：</strong></span></p> 
<pre><code class="language-csharp">if (Session["userName"] != null)
{
	string userName = Session["userName"].ToString();
}
//这里为引用类型，可以直接强制转换为存放时的类型
string userName = (string)Session["userName"];</code></pre> 
<p><br> </p> 
<span style="font-size:18px; font-family:FangSong_GB2312"><strong>销毁会话：</strong></span> 
<br> 
<pre><code class="language-csharp">Session.Abandon();</code></pre> 
<p><br> </p> 
<span style="font-size:18px; font-family:FangSong_GB2312"><strong>说明：</strong></span> 
<br> 
<span style="font-family:SimSun; font-size:14px">1.Session 可以存储任意类型的数据。</span> 
<p></p> 
<p><span style="font-family:SimSun; font-size:14px">2.Session 属性的访问</span></p> 
<p><span style="font-family:SimSun; font-size:14px">  在Web Forms的后台页面（Page）和 MVC的控制器（Controller）中 可以直接访问到Session属性</span></p> 
<p><span style="font-family:SimSun; font-size:14px">  一般处理程序 中 可以使用 context.Session 访问</span></p> 
<p><span style="font-family:SimSun; font-size:14px">  类中需要使用 HttpContext.Current.Session 访问</span><br> <br> <br> <br> <span style="font-size:18px; font-family:FangSong_GB2312"><strong>会话标识符：</strong></span></p> 
<p><span style="font-family:SimSun; font-size:14px">默认情况下，SessionID 存储在浏览器未到期会话的 cookie 中。</span></p> 
<p><span style="font-family:SimSun; font-size:14px">通过在 Web.config 文件的 sessionState 节中将 cookieless 属性设置为 true，可以指定不将会话标识符存储在 cookie 中，将会存放在URL中传递，个人不建议这样使用（不安全、不方便 并且 会造成共享会话）。</span></p> 
<p><br> <br> <br> <span style="font-size:18px; font-family:FangSong_GB2312"><strong>会话状态事件：</strong></span></p> 
<p><span style="font-family:SimSun; font-size:14px">ASP.NET 提供了两种帮助您管理用户会话的事件：Session_OnStart 事件和 Session_OnEnd 事件；前者在新会话开始时引发，后者在会话被放弃或过期时引发。</span></p> 
<p><span style="font-family:SimSun; font-size:14px">可以使用会话事件（Session_OnStart() 和 Session_OnEnd()）统计在线人数。</span></p> 
<p><span style="font-family:SimSun; font-size:14px">注意：只有会话状态属性 Mode 设置为 InProc（默认值）时，才支持 Session_OnEnd 事件</span><br> <br> <br> <br> <span style="font-size:18px; font-family:FangSong_GB2312"><strong>会话状态模式：</strong></span></p> 
<p><span style="font-size:18px; font-family:FangSong_GB2312"><strong>ASP.NET 会话状态模式包括5种:InProc模式(进程内模式)、StateServer模式(状态服务器模式)、SQLServer模式、Custom模式(自定义模式) 和 Off 模式。</strong></span><br> <br> <br> <span style="font-size:18px; font-family:FangSong_GB2312"><strong>1.InProc 模式：会话状态存储在 Web 服务器上的内存中。</strong></span></p> 
<p><span style="font-family:SimSun; font-size:14px">这是默认设置。唯一支持 Session_OnEnd 事件的模式。</span><br> <br> <br> <span style="font-size:18px; font-family:FangSong_GB2312"><strong>2.StateServer 模式：会话状态存储在一个名为 ASP.NET 状态服务的单独进程中。</strong></span></p> 
<p><span style="font-family:SimSun; font-size:14px">需要启动服务名称为aspnet_state 显示名称为ASP.NET State Service的服务。并配置Web.config文件如下：</span></p> 
<p></p> 
<pre><code class="language-html">&lt;configuration&gt;
  &lt;system.web&gt;
    &lt;sessionState mode="StateServer"
      stateConnectionString="tcpip=服务器名称:42424"
      timeout="40"/&gt;
  &lt;/system.web&gt;
&lt;/configuration&gt;</code></pre> 
<p></p> 
<p><span style="font-family:SimSun; font-size:14px">本地服务器名称为： localhost 或者 127.0.0.1</span></p> 
<p><span style="font-family:SimSun; font-size:14px">在注册表里可配置是否运行远程连接 和 端口号，如下：</span></p> 
<p><span style="font-family:SimSun; font-size:14px">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\aspnet_state\Parameters\AllowRemoteConnection</span></p> 
<p><span style="font-family:SimSun; font-size:14px">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\aspnet_state\Parameters\Port</span><br> <br> <br> <span style="font-size:18px; font-family:FangSong_GB2312"><strong>3.SQLServer 模式：会话状态存储到一个 SQL Server 数据库中。</strong></span></p> 
<p><span style="font-family:SimSun; font-size:14px">需要在 SQL Server 上安装 ASP.NET 会话状态数据库，可以使用 Aspnet_regsql.exe 工具安装会话状态数据库 和 运行InstallSqlState.sql脚本。并配置Web.config文件如下：</span></p> 
<p></p> 
<pre><code class="language-html">&lt;configuration&gt;
  &lt;system.web&gt;
        &lt;sessionState mode="SQLServer"
          sqlConnectionString="Data Source=LCL\SQLSERVER2012;Integrated Security=SSPI;
          timeout="40" /&gt;
  &lt;/system.web&gt;
&lt;/configuration&gt;</code></pre> 
<p><span style="font-size:14px; font-family:SimSun">Data Source=LCL\SQLSERVER2012 表示数据库的服务器名称为“LCL\SQLSERVER2012”。<br> Integrated Security=SSPI 表示使用Windows集成身份验证。<br> </span></p> 
<p><span style="font-size:14px; font-family:SimSun">使用此模式可以确保在重新启动 Web 应用程序时保留会话状态，并使会话状态可用于网络场中的多个 Web 服务器。</span></p> 
<p><span style="font-size:14px; font-family:SimSun">安装会话状态数据库后会创建aspnetdb和ASPState数据库，并且状态存储在系统数据库的tempdb数据库中的ASPStateTempSessions表里。</span></p> 
<p><span style="font-size:14px; font-family:SimSun">注意：需要运行SQLAgent服务（显示名称“SQL Server 代理”），并在数据库软件里的[SQL Server 代理]-[作业]里启动 ASPState_Job_DeleteExpiredSessions 作业。这样会自动清理过期的Session信息，如果不清理则SessionId一直存放在数据库，并且在服务器Session信息一直不会消失。</span></p> 
<p><br> </p> 
<p><br> <span style="font-family:FangSong_GB2312; font-size:18px"><strong>4.Custom 模式：允许您指定自定义存储提供程序。<br> <br> 5.Off 模式：禁用会话状态。</strong></span><br> </p> 
<p><span style="font-family:FangSong_GB2312; font-size:18px"><br> </span><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/97a3db278c5f3f821f23238d41a442a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">lombok注解介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be54c50f221784932ec662320a7e3fca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python中矩阵（matrix或array）运算比for循环速度更快</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>