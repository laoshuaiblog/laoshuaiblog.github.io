<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Learning Spark - LIGHTNING-FAST DATA ANALYSIS 第四章 - (1) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/47f6c2089fe3c5979719961c6853d053/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Learning Spark - LIGHTNING-FAST DATA ANALYSIS 第四章 - (1)">
  <meta property="og:description" content="续第三章：Learning Spark 第三章 RDD编程 已翻译整理完毕，PDF可下载
PS:今天去换药，一上午就没了，坑爹啊~~ 加油加油，第四章！！
第四章 处理键值对(Key/Value Pairs) 本章介绍如何处理键值对，这是Spark中常见的一种数据类型。键值对RDD通常用于聚合操作，也经常会将一些初始ETL(提取，转换，加载)获取的数据保存为键值对的格式。键值对的RDD也暴露了一些新的操作（比如每个产品的评价计数，按相同的键对数据进行分组，对两个不同的RDD分组）。
我们也会讨论一个键值对RDD的高级特征：分区(partitioning)，使用户可以跨节点控制RDD的布局。通过可控的分区，应用程序有时可确保数据在同一个机器上，可以集中访问，就可以大量的减少通信的开销，以此获得显著的提速。我们会用一个PageRand算法的例子来阐述分区。选择正确的分区对于分布式系统来说就和本地程序选择正确的数据结构类似，这两者都说明数据的布局对性能的影响非常大。
动机
Spark为包含键值对的RDD提供了一些特殊的操作。这种RDD被称之为pair RDD。Pair RDD在许多程序中都是很有用的组件，因为它们对外的操作可以让你并行的处理每个键，或者跨网络重组数据。例如，Pair RDD有一个reduceByKey()的方法，它可以对每个键的数据分别进行聚合；join()方法可以通过对两个RDD中相同的元素进行分组合并。从RDD中抽取字段（例如事件的事件，客户ID或者其他标识）并用这些字段作为pair RDD的键进行处理是很常见的。
创建Pair RDD
Spark中有多种方式能得到pair RDD。在第五章中我们要探索的很多格式加载时都可以直接的返回其键值数据为pair RDD。另外，我们有一个普通RDD想要转换为pair RDD，可以通过map()操作来返回键值对。通过代码来看个例子，从一个包含文本行的RDD开始，用每一行的第一个单词作为key。
这种方式构造键值RDD会根据编程语言有些不同。在Python中，为了处理有key的数据，我们需要返回tuple组成的RDD（见示例4-1）。
示例4-1 Python中使用第一个单词做key来创建pair RDD
pairs = lines.map(lambda x: (x.split(&#34; &#34;)[0], x))
在Scala中，为了处理有key的数据，我们同样需要返回tuple（见示例4-2）。tuple类型的RDD存在隐式转换，可以提供附加的键值函数。
示例4-2 Scala中使用第一个单词做key来创建pair RDD
val pairs = lines.map(x =&amp;gt; (x.split(&#34; &#34;)(0), x))
Java没有内置的tuple类型，所以Spark的Java API有一个用户创建的scala.Tuple2类。该类很简单：Java用户可以编写new Tuple2(elem1, elem2)来创建一个新tuple，然后用._1()和._2()方法来访问tuple中的元素。
Java用户在创建pair RDD时同样需要调用特殊版本的Spark函数。比如用mapToPair()替换基本函数map()，在43页的“JAVA”部分有更多讨论。不过可以看一个简单的示例4-3。
示例4-3 Java中使用第一个单词做key来创建pair RDD
PairFunction&amp;lt;String, String, String&amp;gt; keyData =
new PairFunction&amp;lt;String, String, String&amp;gt;() {
public Tuple2&amp;lt;String, String&amp;gt; call(String x) {">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2015-09-28T20:54:36+08:00">
    <meta property="article:modified_time" content="2015-09-28T20:54:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Learning Spark - LIGHTNING-FAST DATA ANALYSIS 第四章 - (1)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px">续第三章：</span><a target="_blank" href="http://blog.csdn.net/coding_hello/article/details/48769951" style="font-size:18px" rel="noopener noreferrer">Learning Spark 第三章 RDD编程 已翻译整理完毕，PDF可下载</a></p> 
<p><br> </p> 
<p><span style="font-size:18px">PS:今天去换药，一上午就没了，坑爹啊~~ 加油加油，第四章！！</span><br> </p> 
<p><br> </p> 
<p></p> 
<h4>第四章</h4> 
<h4>处理键值对<span style="font-family:'Times New Roman'">(Key/Value Pairs)</span></h4> 
<p></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>本章介绍如何处理键值对，这是<span style="font-family:Times New Roman">Spark</span><span style="font-family:宋体">中常见的一种数据类型。键值对</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">通常用于聚合操作，也经常会将一些初始</span><span style="font-family:Times New Roman">ETL(</span><span style="font-family:宋体">提取，转换，加载</span><span style="font-family:Times New Roman">)</span><span style="font-family:宋体">获取的数据保存为键值对的格式。键值对的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">也暴露了一些新的操作（比如每个产品的评价计数，按相同的键对数据进行分组，对两个不同的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">分组）。</span></p> 
<p> </p> 
<p>我们也会讨论一个键值对<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">的高级特征：分区</span><span style="font-family:Times New Roman">(partitioning)</span><span style="font-family:宋体">，使用户可以跨节点控制</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">的布局。通过可控的分区，应用程序有时可确保数据在同一个机器上，可以集中访问，就可以大量的减少通信的开销，以此获得显著的提速。我们会用一个</span><span style="font-family:Times New Roman">PageRand</span><span style="font-family:宋体">算法的例子来阐述分区。选择正确的分区对于分布式系统来说就和本地程序选择正确的数据结构类似，这两者都说明数据的布局对性能的影响非常大。</span></p> 
<p> </p> 
<p>动机</p> 
<p>Spark<span style="font-family:宋体">为包含键值对的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">提供了一些特殊的操作。这种</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">被称之为</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">。</span><span style="font-family:Times New Roman">Pair RDD</span><span style="font-family:宋体">在许多程序中都是很有用的组件，因为它们对外的操作可以让你并行的处理每个键，或者跨网络重组数据。例如，</span><span style="font-family:Times New Roman">Pair RDD</span><span style="font-family:宋体">有一个</span><span style="font-family:Times New Roman">reduceByKey()</span><span style="font-family:宋体">的方法，它可以对每个键的数据分别进行聚合；</span><span style="font-family:Times New Roman">join()</span><span style="font-family:宋体">方法可以通过对两个</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中相同的元素进行分组合并。从</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中抽取字段（例如事件的事件，客户</span><span style="font-family:Times New Roman">ID</span><span style="font-family:宋体">或者其他标识）并用这些字段作为</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">的键进行处理是很常见的。</span></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>创建<span style="font-family:Times New Roman">Pair RDD</span></p> 
<p>Spark<span style="font-family:宋体">中有多种方式能得到</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">。在第五章中我们要探索的很多格式加载时都可以直接的返回其键值数据为</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">。另外，我们有一个普通</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">想要转换为</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">，可以通过</span><span style="font-family:Times New Roman">map()</span><span style="font-family:宋体">操作来返回键值对。通过代码来看个例子，从一个包含文本行的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">开始，用每一行的第一个单词作为</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">。</span></p> 
<p> </p> 
<p>这种方式构造键值<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">会根据编程语言有些不同。在</span><span style="font-family:Times New Roman">Python</span><span style="font-family:宋体">中，为了处理有</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">的数据，我们需要返回</span><span style="font-family:Times New Roman">tuple</span><span style="font-family:宋体">组成的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">（见示例</span><span style="font-family:Times New Roman">4-1</span><span style="font-family:宋体">）。</span></p> 
<p> </p> 
<p>示例<span style="font-family:Times New Roman">4-1 Python</span><span style="font-family:宋体">中使用第一个单词做</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">来创建</span><span style="font-family:Times New Roman">pair RDD</span><span style="color:rgb(35,31,32)"><br> </span><span style="color:rgb(0,0,255)">pairs = lines.map(lambda x: (x.split(</span><span style="color:rgb(255,0,0)">" "</span><span style="color:rgb(0,0,255)">)[0], x))</span></p> 
<p><span style="color:rgb(0,0,255)"> </span></p> 
<p>在<span style="font-family:Times New Roman">Scala</span><span style="font-family:宋体">中，为了处理有</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">的数据，我们同样需要返回</span><span style="font-family:Times New Roman">tuple</span><span style="font-family:宋体">（见示例</span><span style="font-family:Times New Roman">4-2</span><span style="font-family:宋体">）。</span><span style="font-family:Times New Roman">tuple</span><span style="font-family:宋体">类型的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">存在隐式转换，可以提供附加的键值函数。</span></p> 
<p> </p> 
<p>示例<span style="font-family:Times New Roman">4-2 Scala</span><span style="font-family:宋体">中使用第一个单词做</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">来创建</span><span style="font-family:Times New Roman">pair RDD</span><span style="color:rgb(35,31,32)"><br> </span><span style="color:rgb(0,0,255)">val pairs = lines.map(x =&gt; (x.split(</span><span style="color:rgb(255,0,0)">" "</span><span style="color:rgb(0,0,255)">)(0), x))</span></p> 
<p>Java<span style="font-family:宋体">没有内置的</span><span style="font-family:Times New Roman">tuple</span><span style="font-family:宋体">类型，所以</span><span style="font-family:Times New Roman">Spark</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">Java API</span><span style="font-family:宋体">有一个用户创建的</span><span style="font-family:Times New Roman">scala.Tuple2</span><span style="font-family:宋体">类。该类很简单：</span><span style="font-family:Times New Roman">Java</span><span style="font-family:宋体">用户可以编写</span><span style="font-family:Times New Roman">new Tuple2(elem1, elem2)</span><span style="font-family:宋体">来创建一个新</span><span style="font-family:Times New Roman">tuple</span><span style="font-family:宋体">，然后用</span><span style="font-family:Times New Roman">._1()</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">._2()</span><span style="font-family:宋体">方法来访问</span><span style="font-family:Times New Roman">tuple</span><span style="font-family:宋体">中的元素。</span></p> 
<p> </p> 
<p>Java<span style="font-family:宋体">用户在创建</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">时同样需要调用特殊版本的</span><span style="font-family:Times New Roman">Spark</span><span style="font-family:宋体">函数。比如用</span><span style="font-family:Times New Roman">mapToPair()</span><span style="font-family:宋体">替换基本函数</span><span style="font-family:Times New Roman">map()</span><span style="font-family:宋体">，在</span><span style="font-family:Times New Roman">43</span><span style="font-family:宋体">页的“</span><span style="font-family:Times New Roman">JAVA</span><span style="font-family:宋体">”部分有更多讨论。不过可以看一个简单的示例</span><span style="font-family:Times New Roman">4-3</span><span style="font-family:宋体">。</span></p> 
<p> </p> 
<p>示例<span style="font-family:Times New Roman">4-3 Java</span><span style="font-family:宋体">中使用第一个单词做</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">来创建</span><span style="font-family:Times New Roman">pair RDD</span><span style="color:rgb(35,31,32)"><br> </span><span style="color:rgb(0,0,255)">PairFunction&lt;String, String, String&gt; keyData =</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">    </span><span style="color:rgb(0,0,255)">new PairFunction&lt;String, String, String&gt;() {<!-- --></span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">        </span><span style="color:rgb(0,0,255)">public Tuple2&lt;String, String&gt; call(String x) {<!-- --></span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">        </span><span style="color:rgb(0,0,255)">return new Tuple2(x.split(</span><span style="color:rgb(255,0,0)">" "</span><span style="color:rgb(0,0,255)">)[0], x);</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">    </span><span style="color:rgb(0,0,255)">}</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">};</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">JavaPairRDD&lt;String, String&gt; pairs = lines.mapToPair(keyData);</span></p> 
<p>在<span style="font-family:Times New Roman">Scala</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">Python</span><span style="font-family:宋体">中，当从内存中的的集合创建</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">，我们只需要对集合调用</span><span style="font-family:Times New Roman">SparkContext.parallelize()</span><span style="font-family:宋体">即可。而在</span><span style="font-family:Times New Roman">Java</span><span style="font-family:宋体">中，要从内存中的集合创建</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">，需要调用</span><span style="font-family:Times New Roman">SparkContext.parallelizePairs()</span><span style="font-family:宋体">函数。</span></p> 
<p> </p> 
<p>对<span style="font-family:Times New Roman">Pair RDD</span><span style="font-family:宋体">的变换</span></p> 
<p>Pair RDD<span style="font-family:宋体">允许使用标准</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">的所有转换。</span><span style="font-family:Times New Roman">30</span><span style="font-family:宋体">页中“传入函数到</span><span style="font-family:Times New Roman">Spark</span><span style="font-family:宋体">”的规则同样适用。由于</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">包含</span><span style="font-family:Times New Roman">tuple</span><span style="font-family:宋体">，我们需要传入操作</span><span style="font-family:Times New Roman">tuple</span><span style="font-family:宋体">而不是单个元素的函数。表</span><span style="font-family:Times New Roman">4-1</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">4-2</span><span style="font-family:宋体">汇总了对</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">的变换，在后面的章节中会深入这些变换的细节。</span></p> 
<p> </p> 
<p>表格 4-1 <span style="font-family:黑体">对单个</span><span style="font-family:Arial">pair RDD</span><span style="font-family:黑体">的变换（例子：</span><span style="font-family:Arial">{(1,2), (3,4), (3,6)}</span><span style="font-family:黑体">）</span></p> 
<table><tbody><tr><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">函数名</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">目的</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">示例</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">结果</span></p> </td></tr><tr><td> <p>reduceByKey(func)</p> </td><td> <p>按相同的键合并</p> </td><td> <p>rdd.reduceByKey(</p> <p>(x, y) =&gt; x + y )</p> </td><td> <p>{(1,2), (3,10)}</p> </td></tr><tr><td> <p>groupByKey()</p> </td><td> <p>按相同的键分组</p> </td><td> <p>rdd.groupByKey()</p> </td><td> <p>{(1,[2]),(3,[4,6])}</p> </td></tr><tr><td> <p>combineByKey(</p> <p>createCombiner, mergeValue, mergeCombiners, partitioner)</p> </td><td> <p>按相同的键合并，返回不同的结果类型</p> </td><td> <p>见示例<span style="font-family:Times New Roman">4-12</span><span style="font-family:宋体">到</span><span style="font-family:Times New Roman">4-14</span></p> </td><td> <p> </p> </td></tr><tr><td> <p>mapValues(func)</p> </td><td> <p>应用函数到<span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">的每个值，但是不改变键</span></p> </td><td> <p>rdd.mapValues(</p> <p>x =&gt; x+1)</p> </td><td> <p>{(1,3), (3, 5), (3, 7)}</p> </td></tr><tr><td> <p>flatMapValues(func)</p> </td><td> <p>应用一个返回<span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">中每个值的迭代器的函数，并对每个返回的元素以原来的键生成键值对，通常用于分词</span></p> </td><td> <p>rdd.flatMapValues(</p> <p>x =&gt; (x to 5) )</p> </td><td> <p>{(1, 2), (1, 3), (1, 4), (1, 5), (3, 4), (3, 5)}</p> </td></tr><tr><td> <p>keys()</p> </td><td> <p>只返回<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中的所有键</span></p> </td><td> <p>rdd.keys()</p> </td><td> <p>{1, 3, 3}</p> </td></tr></tbody></table> 
<p> </p> 
<table><tbody><tr><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">函数名</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">目的</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">示例</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">结果</span></p> </td></tr><tr><td> <p>values()</p> </td><td> <p>只返回<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中的所有值</span></p> </td><td> <p>rdd.values()</p> </td><td> <p>{2, 4, 6}</p> </td></tr><tr><td> <p>sortByKey()</p> </td><td> <p>返回按键排序的<span style="font-family:Times New Roman">RDD</span></p> </td><td> <p>rdd.sortByKey()</p> </td><td> <p>{(1, 2), (3, 4), (3, 6)}</p> </td></tr></tbody></table> 
<p> </p> 
<p>表格 4-2 <span style="font-family:黑体">对两个</span><span style="font-family:Arial">pair RDD</span><span style="font-family:黑体">的变换（</span><span style="font-family:Arial">rdd={(1,2), (3,4), (3,6)}</span><span style="font-family:黑体">，</span><span style="font-family:Arial">other={(3,9)}</span><span style="font-family:黑体">）</span></p> 
<table><tbody><tr><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">函数名</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">目的</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">示例</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255)">结果</span></p> </td></tr><tr><td> <p>subtractByKey</p> </td><td> <p>去除另一个<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中存在键的元素</span></p> </td><td> <p>rdd.subtractByKey(other)</p> </td><td> <p>{(1, 2)}</p> </td></tr><tr><td> <p>join</p> </td><td> <p>两个<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">执行内连接</span></p> </td><td> <p>rdd.join(other)</p> </td><td> <p>{(3, (4, 9)), (3, (6, 9)}</p> </td></tr><tr><td> <p>rightOutJoin</p> </td><td> <p>两个<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">执行连接操作，但是</span><span style="font-family:Times New Roman">other RDD</span><span style="font-family:宋体">中的</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">必须存在</span></p> </td><td> <p>rdd.rightOutJoin(other)</p> </td><td> <p>{(3, (Some(4), 9)), (3, (Some(6), 9))}</p> </td></tr><tr><td> <p>leftOutJoin</p> </td><td> <p>两个<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">执行连接操作，但是第一个</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中的</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">必须存在</span></p> </td><td> <p>rdd.leftOutJoin(other)</p> </td><td> <p>{(1,(2,None)), (3,(4,Some(9))), (3,(6,Some(9)))}</p> </td></tr><tr><td> <p>cogroup</p> </td><td> <p>对两个<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">的数据共享相同的键分组</span></p> </td><td> <p>rdd.cogroup(other)</p> </td><td> <p>{(1, ([2], [])),  (3,<br> ([4, 6], [9]))}</p> </td></tr></tbody></table> 
<p> </p> 
<p>我们将在接下来的章节讨论每个<span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">函数簇的更多细节。</span></p> 
<p> </p> 
<p>Pair RDD<span style="font-family:宋体">也仍然是</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">（在</span><span style="font-family:Times New Roman">Java/Scala</span><span style="font-family:宋体">中是</span><span style="font-family:Times New Roman">Tuple2</span><span style="font-family:宋体">类型的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">，在</span><span style="font-family:Times New Roman">Python</span><span style="font-family:宋体">中是</span><span style="font-family:Times New Roman">Tuple</span><span style="font-family:宋体">类型的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">），所以也支持</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">的相同功能。例如，我们可以用前一节中的</span><span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">来过滤掉大于</span><span style="font-family:Times New Roman">20</span><span style="font-family:宋体">字节的行。见示例</span><span style="font-family:Times New Roman">4-4</span><span style="font-family:宋体">到</span><span style="font-family:Times New Roman">4-6</span><span style="font-family:宋体">和图</span><span style="font-family:Times New Roman">4-1</span><span style="font-family:宋体">。</span></p> 
<p> </p> 
<p>示例<span style="font-family:Times New Roman">4-4 Python</span><span style="font-family:宋体">中对第二个元素简单过滤</span><span style="color:rgb(35,31,32)"><br> </span><span style="color:rgb(0,0,255)">result = pairs.filter(lambda keyValue: len(keyValue[1]) &lt; 20)</span></p> 
<p><span style="color:rgb(0,0,255)"> </span></p> 
<p>示例<span style="font-family:Times New Roman">4-5 Scala</span><span style="font-family:宋体">中对第二个元素简单过滤</span><span style="color:rgb(35,31,32)"><br> </span><span style="color:rgb(0,0,255)">pairs.filter{case (key, value) =&gt; value.length &lt; 20}</span></p> 
<p>示例<span style="font-family:Times New Roman">4-6 Java</span><span style="font-family:宋体">中对第二个元素简单过滤</span><span style="color:rgb(35,31,32)"><br> </span><span style="color:rgb(0,0,255)">Function&lt;Tuple2&lt;String, String&gt;, Boolean&gt; longWordFilter =</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">    </span><span style="color:rgb(0,0,255)">new Function&lt;Tuple2&lt;String, String&gt;, Boolean&gt;() {<!-- --></span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">        </span><span style="color:rgb(0,0,255)">public Boolean call(Tuple2&lt;String, String&gt; keyValue) {<!-- --></span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">        </span><span style="color:rgb(0,0,255)">return (keyValue._2().length() &lt; 20);</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">    </span><span style="color:rgb(0,0,255)">}</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">};</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">JavaPairRDD&lt;String, String&gt; result = pairs.filter(longWordFilter);</span></p> 
<p> </p> 
<p><img src="https://images2.imgbox.com/7c/f6/CbYp6xFw_o.png" alt=""><br> </p> 
<p>图 4-1 按值过滤</p> 
<p> </p> 
<p>有时我们只是想访问<span style="font-family:Times New Roman">pair RDD</span><span style="font-family:宋体">的值那部分，处理</span><span style="font-family:Times New Roman">pair</span><span style="font-family:宋体">就会有些不灵活。由于这是很常见的模式，所以</span><span style="font-family:Times New Roman">Spark</span><span style="font-family:宋体">提供了</span><span style="font-family:Times New Roman">mapValues(func)</span><span style="font-family:宋体">函数，等同于</span><span style="font-family:Times New Roman">map{case (x, y) =&gt; (x, func(y))}</span><span style="font-family:宋体">。在我们的示例中会大量使用该函数。</span></p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c0f8696301b5f4b78dc6011408b8f9e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Learning Spark 第三章 RDD编程 已翻译整理完毕，PDF可下载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6c8a691efe5fcc992a63db3f1f9acc4e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pom.xml解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>