<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ之消息确认机制（事务&#43;Confirm） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/2bc39751c1583020caa084afee213540/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="RabbitMQ之消息确认机制（事务&#43;Confirm）">
  <meta property="og:description" content="概述 在使用RabbitMQ的时候，我们可以通过消息持久化操作来解决因为服务器的异常奔溃导致的消息丢失，除此之外我们还会遇到一个问题，当消息的发布者在将消息发送出去之后，消息到底有没有正确到达broker代理服务器呢？如果不进行特殊配置的话，默认情况下发布操作是不会返回任何信息给生产者的，也就是默认情况下我们的生产者是不知道消息有没有正确到达broker的，如果在消息到达broker之前已经丢失的话，持久化操作也解决不了这个问题，因为消息根本就没到达代理服务器，你怎么进行持久化，那么这个问题该怎么解决呢？
RabbitMQ为我们提供了两种方式：
通过AMQP事务机制实现，这也是AMQP协议层面提供的解决方案；通过将channel设置成confirm模式来实现； 事务机制 这里首先探讨下RabbitMQ事务机制。
RabbitMQ中与事务机制有关的方法有三个：txSelect(), txCommit()以及txRollback(), txSelect用于将当前channel设置成transaction模式，txCommit用于提交事务，txRollback用于回滚事务，在通过txSelect开启事务之后，我们便可以发布消息给broker代理服务器了，如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了。
关键代码：
channel.txSelect(); channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes()); channel.txCommit(); 通过wirkshark抓包（ip.addr==xxx.xxx.xxx.xxx &amp;amp;&amp;amp; amqp），可以看到： （注意这里的Tx.Commit与Tx.Commit-Ok之间的时间间隔294ms，由此可见事务还是很耗时的。）
我们先来看看没有事务的通信过程是什么样的： 可以看到带事务的多了四个步骤：
client发送Tx.Selectbroker发送Tx.Select-Ok(之后publish)client发送Tx.Commitbroker发送Tx.Commit-Ok 下面我们来看下事务回滚是什么样子的。关键代码如下：
try { channel.txSelect(); channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes()); int result = 1 / 0; channel.txCommit(); } catch (Exception e) { e.printStackTrace(); channel.txRollback(); } 同样通过wireshark抓包可以看到： 代码中先是发送了消息至broker中但是这时候发生了异常，之后在捕获异常的过程中进行事务回滚。
事务确实能够解决producer与broker之间消息确认的问题，只有消息成功被broker接受，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作同时进行消息重发，但是使用事务机制的话会降低RabbitMQ的性能，那么有没有更好的方法既能保障producer知道消息已经正确送到，又能基本上不带来性能上的损失呢？从AMQP协议的层面看是没有更好的方法，但是RabbitMQ提供了一个更好的方案，即将channel信道设置成confirm模式。
Confirm模式 概述 上面我们介绍了RabbitMQ可能会遇到的一个问题，即生成者不知道消息是否真正到达broker，随后通过AMQP协议层面为我们提供了事务机制解决了这个问题，但是采用事务机制实现会降低RabbitMQ的消息吞吐量，那么有没有更加高效的解决方式呢？答案是采用Confirm模式。
producer端confirm模式的实现原理 生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。
confirm模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息。
在channel 被设置成 confirm 模式之后，所有被 publish 的后续消息都将被 confirm（即 ack） 或者被nack一次。但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm又被nack 。
开启confirm模式的方法 生产者通过调用channel的confirmSelect方法将channel设置为confirm模式，如果没有设置no-wait标志的话，broker会返回confirm.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2017-02-17T16:33:00+08:00">
    <meta property="article:modified_time" content="2017-02-17T16:33:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ之消息确认机制（事务&#43;Confirm）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="content-detail markdown-body"> 
 <div class="markdown_views"> 
  <h4><strong>概述</strong></h4> 
  <p>在使用RabbitMQ的时候，我们可以通过消息持久化操作来解决因为服务器的异常奔溃导致的消息丢失，除此之外我们还会遇到一个问题，当消息的发布者在将消息发送出去之后，消息到底有没有正确到达broker代理服务器呢？如果不进行特殊配置的话，默认情况下发布操作是不会返回任何信息给生产者的，也就是默认情况下我们的生产者是不知道消息有没有正确到达broker的，如果在消息到达broker之前已经丢失的话，持久化操作也解决不了这个问题，因为消息根本就没到达代理服务器，你怎么进行持久化，那么这个问题该怎么解决呢？</p> 
  <p>RabbitMQ为我们提供了两种方式：</p> 
  <ol><li>通过AMQP事务机制实现，这也是AMQP协议层面提供的解决方案；</li><li>通过将channel设置成confirm模式来实现；</li></ol> 
  <h3><strong>事务机制</strong></h3> 
  <p>这里首先探讨下RabbitMQ事务机制。</p> 
  <p>RabbitMQ中与事务机制有关的方法有三个：txSelect(), txCommit()以及txRollback(), txSelect用于将当前channel设置成transaction模式，txCommit用于提交事务，txRollback用于回滚事务，在通过txSelect开启事务之后，我们便可以发布消息给broker代理服务器了，如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了。</p> 
  <p>关键代码：</p> 
  <pre class="prettyprint"><code class="hljs avrasm">channel<span class="hljs-preprocessor">.txSelect</span>()<span class="hljs-comment">;</span>
channel<span class="hljs-preprocessor">.basicPublish</span>(ConfirmConfig<span class="hljs-preprocessor">.exchangeName</span>, ConfirmConfig<span class="hljs-preprocessor">.routingKey</span>, MessageProperties<span class="hljs-preprocessor">.PERSISTENT</span>_TEXT_PLAIN, ConfirmConfig<span class="hljs-preprocessor">.msg</span>_10B<span class="hljs-preprocessor">.getBytes</span>())<span class="hljs-comment">;</span>
channel<span class="hljs-preprocessor">.txCommit</span>()<span class="hljs-comment">;</span></code></pre> 
  <p>通过wirkshark抓包（ip.addr==xxx.xxx.xxx.xxx &amp;&amp; amqp），可以看到： <br><img src="https://images2.imgbox.com/14/dc/boOluJXj_o.png" alt="这里写图片描述" title=""><br> （注意这里的Tx.Commit与Tx.Commit-Ok之间的时间间隔294ms，由此可见事务还是很耗时的。）</p> 
  <p>我们先来看看没有事务的通信过程是什么样的： <br><img src="https://images2.imgbox.com/b3/5a/Vs0A5HGM_o.png" alt="这里写图片描述" title=""><br> 可以看到带事务的多了四个步骤：</p> 
  <ul><li>client发送Tx.Select</li><li>broker发送Tx.Select-Ok(之后publish)</li><li>client发送Tx.Commit</li><li>broker发送Tx.Commit-Ok</li></ul> 
  <p>下面我们来看下事务回滚是什么样子的。关键代码如下：</p> 
  <pre class="prettyprint"><code class="hljs avrasm">try {
    channel<span class="hljs-preprocessor">.txSelect</span>()<span class="hljs-comment">;</span>
    channel<span class="hljs-preprocessor">.basicPublish</span>(exchange, routingKey, MessageProperties<span class="hljs-preprocessor">.PERSISTENT</span>_TEXT_PLAIN, msg<span class="hljs-preprocessor">.getBytes</span>())<span class="hljs-comment">;</span>
    int result = <span class="hljs-number">1</span> / <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    channel<span class="hljs-preprocessor">.txCommit</span>()<span class="hljs-comment">;</span>
} catch (Exception e) {
    e<span class="hljs-preprocessor">.printStackTrace</span>()<span class="hljs-comment">;</span>
    channel<span class="hljs-preprocessor">.txRollback</span>()<span class="hljs-comment">;</span>
}</code></pre> 
  <p>同样通过wireshark抓包可以看到： <br><img src="https://images2.imgbox.com/2d/b0/CqRoMAIO_o.png" alt="这里写图片描述" title=""><br> 代码中先是发送了消息至broker中但是这时候发生了异常，之后在捕获异常的过程中进行事务回滚。</p> 
  <p>事务确实能够解决producer与broker之间消息确认的问题，只有消息成功被broker接受，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作同时进行消息重发，但是使用事务机制的话会降低RabbitMQ的性能，那么有没有更好的方法既能保障producer知道消息已经正确送到，又能基本上不带来性能上的损失呢？从AMQP协议的层面看是没有更好的方法，但是RabbitMQ提供了一个更好的方案，即将channel信道设置成confirm模式。</p> 
  <hr> 
  <h3><strong>Confirm模式</strong></h3> 
  <h4><strong>概述</strong></h4> 
  <p>上面我们介绍了RabbitMQ可能会遇到的一个问题，即生成者不知道消息是否真正到达broker，随后通过AMQP协议层面为我们提供了事务机制解决了这个问题，但是采用事务机制实现会降低RabbitMQ的消息吞吐量，那么有没有更加高效的解决方式呢？答案是采用Confirm模式。</p> 
  <h4><strong>producer端confirm模式的实现原理</strong></h4> 
  <p>生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。</p> 
  <p>confirm模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息。</p> 
  <p>在channel 被设置成 confirm 模式之后，所有被 publish 的后续消息都将被 confirm（即 ack） 或者被nack一次。但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm又被nack 。</p> 
  <h4><strong>开启confirm模式的方法</strong></h4> 
  <p>生产者通过调用channel的confirmSelect方法将channel设置为confirm模式，如果没有设置no-wait标志的话，broker会返回confirm.select-ok表示同意发送者将当前channel信道设置为confirm模式(从目前RabbitMQ最新版本3.6来看，如果调用了channel.confirmSelect方法，默认情况下是直接将no-wait设置成false的，也就是默认情况下broker是必须回传confirm.select-ok的)。 <br><img src="https://images2.imgbox.com/d4/6c/2PzLvV7y_o.png" alt="这里写图片描述" title=""></p> 
  <blockquote> 
   <p>已经在transaction事务模式的channel是不能再设置成confirm模式的，即这两种模式是不能共存的。</p> 
  </blockquote> 
  <h4><strong>编程模式</strong></h4> 
  <p>对于固定消息体大小和线程数，如果消息持久化，生产者confirm(或者采用事务机制)，消费者ack那么对性能有很大的影响.</p> 
  <p>消息持久化的优化没有太好方法，用更好的物理存储（SAS, SSD, RAID卡）总会带来改善。生产者confirm这一环节的优化则主要在于客户端程序的优化之上。归纳起来，客户端实现生产者confirm有三种编程方式：</p> 
  <ol><li>普通confirm模式：每发送一条消息后，调用waitForConfirms()方法，等待服务器端confirm。实际上是一种串行confirm了。</li><li>批量confirm模式：每发送一批消息后，调用waitForConfirms()方法，等待服务器端confirm。</li><li>异步confirm模式：提供一个回调方法，服务端confirm了一条或者多条消息后Client端会回调这个方法。</li></ol> 
  <p>从编程实现的复杂度上来看： <br><strong>第1种</strong> <br> 普通confirm模式最简单，publish一条消息后，等待服务器端confirm,如果服务端返回false或者超时时间内未返回，客户端进行消息重传。 <br> 关键代码如下：</p> 
  <pre class="prettyprint"><code class="hljs avrasm">channel<span class="hljs-preprocessor">.basicPublish</span>(ConfirmConfig<span class="hljs-preprocessor">.exchangeName</span>, ConfirmConfig<span class="hljs-preprocessor">.routingKey</span>, MessageProperties<span class="hljs-preprocessor">.PERSISTENT</span>_TEXT_PLAIN, ConfirmConfig<span class="hljs-preprocessor">.msg</span>_10B<span class="hljs-preprocessor">.getBytes</span>())<span class="hljs-comment">;</span>
if(!channel<span class="hljs-preprocessor">.waitForConfirms</span>()){
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"send message failed."</span>)<span class="hljs-comment">;</span>
}</code></pre> 
  <p>wirkShark抓包可以看到如下： <br><img src="https://images2.imgbox.com/6b/f8/DhVigR4c_o.png" alt="这里写图片描述" title=""><br> (注意这里的Publish与Ack的时间间隔：305ms 4ms 4ms 15ms 5ms…. )</p> 
  <p><strong>第二种</strong> <br> 批量confirm模式稍微复杂一点，客户端程序需要定期（每隔多少秒）或者定量（达到多少条）或者两则结合起来publish消息，然后等待服务器端confirm, 相比普通confirm模式，批量极大提升confirm效率，但是问题在于一旦出现confirm返回false或者超时的情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且，当消息经常丢失时，批量confirm性能应该是不升反降的。 <br> 关键代码：</p> 
  <pre class="prettyprint"><code class="hljs avrasm">channel<span class="hljs-preprocessor">.confirmSelect</span>()<span class="hljs-comment">;</span>
for(int i=<span class="hljs-number">0</span><span class="hljs-comment">;i&lt;batchCount;i++){<!-- --></span>
    channel<span class="hljs-preprocessor">.basicPublish</span>(ConfirmConfig<span class="hljs-preprocessor">.exchangeName</span>, ConfirmConfig<span class="hljs-preprocessor">.routingKey</span>, MessageProperties<span class="hljs-preprocessor">.PERSISTENT</span>_TEXT_PLAIN, ConfirmConfig<span class="hljs-preprocessor">.msg</span>_10B<span class="hljs-preprocessor">.getBytes</span>())<span class="hljs-comment">;</span>
}
if(!channel<span class="hljs-preprocessor">.waitForConfirms</span>()){
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"send message failed."</span>)<span class="hljs-comment">;</span>
}</code></pre> 
  <p><strong>第三种</strong> <br> 异步confirm模式的编程实现最复杂，Channel对象提供的ConfirmListener()回调方法只包含deliveryTag（当前Chanel发出的消息序号），我们需要自己为每一个Channel维护一个unconfirm的消息序号集合，每publish一条数据，集合中元素加1，每回调一次handleAck方法，unconfirm集合删掉相应的一条（multiple=false）或多条（multiple=true）记录。从程序运行效率上看，这个unconfirm集合最好采用有序集合SortedSet存储结构。实际上，SDK中的waitForConfirms()方法也是通过SortedSet维护消息序号的。 <br> 关键代码：</p> 
  <pre class="prettyprint"><code class="hljs java"> SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(<span class="hljs-keyword">new</span> TreeSet&lt;Long&gt;());
 channel.confirmSelect();
        channel.addConfirmListener(<span class="hljs-keyword">new</span> ConfirmListener() {
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleAck</span>(<span class="hljs-keyword">long</span> deliveryTag, <span class="hljs-keyword">boolean</span> multiple) <span class="hljs-keyword">throws</span> IOException {
                <span class="hljs-keyword">if</span> (multiple) {
                    confirmSet.headSet(deliveryTag + <span class="hljs-number">1</span>).clear();
                } <span class="hljs-keyword">else</span> {
                    confirmSet.remove(deliveryTag);
                }
            }
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleNack</span>(<span class="hljs-keyword">long</span> deliveryTag, <span class="hljs-keyword">boolean</span> multiple) <span class="hljs-keyword">throws</span> IOException {
                System.out.println(<span class="hljs-string">"Nack, SeqNo: "</span> + deliveryTag + <span class="hljs-string">", multiple: "</span> + multiple);
                <span class="hljs-keyword">if</span> (multiple) {
                    confirmSet.headSet(deliveryTag + <span class="hljs-number">1</span>).clear();
                } <span class="hljs-keyword">else</span> {
                    confirmSet.remove(deliveryTag);
                }
            }
        });

        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
            <span class="hljs-keyword">long</span> nextSeqNo = channel.getNextPublishSeqNo();
            channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());
            confirmSet.add(nextSeqNo);
        }</code></pre> 
  <p>SDK中waitForConfirms方法实现：</p> 
  <pre class="prettyprint"><code class="hljs java"><span class="hljs-javadoc">/** Set of currently unconfirmed messages (i.e. messages that have
 *  not been ack'd or nack'd by the server yet. */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SortedSet&lt;Long&gt; unconfirmedSet =
        Collections.synchronizedSortedSet(<span class="hljs-keyword">new</span> TreeSet&lt;Long&gt;());

<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">waitForConfirms</span>(<span class="hljs-keyword">long</span> timeout)
        <span class="hljs-keyword">throws</span> InterruptedException, TimeoutException {
    <span class="hljs-keyword">if</span> (nextPublishSeqNo == <span class="hljs-number">0</span>L)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Confirms not selected"</span>);
    <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();
    <span class="hljs-keyword">synchronized</span> (unconfirmedSet) {
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
            <span class="hljs-keyword">if</span> (getCloseReason() != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">throw</span> Utility.fixStackTrace(getCloseReason());
            }
            <span class="hljs-keyword">if</span> (unconfirmedSet.isEmpty()) {
                <span class="hljs-keyword">boolean</span> aux = onlyAcksReceived;
                onlyAcksReceived = <span class="hljs-keyword">true</span>;
                <span class="hljs-keyword">return</span> aux;
            }
            <span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">0</span>L) {
                unconfirmedSet.wait();
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">long</span> elapsed = System.currentTimeMillis() - startTime;
                <span class="hljs-keyword">if</span> (timeout &gt; elapsed) {
                    unconfirmedSet.wait(timeout - elapsed);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeoutException();
                }
            }
        }
    }
}</code></pre> 
  <h4><strong>性能测试</strong></h4> 
  <p>Client端机器和RabbitMQ机器配置：CPU:24核，2600MHZ, 64G内存，1TB硬盘。 <br> Client端发送消息体大小10B，线程数为1即单线程，消息都持久化处理（deliveryMode:2）。 <br> 分别采用事务模式、普通confirm模式，批量confirm模式和异步confirm模式进行producer实验，比对各个模式下的发送性能。 <br><img src="https://images2.imgbox.com/12/63/Tj2L115X_o.png" alt="这里写图片描述" title=""></p> 
  <p>发送平均速率：</p> 
  <ul><li>事务模式（tx）：1637.484</li><li>普通confirm模式(common)：1936.032</li><li>批量confirm模式(batch)：10432.45</li><li>异步confirm模式(async)：10542.06</li></ul> 
  <p>可以看到事务模式性能是最差的，普通confirm模式性能比事务模式稍微好点，但是和批量confirm模式还有异步confirm模式相比，还是小巫见大巫。批量confirm模式的问题在于confirm之后返回false之后进行重发这样会使性能降低，异步confirm模式(async)编程模型较为复杂，至于采用哪种方式，那是仁者见仁智者见智了。</p> 
  <hr> 
  <h3><strong>消息确认（Consumer端）</strong></h3> 
  <p>为了保证消息从队列可靠地到达消费者，RabbitMQ提供消息确认机制(message acknowledgment)。消费者在声明队列时，可以指定noAck参数，当noAck=false时，RabbitMQ会等待消费者显式发回ack信号后才从内存(和磁盘，如果是持久化消息的话)中移去消息。否则，RabbitMQ会在队列中消息被消费后立即删除它。</p> 
  <p>采用消息确认机制后，只要令noAck=false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直持有消息直到消费者显式调用basicAck为止。</p> 
  <p>当noAck=false时，对于RabbitMQ服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者ack信号的消息。如果服务器端一直没有收到消费者的ack信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。</p> 
  <p>RabbitMQ不会为未ack的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。</p> 
  <p>RabbitMQ管理平台界面上可以看到当前队列中Ready状态和Unacknowledged状态的消息数，分别对应上文中的等待投递给消费者的消息数和已经投递给消费者但是未收到ack信号的消息数。也可以通过命令行来查看上述信息： <br><img src="https://images2.imgbox.com/8f/c4/5aoj8uDw_o.png" alt="这里写图片描述" title=""></p> 
  <p>代码示例（关闭自动消息确认，进行手动ack）：</p> 
  <pre class="prettyprint"><code class="hljs javascript">        QueueingConsumer consumer = <span class="hljs-keyword">new</span> QueueingConsumer(channel);
        channel.basicConsume(ConfirmConfig.queueName, <span class="hljs-literal">false</span>, consumer);

        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
            QueueingConsumer.Delivery delivery = consumer.nextDelivery();
            <span class="hljs-built_in">String</span> msg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(delivery.getBody());
     <span class="hljs-comment">// do something with msg. </span>
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);
        }</code></pre> 
  <blockquote> 
   <p>broker将在下面的情况中对消息进行confirm：</p> 
   <blockquote> 
    <p>broker发现当前消息无法被路由到指定的queues中（如果设置了mandatory属性，则broker会发送basic.return） <br> 非持久属性的消息到达了其所应该到达的所有queue中（和镜像queue中） <br> 持久消息到达了其所应该到达的所有queue中（和镜像中），并被持久化到了磁盘（fsync） <br> 持久消息从其所在的所有queue中被consume了（如果必要则会被ack）</p> 
   </blockquote> 
  </blockquote> 
  <p>basicRecover：是路由不成功的消息可以使用recovery重新发送到队列中。 <br> basicReject：是接收端告诉服务器这个消息我拒绝接收,不处理,可以设置是否放回到队列中还是丢掉，而且只能一次拒绝一个消息,官网中有明确说明不能批量拒绝消息，为解决批量拒绝消息才有了basicNack。 <br> basicNack：可以一次拒绝N条消息，客户端可以设置basicNack方法的multiple参数为true，服务器会拒绝指定了delivery_tag的所有未确认的消息(tag是一个64位的long值，最大值是9223372036854775807)。</p> 
  <hr> 
  <h3>参考资料</h3> 
  <ol><li><a href="http://blog.csdn.net/hzw19920329/article/details/54340711">深入学习RabbitMQ(三)：channel的confirm模式</a></li><li><a href="http://blog.csdn.net/anzhsoft/article/details/21603479">RabbitMQ消息队列（九）：Publisher的消息确认机制</a></li><li><a href="http://blog.csdn.net/hzw19920329/article/details/54315940">深入学习RabbitMQ(二)：AMQP事务机制</a></li></ol> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b33c421cc26503f4f25dea44120077b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">maven资源过滤导致打包后文件变大</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc6683bfec59fa867fdfc827589382ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JAVA对MYSQL数据库进行批量操作，addBatch(),executeBatch()方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>