<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>leetcode每日一题--矩阵中移动的最大次数 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/afc01e95f033e1451cda1e320068e5a9/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="leetcode每日一题--矩阵中移动的最大次数">
  <meta property="og:description" content="一.题目原型 二.思路解析 1.动态规划 这道题要求的是矩阵的最大移动次数。根据题目意思，从索引 0 列开始向右移动，每次移动一列，最多移动到 n - 1 列，也就是 n - 1次。其移动规则为：当前单元格可以移动到其右上方、正右方以及右下方三个位置中严格大于其的单元格。那么换个角度想，一个单元格可以从其左上方、正左方以及左下方的单元格转移过来。
这不就是我们动态规划最开始的典型思路吗？
在这题中，我们从第一列开始，往后能走多少，到了第几列，其实就是这一次的走的步数，走到最远的列，就是最大的移动次数。
我们创建一个二维dp数组，初始化为0，我们从不同行的第一列元素开始走，能走到的地方我们做一个标记为1，已经标记过的我们就不再去走了，以免死循环。
int m=grid.size(),n=grid[0].size(),max_j=0; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;dp(m,vector&amp;lt;int&amp;gt;(n,0)); for(int i=0;i&amp;lt;m;&#43;&#43;i){//初始化 dp[i][0]=1; } dp【i】【j】由dp【i-1】【j-1】和dp【i】【j-1】和dp【i&#43;1】【j】决定
for(int j=1;j&amp;lt;n;&#43;&#43;j){//从第1列开始 for(int i=0;i&amp;lt;m;&#43;&#43;i){ if((dp[i][j-1]==1&amp;amp;&amp;amp;grid[i][j]&amp;gt;grid[i][j-1])||(i-1&amp;gt;-1&amp;amp;&amp;amp;dp[i-1][j-1]==1&amp;amp;&amp;amp;grid[i][j]&amp;gt;grid[i-1][j-1])||(i&#43;1&amp;lt;m&amp;amp;&amp;amp;dp[i&#43;1][j-1]==1&amp;amp;&amp;amp;grid[i][j]&amp;gt;grid[i&#43;1][j-1])){ dp[i][j]=1; max_j=j; } } } 2.深度优先遍历 从第一列的任一单元格 (i,0)开始递归。枚举往右上/右/右下三个方向走，如果走一步后，没有出界，且格子值大于 grid[i][j]，则可以走，继续递归。
在递归过程中，记录能访问到的最大列号，作为答案。
代码实现时，为避免重复递归之前访问过的格子，可以用一个 vis 数组标记访问过的格子。但实际上，可以把 grid[i][j]置为 0从而无需创建 vis数组。这是因为网格值均为正数，并且我们只能访问到比当前格子值更大的格子，所以置为 0 会导致永远无法访问到该格子，这正是我们所希望的。grid[i][j]置为0，表示这个点我们已经走过了，之后没有必要再走了，因为再往这个点走，移动的次数都是一样的。标记后就肯定不会再走了，因为要往后走的一个条件就是后面的点的值大于当前点的值。
function&amp;lt;void(int, int)&amp;gt; dfs = [&amp;amp;](int i, int j) { ans = max(ans, j); if (ans == n - 1) { // ans 已达到最大值 return; } // 向右上/右/右下走一步 for (int k = max(i - 1, 0); k &amp;lt; min(i &#43; 2, m); k&#43;&#43;) { if (grid[k][j &#43; 1] &amp;gt; grid[i][j]) { dfs(k, j &#43; 1); } } grid[i][j] = 0; }; 3.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-16T22:59:39+08:00">
    <meta property="article:modified_time" content="2024-03-16T22:59:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">leetcode每日一题--矩阵中移动的最大次数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2> 一.题目原型</h2> 
<p><img alt="" height="320" src="https://images2.imgbox.com/c6/bf/6TRgtOj3_o.png" width="700"><img alt="" height="541" src="https://images2.imgbox.com/55/bb/j1EnxDgC_o.png" width="706"></p> 
<p><img alt="" height="669" src="https://images2.imgbox.com/58/2d/iSPKFxYP_o.png" width="669"> </p> 
<h2> 二.思路解析</h2> 
<h3>1.动态规划</h3> 
<p>这道题要求的是矩阵的最大移动次数。根据题目意思，从索引 0 列开始向右移动，每次移动一列，最多移动到 n - 1 列，也就是 n - 1次。其移动规则为：当前单元格可以移动到其右上方、正右方以及右下方三个位置中严格大于其的单元格。那么换个角度想，一个单元格可以从其左上方、正左方以及左下方的单元格转移过来。</p> 
<p><img alt="" height="699" src="https://images2.imgbox.com/ca/79/6GH9NbH6_o.png" width="1200"></p> 
<p>这不就是我们动态规划最开始的典型思路吗？</p> 
<p>在这题中，我们从第一列开始，往后能走多少，到了第几列，其实就是这一次的走的步数，走到最远的列，就是最大的移动次数。</p> 
<p>我们创建一个二维dp数组，初始化为0，我们从不同行的第一列元素开始走，能走到的地方我们做一个标记为1，已经标记过的我们就不再去走了，以免死循环。</p> 
<pre><code class="hljs">int m=grid.size(),n=grid[0].size(),max_j=0;
        vector&lt;vector&lt;int&gt;&gt;dp(m,vector&lt;int&gt;(n,0));
        for(int i=0;i&lt;m;++i){//初始化
            dp[i][0]=1;
        }</code></pre> 
<p> dp【i】【j】由dp【i-1】【j-1】和dp【i】【j-1】和dp【i+1】【j】决定</p> 
<p><img alt="" height="153" src="https://images2.imgbox.com/6e/22/VradadpH_o.png" width="117"></p> 
<pre><code class="hljs">for(int j=1;j&lt;n;++j){//从第1列开始
            for(int i=0;i&lt;m;++i){
                if((dp[i][j-1]==1&amp;&amp;grid[i][j]&gt;grid[i][j-1])||(i-1&gt;-1&amp;&amp;dp[i-1][j-1]==1&amp;&amp;grid[i][j]&gt;grid[i-1][j-1])||(i+1&lt;m&amp;&amp;dp[i+1][j-1]==1&amp;&amp;grid[i][j]&gt;grid[i+1][j-1])){
                    dp[i][j]=1;
                    max_j=j;
                }
            }
        }</code></pre> 
<h3>2.深度优先遍历</h3> 
<p>从第一列的任一单元格 (i,0)开始递归。枚举往右上/右/右下三个方向走，如果走一步后，没有出界，且格子值大于 grid[i][j]，则可以走，继续递归。</p> 
<p>在递归过程中，记录能访问到的最大列号，作为答案。</p> 
<p>代码实现时，为避免重复递归之前访问过的格子，可以用一个 vis 数组标记访问过的格子。但实际上，可以把 grid[i][j]置为 0从而无需创建 vis数组。这是因为网格值均为正数，并且我们只能访问到比当前格子值更大的格子，所以置为 0 会导致永远无法访问到该格子，这正是我们所希望的。grid[i][j]置为0，表示这个点我们已经走过了，之后没有必要再走了，因为再往这个点走，移动的次数都是一样的。标记后就肯定不会再走了，因为要往后走的一个条件就是后面的点的值大于当前点的值。</p> 
<pre><code class="hljs">function&lt;void(int, int)&gt; dfs = [&amp;](int i, int j) {
            ans = max(ans, j);
            if (ans == n - 1) { // ans 已达到最大值
                return;
            }
            // 向右上/右/右下走一步
            for (int k = max(i - 1, 0); k &lt; min(i + 2, m); k++) {
                if (grid[k][j + 1] &gt; grid[i][j]) {
                    dfs(k, j + 1);
                }
            }
            grid[i][j] = 0;
        };</code></pre> 
<p>3.广度优先遍历</p> 
<p>同样，我们也可以使用BFS的方法，我们首先将所有的行坐标加入集合中，表示这些地方都可以走，作为出发点。然后依次进行遍历，找到下一列可以走到的所有行坐标，这些下一列的行坐标都是严格满足比其走过来的点值要大的，然后将这些行坐标的集合替换掉之前的集合，再进行遍历，找到下一列能够走到的行坐标。直到没有能走的行坐标，或者走到最后一列为止。</p> 
<p>我们需要一个vis数组去标记走过的位置，不能再走了</p> 
<p>定义一个判断坐标合法的函数is_valid去判断坐标是不是合法的。</p> 
<p></p> 
<h2>三.代码实现：</h2> 
<h3>动态规划（DP）</h3> 
<pre><code class="hljs">class Solution {
public:
    int maxMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int m=grid.size(),n=grid[0].size(),max_j=0;
        vector&lt;vector&lt;int&gt;&gt;dp(m,vector&lt;int&gt;(n,0));
        for(int i=0;i&lt;m;++i){//初始化
            dp[i][0]=1;
        }
        for(int j=1;j&lt;n;++j){//从第1列开始
            for(int i=0;i&lt;m;++i){
                if((dp[i][j-1]==1&amp;&amp;grid[i][j]&gt;grid[i][j-1])||(i-1&gt;-1&amp;&amp;dp[i-1][j-1]==1&amp;&amp;grid[i][j]&gt;grid[i-1][j-1])||(i+1&lt;m&amp;&amp;dp[i+1][j-1]==1&amp;&amp;grid[i][j]&gt;grid[i+1][j-1])){
                    dp[i][j]=1;
                    max_j=j;
                }
            }
        }
        return max_j;
    }
};


</code></pre> 
<h3>深度优先遍历（DFS）</h3> 
<pre><code class="hljs">class Solution {
public:
    int maxMoves(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {
        int m = grid.size(), n = grid[0].size();
        int ans = 0;
        function&lt;void(int, int)&gt; dfs = [&amp;](int i, int j) {
            ans = max(ans, j);
            if (ans == n - 1) { // ans 已达到最大值
                return;
            }
            // 向右上/右/右下走一步
            for (int k = max(i - 1, 0); k &lt; min(i + 2, m); k++) {
                if (grid[k][j + 1] &gt; grid[i][j]) {
                    dfs(k, j + 1);
                }
            }
            grid[i][j] = 0;
        };
        for (int i = 0; i &lt; m; i++) {
            dfs(i, 0); // 从第一列的任一单元格出发
        }
        return ans;
    }
};
</code></pre> 
<h3><strong>广度优先遍历（BFS）</strong></h3> 
<pre><code class="hljs">class Solution {
public:
    int maxMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int M = grid.size(), N = grid[0].size();
        auto is_valid = [&amp;](int r, int c) -&gt; bool {
            return 0 &lt;= r &amp;&amp; r &lt; M &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; N;
        };
        queue&lt;pair&lt;int, int&gt;&gt; que;
        vector&lt;vector&lt;bool&gt;&gt; vis(M, vector&lt;bool&gt;(N, false));
        for (int r = 0; r &lt; M; r++) {
            vis[r][0] = true;
            que.push(make_pair(r, 0));
        }
        int ans = 0;
        while (!que.empty()) {
            auto [r, c] = que.front(); que.pop();
            ans = max(ans, c);
            int ce = c+1;
            for (const int&amp; re : {r-1, r, r+1}) {
                if (is_valid(re, ce) &amp;&amp; !vis[re][ce] &amp;&amp; grid[r][c] &lt; grid[re][ce]) {
                    vis[re][ce] = true;
                    que.push(make_pair(re, ce));
                }
            }
        }
        return ans;
    }
};
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02b6bff446e37d48fc807919f8f24177/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">rust引用-借用机制扩展</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45175afff05399d782cdb58e14794a9d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 数据结构 二叉树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>