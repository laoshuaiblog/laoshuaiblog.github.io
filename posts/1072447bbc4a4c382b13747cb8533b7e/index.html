<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Learning Spark - LIGHTNING-FAST DATA ANALYSIS 第三章 - (3) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/1072447bbc4a4c382b13747cb8533b7e/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Learning Spark - LIGHTNING-FAST DATA ANALYSIS 第三章 - (3)">
  <meta property="og:description" content="更新，第三章完整版PDF可下载：Learning Spark 第三章 RDD编程 已翻译整理完毕，PDF可下载
续啊续，再续上一篇：Learning Spark - LIGHTNING-FAST DATA ANALYSIS 第三章 - (2)
常见的变换和动作
在本章中，我们巡视一遍Spark中最常见的变换和动作。对包含某种类型数据的RDD还有些另外的操作可用，比如RDD的数量的统计函数，对RDD的key/value对按照key进行聚合的key/value操作。在后面的章节中我们会讲到RDD类型之间的转换和其他操作。
基本RDD
我们先从对于不管是什么数据的RDD都适用的变换和动作说起。
元素级的变换
两个最常见的你可能用到的变换是map()和filter()（见图3-2）。map()变换传入一个函数，并将该函数应用到RDD中的每一个元素。函数的返回结果就是变换后的每个元素构成的新RDD。filter()变换也是传入一个函数，返回的是该RDD中仅能通过该函数的元素构成的新RDD。
图 3-2 从输入RDD中map和filter后的RDD
我们可以用map()做任何的事情，从我们的集合中取出网站关联的每个url到计算平方数。map()的返回类型不必和输入类型相同，这很有用。如果我们有一个String类型的RDD，通过map()将字符串解析后返回double，那么我们的输入类型就是RDD[String]，而结果类型就是RDD[Double]。
让我们看一个map()的简单例子，计算RDD中所有数的平方（示例3-36到3-28）。
示例3-26：Python计算RDD中的平方值
nums = sc.parallelize([1, 2, 3, 4])
squared = nums.map(lambda x: x * x).collect()
for num in squared:
print &#34;%i &#34; % (num)
示例3-27：Scala计算RDD中的平方值
val input = sc.parallelize(List(1, 2, 3, 4))
val result = input.map(x =&amp;gt; x * x)
println(result.collect().mkString(&#34;,&#34;))
示例3-28：Java计算RDD中的平方值
JavaRDD&amp;lt;Integer&amp;gt; rdd = sc.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2015-09-26T21:04:15+08:00">
    <meta property="article:modified_time" content="2015-09-26T21:04:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Learning Spark - LIGHTNING-FAST DATA ANALYSIS 第三章 - (3)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="font-family:宋体; font-size:18px">更新，第三章完整版PDF可下载：</span><a target="_blank" href="http://blog.csdn.net/coding_hello/article/details/48769951" style="font-family:宋体; font-size:18px" rel="noopener noreferrer">Learning Spark 第三章 RDD编程 已翻译整理完毕，PDF可下载</a><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">续啊续，再续上一篇：<a target="_blank" href="http://blog.csdn.net/coding_hello/article/details/48737997" rel="noopener noreferrer">Learning Spark - LIGHTNING-FAST DATA ANALYSIS 第三章 - (2)</a></span><br> </p> 
<p><br> </p> 
<p></p> 
<p>常见的变换和动作</p> 
<p>在本章中，我们巡视一遍<span style="font-family:Times New Roman">Spark</span><span style="font-family:宋体">中最常见的变换和动作。对包含某种类型数据的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">还有些另外的操作可用，比如</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">的数量的统计函数，对</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">key/value</span><span style="font-family:宋体">对按照</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">进行聚合的</span><span style="font-family:Times New Roman">key/value</span><span style="font-family:宋体">操作。在后面的章节中我们会讲到</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">类型之间的转换和其他操作。</span></p> 
<p>基本<span style="font-family:Times New Roman">RDD</span></p> 
<p>我们先从对于不管是什么数据的<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">都适用的变换和动作说起。</span></p> 
<p> </p> 
<p>元素级的变换</p> 
<p>两个最常见的你可能用到的变换是<span style="font-family:Times New Roman">map()</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">filter()</span><span style="font-family:宋体">（见图</span><span style="font-family:Times New Roman">3-2</span><span style="font-family:宋体">）。</span><span style="font-family:Times New Roman">map()</span><span style="font-family:宋体">变换传入一个函数，并将该函数应用到</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中的每一个元素。函数的返回结果就是变换后的每个元素构成的新</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">。</span><span style="font-family:Times New Roman">filter()</span><span style="font-family:宋体">变换也是传入一个函数，返回的是该</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中仅能通过该函数的元素构成的新</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">。</span></p> 
<p> <img src="https://images2.imgbox.com/89/0b/yJjyFwzF_o.png" alt=""></p> 
<p>图 3-2 <span style="font-family:黑体">从输入</span><span style="font-family:Arial">RDD</span><span style="font-family:黑体">中</span><span style="font-family:Arial">map</span><span style="font-family:黑体">和</span><span style="font-family:Arial">filter</span><span style="font-family:黑体">后的</span><span style="font-family:Arial">RDD</span></p> 
<p> </p> 
<p>我们可以用<span style="font-family:Times New Roman">map()</span><span style="font-family:宋体">做任何的事情，从我们的集合中取出网站关联的每个</span><span style="font-family:Times New Roman">url</span><span style="font-family:宋体">到计算平方数。</span><span style="font-family:Times New Roman">map()</span><span style="font-family:宋体">的返回类型不必和输入类型相同，这很有用。如果我们有一个</span><span style="font-family:Times New Roman">String</span><span style="font-family:宋体">类型的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">，通过</span><span style="font-family:Times New Roman">map()</span><span style="font-family:宋体">将字符串解析后返回</span><span style="font-family:Times New Roman">double</span><span style="font-family:宋体">，那么我们的输入类型就是</span><span style="font-family:Times New Roman">RDD[String]</span><span style="font-family:宋体">，而结果类型就是</span><span style="font-family:Times New Roman">RDD[Double]</span><span style="font-family:宋体">。</span></p> 
<p> </p> 
<p>让我们看一个<span style="font-family:Times New Roman">map()</span><span style="font-family:宋体">的简单例子，计算</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中所有数的平方（示例</span><span style="font-family:Times New Roman">3-36</span><span style="font-family:宋体">到</span><span style="font-family:Times New Roman">3-28</span><span style="font-family:宋体">）。</span></p> 
<p> </p> 
<p>示例<span style="font-family:Times New Roman">3-26</span><span style="font-family:宋体">：</span><span style="font-family:Times New Roman">Python</span><span style="font-family:宋体">计算</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中的平方值</span><br> <span style="color:rgb(0,0,255)">nums </span><span style="color:rgb(0,0,255)">= sc.parallelize([1, 2, 3, 4])</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">squared = nums.map(</span><span style="color:rgb(0,0,255)">lambda </span><span style="color:rgb(0,0,255)">x: x * x).collect()</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">for num in squared:</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">    </span><span style="color:rgb(0,0,255)">print </span><span style="color:rgb(255,0,0)">"%i "</span><span style="color:rgb(0,0,255)"> % (num)</span><span style="color:rgb(0,0,255)"><br> </span></p> 
<p>示例<span style="font-family:Times New Roman">3-27</span><span style="font-family:宋体">：</span><span style="font-family:Times New Roman">Scala</span><span style="font-family:宋体">计算</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中的平方值</span><br> <span style="color:rgb(0,0,255)">val input = sc.parallelize(List(1, 2, 3, 4))</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">val result = input.map(x =&gt; x * x)</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">println(result.collect().mkString(</span><span style="color:rgb(255,0,0)">","</span><span style="color:rgb(0,0,255)">))</span></p> 
<p><span style="color:rgb(0,0,255)"><br> </span>示例<span style="font-family:Times New Roman">3-28</span><span style="font-family:宋体">：</span><span style="font-family:Times New Roman">Java</span><span style="font-family:宋体">计算</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中的平方值</span><br> <span style="color:rgb(0,0,255)">JavaRDD&lt;Integer&gt; rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4));</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">JavaRDD&lt;Integer&gt; result = rdd.map(new Function&lt;Integer, Integer&gt;() {<!-- --></span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">    </span><span style="color:rgb(0,0,255)">public Integer call(Integer x) { return x*x; }</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">});</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">System.out.println(StringUtils.join(result.collect(), </span><span style="color:rgb(255,0,0)">","</span><span style="color:rgb(0,0,255)">));</span></p> 
<p><span style="color:rgb(0,0,255)"> </span></p> 
<p>有时我们想为每个输入元素产生多个输出元素。这个操作叫做<span style="font-family:Times New Roman">flatMap()</span><span style="font-family:宋体">。和</span><span style="font-family:Times New Roman">map()</span><span style="font-family:宋体">一样，我们提供给</span><span style="font-family:Times New Roman">flatMap()</span><span style="font-family:宋体">的函数被输入</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中的每个元素单独调用，但不是返回单个元素，而是返回的一个返回值的迭代器。与其说是产生了一个迭代器的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">，不如说是得到了一个来自所有迭代器的元素组成的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">。</span><span style="font-family:Times New Roman">flatMap()</span><span style="font-family:宋体">的一个简单用法是分割输入字符串到单词，见示例</span><span style="font-family:Times New Roman">3-29</span><span style="font-family:宋体">到</span><span style="font-family:Times New Roman">3-31</span><span style="font-family:宋体">。</span></p> 
<p> </p> 
<p>示例<span style="font-family:Times New Roman">3-29 Python</span><span style="font-family:宋体">中使用</span><span style="font-family:Times New Roman">flatMap()</span><span style="font-family:宋体">分割文本行到单词</span><br> <span style="color:rgb(0,0,255)">lines = sc.parallelize([</span><span style="color:rgb(255,0,0)">"hello world"</span><span style="color:rgb(0,0,255)">, </span><span style="color:rgb(255,0,0)">"hi"</span><span style="color:rgb(0,0,255)">])</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">words = lines.flatMap(lambda line: line.split(</span><span style="color:rgb(255,0,0)">" "</span><span style="color:rgb(0,0,255)">))</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">words.first() # returns "hello"</span><span style="color:rgb(0,0,255)"><br> </span></p> 
<p>示例<span style="font-family:Times New Roman">3-30 Scala</span><span style="font-family:宋体">中使用</span><span style="font-family:Times New Roman">flatMap()</span><span style="font-family:宋体">分割文本行到单词</span></p> 
<p><span style="color:rgb(0,0,255)">val lines = sc.parallelize(List("</span><span style="color:rgb(255,0,0)">hello world"</span><span style="color:rgb(0,0,255)">, </span><span style="color:rgb(255,0,0)">"hi"</span><span style="color:rgb(0,0,255)">))</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">val words = lines.flatMap(line =&gt; line.split(</span><span style="color:rgb(255,0,0)">" "</span><span style="color:rgb(0,0,255)">))</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">words.first() // returns "hello"</span><span style="color:rgb(53,88,108)"><br> </span></p> 
<p>示例<span style="font-family:Times New Roman">3-31 Java</span><span style="font-family:宋体">中使用</span><span style="font-family:Times New Roman">flatMap()</span><span style="font-family:宋体">分割文本行到单词</span><span style="color:rgb(35,31,32)"><br> </span><span style="color:rgb(0,0,255)">JavaRDD&lt;String&gt; lines = sc.parallelize(Arrays.asList(</span><span style="color:rgb(255,0,0)">"hello world"</span><span style="color:rgb(0,0,255)">, </span><span style="color:rgb(255,0,0)">"hi"</span><span style="color:rgb(0,0,255)">));</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">JavaRDD&lt;String&gt; words = lines.flatMap(new FlatMapFunction&lt;String, String&gt;() {<!-- --></span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">    </span><span style="color:rgb(0,0,255)">public Iterable&lt;String&gt; call(String line) {<!-- --></span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">        </span><span style="color:rgb(0,0,255)">return Arrays.asList(line.split(</span><span style="color:rgb(255,0,0)">" "</span><span style="color:rgb(0,0,255)">));</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">    </span><span style="color:rgb(0,0,255)">}</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">});</span><span style="color:rgb(0,0,255)"><br> </span><span style="color:rgb(0,0,255)">words.first(); // returns "hello"</span></p> 
<p>在图<span style="font-family:Times New Roman">3-3</span><span style="font-family:宋体">中我们说明了</span><span style="font-family:Times New Roman">flatMap()</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">map()</span><span style="font-family:宋体">之间的不同。你可以认为</span><span style="font-family:Times New Roman">flatMap()</span><span style="font-family:宋体">是“压扁”了返回给它的迭代器。所以最终得到的不是一个</span><span style="font-family:Times New Roman">list</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">，而是这些</span><span style="font-family:Times New Roman">list</span><span style="font-family:宋体">中的元素的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">。</span></p> 
<p> <img src="https://images2.imgbox.com/a6/15/PhJWlOvW_o.png" alt=""></p> 
<p>图 3-3 flatMap()<span style="font-family:黑体">和</span><span style="font-family:Arial">map()</span><span style="font-family:黑体">之间的区别</span></p> 
<p> </p> 
<p>伪集合操作</p> 
<p>RDD<span style="font-family:宋体">支持许多数学集合操作，比如并集合交集。甚至即使</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">本身不是严格的集合。图</span><span style="font-family:Times New Roman">3-4</span><span style="font-family:宋体">列出了</span><span style="font-family:Times New Roman">4</span><span style="font-family:宋体">个操作。这里的重点是所有这些操作要求被操作的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">是同一个类型。</span></p> 
<p> <img src="https://images2.imgbox.com/b3/1f/AsSbGKZC_o.png" alt=""></p> 
<p>图 3-4 <span style="font-family:黑体">一些简单的集合操作</span></p> 
<p> </p> 
<p>我们的<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中最常丢失的集合属性是唯一性，经常会有重复元素。如果需要元素唯一可以用</span><span style="font-family:Times New Roman">RDD.distinct()</span><span style="font-family:宋体">变换来生成一个新的无重复元素的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">。然而，请注意</span><span style="font-family:Times New Roman">distinct()</span><span style="font-family:宋体">很昂贵，因为它需要所有的数据通过网络进行</span><span style="font-family:Times New Roman">Shuffling</span><span style="font-family:宋体">以确保唯一性。我们将在第四章详细讨论关于</span><span style="font-family:Times New Roman">Shuffling</span><span style="font-family:宋体">以及如何避免它。</span></p> 
<p> </p> 
<p>最简单的集合运算是<span style="font-family:Times New Roman">union(other)</span><span style="font-family:宋体">，它返回一个由两个源的数据一起组成的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">。在有些情况下会有用，比如处理来自多个源的日志文件。和数学意义上的并集不同，如果在输入的多个</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中有重复元素，则</span><span style="font-family:Times New Roman">Spark</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">union()</span><span style="font-family:宋体">的结果也有重复元素（可以通过</span><span style="font-family:Times New Roman">dictinct()</span><span style="font-family:宋体">修复）。</span></p> 
<p> </p> 
<p>Spark<span style="font-family:宋体">也提供了</span><span style="font-family:Times New Roman">intersection(other)</span><span style="font-family:宋体">方法，它返回两个</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中都存在的元素。</span><span style="font-family:Times New Roman">Intersection()</span><span style="font-family:宋体">也会去除所有的重复元素（包括在单个</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中存在的重复元素）。虽然</span><span style="font-family:Times New Roman">union()</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">intersection()</span><span style="font-family:宋体">是相似的概念，但是</span><span style="font-family:Times New Roman">intersection()</span><span style="font-family:宋体">的性能要差得多。因为它需要通过网络</span><span style="font-family:Times New Roman">shuffle</span><span style="font-family:宋体">数据来识别公共元素。</span></p> 
<p> </p> 
<p>有时我们需要根据想法去掉一些数据。<span style="font-family:Times New Roman">subtract(other)</span><span style="font-family:宋体">函数传入一个</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">，返回的是只在第一个</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中存在并且不在第二个</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中存在的值的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">。就像</span><span style="font-family:Times New Roman">intersection()</span><span style="font-family:宋体">一样，也需要</span><span style="font-family:Times New Roman">shuffle</span><span style="font-family:宋体">数据。</span></p> 
<p> </p> 
<p>我们还可以计算两个<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">的笛卡尔积，如图</span><span style="font-family:Times New Roman">3-5</span><span style="font-family:宋体">。</span><span style="font-family:Times New Roman">cartesian(other)</span><span style="font-family:宋体">变换返回</span><span style="font-family:Times New Roman">(a,b)</span><span style="font-family:宋体">的所有可能的组合，其中</span><span style="font-family:Times New Roman">a</span><span style="font-family:宋体">在源</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中，</span><span style="font-family:Times New Roman">b</span><span style="font-family:宋体">在另一个</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中。笛卡儿积在我们考虑所有可能的组合的相似性的时候会有用，比如计算用户对每个机会感兴趣的预期。也可以对</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">自己做笛卡儿积，对于用户相似度类似的任务会有用。然而请注意，笛卡儿积操作对于太大的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">来说非常昂贵。</span></p> 
<p> <img src="https://images2.imgbox.com/69/dc/dBOTDPiK_o.png" alt=""></p> 
<p>图 3-5 <span style="font-family:黑体">计算两个</span><span style="font-family:Arial">RDD</span><span style="font-family:黑体">的笛卡儿积</span></p> 
<p>表<span style="font-family:Times New Roman">3-2</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">3-3</span><span style="font-family:宋体">汇总了常见的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">变换。</span></p> 
<p>表格 3-2 <span style="font-family:黑体">对一个包含</span><span style="font-family:Arial">{1, 2, 3, 3}</span><span style="font-family:黑体">的</span><span style="font-family:Arial">RDD</span><span style="font-family:黑体">进行基本的变换</span></p> 
<table><tbody><tr><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255); color:rgb(255,255,255)">函数名</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255); color:rgb(255,255,255)">目的</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255); color:rgb(255,255,255)">示例</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255); color:rgb(255,255,255)">结果</span></p> </td></tr><tr><td> <p>map()</p> </td><td> <p>应用函数到<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中的每个元素，并返回一个结果</span><span style="font-family:Times New Roman">RDD</span></p> </td><td> <p>rdd.map(</p> <p>  x =&gt; x + 1 )</p> </td><td> <p>{2, 3, 4, 4}</p> </td></tr><tr><td> <p>flatMap()</p> </td><td> <p>应用函数到<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中的每个元素，并返回一个返回的迭代器内容的</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">，通常用于提取单词</span></p> </td><td> <p>rdd.flatMap(</p> <p>  x =&gt; x.to(3) )</p> </td><td> <p>{1, 2, 3, 2, 3, 3, 3}</p> </td></tr><tr><td> <p>filter()</p> </td><td> <p>返回由仅通过传入<span style="font-family:Times New Roman">filter()</span><span style="font-family:宋体">的条件的元素组成的</span><span style="font-family:Times New Roman">RDD</span></p> </td><td> <p>rdd.filter(</p> <p>  x =&gt; x != 1 )</p> </td><td> <p>{2, 3, 3}</p> </td></tr><tr><td> <p>distinct()</p> </td><td> <p>去重</p> </td><td> <p>rdd.distinct()</p> </td><td> <p>{1, 2, 3}</p> </td></tr><tr><td> <p>Sample(withReplacement, fraction, [seed])</p> </td><td> <p>RDD<span style="font-family:宋体">采样数据，可替换</span></p> </td><td> <p>rdd.sample(</p> <p>  false, 0.5)</p> </td><td> <p>Nondeterministic</p> </td></tr></tbody></table> 
<p> </p> 
<p>表格 3-3 <span style="font-family:黑体">对包含</span><span style="font-family:Arial">{1, 2, 3}</span><span style="font-family:黑体">和</span><span style="font-family:Arial">{3, 4, 5}</span><span style="font-family:黑体">的两个</span><span style="font-family:Arial">RDD</span><span style="font-family:黑体">进行变换</span></p> 
<table><tbody><tr><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255); color:rgb(255,255,255)">函数名</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255); color:rgb(255,255,255)">目的</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255); color:rgb(255,255,255)">示例</span></p> </td><td style="background:rgb(0,0,0)"> <p><span style="color:rgb(255,255,255); color:rgb(255,255,255)">结果</span></p> </td></tr><tr><td> <p>union()</p> </td><td> <p>生成一个包含两个<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中所有元素的</span><span style="font-family:Times New Roman">RDD</span></p> </td><td> <p>rdd.union(other )</p> </td><td> <p>{1, 2, 3, 3, 4, 5}</p> </td></tr><tr><td> <p>intersection()</p> </td><td> <p>生成两个<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中都有的元素组成的</span><span style="font-family:Times New Roman">RDD</span></p> </td><td> <p>rdd.intersection(other)</p> </td><td> <p>{3}</p> </td></tr><tr><td> <p>subtract()</p> </td><td> <p>从一个<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中去掉另一个</span><span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">中存在的元素</span><span style="font-family:Times New Roman">(</span><span style="font-family:宋体">比如去掉训练数据</span><span style="font-family:Times New Roman">)</span></p> </td><td> <p>rdd.subtract(other)</p> </td><td> <p>{1, 2}</p> </td></tr><tr><td> <p>cartesian()</p> </td><td> <p>生成两个<span style="font-family:Times New Roman">RDD</span><span style="font-family:宋体">的笛卡尔积的</span><span style="font-family:Times New Roman">RDD</span></p> </td><td> <p>rdd.cartesian(other)</p> </td><td> <p>{(1, 3), (1, 4), ..., (3,5)}</p> </td></tr></tbody></table> 
<p> </p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04730143286964309d6fab8e385a6f48/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">svn中项目进行提交测试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c0f8696301b5f4b78dc6011408b8f9e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Learning Spark 第三章 RDD编程 已翻译整理完毕，PDF可下载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>