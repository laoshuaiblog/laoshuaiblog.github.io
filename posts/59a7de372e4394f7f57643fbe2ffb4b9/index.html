<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Collectors.toMap报错：空指针 &amp; key重复 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/59a7de372e4394f7f57643fbe2ffb4b9/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Collectors.toMap报错：空指针 &amp; key重复">
  <meta property="og:description" content="Java 8中的stream在项目开发中被同学们用的风生水起，当然大家也踩了不少坑。下面我就来说说Collections.toMap在项目使用中踩的坑，避免大家重复被坑。
一.介绍Collectors.toMap Collectors.toMap 是 Java 8 中的一个收集器，它可以将流中的元素转换为 Map 对象，其中每个元素的 key 由指定的函数生成。
当我们使用 Collectors.toMap 方法时，可能会遇到重复的 key 问题，这是因为我们在将元素转化为 Map 对象时，如果两个元素具有相同的 key，则会发生冲突，抛出异常。
还可能会遇到value为null的问题，这是因为我们在将元素转化为 Map 对象时，toMap最终是调用了Map.merge方法，merge方法不允许value为null 导致的异常抛出。
二.问题复现与分析以及解决方案 1、Collectors.toMap的key重复问题 问题复现： public static void main(String[] args) { List&amp;lt;BenefitModel&amp;gt; benefitModelList = new ArrayList&amp;lt;&amp;gt;(); benefitModelList.add(new BenefitModel(&#34;123&#34;, &#34;积分权益&#34;)); benefitModelList.add(new BenefitModel(&#34;123&#34;, &#34;现金权益&#34;)); Map&amp;lt;String, String&amp;gt; benefitMap = benefitModelList.stream().collect(Collectors.toMap(BenefitModel::getBenefitId, BenefitModel::getBenefitName)); System.out.println(JSON.toJSONString(benefitMap)); } 运行结果： 原因分析： 查看Collectors.toMap源码如下，
toMap最终是调用了Map.merge方法，传入的mergeFunction是throwingMerger直接抛出异常，日志信息使用的是第一个参数u。传入的mapSupplier是HashMap对象（HashMap::new）。所以最终会调用到HashMap.merge。
而在HashMap.merge中，对于mergeFunction的应用如下：
在HashMap.merge的语义中，mergeFunction用于合并value，比如对于key的计数，可以使用map.merge(key, 1, Integer::sum)。若不存在则置1，存在则&#43;1。这里的入参是oldValue和newValue。
所以最终传递给throwingMerger的两个参数就不是k-v了。所以报错的所谓Duplicate key其实是oldValue。
解决方案： 保证toMap的key不重复调用重载方法，主动指定当key重复时，需要做的合并操作（合并规则可以根据业务需要，自定义） 于是上面重复key的代码优化后为:(合并规则：重复key出现时，取后面的，前面的丢弃)
public static void main(String[] args) { List&amp;lt;BenefitModel&amp;gt; benefitModelList = new ArrayList&amp;lt;&amp;gt;(); benefitModelList.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-01T15:21:46+08:00">
    <meta property="article:modified_time" content="2023-11-01T15:21:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Collectors.toMap报错：空指针 &amp; key重复</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="ue9812345"></p> 
<p class="img-center"><img alt="" height="824" id="ua015325b" src="https://images2.imgbox.com/ac/f9/8yJ6RgNa_o.png" width="1200"></p> 
<p id="ud1e1b504">Java 8中的stream在项目开发中被同学们用的风生水起，当然大家也踩了不少坑。下面我就来说说Collections.toMap在项目使用中踩的坑，避免大家重复被坑。</p> 
<p id="ub9671e41"></p> 
<hr id="wIE9C"> 
<h3 id="JRAUz">一.介绍Collectors.toMap</h3> 
<p id="u6049fc8e">Collectors.toMap 是 Java 8 中的一个收集器，它可以将流中的元素转换为 Map 对象，其中每个元素的 key 由指定的函数生成。</p> 
<p id="u092351b7">当我们使用 Collectors.toMap 方法时，可能会遇到重复的 key 问题，这是因为我们在将元素转化为 Map 对象时，如果两个元素具有相同的 key，则会发生冲突，抛出异常。</p> 
<p id="u43669f3c">还可能会遇到value为null的问题，这是因为我们在将元素转化为 Map 对象时，toMap最终是调用了Map.merge方法，merge方法不允许value为null 导致的异常抛出。</p> 
<p id="ue99553ed"></p> 
<h3 id="oIoyp">二.问题复现与分析以及解决方案</h3> 
<h4 id="vCAKZ">1、Collectors.toMap的key重复问题</h4> 
<h5 id="vmbwT">问题复现：</h5> 
<pre id="PkpDU"><code>    public static void main(String[] args) {
        List&lt;BenefitModel&gt; benefitModelList = new ArrayList&lt;&gt;();
        benefitModelList.add(new BenefitModel("123", "积分权益"));
        benefitModelList.add(new BenefitModel("123", "现金权益"));
        Map&lt;String, String&gt; benefitMap = benefitModelList.stream().collect(Collectors.toMap(BenefitModel::getBenefitId, BenefitModel::getBenefitName));
        System.out.println(JSON.toJSONString(benefitMap));
    }</code></pre> 
<h5 id="UeAPU">运行结果：</h5> 
<p id="u835a769d"></p> 
<p class="img-center"><img alt="" height="320" id="u356d5b3a" src="https://images2.imgbox.com/46/d9/HdXYoPGu_o.png" width="769"></p> 
<h5 id="ROchI">原因分析：</h5> 
<p id="udf0d62b2">查看Collectors.toMap源码如下，</p> 
<p id="uba0f8836"></p> 
<p class="img-center"><img alt="" height="126" id="ucf54ece3" src="https://images2.imgbox.com/f0/7c/KH6znd89_o.png" width="720"></p> 
<p id="u3f881ce9"></p> 
<p class="img-center"><img alt="" height="246" id="u8df2e8f1" src="https://images2.imgbox.com/78/8f/jT3koiRq_o.png" width="877"></p> 
<p id="u93075fe3">toMap最终是调用了Map.merge方法，传入的mergeFunction是throwingMerger直接抛出异常，日志信息使用的是第一个参数u。传入的mapSupplier是HashMap对象（HashMap::new）。所以最终会调用到HashMap.merge。</p> 
<p id="u58ea8b46">而在HashMap.merge中，对于mergeFunction的应用如下：</p> 
<p id="u9c2b6217"></p> 
<p class="img-center"><img alt="" height="351" id="ua4d759e3" src="https://images2.imgbox.com/a9/50/B2VwnrCX_o.png" width="715"></p> 
<p id="u060c9638">在HashMap.merge的语义中，mergeFunction用于合并value，比如对于key的计数，可以使用map.merge(key, 1, Integer::sum)。若不存在则置1，存在则+1。这里的入参是oldValue和newValue。</p> 
<p id="u71a9e87d">所以最终传递给throwingMerger的两个参数就不是k-v了。所以报错的所谓Duplicate key其实是oldValue。</p> 
<h5 id="AMZiS">解决方案：</h5> 
<ul><li id="u53cdfaee">保证toMap的key不重复</li><li id="u625f45af">调用重载方法，主动指定当key重复时，需要做的合并操作（合并规则可以根据业务需要，自定义）</li></ul> 
<p id="u0f74e04f"></p> 
<p class="img-center"><img alt="" height="147" id="u759af093" src="https://images2.imgbox.com/cf/f4/2ZUyoyfM_o.png" width="773"></p> 
<p id="ua5af6948"><strong>于是上面重复key的代码优化后为:(</strong>合并规则：重复key出现时，取后面的，前面的丢弃<strong>)</strong></p> 
<pre id="DdQdF"><code>    public static void main(String[] args) {
        List&lt;BenefitModel&gt; benefitModelList = new ArrayList&lt;&gt;();
        benefitModelList.add(new BenefitModel("123", "积分权益"));
        benefitModelList.add(new BenefitModel("123", "现金权益"));
        Map&lt;String, String&gt; map = benefitModelList.stream()
                .collect(Collectors.toMap(BenefitModel::getBenefitId, BenefitModel::getBenefitName,
                                          (k1, k2) -&gt; k2));
        System.out.println(JSON.toJSONString(map));
    }</code></pre> 
<h5 id="ZJ6Cl">高版本JDK的修复措施：</h5> 
<p id="ua24f47f2">重复key这个问题在后续版本中得到修复，比如在JDK 11中的处理。</p> 
<p id="uad5daf41"></p> 
<p class="img-center"><img alt="" height="409" id="uad933aea" src="https://images2.imgbox.com/3f/f6/8WKhkvth_o.png" width="1086"></p> 
<p id="uc3e9b595"></p> 
<p class="img-center"><img alt="" height="726" id="ub0c6e3f2" src="https://images2.imgbox.com/a8/86/VmendL9w_o.png" width="1200"></p> 
<p id="u4af4332c"></p> 
<h4 id="l0RZx">2、Collectors.toMap的value值为null问题</h4> 
<h5 id="u7OWk">问题复现：</h5> 
<pre id="ZfV6H"><code>    public static void main(String[] args) {
        List&lt;BenefitModel&gt; benefitModelList = new ArrayList&lt;&gt;();
        benefitModelList.add(new BenefitModel("123", "积分权益"));
        benefitModelList.add(new BenefitModel("124", null));
        Map&lt;String, String&gt; benefitMap = benefitModelList.stream().
        collect(Collectors.toMap(BenefitModel::getBenefitId, BenefitModel::getBenefitName));
        System.out.println(JSON.toJSONString(benefitMap));
    }</code></pre> 
<h5 id="A8h9l">运行结果：</h5> 
<p id="uc35cbc46"></p> 
<p class="img-center"><img alt="" height="298" id="uf4277a94" src="https://images2.imgbox.com/fb/21/RZXDp5vj_o.png" width="731"></p> 
<h5 id="I5hlv">原因分析：</h5> 
<p id="u0eeae942">有问题，看源码，查看Collectors.toMap源码如下，</p> 
<p id="udfd3e72b"></p> 
<p class="img-center"><img alt="" height="126" id="luddM" src="https://images2.imgbox.com/54/d2/8u9lLHUY_o.png" width="720"></p> 
<p id="u01e40194"></p> 
<p class="img-center"><img alt="" height="246" id="Uky7m" src="https://images2.imgbox.com/2c/e9/WAc4IrVd_o.png" width="877"></p> 
<p id="u6ed149aa">toMap最终是调用了Map.merge方法，而在HashMap.merge中，对于value的应用如下：</p> 
<p id="u731132eb"></p> 
<p class="img-center"><img alt="" height="440" id="u8d635802" src="https://images2.imgbox.com/0c/5e/7XVoklZJ_o.png" width="927"></p> 
<p id="u571e44c1"></p> 
<p class="img-center"><img alt="" height="159" id="ue5a03c34" src="https://images2.imgbox.com/4b/f7/38m1PQ40_o.png" width="953"></p> 
<p id="u21ec0f87">在HashMap.merge的语义中，value使用前需要进行判空处理，null直接抛出异常NullPointerException。</p> 
<h5 id="dQcMj">解决方案：</h5> 
<p id="uda255183">方案1：先把value为null的数据过滤掉，再用Collectors.toMap。</p> 
<pre id="hcfg6"><code>        Map&lt;String, String&gt; map2 = benefitModelList.stream()
                .filter(m -&gt; m.getBenefitName() != null)
                .collect(Collectors.toMap(BenefitModel::getBenefitId, BenefitModel::getBenefitName));</code></pre> 
<p id="u9f7830cd">方案2：查资料评价度最好的方案如下。其实跟你方案1中思路-手动foreach一毛一样。</p> 
<pre id="MScdM"><code>        Map&lt;String, String&gt; map2 = benefitModelList.stream().collect(HashMap::new, 
                (m, v) -&gt; m.put(v.getBenefitId(), v.getBenefitName()),
                HashMap::putAll);</code></pre> 
<h5 id="qClvg">高版本JDK的修复措施：</h5> 
<p id="u9ef6259a">Collectors.toMap使用时，value值为null，这个问题在Java 11中仍然存在。可能value为null，这种数据很少见，促使解决过程比较缓慢。</p> 
<h3 id="Y2NBH">三、Collectors.toMap使用总结</h3> 
<p id="u539b3ffc">综上所以，在使用Collectors.toMap时需要记住几点：</p> 
<p id="u32ebf3af">1、key不能有重复，否则会报错IllegalStateException: Duplicate key，因为Map的key不能重复。</p> 
<p id="u9ed535e6">2、value不能为空，否则报错NullPointerException。</p> 
<p id="udda668b4">看完了本文，你可以去搜搜你的项目代码中使用Collectors.toMap的地方，有没有可能踩上面的坑。不要说你的业务数据不会出现重复key的数据，不会出现value值null的情况，上百万的业务数据，什么情况都会有的。</p> 
<p id="ue9218d98"></p> 
<p id="u00f49465"></p> 
<p id="u11ffdb13">参考资料：<a href="https://stackoverflow.com/questions/32312876/ignore-duplicates-when-producing-map-using-streams" rel="nofollow" title="java - Ignore duplicates when producing map using streams - Stack Overflow">java - Ignore duplicates when producing map using streams - Stack Overflow</a></p> 
<p id="u0549ec3c"><a href="https://stackoverflow.com/questions/24630963/nullpointerexception-in-collectors-tomap-with-null-entry-values" rel="nofollow" title="java - NullPointerException in Collectors.toMap with null entry values - Stack Overflow">java - NullPointerException in Collectors.toMap with null entry values - Stack Overflow</a></p> 
<p id="uf8dbb6d6"></p> 
<p id="u9f9c8a54"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/139849244c7c67ac24aefd7c4050e818/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">我的新作品《码农宝》App上线了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7799361dd3d1df90298d422d2ff93101/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">浅谈ClickHouse聚合和窗口函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>