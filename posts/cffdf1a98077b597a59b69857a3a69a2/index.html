<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【零基础C语言】指针解析3 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/cffdf1a98077b597a59b69857a3a69a2/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【零基础C语言】指针解析3">
  <meta property="og:description" content="17.字符指针变量 在指针类型中我们通常使用char*
代码展示
int main() { char ch = &#39;w&#39;; char* p = &amp;amp;ch; *p = &#39;s&#39;; printf(&#34;%c&#34;, ch); return 0; } int main() { char ch[] = &#34;hello ouquyang!&#34;; char* pch = &amp;amp;ch; printf(&#34;%s&#34;, pch); return 0; } 上述代码中，并不是将字符串放入指针中，而是将字符或字符串首字符的
地址存放在指针中，在使用时顺藤摸瓜就可以打印出后面内容了
如剑指offer上的一题
int main() { char str1[] = &#34;hello bit.&#34;; char str2[] = &#34;hello bit.&#34;; const char* str3 = &#34;hello bit.&#34;; const char* str4 = &#34;hello bit.&#34;; if (str1 == str2) printf(&#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-09T20:01:25+08:00">
    <meta property="article:modified_time" content="2024-03-09T20:01:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【零基础C语言】指针解析3</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>17.字符指针变量</h2> 
<p><br> 在指针类型中我们通常使用char*</p> 
<p>代码展示</p> 
<pre><code class="language-cpp">int main()
{
	char ch = 'w';
	char* p = &amp;ch;
	*p = 's';
	printf("%c", ch);
	return 0;
}

int main()
{
	char ch[] = "hello ouquyang!";
	char* pch = &amp;ch;
	printf("%s", pch);
	return 0;
}</code></pre> 
<p>上述代码中，并不是将字符串放入指针中，而是将字符或字符串首字符的<br> 地址存放在指针中，在使用时顺藤摸瓜就可以打印出后面内容了</p> 
<p>如剑指offer上的一题</p> 
<pre><code class="language-cpp">int main()
{
	char str1[] = "hello bit.";
	char str2[] = "hello bit.";
	const char* str3 = "hello bit.";
	const char* str4 = "hello bit.";
	if (str1 == str2)
		printf("str1 and str2 are same\n");
	else
		printf("str1 and str2 are not same\n");
	if (str3 == str4)
		printf("str3 and str4 are same\n");
	else
		printf("str3 and str4 are not same\n");
	return 0;
}</code></pre> 
<p>字符数组str1和str2都是独立开创的两个空间，所以指向的对象是不一样的<br> 而字符指针str3和str4指向的是同一块空间，同一个地址，所以是相同的。</p> 
<h2>18.数组指针变量</h2> 
<p>之前我们知道指针数组是用来存放指针的数组，数组中存放的是地址（指针）<br> 那么数组指针变量是指针变量</p> 
<p><br> 整型指针变量：int* pint ;存放的是整形变量的地址，<br>  能够指向整形数据的指针</p> 
<p><br> 浮点型指针变量：float* pf;存放浮点型变量的地址，<br>  能够指向浮点型数据的指针</p> 
<p>判断一下</p> 
<pre><code class="language-cpp">int* p1[5];//指针数组 - 用来存放指针的数组</code></pre> 
<pre><code class="language-cpp">int(*p2)[5];//数组指针 - 用来指向数组地址的指针</code></pre> 
<pre><code class="language-cpp">int (*p)[10];</code></pre> 
<p><br> 解析：p先与*结合，说明p是一个指针变量，然后指向的是一个大小为10<br> 整型的数组，所以p是指针，指向一个数组，称作数组指针</p> 
<h2>19.数组指针如何初始化</h2> 
<p>int arr[10] = { 0 };<br> &amp;arr;//得到整个数组的地址</p> 
<pre><code class="language-cpp">int main()
{
	int arr[10] = { 0 };
	int(*p)[10] = &amp;arr;
	return 0;
}</code></pre> 
<p>数组指针类型解析：<br> int - p指向的数组元素类型<br> *p - 说明p是数组指针的变量名<br> [10] - p指向数组的元素个数</p> 
<h2>20.二维数组传参的本质</h2> 
<pre><code class="language-cpp">void text(int arr[3][3], int r, int c)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; r; i++)
	{
		
		for (j = 0; j &lt; c; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}

void text2(int(*p)[3], int r, int c)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; r; i++)
	{
		for (j = 0; j &lt; c; j++)
		{
			printf("%d ", *(*(p + i) + j));
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][3] = { {1,2,3},{4,5,6},{7,8,9} };
	text(arr, 3, 3);
	printf("\n");
	text2(arr, 3, 3);
	return 0;
}</code></pre> 
<h2>21.函数指针变量</h2> 
<p>函数存在地址</p> 
<pre><code class="language-cpp">void text()
{
	printf("hehe\n");
}
int main()
{
	printf("text  = %p\n", text);
	printf("&amp;text = %p\n", &amp;text);

	return 0;
}


void test()
{
	printf("hehe\n");
}
void (*pf1)() = &amp;test;
void (*pf2)() = test;
int add(int x, int y)
{
	return x + y;
}</code></pre> 
<pre><code class="language-cpp">int(*pf3)(int, int) = Add;
int(*pf3)(int x, int y) = &amp;Add;//x和y写上或者省略都是可以的
</code></pre> 
<p>void (*p)(int, int)<br> void - p指向函数的返回类型<br> *p - 函数指针变量名<br> (int, int)p指向函数参数类型和个数<br> 函数指针变量的使用<br> 通过函数指针调用指针指向的函数</p> 
<pre><code class="language-cpp">int add(int x, int y)
{
	return x + y;
}

int main()
{
	int(*p)(int, int) = add;

	printf("%d\n", (*p)(2, 3));

	printf("%d\n", p(2, 5));

	return;
}</code></pre> 
<p>22.typedef 关键字</p> 
<p> typedef 关键字可以更改复杂的名称</p> 
<p>举例：<br> /*typedef unsigned int uint*/</p> 
<p><br> 对于指针的重命名<br> 举例：<br> /*typedef int* ptr_t*/</p> 
<p>对于数组指针的重命名<br> 举例：<br> int(*)[5];<br> /*typedef int (*parr_t)[5]*/</p> 
<p>对于函数指针重命名也是一样的<br> 举例：<br> void(*)(int);<br> /*typedef void(*pfun_t)(int)*/</p> 
<p><br> 知道上面的命名方法以后，我们可以试着简化以下代码</p> 
<p>代码1</p> 
<pre><code class="language-cpp">  (*(void (*)())0)();
typedef void (*pfun_t)(int);</code></pre> 
<p>代码2</p> 
<pre><code class="language-cpp">void (*signal(int, void(*)(int)))(int);
typedef void (*pfun_t)(int);
pfun_t signal(int, pfun_t);</code></pre> 
<p>23.函数指针数组</p> 
<p>指针数组<br> 如：<br>  int* arr[10];<br> 每个元素的类型是int*</p> 
<p><br> 函数指针数组的定义<br>  int (*parr1[3])();<br> parr1先与[]结合，说明parr1是数组，<br>  数组的内容是int(*)()类型的函数指针</p> 
<h2>24.转移表</h2> 
<p><br> 计算器的实现</p> 
<pre><code class="language-cpp">int add(int x, int y)//加法
{
	return x + y;
}

int sub(int x, int y)//减法
{
	return x - y;
}

int mul(int x, int y)//乘法
{
	return x * y;
}

int diu(int x, int y)//除法
{
	return x / y;
}

int main()
{
	int (*parr1[5])(int) = { 0, add,sub,mul,diu };
	int x = 0;
	int y = 0;
	int input = 1;
	int ret = 0;
	do 
	{
			printf("**************************\n");
			printf("*****1.add     2.sub******\n");
			printf("*****3.mul     4.diu******\n");
			printf("*********0. exit**********\n");
			printf("**************************\n");
			printf("请选择： ");
			scanf("%d", &amp;input);
		if (input &gt;= 1 &amp;&amp; input &lt;= 4)
		{
			printf("请输入你要计算的数字： ");
			scanf("%d %d", &amp;x, &amp;y);
			ret = (*parr1[input])(x, y);
			printf("ret = %d\n", ret);
		}
		else if (input == 0)
		{
			printf("退出游戏！");
		}
		else
		{
			printf("输入错误，请重新输入！");
		}
		
	} while (input);
	
	return 0;

}</code></pre> 
<h2>24.回调函数 - 计算器</h2> 
<pre><code class="language-cpp">int add(int x, int y)//加法
{
	return x + y;
}

int sub(int x, int y)//减法
{
	return x - y;
}

int mul(int x, int y)//乘法
{
	return x * y;
}

int div(int x, int y)//除法
{
	return x / y;
}

void meun(void)//菜单选择
{
	printf("**************************\n");
	printf("*****1.add     2.sub******\n");
	printf("*****3.mul     4.div******\n");
	printf("*********0. exit**********\n");
	printf("**************************\n");
	printf("请选择： ");

}

void calc(int(*pf)(int, int))
{
	int x = 0;
	int y = 0;
	int ret = 0;
	printf("请输入操作数： ");
	scanf("%d %d", &amp;x, &amp;y);
	ret = pf(x, y);
	printf("ret = %d\n", ret);
}

int main()
{
	int input = 1;
	do
	{
		meun();
		scanf("%d", &amp;input);
		switch (input)
		{
		case 1:
			calc(add);
			break;
		case 2:
			calc(sub);
			break; 
		case 3:
			calc(mul);
			break;
		case 4:
			calc(div);
			break;
		case 0:
			printf("退出程序");
			break;
		default:
			printf("选择错误");
			break;
		}
	} while (input);
	return 0;
}</code></pre> 
<p>25.qsort函数的使用和模拟实现</p> 
<p>qsort函数的使用</p> 
<p>原型<br> void qsort(void* base, //指针，指向的是待排序数组的第一个元素<br>             size_t num, //是base指向的待排序数组的元素个数<br>             size_r size， //base指向的待排序数组的元素大小<br>             int(*compar)(const void*, const void*)//函数指针 - 指向的就是两个元素的比较函数<br>             );</p> 
<p> void* 类型的指针是无具体类型的指针，不可以解引用，也不能进行+-整数的运算</p> 
<p><br> qsort函数的使用者需要实现一个比较函数</p> 
<pre><code class="language-cpp">int int_cmp(const void* p1, const void* p2)
{
	return (*(int*)p1 - *(int*)p2);
}

int main()
{
	int arr[] = { 1,3,5,7,9,2,4,6,8,0 };
	int i = 0;
	qsort(arr, sizeof(arr) / sizeof(arr[0]), sizeof(int), int_cmp);
	for (i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
	return 0;
}</code></pre> 
<h2>25.1使用qsort函数排序结构数据</h2> 
<pre><code class="language-cpp">struct Stu //学生
{
	char name[20];//名字
	int age;//年龄
};

//假设拿年龄来比较
int int_cmp_age(const void* s1, const void* s2)
{
	return ((struct Stu*)s1)-&gt;age - ((struct Stu*)s2)-&gt;age;
}


int int_cmp_name(const void* s1, const void* s2)
{
	return (((struct Stu*)s1)-&gt;name - ((struct Stu*)s2)-&gt;name);
}

void text1()
{
	struct Stu s[] = { {"zhangsan",20},{"lisi",18},{"wangsan",28} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), int_cmp_age);
}

void text2()
{
	struct Stu s[] = { {"zhangsan",20},{"lisi",18},{"wangsan",28} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), int_cmp_name);
}

int main()
{
	text1();
	text2();
	return 0;
}</code></pre> 
<p>qsort函数的模拟实现<br> 使⽤回调函数，模拟实现qsort（采⽤冒泡的⽅式）。<br> 注意：这⾥第⼀次使⽤ void* 的指针，讲解 void* 的作⽤。</p> 
<pre><code class="language-cpp">int int_cmp(const void* p1, const void* p2)
{
	return (*(int*)p1 - *(int*)p2);
}
void _swap(void* p1, void* p2, int size)
{
	int i = 0;
	for (i = 0; i &lt; size; i++)
	{
		char tmp = *((char*)p1 + i);
		*((char*)p1 + i) = *((char*)p2 + i);
		*((char*)p2 + i) = tmp;
	}
}
void bubble(void* base, int count, int size, int(*cmp)(void*, void*))
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; count - 1; i++)
	{
		for (j = 0; j &lt; count - i - 1; j++)
		{
			if (cmp((char*)base + j * size, (char*)base + (j + 1) * size) &gt; 0)
			{
				_swap((char*)base + j * size, (char*)base + (j + 1) * size, size);
			}
		}
	}
}
int main()
{
	int arr[] = { 1, 3, 5, 7, 9, 2, 4, 6, 8, 0 };
	int i = 0;
	bubble(arr, sizeof(arr) / sizeof(arr[0]), sizeof(int), int_cmp);
	for (i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71a18e33f7d6e4eac4a764680e7e143b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构初阶】单链表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44a6856ae7d47d4f915d4d1d2fe50c7b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【WEEK2】 【DAY1】第一个MVC程序之使用注解【中文版】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>