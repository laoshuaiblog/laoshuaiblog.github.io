<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux之查看进程ps -ef、进程的前后台切换fg、挂起后的激活bg、标准输入/输出/错误三者的重定向、管道 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/68d38ba81577d1589d1820949cbac301/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Linux之查看进程ps -ef、进程的前后台切换fg、挂起后的激活bg、标准输入/输出/错误三者的重定向、管道">
  <meta property="og:description" content="注意：
全称含义举例fgforeground前景、前台foreground process 前台进程bgbackground背景、后台background process 后台进程 fg、bg后面跟的都是后台进程的序号，不是PID进程号
fg 后台进程的序号——后台进程拉到前台 、将后台的进程调(读法：四声)到前台——也就是说，改变的只是进程所处的环境，即：从后台变成前台 bg 后台进程的序号——把后台挂起（即：Stopped、暂停）的进程，变成在后台继续执行、激活被挂起的进程、把后台Stopped状态的进程变成Running状态——也就是说，bg命令只是用来改变进程的状态，而进程所处的环境依然是在后台。 当然，也可以使用fg把它放到前台。
jobs——查看后台进程的状态
后台进程的几种状态:Stopped（挂起）、Running（运行中）、Killed（杀死）、Done（完成）
ctrl&#43;c——强制中断程序的执行，强制中断任务，即：程序会退出
ctrl&#43;z——中断程序的执行，但不会退出，而是在后台被挂起，即：不会退出，而是处于stopped状态。
一、查看进程 ps ——查看当前用户，当前这一个终端上的进程，即：在哪个终端上敲ps，就只能看见那一个终端上的进程。
ps -ef——查看系统上所有的进程
其中，-e——显示所有进程；-f——全格式，所有的格式，即：显示全部的列(字段)
参数说明：
[root@localhost~]#ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 18:00 ? 00:00:01 /sbin/init root 2 0 0 18:00 ? 00:00:00 [kthreadd] root 3 0 2 18:00 ? 00:00:00 [migration/0] UID——启动该进程的用户，即：谁启动了这个进程。
PID——进程号，进程的一个代号，是根据每个进程在系统中启动的时间顺序，系统自动编排的。
PPID——父进程的进程号
C——CPU的使用率，形式是百分数（%）
STIME——进程启动时的系统时间
TTY——进程启动时的终端设备，如果显示？表示该进程不是由终端发起
TIME——进程的执行时间
CMD——进程的名称或对应的路径或命令
常见的组合命令：
ps -ef | grep 进程名称">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-11-12T10:39:59+08:00">
    <meta property="article:modified_time" content="2022-11-12T10:39:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux之查看进程ps -ef、进程的前后台切换fg、挂起后的激活bg、标准输入/输出/错误三者的重定向、管道</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>注意：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th></th><th>全称</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>fg</td><td><span style="color:#0d0016;">foreground</span></td><td><span style="color:#0d0016;">前景、前台</span></td><td><span style="color:#0d0016;">foreground process 前台进程</span></td></tr><tr><td>bg</td><td><span style="color:#0d0016;">background</span></td><td><span style="color:#0d0016;">背景、后台</span></td><td><span style="color:#0d0016;">background process 后台进程</span></td></tr></tbody></table> 
<p>fg、bg后面跟的都是后台进程的序号，不是PID进程号</p> 
<p><strong>fg 后台进程的序号</strong>——<span style="background-color:#ffd900;">后台进程拉到前台</span> 、将后台的进程调(读法：四声)到前台——<strong><span style="background-color:#ffd900;">也就是说，改变的只是进程所处的环境，即：从后台变成前台 </span></strong></p> 
<p></p> 
<p><strong>bg 后台进程的序号</strong>——<span style="background-color:#ffd900;">把后台挂起（即：Stopped、暂停）的进程，变成在后台继续执行</span>、激活被挂起的进程、把后台Stopped状态的进程变成Running状态——<u><strong><span style="background-color:#ffd900;">也就是说，bg命令只是用来改变进程的状态，而进程所处的环境依然是在后台</span></strong><span style="background-color:#ffd900;">。</span>   </u>当然，也可以使用fg把它放到前台。</p> 
<p><strong>jobs</strong>——查看后台进程的状态</p> 
<p><strong>后台进程的几种状态:Stopped</strong>（挂起）、<strong>Running</strong>（运行中）、<strong>Killed</strong>（杀死）、<strong>Done</strong>（完成）</p> 
<p><strong>ctrl+c</strong>——强制中断程序的执行，强制中断任务，即：程序会退出</p> 
<p><strong>ctrl+z</strong>——中断程序的执行，但不会退出，而是在后台被挂起，即：不会退出，而是处于stopped状态。</p> 
<h3><span style="color:#a2e043;">一、查看进程</span></h3> 
<p><strong>ps </strong>——查看当前用户，当前这一个终端上的进程，即：<span style="background-color:#ffd900;">在哪个终端上敲ps，就只能看见那一个终端上的进程。</span></p> 
<p><strong>ps -ef</strong>——<strong><span style="background-color:#ffd900;">查看系统上所有的进程</span></strong></p> 
<p>其中，<strong>-e</strong>——显示所有进程；<strong>-f</strong>——全格式，所有的格式，即：显示全部的列(字段)</p> 
<p>参数说明：</p> 
<pre><code class="language-bash">[root@localhost~]#ps -ef
UID        PID    PPID   C    STIME    TTY        TIME    CMD
root         1       0   0    18:00    ?      00:00:01    /sbin/init
root         2       0   0    18:00    ?      00:00:00    [kthreadd]
root         3       0   2    18:00    ?      00:00:00    [migration/0]</code></pre> 
<p><strong>UID</strong>——启动该进程的用户，即：谁启动了这个进程。</p> 
<p><strong>PID</strong>——进程号，进程的一个代号，是根据每个进程在系统中启动的时间顺序，系统自动编排的。</p> 
<p><strong>PPID</strong>——父进程的进程号</p> 
<p><strong>C</strong>——CPU的使用率，形式是百分数（%）</p> 
<p><strong>STIME</strong>——进程启动时的系统时间</p> 
<p><strong>TTY</strong>——进程启动时的终端设备，如果显示？表示该进程不是由终端发起</p> 
<p><strong>TIME</strong>——进程的执行时间</p> 
<p><strong>CMD</strong>——进程的名称或对应的路径或命令</p> 
<p><strong>常见的组合命令：</strong></p> 
<p>ps -ef | grep 进程名称</p> 
<p>ps -ef | grep 要查找的内容</p> 
<h2><span style="color:#a2e043;">二、进程的前后台运行、切换</span></h2> 
<h3><span style="color:#a2e043;">1、含义</span></h3> 
<p>        首先，要先搞清楚什么是前台进程什么是后台进程，所谓<strong><span style="background-color:#ffd900;">前台进程</span></strong>就是能<strong><span style="background-color:#ffd900;">看得见程序执行界面的进程</span></strong>，<strong><span style="background-color:#ffd900;">后台进程</span></strong>就是看不见程序执行界面的进程。一般来说，后台进程都是为了给前台进程提供服务的。但也有可能是，<span style="background-color:#ffd900;">有些命令执行的时间较长，如果一直在前台运行会占用屏幕资源</span>，不方便其它工作的展开，<span style="background-color:#ffd900;">这时候就比较适合把它放到后台去执行</span>，比如，大文件的备份。</p> 
<h3><span style="color:#a2e043;">2、二者区别</span></h3> 
<p><strong>视觉上：</strong>前台进程，人眼在屏幕上能直接看得到。后台进程，因为是在后台运行，所以我们无法在屏幕上看到。</p> 
<p><strong>命令上：</strong>前台进程执行时候，就按照平常的命令执行即可，而<span style="background-color:#ffd900;">后台进程，需要在末尾加&amp;</span>符号。</p> 
<p><strong>例如：执行一个a.sh文件</strong></p> 
<p>前台命令：./a.sh</p> 
<p>后台命令：<strong><span style="background-color:#fbd4d0;">./a.sh&amp;</span></strong></p> 
<h3><span style="color:#a2e043;">3、前后台进程的切换——fg </span></h3> 
<p><strong><span style="background-color:#ffd900;">（1）前切后</span></strong>：即：前台进程切换成后台进程。</p> 
<p><strong><span style="background-color:#ffd900;">做法</span>：</strong>按照正常的前台执行命令，末尾加&amp;即可。</p> 
<p><strong><span style="background-color:#fbd4d0;">（2）后切前</span>：</strong>即：后台进程切换成前台进程。  <span style="color:#ffd900;"> <strong>——fg</strong></span></p> 
<p><strong><span style="background-color:#ffd900;">做法：</span></strong></p> 
<p>第一步：首先，作为后台进程，都会有一个序号，这个序号是根据后台进程个数的增加而逐个排下来的。比如，我现在将<strong>./a.sh&amp;</strong>作为第一个后台进程，那么它的<strong>序号就是1，</strong>再将<strong>./b.sh&amp;</strong>作为后台进程，那么它的序号就是<strong>2</strong>，后面以此类推。当然，如果忘记了这个后台进程的序号，也可以通过<strong><span style="background-color:#ffd900;">jobs</span></strong>进行查看，将会<strong><span style="background-color:#ffd900;">列出所有的后台进程</span></strong>。</p> 
<p>第二步：终端上输入  <strong><span style="background-color:#fbd4d0;">fg 后台进程序号</span></strong>  即可。</p> 
<p></p> 
<h3><span style="color:#a2e043;"><strong>4、常见问题</strong></span></h3> 
<p><strong><span style="background-color:#ffd900;">1、前台进程如何被挂起？</span> <span style="background-color:#fbd4d0;"> 挂起的进程如何重新激活？</span>    <span style="background-color:#fefcd8;">激活后如何拉回前台？</span></strong></p> 
<p>思路：先要明确一点：提到挂起就是放到了后台；挂起后再激活就是说改变了状态；拉回前台那就是前后台的转化。</p> 
<p>解答：</p> 
<p>        首先，挂起可以理解为暂停，<strong>jobs中显示的状态是Stopped</strong>。<strong><span style="background-color:#fbd4d0;">先在前台上正常执行该文件，然后立马按ctrl+z</span></strong>，此时，该前台进程就被挂起到后台了（因为ctrl+z的作用就是将一个正在前台运行的任务放到后台暂停起来，即：挂起进程）。</p> 
<p>        至于挂起后怎么重新激活，先要搞清楚什么是激活？所谓激活就是说<strong><u><span style="background-color:#fbd4d0;">把原来Stopped状态的进程，变成Running状态</span></u>。</strong>即：从暂停状态变为运行状态。直接终端上输入<strong><span style="background-color:#fbd4d0;">bg 后台进程的序号</span></strong> 回车 即可。然后通过jobs可以看到该后台进程的状态已经改成Running了。</p> 
<p>        最后怎么拉回前台，就是直接使用<strong><span style="background-color:#fefcd8;">fg 进程后台序号 回车</span></strong>即可。</p> 
<p>小结：具体过程：以执行a.sh文件为例进行说明。</p> 
<pre><code class="language-bash">[root@localhost~]#./a.sh   # 前台进程 ctrl+z——进程被挂起到后台
^Z
[1]+   Stopped          ./a.sh

[root@localhost~]#jobs
[1]+   Stopped          ./a.sh

[root@localhost~]#bg 1    # bg 进程序号————激活1号后台进程
[1]+  ./a.sh &amp;

[root@localhost~]#jobs    # 变成Running则激活成功，开始在后台运行
[1]+   Running          ./a.sh &amp;  

[root@localhost~]#fg 1   #拉回前台
./a.sh 

</code></pre> 
<p><strong><span style="background-color:#ffd900;">2、任务放在后台执行，但被挂起，如何拉到前台？</span></strong></p> 
<p><strong>思路：大致和问题1一样，问题1是先将任务在前台执行，然后按ctrl+z强制挂到后台，而这里是直接把任务放到后台执行，但后台执行不了，所以才被挂起。</strong></p> 
<p><strong>但总的来说，最终的结果都是一样的，进程都在后台被挂起，即：用jobs查看，都是Stopped状态。</strong></p> 
<p>解答：</p> 
<p>        首先，先<strong>要知道什么是任务在后台执行？</strong>就是把一个正常执行的命令末尾加&amp;，此时它就变成了一个后台进程，然后用jobs查看状态是否是<strong>Stopped</strong>，如果是，则说明，它是一个后台被挂起的进程。</p> 
<p>        其次，确定了后台进程哪个被挂起了，现在<strong>怎么把它拉回前台</strong>。很简单，<strong><span style="background-color:#ffd900;">fg 序号  回车</span></strong>  即可。</p> 
<p>下面以一个实例进行说明。</p> 
<p>        比如，利用<strong>touch d.sh</strong>新建一个d.sh文件，然后<strong>vi d.sh</strong>让它作为前台进程进行编辑。里面输入，<strong>hello word</strong>，然后<strong>:wq</strong>退出。这个过程就是一个前台进程的正确执行过程。</p> 
<p>        而现在，我们想要把打开d.sh并进行编辑的这个过程，放到后台，让这个动作变成一个后台进程来完成，怎么做？很简单，就是在终端上输入<span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">vi d.sh&amp; </span>  即可。此时，</strong></span>回车之后就会输出一行两列数字。</p> 
<pre><code class="language-bash">[root@localhost~]#vi d.sh&amp;
[1]  2335

</code></pre> 
<p><strong>[1]</strong>——后台进程的序号。即：它是<strong>第几个后台进程</strong>。也就是使用fg bg命令时候后面所跟的内容。</p> 
<p><strong>2335</strong>——<strong>进程号，即 PID</strong>。</p> 
<p>现在用<strong>jobs</strong>进行查看，发现成了Stopped，<strong><span style="background-color:#ffd900;">为什么会变成Stopped</span></strong>？因为，vi命令本身就是用来编辑文件内容的，也就意味着需要界面，需要人机交互的一个界面，通过这个界面我才可以往这个文件里面写东西；也就意味着它是个前台进程；但是你却要给它加个&amp;，让它变成后台进程，显然在后台它是没办法运行的，所以最终只能被挂起。此时怎么拉到前台进行激活？</p> 
<pre><code class="language-bash">[root@localhost~]#jobs  
[1]+  Stopped    vi d.sh </code></pre> 
<p>fg 序号回车即可，即：<strong><span style="background-color:#ffd900;">fg 1</span></strong> 这样就能拉到前台了。此时，就会呈现出之前用vi d.sh一样的效果了。再次jobs，就可以看到后台没进程了。</p> 
<pre><code class="language-bash">[root@localhost~]#jobs  
[root@localhost~]#</code></pre> 
<p><strong><span style="background-color:#ffd900;">3、终止进程的两种方法</span></strong></p> 
<p><strong>自动终止：</strong>（1）任务执行完了，进程自动终止。（2）关闭终端窗口。（3）执行过程中遇到异常或者bug，导致进程终止。</p> 
<p><strong>手动终止：</strong>（1）ctrl+C  （2）kill -9 PID</p> 
<h2><span style="color:#a2e043;"><strong>三、重定向</strong></span></h2> 
<p style="margin-left:.0001pt;text-align:left;">顾名思义就是重新定义一个方向。比如，对于一个程序的输出，如果不想把它输到终端上去，就可以利用重定向把它输到（保存到）一个文件上去。</p> 
<p style="margin-left:.0001pt;text-align:left;">用<strong><span style="background-color:#ffd900;"> &gt; 表示重定向</span></strong>，其中，<strong>一个&gt;是覆盖</strong>的意思，即：下一行覆盖上一行。<strong>两个&gt;&gt;是末尾追加</strong>，而不是覆盖。</p> 
<p style="margin-left:.0001pt;text-align:left;">        在Linux系统中可以进行三个方面的重定向，分别是：对标准输出的重定向、对标准错误的重定向、对标准输入的重定向。对于这三者，重定向时候有各自的代号，<strong>0代表输入，1表示输出，2表示错误。</strong></p> 
<h3 style="margin-left:.0001pt;text-align:left;"><span style="color:#a2e043;">1、标准输出的重定向</span></h3> 
<p style="margin-left:.0001pt;text-align:left;">所谓<strong><span style="background-color:#ffd900;">标准输出</span></strong>，其实就是我们敲完什么命令之后，结果就会打在屏幕上。而<strong><span style="background-color:#ffd900;">标准输出的重定向</span></strong>，就是说把结果不打在屏幕上了，而是存到某个地方。</p> 
<p style="margin-left:.0001pt;text-align:left;">例如，把执行的ps -ef的结果重定向到result.1111文件上去。</p> 
<pre><code class="language-bash">[root@localhost~]#ps -ef &gt;result .1111 </code></pre> 
<p style="margin-left:.0001pt;text-align:left;">把执行的a.sh文件的结果保存到a22上去。注意：为了避免结果的覆盖，如果是要对一个可执行文件的的结果进行重定向，那么在可执行文件中，最好不要再有重定向。</p> 
<pre><code class="language-bash">[root@localhost~]#./a.sh &gt;a22 </code></pre> 
<h3 style="margin-left:.0001pt;text-align:left;"><span style="color:#a2e043;">2、标准错误的重定向</span></h3> 
<p style="margin-left:.0001pt;text-align:left;">所谓<strong><span style="background-color:#ffd900;">标准错误</span></strong>，其实就是我们敲完什么命令之后，如果出现什么错误，报错的内容就会显示在屏幕上。而<strong><span style="background-color:#ffd900;">标准错误的重定向</span></strong>，就是说把错误的内容不打在屏幕上了，而是存到某个地方。</p> 
<p style="margin-left:.0001pt;text-align:left;">通常情况下，它与输出一起做重定向。可以重定向到同一个文件，也可以重定向到不同文件。</p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>(1)重定向到同一文件：</strong></p> 
<p style="margin-left:.0001pt;text-align:left;">格式：<strong><span style="background-color:#ffd900;">所执行的操作 &gt;文件名 2&gt;&amp;1</span>       </strong>其中，&amp;表示取地址的意思</p> 
<p style="margin-left:.0001pt;text-align:left;">例如：<strong>./a.sh &gt;out 2&gt;&amp;1————</strong>把执行a.sh文件的输出结果和错误都保存到out这个文件上。</p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>(2)重定向到不同文件：即：错误的和正确的进行分开</strong></p> 
<p style="margin-left:.0001pt;text-align:left;">格式：<strong><span style="background-color:#ffd900;">所执行的操作 &gt;a 2&gt;b</span>    </strong><span style="background-color:#fbd4d0;"> 即：标准的输出存a文件里，错误的存b文件里</span><strong>。   </strong></p> 
<p style="margin-left:.0001pt;text-align:left;">例如：<strong>./a.sh &gt;zz 2&gt;xx————</strong>把输出的结果放到zz里，把错误放到xx这个文件里。</p> 
<h3 style="margin-left:.0001pt;text-align:left;"><span style="color:#a2e043;">3、标准输入的重定向</span></h3> 
<p style="margin-left:.0001pt;text-align:left;">所谓<strong><span style="background-color:#ffd900;">标准输入</span></strong>，就是我们平时要执行什么操作/命令的时候，直接就在终端上输，然后回车运行。而<strong><span style="background-color:#ffd900;">标准输入的重定向</span></strong>，就是不从终端上输了，而是从一个文件上去读取。</p> 
<h2 style="margin-left:.0001pt;text-align:left;"><span style="color:#a2e043;"><strong>四、管道</strong></span></h2> 
<p style="margin-left:.0001pt;text-align:left;">就是把前面那个命令的输出，作为后面那个命令的输入，类似把两行命令合并成一行了。通常使用一个竖杠表示管道。即：<span style="background-color:#ffd900;"> </span><strong><span style="background-color:#ffd900;">|  </span></strong>。</p> 
<p style="margin-left:.0001pt;text-align:left;">格式：命令1 |命令2 |.......</p> 
<p style="margin-left:.0001pt;text-align:left;">例如：执行完a.sh文件后，想知道里面有没有出现error报错信息。</p> 
<p style="margin-left:.0001pt;text-align:left;">法1：没用管道</p> 
<pre><code class="language-bash">[root@localhost~]#./a.sh &gt;out.log 
[root@localhost~]#grep error out.log 
</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">法2：利用管道</p> 
<pre><code class="language-bash">[root@localhost~]#./a.sh |grep error </code></pre> 
<p>当然，管道还可以进行多层的使用，就在后面加|加命令即可，例如想要统计error的行数。</p> 
<pre><code class="language-bash">[root@localhost~]#./a.sh |grep error |wc -l</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e31d494f71b7cdd161f03eb50493a81f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kotlin 特殊字符处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/55f9486ebaad6efb8ad94e2597938890/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Apollo学习（超详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>