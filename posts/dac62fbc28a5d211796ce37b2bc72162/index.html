<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>尚硅谷-宋红康-JVM上中下篇完整笔记-JVM上篇_内存与垃圾回收篇 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/dac62fbc28a5d211796ce37b2bc72162/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="尚硅谷-宋红康-JVM上中下篇完整笔记-JVM上篇_内存与垃圾回收篇">
  <meta property="og:description" content="前言 一.jvm及java体系结构 1. Java及JVM简介 TIOBE语言热度排行榜
https://www.tiobe.com/tiobe-index/
世界上没有最好的编程语言，只有最适用于具体应用场景的编程语言。
java: 跨平台的语言
JVM: 跨语言的平台
随着Java7的正式发布,Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序.Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的,它只关心&#34;字节码&#34;文件.也就是说java虚拟机拥有语言无关性,并不会单纯地与Java语言&#34;终身绑定&#34;,只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集,符号表以及其他的辅助信息,它就是一个有效的字节码文件,就能够被虚拟机所识别并装载运行. 字节码 我们平时说的Java字节码,指的是用java语言编译成的字节码.准确的说任何能在jvm平台上执行的字节码格式都是一样的.所以应该统称为:jvm字节码.不同的编译器,可以编译出相同的字节码文件,字节码文件也可以在不同的jvm上运行.java虚拟机与java语言并没有必然的联系,它只与特定的二进制文件格式—Class文件格式所关联,Class文件中包含了java虚拟机指令集(或者称为字节码,Bytecodes)和符号表,还有一些其他辅助信息. 多语言混合编程 java平台上的多语言混合编程正成为主流,通过特定领域的语言取解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向.试想一下,在一个项目之中,并行处理用Clojure语言编写,展示层使用过JRuby/Rails,中间层用过java,每个应用层都将使用不用的编程语言来完成,而且,接口对每一层的开发者都是透明的.各种语言之间的交互不存在任何困难,就像使用自己语言的原生API一样方便,因为它们最终都运行在一个虚拟机上.对这些运行与Java虚拟机上,Java之外的语言,来自系统级的,底层的支持正在迅速增强,以JSR-292为核心的一系列项目和功能改进(如DaVinci Machine项目,Nashorn引擎,InvokeDynamic指令,java.lang.invoke包等),推动Java虚拟机从&#34;Java语言的虚拟机&#34;想&#34;多语言虚拟机&#34;的方向发展. 2. Java发展的重大事件 Open JDK和Oracle JDK
在JDK11之前,OracleJDK中还会存在一些OpenJDK中没有的,闭源的功能.但在JDK11中,我们可以认为OpenJDK和OracleJDK代码实质上已经完全一致了.
3. 虚拟机与Java虚拟机 虚拟机 所谓虚拟机(Virtual Machine),就是一台虚拟的计算机,它是一款软件,用来执行一系列虚拟计算机指令.大体上,虚拟机可以分为系统虚拟机和程序虚拟机.大名鼎鼎的Visual Box,VMware就属于系统虚拟机,它们完全是对物理计算机的仿真,提供了一个可运行完整操作系统的软件平台.程序虚拟机的典型代表就是Java虚拟机,它专门为执行单个计算机程序而设计,在java虚拟机中执行的指令我们称为Java字节码指令.无论是系统虚拟机还是程序虚拟机,在上面运行的软件都被限制与虚拟机提供的资源中. Java虚拟机 java虚拟机是一台执行Java字节码的虚拟计算机,它拥有独立的运行机制,其运行的java字节码也未必由Java语言编译而成.JVM平台的各种语言可以共享Java虚拟机带来的跨平台型,优秀的垃圾回收器,以及科考的即时编译器.JAVA技术的核心就是Java虚拟机(JVM,Java Virtual Machine),因为所有的Java程序都运行在Java虚拟机内部. - 作用:
JAVA虚拟机就是二进制字节码的运行环境,负责装载字节码到其内部,解释/编译为对应平台上的机器指令执行.每一条Java指令,Java虚拟机规范都有详细定义,如怎么取操作数,怎么处理操作数,处理结果放在哪里. - 特点:
一次编译,到处运行. 2.自动内存管理. 3. 自动垃圾回收功能 JVM的位置
JVM是运行在操作系统之上的,它与硬件没有直接的交互.
4. JVM的整体结构 HotSpot VM是目前市面上高性能虚拟机的代表之一.它采用解释器与即时编译器并存的架构.在今天,Java程序的运行性能早已脱胎换骨,已经达到了可以和C/C&#43;&#43;程序一较高下的地步. 谈谈你对JVM整体的理解?
类加载子系统运行时数据区(我们核心关注这里的栈,堆,方法区)执行引擎(解释器和JIT编译器共存) 5. Java代码执行流程 6. JVM的架构模型 Java编译器输入的指令流基本上是一种基于栈的指令集架构,另外一种指令集架构则是基于寄存器的指令集架构.
具体来说:这两种架构之间的区别:
基于栈式架构的特点: 涉及和实现更简单,适用于资源受限的系统.避开了寄存器的分配难题:适用零地址指令方式分配.指令流中的指令大部分是零地址指令,其执行过程依赖于操作栈.指令集更小,编译器容易实现.不需要硬件支持,可移植性更好,更好实现跨平台. 基于寄存器架构的特点: 典型的应用是x86的二进制指令集,比如传统的PC一级Android的Davlik虚拟机.指令集架构则完全依赖硬件,可移植性差.性能优秀和执行更高效.花费更少的指令取完成一项操作. 在大部分情况下,基于寄存器的指令集都以一地址指令,二地址指令和三地址指令,二基于栈式架构的指令集确实以零地址指令为主. 总结:
由于跨平台性的设计,Java的指令都是根据栈来设计的,不同平台CPU架构不同,所以不能涉及为基于寄存器的.优点是跨平台,指令集小,编译器容易实现,缺点是性能下降,实现同样的功能需要更多的指令.时至今日,尽管嵌入式平台已经不是Java程序的主流运行平台了(准确来说应是HotSportVM的宿主环境已经不局限于嵌入式平台了),那么为什么不将架构更换为基于寄存器的架构呢? 7. JVM的生命周期 虚拟机的启动:
Java虚拟机的启动时通过引导类加载器(bootstrap class loader)创建一个初始类(initial class) 来完成的,这个类是由虚拟机的具体实现指定的.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-08T15:18:18+08:00">
    <meta property="article:modified_time" content="2023-05-08T15:18:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">尚硅谷-宋红康-JVM上中下篇完整笔记-JVM上篇_内存与垃圾回收篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ce/eb/IQ2CJdeW_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/60/b8/OSSSSH7l_o.png"></p> 
<h2>一.jvm及java体系结构</h2> 
<h3 id="1.%20Java%E5%8F%8AJVM%E7%AE%80%E4%BB%8B"><a id="1_JavaJVM_3"></a>1. Java及JVM简介</h3> 
<p>TIOBE语言热度排行榜<br> https://www.tiobe.com/tiobe-index/<br> 世界上没有最好的编程语言，只有最适用于具体应用场景的编程语言。</p> 
<ul><li>java: 跨平台的语言<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/c7/11/YiBgYCH1_o.jpg"></li><li>JVM: 跨语言的平台<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/60/9d/L5WGxj1y_o.jpg"></li></ul> 
<blockquote> 
 <ul><li>随着Java7的正式发布,Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序.</li><li>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的,它只关心"字节码"文件.也就是说java虚拟机拥有语言无关性,并不会单纯地与Java语言"终身绑定",只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集,符号表以及其他的辅助信息,它就是一个有效的字节码文件,就能够被虚拟机所识别并装载运行.</li></ul> 
</blockquote> 
<ul><li>字节码</li></ul> 
<blockquote> 
 <ul><li>我们平时说的Java字节码,指的是用java语言编译成的字节码.准确的说任何能在jvm平台上执行的字节码格式都是一样的.所以应该统称为:jvm字节码.</li><li>不同的编译器,可以编译出相同的字节码文件,字节码文件也可以在不同的jvm上运行.</li><li>java虚拟机与java语言并没有必然的联系,它只与特定的二进制文件格式—Class文件格式所关联,Class文件中包含了java虚拟机指令集(或者称为字节码,Bytecodes)和符号表,还有一些其他辅助信息.</li></ul> 
</blockquote> 
<ul><li>多语言混合编程</li></ul> 
<blockquote> 
 <ul><li>java平台上的多语言混合编程正成为主流,通过特定领域的语言取解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向.</li><li>试想一下,在一个项目之中,并行处理用Clojure语言编写,展示层使用过JRuby/Rails,中间层用过java,每个应用层都将使用不用的编程语言来完成,而且,接口对每一层的开发者都是透明的.各种语言之间的交互不存在任何困难,就像使用自己语言的原生API一样方便,因为它们最终都运行在一个虚拟机上.</li><li>对这些运行与Java虚拟机上,Java之外的语言,来自系统级的,底层的支持正在迅速增强,以JSR-292为核心的一系列项目和功能改进(如DaVinci Machine项目,Nashorn引擎,InvokeDynamic指令,java.lang.invoke包等),推动Java虚拟机从"Java语言的虚拟机"想"多语言虚拟机"的方向发展.</li></ul> 
</blockquote> 
<h3 id="2.%20Java%E5%8F%91%E5%B1%95%E7%9A%84%E9%87%8D%E5%A4%A7%E4%BA%8B%E4%BB%B6"><a id="2_Java_18"></a>2. Java发展的重大事件</h3> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/9b/74/JT6OFa48_o.png"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/18/0f/OGxajRtP_o.png"></p> 
<ul><li>Open JDK和Oracle JDK<br><img alt="请添加图片描述" src="https://images2.imgbox.com/fe/95/ntdNUXDt_o.png"></li></ul> 
<blockquote> 
 <p>在JDK11之前,OracleJDK中还会存在一些OpenJDK中没有的,闭源的功能.但在JDK11中,我们可以认为OpenJDK和OracleJDK代码实质上已经完全一致了.</p> 
</blockquote> 
<h3 id="3.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8EJava%E8%99%9A%E6%8B%9F%E6%9C%BA"><a id="3__Java_23"></a>3. 虚拟机与Java虚拟机</h3> 
<ul><li>虚拟机</li></ul> 
<blockquote> 
 <ul><li>所谓虚拟机(Virtual Machine),就是一台虚拟的计算机,它是一款软件,用来执行一系列虚拟计算机指令.大体上,虚拟机可以分为系统虚拟机和程序虚拟机.</li><li>大名鼎鼎的Visual Box,VMware就属于系统虚拟机,它们完全是对物理计算机的仿真,提供了一个可运行完整操作系统的软件平台.</li><li>程序虚拟机的典型代表就是Java虚拟机,它专门为执行单个计算机程序而设计,在java虚拟机中执行的指令我们称为Java字节码指令.</li><li>无论是系统虚拟机还是程序虚拟机,在上面运行的软件都被限制与虚拟机提供的资源中.</li></ul> 
</blockquote> 
<ul><li>Java虚拟机</li></ul> 
<blockquote> 
 <ul><li>java虚拟机是一台执行Java字节码的虚拟计算机,它拥有独立的运行机制,其运行的java字节码也未必由Java语言编译而成.</li><li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台型,优秀的垃圾回收器,以及科考的即时编译器.</li><li>JAVA技术的核心就是Java虚拟机(JVM,Java Virtual Machine),因为所有的Java程序都运行在Java虚拟机内部.</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>- 作用:</strong></p> 
 <ul><li>JAVA虚拟机就是二进制字节码的运行环境,负责装载字节码到其内部,解释/编译为对应平台上的机器指令执行.每一条Java指令,Java虚拟机规范都有详细定义,如怎么取操作数,怎么处理操作数,处理结果放在哪里.</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>- 特点:</strong></p> 
 <ol><li>一次编译,到处运行. 2.自动内存管理. 3. 自动垃圾回收功能</li></ol> 
</blockquote> 
<ul><li>JVM的位置<br><img alt="请添加图片描述" src="https://images2.imgbox.com/d1/41/cpUonfrq_o.jpg"></li></ul> 
<blockquote> 
 <p>JVM是运行在操作系统之上的,它与硬件没有直接的交互.</p> 
</blockquote> 
<h3 id="4.%20JVM%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><a id="4_JVM_42"></a>4. JVM的整体结构</h3> 
<blockquote> 
 <ul><li>HotSpot VM是目前市面上高性能虚拟机的代表之一.</li><li>它采用解释器与即时编译器并存的架构.</li><li>在今天,Java程序的运行性能早已脱胎换骨,已经达到了可以和C/C++程序一较高下的地步.</li></ul> 
</blockquote> 
<blockquote> 
 <p>谈谈你对JVM整体的理解?</p> 
 <ul><li>类加载子系统</li><li>运行时数据区(我们核心关注这里的栈,堆,方法区)</li><li>执行引擎(解释器和JIT编译器共存)</li></ul> 
</blockquote> 
<h3 id="5.%20Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><a id="5_Java_51"></a>5. Java代码执行流程</h3> 
<p><img alt="请添加图片描述" src="https://images2.imgbox.com/dc/a1/vOc2PWvv_o.png"></p> 
<h3 id="6.%20JVM%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><a id="6_JVM_53"></a>6. JVM的架构模型</h3> 
<blockquote> 
 <p>Java编译器输入的指令流基本上是一种基于栈的指令集架构,另外一种指令集架构则是基于寄存器的指令集架构.<br> 具体来说:这两种架构之间的区别:</p> 
 <ul><li>基于栈式架构的特点:</li></ul> 
 <ol><li>涉及和实现更简单,适用于资源受限的系统.</li><li>避开了寄存器的分配难题:适用零地址指令方式分配.</li><li>指令流中的指令大部分是零地址指令,其执行过程依赖于操作栈.指令集更小,编译器容易实现.</li><li>不需要硬件支持,可移植性更好,更好实现跨平台.</li></ol> 
 <ul><li>基于寄存器架构的特点:</li></ul> 
 <ol><li>典型的应用是x86的二进制指令集,比如传统的PC一级Android的Davlik虚拟机.</li><li>指令集架构则完全依赖硬件,可移植性差.</li><li>性能优秀和执行更高效.</li><li>花费更少的指令取完成一项操作.</li></ol> 
 <ul><li>在大部分情况下,基于寄存器的指令集都以一地址指令,二地址指令和三地址指令,二基于栈式架构的指令集确实以零地址指令为主.</li></ul> 
</blockquote> 
<blockquote> 
 <p>总结:</p> 
 <ul><li>由于跨平台性的设计,Java的指令都是根据栈来设计的,不同平台CPU架构不同,所以不能涉及为基于寄存器的.优点是跨平台,指令集小,编译器容易实现,缺点是性能下降,实现同样的功能需要更多的指令.</li><li>时至今日,尽管嵌入式平台已经不是Java程序的主流运行平台了(准确来说应是HotSportVM的宿主环境已经不局限于嵌入式平台了),那么为什么不将架构更换为基于寄存器的架构呢?</li></ul> 
</blockquote> 
<h3 id="7.%20JVM%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><a id="7_JVM_72"></a>7. JVM的生命周期</h3> 
<blockquote> 
 <p><strong>虚拟机的启动:</strong></p> 
 <ul><li>Java虚拟机的启动时通过引导类加载器(bootstrap class loader)创建一个初始类(initial class) 来完成的,这个类是由虚拟机的具体实现指定的.</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>虚拟机的运行:</strong></p> 
 <ul><li>一个运行的Java虚拟机有着一个清晰的任务:执行Java程序.</li><li>程序开始执行时它才运行,程序结束时它就停止.</li><li>执行一个所谓的Java程序的时候,真真正正在执行的是一个叫做Java虚拟机的进程.</li></ul> 
</blockquote> 
<p><strong>虚拟机的退出:</strong></p> 
<blockquote> 
 <p>有如下几种情况:</p> 
 <ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或者错误而异常终止.</li><li>由于操作系统出现错误而导致Java虚拟机进程终止.</li><li>某线程调用Runtime类或者System类的exit方法,或Runtime类的halt方法,并且Java安全管理器也运行这次exit或halt操作.</li><li>除此之外,JNI(Java Native InterFace)规范描述了用JNI Invocation API来加载或者卸载Java虚拟机,Java虚拟机的退出情况.</li></ul> 
</blockquote> 
<h3 id="8.%20JVM%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><a id="8_JVM_88"></a>8. JVM发展历程</h3> 
<ul><li>Sun Classic VM</li></ul> 
<blockquote> 
 <ul><li>早在1996年Java1.0版本的时候,Sun公司发不了一款名为Sun Classic VM的Java虚拟机,它同时也是世界上第一款商用Java虚拟机,JDK1.4时完全被淘汰.</li><li>这块虚拟机内部只提供解释器.</li><li>如果使用JIT编译器,就需要进行外挂.但是一旦使用了JIT编译器,JIT就会接管虚拟机的执行系统.解释器就不再工作.解释器和编译器不能配合工作.</li><li>现在hotspot内置了此虚拟机.</li></ul> 
</blockquote> 
<ul><li>Exact VM</li></ul> 
<blockquote> 
 <ul><li>为了解决上一个虚拟机问题,jdk1.2时,sun提供了此虚拟机.</li><li>Exact Memory Management:准确式内存管理.</li><li>也可以叫Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型.</li><li>具体现代高性能虚拟机的雏形</li></ul> 
 <ol><li>热点探测</li><li>编译器与解释器混合工作模式</li></ol> 
 <ul><li>只在Solaris平台短暂使用,其他平台上还是classic VM</li></ul> 
 <ol><li>英雄气短,终被Hotspot虚拟机替换.</li></ol> 
</blockquote> 
<ul><li>Sun公司的HotSpot VM</li></ul> 
<blockquote> 
 <ul><li>HotSpot 历史</li></ul> 
 <ol><li>最初有一家名为"Longview Technologies"的小公司涉及.</li><li>1997年,此公司被Sun公司收购,2009年,Sun公司被甲骨文收购.</li><li>JDK1.3时,HotSpot VM成为默认虚拟机.</li></ol> 
 <ul><li>目前HotSpot 占有绝对的市场地位,称霸武林</li></ul> 
 <ol><li>不管是现在仍在广泛是用的JDK6,还是使用比较多的JDK8中,默认的虚拟机都HotSpot.</li><li>Sun/Oracle JDK和OpenJDK的默认虚拟机.</li><li>因此本课程默认介绍的虚拟机都是HotSpot .</li></ol> 
 <ul><li>从服务器,桌面到移动端,嵌入式都有应用.</li></ul> 
 <ol><li>通过计数器找到最具编译价值的代码,触发即时编译或者栈上替换.</li><li>通过编译器与解释器协同工作,在最优化的程序响应时间与最佳执行性能中取得平衡.</li></ol> 
</blockquote> 
<ul><li>BEA的JRockit</li></ul> 
<blockquote> 
 <ul><li>专注于服务器端应用</li></ul> 
 <ol><li>它可以不太关注程序启动速度,因此JRockit内部不包含解释器实现,全部代码都是靠即时编译器编译后执行.</li></ol> 
 <ul><li>大量的行业基准测试显示,JRockit JVM是世界上最快的JVM</li></ul> 
 <ol><li>使用JRockit产品,可以已经体验到了显著的性能提高(一般超过了70%)和硬件成本的减少(50%).</li></ol> 
 <ul><li>优势:全面的Java运行时解决方案组合</li></ul> 
 <ol><li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或者微秒级的JVM响应时间,适合财务,军事指挥,电信网络的需要.</li><li>MissionControl服务套件,它是一组以极低的开销来监控,管理和分析生产环境中的应用程序的工具.</li></ol> 
 <ul><li>2008年,BEA被Oracle收购.</li><li>Oracle表达了整合两大优势虚拟机的工资,大致在JDK 8中完成.整合的方式是在HotSpot的基础上,移植JRockit的优秀特性.</li></ul> 
</blockquote> 
<ul><li>IBM的J9</li></ul> 
<blockquote> 
 <ul><li>全称: IBM Technology for Java Virtual Machine,简称IT4J,内部代号:J9.</li><li>市场点位与HotSpot接近,服务器端,桌面应用,嵌入式等多用途VM.</li><li>广泛用于IBM的各种Java产品中</li><li>目前,有影响力的三大商用服务器之一,也号称世界上最快的Java虚拟机.</li><li>2017年左右,IBM发布了开源J9 VM,命名为Open J9,交给Ecllipse基金会管理,也成为了Eclipse OpenJ9.</li></ul> 
</blockquote> 
<ul><li>KVM和CDC/CLDC Hotspot</li></ul> 
<blockquote> 
 <ul><li>Oracle在Java ME产品线上的两款虚拟机为:CDC/CLDC HotSpot Implementation VM&gt;</li><li>KVM(Kilobyte)是CLDC-HT早起产品.</li><li>目前移动领域地位尴尬,智能手机被安卓和IOS二分天下.</li><li>KVM简单,轻量,高度可移植,面向更低端的设备上还维持自己的一片市场</li></ul> 
 <ol><li>智能控制器,传感器</li><li>老人手机,经济欠发达地区的功能手机</li></ol> 
 <ul><li>所有的虚拟机的原则:一次编译,到处运行.</li></ul> 
</blockquote> 
<ul><li>Azul VM</li></ul> 
<blockquote> 
 <ul><li>前面三大"高性能Java虚拟机"使用在通用硬件平台上.</li><li>这里Azul VM和BEA Liquid VM是特定硬件平台绑定,软硬件配合的专有虚拟机</li><li>高性能Java虚拟机中的战斗机.</li><li>Azul VM是Azul Systems公司在Hotspot基础上进行大量改进,运行于Azul Systems公司的专有Vega系统上的Java虚拟机.</li><li>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源,并提供在巨大内存范围内实现可控的GC时间的垃圾收集器,专有硬件优化的线程调度等有优秀特性.</li><li>2010年,Azul Systems公司开始从硬件转向软件,发布了自己的Zing JVM,可以在通用X86平台提供接近与Vega系统的特性.</li></ul> 
</blockquote> 
<ul><li>Liquid VM</li></ul> 
<blockquote> 
 <ul><li>高性能Java虚拟机中的战斗机.</li><li>BEA公司开发的,直接运行在自家Hypervisor系统上.</li><li>Liquid VM即使现在的JRockit VE,Liquid VM不需要操作系统的支持,或者说它自己本身实现了一个专有的操作系统的必要功能,如线程调度,文件系统,网络支持等.</li><li>随着JRockit虚拟机终止开发,Liquid VM项目也停止了.</li></ul> 
</blockquote> 
<ul><li>Apache Harmony</li></ul> 
<blockquote> 
 <ul><li>Apache 也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony.</li><li>它是IBM和Intel联合开发的开源JVM,收到同样开源的OpenJDK的压制,Sun坚决不让Harmony获得JCP认证,最终于2011年退役,IBM转而参加OpenJDK</li><li>虽然目前并没有Apache Harmony被大规模商用的案例,但是它的Java类库代码吸纳进了Android SDK.</li></ul> 
</blockquote> 
<ul><li>Microsoft JVM</li></ul> 
<blockquote> 
 <ul><li>微软为了在IE3浏览器中支持Java Applets,开发了Microsoft JVM.</li><li>只能在window平台运行.但确实是当时Windows下性能最好的Java VM.</li><li>1997年,Sun以侵权商标,不正当竞争罪名质控微软成功,陪了sun很多钱,微软在WinowsXP SP3中抹掉了其VM.现在windows上安装的JDK都是HotSpot.</li></ul> 
</blockquote> 
<ul><li>TaobaoJVM</li></ul> 
<blockquote> 
 <ul><li>由AliJVM团队发布.阿里,国内使用Java最强大的公司,覆盖了云计算,金融,物流,电商等众多领域,需要解决高并发,高可用,分布式的复合问题.有大量的开源产品.</li><li>基于OpenJDK开发了自己的定制版本AlibabaJDK,简称AJDK.是整个阿里Java体系的基时.</li><li>基于OpenJDK HotSpot VM发布的国内第一个优化,深度定制且开源的高性能服务器版Java虚拟机.</li></ul> 
 <ol><li>创新的GCIH(GC invisible heap)技术实现了off-heap,即将全生命周期较长的Java对象从heap中移到heap之外,并且GC不能管理GCIH内部的Java对象,一次达到降低GC的回收频率和提升GC的回收效率的目的.</li><li>GCIH中的对象还能够在多个java虚拟机进程中实现共享.</li><li>使用crc32指令实现JVM intrinsic降低JNI的调用开销.</li><li>PMU hardware的Java profiling tool和诊断协助工功能.</li><li>针对大数据场景的ZenGC.</li></ol> 
 <ul><li>taobao VM应用在阿里产品上性能高,硬件严重依赖intel的cpu,损失了兼容性,但提高了性能.</li></ul> 
 <ol><li>目前已经在淘宝,天猫上线,把Oracle官方JVM版本全部替换了.</li></ol> 
</blockquote> 
<h2 id="%E4%BA%8C%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><a id="__171"></a>二 类加载子系统</h2> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/d2/6c/wK99d1WR_o.png"></p> 
<h3 id="1.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><a id="1__174"></a>1. 类加载器子系统的作用</h3> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/cc/ec/GYebPoz3_o.png"></p> 
<blockquote> 
 <ul><li>类加载器子系统负责从文件系统或者网络中心加载Class文件，class文件在文件开头有特定的文件标识。</li><li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。<br> 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ul> 
</blockquote> 
<h3 id="2.%20%E7%B1%BB%E5%8A%A0%E8%BD%BDClassLoader%E8%A7%92%E8%89%B2"><a id="2_ClassLoader_179"></a>2. 类加载ClassLoader角色</h3> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/9c/8d/ZMXKVPNU_o.png"></p> 
<blockquote> 
 <ul><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化n个一模一样的实例。</li><li>class file加载到JVM，被称为DNA元数据模板，放在方法区。</li><li>在.class文件 --&gt;JVM --&gt;最终成为元数据模板，此过程就要有一个运输工具（类加载器Class Loader）扮演一个快递员的角色。</li></ul> 
</blockquote> 
<h3 id="3.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><a id="3__184"></a>3. 类加载过程</h3> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ff/53/51ZbAqb0_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/14/d8/3HeIAIGA_o.png"></p> 
<h4 id="3.1%20%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><a id="31__187"></a>3.1 加载阶段</h4> 
<blockquote> 
 <ul><li>通过一个类的全限定名获取定义此类的二进制字节流。</li><li>将这个字节流所代表的的静态存储结果转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li><li>类将.class文件加载至元空间后，会在堆中创建一个java.lang.Class对象，用来封装类位于方法区内的数据结构。该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。</li></ul> 
</blockquote> 
<blockquote> 
 <p>补充：加载.class文件的方式</p> 
 <ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar，war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用</li><li>从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul> 
</blockquote> 
<h4 id="3.2%20%E9%93%BE%E6%8E%A5(Linking)"><a id="32_Linking_201"></a>3.2 链接(Linking)</h4> 
<p id="3.2.1%20%E9%AA%8C%E8%AF%81(Verify)"><a id="321_Verify_202"></a>3.2.1 验证(Verify)</p> 
<blockquote> 
 <ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身的安全。</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</li><li>格式检查:是否以魔术oxCAFEBABE开头,主版本和副版本是否在当前Java虚拟机的支持范围内,数据中每一项是否都拥有正确的长度等等。</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/b0/78/ns83C8Zl_o.png"></p> 
<p id="3.2.2%20%E5%87%86%E5%A4%87(Prepare)"><a id="322_Prepare_208"></a>3.2.2 准备(Prepare)</p> 
<blockquote> 
 <ul><li>为类变量分配内存并且设置该变量的默认初始值，即零值。</li><li><code>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</code>。<br><code>这里不会为实例变量分配初始化，</code>类变量会分配在方法区中，而实例变量会随着对象一起分配到Java堆中。</li><li>注意:Java并不支持boolean类型,对于boolean类型,内部实现是int,由于int的默认值是0,故对应的,boolean的默认值就是false</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/3e/e4/KYvQyFtV_o.png"></p> 
<p id="3.2.3%20%E8%A7%A3%E6%9E%90(Resolve)"><a id="323_Resolve_215"></a>3.2.3 解析(Resolve)</p> 
<blockquote> 
 <ul><li>将常量池内的符号引用转换为直接引用的过程。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后在执行。</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或者接口，字段，类方法，接口方法，方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li><li>符号引号有:类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li></ul> 
</blockquote> 
<blockquote> 
 <p>解释什么是符号引号和直接引用?</p> 
 <ol><li>教室里有个空的位子没坐人,座位上边牌子写着小明的座位(符号引用),后来小明进来坐下去掉牌子(符号引用换成直接引用)</li><li>我们去做菜,看菜谱,步骤都是什么样的(这是符号引号),当我们实际上去做,这个过程是直接引用</li><li>举例:输出操作System.out.println()对应的字节码:<br> invokevirtual #24 &lt;java/io/PrintStream.println&gt;</li></ol> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ed/8d/LbF7Yloc_o.png"></p> 
<blockquote> 
 <p>以方法为例,Java虚拟机为每个类都准备了一张方法表,将其所有的方法都列在表中,当需要调用一个类的方法的时候,只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作,符号引用就可以转变为目标方法在类中方法表中的位置,从而使得方法被成功调用</p> 
</blockquote> 
<h3 id="3.3%20%E5%88%9D%E5%A7%8B%E5%8C%96(Initialization)"><a id="33_Initialization_231"></a>3.3 初始化(Initialization)</h3> 
<blockquote> 
 <ul><li>为类变量赋予正确的初始化值。</li><li>初始化阶段就是执行类构造器clinit()的过程。</li></ul> 
</blockquote> 
<pre><code class="language-java">public class ClassInitTest {
private  static int num=1; //类变量的赋值动作

//静态代码快中的语句static{
num=2;
number=20;
System.out.println(num);//System.out.println(number); 报错:非法的前向引用

}

//Linking之prepare: number=0 --&gt;initial:20--&gt;10
private static int number=10;

public static void main(String[] args) {

System.out.println(ClassInitTest.num);
System.out.println(ClassInitTest.number);
}
}
</code></pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/6d/28/Kzn7IFWN_o.png"></p> 
<blockquote> 
 <ul><li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li>clinit()不同于类的构造器。（关联：构造器是虚拟机视角下的init()）</li><li>若该类具有父类，JVM会保证子类的clinit()执行前，父类的clinit()依据执行完毕。clinit 不同于类的构造方法(init) (由父及子,静态先行)</li></ul> 
</blockquote> 
<pre><code class="language-java">public class ClinitTest1 {

static class Father{
public static int A=1;
static{
A=2;
}
}

static class Son extends Father{
public static int B=A;

}

public static void main(String[] args) {
//这个输出2,则说明父类已经全部加载完毕
System.out.println(Son.B);
}

}
</code></pre> 
<blockquote> 
 <ul><li>虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。</li><li>Java编译器并不会为所有的类都产生clinit()初始化方法。哪些类在编译为字节码后,字节码文件中将不会包含clinit()方法？</li></ul> 
 <ol><li>一个类中并没有声明任何的类变量,也没有静态代码块时</li><li>一个类中声明类变量,但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</li><li>一个类中包含static final修饰的基本数据类型的字段,这些类字段初始化语句采用编译时常量表达式 (如果这个static final 不是通过方法或者构造器,则在链接阶段)</li></ol> 
</blockquote> 
<pre><code class="language-java">/**
* @author TANGZHI* @create 2021-01-01 18:49
* 哪些场景下,java编译器就不会生成&lt;clinit&gt;()方法
*/

public class InitializationTest1 {
//场景1:对应非静态的字段,不管是否进行了显式赋值,都不会生成&lt;clinit&gt;()方法
public int num = 1;

//场景2:静态的字段,没有显式的赋值,不会生成&lt;clinit&gt;()方法
public static int num1;

//场景3:比如对于声明为static final的基本数据类型的字段,不管是否进行了显式赋值,都不会生成&lt;clinit()
//方法
public static final int num2 = 1;
}
</code></pre> 
<blockquote> 
 <ul><li>static与final的搭配问题(使用static + final修饰,且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值,是在链接阶段的准备环节进行)</li></ul> 
</blockquote> 
<pre><code class="language-java">
/*** @author TANGZHI* @create 2021-01-01 *
* 说明:使用static + final修饰的字段的显式赋值的操作,到底是在哪个阶段进行的赋值？
* 情况1:在链接阶段的准备环节赋值
* 情况2:在初始化阶段&lt;clinit&gt;()中赋值
* 结论:
* 在链接阶段的准备环节赋值的情况:
* 1. 对于基本数据类型的字段来说,如果使用static final修饰,则显式赋值(直接赋值常量,而非调用方法)通常是在链接阶段的准备环节进行
* 2. 对于String来说,如果使用字面量的方式赋值,使用static final修饰的话,则显式赋值通常是在链接阶
*段的准备环节进行
* 在初始化阶段&lt;clinit&gt;()中赋值的情况:
* 排除上述的在准备环节赋值的情况之外的情况。
* 最终结论:使用static + final修饰,且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值,是在链接阶段的准备环节进行。*/

public class InitializationTest2 {
public static int a = 1;

//在初始化阶段&lt;clinit&gt;()中赋值
public static final int INT_CONSTANT = 10;

//在链接阶段的准备环节赋值
public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100);

//在初始化阶段&lt;clinit&gt;()中赋值
public static Integer INTEGER_CONSTANT2 = Integer.valueOf(1000);

//在初始化阶段&lt;clinit&gt;()中赋值
public static final String s0 = "helloworld0";

//在链接阶段的准备环节赋值
public static final String s1 = new String("helloworld1");

//在初始化阶段&lt;clinit&gt;()中赋值
public static String s2 = "helloworld2";
public static final int NUM1 = new Random().nextInt(10);//在初始化阶段&lt;clinit&gt;()中赋值
}
</code></pre> 
<blockquote> 
 <ul><li>clinit()的调用会死锁吗?</li></ul> 
 <ol><li>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步,如果多个线程同时去初始化一个类,那么只会有一个线程去执行这个类的()方法,其他线程都需要阻塞等待,直到活动线程执行()方法完毕</li><li>正是因为函数()带锁线程安全的,因此,如果在一个类的()方法中有耗时很长的操作,就可能造成多个线程阻塞,引发死锁。并且这种死锁是很难发现的,因为看起来它们并没有可用的锁信息</li></ol> 
</blockquote> 
<h3 id="4.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><a id="4__332"></a>4. 类加载器分类</h3> 
<blockquote> 
 <ul><li>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</li></ul> 
</blockquote> 
<blockquote> 
 <ul><li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/c1/d4/wXkSMlbU_o.png"><br> 这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p> 
<h4 id="4.1%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><a id="41__340"></a>4.1 虚拟机自带的加载器</h4> 
<p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p> 
<blockquote> 
 <ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul> 
</blockquote> 
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p> 
<blockquote> 
 <ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul> 
</blockquote> 
<h4 id="4.2%20%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><a id="42__355"></a>4.2 用户自定义类加载器</h4> 
<blockquote> 
 <ul><li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</li></ul> 
</blockquote> 
<blockquote> 
 <ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul> 
</blockquote> 
<blockquote> 
 <p>用户自定义类加载器实现步骤：</p> 
</blockquote> 
<blockquote> 
 <ul><li>开发人员可以通过继承抽象类ava.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass() 方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass() 方法，而是建议把自定义的类加载逻辑写在findClass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul> 
</blockquote> 
<pre><code class="language-java">public class ClassLoaderDemo {

public static void main(String[] args) {

ClassLoader classloader1 = ClassLoader.getSystemClassLoader();
//sun.misc.Launcher$AppClassLoader@18b4aac2
System.out.println(classloader1);

//获取到扩展类加载器
//sun.misc.Launcher$ExtClassLoader@424c0bc4
System.out.println(classloader1.getParent());

//获取到引导类加载器 null
System.out.println(classloader1.getParent().getParent());

//获取系统的ClassLoader
ClassLoader classloader2 = Thread.currentThread().getContextClassLoader();

//sun.misc.Launcher$AppClassLoader@18b4aac2
System.out.println(classloader2);

String[]strArr=new String[10];
ClassLoader classLoader3 = strArr.getClass().getClassLoader();

//null,表示使用的是引导类加载器
System.out.println(classLoader3);

ClassLoaderDemo[]refArr=new ClassLoaderDemo[10];
//sun.misc.Launcher$AppClassLoader@18b4aac2
System.out.println(refArr.getClass().getClassLoader());

int[]intArr=new int[10];
//null,如果数组的元素类型是基本数据类型,数组类是没有类加载器的System.out.println(intArr.getClass().getClassLoader());
}
}
</code></pre> 
<h4 id="4.3%20ClassLoader%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><a id="43_ClassLoader_396"></a>4.3 ClassLoader的使用说明</h4> 
<blockquote> 
 <ul><li>ClassLoader类是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/79/80/qu3N5K6H_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/b7/89/mUHoWn40_o.png"><br><strong>获取ClassLoader的途径</strong></p> 
<pre><code class="language-java">方式一：获取当前ClassLoader
clazz.getClassLoader()

方式二：获取当前线程上下文的ClassLoader 
Thread.currentThread().getContextClassLoader()

方式三：获取系统的ClassLoader
ClassLoader.getSystemClassLoader()

方式四：获取调用者的ClassLoader 
DriverManager.getCallerClassLoader()
</code></pre> 
<h4 id="4.3%20%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><a id="43__412"></a>4.3 双亲委派机制</h4> 
<blockquote> 
 <p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p> 
</blockquote> 
<blockquote> 
 <p><strong>工作原理</strong></p> 
 <ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/c8/82/ySaY52sr_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/11/74/rxna0SnN_o.png"></p> 
<blockquote> 
 <p><strong>举例</strong></p> 
 <ul><li>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类jdbc.jar的加载。</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/02/ee/zIcLQlwW_o.png"></p> 
<blockquote> 
 <p><strong>优势</strong></p> 
 <ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改 
   <ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>沙箱安全机制</strong></p> 
 <ul><li>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li><li>如图,虽然我们自定义了一个java.lang包下的String尝试覆盖核心类库中的String,但是由于双亲委派机制,启动加载器会加载java核心类库的String类(BootStrap启动类加载器只加载包名为java、javax、sun等开头的类),而核心类库中的String并没有main方法</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/e3/3e/hE3ElLa2_o.png"></p> 
<h3 id="5.%20%E5%85%B6%E4%BB%96"><a id="5__439"></a>5. 其他</h3> 
<p><strong>如何判断两个class对象是否相同</strong></p> 
<blockquote> 
 <p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p> 
 <ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul> 
</blockquote> 
<blockquote> 
 <p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p> 
</blockquote> 
<p><strong>对类加载器的引用</strong></p> 
<blockquote> 
 <p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p> 
</blockquote> 
<p><strong>类的主动使用和被动使用</strong></p> 
<blockquote> 
 <p>Java程序对类的使用方式分为：主动使用和被动使用。</p> 
</blockquote> 
<blockquote> 
 <p>主动使用，又分为七种情况：</p> 
 <ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName（“com.atguigu.Test”））</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK 7 开始提供的动态语言支持：<br> java.lang.invoke.MethodHandle实例的解析结果<br> REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ul> 
</blockquote> 
<blockquote> 
 <p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p> 
</blockquote> 
<h2 id="%E4%B8%89%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><a id="__469"></a>三 运行时数据区</h2> 
<h3 id="1.%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><a id="1__470"></a>1. 运行时数据区</h3> 
<h4 id="1.1%20%E6%A6%82%E8%BF%B0"><a id="11__471"></a>1.1 概述</h4> 
<p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/2f/20/2EYK4WVd_o.png"></p> 
<blockquote> 
 <p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a5/4d/pr7hmANT_o.png"></p> 
</blockquote> 
<blockquote> 
 <p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/cf/e4/cS84CZWt_o.png"></p> 
<blockquote> 
 <p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/4b/f0/0q1Jm63Q_o.png"></p> 
<blockquote> 
 <p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p> 
</blockquote> 
<blockquote> 
 <p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p> 
 <ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/4d/ac/QPVxPNYf_o.png"><br> 每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ab/e4/k3tNc22L_o.png"></p> 
<h4 id="1.2%20%E7%BA%BF%E7%A8%8B"><a id="12__492"></a>1.2 线程</h4> 
<blockquote> 
 <ul><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</li><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li><li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</li></ul> 
</blockquote> 
<h4 id="1.3%20JVM%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B"><a id="13_JVM_497"></a>1.3 JVM系统线程</h4> 
<blockquote> 
 <ul><li>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[] args)的main线程以及所有这个main线程自己创建的线程。</li><li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个： 
   <ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括"stop-the-world"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul></li></ul> 
</blockquote> 
<h3 id="2.%20%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8(PC%E5%AF%84%E5%AD%98%E5%99%A8)"><a id="2_PC_506"></a>2. 程序计数器(PC寄存器)</h3> 
<blockquote> 
 <p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/2e/63/MxySsgLW_o.png"></p> 
<blockquote> 
 <p><strong>作用</strong></p> 
 <ul><li>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</li><li>特点(是线程私有的 、不会存在内存溢出)</li><li>在物理上实现程序计数器是在寄存器实现的,整个cpu中最快的一个执行单元</li><li>是唯一一个在java虚拟机规范中没有OOM的区域</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/17/89/G9GdscqO_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/eb/2e/AnxksmaH_o.png"></p> 
<p></p> 
<blockquote> 
 <ul><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是==所谓的当前方法。==程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</strong></p> 
 <ul><li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</li><li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/04/d9/yTOnuiea_o.png"></p> 
<blockquote> 
 <p><strong>PC寄存器为什么被设定为私有的？</strong></p> 
 <ul><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>CPU时间片</strong></p> 
 <ul><li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li><li>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li><li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</li></ul> 
</blockquote> 
<h2 id="%E5%9B%9B%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><a id="__539"></a>四 虚拟机栈</h2> 
<h3 id="4.1.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%A6%82%E8%BF%B0"><a id="41__540"></a>4.1. 虚拟机栈概述</h3> 
<h4 id="4.1.1%20%E8%83%8C%E6%99%AF"><a id="411__541"></a>4.1.1 背景</h4> 
<blockquote> 
 <ul><li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</li><li>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li></ul> 
</blockquote> 
<h4 id="4.1.2%20%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E5%A0%86"><a id="412__544"></a>4.1.2 内存中的栈与堆</h4> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;">栈是运行时的单位，而堆是存储的单位</span></li><li><span style="color:#fe2c24;">栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</span></li><li><span style="color:#fe2c24;">堆解决的是数据存储的问题，即数据怎么放，放哪里</span></li></ul> 
</blockquote> 
<p><a id="413__548"></a>4.1.3 虚拟机栈基本内容</p> 
<p><strong>Java虚拟机栈是什么？</strong></p> 
<blockquote> 
 <p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的。</p> 
</blockquote> 
<p><strong>生命周期</strong></p> 
<blockquote> 
 <p>生命周期和线程一致</p> 
</blockquote> 
<p><strong>作用</strong></p> 
<blockquote> 
 <p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p> 
</blockquote> 
<p><strong>栈的特点</strong></p> 
<blockquote> 
 <ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM直接对Java栈的操作只有两个： 
   <ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul></li><li><span style="color:#fe2c24;">对于栈来说不存在垃圾回收问题（</span><span style="color:#511b78;">栈存在溢出的情况</span><span style="color:#fe2c24;">）</span></li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/f3/eb/kpx7EY09_o.png"><br><strong>栈中可能出现的异常</strong></p> 
<blockquote> 
 <ul><li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。 
   <ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 ==OutOfMemoryError ==异常。</li></ul></li></ul> 
</blockquote> 
<pre><code class="language-java">public static void main(String[] args) {

test();
}

public static void test() {
test();
}
//抛出异常：Exception in thread"main"java.lang.StackoverflowError
//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。
</code></pre> 
<p><strong>设置栈内存大小</strong></p> 
<blockquote> 
 <ul><li>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</li><li>如何设置栈内存的大小？ -Xss size (即:-XX:ThreadStackSize) 
   <ul><li>一般默认为512k-1024k,取决于操作系统(jdk5之前,默认栈大小是256k;jdk5之后,默认栈大小是1024k)<br> 栈的大小直接决定了函数调用的最大可达深度</li></ul></li></ul> 
</blockquote> 
<pre><code class="language-java">public class StackDeepTest{ 

private static int count=0; 
public static void recursion(){
count++; 
recursion(); 
}

public static void main(String args[]){
try{
recursion();
} catch (Throwable e){
System.out.println("deep of calling="+count); 
e.printstackTrace();}
}
}
</code></pre> 
<h3 id="4.2%20%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><a id="42__603"></a>4.2 栈的存储单位</h3> 
<h4 id="4.2.1%20%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><a id="421__604"></a>4.2.1 栈中存储什么？</h4> 
<blockquote> 
 <ul><li>每个线程都有自己的栈，栈中的数据都是以<span style="color:#fe2c24;">栈帧（Stack Frame）</span>的格式存在。</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ul> 
</blockquote> 
<h4 id="4.2.2%20%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><a id="422__608"></a>4.2.2 栈运行原理</h4> 
<blockquote> 
 <ul><li>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</li><li><span style="color:#fe2c24;">在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</span></li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li><li><span style="color:#fe2c24;">如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</span></li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/06/02/BVgGR947_o.png"></p> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;">不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</span></li><li><span style="color:#fe2c24;">如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</span></li><li><span style="color:#fe2c24;">Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</span></li></ul> 
</blockquote> 
<h4 id="4.2.3%C2%A0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><a id="424__652"></a>4.2.3 栈帧的内部结构</h4> 
<blockquote> 
 <p><strong>每个栈帧中存储着:</strong></p> 
 <ul><li>局部变量表（Local Variables）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/22/f5/UAGShAIQ_o.png"><br> 并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/79/db/2FWTGX5G_o.png"></p> 
<h3 id="4.3%20%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8(Local%20Variables)"><a id="43_Local_Variables_663"></a>4.3 局部变量表(Local Variables)</h3> 
<blockquote> 
 <ul><li>局部变量表也被称之为局部变量数组或本地变量表</li><li>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，==因此不存在数据安全问题 ==</li><li>==<span style="color:#fe2c24;">局部变量表所需的容量大小是在编译期确定下来的</span>，<span style="color:#fe2c24;">==并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</span></li><li>方法嵌套调用的次数由栈的大小决定。一般来说，==栈越大，方法嵌套调用次数越多。==对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li>==局部变量表中的变量只在当前方法调用中有效。==在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul> 
</blockquote> 
<pre><code class="language-java">//使用javap -v 类.class 或者使用jclasslib
public class LocalVariableTest {

public static void main(String[] args) {
LocalVariableTest test=new LocalVariableTest();
int num=10;
test.test1();
}

public static void test1(){
Date date=new Date();
String name="xiaozhi";
}
}
</code></pre> 
<p>jclasslib截图说明如下:<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/08/eb/ofNEyPMQ_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a3/cc/KefAx6kY_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/94/32/OvmefvVB_o.png"></p> 
<h4 id="4.3.1%20%E5%85%B3%E4%BA%8ESlot%E7%9A%84%E7%90%86%E8%A7%A3"><a id="431_Slot_689"></a>4.3.1 关于Slot的理解</h4> 
<blockquote> 
 <ul><li>局部变量表，最基本的存储单元是Slot（变量槽）</li><li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li><li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li><li>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或doub1e类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a3/e4/j11AfMcl_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/58/e0/C1j3sZII_o.png"></p> 
<h4 id="4.3.2%20Slot%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8"><a id="432_Slot_703"></a>4.3.2 Slot的重复利用</h4> 
<blockquote> 
 <p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p> 
</blockquote> 
<pre><code class="language-java">public class SlotTest {

public void localVarl() {

int a = 0;

System.out.println(a);

int b = 0;

}

public void localVar2() {

int a = 0;
System.out.println(a);

}//此时的就会复用a的槽位int b = 0;

}
}
</code></pre> 
<h4 id="4.3.3.%20%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><a id="433__722"></a>4.3.3. 静态变量与局部变量的对比</h4> 
<blockquote> 
 <ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li><span style="color:#fe2c24;">我们知道类变量表有两次初始化的机会，第一次是在==“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”==阶段，赋予程序员在代码中定义的初始值。</span></li><li><span style="color:#fe2c24;">和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</span></li></ul> 
</blockquote> 
<pre><code class="language-java">//这样的代码是错误的，没有赋值不能够使用。
public void test(){int i;System. out. println(i);
}
</code></pre> 
<blockquote> 
 <p><strong>补充说明</strong></p> 
 <ul><li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li></ul> 
</blockquote> 
<h3 id="4.4.%20%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88Operand%20Stack%EF%BC%89"><a id="44_Operand_Stack_736"></a>4.4. 操作数栈（Operand Stack）</h3> 
<blockquote> 
 <ul><li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）</li><li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop） 
   <ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul></li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/7d/74/FStdyEvo_o.png"></p> 
<pre><code class="language-java">public void testAddOperation(){byte i = 15; int j = 8; int k = i + j;
}
</code></pre> 
<pre><code class="language-java">public void testAddOperation();
 Code:
0: bipush 15
2: istore_1 
3: bipush 8
5: istore_2 
6:iload_1 
7:iload_2 
8:iadd
9:istore_3 
10:return
</code></pre> 
<blockquote> 
 <ul><li>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</li><li><span style="color:#fe2c24;">每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</span></li><li>栈中的任何一个元素都是可以任意的Java数据类型 
   <ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li><li><span style="color:#fe2c24;">另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</span></li></ul> 
</blockquote> 
<h3 id="4.5.%20%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA"><a id="45__773"></a>4.5. 代码追踪</h3> 
<pre><code class="language-java">public void testAddOperation() {byte i = 15;int j = 8;int k = i + j;
}
</code></pre> 
<p><strong>使用javap 命令反编译class文件：javap -v 类名.class</strong></p> 
<pre><code class="language-java">public void testAddoperation(); 
Code:
0: bipush 15 
2: istore_1 
3: bipush 8
5: istore_2
6: iload_1
7: iload_2
8: iadd
9: istore_3
10: return
</code></pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/40/b4/0QS3hZET_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/38/01/VZrjXYNJ_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/df/38/Hv4iRUrL_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/d7/2f/975YgZKl_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/dc/73/MuKdGr3u_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/8f/5f/Yag9TQMG_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/13/c4/Iu0zfgxW_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/24/61/RdZF9GqX_o.png"></p> 
<h3 id="4.6.%20%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%EF%BC%88Top%20Of%20Stack%20Cashing%EF%BC%89%E6%8A%80%E6%9C%AF"><a id="46_Top_Of_Stack_Cashing_803"></a>4.6. 栈顶缓存技术（Top Of Stack Cashing）技术</h3> 
<blockquote> 
 <ul><li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></li></ul> 
</blockquote> 
<h3 id="4.7.%20%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88Dynamic%20Linking%EF%BC%89"><a id="47_Dynamic_Linking_806"></a>4.7. 动态链接（Dynamic Linking）</h3> 
<blockquote> 
 <ul><li>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</li><li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<span style="color:#fe2c24;">动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</span></li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/0c/91/y2d1slV4_o.png"></p> 
<blockquote> 
 <p><strong>为什么需要运行时常量池呢？</strong><br> 常量池的作用：就是为了提供一些符号和常量，便于指令的识别.<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/dd/31/xl0752Ed_o.png"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a3/d4/IyRYbGby_o.png"></p> 
</blockquote> 
<h3 id="4.8.%20%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><a id="48__817"></a>4.8. 方法的调用</h3> 
<blockquote> 
 <p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关.</p> 
</blockquote> 
<p><strong>静态链接:</strong></p> 
<blockquote> 
 <p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p> 
</blockquote> 
<p><strong>动态链接:</strong></p> 
<blockquote> 
 <p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p> 
</blockquote> 
<blockquote> 
 <p>静态链接和动态链接不是名词，而是动词，这是理解的关键。</p> 
</blockquote> 
<blockquote> 
 <p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<span style="color:#fe2c24;">绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</span></p> 
</blockquote> 
<p><strong>早期绑定:</strong></p> 
<blockquote> 
 <p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p> 
</blockquote> 
<p><strong>晚期绑定</strong></p> 
<blockquote> 
 <p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p> 
</blockquote> 
<blockquote> 
 <p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p> 
</blockquote> 
<blockquote> 
 <p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C语言中的虚函数（C中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p> 
</blockquote> 
<h4><a id="481__840"></a>4.8.1 虚方法和非虚方法</h4> 
<p><strong>非虚方法:</strong></p> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;">如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</span></li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。其他方法称为虚方法。</li></ul> 
</blockquote> 
<p>在类加载的解析阶段就可以进行解析，如下是非虚方法举例</p> 
<pre><code class="language-java">class Father{
public static void print(String str){
System. out. println("father "+str); 
}

private void show(String str){

System. out. println("father"+str);

}
}

class Son extends Father{

public class VirtualMethodTest{

public static void main(String[] args){
Son.print("coder");
//Father fa=new Father();
//fa.show("atguigu.com");}
}
</code></pre> 
<p>虚拟机中提供了以下几条方法调用指令：</p> 
<blockquote> 
 <p><strong>普通调用指令：</strong></p> 
 <ul><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>动态调用指令：</strong></p> 
 <ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul> 
</blockquote> 
<blockquote> 
 <p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</p> 
</blockquote> 
<pre><code class="language-java">/*** 解析调用中非虚方法、虚方法的测试*/
class Father {

public Father(){
System.out.println("Father默认构造器");
}

public static void showStatic(String s){
System.out.println("Father show static"+s);
}

public final void showFinal(){
System.out.println("Father show final");
}

public void showCommon(){
System.out.println("Father show common");
}
}

public class Son extends Father{

public Son(){super();}

public Son(int age){
this();
}

public static void main(String[] args) {
Son son = new Son();
son.show();
}

//不是重写的父类方法,因为静态方法不能被重写
public static void showStatic(String s){
System.out.println("Son show static"+s);
}

private void showPrivate(String s){
System.out.println("Son show private"+s);
}

public void show(){
//invokestaticshowStatic(" 大头儿子");
//invokestaticsuper.showStatic(" 大头儿子");
//invokespecialshowPrivate(" hello!");
//invokespecialsuper.showCommon();
//invokevirtual 因为此方法声明有final 不能被子类重写,所以也认为该方法是非虚方法showFinal();
//虚方法如下
//invokevirtualshowCommon();/
/没有显式加super,被认为是虚方法,因为子类可能重写
showCommoninfo();
MethodInterface in = null;
//invokeinterface  不确定接口实现类是哪一个 需要重写
in.methodA();
}

public void info(){}}

interface MethodInterface {void methodA();
}</code></pre> 
<blockquote> 
 <p><strong>关于invokednamic指令</strong></p> 
 <ul><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现「动态类型语言」支持而做的一种改进。</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li><li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>动态类型语言和静态类型语言</strong></p> 
 <ul><li>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</li><li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li><li><span style="color:#fe2c24;">Java是静态类型语言(尽管lambda表达式为其增加了动态特性),js,python是动态类型语言</span></li></ul> 
</blockquote> 
<pre><code class="language-java">	Java:String info = "小智";

//静态语言JS:
var name = "小智“；
var name = 10;

//动态语言Pythom: 
info = 130;//更加彻底的动态语言
</code></pre> 
<blockquote> 
 <p><strong>Java 语言中方法重写的本质：</strong></p> 
 <ul><li>pc寄存器每执行一条指令都会被改变,而返回地址在调用call之前一直是上一条call后面的地址,不改变</li><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>IllegalAccessError介绍</strong></p> 
 <ul><li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li></ul> 
</blockquote> 
<h4><a id="482__979"></a>4.8.2 方法的调用：虚方法表</h4> 
<blockquote> 
 <ul><li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。<span style="color:#fe2c24;">因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</span></li><li><span style="color:#fe2c24;">每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</span></li><li>虚方法表是什么时候被创建的呢？ 
   <ul><li>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</li></ul></li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/07/2a/E3QiPJCP_o.png"></p> 
<pre><code>interface Friendly{void sayHello();void sayGoodbye(); 
}
class Dog{public void sayHello(){}public String tostring(){return "Dog";}
}
class Cat implements Friendly {public void eat() {}public void sayHello() { } public void sayGoodbye() {}protected void finalize() {}
}
class CockerSpaniel extends Dog implements Friendly{public void sayHello() { super.sayHello();}public void sayGoodbye() {}
}
</code></pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/d9/d9/C28QzRsC_o.png"></p> 
<h3><a id="49_return_address_1017"></a>4.9. 方法返回地址（return address）</h3> 
<blockquote> 
 <ul><li>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式： 
   <ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li><li>本质上,方法的退出就是当前栈帧出栈的过程.此时,需要恢复上层方法的局部变量表,操作数栈,将返回值压入调用者栈帧的操作数栈,设置PC寄存器值等,让调用方法继续执行下去.</li><li>正常完成出口和异常完成出口的区别在于:通过异常完成出口退出的不会给他的上层调用者产生任何的返回值.</li></ul> 
</blockquote> 
<p><strong>当一个方法开始执行后，只有两种方式可以退出这个方法：</strong></p> 
<blockquote> 
 <ul><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口； 
   <ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul></li><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的<span style="color:#fe2c24;">异常表中没有搜索到匹配的异常处理器</span>，就会导致方法退出，简称异常完成出口。</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/70/c1/2R9FXFuC_o.png"></p> 
<p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/65/a3/gldGvKPL_o.png"></p> 
<blockquote> 
 <p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p> 
</blockquote> 
<blockquote> 
 <p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p> 
</blockquote> 
<h3><a id="410__1040"></a>4.10 一些附加信息</h3> 
<blockquote> 
 <p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/de/25/vtMKRgoa_o.png"><br><strong>栈的相关面试题</strong></p> 
<blockquote> 
 <ul><li>栈溢出的情况?栈溢出:StackOverflowError 
   <ul><li><span style="color:#fe2c24;">栈中是不存在GC的,存在OOM和StackOverflowError</span></li><li>举个简单的例子:在main方法中调用main方法,就会不断压栈执行,直到栈溢出;</li></ul></li><li>栈的大小可以是固定大小的,也可以是动态变化(动态扩展)的 
   <ul><li>如果是固定的,那么会抛出StackOverflowError</li><li>如果是动态扩展的,那么会抛出OOM异常(java.lang.OutOfMemoryError)</li></ul></li><li>举例栈溢出的情况？（StackOverflowError） 
   <ul><li>通过 -Xss设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？ 
   <ul><li>不能。因为调整栈大小,只会减少出现溢出的可能,栈大小不是可以无限扩大的,所以不能保证不出现溢出</li></ul></li><li>分配的栈内存越大越好么？ 
   <ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li><span style="color:#fe2c24;">垃圾回收是否涉及到虚拟机栈？</span> 
   <ul><li><span style="color:#fe2c24;">不会;垃圾回收只会涉及到方法区和堆中,方法区和堆也会存在溢出的可能</span></li><li><span style="color:#fe2c24;">程序计数器,只记录运行下一行的地址,不存在溢出和垃圾回收</span></li><li><span style="color:#fe2c24;">虚拟机栈和本地方法栈,都是只涉及压栈和出栈,可能存在栈溢出,不存在垃圾回收</span></li></ul></li><li>方法中定义的局部变量是否线程安全？ 
   <ul><li>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul></li></ul> 
</blockquote> 
<pre><code class="language-java">/**方法中定义的局部变量是否线程安全?   具体问题具体分析
* @author shkstart* @create 15:53
*/
public class LocalVariableThreadSafe {

//s1的声明方式是线程安全的,因为线程私有,在线程内创建的s1 ,不会被其它线程调用
public static void method1() {
//StringBuilder:线程不安全
StringBuilder s1 = new StringBuilder();
s1.append("a");
s1.append("b");
//...}

//stringBuilder的操作过程:是线程不安全的,
// 因为stringBuilder是外面传进来的,有可能被多个线程调用
public static void method2(StringBuilder stringBuilder) {
stringBuilder.append("a");
stringBuilder.append("b");
//...}

//stringBuilder的操作:是线程不安全的；因为返回了一个stringBuilder,
// stringBuilder有可能被其他线程共享
public static StringBuilder method3() {
StringBuilder stringBuilder = new StringBuilder();
stringBuilder.append("a");
stringBuilder.append("b");
return stringBuilder;
}

//stringBuilder的操作:是线程安全的；因为返回了一个stringBuilder.toString()相当于new了一个String,
// 所以stringBuilder没有被其他线程共享的可能
public static String method4() {
StringBuilder stringBuilder = new StringBuilder();
stringBuilder.append("a");
stringBuilder.append("b");
return stringBuilder.toString();
/*** 结论:如果局部变量在内部产生并在内部消亡的,那就是线程安全的*/
}
}</code></pre> 
<table><thead><tr><th>运行时数据区</th><th>是否存在Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>否</td></tr><tr><td>虚拟机栈</td><td>是（SOE）</td><td>否</td></tr><tr><td>本地方法栈</td><td>是</td><td>否</td></tr><tr><td>方法区</td><td>是（OOM）</td><td>是</td></tr><tr><td>堆</td><td>是</td><td>是</td></tr></tbody></table> 
<h2 id="%E4%BA%94%20%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><a id="__1118"></a>五 本地方法接口和本地方法栈</h2> 
<h3><a id="51__1119"></a>5.1. 本地方法接口</h3> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/60/2a/4w9Uj18F_o.png"><br><strong>什么是本地方法？</strong></p> 
<blockquote> 
 <p>简单地讲，一个Native Method是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C中，你可以用extern “c” 告知c编译器去调用一个c的函数。</p> 
</blockquote> 
<blockquote> 
 <p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;">本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</span></p> 
</blockquote> 
<pre><code class="language-java">//标识符native可以与其它java标识符连用，但是abstract除外
public class IHaveNatives{

public native void methodNative1(int x);

public native static long methodNative2();

private native synchronized float methodNative3(Object o);

native void methodNative4(int[] ary) throws Exception;
}
</code></pre> 
<p><strong>为什么使用Native Method？</strong></p> 
<blockquote> 
 <p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p> 
</blockquote> 
<p><strong>与Java环境的交互</strong></p> 
<blockquote> 
 <p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p> 
</blockquote> 
<p><strong>与操作系统的交互</strong></p> 
<blockquote> 
 <p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p> 
</blockquote> 
<p><strong>Sun’s Java</strong></p> 
<blockquote> 
 <p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority() ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p> 
</blockquote> 
<p><strong>现状</strong></p> 
<blockquote> 
 <p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p> 
</blockquote> 
<h3><a id="52__1152"></a>5.2. 本地方法栈</h3> 
<blockquote> 
 <ul><li>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</li><li><span style="color:#fe2c24;">本地方法栈，也是线程私有的。</span></li><li>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的） 
   <ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</li></ul></li><li>本地方法是使用C语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/3c/ab/AE30tfXL_o.png"></p> 
<blockquote> 
 <ul><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。 
   <ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ul> 
</blockquote> 
<h2 id="6.%20%E5%A0%86"><a id="6___1169"></a>六. 堆</h2> 
<h3><a id="61_Heap_1170"></a>6.1. 堆（Heap）的核心概述</h3> 
<blockquote> 
 <p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/b5/58/9cboEsZn_o.png"></p> 
<blockquote> 
 <ul><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li><li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。 
   <ul><li>堆内存的大小是可以调节的。</li></ul></li><li><span style="color:#fe2c24;">《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</span></li><li><strong><span style="color:#fe2c24;">所有的线程共享Java堆，</span><span style="color:#511b78;">在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）</span><span style="color:#fe2c24;">。</span></strong></li><li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</li><li><span style="color:#fe2c24;">数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</span></li><li><span style="color:#fe2c24;">在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</span></li><li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li></ul> 
</blockquote> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/30/14/BcECnHnU_o.png"></p> 
<h4 style="text-align:center;"><a id="611__1185"></a><img alt="" src="https://images2.imgbox.com/f8/30/hhQPcNEC_o.png"></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/94/2b/AjkAVjLG_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/e5/8f/E5OM9DJF_o.png"></p> 
<h3>6.2. 设置堆内存大小与OOM</h3> 
<blockquote> 
 <p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项"-Xmx"和"-Xms"来进行设置。<br> “-xms"用于表示堆区的起始内存，等价于-XX: InitialHeapsize“ -Xmx"则用于表示堆区的最大内存，等价于-XX:MaxHeapsize<br> 一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时，将会抛出OutOfMemoryError异常。<br> 通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。<br> 默认情况下，初始内存大小:物理电脑内存大小/64。最大内存大小:物理电脑内存大小/ 4</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/81/2c/2pVMNND6_o.png"></p> 
<pre><code class="language-java">/**
 * 1. 设置堆空间大小的参数
 * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小
 *      -X 是jvm的运行参数
 *      ms 是memory start
 * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小
 *
 * 2. 默认堆空间的大小
 *    初始内存大小：物理电脑内存大小 / 64
 *             最大内存大小：物理电脑内存大小 / 4
 * 3. 手动设置：-Xms600m -Xmx600m
 *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。
 *
 * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id
 *                  方式二：-XX:+PrintGCDetails
 * @author shkstart  shkstart@126.com
 * @create 2020  20:15
 */
public class HeapSpaceInitial {
    public static void main(String[] args) {

        //返回Java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        //返回Java虚拟机试图使用的最大堆内存量
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;

        System.out.println("-Xms : " + initialMemory + "M");
        System.out.println("-Xmx : " + maxMemory + "M");

//        System.out.println("系统内存大小为：" + initialMemory * 64.0 / 1024 + "G");
//        System.out.println("系统内存大小为：" + maxMemory * 4.0 / 1024 + "G");

        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
<p>-Xmx600M -Xms600M -XX:+PrintGCDetails</p> 
<p><img alt="" src="https://images2.imgbox.com/c4/46/OVy1qJz3_o.png"><br> 明明设置的600M，为啥打印出来只有575M？<br> 新生代中survival区只有一部分被正在使用了，另一部分空闲。<br> （179200+409600）/1024=575<br> （179200+409600+25600）/1024=600</p> 
<p><img alt="" src="https://images2.imgbox.com/67/7b/te1rvxXo_o.png"><br> S0C:S0区的总容量 S0U:S0区已使用的容量</p> 
<p></p> 
<p><strong>给jvisualvm安装Visual GC插件</strong><br> 打开jvisualvm以后，点击工具—&gt;插件—&gt;可用插件----&gt;找到对应版本的Visual GC<br> 使用的是JDK8版本，对应的Visual GC是2.1.2，因为直接安装插件已经不行了，所以去官网下载插件后安装<br> https://visualvm.github.io/download.html</p> 
<p><img alt="" src="https://images2.imgbox.com/b1/bd/U138cM4I_o.png"><br> 点击上述红框中的链接，跳转到下面这个界面，找到自己对应的JDK版本 <img alt="" src="https://images2.imgbox.com/36/65/gFzf5KSu_o.png"></p> 
<p>找到想要下载的Visual GC 2.1.2 版本</p> 
<p><img alt="" src="https://images2.imgbox.com/e4/68/i1HxAQR0_o.png"><br> 下载完成后将安装包放到jdk安装目录的bin目录下</p> 
<p><img alt="" src="https://images2.imgbox.com/7b/30/z7U9jFL1_o.png"> 然后打开jvisualvm安装插件即可。</p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/98/73/QKWS3NXn_o.png"></p> 
<h3> <br> 6.3. 年轻代与老年代</h3> 
<blockquote> 
 <p>存储在JVM中的Java对象可以被划分为两类:<br> 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<br> 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。<br> Java堆区进一步细分的话，可以划分为年轻代(YoungGen)和老年代(oldGen)其中年轻代又可以划分为Eden空间、Survivor0空间和survivor1空间（有时也叫做from区、to区) 。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/63/c8/hmRD2equ_o.png"></p> 
<blockquote> 
 <p>配置新生代与老年代在堆结构的占比，一般情况下采用默认即可不用刻意修改。<br> 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3<br> 可以修改-XX :NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p> 
</blockquote> 
<blockquote> 
 <p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8:1:1·当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8<br> 几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了</p> 
 <p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。<br> 可以使用选项”-Xmn"设置新生代最大内存大小。这个参数一般使用默认值就可以了。</p> 
 <p>-XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.<br> -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8<br> -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略 （暂时用不到）<br> -Xmn:设置新生代的最大内存。 （一般不设置）</p> 
</blockquote> 
<h3>6.4. 图解对象分配过程</h3> 
<blockquote> 
 <p><br><strong>对象分配过程概述：</strong></p> 
 <p></p> 
 <p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑Gc执行完内存回收后是否会在内存空间中等生内存碎片。<br> 1）new的对象先放伊甸园区。此区有大小限制。<br> 2）当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区<br> 3）然后将伊甸园中的剩余对象移动到幸存者0区。<br> 4）如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。<br> 5）如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。<br> 6）啥时候能去养老区呢?可以设置次数。默认是15次。可以设置参数:-XX:MaxTenuringThreshold=进行设置。<br> 7）在养老区，相对悠闲。当养老区内存不足时，再次触发GC: Major GC，进行养老区的内存清理。<br> 8）若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/07/fDLzqkUg_o.png"></p> 
<blockquote> 
 <p>总结:<br> 针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to.<br> 关于垃圾回收:频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/96/86/E6vTccB3_o.png"></p> 
<h3>6.5. Minor GC、Major GC与Full GC</h3> 
<blockquote> 
 <p>JVM在进行Gc时，并非每次都对上面三个内存(新生代、老年代方法区)区域一起回收的，大部分时候回收的都是指新生代。<br> 针对HotSpot VM的实现，它里面的Gc按照回收区域又分为两大种类型:一种是部分收集(Partial Gc) ，一种是整堆收集（Full GC)<br> 部分收集:不是完整收集整个Java堆的垃圾收集。其中又分为:<br> 新生代收集（Minor GC / Young GC):只是新生代(Eden\S0,S1）的垃圾收集<br> 老年代收集（Major GO / Old GO）:只是老年代的垃圾收集。<br> 目前，只有CMS GC会有单独收集老年代的行为。<br> 注意，很多时候Major GC会和Full Gc混淆使用,需要具体分辨是老年代回收还是整堆回收。<br> 混合收集（Mixed GC):收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为<br> 整堆收集（Full GC):收集整个java堆和方法区的垃圾收集。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>年轻代GC(Minor GC)触发机制:</strong></span><br> 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会引发GC。(每次Minor GC会清理年轻代的内存,Minor GC清理Eden区内存时会顺带把Survivor区内存垃圾也清理掉)<br> 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。<br> Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>老年代GC (Major GC/Full GC)触发机制:</strong></span><br> 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。<br> 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。<br> 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC<br> Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。如果Major GC后，内存还不足，就报OOM了。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>Full GC触发机制:（后面细讲)触发Full GC执行的情况有如下五种:</strong></span><br> (1）调用system.gc()时，系统建议执行Full GC，但是不必然执行<br> (2）老年代空间不足<br> (3）方法区空间不足<br> (4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存<br> (5）由Eden区、survivor space0 (From Space)区向survivor space1 (ToSpace）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小<br> 说明: Full GC是开发豉调优中尽量要避免的。这样暂时时间会短一些。</p> 
</blockquote> 
<h3>6.6. 堆空间分代思想</h3> 
<blockquote> 
 <p>为什么需要把Jaya堆分代?不分代就不能正常工作了吗?经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。<br> 新生代:有Eden、两块大小相同的survivor (又称为from/to，s0/s1)构成，to总为空。<br> 老年代:存放新生代中经历多次GC仍然存活的对象。</p> 
 <p>其实不分代完全可以，分代的唯一理由就是优化cc性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用,这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p> 
</blockquote> 
<h3>6.7. 内存分配策略（或对象提升(Promotion)规则)</h3> 
<blockquote> 
 <p><br> 如果对象在Eden 出生并经过第一次MinorGC后仍然存活，并且能被survivor容纳的话，将被移动到survivor 空间中，并将对象年龄设为1 。对象在survivor区中每熬过一次Minor GC ,年龄就增加1岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p> 
 <p>对象晋升老年代的年龄阈值，可以通过选项-XX:MaxTenuringThreshold来设置。</p> 
 <p>针对不同年龄段的对象分配原则如下所示:优先分配到Eden<br> 大对象直接分配到老年代<br> 尽量避免程序中出现过多的大对象。长期存活的对象分配到老年代。</p> 
 <p>动态对象年龄判断<br> 如果survivor区中相同年龄的所有对象大小的总和大于survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p> 
 <p>空间分配担保，-XX :HandlePromotionFailure</p> 
</blockquote> 
<h3>6.8. 为对象分配内存:TLAB</h3> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>为什么有TLAB ((Thread Local Allocation Buffer ) ?</strong></span><br> 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据<br> 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的<br> 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>什么是TLAB?</strong></span><br> 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。<br> 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，<br> 同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。<br> 据我所知所有openJDK衍生出来的JVM都提供了TLAB的设计。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>TLAB的再说明:</strong></span><br> 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。<br> 在程序中，开发人员可以通过选项“-xX:UseTLAB”设置是否开启TLAB空间。<br> 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TABwasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。<br> 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p> 
</blockquote> 
<h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/89/b8/xNEewuoU_o.png"></h3> 
<h3>6.9. 小结堆空间的参数设置</h3> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>测试堆空间常用的jvm参数：</strong></span><br> -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值<br> -XX:+PrintFlagsFinal ：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>具体查看某个参数的指令： jps：查看当前运行中的进程</strong></span><br> jinfo -flag SurvivorRatio 进程id</p> 
</blockquote> 
<blockquote> 
 <p>-Xms：初始堆空间内存 （默认为物理内存的1/64）<br> -Xmx：最大堆空间内存（默认为物理内存的1/4）<br> -Xmn：设置新生代的大小。(初始值及最大值)<br> -XX:NewRatio：配置新生代与老年代在堆结构的占比<br> -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例<br> -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄<br> -XX:+PrintGCDetails：输出详细的GC处理日志<br> 打印gc简要信息：① -XX:+PrintGC ② -verbose:gc</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>-XX:HandlePromotionFailure：是否设置空间分配担保</strong></span></p> 
 <p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。<br> 如果大于，则此次Minor GC是安全的<br> 如果小于，则虚拟机会查看-xX:HandlePromotionFailure设置值是否允许担保失败。<br> 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。<br> 如果大于，则尝试进行一次Minor GC，但这次Minor Gc依然是有风险的;<br> 如果小于，则改为进行一次Full GC。<br> 如果HandlePromotionFailure=false，则改为进行一次Full GC。<br> 在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p> 
</blockquote> 
<h3>6.10. 堆是分配对象存储的唯一选择吗?</h3> 
<blockquote> 
 <p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述:<br> 随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，<span style="color:#fe2c24;"><strong>所有的对象都分配到堆上也渐渐变得不那么“绝对”了</strong></span>。<br> 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<span style="color:#fe2c24;">如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</span>。<span style="color:#fe2c24;">这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</span><br> 此外，前面提到的基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且cc不能管理GCIH内部的Java对象，以此达到降低cc的回收频率和提升Gc的回收效率的目的。</p> 
</blockquote> 
<blockquote> 
 <p><strong>逃逸分析概述</strong><br> 如何将堆上的对象分配到栈，需要使用逃逸分析手段。<br> 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。<br> 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。<br> 逃逸分析的基本行为就是分析对象动态作用域:<br> 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。<br> 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p> 
 <p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。</p> 
</blockquote> 
<pre><code class="language-java">/**
 * 逃逸分析
 *
 *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。
 * @author shkstart
 * @create 2020 下午 4:00
 */
public class EscapeAnalysis {

    public EscapeAnalysis obj;

    /*
    方法返回EscapeAnalysis对象，发生逃逸
     */
    public EscapeAnalysis getInstance(){
        return obj == null? new EscapeAnalysis() : obj;
    }
    /*
    为成员属性赋值，发生逃逸
     */
    public void setObj(){
        this.obj = new EscapeAnalysis();
    }
    //思考：如果当前的obj引用声明为static的？仍然会发生逃逸。

    /*
    对象的作用域仅在当前方法中有效，没有发生逃逸
     */
    public void useEscapeAnalysis(){
        EscapeAnalysis e = new EscapeAnalysis();
    }
    /*
    引用成员变量的值，发生逃逸
     */
    public void useEscapeAnalysis1(){
        EscapeAnalysis e = getInstance();
        //getInstance().xxx()同样会发生逃逸
    }
}</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/a9/e2/KNJERr3e_o.png"></p> 
<p></p> 
<blockquote> 
 <p><strong>参数设置:</strong><br> 在JDK 6u23版本之后，HotSpot中默认就已经开启了逃逸分析。.如果使用的是较早的版本，开发人员则可以通过:<br> 选项“一xX: +DoEscapeAnalysis"显式开启逃逸分析<br> 通过选项“一XX:+PrintEscapeAnalysis"查看逃逸分析的筛选结果。</p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p>结论:<br><span style="color:#fe2c24;"><strong>开发中能使用局部变量的，就不要使用在方法外定义。</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><strong>使用逃逸分析，编译器可以对代码做如下优化:</strong><br><strong>1)、栈上分配</strong>。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。<br><strong>2)、同步省略</strong>。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。<br><strong>3)、分离对象或标量替换</strong>。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p> 
</blockquote> 
<blockquote> 
 <p><strong>代码优化之栈上分配</strong></p> 
 <p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行,I最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p> 
 <p><strong>常见的栈上分配的场景</strong><br> 在逃逸分析中，已经说明了。会发生逃逸现象的场景分别是给成员变量赋值、方法返回值、实例引用传递。</p> 
</blockquote> 
<blockquote> 
 <p><strong>代码优化之同步省略（锁消除)</strong></p> 
 <p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。<br> 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/08/a9/KusoGl4V_o.png"></p> 
<p></p> 
<blockquote> 
 <p><strong>代码优化之标量替换</strong><br> 标量(Scalar)是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。<br> 相对的，那些还可以分解的数据叫做聚合量(Aggregate), Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。<br> 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。<br><strong>标量替换参数设置︰</strong><br><span style="color:#fe2c24;">参数-XX:+EliminateAllocations:开启了标量替换(默认打开)，允许将对象打散分配在栈上。</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d8/c9/mJXR1pC4_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ec/19/9F3tOfcq_o.png"></p> 
<p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生 GC。使用如下参数运行上述代码:<br> -server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+Printcc -XX:+EliminateAl1Gcations<br> 这里使用参数如下:<br> 参数-server:启动server模式，因为在server模式下，才可以启用逃逸分析。·参数-XX:+DoEscapeAnalysis:启用逃逸分析<br> 参数-Xmx10m:指定了堆空间最大为10MB<br> 参数-XX:+PrintGC:将打印Gc日志。<br> 参数-XX:+EliminateAllocations:开启了标量替换(默认打开)，允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配。</p> 
<p><span style="color:#fe2c24;">HotSpot中并未开启栈上分配，但是开启了标量替换。逃逸分析也是默认打开的。</span><br><img alt="" src="https://images2.imgbox.com/76/1b/ED65Ekuz_o.png"></p> 
<h2> 七. 方法区</h2> 
<h3>7.1. 栈、堆、方法区的交互关系</h3> 
<blockquote> 
 <p><strong>大厂面试题</strong><br> 说一下JVM内存模型吧，有哪些区?分别干什么的?<br> Java8的内存分代改进<br> JVM内存分哪几个区，每个区的作用是什么?<br> JVM内存分布/内存结构?栈和堆的区别?堆的结构?为什么两个survivor区?<br> Eden和survior的比例分配<br> jvm内存分区，为什么要有新生代和老年代<br> Java的内存分区<br> 讲讲jvm运行时数据库区什么时候对象会进入老年代?<br> VM的内存结构，Eden和survivor比例。<br> VM内存为什么要分成新生代，老年代，持久代。<br> 新生代中为什么要分为Eden和survivor。<br> Jvm内存模型以及分区，需要详细到每个区放什么。<br> JVM的内存模型，Java8做了什么修改<br> JVM内存分哪几个区，每个区的作用是什么?<br> java内存分配<br> jvm的永久代中会发生垃圾回收吗?<br> jvm内存分区，为什么要有新生代和老年代?</p> 
</blockquote> 
<h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/39/b6/nDFJoIf8_o.png"></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f6/dd/Z8OsmFhS_o.png"></p> 
<p></p> 
<h3>7.2. 方法区的理解</h3> 
<blockquote> 
 <p>《Java虚拟机规范》中明确说明:“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。<br> 所以，方法区看作是一块独立于Java堆尚内存空间。</p> 
</blockquote> 
<blockquote> 
 <p><img alt="" src="https://images2.imgbox.com/d7/14/x2EYOM7s_o.png"><br> 方法区(Method Area）与Java堆一样，是各个线程共享的内存区域。<br> 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。<br> 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java.lang. outOfMemoryError:PermGen spacel或者java.lang.outOfMemoryError: Metaspace。加载大量的第三方的jar包;Tomcat部署的工程过多（30-50个)﹔大量动态的生成反射类<br> 关闭JVM就会释放这个区域的内存。</p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p><strong>Hotspot中方法区的演进</strong><br> 在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。<br> ln JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace<br> 本质上，方法区和永久代并不等价。仅是对hotspot而言的。<span style="color:#fe2c24;">《Java虚拟机规范》对如何实现方法区，不做统一要求。</span>例如:BEA JRockit/ IBM J9中不存在永久代的概念。<br> 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易ooM（超过-XX:MaxPermSize上限)</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b3/e0/iUaefOhG_o.png"></p> 
 <p></p> 
 <p>而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p> 
 <p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于:元空间不在虚拟机设置的内存中，<br> 而是使用本地内存。<br> 永久代、元空间二者并不只是名字变了，内部结构也调整了。<br> 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</p> 
</blockquote> 
<h3>7.3.设置方法区大小与OOM</h3> 
<blockquote> 
 <p>jdk8及以后:<br> 元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定。</p> 
 <p>默认值依赖于平台。windows下，-XX:Metaspacesize是21M，-XX:MaxMetaspaceSize 的值是-1，即没有限制</p> 
 <p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError: Metaspace<br> -XX:MetaspaceSize:设置初始的元空间大小。对于一个64位的服务器端JVM来说,其默认的-XX:Metaspacesize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full Gc将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）,然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。<br> 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地Gc ，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p> 
</blockquote> 
<h3>7.4. 方法区的内部结构</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4d/86/wDCAFtbQ_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5c/d5/yvph1cK2_o.png"><img alt="" src="https://images2.imgbox.com/56/fe/dUgczok3_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b5/17/qg2UyEHm_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/80/c8/Ge0AP8tc_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/f1/25/KvNa25ed_o.png"> <span style="color:#fe2c24;"><strong>运行时常量池和常量池</strong></span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b4/73/l6OVWr2d_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0b/38/gqpUC9Lo_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fa/7b/fzLRyes0_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d6/37/kubKWNSE_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/32/32/0GJJNjEX_o.png"></p> 
<h3>7.5. 方法区的演进细节</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cd/c4/Y94Mf0Qs_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0d/49/ZssrVVOh_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c3/04/vffnAYpP_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/08/b0/enJE6ZBa_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/70/9b/XplZfT2w_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/52/70/qGpZhT0N_o.png"><span style="color:#fe2c24;"><strong> 静态引用对应的对象实体始终都存在堆空间。</strong></span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a3/9c/J3FVl4Vi_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/76/6b/aAbkAOoI_o.png"></p> 
<h3> 7.6. 方法区的垃圾收集</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8e/66/9Hp8z21b_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/50/3d/EB1wKHjg_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1f/8d/FIx0PZIf_o.png"></p> 
<p><br><strong>总结</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/92/ee/hpen9qUw_o.png"></strong></p> 
<p></p> 
<h2>八. 对象的实例化、内存布局与访问定位、直接内存</h2> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>大厂面试题</strong></span><br> 对象在JVM中是怎么存储的?对象头信息里面有哪些东西?<br> java对象头里有什么</p> 
</blockquote> 
<h3>8.1. 对象的实例化 </h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9e/73/tYvVT4m6_o.png"></p> 
<p></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>对象实例化步骤：</strong></span></p> 
 <p></p> 
 <p>①虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(<span style="color:#fe2c24;">即判断类元信息是否存在</span>)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class 类对象</p> 
 <p></p> 
 <p>②首先计算对象占用空间大小少，接着在堆中划分一块内存给新对象。<br> 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。</p> 
 <p></p> 
 <p>③<span style="color:#fe2c24;">如果内存是规整的，那么虚拟机将采用的是指针碰撞法(Bump The Pointer )来为对象分配内存</span>。<br> 意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact(整理)过程的收集器时，使用指针碰撞。</p> 
 <p></p> 
 <p>④<span style="color:#fe2c24;">如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存</span>。<br> 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表(Free List ) ".</p> 
 <p></p> 
 <p>⑤选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p> 
 <p></p> 
 <p>⑥将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p> 
 <p></p> 
 <p>⑦在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p> 
</blockquote> 
<h3>8.2. 对象的内存布局</h3> 
<p><img alt="" src="https://images2.imgbox.com/bc/21/KzVw8xpx_o.png"></p> 
<pre><code class="language-java">/**
 * 测试对象实例化的过程
 *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）
 *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化
 *
 *  给对象的属性赋值的操作：
 *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化
 * @author shkstart  shkstart@126.com
 * @create 2020  17:58
 */

 

public class Customer{
    int id = 1001;
    String name;
    Account acct;

    {
        name = "匿名客户";
    }
    public Customer(){
        acct = new Account();
    }

}
class Account{

}</code></pre> 
<p></p> 
<pre><code class="language-java">public class CustomerTest {
    public static void main(String[] args) {
        Customer cust = new Customer();
    }
}</code></pre> 
<p><strong>CustomerTest 的main方法发生了什么？</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/67/57/hJ8HHggM_o.png"></p> 
<p></p> 
<h3>8.3. 对象的访问定位</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c5/74/xA2uQXZZ_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/9e/1x6rEvTF_o.png"></p> 
<p><strong>句柄访问方式： </strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/92/f7/v9pbsB5d_o.png"></p> 
<p><strong>直接指针方式：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2a/34/6qYyhOWQ_o.png"></p> 
<p></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>句柄访问与直接指针访问的优劣：</strong></span></p> 
 <p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。</p> 
 <p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访 问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，HotSpot主要使用第二种方式进行对象访问。</p> 
</blockquote> 
<p></p> 
<h3>8.4. 直接内存</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c8/97/8Wp5cqQp_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7e/8c/3qj8C6Qb_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/85/5c/6B8ZT6sw_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/94/8a/30LNOQJD_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/eb/7b/CIR3cdhz_o.png"></p> 
<h2>九.JVM之执行引擎</h2> 
<h3>9.1.执行引擎概述</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5e/fe/cYOiNp6a_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/15/3b/hSX1MaXn_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/21/16/VYvkcwuG_o.png"></p> 
<blockquote> 
 <p>将java文件编译成class文件称为<span style="color:#fe2c24;">前端编译(javac)</span>，在执行引擎中将字节码编译成机器指令称为<span style="color:#fe2c24;">后端编译</span>。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/22/27/ehBQHL0j_o.png"><br>  </p> 
<h3>9.2. Java代码编译和执行的过程</h3> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/36/74/9Gnvr2sZ_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f6/ae/WnTv9hAT_o.png"><img alt="" src="https://images2.imgbox.com/0f/8e/ZWDvBllQ_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/26/8d/9ykv9rAg_o.png"></p> 
<h3><img alt="" src="https://images2.imgbox.com/d5/a3/LOvOR8fY_o.png"> <br> 9.3. 机器码、指令、汇编语言</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0e/c1/oxVPhEYl_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bb/33/NnAeJaHL_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5b/4d/FyLFqr5t_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bc/5a/QPQbvR5U_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/be/c3/Gw6S5AtP_o.png"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">高级语言需要先翻译成汇编语言，汇编语言再翻译成机器指令</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/52/30/Y5tec1fo_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7a/92/6uNoZxLh_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0e/cf/BVbs754Z_o.png"></p> 
<h3>9.4. 解释器</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/58/b5/4sOLdIlo_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8f/04/ewkDEOkZ_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/98/54/li6jqLn6_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/43/2e/Yqfacv40_o.png"></p> 
<h3>9.5. JIT编译器</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/14/85/yifJUqdB_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e4/ab/98WPB3nn_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b0/10/UVsp73xf_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/03/ba/ksdnklKW_o.png"><img alt="" src="https://images2.imgbox.com/39/ac/YJrWBswD_o.png"> </p> 
<p><img alt="" src="https://images2.imgbox.com/f2/62/Gg4AXopm_o.png"><img alt="" src="https://images2.imgbox.com/20/3b/LJPOaEHV_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0d/6a/hs2csRel_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0f/69/1wJVkqa0_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/32/27/aJVrGNej_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e9/a9/tD61oISB_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1a/96/SxyB8Zlf_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5a/b7/B9V345sE_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/16/0c/THPntaCL_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6c/31/eLpegE2Y_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4b/9c/QqV7HslQ_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d6/f3/ZrFmwchf_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f2/2d/XJq1BW5e_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/35/a2/CUv5tYPH_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6c/47/W5owSf3d_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/81/9b/mhucBgti_o.png"></p> 
<h2>十.StringTable</h2> 
<h3>10.1. String的基本特性</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2d/d4/5nhnaSw2_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0d/d2/mYh8NrTR_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c4/9c/CzjjGNrn_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/63/62/k6VwYKK6_o.png"></p> 
<h3>10.2. String的内存分配</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/2f/6Venfaqc_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/93/f3/gY6U7QyP_o.png"></p> 
<p></p> 
<blockquote> 
 <p>使用String的intern方法可以把字符串加入到字符串常量池。同时可以使用该方法来证明JDK8中字符串常量池存储在堆里面。</p> 
</blockquote> 
<pre><code class="language-java">/**
 * jdk6中：
 * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m
 *
 * jdk8中：
 * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m
 * @author shkstart  shkstart@126.com
 * @create 2020  0:36
 */
public class StringTest3 {
    public static void main(String[] args) {
        //使用Set保持着常量池引用，避免full gc回收常量池行为
        Set&lt;String&gt; set = new HashSet&lt;String&gt;();
        //在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。
        short i = 0;
        while(true){
            set.add(String.valueOf(i++).intern());
        }
    }
}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/39/a2/0Lu4z3SX_o.png"><br><br>  </p> 
<h3 style="text-align:center;"><br> 10.3. String的基本操<img alt="" src="https://images2.imgbox.com/4e/f5/pHx7IXyv_o.png">作</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bf/b9/LGz3ZNjq_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fd/9a/TKS8FUGY_o.png"></p> 
<h3>10.4.字符串的拼接操作</h3> 
<p><img alt="" src="https://images2.imgbox.com/18/fe/p5lwUT5b_o.png"></p> 
<blockquote> 
 <p>如下的s1 + s2 的执行细节：(变量s是我临时定义的）<br> ① StringBuilder s = new StringBuilder();<br> ② s.append(“a”)<br> ③ s.append(“b”)<br> ④ s.toString() --&gt; 约等于 new String(“ab”)</p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p>补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer<br> 1) 字符串拼接操作不一定使用的是StringBuilder!<br>    如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。<br> 2) 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。<br>  </p> 
</blockquote> 
<pre><code class="language-java">package com.atguigu.java1;

import org.junit.Test;

/**
 * 字符串拼接操作
 * @author shkstart  shkstart@126.com
 * @create 2020  0:59
 */
public class StringTest5 {
    @Test
    public void test1(){
        String s1 = "a" + "b" + "c";//编译期优化：等同于"abc"
        String s2 = "abc"; //"abc"一定是放在字符串常量池中，将此地址赋给s2
        /*
         * 最终.java编译成.class,再执行.class
         * String s1 = "abc";
         * String s2 = "abc"
         */
        System.out.println(s1 == s2); //true
        System.out.println(s1.equals(s2)); //true
    }

    @Test
    public void test2(){
        String s1 = "javaEE";
        String s2 = "hadoop";

        String s3 = "javaEEhadoop";
        String s4 = "javaEE" + "hadoop";//编译期优化
        //如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop
        String s5 = s1 + "hadoop";
        String s6 = "javaEE" + s2;
        String s7 = s1 + s2;

        System.out.println(s3 == s4);//true
        System.out.println(s3 == s5);//false
        System.out.println(s3 == s6);//false
        System.out.println(s3 == s7);//false
        System.out.println(s5 == s6);//false
        System.out.println(s5 == s7);//false
        System.out.println(s6 == s7);//false
        //intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；
        //如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。
        String s8 = s6.intern();
        System.out.println(s3 == s8);//true
    }

    @Test
    public void test3(){
        String s1 = "a";
        String s2 = "b";
        String s3 = "ab";
        /*
        如下的s1 + s2 的执行细节：(变量s是我临时定义的）
        ① StringBuilder s = new StringBuilder();
        ② s.append("a")
        ③ s.append("b")
        ④ s.toString()  --&gt; 约等于 new String("ab")

        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer
         */
        String s4 = s1 + s2;//
        System.out.println(s3 == s4);//false
    }
    /*
    1. 字符串拼接操作不一定使用的是StringBuilder!
       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。
    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。
     */
    @Test
    public void test4(){
        final String s1 = "a";
        final String s2 = "b";
        String s3 = "ab";
        String s4 = s1 + s2;
        System.out.println(s3 == s4);//true
    }
    //练习：
    @Test
    public void test5(){
        String s1 = "javaEEhadoop";
        String s2 = "javaEE";
        String s3 = s2 + "hadoop";
        System.out.println(s1 == s3);//false

        final String s4 = "javaEE";//s4:常量
        String s5 = s4 + "hadoop";
        System.out.println(s1 == s5);//true

    }

    /*
    体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！
    详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象
          使用String的字符串拼接方式：创建过多个StringBuilder和String的对象
         ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。

     改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：
               StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]
     */
    @Test
    public void test6(){

        long start = System.currentTimeMillis();

//        method1(100000);//4014
        method2(100000);//7

        long end = System.currentTimeMillis();

        System.out.println("花费的时间为：" + (end - start));
    }

    public void method1(int highLevel){
        String src = "";
        for(int i = 0;i &lt; highLevel;i++){
            src = src + "a";//每次循环都会创建一个StringBuilder、String
        }
//        System.out.println(src);

    }

    public void method2(int highLevel){
        //只需要创建一个StringBuilder
        StringBuilder src = new StringBuilder();
        for (int i = 0; i &lt; highLevel; i++) {
            src.append("a");
        }
//        System.out.println(src);
    }
}</code></pre> 
<h3><br><br> 10.5. intern()的使用</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e7/3d/HZSnOrza_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4b/d5/wWwieWWr_o.png"></p> 
<p></p> 
<pre><code class="language-java">/**
 * 题目：
 * new String("ab")会创建几个对象？看字节码，就知道是两个。
 *     一个对象是：new关键字在堆空间创建的
 *     另一个对象是：字符串常量池中的对象"ab"。 字节码指令：ldc
 *
 * 思考：
 * new String("a") + new String("b")呢？
 *  对象1：new StringBuilder()
 *  对象2： new String("a")
 *  对象3： 常量池中的"a"
 *  对象4： new String("b")
 *  对象5： 常量池中的"b"
 *
 *  深入剖析： StringBuilder的toString():
 *      对象6 ：new String("ab")
 *       强调一下，toString()的调用，在字符串常量池中，没有生成"ab"
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  20:38
 */
public class StringNewTest {
    public static void main(String[] args) {
//        String str = new String("ab");

        String str = new String("a") + new String("b");
    }
}</code></pre> 
<p></p> 
<pre><code class="language-java">/**
 * 如何保证变量s指向的是字符串常量池中的数据呢？
 * 有两种方式：
 * 方式一： String s = "shkstart";//字面量定义的方式
 * 方式二： 调用intern()
 *         String s = new String("shkstart").intern();
 *         String s = new StringBuilder("shkstart").toString().intern();
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  18:49
 */
public class StringIntern {
    public static void main(String[] args) {

        String s = new String("1");
        s.intern();//调用此方法之前，字符串常量池中已经存在了"1"
        String s2 = "1";
        System.out.println(s == s2);//jdk6：false   jdk7/8：false


        String s3 = new String("1") + new String("1");//s3变量记录的地址为：new String("11")
        //执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！
        s3.intern();//在字符串常量池中生成"11"。如何理解：jdk6:创建了一个新的对象"11",也就有新的地址。
                                            //         jdk7:此时常量中并没有创建"11",而是创建一个指向堆空间中new String("11")的地址
        String s4 = "11";//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的"11"的地址
        System.out.println(s3 == s4);//jdk6：false  jdk7/8：true
    }
}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c7/02/VCqPmd9G_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fd/3e/sPJNQq17_o.png"></p> 
<pre><code class="language-java">public class StringIntern1 {
    public static void main(String[] args) {
        //StringIntern.java中练习的拓展：
        String s3 = new String("1") + new String("1");//new String("11")
        //执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！
        String s4 = "11";//在字符串常量池中生成对象"11"
        String s5 = s3.intern();
        System.out.println(s3 == s4);//false
        System.out.println(s5 == s4);//true
    }
}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e6/3c/SqArGVpp_o.png"></p> 
<p></p> 
<pre><code class="language-java">/**
 * @author shkstart  shkstart@126.com
 * @create 2020  20:17
 */
public class StringExer1 {
    public static void main(String[] args) {
        String s = new String("a") + new String("b");//new String("ab")
        //在上一行代码执行完以后，字符串常量池中并没有"ab"

        String s2 = s.intern();//jdk6中：在串池中创建一个字符串"ab"
                               //jdk8中：串池中没有创建字符串"ab",而是创建一个引用，指向new String("ab")，将此引用返回

        System.out.println(s2 == "ab");//jdk6:true  jdk8:true
        System.out.println(s == "ab");//jdk6:false  jdk8:true
    }
}</code></pre> 
<p></p> 
<pre><code class="language-java">/**
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  20:26
 */
public class StringExer2 {
    public static void main(String[] args) {
        String s1 = new String("ab");//执行完以后，会在字符串常量池中会生成"ab"                         // false
//        String s1 = new String("a") + new String("b");执行完以后，不会在字符串常量池中会生成"ab"  // true
        s1.intern();
        String s2 = "ab";
        System.out.println(s1 == s2);
    }
}</code></pre> 
<blockquote> 
 <p>intern的效率测试<br> 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</p> 
</blockquote> 
<pre><code class="language-java">/**
 * 使用intern()测试执行效率：空间使用上
 *
 * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。
 *
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  21:17
 */
public class StringIntern2 {
    static final int MAX_COUNT = 1000 * 10000;
    static final String[] arr = new String[MAX_COUNT];

    public static void main(String[] args) {
        Integer[] data = new Integer[]{1,2,3,4,5,6,7,8,9,10};

        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; MAX_COUNT; i++) {
//            arr[i] = new String(String.valueOf(data[i % data.length]));
            arr[i] = new String(String.valueOf(data[i % data.length])).intern();

        }
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为：" + (end - start));

        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.gc();
    }
}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ac/94/46KHGIL8_o.png"></p> 
<p></p> 
<h3>10.6. G1中的String去重操作</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8f/b4/iEVMPQBJ_o.png"><br>  </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/42/fb/Apg0l23R_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/06/d6/aV29nOcg_o.png"></p> 
<p></p> 
<h2>十一.垃圾回收相关概念</h2> 
<h3>11.1. System.gc()的理解</h3> 
<h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/97/F3vJm7qy_o.png"></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/73/df/96270rwI_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a8/26/209D0bOE_o.png"></p> 
<h3> 11.2.内存溢出与内存泄漏</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4c/46/sDuyUlC9_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f0/56/A3NqJKo1_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5d/d1/aiK09yTx_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c8/6e/T6FIXl1p_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8d/b6/S3WlX0e0_o.png"></p> 
<h3>11.3. Stop The World</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e8/94/igXA0lII_o.png"></p> 
<h3><img alt="" src="https://images2.imgbox.com/fe/d0/LbQeYojK_o.png"> <br> 11.4. 并发与并行</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/38/1e/2n5fzsKN_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/19/3e/BArI85HZ_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/28/0f/wTph86bt_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2b/00/J5GOKFm9_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/9c/lc8SxaJV_o.png"></p> 
<p style="text-align:center;"></p> 
<p></p> 
<h3>11.5. 安全点与安全区域的说明</h3> 
<h3><img alt="" src="https://images2.imgbox.com/70/0d/oM6vo3LH_o.png"></h3> 
<h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2a/be/sWTAK4CI_o.png"></h3> 
<h3><img alt="" src="https://images2.imgbox.com/30/81/F2lu06bG_o.png"></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/93/d0/9CYZndtw_o.png"></p> 
<p></p> 
<h3>11.6. 强引用、软引用、弱引用、虚引用</h3> 
<p><img alt="" src="https://images2.imgbox.com/4f/e0/Rj7lzr7h_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/ab/76/zLrI4dub_o.png"></p> 
<blockquote> 
 <p><strong>强引用</strong></p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/2d/dd/QRXw2JLD_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/48/73/QW1Bqcfv_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/d5/3c/IcS3iaTn_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/12/bc/owauOyC0_o.png">  </p> 
<blockquote> 
 <p><strong>软引用</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3b/07/Q9Ia5IN7_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/c4/18/0Rjx4CKs_o.png"></p> 
<blockquote> 
 <p>SoftReference userSoftRef = new SoftReference(new User(1, “songhk”));<br> //上面的一行代码，等价于如下的三行代码<br> User u1 = new User(1,“songhk”);<br> SoftReference userSoftRef = new SoftReference(u1);<br> u1 = null;//取消强引用</p> 
</blockquote> 
<pre><code class="language-java">**
 * 软引用的测试：内存不足即回收
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  16:06
 */
public class SoftReferenceTest {
    public static class User {
        public User(int id, String name) {
            this.id = id;
            this.name = name;
        }

        public int id;
        public String name;

        @Override
        public String toString() {
            return "[id=" + id + ", name=" + name + "] ";
        }
    }

    public static void main(String[] args) {
        //创建对象，建立软引用
//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, "songhk"));
        //上面的一行代码，等价于如下的三行代码
        User u1 = new User(1,"songhk");
        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(u1);
        u1 = null;//取消强引用


        //从软引用中重新获得强引用对象
        System.out.println(userSoftRef.get());

        System.gc();
        System.out.println("After GC:");
//        //垃圾回收之后获得软引用中的对象
        System.out.println(userSoftRef.get());//由于堆空间内存足够，所有不会回收软引用的可达对象。
//
        try {
            //让系统认为内存资源紧张、不够
//            byte[] b = new byte[1024 * 1024 * 7];
            byte[] b = new byte[1024 * 7168 - 635 * 1024];
        } catch (Throwable e) {
            e.printStackTrace();
        } finally {
            //再次从软引用中获取数据
            System.out.println(userSoftRef.get());//在报OOM之前，垃圾回收器会回收软引用的可达对象。
        }
    }
}</code></pre> 
<blockquote> 
 <p><strong>弱引用</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1a/43/B3oGHiR0_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d4/ba/wgYL9e0P_o.png"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>弱引用和软引用的区别：弱引用发生GC就回收，软引用内存不足才回收。发生GC不代表就内存不足了，还需要通过算法检查。</strong></span></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p><strong>虚引用</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d0/d5/WxHPF1ry_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/57/2b/2Yip2ZBd_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/e3/LNKsnJvp_o.png"></p> 
<h2>十二.垃圾回收算法</h2> 
<h3>1.垃圾回收概述</h3> 
<h4 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f8/79/QYCSJzvh_o.png"></h4> 
<h4><img alt="" src="https://images2.imgbox.com/3c/b5/s6Dmzt8g_o.png"><br> 1.1 什么是垃圾</h4> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/6f/b1/36NzS6ZF_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d5/e1/voQDs5bf_o.png"></p> 
<h4>1.2 为什么需要GC</h4> 
<h4><img alt="" src="https://images2.imgbox.com/56/94/xAhYloh0_o.png"><br> 1.3 Java垃圾回收机制</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f3/28/tuhsZsfF_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5f/b1/lTlqCF9z_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/22/45/hje54uKj_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/52/44/XmgbcTBU_o.png"></p> 
<p></p> 
<h3>2. 垃圾回收算法</h3> 
<h4><br> 2.1 垃圾标记算法</h4> 
<p><img alt="" src="https://images2.imgbox.com/ba/50/KGkHnFk6_o.png"><br><strong>2.1.1 引用计数法</strong></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/03/fe/byc0JbDp_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dd/e6/kpdkqcAT_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e7/d3/MpcLdlaN_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/07/11/s4nYtWgf_o.png"> <br><strong>2.1.2 可达性分析算法</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8a/2d/yxUALUhI_o.png"><br><img alt="" src="https://images2.imgbox.com/a1/b2/4th4mUuL_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0b/ca/V9EGARzk_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/64/21/YkThhcJB_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/13/7f/MtTWApSu_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f5/fc/B5cILrkn_o.png"></p> 
<blockquote> 
 <p> 对象的finalization机制</p> 
</blockquote> 
<p>该方法十分鸡肋，工作中几乎用不到。 </p> 
<p><img alt="" src="https://images2.imgbox.com/4c/27/SHk8xmYC_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8c/c4/Weucfx0H_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a5/bd/YL5STlMy_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/65/cf/WTjVh0ii_o.png"></p> 
<blockquote> 
 <p>MAT与JProfiler的GC Roots溯源</p> 
</blockquote> 
<blockquote> 
 <p><strong>MAT</strong><br> MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。<br> MAT是基于Eclipse开发的，是一款免费的性能分析工具</p> 
</blockquote> 
<pre><code class="language-java">public class GCRootsTest {
    public static void main(String[] args) {
        List&lt;Object&gt; numList = new ArrayList&lt;&gt;();
        Date birth = new Date();

        for (int i = 0; i &lt; 100; i++) {
            numList.add(String.valueOf(i));
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("数据添加完毕，请操作：");
        new Scanner(System.in).next();
        numList = null;
        birth = null;

        System.out.println("numList、birth已置空，请操作：");
        new Scanner(System.in).next();

        System.out.println("结束");
    }
}</code></pre> 
<blockquote> 
 <p>生成堆dump文件<br> jmap -dump:format=b,file=C:\Users\qinshuoyu\Desktop\1.hprof.analysis\log\1.hprof 19420</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/c0/62/ufMSpiFM_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/60/ea/MJ71M99c_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e7/07/RsOCyrek_o.png"></p> 
<p>numList、birth置空前，GC ROOTS中有ArrayList对象和Date对象</p> 
<p><img alt="" src="https://images2.imgbox.com/d3/28/zFbyPzMs_o.png"><br> numList、birth置空后，GC ROOTS中已经没有ArrayList对象和Date对象了</p> 
<p><img alt="" src="https://images2.imgbox.com/de/88/sAKzm7as_o.png">MAT中GC ROOTS分类与之前所讲略有不同，只要分为系统类、JNI Global、线程、监视器</p> 
<h4>2.2 标记-清除算法原理及优缺点</h4> 
<blockquote> 
 <p>垃圾清除阶段</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a8/38/SvQ0iTvF_o.png"><br><img alt="" src="https://images2.imgbox.com/18/23/OVlmPQ6b_o.png"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong> 标记的是可达的对象，因为从GC ROOTS出发只能关联到可达对象。</strong></span></p> 
</blockquote> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/ec/78/LXHoc3Ns_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3d/01/U2DWimih_o.png"></p> 
<h4> 2.3 复制算法</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/54/2e/eu4rTBIl_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/de/1f/3EYhj47R_o.png"></p> 
<blockquote> 
 <p><img alt="" src="https://images2.imgbox.com/c9/7e/ROKrPHx1_o.png"><strong> 特别适合垃圾对象很多,存活对象很少的场景;例如:Young区的S0区和S1区</strong></p> 
</blockquote> 
<h4><img alt="" src="https://images2.imgbox.com/67/0f/kGIbfVzR_o.png"><br> 2.4 标记压缩(标记整理)</h4> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/b7/e3/exeW2cuj_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0e/09/4g2o9iBW_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e8/26/Jgw60zqV_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ab/93/lfizRtaV_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/db/3a/ZR5ENnGF_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1a/87/lk7ny9ez_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/7b/66/oUBORmfU_o.png"><img alt="" src="https://images2.imgbox.com/6d/b0/qiUCGgoa_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dd/36/suTSTcat_o.png"></p> 
<h4>2.5 增量收集算法、分区算法</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2d/fb/6q2fdBFD_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9c/f7/IaAEwTF9_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/15/50/ksZgFW1m_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b2/36/WVKs2Ge0_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/61/2d/n0agMNLz_o.png"></p> 
<h2>十三.垃圾回收器</h2> 
<h3>13.1. 垃圾回收器分类</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e1/29/4nDPjErD_o.png"><br><img alt="" src="https://images2.imgbox.com/ec/10/SmScESsN_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/eb/5b/3CRX1osO_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/db/77/UcmbJt3Z_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/af/9d/VV5xkBm4_o.png"> </p> 
<blockquote> 
 <p> 评估GC的性能指标</p> 
</blockquote> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/d5/0b/P9vIcG9o_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a2/9a/YH6NB1lI_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/83/d1/PJXbvdxI_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c7/f2/sGDRFRhG_o.png"> </p> 
<h3><img alt="" src="https://images2.imgbox.com/3f/d3/bVlbIEet_o.png">13.2. 不同垃圾回收器概述</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b2/42/PNTort7q_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b8/3d/3EOCzAfU_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/75/dd/4a99rKYn_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a7/17/rOviGMjw_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/21/41/ZgTjInSl_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/43/9b/DdedtkDJ_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dd/dd/VwYaARyj_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f4/de/9dRdti2f_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bc/cc/UZcar6Bt_o.png"> </p> 
<blockquote> 
 <p>jdk8中，UseParallelGC默认搭配UseParallelOldGC</p> 
</blockquote> 
<blockquote> 
 <p>修改idea中程序运行的JDK版本</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/23/2a/Z8qJoPJp_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8d/be/z0eh51ra_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1a/75/fxCpMgBc_o.png"> </p> 
<h3>13.3. Serial与Serial Old垃圾回收器：串行回收</h3> 
<h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a4/b3/jis8fiSf_o.png"></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a1/a9/3ykbCA1L_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/00/67/KOZo2UXX_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4f/72/qwRwNqa2_o.png"> </p> 
<h3>13.4. ParNew垃圾回收器：并行回收</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/46/4f/VUEUInwF_o.png"></p> 
<blockquote> 
 <p> ParNew底层与Serial共用了大量的代码</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/70/0f/1BxpUEL2_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/60/78/EXBbLHwX_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/19/d5/MPN1oNAS_o.png"> </p> 
<h3>13.5. Parallel与Parallel Old垃圾回收器：吞吐量优先</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/53/fc/5OXvlBTz_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/72/55/pce4yW41_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f6/cd/YyQXGCJ8_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a3/c0/uETIB2Hn_o.png"> </p> 
<h3><img alt="" src="https://images2.imgbox.com/07/7b/Kwkqut34_o.png"><img alt="" src="https://images2.imgbox.com/25/07/3EE8uTKs_o.png"><img alt="" src="https://images2.imgbox.com/8e/02/AwFc6BEM_o.png"> </h3> 
<p> </p> 
<h3>13.6. CMS回收器：低延迟</h3> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/ab/c3/Yq8BaCY1_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9e/81/lQGZiTin_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/db/e3/4GRNOWYw_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/16/48/45DAzrTH_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c1/de/rwaJkEJ5_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0a/99/ZPNWhY9p_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6d/a4/U6rUbaLP_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/22/b7/QrTlMcsz_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/eb/38/fOEiCNbl_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/0d/1O2IgDFu_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ab/d3/7ibhLqga_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7c/a9/GVdSHZ2E_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9c/07/JWtF5Gdq_o.png"> </p> 
<p> </p> 
<h3>13.7. G1回收器：区域分代式</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/51/b5/XSW6Mnvf_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/86/38/C0rJpHNY_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d8/bb/jFVuGKbD_o.png"> </p> 
<blockquote> 
 <p>G1回收器的特点(优势)</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/be/0f/kRNr2e9F_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/47/24/L766brNg_o.png"> </p> 
<p><img alt="" src="https://images2.imgbox.com/49/55/ECgqHXzb_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5c/c6/9lDnxVlC_o.png"></p> 
<blockquote> 
 <p>G1回收器的缺点：</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c1/3f/CQkwknNm_o.png"></p> 
<p> </p> 
<blockquote> 
 <p>G1回收器的参数设置</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8c/72/3O2EB9D8_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/da/6b/iIHVhbxb_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0f/52/nP3h43qh_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/66/45/BJzPvLVW_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2e/6c/pJI7bEol_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/32/0c/RDFu9MRJ_o.png"> </p> 
<blockquote> 
 <p><img alt="" src="https://images2.imgbox.com/3d/f9/UmGivrTV_o.png">Bump-the-pointer：<br> 单个Region使用指针碰撞的方式来放数据上面allocated是已经使用的内存空间，top就是指针的位置，unallocate是没有使用的内存空间<br> TLAB：<br> 虽然存在分区Region，但是依然有线程独有的TLAB空间，这样可以保证多个线程对对象修改可以并行操作</p> 
</blockquote> 
<blockquote> 
 <p><strong> G1回收过程</strong></p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/ee/79/6OVAKWeP_o.png"><img alt="" src="https://images2.imgbox.com/44/93/oaLmDKmX_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e1/4f/XJd4YgzO_o.png"> </p> 
<blockquote> 
 <p><strong>Remebered Set  </strong></p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/bd/e7/VPhe0lx3_o.png"><img alt="" src="https://images2.imgbox.com/8b/03/Tj3nMfEO_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2f/53/UTpkV2BI_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/96/ae/fRrt7WGB_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e6/54/EGuYGt83_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/96/c5/Uoe2lcRW_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4f/c1/fQBBnwlx_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1e/76/FsWBzOQU_o.png"> </p> 
<p><img alt="" src="https://images2.imgbox.com/8e/fe/lnA8U1iC_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/32/0b/stqJ0wym_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/39/32/SBPWqM0O_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4d/10/3RnSiv7r_o.png"> </p> 
<h3><br> 13.8. 垃圾回收器总结</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/74/5e/y5Zu5yYj_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/33/d8/otN6pXkC_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b3/a5/nQqAonn6_o.png"> </p> 
<blockquote> 
 <p> <span style="color:#fe2c24;"><strong>CMS是在JDK9被废弃。</strong></span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f0/a5/d7S5mOSF_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/86/75/3Xx98A7w_o.png"> </p> 
<p><img alt="" src="https://images2.imgbox.com/d1/b1/wNk1NMpF_o.png"></p> 
<pre><code class="language-java">/**
 *  -XX:+PrintCommandLineFlags
 *
 *  -XX:+UseSerialGC:表明新生代使用Serial GC ，同时老年代使用Serial Old GC
 *
 *  -XX:+UseParNewGC：标明新生代使用ParNew GC
 *
 *  -XX:+UseParallelGC:表明新生代使用Parallel GC
 *  -XX:+UseParallelOldGC : 表明老年代使用 Parallel Old GC
 *  说明：二者可以相互激活
 *
 *  -XX:+UseConcMarkSweepGC：表明老年代使用CMS GC。同时，年轻代会触发对ParNew 的使用
 * @author shkstart  shkstart@126.com
 * @create 2020  0:10
 */
public class GCUseTest {
    public static void main(String[] args) {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        while(true){
            byte[] arr = new byte[100];
            list.add(arr);
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

</code></pre> 
<h3><br> 13.9. GC日志分析</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b1/0c/P2k2Rlpz_o.png"></p> 
<p> </p> 
<blockquote> 
 <p>下面两种是等价的<br> -Xms60m -Xmx60m -XX:+PrintGC<br> -Xms60m -Xmx60m -verbose:gc</p> 
</blockquote> 
<pre><code class="language-java">public class GCLogTest {
    public static void main(String[] args) {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 500; i++) {
            byte[] arr = new byte[1024 * 100];//100KB
            list.add(arr);
    }
}</code></pre> 
<pre><code class="language-bash">[GC (Allocation Failure)  15289K-&gt;13782K(58880K), 0.0044617 secs]
[GC (Allocation Failure)  29081K-&gt;29184K(58880K), 0.0046940 secs]
[Full GC (Ergonomics)  29184K-&gt;28807K(58880K), 0.0102882 secs]
[Full GC (Ergonomics)  44125K-&gt;43710K(58880K), 0.0060180 secs]</code></pre> 
<blockquote> 
 <p>GC、Full GC: GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代，老年代。<br> Allocation Failure: GC发生的原因。<br> 15289K-&gt;13782K:堆在GC前的大小和GC后的大小<br> 58880K:总共的堆大小。<br> 0.0044617 secs: GC持续的时间。</p> 
</blockquote> 
<p>-Xms60m -Xmx60m -XX:+PrintGCDetails</p> 
<pre><code class="language-java">[GC (Allocation Failure) [PSYoungGen: 15282K-&gt;2548K(17920K)] 15282K-&gt;13874K(58880K), 0.0417173 secs] [Times: user=0.00 sys=0.00, real=0.04 secs] 
[GC (Allocation Failure) [PSYoungGen: 17847K-&gt;2500K(17920K)] 29173K-&gt;29028K(58880K), 0.0073599 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Ergonomics) [PSYoungGen: 2500K-&gt;0K(17920K)] [ParOldGen: 26528K-&gt;28807K(40960K)] 29028K-&gt;28807K(58880K), [Metaspace: 3495K-&gt;3495K(1056768K)], 0.0135070 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
[Full GC (Ergonomics) [PSYoungGen: 15318K-&gt;3000K(17920K)] [ParOldGen: 28807K-&gt;40709K(40960K)] 44126K-&gt;43710K(58880K), [Metaspace: 3496K-&gt;3496K(1056768K)], 0.0167859 secs] [Times: user=0.00 sys=0.02, real=0.02 secs] 
Heap
 PSYoungGen      total 17920K, used 10253K [0x00000000fec00000, 0x0000000100000000, 0x0000000100000000)
  eden space 15360K, 66% used [0x00000000fec00000,0x00000000ff603510,0x00000000ffb00000)
  from space 2560K, 0% used [0x00000000ffd80000,0x00000000ffd80000,0x0000000100000000)
  to   space 2560K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffd80000)
 ParOldGen       total 40960K, used 40709K [0x00000000fc400000, 0x00000000fec00000, 0x00000000fec00000)
  object space 40960K, 99% used [0x00000000fc400000,0x00000000febc17f0,0x00000000fec00000)
 Metaspace       used 3502K, capacity 4498K, committed 4864K, reserved 1056768K
  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</code></pre> 
<blockquote> 
 <p>GC, Full GC:同样是GC的类型<br> Allocation Failure: GC原因<br> PsYoungGen:使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化<br> ParOldGen:使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化<br> Metaspace:元数据区GC前后大小的变化，JDK1.8中引入了元数据区以替代永久代<br> secs: 指GC花费的时间<br> Times: user:指的是垃圾收集器花费的所有CPu时间<br> sys:花费在等待系统调用或系统事件的时间<br> real:GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</p> 
</blockquote> 
<p>-Xms60m -Xmx60m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</p> 
<pre><code class="language-java">2022-12-16T23:07:42.172+0800: 0.260: [GC (Allocation Failure) [PSYoungGen: 15282K-&gt;2544K(17920K)] 15282K-&gt;13894K(58880K), 0.0420238 secs] [Times: user=0.00 sys=0.00, real=0.04 secs] 
2022-12-16T23:07:42.213+0800: 0.270: [GC (Allocation Failure) [PSYoungGen: 17843K-&gt;2536K(17920K)] 29193K-&gt;29112K(58880K), 0.0083888 secs] [Times: user=0.01 sys=0.13, real=0.02 secs] 
2022-12-16T23:07:42.229+0800: 0.278: [Full GC (Ergonomics) [PSYoungGen: 2536K-&gt;0K(17920K)] [ParOldGen: 26576K-&gt;28807K(40960K)] 29112K-&gt;28807K(58880K), [Metaspace: 3494K-&gt;3494K(1056768K)], 0.0184285 secs] [Times: user=0.09 sys=0.00, real=0.01 secs] 
2022-12-16T23:07:42.244+0800: 0.301: [Full GC (Ergonomics) [PSYoungGen: 15318K-&gt;3000K(17920K)] [ParOldGen: 28807K-&gt;40709K(40960K)] 44125K-&gt;43710K(58880K), [Metaspace: 3495K-&gt;3495K(1056768K)], 0.0148117 secs] [Times: user=0.05 sys=0.06, real=0.02 secs] </code></pre> 
<blockquote> 
 <p>2022-12-16T23:07:42.172+0800: -XX:+PrintGCDateStamps 参数打印的，表示当前打印的时间戳<br> 0.260：-XX:+PrintGCTimeStamps 参数打印的，表示JVM启动了多久。</p> 
 <p>GC真正耗时：real</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dc/09/6EA3uKK7_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/77/d0/ofnL4t8h_o.png"> </p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/80/41/UbsMFzHF_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fa/dc/XGHxD7Zs_o.png"></p> 
<pre><code class="language-java">/**
 * 在jdk7 和 jdk8中分别执行
 * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC
 * @author shkstart  shkstart@126.com
 * @create 2020  0:12
 */
public class GCLogTest1 {
    private static final int _1MB = 1024 * 1024;

    public static void testAllocation() {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB];
    }

    public static void main(String[] agrs) {
        testAllocation();
    }
}</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/a6/bc/2Y2fEIWz_o.png"><br><br><strong>JDK7中</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ac/6b/Yz430Web_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/b4/c3/Xb66MqVb_o.png"><strong>JDK8中</strong> </p> 
<pre><code class="language-java">[GC (Allocation Failure) [DefNew: 6431K-&gt;695K(9216K), 0.0084041 secs] 6431K-&gt;4791K(19456K), 0.0085389 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 7161K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  78% used [0x00000000fec00000, 0x00000000ff2506b0, 0x00000000ff400000)
  from space 1024K,  67% used [0x00000000ff500000, 0x00000000ff5adf38, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00020, 0x00000000ffa00200, 0x0000000100000000)
 Metaspace       used 3500K, capacity 4498K, committed 4864K, reserved 1056768K
  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</code></pre> 
<blockquote> 
 <p><strong>可以看出老年代占了40%，也就是4M，相当于大对象在Eden区放不下后直接放到了老年代，但是JDK7中不是，是把Eden区中的对象升级到老年代，然后把大对象分配在Eden区</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2a/06/zCRYViHW_o.png"> </p> 
<blockquote> 
 <p><img alt="" src="https://images2.imgbox.com/d4/73/aGfjAKv5_o.png">GCViewer就是一个jar包，点击就能运行，但是页面不能调节，分辨率不适配，很难用。<br> GCEasy：https://gceasy.io</p> 
</blockquote> 
<p>-Xms60m -Xmx60m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:./logs/gc.log</p> 
<pre><code class="language-java">public class GCLogTest {
    public static void main(String[] args) {
        ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;();

        for (int i = 0; i &lt; 500; i++) {
            byte[] arr = new byte[1024 * 100];//100KB
            list.add(arr);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre> 
<p>./指的是当前目录，即当前工程总目录，下的logs文件夹下的gc.log,将其复制到桌面，然后上传到GCeasy分析一下。</p> 
<h3><img alt="" src="https://images2.imgbox.com/07/32/XfzIqosM_o.png"><br> 13.10. 垃圾回收器的新发展</h3> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/76/5a/HOxIgEaR_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/da/48/8NUyW4Y6_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c1/06/onOyseKN_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/98/75/V4HAxD1X_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3c/8c/wZ1fumSl_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/82/30/iDuJ7EEp_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/28/6f/GLCZyRi2_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/47/79/deEltSJd_o.png"> </p> 
<p><strong>注：本文是学习 尚硅谷宋红康JVM全套教程（详解java虚拟机）所做笔记。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e256441edcf5b52b5deed38f8f1aa118/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NAT模式下将虚拟机IP设置为固定IP</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/48151ce91f4903614cde55b437502dc7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何设计电商SPU与SKU表以及相关的表？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>