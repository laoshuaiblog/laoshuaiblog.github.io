<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>解决Golang获取当前项目绝对路径问题 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/ac8edf32265d5c07686e4103488009bb/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="解决Golang获取当前项目绝对路径问题">
  <meta property="og:description" content="导读 由于Golang是编译型语言（非脚本型语言），如果你想在Golang程序中获取当前执行目录将是一件非常蛋疼的事情。 以前大家最折中的解决方案就是通过启动传参或是环境变量将路径手动传递到程序，而今天我在看日志库的时候发现了一种新的解决方案。
Go程序两种不同的执行方式 用Go编写的程序有两种执行方式，go run和go build
通常的做法是go run用于本地开发，用一个命令中快速测试代码确实非常方便；在部署生产环境时，我们会通过go build构建出二进制文件然后上传到服务器再去执行。 两种启动方式会产生什么问题？ 那么两种启动方式下，获取到当前执行路径会产生什么问题？
话不多说，我们直接上代码
我们编写获取当前可执行文件路径的方法
package main import ( &#34;fmt&#34; &#34;log&#34; &#34;os&#34; &#34;path/filepath&#34; ) func main() { fmt.Println(&#34;getCurrentAbPathByExecutable = &#34;, getCurrentAbPathByExecutable()) } // 获取当前执行程序所在的绝对路径 func getCurrentAbPathByExecutable() string { exePath, err := os.Executable() if err != nil { log.Fatal(err) } res, _ := filepath.EvalSymlinks(filepath.Dir(exePath)) return res } 首先通过go run启动
D:\Projects\demo&amp;gt;go run main.go getCurrentAbPathByExecutable = C:\Users\XXX\AppData\Local\Temp\go-build216571510\b001\exe 再尝试go build执行
D:\Projects\demo&amp;gt;go build &amp;amp; demo.exe getCurrentAbPathByExecutable = D:\Projects\demo 通过对比执行结果，我们发现两种执行方式，我们获取到了不同的路径。而且很明显，go run获取到的路径是错误的。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-06T11:52:01+08:00">
    <meta property="article:modified_time" content="2023-05-06T11:52:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">解决Golang获取当前项目绝对路径问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>导读</h4> 
<p>由于Golang是编译型语言（非脚本型语言），如果你想在Golang程序中获取当前执行目录将是一件非常蛋疼的事情。 以前大家最折中的解决方案就是<strong>通过启动传参或是环境变量将路径手动传递到程序</strong>，而今天我在看日志库的时候发现了一种新的解决方案。</p> 
<h4>Go程序两种不同的执行方式</h4> 
<p>用Go编写的程序有两种执行方式，<code>go run</code>和<code>go build</code></p> 
<ul><li>通常的做法是<code>go run</code>用于本地开发，用一个命令中快速测试代码确实非常方便；</li><li>在部署生产环境时，我们会通过<code>go build</code>构建出二进制文件然后上传到服务器再去执行。</li></ul> 
<h4>两种启动方式会产生什么问题？</h4> 
<p><strong>那么两种启动方式下，获取到当前执行路径会产生什么问题？</strong></p> 
<p>话不多说，我们直接上代码</p> 
<p>我们编写获取当前可执行文件路径的方法</p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
)

func main() {
	fmt.Println("getCurrentAbPathByExecutable = ", getCurrentAbPathByExecutable())
}


// 获取当前执行程序所在的绝对路径
func getCurrentAbPathByExecutable() string {
	exePath, err := os.Executable()
	if err != nil {
		log.Fatal(err)
	}
	res, _ := filepath.EvalSymlinks(filepath.Dir(exePath))
	return res
}</code></pre> 
<p> </p> 
<p>首先通过<code>go run</code>启动</p> 
<pre><code>D:\Projects\demo&gt;go run main.go
getCurrentAbPathByExecutable =  C:\Users\XXX\AppData\Local\Temp\go-build216571510\b001\exe
</code></pre> 
<p>再尝试<code>go build</code>执行</p> 
<pre><code>D:\Projects\demo&gt;go build &amp; demo.exe
getCurrentAbPathByExecutable =  D:\Projects\demo
</code></pre> 
<p>通过对比执行结果，我们发现两种执行方式，我们获取到了不同的路径。而且很明显，<code>go run</code>获取到的路径是错误的。</p> 
<p> </p> 
<p><strong>原因：</strong> 这是由于<code>go run</code>会将源代码编译到系统<code>TEMP</code>或<code>TMP</code>环境变量目录中并启动执行；而<code>go build</code>只会在当前目录编译出可执行文件，并不会自动执行。</p> 
<p>我们可以简单理解为，<code>go run main.go</code>等价于<code>go build &amp; ./main</code></p> 
<p>虽然两种执行方式最终都是一样的过程：<strong>源码-&gt;编译-&gt;可执行文件-&gt;执行输出</strong>，但他们的执行目录却完全不一样了。</p> 
<p> </p> 
<h4>新的方案诞生</h4> 
<p>这是在我今天查看服务日志(<code>zap</code>库)的时候，突然反应过来一件事情。 比如下面是一条简单的日志，而服务是通过<code>go run</code>启动的，但日志库却把我正确的程序路径<code>D:/Projects/te-server/modules/es/es.go:139</code>给打印出来了</p> 
<pre><code>2021-03-26 17:47:06    D:/Projects/te-server/modules/es/es.go:139  update es index {"index": "tags", "data": "[200 OK] {\"acknowledged\":true}"}
</code></pre> 
<p>于是我马上去翻看<code>zap</code>源码，发现是通过<code>runtime.Caller()</code>实现的，其实所有Golang日志库都会有<code>runtime.Caller()</code>这个调用。</p> 
<p> </p> 
<p>我开心的以为找到了最终答案，然后写代码试了下： </p> 
<pre><code class="language-Go">package main

import (
	"fmt"
	"path"
	"runtime"
)

func main() {
	fmt.Println("getCurrentAbPathByCaller = ", getCurrentAbPathByCaller())

}

// 获取当前执行文件绝对路径（go run）
func getCurrentAbPathByCaller() string {
	var abPath string
	_, filename, _, ok := runtime.Caller(0)
	if ok {
		abPath = path.Dir(filename)
	}
	return abPath
}
</code></pre> 
<p> </p> 
<p>首先在windows下面<code>go run</code> 和<code>go build</code>试一下</p> 
<pre><code>D:\Projects\demo&gt;go run main.go
getCurrentAbPathByCaller =  D:/Projects/demo


D:\Projects\demo&gt;go build &amp; demo.exe
getCurrentAbPathByCaller =  D:/Projects/demo
</code></pre> 
<p>嗯~~ 结果完全正确！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88a925d6baba6f0479947dd2588b4671/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">生信学习之通路富集一（GO分析）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e256441edcf5b52b5deed38f8f1aa118/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NAT模式下将虚拟机IP设置为固定IP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>