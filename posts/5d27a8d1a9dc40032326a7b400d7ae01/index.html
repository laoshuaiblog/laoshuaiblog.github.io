<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android广播 有序 无序,Android中的有序和无序广播浅析 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/5d27a8d1a9dc40032326a7b400d7ae01/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="android广播 有序 无序,Android中的有序和无序广播浅析">
  <meta property="og:description" content="BroadcastReceiver所对应的广播分两类：无序广播和有序广播。
无序广播即为我们平时经常使用的广播，其主要是通过public abstract void sendBroadcast (Intent intent)方法进行发送，并通过intent传递数据。代码示例如下：
Intent nonOrderIntent = new Intent();
nonOrderIntent.setAction(ACTION);
sendBroadcast(nonOrderIntent);
无序广播会被注册了的相应的感兴趣(intent-filter匹配)接收，且顺序是无序的。如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。
无序广播的广播接收者不可以使用setResultData()方法和abortBroadcast()方法，如果使用了会报错。 但是可以使用getResultData()方法，虽然不报错，但是获取到的数据为null。但是在一种特殊情况下，getResultData()方法能取到无序广播传递的数据，下文会说明在什么情况下。
无序广播不可以被拦截，不可以被终止，不可以被修改，无序广播任何接收者只要匹配条件都可以接收到，无优先级问题。
如果想通过无序广播传递数据，则可以调用intent.putExtra方法传递， 接收者可通过intent.get...接收，不可通过getResultData接收。
有序广播主要是通过public abstract void sendOrderedBroadcast (Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)方法进行发送。代码示例如下：
Intent intent = new Intent();
intent.setAction(ACTION);
sendOrderedBroadcast(intent, null, new Priority2BroadcastReceiver(), null, Activity.RESULT_OK, &#34;MainActivity发送了一个有序广播&#34;, null);
先介绍一下public abstract void sendOrderedBroadcast (Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)方法">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-05-25T22:24:58+08:00">
    <meta property="article:modified_time" content="2021-05-25T22:24:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android广播 有序 无序,Android中的有序和无序广播浅析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>BroadcastReceiver所对应的广播分两类：无序广播和有序广播。</p> 
 <p>无序广播即为我们平时经常使用的广播，其主要是通过public abstract void sendBroadcast (Intent intent)方法进行发送，并通过intent传递数据。代码示例如下：</p> 
 <p>Intent nonOrderIntent = new Intent();</p> 
 <p>nonOrderIntent.setAction(ACTION);</p> 
 <p>sendBroadcast(nonOrderIntent);</p> 
 <p>无序广播会被注册了的相应的感兴趣(intent-filter匹配)接收，且顺序是无序的。如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。</p> 
 <p>无序广播的广播接收者不可以使用setResultData()方法和abortBroadcast()方法，如果使用了会报错。 但是可以使用getResultData()方法，虽然不报错，但是获取到的数据为null。但是在一种<u>特殊情况</u>下，getResultData()方法能取到无序广播传递的数据，下文会说明在什么情况下。</p> 
 <p>无序广播不可以被拦截，不可以被终止，不可以被修改，无序广播任何接收者只要匹配条件都可以接收到，无优先级问题。</p> 
 <p>如果想通过无序广播传递数据，则可以调用intent.putExtra方法传递， 接收者可通过intent.get...接收，不可通过getResultData接收。</p> 
 <p>有序广播主要是通过public abstract void sendOrderedBroadcast (Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)方法进行发送。代码示例如下：</p> 
 <p>Intent intent = new Intent();</p> 
 <p>intent.setAction(ACTION);</p> 
 <p>sendOrderedBroadcast(intent, null, new Priority2BroadcastReceiver(), null, Activity.RESULT_OK, "MainActivity发送了一个有序广播", null);</p> 
 <p>先介绍一下public abstract void sendOrderedBroadcast (Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)方法</p> 
 <p>官网api的参数解释：</p> 
 <p>Parameters</p> 
 <p>intent The Intent to broadcast; all receivers matching this Intent will receive the broadcast.</p> 
 <p>receiverPermission String naming a permissions that a receiver must hold in order to receive your broadcast. If null, no permission is required.</p> 
 <p>resultReceiver Your own BroadcastReceiver to treat as the final receiver of the broadcast.</p> 
 <p>scheduler A custom Handler with which to schedule the resultReceiver callback; if null it will be scheduled in the Context's main thread.</p> 
 <p>initialCode An initial value for the result code. Often Activity.RESULT_OK.</p> 
 <p>initialData An initial value for the result data. Often null.</p> 
 <p>initialExtras An initial value for the result extras. Often null.</p> 
 <p>第一个intent：不多说指定intent，所有广播接收者的匹配规则</p> 
 <p>第二个receiverPermission：指定广播接收器的权限，一般自定义，不常用，可传null。</p> 
 <p>第三个resultReceiver：指定一个最终的广播接收器，相当于finally功能，不论优先级，最后都要接收一次广播，而这一次收到的广播为无序广播(可以在BroadcastReceiver中通过boolean orderedBroadcast = isOrderedBroadcast()方法验证)，但是却可以通过getResultData等方法取得数据，这就是上面提到的特殊情况。</p> 
 <p>第四个scheduler：看英文没怎么看懂什么意思，一般传null。</p> 
 <p>第五个initialCode：指定一个code，一般传Activity.RESULT_OK。</p> 
 <p>第六个initialData：传一个字符串数据。对应的在BroadcastReceiver中通过String resultData = getResultData()取得数据；通过setResultData("优先级为3的setResultData的数据")修改数据，将数据传给下一个优先级较低的BroadcastReceiver；如果在优先级较高的BroadcastReceiver中没有使用setResultData修改数据，那么优先级较低的接收到的数据还是最原始的数据，即initialData的值。</p> 
 <p>第七个initialExtras：传一个Bundle对象，也就是可以传多种类型的数据。对应的在BroadcastReceiver中通过Bundle bundle = getResultExtras(false)取得Bundle对象，然后再通过bundle的各种get方法取得数据；通过setResultExtras()传入一个修改过的bundle，将该bundle对象传给下一个优先级较低的BroadcastReceiver；如果在优先级较高的BroadcastReceiver中没有使用setResultExtras修改数据，那么优先级较低的接收到的数据还是最原始的bundle对象，即initialExtras的值。</p> 
 <p>有序广播所对应的所有的receiver按照在intent-filter中设置的android:priority属性依次执行，android:priority表示优先级，值越大，其所对应的广播接收者，越先接收到广播。在android:priority相同的情况下，如果广播接收器是通过静态注册的，则接收到广播的顺序不确定，如果是动态注册的，先注册的将先收到广播。</p> 
 <p>有序广播可以被拦截，�可以在较高优先级的接收器中通过abortBroadcast()拦截广播，这样就会导致较低优先级的接收器无法收到广播了，但是sendOrderedBroadcast第三个参数指定的BroadcastReceiver还是会收到广播的，而且能获得数据。</p> 
 <p>有序广播可以通过原始intent.putExtra这种方式传递数据给BroadcastReceiver，也能通过sendOrderedBroadcast方法的最后2个参数传递数据，但是通过第一种方式传递的数据无法中途修改，通过第二种方式传递的可以通过上面参数说明中的方式进行修改。</p> 
 <p>具体验证方式可通过如下代码验证以上结论：</p> 
 <p>MainActivity</p> 
 <p>import android.app.Activity;</p> 
 <p>import android.content.Intent;</p> 
 <p>import android.os.Bundle;</p> 
 <p>import android.os.Handler;</p> 
 <p>import android.os.Message;</p> 
 <p>import android.support.design.widget.FloatingActionButton;</p> 
 <p>import android.support.design.widget.Snackbar;</p> 
 <p>import android.support.v7.app.AppCompatActivity;</p> 
 <p>import android.support.v7.widget.Toolbar;</p> 
 <p>import android.view.Menu;</p> 
 <p>import android.view.MenuItem;</p> 
 <p>import android.view.View;</p> 
 <p>import com.tbc.hsx.testbroadcast.receiver.Priority2BroadcastReceiver;</p> 
 <p>public class MainActivity extends AppCompatActivity implements View.OnClickListener {<!-- --></p> 
 <p>private static final String ACTION = "com.tbc.hsx.testbroadcast.MainActivity";</p> 
 <p>public static final String DATA = "data";</p> 
 <p>public static final String ORDER_DATA = "order_data";</p> 
 <p>@Override</p> 
 <p>protected void onCreate(Bundle savedInstanceState) {<!-- --></p> 
 <p>super.onCreate(savedInstanceState);</p> 
 <p>setContentView(R.layout.activity_main);</p> 
 <p>Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</p> 
 <p>setSupportActionBar(toolbar);</p> 
 <p>FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);</p> 
 <p>fab.setOnClickListener(new View.OnClickListener() {<!-- --></p> 
 <p>@Override</p> 
 <p>public void onClick(View view) {<!-- --></p> 
 <p>Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG)</p> 
 <p>.setAction("Action", null).show();</p> 
 <p>}</p> 
 <p>});</p> 
 <p>findViewById(R.id.send_broadcast_btn).setOnClickListener(this);</p> 
 <p>findViewById(R.id.send_ordered_broadcast_btn).setOnClickListener(this);</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>public boolean onCreateOptionsMenu(Menu menu) {<!-- --></p> 
 <p>// Inflate the menu; this adds items to the action bar if it is present.</p> 
 <p>getMenuInflater().inflate(R.menu.menu_main, menu);</p> 
 <p>return true;</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>public boolean onOptionsItemSelected(MenuItem item) {<!-- --></p> 
 <p>// Handle action bar item clicks here. The action bar will</p> 
 <p>// automatically handle clicks on the Home/Up button, so long</p> 
 <p>// as you specify a parent activity in AndroidManifest.xml.</p> 
 <p>int id = item.getItemId();</p> 
 <p>//noinspection SimplifiableIfStatement</p> 
 <p>if (id == R.id.action_settings) {<!-- --></p> 
 <p>return true;</p> 
 <p>}</p> 
 <p>return super.onOptionsItemSelected(item);</p> 
 <p>}</p> 
 <p>Handler handler = new Handler() {<!-- --></p> 
 <p>@Override</p> 
 <p>public void dispatchMessage(Message msg) {<!-- --></p> 
 <p>super.dispatchMessage(msg);</p> 
 <p>}</p> 
 <p>};</p> 
 <p>@Override</p> 
 <p>public void onClick(View view) {<!-- --></p> 
 <p>if (view.getId() == R.id.send_broadcast_btn) {<!-- --></p> 
 <p>Intent nonOrderIntent = new Intent();</p> 
 <p>nonOrderIntent.setAction(ACTION);</p> 
 <p>sendBroadcast(nonOrderIntent);</p> 
 <p>} else if (view.getId() == R.id.send_ordered_broadcast_btn) {<!-- --></p> 
 <p>Intent intent = new Intent();</p> 
 <p>intent.putExtra(DATA, "有序广播通过intent.putExtra传递的数据");</p> 
 <p>intent.setAction(ACTION);</p> 
 <p>Bundle bundle = new Bundle();</p> 
 <p>bundle.putString(ORDER_DATA, "有序广播通过bundle传递的数据");</p> 
 <p>sendOrderedBroadcast(intent, null, new Priority2BroadcastReceiver(), handler, Activity.RESULT_OK, "MainActivity发送了一个有序广播", bundle);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>Priority1BroadcastReceiver</p> 
 <p>import android.content.BroadcastReceiver;</p> 
 <p>import android.content.Context;</p> 
 <p>import android.content.Intent;</p> 
 <p>/**</p> 
 <p>* Created by Doraemon</p> 
 <p>* Date: 16/4/27</p> 
 <p>* Time: 16:35</p> 
 <p>* Summary:优先级为1的广播接收器</p> 
 <p>*/</p> 
 <p>public class Priority1BroadcastReceiver extends BroadcastReceiver {<!-- --></p> 
 <p>@Override</p> 
 <p>public void onReceive(Context context, Intent intent) {<!-- --></p> 
 <p>String resultData = getResultData();//获取有序广播的数据</p> 
 <p>System.out.println("优先级为1的接收到的广播数据resultData----&gt;" + resultData);</p> 
 <p>setResultData("优先级为1的setResultData的数据");//修改有序广播的数据</p> 
 <p>}</p> 
 <p>}</p> 
 <p>Priority2BroadcastReceiver</p> 
 <p>import android.content.BroadcastReceiver;</p> 
 <p>import android.content.Context;</p> 
 <p>import android.content.Intent;</p> 
 <p>import android.os.Bundle;</p> 
 <p>import com.tbc.hsx.testbroadcast.MainActivity;</p> 
 <p>/**</p> 
 <p>* Created by Doraemon</p> 
 <p>* Date: 16/4/27</p> 
 <p>* Time: 16:35</p> 
 <p>* Summary:</p> 
 <p>*/</p> 
 <p>public class Priority2BroadcastReceiver extends BroadcastReceiver {<!-- --></p> 
 <p>@Override</p> 
 <p>public void onReceive(Context context, Intent intent) {<!-- --></p> 
 <p>boolean orderedBroadcast = isOrderedBroadcast();</p> 
 <p>if (orderedBroadcast) {<!-- --></p> 
 <p>System.out.println("优先级为1的接收者接收到的是有序广播");</p> 
 <p>} else {<!-- --></p> 
 <p>System.out.println("优先级为1的接收者接收到的是无序广播");</p> 
 <p>}</p> 
 <p>Bundle bundle=getResultExtras(false);</p> 
 <p>if (bundle != null) {<!-- --></p> 
 <p>String orderData = bundle.getString(MainActivity.ORDER_DATA);</p> 
 <p>System.out.println("Priority2BroadcastReceiver--------&gt;" + orderData);</p> 
 <p>}</p> 
 <p>String resultData = getResultData();//获取有序广播的数据</p> 
 <p>System.out.println("优先级为2的接收到的广播数据resultData----&gt;" + resultData);</p> 
 <p>setResultData("优先级为2的setResultData的数据");//修改有序广播的数据</p> 
 <p>}</p> 
 <p>}</p> 
 <p>Priority3BroadcastReceiver</p> 
 <p>import android.content.BroadcastReceiver;</p> 
 <p>import android.content.Context;</p> 
 <p>import android.content.Intent;</p> 
 <p>import android.os.Bundle;</p> 
 <p>import com.tbc.hsx.testbroadcast.MainActivity;</p> 
 <p>/**</p> 
 <p>* Created by Doraemon</p> 
 <p>* Date: 16/4/27</p> 
 <p>* Time: 16:32</p> 
 <p>* Summary:</p> 
 <p>*/</p> 
 <p>public class Priority3BroadcastReceiver extends BroadcastReceiver {<!-- --></p> 
 <p>@Override</p> 
 <p>public void onReceive(Context context, Intent intent) {<!-- --></p> 
 <p>Bundle bundle = getResultExtras(false);</p> 
 <p>if (bundle != null) {<!-- --></p> 
 <p>String orderData = bundle.getString(MainActivity.ORDER_DATA);</p> 
 <p>System.out.println("Priority3BroadcastReceiver--------&gt;" + orderData);</p> 
 <p>}</p> 
 <p>// bundle.putString(MainActivity.ORDER_DATA, "优先级为3的接收者修改了bundle数据");</p> 
 <p>// setResultExtras(bundle);</p> 
 <p>boolean orderedBroadcast = isOrderedBroadcast();</p> 
 <p>if (orderedBroadcast) {<!-- --></p> 
 <p>System.out.println("优先级为3的接收者接收到的是有序广播");</p> 
 <p>} else {<!-- --></p> 
 <p>System.out.println("优先级为3的接收者接收到的是无序广播");</p> 
 <p>}</p> 
 <p>String resultData = getResultData();//获取有序广播的数据</p> 
 <p>System.out.println("优先级为3的接收到的广播数据resultData----&gt;" + resultData);</p> 
 <p>setResultData("优先级为3的setResultData的数据");//修改有序广播的数据</p> 
 <p>// abortBroadcast();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>AndroidManifest.xml(BroadcastReceiver注册部分)</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b5fc9d878b683b2cf1419620ece8e0b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS学习笔记（二十二）弹性布局</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1715ca5af4144a3516ab6255291363d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android相对布局一行三个,037-布局-相对布局-RelativeLayout</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>