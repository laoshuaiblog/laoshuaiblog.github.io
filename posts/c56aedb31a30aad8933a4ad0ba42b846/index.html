<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java注解编译期处理AbstractProcessor详解 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/c56aedb31a30aad8933a4ad0ba42b846/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Java注解编译期处理AbstractProcessor详解">
  <meta property="og:description" content="概述 我们接触的注解主要分为以下两类
运行时注解：通过反射在运行时动态处理注解的逻辑编译时注解：通过注解处理器在编译期动态处理相关逻辑 平时我们接触的框架大部分都是运行时注解，比如：@Autowire @Resoure @Bean 等等。
那么我们平时有接触过哪些编译期注解呢，@Lombok @AutoService 等等
像这些编译时注解的作用都是自动生成代码，一是为了提高编码的效率，二是避免在运行期大量使用反射，通过在编译期利用反射生成辅助类和方法以供运行时使用。
那这些编译器注解都是如何运行的呢? 又是怎么自动生成代码的呢？
我们今天来详细介绍一下，不过再介绍之前，可以先简单了解一下 Java 注解的基本概念
Java 注解
注解处理器 注解处理流程 注解编译期处理流程最关键的一个类就是 Processor ，它是注解处理器的接口类，我们所有需要对编译期处理注解的逻辑都需要实现这个 Processor 接口，当然，AbstractProcessor 抽象类帮我们写好了大部分都流程，所以我们只需要实现这个抽象类就可以很方便的定义一个注解处理器；
注解处理流程由多轮完成。每一轮都从编译器在源文件中搜索注解并选择适合这些注解的 注解处理器 (AbstractProcessor) 开始。每个注解处理器依次在相应的源上被调用。
如果在此过程中生成了任何文件，则将以生成的文件作为输入开始另一轮。这个过程一直持续到处理阶段没有新文件生成为止。
注解处理器的处理步骤：
在 java 编译器中构建；编译器开始执行未执行过的注解处理器；循环处理注解元素 (Element)，找到被该注解所修饰的类，方法，或者属性；生成对应的类，并写入文件；判断是否所有的注解处理器都已执行完毕，如果没有，继续下一个注解处理器的执行 (回到步骤 1)。 AbstractProcessor 这是注解处理器的核心抽象类，我们主要来看看里面的方法
getSupportedOptions() 默认的实现是 从注解SupportedOptions获取值，该值是一个字符数组，例如
@SupportedOptions({&#34;name&#34;,&#34;age&#34;}) public class SzzTestProcessor extends AbstractProcessor { } 不过貌似该接口并没有什么用处。
有资料表示 该可选参数可以从 processingEnv 获取到参数。
String resultPath = processingEnv.getOptions().get(参数); 实际上这个获取的参数是编译期通过入参 -Akey=name 设置的，跟 getSupportedOptions 没有什么关系。
getSupportedAnnotationTypes 获取当前的注解处理类能够处理哪些注解类型，默认实现是从SupportedAnnotationTypes注解里面获取；
注解值是个字符串数组 String [] ;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-30T08:57:40+08:00">
    <meta property="article:modified_time" content="2023-05-30T08:57:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java注解编译期处理AbstractProcessor详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>概述</h3> 
<p>我们接触的注解主要分为以下两类</p> 
<ol><li><strong>运行时注解</strong>：通过反射在运行时动态处理注解的逻辑</li><li><strong>编译时注解</strong>：通过注解处理器在编译期动态处理相关逻辑</li></ol> 
<p>平时我们接触的框架大部分都是运行时注解，比如：@Autowire @Resoure @Bean 等等。</p> 
<p>那么我们平时有接触过哪些编译期注解呢，<code>@Lombok</code> <code>@AutoService</code> 等等</p> 
<p>像这些<strong>编译时注解</strong>的作用都是自动生成代码，一是为了<strong>提高编码的效率</strong>，二是<strong>避免在运行期大量使用反射</strong>，通过在编译期利用反射生成辅助类和方法以供运行时使用。</p> 
<p>那这些编译器注解都是如何运行的呢? 又是怎么自动生成代码的呢？</p> 
<p>我们今天来详细介绍一下，不过再介绍之前，可以先简单了解一下 Java 注解的基本概念<br> <a href="https://blog.csdn.net/u010634066/article/details/80384125">Java 注解</a></p> 
<h3><a id="_34"></a>注解处理器</h3> 
<h4><a id="_38"></a>注解处理流程</h4> 
<p>注解编译期处理流程最关键的一个类就是 <strong>Processor</strong> ，它是注解处理器的接口类，我们所有需要对编译期处理注解的逻辑都需要实现这个 <strong>Processor</strong> 接口，当然，<strong>AbstractProcessor</strong> 抽象类帮我们写好了大部分都流程，所以我们只需要实现这个抽象类就可以很方便的定义一个<strong>注解处理器</strong>；</p> 
<p><img src="https://images2.imgbox.com/d1/97/E2jy0kzD_o.png" alt=""></p> 
<p>注解处理流程由多轮完成。每一轮都从编译器在源文件中搜索<strong>注解</strong>并选择适合这些注解的 <strong>注解处理器 (AbstractProcessor)</strong> 开始。每个<strong>注解处理器</strong>依次在相应的源上被调用。</p> 
<p>如果在此过程中生成了任何文件，则将以生成的文件作为输入开始另一轮。这个过程一直持续到处理阶段没有新文件生成为止。</p> 
<p>注解处理器的处理步骤：</p> 
<ul><li>在 java 编译器中构建；</li><li>编译器开始执行未执行过的注解处理器；</li><li>循环处理注解元素 (Element)，找到被该注解所修饰的类，方法，或者属性；</li><li>生成对应的类，并写入文件；</li><li>判断是否所有的注解处理器都已执行完毕，如果没有，继续下一个注解处理器的执行 (回到步骤 1)。</li></ul> 
<h4><a id="AbstractProcessor_70"></a>AbstractProcessor</h4> 
<p>这是注解处理器的核心抽象类，我们主要来看看里面的方法</p> 
<h5><a id="getSupportedOptions_78"></a>getSupportedOptions()</h5> 
<p>默认的实现是 从注解<code>SupportedOptions</code>获取值，该值是一个字符数组，例如</p> 
<pre><code>@SupportedOptions({"name","age"})
public class SzzTestProcessor extends AbstractProcessor {
}
</code></pre> 
<p>不过貌似该接口并没有什么用处。</p> 
<p>有资料表示 该可选参数可以从 processingEnv 获取到参数。</p> 
<pre><code>String resultPath = processingEnv.getOptions().get(参数);
</code></pre> 
<p>实际上这个获取的参数是编译期通过入参 <code>-Akey=name</code> 设置的，跟 getSupportedOptions 没有什么关系。</p> 
<h5><a id="getSupportedAnnotationTypes_112"></a>getSupportedAnnotationTypes</h5> 
<p>获取当前的<strong>注解处理类</strong>能够处理哪些注解类型，默认实现是从<code>SupportedAnnotationTypes</code>注解里面获取；<br> 注解值是个字符串数组 String [] ;<br> 匹配上的注解, 会通过当前的<strong>注解处理类</strong>的 process 方法传入。</p> 
<p>例如下面使用 * 通配符支持所有的注解</p> 
<pre><code>@SupportedAnnotationTypes("*")
@SupportedSourceVersion(SourceVersion.RELEASE_11)
public class PrintingProcessor extends AbstractProcessor {

}
</code></pre> 
<p>又或者可以直接重写这个接口</p> 
<pre><code>@Override
  public ImmutableSet&lt;String&gt; getSupportedAnnotationTypes() {
    return ImmutableSet.of(AutoService.class.getName());
  }
</code></pre> 
<p>最终他们生效的地方就是用来做过滤，因为处理的时候会获取到所有的注解，然后根据这个配置来获取自己能够处理的注解。</p> 
<h5><a id="getSupportedSourceVersion_153"></a>getSupportedSourceVersion</h5> 
<p>获取该注解处理器最大能够支持多大的版本，默认是从注解 <code>SupportedSourceVersion</code>中读取，或者自己重写方法，如果都没有的话 默认值是 <strong>RELEASE_6</strong></p> 
<pre><code>@SupportedSourceVersion(SourceVersion.RELEASE_11)
public class PrintingProcessor extends AbstractProcessor {

}
</code></pre> 
<p><strong>或者重写 (*<em>推荐*</em> , 获取最新的版本)</strong></p> 
<pre><code>@Override
  public SourceVersion getSupportedSourceVersion() {
    //设置为能够支持最新版本
    return SourceVersion.latestSupported();
  }
</code></pre> 
<h5><a id="init__184"></a>init 初始化</h5> 
<p>init 是初始化方法，这个方法传入了 ProcessingEnvironment 对象。一般我们不需要去重写它，直接使用抽象类就行了。<br> 当然你也可以根据自己的需求来重新</p> 
<pre><code>@Override
    public synchronized void init(ProcessingEnvironment pe) {
        super.init(pe);
        System.out.println("SzzTestProcessor.init.....");
        // 可以获取到编译器参数（下面两个是一样的）
        System.out.println(processingEnv.getOptions());
        System.out.println(pe.getOptions());

    }
</code></pre> 
<p>可以获取到很多信息，例如<strong>获取编译器自定义参数</strong>， 自定义参数的设置请看下面的 <strong>如何给编译期设置入参</strong> 部分</p> 
<p>一些参数说明</p> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Elements getElementUtils()</td><td>返回实现 Elements 接口的对象，用于操作元素的工具类。</td></tr><tr><td>Filer getFiler()</td><td>返回实现 Filer 接口的对象，用于创建文件、类和辅助文件。</td></tr><tr><td>Messager getMessager()</td><td>返回实现 Messager 接口的对象，用于报告错误信息、警告提醒。</td></tr><tr><td>Map&lt;String,String&gt; getOptions()</td><td>返回指定的参数选项。</td></tr><tr><td>Types getTypeUtils()</td><td>返回实现 Types 接口的对象，用于操作类型的工具类。</td></tr></tbody></table> 
<h5><a id="process__225"></a>process 处理方法</h5> 
<p>process 方法提供了两个参数，第一个是我们请求处理注解类型的集合（也就是我们通过重写 getSupportedAnnotationTypes 方法所指定的注解类型），第二个是有关当前和上一次循环的信息的环境。</p> 
<p>返回值表示这些注解是否由此 Processor 声明<br> 如果返回 true，则这些注解不会被后续 Processor 处理；<br> 如果返回 false，则这些注解可以被后续的 Processor 处理。</p> 
<pre><code>@Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        System.out.println("SzzTestProcessor.process.....;");

        return false;
    }
</code></pre> 
<p>我们可以通过 RoundEnvironment 接口获取注解元素，注意 annotations 只是注解类型，并不知道哪些实例被注解标记了，RoundEnvironment 是可以知道哪些被注解标记了的。</p> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a)</td><td>返回被指定注解类型注解的元素集合。</td></tr><tr><td>Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a)</td><td>返回被指定注解类型注解的元素集合。</td></tr><tr><td>processingOver()</td><td>如果循环处理完成返回 true，否则返回 false。</td></tr></tbody></table> 
<p>关于这部分的使用介绍，请看下面的<strong>自定义注解处理器范例</strong></p> 
<h3><a id="_266"></a>如何注册注解处理器</h3> 
<p>上面介绍了注解处理器的一些核心方法，那么我们<strong>如何注册注解处理器呢</strong>？</p> 
<p>并不是说我们实现了 <strong>AbstractProcessor</strong> 类就会生效，由于<strong>注解处理器 (AbstractProcessor)</strong> 是在编译期执行的，而且它是作为一个 Jar 包的形式来生效，所以我们需要将<strong>注解处理器</strong>作为一个单独的 Module 来打包。<br> 然后在需要使用到<strong>注解处理器</strong>的 Module 引用。</p> 
<p>这个<strong>注解处理器</strong> 所在 Module 打包的时候需要注意：</p> 
<p>因为 AbstractProcessor 本质上是通过 <strong>ServiceLoader</strong> 来加载的 (SPI), 所以想要被成功注册上。则有两种方式</p> 
<p><strong>一、配置 SPI</strong></p> 
<ol><li> <p>在<code>resource/META-INF.services</code>文件夹下创建一个名为<code>javax.annotation.processing.Processor</code>的文件；里面的内容就是你的<strong>注解处理器</strong>的全限定类名</p> <p><img src="https://images2.imgbox.com/02/74/7HpPYnqo_o.png" alt="img"></p> </li><li> <p>设置编译期间禁止处理 Process，之所以这样做是因为，如果你不禁止 Process，ServiceLoader 就会去加载你刚刚设置的<strong>注解处理器</strong>，但是因为是在编译期，Class 文件被没有被成功加载，所以会抛出下面的异常</p> <pre><code>服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Provider org.example.SzzTestProcessor not found时抛出异常错误
</code></pre> <p>如果是用 Maven 编译的话，请加上如下配置 <code>&lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt;</code></p> <pre><code>&lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.5.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;default-compile&lt;/id&gt;
                        &lt;configuration&gt;
                            &lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                    &lt;execution&gt;
                        &lt;id&gt;compile-project&lt;/id&gt;
                        &lt;phase&gt;compile&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;compile&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</code></pre> </li><li> <p>注解处理器打包成功，就可以提供给别的 Module 使用了</p> </li></ol> 
<p><strong>二、使用 @AutoService 自动配置 SPI 的配置文件</strong></p> 
<p>@AutoService 是 Google 开源的一个小插件，它可以自动的帮我们生成<code>META-INF/services</code> 的文件, 也就不需要你去手动的创建配置文件了。</p> 
<p>当然，上面的 <code>&lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt;</code>参数也不需要了。</p> 
<p>所以也就不会有编译期上述的问题<code>xxx not found </code>问题了。因为编译的时候<code>META-INF/services</code> 还没有配置你的<strong>注解处理器</strong>，也就不会抛出加载异常了。</p> 
<p>例如下面，使用 @AutoService(Processor.class)，他会自动帮我们生成对应的配置文件。</p> 
<pre><code>@AutoService(Processor.class)
public class SzzBuildProcessor extends AbstractProcessor {

}
</code></pre> 
<p><img src="https://images2.imgbox.com/de/74/yvziiK6B_o.png" alt="img"></p> 
<p>另外，实际上 <strong>@AutoService</strong> 自动生成配置文件也是通过 AbstractProcessor 来实现的。</p> 
<p>具体的使用方式请看 ：<a href="https://szzdzhp.blog.csdn.net/article/details/129923721" rel="nofollow">@AutoService 详解</a></p> 
<h3><a id="_381"></a>如何调试编译期代码</h3> 
<p>在我们自己写了注解处理器之后，可能想要调试，那么编译期的调试跟运行期的调试不一样。</p> 
<p>请看：<a href="https://szzdzhp.blog.csdn.net/article/details/129948032" rel="nofollow">如何在 IDEA 中调试编译期源码</a></p> 
<h3><a id="Maven___Processor_393"></a>Maven 相关配置 (指定生效的 Processor)</h3> 
<p>如果你使用的是 Maven 来编译，那么有一些参数可以设置</p> 
<p>比如<strong>指定注解处理器生效</strong> 、代码生成的源路径。默认是 <code>target/generated-sources/annotations</code></p> 
<p>除非特殊情况，一般不需要设置这些参数。</p> 
<pre><code>&lt;build&gt;
    &lt;plugins&gt;

        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;!-- 主动设置生成的源码的文件夹路径，默认的就是下面的地址。一般不需要主动设置除非你有自己的需求  --&gt;
                &lt;generatedSourcesDirectory&gt;${project.build.directory} /generated-sources/&lt;/generatedSourcesDirectory&gt;
                 &lt;!-- 指定生效的注解处理器，这里设置之后，只会有下面配置的注解处理器生效; 一般情况也不用主动配置，可以将下面的全部删除 --&gt;
                &lt;annotationProcessors&gt;
                    &lt;annotationProcessor&gt;
                            org.example.SzzTestProcessor
                    &lt;/annotationProcessor&gt;
                &lt;/annotationProcessors&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;

    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre> 
<h3><a id="_438"></a>注意事项</h3> 
<p><strong>注解</strong>和<strong>注解处理器</strong>是单独的 module：<strong>注解处理器</strong>只需要在编译的时候使用，注解的 Module 只需要引入注解处理器的 Jar 包就行了。因此我们需要将注解处理器分离为单独的 module。</p> 
<p>并且打包的时候请先打包<strong>注解处理器</strong>的 Module.</p> 
<p>自定义 Processor 类最终是通过打包成 jar，在编译过程中调用的。</p> 
<h3><a id="_454"></a>自定义注解处理器范例</h3> 
<h4><a id="__Build__458"></a>范例一： 自动生成 Build 构造器</h4> 
<p><strong>1. 需求描述</strong></p> 
<p>假设我们的注释用户模块中有一些简单的 POJO 类，其中包含几个字段：</p> 
<pre><code>public class Company {

    private String name;

    private String email ;
    
}

public class Personal {

    private String name;

    private String age;
}
</code></pre> 
<p>我们想创建对应的构建器帮助类来更流畅地实例化 POJO 类</p> 
<pre><code>Company company = new CompanyBuilder()
                .setName("ali").build();
        Personal personal = new PersonalBuilder()
                .setName("szz").build();
</code></pre> 
<p><strong>2. 需求分析</strong></p> 
<p>如果没有 POJO 都要手动的去创建对应的 Build 构建器，未免太繁杂了，我们可以通过注解的形式，去自动的帮我们的 POJO 类生成对应的 Build 构建器，但是当然不是每个都生成，按需生成；</p> 
<ol><li> <p>定义一个 @BuildProperty 注解，在需要生成对应的 setXX 方法的方法上标记注解</p> </li><li> <p>自定义 <strong>注解处理器</strong>扫描 @BuildProperty 注解，按照需求自动生成 Build 构建器。例如 CompanyBuilder</p> <pre><code>public class CompanyBuilder {

    private Company object = new Company();

    public Company build() {
        return object;
    }

    public CompanyBuilder setName(java.lang.String value) {
        object.setName(value);
        return this;
    }

}
</code></pre> </li></ol> 
<p><strong>3. 编码</strong></p> 
<p>创建一个注解处理器 Module：<strong>szz-test-processor-handler</strong></p> 
<p>@BuildProperty</p> 
<pre><code>@Target(ElementType.METHOD) // 注解用在方法上
@Retention(RetentionPolicy.SOURCE) // 尽在Source处理期间可用，运行期不可用
public @interface BuildProperty {
}
</code></pre> 
<p><strong>注解处理器</strong></p> 
<pre><code>@SupportedAnnotationTypes("org.example.BuildProperty") // 只处理这个注解；
public class SzzBuildProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        System.out.println("SzzBuildProcessor.process ;");

        for (TypeElement annotation : annotations) {
            // 获取所有被该注解 标记过的实例
            Set&lt;? extends Element&gt; annotatedElements = roundEnv.getElementsAnnotatedWith(annotation);

            // 按照需求 检查注解使用的是否正确 以set开头，并且参数只有一个
            Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(
                    Collectors.partitioningBy(element -&gt;
                            ((ExecutableType) element.asType()).getParameterTypes().size() == 1
                                    &amp;&amp; element.getSimpleName().toString().startsWith("set")));

            List&lt;Element&gt; setters = annotatedMethods.get(true);
            List&lt;Element&gt; otherMethods = annotatedMethods.get(false);

            // 打印注解使用错误的case
            otherMethods.forEach(element -&gt;
                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                            "@BuilderProperty 注解必须放到方法上并且是set开头的单参数方法", element));

            if (setters.isEmpty()) {
                continue;
            }


            Map&lt;String ,List&lt;Element&gt;&gt; groupMap = new HashMap();

            // 按照全限定类名分组。一个类创建一个Build
            setters.forEach(setter -&gt;{
                // 全限定类名
                String className = ((TypeElement) setter
                        .getEnclosingElement()).getQualifiedName().toString();
                List&lt;Element&gt; elements = groupMap.get(className);
                if(elements != null){
                    elements.add(setter);
                }else {
                    List&lt;Element&gt; newElements = new ArrayList&lt;&gt;();
                    newElements.add(setter);
                    groupMap.put(className,newElements);
                }
            });

            
            groupMap.forEach((groupSetterKey,groupSettervalue)-&gt;{
                //获取 类名SimpleName 和 set方法的入参
                Map&lt;String, String&gt; setterMap = groupSettervalue.stream().collect(Collectors.toMap(
                        setter -&gt; setter.getSimpleName().toString(),
                        setter -&gt; ((ExecutableType) setter.asType())
                                .getParameterTypes().get(0).toString()
                ));
                try {
                    // 组装XXXBuild类。并创建对应的类文件
                    writeBuilderFile(groupSetterKey,setterMap);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }

            });
        }

        // 返回false 表示 当前处理器处理了之后 其他的处理器也可以接着处理，返回true表示，我处理完了之后其他处理器不再处理
        return true;
    }

    private void writeBuilderFile(
            String className, Map&lt;String, String&gt; setterMap)
            throws IOException {

        String packageName = null;
        int lastDot = className.lastIndexOf('.');
        if (lastDot &gt; 0) {
            packageName = className.substring(0, lastDot);
        }

        String simpleClassName = className.substring(lastDot + 1);
        String builderClassName = className + "Builder";
        String builderSimpleClassName = builderClassName
                .substring(lastDot + 1);

        JavaFileObject builderFile = processingEnv.getFiler()
                .createSourceFile(builderClassName);

        try (PrintWriter out = new PrintWriter(builderFile.openWriter())) {

            if (packageName != null) {
                out.print("package ");
                out.print(packageName);
                out.println(";");
                out.println();
            }

            out.print("public class ");
            out.print(builderSimpleClassName);
            out.println(" {");
            out.println();

            out.print("    private ");
            out.print(simpleClassName);
            out.print(" object = new ");
            out.print(simpleClassName);
            out.println("();");
            out.println();

            out.print("    public ");
            out.print(simpleClassName);
            out.println(" build() {");
            out.println("        return object;");
            out.println("    }");
            out.println();

            setterMap.entrySet().forEach(setter -&gt; {
                String methodName = setter.getKey();
                String argumentType = setter.getValue();

                out.print("    public ");
                out.print(builderSimpleClassName);
                out.print(" ");
                out.print(methodName);

                out.print("(");

                out.print(argumentType);
                out.println(" value) {");
                out.print("        object.");
                out.print(methodName);
                out.println("(value);");
                out.println("        return this;");
                out.println("    }");
                out.println();
            });

            out.println("}");
        }
    }

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        System.out.println("----------");

        System.out.println(processingEnv.getOptions());

    }
    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }


}
</code></pre> 
<p><strong>4. 注册注解处理器</strong></p> 
<p><img src="https://images2.imgbox.com/65/58/4rk8OsTa_o.png" alt="img"></p> 
<p><strong>5. 配置编译参数</strong></p> 
<p>因为这里选择的是手动配置了 <code>META-INF.services</code>; 所以我们需要配置一下编译期间忽略 Processor；<br> 主要参数就是</p> 
<pre><code>&lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt;
</code></pre> 
<p>如下所示</p> 
<pre><code>&lt;build&gt;
        &lt;pluginManagement&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.5.1&lt;/version&gt;
                    &lt;configuration&gt;
                        &lt;source&gt;1.8&lt;/source&gt;
                        &lt;target&gt;1.8&lt;/target&gt;
                    &lt;/configuration&gt;
                    &lt;executions&gt;
                        &lt;execution&gt;
                            &lt;id&gt;default-compile&lt;/id&gt;
                            &lt;configuration&gt;
                                &lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt;
                            &lt;/configuration&gt;
                        &lt;/execution&gt;
                        &lt;execution&gt;
                            &lt;id&gt;compile-project&lt;/id&gt;
                            &lt;phase&gt;compile&lt;/phase&gt;
                            &lt;goals&gt;
                                &lt;goal&gt;compile&lt;/goal&gt;
                            &lt;/goals&gt;
                        &lt;/execution&gt;
                    &lt;/executions&gt;
                &lt;/plugin&gt;

             &lt;/plugins&gt;

        &lt;/pluginManagement&gt;

    &lt;/build&gt;
</code></pre> 
<p><strong>6. 执行编译打包</strong></p> 
<p>mvn install 一下, 其他 Module 就可以引用了。</p> 
<p><strong>7. Demo Module 依赖注解处理器</strong></p> 
<p>创建一个新的 Module： <strong>szz-test-demo</strong> ; 让它依赖上面的 <strong>szz-test-processor-handler</strong></p> 
<p>并在 Company 的一些方法上使用注解。</p> 
<p><img src="https://images2.imgbox.com/7b/87/QhKLyE4I_o.png" alt="img"></p> 
<p><strong>8. Demo Module 进行编译，会自动生成 BuildCompany 类</strong></p> 
<p>Demo Module 编译之后，就会在 target 文件夹生成 BuildXXX 类。 并且只有我们用注解 BuildProperty 标记了的方法才会生成对应的方法。<br> 而且如果注解 BuildProperty 使用的方式不对，我们也会打印出来了异常。</p> 
<p><img src="https://images2.imgbox.com/d9/46/W6namfYL_o.png" alt="img"></p> 
<h4><a id="_824"></a>范例二：</h4> 
<p>待补充。</p> 
<h3><a id="_832"></a>如何给编译期设置入参</h3> 
<p>在 init 初始化的接口中，我们可以获取到编译器的一些自定义参数;</p> 
<pre><code>String verify = processingEnv.getOptions().get("自定义key");
</code></pre> 
<p>注意这个获取到的编译器参数只能获取的是以<code>-A开头</code>的参数，因为是过滤之后的</p> 
<p><img src="https://images2.imgbox.com/ce/b8/C97CUc7C_o.png" alt="img"></p> 
<p>那么这个自定义参数从哪里设置的呢？</p> 
<p><strong>如果你是 IDEA 编译</strong></p> 
<pre><code>-Akey=value 或者 -Akey
</code></pre> 
<p><img src="https://images2.imgbox.com/39/b0/5zHwdCN6_o.png" alt="img"></p> 
<p><strong>如果是用 Maven 编译</strong></p> 
<p><img src="https://images2.imgbox.com/57/44/Rdss8Zyk_o.png" alt="img"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/34933e5d966b18e2325bb5f6f2638fa9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java高级编程——多线程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ffd05011f83784c448fa6056571d28c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JVM总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>