<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d367174f07c0f3b41cc8b25631b12a2/" rel="bookmark">
			【附安装包】Java/JDK介绍、下载、安装、配置与使用（保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
1、Java历史
2、Java介绍（JDK、JRE、JVM）
3、Java运行机制
4、Java跨平台性
5、JDK版本选择
二、下载安装
1、JDK下载
2、JDK安装
三、配置环境变量
四、测试与使用
1、测试
2、使用
一、概述 1、Java历史 Java语言诞生于SUN（Stanford University Network）公司，创始人是詹姆斯·高斯林。1995年5月23日定名为Java，1996年1月JDK1.0正式发布，2009年4月20日甲骨文以现金74亿美元收购SUN公司，2014年3月18日JDK8.0发布，目前JDK最新的版本是2023年9月19日发布的JDK21.0。
2、Java介绍（JDK、JRE、JVM） JDK(Java Developer's Kit、Java开发工具包) = JRE + 开发工具(javac.exe,java.exe,javadoc.exe等)；JRE(Java Runtime Environment、Java运行环境) = JVM + 核心类库(常用类：String、日期时间、数学、集合、IO、网络、多线程等)；JVM(Java Virtual Machine、Java虚拟机)：一个虚拟的计算机，用于运行Java程序。
3、Java运行机制 编写.java的源文件，经javac.exe编译为.class的字节码文件，经java.exe运行于Java虚拟机上，此时字节码转为CPU能执行的机器指令。
4、Java跨平台性 通过Java语言编写的应用程序在不同的系统平台上均可运行（一次编写，处处运行）；Java程序不是直接运行在操作系统上，而是运行在JVM上的。而不同的操作系统平台，可以安装不同的JVM。
5、JDK版本选择 LTS（Long Term Support）是指长期支持的版本，会获得至少5-8年的支持，适用于生产环境；STS（Short Term Support）是指短期支持的版本，只会获得6个月的支持，适用于开发环境体验新特性。所以简单来说，oracleJDK的LTS版本才是生产环境首选，而STS版本更适用于开发测试环境，如果你的项目重视稳定性和长期使用，建议选择LTS版本，例如JDK8、11、17、21。如果你只是想尽快体验到Java的新特性，也可以选择最近的STS版本。总而言之，两种版本各有优势，需要根据具体使用场景进行选择。
视频讲解：
①概述【小白福音】Java构成、运行机制、版本选择_哔哩哔哩_bilibili
②实操【秒会! 附安装包】Java下载、安装、配置与使用_哔哩哔哩_bilibili
二、下载安装 1、JDK下载 进入Oracle官网https://www.oracle.com，按下图依次操作，也可以直接访问https://www.oracle.com/java/technologies/downloads/archive/。
选择自己需要的JDK版本，这里以JDK-8u381为例。
根据自己电脑的操作系统，选择对应的JDK。因为我电脑装的是Windows操作系统，所以这里我选择Windows版本的JDK。点击红色框内链接进行下载。值得注意的是，首次下载需要注册登录。
或直接使用我提前下载的安装包，关注微信公众号 程序员钟霖，回复 Java安装包 获取。
2、JDK安装 双击下载好的JDK安装包，进入安装向导，如下图所示，点击下一步。
更改安装路径，建议路径名不要有中文/空格、目标文件夹命名携带JDK版本号。
因为JDK中已经包含JRE，故不需要安装独立的JRE，按下图操作取消安装独立的JRE。
依次点击下一步、关闭，完成JDK的安装。
三、配置环境变量 在电脑桌面右击【我的电脑】，依次点击属性、高级系统设置、环境变量，进入环境变量设置页面。
在环境变量设置页面，按下图顺序添加变量“JAVA_HOME”，值为JDK的安装路径。
双击系统变量中的Path变量，按下图顺序添加环境变量。
四、测试与使用 1、测试 按下"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d367174f07c0f3b41cc8b25631b12a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bfdea30c9b08e3d6942f1ef12af4c89/" rel="bookmark">
			泰克Tektronix MSO4104B示波器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泰克MSO4104B示波器是一款功能强大的数字示波器，它具有高带宽、高采样率和多功能的特点，可以满足多种应用场景的需求。
泰克MSO4104B示波器采用了最先进的技术，配备了高精度的硬件和软件，为用户提供了全面的测试和测量解决方案。它可以实时捕获、分析和存储信号，适用于各种应用场景，如高速数字系统、电源和音频测试等
。
使用泰克MSO4104B示波器可以帮助工程师更准确地了解信号的特性和性能，更好地分析系统的问题和故障，并且更加方便地设计、测试和调试电路。它的特点在于可以提供多个通道同时进行测试，使得测量速度更快，同时也极大地简化了操作流程，降低了测试难度。
除了实时测量外，泰克MSO4104B示波器还支持对信号进行离线分析，以及采用多种触发方式和滤波器进行信号过滤，可以帮助用户更好地观测信号细节，提高测量精度和准确性。
除此之外，泰克MSO4104B示波器还支持多种标准接口，如USB、LAN和VGA等，可以方便地与其他设备进行连接和集成，使得数据传输更加便捷。同时，它也支持多种文件格式的存储和输出，方便用户进行数据分析和处理。
总的来说，泰克MSO4104B示波器是一款非常优秀的数字示波器，具有广泛的应用场景和强大的测量能力它。可以提高测试效率、降低测量成本并保障系统稳定性，是一款值得信赖的测试设备。
泰克MSO4104B示波器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6eb544efbda029fc697c6220fb825e7/" rel="bookmark">
			计算机毕业设计：500个开源项目推荐（源码&#43;论文）大数据&#43;JAVA&#43;Python&#43;深度学习✅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人 ，点赞关注不迷路。
文章目录 1、Python项目选题（1）优秀项目（2）招聘项目（3）电影项目（4）音乐项目（5）电商+购物+商品商城项目（6）旅游项目（7）租房+商品房项目（8）新闻项目（9）图书+小说项目（10）情感分析+舆情分析项目（11）美食项目（12）评论数据分析项目（13）人脸识别项目（14）车牌识别项目（15）汽车+交通项目（16）金融+股票项目（17）课堂+考研考试+成绩项目（18）医疗医药项目（19）推荐系统项目（20）管理系统项目（21）未分类项目1（22）未分类项目2 2、深度学习项目选题3、Java项目选题选题指导 1、Python项目选题 （1）优秀项目 项目名称使用技术气象数据采集+预测算法+可视化系统+文档Flask框架、requests爬虫、Echarts可视化、多元线性回归预测模型-scikit-learn机器学习、定时采集任务网易云音乐数据采集+可视化分析大屏系统+文档Flask框架、requests爬虫、Echarts可视化招聘推荐系统+爬虫+可视化（协同过滤算法）猎聘Django框架、基于物品的协同过滤推荐算法、Selenium爬虫库、猎聘网旅游推荐系统+爬虫+文档Django框架、requests爬虫、基于用户协同过滤推荐算法、去哪儿旅游网电商销售数据分析+算法预测+可视化大屏系统Flask框架、Selenium爬虫、Echarts可视化、多元线性回归预测模型-scikit-learn机器学习、淘宝网朴素贝叶斯垃圾邮件分类与检测+可视化+文档Flask框架、TF-IDF特征提取、多项式朴素贝叶斯算法、Echarts可视化网络爬虫与协同过滤算法电影推荐系统（vue前端）Django框架、requests爬虫、vue前端框架、抓取豆瓣电影、基于用户的协同过滤+基于物品的协同过滤推荐算法、bootstrap3框架超市商品营收数据可视化大屏系统+文档Flask框架、Echarts可视化、Html、实时大屏租房数据爬虫+可视化系统+文档Flask框架、Layui前端框架、requests爬虫、Echarts可视化、链家租房网Django招聘推荐系统+可视化（协同过滤算法）Django框架、scrapy爬虫、智联招聘网、协同过滤推荐算法、Echarts可视化招聘招聘数据分析可视化系统+爬虫 7种薪资预测模型Flask框架、requests爬虫、Layui前端框架、Echarts可视化、7种预测模型、拉钩招聘网音乐推荐系统（2种算法+播放+标签）Django框架、协同过滤推荐算法（基于物品+基于用户）、音乐在线播放拉钩招聘数据爬虫+分析可视化系统 随机森林预测算法+文档Flask框架、requests爬虫、拉钩招聘网、随机森林算法预测薪资电影推荐系统+爬虫+可视化+Django框架+文档Django框架、协同过滤推荐算法（基于物品+基于用户）、Echarts可视化公开数据集的音乐推荐系统+文档（用户画像+协同过滤）Django框架、用户画像+基于用户的协同过滤推荐算法、数据集是Last.fm Dataset 歌曲数据集语料库构建与情感分析系统+文档Django框架、requests爬虫、 opencv-Python、tensorflowFlask美食数据采集分析系统+文档Flask框架、Layui框架、MySQL数据库、Html高考志愿+高校推荐系统+文档Django框架、推荐算法、性格测试、高校专业查询Django选课系统+文档Django框架、Echarts可视化、Htmlsteam游戏数据分析系统+文档Django框架、Echarts可视化、requests爬虫民宿预定系统+文档Django框架、vue框架、HtmlDjango记账分析可视化+文档Django框架、Echarts可视化、HtmlDjango邮件分类检测系统+文档Django框架、朴素贝叶斯分类算法、HtmlDjango房屋中介管理系统+文档Django框架、Bootstrap框架、HtmlBoss直聘数据分析可视化+爬虫Flask框架、selenium爬虫、Echarts可视化、Boss直聘网Django图书馆管理+可视化+文档Django框架、MySQL数据、Echarts可视化、图书借阅、图书管理Django招聘推荐系统+可视化+爬虫（智联）Django框架、scrapy爬虫、智联招聘网、协同过滤推荐算法、Echarts可视化Django就业管理系统+多角色+岗位投递Django框架、Bootstrap框架、HtmlFlask人脸识别考勤管理系统Flask框架、MySQL数据库、Dlib库、刷脸签到、多角色登录农业数据分析可视化+预测Flask框架、MySQL数据库 机器学习预测算法（XGBoost模型） Echarts可视化、layui框架、html+css+js水文水资源数据采集预测与可视化分析Flask框架、MySQL数据库、多元线性回归预测算法、Echarts可视化、Layui框架Flask全国气象数据采集及可视化大屏Flask框架、MySQL数据库 、requests爬虫框架、Echarts可视化天气数据采集分析可视化（杏）Flask框架、Echarts可视化、requests爬虫、HTML 部分项目界面演示：
（2）招聘项目 项目名称使用技术boss直聘招聘数据+爬虫+可视化+Django框架+讲解Django框架、selenium爬虫、Echarts可视化、Boss直聘网2023招聘推荐系统+爬虫+可视化（协同过滤算法）猎聘+论文Django框架、基于物品的协同过滤推荐算法、Selenium爬虫库、猎聘网拉钩招聘数据爬虫+可视化+7种预测算法+论文Flask框架、requests爬虫、Layui前端框架、Echarts可视化、7种预测模型、拉钩招聘网2023拉钩招聘数据爬虫+分析可视化系统 随机森林预测算法+论文Flask框架、requests爬虫、拉钩招聘网、随机森林算法预测薪资Flask+招聘双推荐算法+爬虫+可视化系统Flask框架、Vue框架 协同过滤推荐算法（基于用户+基于物品）招聘爬虫 机器学习、Echarts招聘数据+多元爬虫+预测推荐（智联）Flask框架 多元爬虫 实时数据分析 薪资预测+推荐 Echarts可视化大屏、vue前端、BeautifulSoup4、智联招聘招聘推荐+爬虫+可视化（协同过滤算法）Django框架、scrapy爬虫、智联招聘网、协同过滤推荐算法、Echarts可视化招聘推荐系统+可视化（协同过滤算法）Django框架、scrapy爬虫、智联招聘网、协同过滤推荐算法、Echarts可视化Flask招聘数据可视化大屏Flask框架 bootstrap前端框架 MySQL数据库 可视化大屏 echarts可视化 51job招聘网站简单版_招聘数据爬虫+清洗+可视化Flask框架、Echarts可视化、智联招聘、requests 爬虫猎聘数据采集可视化+机器学习预测Django框架、基于物品的协同过滤推荐算法、Selenium爬虫库、猎聘网招聘+租房爬虫可视化系统Flask框架、Layui前端框架、requests爬虫、Echarts可视化、链家租房网、拉钩招聘网就业招聘信息推荐分析系统（推荐算法+爬虫+可视化+Django框架）Django框架、协同过滤推荐算法、requests爬虫库boss直聘_招聘数据爬虫+清洗+可视化系统Flask框架、selenium爬虫、Echarts可视化、Boss直聘网Django招聘可视化+机器学习预测（随机森林）Django框架、requests爬虫、拉钩招聘网、随机森林算法预测薪资Flask招聘数据分析可视化（前程无忧）Flask框架、Echarts可视化、前程无忧网站Flask智联招聘大屏Flask框架、Echarts可视化、智联招聘网站IT类招聘信息数据分析可视化系统Flask框架、Echarts可视化、前程无忧数据IT行业招聘数据分析可视化系统Flask框架、Echarts可视化基于Python的招聘岗位数据爬虫+分析可视化大屏（51job）Flask框架、Echarts可视化、前程无忧数据就业完全版系统（推荐算法-拉钩）Flask框架、Layui框架、MySQL数据库、基于标签的推荐算法、拉钩招聘网站、神经网络作薪资预测模型招聘数据分析可视化系统（51job+vue）Django框架、vue框架、51job数据Django招聘推荐系统+可视化Django框架、协同过滤推荐算法、Echarts可视化拉钩招聘数据分析+7种预测模型+推荐Flask框架、Layui前端框架、基于标签的推荐算法、拉钩招聘、7个预测模型、sklearn机器学习、神经网络、爬虫已失效51job招聘爬虫+数据分析（前程无忧）Django框架、vue前端框架、scrapy 爬虫框架、Echarts、岗位推荐、薪资预测Django+Python招聘数据分析系统+mangodbDjango框架 bootstrap框架 html Echarts可视化Django+招聘信息+可视化Django框架 bootstrap框架 html Echarts可视化Flask+boss直聘-招聘信息获取与分析Django框架 bootstrap框架 html Echarts可视化Django的招聘信息数据可视化Django框架 bootstrap框架 html Echarts可视化Django+招聘可视化+简历Django框架 bootstrap框架 html Echarts可视化Django+中医招聘+可视化Django框架 bootstrap框架 html Echarts可视化Python的招聘信息+Django可视化分析系统Django框架 bootstrap框架 html Echarts可视化Django基于Python的数据分析岗位招聘信息爬取与分析Django框架 bootstrap框架 html Echarts可视化20Django基于协同过滤算法的招聘信息推荐系统Django框架 bootstrap框架 html Echarts可视化Django就业管理系统+多角色+岗位投递Django框架、Bootstrap框架、Html 部分项目界面演示：
（3）电影项目 项目名称使用技术Flask+LSTM电影双推荐算法+爬虫+情感分析+可视化系统（深度学习）Flask框架+LSTM算法 Vue框架 协同过滤推荐算法（基于用户+基于物品）电影爬虫 机器学习、Echarts 深度学习神经网络LSTM算法（情感分析）网络爬虫与协同过滤算法电影推荐系统（vue前端）Django框架、requests爬虫、vue前端框架、抓取豆瓣电影、基于用户的协同过滤+基于物品的协同过滤推荐算法、bootstrap3框架2023电影数据爬虫+可视化+协同过滤推荐系统Django框架、requests、Scrapy爬虫框架、基于用户的协同过滤推荐算法、Echarts可视化、词云、bootstrap3框架、html/js电影推荐算法+爬虫+可视化系统Django框架、requests、豆瓣电影、协同过滤推荐算法、爬虫、echarts可视化2024豆瓣电影+爬虫+可视化分析+讲解Flask框架、MySQL数据库、Echarts可视化、requests爬虫技术、豆瓣电影数据、讲解视频豆瓣电影数据爬虫与可视化系统Django框架 requests爬虫 bootstrap框架 html Echarts可视化电影数据分析可视化系统Django框架 bootstrap框架 html Echarts可视化豆瓣电影爬虫+清洗+可视化系统Flask框架、爬虫、数据清洗、Echarts可视化、豆瓣电影数据、讲解视频基于Python的Flask框架开发的在线电影网站系统Flask框架、 bootstrap框架 html基于Python的电影推荐系统Django框架、基于用户的协同过滤+基于物品的协同过滤推荐算法、前端: bootstrap3框架 + vue3 + jquery、Django-simpleui后台基于Python的电影推荐+可视化系统Django框架、jieba分词库、scikit_learn机器学习库、协同过滤推荐算法（基于物品）、Echarts可视化电影管理网站Django框架、vue框架、MySQL数据库、Navicat管理、click、Django-threadlocals、requests、Python-alipay-sdkFlask电影票房数据分析系统Flask框架、MySQL数据库、Echarts可视化电影推荐系统（物品协同过滤+可视化）Django框架、requests、豆瓣电影、协同过滤推荐算法、爬虫、echarts可视化豆瓣电影爬虫+清洗+可视化系统Flask框架、爬虫、数据清洗、Echarts可视化、豆瓣电影数据、讲解视频影片数据爬取与可视化_uxq8i+论文Django框架、requests、豆瓣电影、协同过滤推荐算法、爬虫、echarts可视化Django+电影+知识图谱+推荐Django框架 bootstrap框架 html Echarts可视化Django+豆瓣电影协同过滤推荐+影评分词分类Django框架 bootstrap框架 html Echarts可视化Django+基于Python的电影推荐系统的设计与系统Django框架 bootstrap框架 html Echarts可视化Flask+中国电影知识图谱Django框架 bootstrap框架 html Echarts可视化Flask+电影票房可视化+推荐Django框架 bootstrap框架 html Echarts可视化Flask+Python爬虫的豆瓣电影数据可视化分析Django框架 bootstrap框架 html Echarts可视化Flask+电影票房分析可视化+预测Django框架 bootstrap框架 html Echarts可视化Django电影个性化推荐系统Django框架 bootstrap框架 html Echarts可视化05Django基于Python的Django框架开发的在线电影网站系统Django框架 bootstrap框架 html Echarts可视化27Python基于Python的电影票购票系统Django框架 bootstrap框架 html Echarts可视化28Python基于Python的豆瓣电影数据分析可视化系统Django框架 bootstrap框架 html Echarts可视化34基于Python的电影票房爬取与可视化系统的设计与实现Django框架 bootstrap框架 html Echarts可视化Python009基于推荐算法的电影推荐系统Django框架 bootstrap框架 html Echarts可视化Python011基于Python和协同过滤算法的电影推荐系统Django框架 bootstrap框架 html Echarts可视化 部分项目界面演示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6eb544efbda029fc697c6220fb825e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8158a35a7faca383431c5c3b18b272e4/" rel="bookmark">
			win11 激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是查看 win11 到期的命令
slmgr.vbs /xpr
下载地址
沧水的KMS服务 - Kms激活|Windows激活|Office激活|Windows下载|Office下载|搭建KMS服务器
直接本地下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d337834ef320e26f959ad8d7c5bbdb/" rel="bookmark">
			陷波器设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.matlab 代码
&gt;&gt; Zeta = 0.01;%设计滤波深度 &gt;&gt; Wn = 100;%设计滤波器频率 &gt;&gt; Width = 2;%设计滤波器宽度 &gt;&gt; s = tf('s') s = s 连续时间传递函数。 模型属性 &gt;&gt; notch = (s^2 + 2*Wn*Zeta*s + Wn^2)*(Wn/Width)*(Wn*Width)/(Wn^2*(s+Wn/Width)*(s+Wn*Width));%陷波器传递函数 &gt;&gt; notch notch = 10000 s^2 + 20000 s + 1e08 --------------------------- 10000 s^2 + 2.5e06 s + 1e08 连续时间传递函数。 模型属性 &gt;&gt; bode(notch) &gt;&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c2d1145b99281ad0351042bca084711/" rel="bookmark">
			2023最新最全【Notepad&#43;&#43;】安装教程【附安装包】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Notepad ++ 获取与安装 ——————————
Notepad ++ 是什么 在运行中输入 notepad 会弹出来记事本： 所以 Notepad ++ 就是增强的记事本！这个跟 C 与 C ++ 的名字是一样滴！ Notepad++ 是开源软件 GPL 许可证 可以免费使用 自带中文 支持很多计算机编程语言 Notepad ++ 是 Windows 操作系统下的一套文本编辑器 软件版权许可证 GPL 有完整的中文化接口及支持多国语言编写的功能 UTF8 技术 Notepad ++ 功能比 Windows 中的 Notepad/记事本 强大 除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码 Notepad ++ 不仅有语法高亮度显示，也有语法折叠功能，并且支持宏以及扩充基本功能的外挂模组 Notepad ++ 是免费软件，可以免费使用，自带中文，支持众多计算机程序语言: C C++ Java pascal C# XML SQL Ada HTML PHP ASP AutoIt 汇编 DOS 批处理 Caml COBOL Cmake CSS D Diff ActionScript Fortran Gui4Cli Haskell INNO JSP KIXtart LISP Lua Make 处理/Makefile Matlab INI 文件 MS-DOS Style NSIS Normal text Objective-C Pascal Python Javascript Verilog Haskell InnoSetup CMake VHDL Matlab ——————————
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c2d1145b99281ad0351042bca084711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a6be6a86abf6bab9fd56dc1ec7b43a/" rel="bookmark">
			最简攻略，一分钟搞定（保姆级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，系统更新经常出大大小小的bug，更新就会出现需要激活的告知，接下来你只需复制粘贴就好，不需要额外下载安装什么anaconda之类的。
1.在桌面新建一个文本文档，把以下代码复制进去，如图所示： slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX slmgr /skms kms.03k.org slmgr /ato
然后ctrl+s保存好
2. 另存为或者自行将此文件后缀名由.txt改为.bat
3.右键此文件，选择“以管理员身份运行”
4.之后自动弹出cmd窗口，然后不用管了，之后还会弹出以下三个窗口，每次都点击确定即可
5.激活成功 ，感觉有帮助小伙伴可以顺手点个赞哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a61cfc508cd10c5930e938791f659d/" rel="bookmark">
			从零开发短视频电商 Java开发者的AI大模型（LLM）应用开发和设计-LangChain4j
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介示例1.添加依赖2.设置OpenAI API 密钥3.创建模型的实例并开始交互 功能实践爬取网页并embeddingHuggingFace在线API集成加载离线model 简介 Github:
https://github.com/langchain4j
https://github.com/langchain4j/langchain4j
https://github.com/langchain4j/langchain4j-embeddings
https://github.com/langchain4j/langchain4j-examples
Java版langchain, 利用LLMs的力量增强你的java应用程序。
该项目的目标是简化 AI/LLM 功能到 Java 应用程序的集成。
可以通过以下方式实现：
一个简单且连贯的抽象层，旨在确保您的代码不依赖于具体实现，例如 LLM providers, embedding store providers,等。这允许轻松替换组件。上述抽象的多种实现，为您提供了多种 LLMs 和嵌入存储可供选择。LLM 之上的一系列热门功能，例如： 获取您自己的数据 own data（文档、代码库等）的能力，允许LLM 根据您的数据采取行动和做出响应。用于将任务（动态定义）委托给LLM的自主代理 agents ，LLM将努力完成这些任务。提示模板 Prompt templates 可帮助您获得最高质量的 LLM 回复。记忆Memory 为LLM提供您当前和过去对话的背景信息。用于接收来自 LLM 的响应的结构化输出，具有所需的结构（如 Java POJO）。“AI 服务”，用于在简单的 API 背后声明性地定义复杂的 AI 行为。减少常见用例中对大量样板代码的需求的链 Chains 。自动调节以确保LLM的所有输入和输出都不会有害。 这个更像是一个大的框架，给你从头到尾梳理了个标准的流程，我认为是一个很大的解决方案。
Spring Boot 3 的支持
兼容性：Java8 或更高, Spring Boot: 2 or 3
示例 1.添加依赖 &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-open-ai&lt;/artifactId&gt; &lt;version&gt;0.24.0&lt;/version&gt; &lt;/dependency&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08a61cfc508cd10c5930e938791f659d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506cab3bfd2043c73e2b715c8dfc47e3/" rel="bookmark">
			Maven 私服搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 配置模板servermirror RELEASE、SNAPSHOT版本区别发行版（RELEASE）快照（SNAPSHOT） mvn deploy 配置模板 server &lt;!--第一个server-id要和下面的mirror中的id一致，代表拉取是也需要进行身份校验--&gt; &lt;server&gt; &lt;id&gt;company-java&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;company&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;!-- jar上传时候进行验证，id对应的是pom中id属性的值--&gt; &lt;id&gt;tcReleases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;company&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;tcSnapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;company&lt;/password&gt; &lt;/server&gt; mirror &lt;mirror&gt; &lt;id&gt;company-java&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;company java&lt;/name&gt; &lt;url&gt;http://192.168.7.10:8081/repository/java-group/&lt;/url&gt; &lt;/mirror&gt; 1.3 profile &lt;profile&gt; &lt;!-- 私服配置id java maven private server --&gt; &lt;id&gt;company-jmps&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;!-- 私服仓库列表 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;company-java&lt;/id&gt; &lt;name&gt;company java&lt;/name&gt; &lt;!-- 虚拟的URL形式,指向镜像的URL--&gt; &lt;url&gt;http://192.168.7.10:8081/repository/java-group/&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;!-- 从该仓库下载releases版本的构件--&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/506cab3bfd2043c73e2b715c8dfc47e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d93edee81008a18ce1400ada5c91e4/" rel="bookmark">
			【java学习】面向切面编程（AOP，Aspect Orient Programming）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，AOP使用场景 面向对象编程（OOP）是从静态角度考虑程序结构，面向切面编程（AOP）是从动态角度考虑程序执行过程。
OOP是从上到下定义问题，AOP通过从左到右定义问题。将一些具有横切性质的系统性服务定义为一个切面，自动注入到目标对象即可统一处理。如事物管理、安全检查、缓存、对象池管理等。
1）优点 不修改原代码，就可以在主干功能里面添加新功能。
2，实现 AspectJ不是Spring组成部分，是独立的AOP框架，一般把AspectJ和Spring框架一起使用进行AOP操作。
常用注解：
注解场景说明备注@EnableAspectJAutoProxy开启Spring对AspectJ代理的支持@Aspect声明一个切面类@Order(数字）设定切面类的优先级。数字越小优先级越高，从0开始。@Pointcut声明切点@Before在切点方法之前执行声明前置通知@After在切点方法之后执行声明后置通知@AfterReturning切点方法返回后执行（发生异常就不会执行）@AfterThrowing切点方法抛异常执行@Around属于环绕增强，能控制切点执行前、执行后声明环绕通知 引入依赖：org.springframework:spring-aspects
1）切面类（aspect） 用@Aspect 声明，同时用@Component声明其是一个bean类。
注意：切面类不会被其他切面自动拦截。
切面（aspect）
按关注点进行模块分解时，横切关注点就表示为一个切面。
连接点（join point）
程序执行的某一刻，可以在这个点上添加额外的动作。
通知（advice）
切面在特定join point上执行的动作。
切入点（pointcut）
用来描述连接点的，它决定了当前代码与连接点是否匹配。
2）切入点（切点，point cut） 通过@Pointcut申明。
//公共切入点抽取 @Pointcut(value="切入点表达式") public void pointDemo(){} @Before(value="pointDemo()") 常用PCD（pointcut designator，切入点标识符）：
1&gt;execution 最常用PCD；匹配特定方法的执行。
AspectJ 5表达式： //[]表示可选项； //&lt;&gt;表示必选项。 execution([权限修饰符]&lt;返回类型&gt;[全限定类名.]&lt;方法&gt;(&lt;参数&gt;)[异常]) -每个部分都可以用*表示 -全限定类名：.*表示包中所有类，..*表示当前包与子包中的所有类。 -参数列表: ()表示方法无参数 (..)表示有任意个参数 (*)表示有一个任意类型的参数 (String)表示有一个String类型参数 (String,String)表示有2个String类型参数 //举例： execution(public com.luo.test.User.add(..)) //User类add方法 execution(* com.luo.test.User.*(..)) //所有方法 execution(* com.luo.test.*(..)) //所有类 execution(* com.luo.test.DeptService+) //表示接口的所有方法以及实现了该接口的所有方法都被aop代理 使用&amp;&amp;、||、!、三种运算符来组合切点表达式，表示与或非的关系。 2&gt;within 匹配特定范围内的类型，可以用通配符匹配某个java包内所有的类。
@within
3&gt;this aop代理对象这个bean本身要匹配某个给定的类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d93edee81008a18ce1400ada5c91e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f608d98e1c69e039c47fa4d2a631878/" rel="bookmark">
			c语言-＞自定义类型联合体和枚举类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 前言 ✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉
🍎个人主页：橘橙黄又青_C语言,函数,指针-CSDN博客
目的：学习联合体和枚举类型的声明联合体的特点和大小，枚举类型的有点和使用。
1. 联合体类型的声明 像结构体⼀样，联合体也是由⼀个或者多个成员构成，这些成员可以不同的类型。 但是编译器只为最⼤的成员分配⾜够的内存空间。联合体的特点是所有成员共⽤同⼀块内存空间 。所 以联合体也叫：共⽤体。 给联合体其中⼀个成员赋值，其他成员的值也跟着变化。 #include &lt;stdio.h&gt; //联合类型的声明 union Un { char c; int i; }; int main() { //联合变量的定义 union Un un = {0}; //计算连个变量的⼤⼩ printf("%d\n", sizeof(un)); return 0; } 输出结果：
4
为什么是4呢？接下来我们来了看
1.2 联合体的特点 联合的成员是共⽤同⼀块内存空间的，这样⼀个联合变量的⼤⼩，⾄少是最⼤成员的⼤⼩（因为联合 ⾄少得有能⼒保存最⼤的那个成员）。 我们来看两个例子你就知道了 案例1： //代码1 #include &lt;stdio.h&gt; //联合类型的声明 union Un { char c; int i; }; int main() { //联合变量的定义 union Un un = {0}; // 下⾯输出的结果是⼀样的吗？ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f608d98e1c69e039c47fa4d2a631878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b67269c0796fe3a240c2a4889d20ce5/" rel="bookmark">
			2023最新最全【Android Studio 】下载及安装和【Gradle配置】零基础入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 下载安装修改Sdk的位置创建项目修改Gradle的位置查看AS版本工具栏–View项工具栏–Build下的功能说明Build Variants视图说明下载模拟器（avd）/安卓虚拟设备 屏幕熄灭功能关闭虚拟设备功能删除自己开发的应用软件将开发的应用运行到虚拟设备上。 修改模拟器的位置 下载 下载地址：官方下载地址
打开后往下拉，直到最后的I agree to the terms.
这里选择的android studio版本是：2021.2.1.16，也可以根据自己的需要下载其他的版本。
至此下载的过程讲解完毕，由于官网的界面会不定时的变动。以后有变动了，再更新下载方式。
安装 双击上面的exe文件
点击Next
点击Next
点击Next
点击Install
点击Next
点击Finish
修改Sdk的位置 点击OK
创建项目 修改Gradle的位置 由于第一次，创建AS项目后，Android sutdio第一次打开一个工程巨慢怎么办？
Android Studio怎么知道该用哪个Gradle呢?AS一个项目所用的Gradle是由我们的工程中下面这个文件决定的:
{your project}/gradle/wrapper/gradle-wrapper.properties
distributionBase：下载的Gradle压缩包解压后存储的主目录
distributionPath：相对于distributionBase的解压缩后的Gradle压缩包的路径
zipStoreBase：同distributionBase，只不过是存放zip压缩包的
zipStorePath：同distributionPath，只不过是存放zip压缩包的
distributionUrl：Gradle发行版压缩包的下载地址
最后一排的distributionUrl 决定了这个项目使用的gradle版本，也就是说不同的项目可以使用不同的gradle版本。
原理：Android Studio打开一个工程时，首先会读取gradle-wrapper.properties 文件，从而知道这个工程需要哪个版本的gradle ,然后就会去保存gradle的文件夹GRADLE_USER_HOME 去找看存不存在这个版本的gradle，不存在则会去distributionUrl 去下载 搞清楚了这个流程，现在是不是明白了，为什么第一次打开一个工程会巨慢了吧，因为AS会去下载gradle。
修改：gradle-wrapper.properties文件，如果想要指定版本的gradle，修改distributionUrl中的版本，只改后面的版本就行，防止自动下载慢，可以把提前下载的好的zip包，放到（C:\Users\Administrator.gradle\wrapper\dists\gradle-7.x.x-bin\6a41zxkdtcxs8rphpq6y0069z目录下，注意不要解压）。然后再次打开工程，会跳过下载gradle，并自动解压。然后下载工程所需依赖jar包（若有）。
下面说下修改：GRADLE_USER_HOME
修改：GRADLE_USER_HOME变量的路径，默认为C:\users{user name}.gradle，默认情况下，下载的gradle版本以及工程中根据gradle下载的依赖jar包都在这个C:\users{user name}.gradle路径下。
可以在系统环境变量里重新指定GRADLE_USER_HOME路径，然后把C:\users{user name}.gradle下的内容都拷贝的新路径下，防止C盘越来越大。
我们也可以采取另外一种方式，来指定当前项目使用的gradle版本及位置。gradle下载的依赖的包的存储路径，这种方式我们就不使用gradle-wrapper.properties文件了。
1.去gradle官网下载gradle版本。
Gradle下载地址：https://services.gradle.org/distributions/
例如：这里我们下载个7.3.2版本
手动解压：
然后配置gradle的全局环境变量：
检验配置是否成功。
出现上面的版本信息就表示配置成功了。
手动创建gradle下载的依赖包的存储路径：
D:\software\gradle-repository
打开项目
这样再重启项目：就不再自动读取gradle-wrapper.properties文件。
这样可以清理一些配置缓存。以便使用新的配置。
注意：这里有个小插曲，在读取gradle配置时，gradle 提示不能小于7.3.3（由于我们前面下载的是7.3.2），在运行程序时提示，JDK 不能低于 11。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b67269c0796fe3a240c2a4889d20ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9348a5fe8ea31435d11157bb0a933ba8/" rel="bookmark">
			python中【random】函数用法、randint(a, b)、random( )、uniform(a, b)、shuffle(序列)、sample( )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、random.randint(a, b) —— 随机生成一个整数，范围在[a,b]之间 ——闭区间
即：生成指定范围内的整数。
注意：a、b必须是整数
import random a = random.randint(1, 3) # 从1~3里随机生成一个整数，包括1和3 print(a) # 结果： 1 或者2 或者 3 2、random.random( ) ——随机生成一个浮点数，范围在[0,1)之间 ——左闭右开
import random a = random.random() print(a) # 结果： 0.010555497939993108 3、random.uniform(a, b) ——随机生成一个浮点数，范围在[a,b)之间 ——左闭右开
import random a = random.uniform(1, 3) print(a) # 结果： 1.2921501572960141 4、random.shuffle(x) ——将一个列表中的元素打乱
import random x = [1, 2, 3, 4, 5] random.shuffle(x) # !!! print(x) # 结果： [1, 3, 5, 2, 4] 或者 [2, 1, 4, 5, 3] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9348a5fe8ea31435d11157bb0a933ba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b46335e6892a50e67fe8ace4ede881/" rel="bookmark">
			排序算法：【选择排序]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、选择排序——时间复杂度 定义：第一趟排序，从整个序列中找到最小的数，把它放到序列的第一个位置上，第二趟排序，再从无序区找到最小的数，把它放到序列的第二个位置上，以此类推。
也就是说，首先从序列中找到最小的元素，放到有序区的第一个位置上，然后再从剩下的无序区中，继续找最小的元素，放到有序区的末尾。
1、容易想到的方法——不推荐 新建一个空列表，然后每遍历一次老列表时候，就把一个最小值，放到新列表里，同时再把这个值从老列表里删除掉。
但这种方法有两个缺点：
（1）额外占内存。因为新建了一个空列表 l1，所以就会多占用一个内存空间。
（2）时间复杂度高，排序效率慢。
列表的增加和删除方法，时间复杂度都是O(n)。
原因：把最小值加到新列表里，首先要先找到最小值，而找最小值的过程，其实就是把所有值都遍历一遍，所以，增加的操作，时间复杂度式O(n)。
同理，对于删除操作也一样，你要删掉最小值，首先得找到，而找最小值的过程就是要把列表全部遍历一遍，时间复杂度也是O(n)。
所以，法1中，增加和删除操作，它俩时间复杂度其实也就是O(n)+O(n)，因为他俩是并行运行的，不是嵌套运行，所以结果还是O(n)。外面还有一个for循环，所以法1代码，复杂度就是。
# 法1 def select_sort_simple(li): l1 = [] for i in range(len(li)): # 时间复杂度o(n) l1.append(min(li)) li.remove(min(li)) return l1 result = select_sort_simple([5, 3, 7, 2, 4]) print(result) # 结果： [2, 3, 4, 5, 7] 或许你会说，把最小值，赋值给一个变量，比如，a=min(li)，然后每次增加删除这个值，结果还一样吗？答案是肯定一样的，因为，你即使把它赋值给一个变量，但前提，你也得先找到这个最小值，而找最小值的过程就是把列表所有值都遍历一遍，此时它的复杂度就已经是了，再加上外面的for循环，代码整体复杂度还是。
# 法2 最小值，赋值给一个变量 def select_sort_simple(li): l1 = [] for i in range(len(li)): # 时间复杂度 O(n) a=min(li) # 时间复杂度 O(n) l1.append(a) li.remove(a) return l1 result = select_sort_simple([5, 3, 7, 2, 4]) print(result) # 结果同上 2、使用切片的方式控制无序区——推荐 使用切片的方式控制无序区，每一趟排序后，都将无序区中的最小值，放到无序区的第一个位置，也就是说，把无序区的最小值跟无序区的第一个元素进行交换，此时，这个最小值也就自然放到了有序区的末尾。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83b46335e6892a50e67fe8ace4ede881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2419a4c9375c90b610c6bb493d2189a/" rel="bookmark">
			n皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 https://www.bilibili.com/video/BV18X4y1k74c?p=52
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058630582ed64fdb23bce44ae79707a8/" rel="bookmark">
			三着色问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码来源：https://blog.csdn.net/queeniewsy/article/details/117430955
原理讲解：https://www.bilibili.com/video/BV1gL411C79e/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6a3bfbe95b8018e73e56fdbed87453e0
#include &lt;iostream&gt; using namespace std; //无向图G为上图a int G[5][5] = { {0,1,1,0,0}, {1,0,0,1,1}, {1,0,0,1,1}, {0,1,1,0,1}, {0,1,1,1,0} }; bool iscolor(int k, int *color) {//判断是否为合法颜色 for (int i = 0;i &lt; 5 &amp;&amp; i != k;i++) {//第k个顶点要跟前面k-1个已经选好颜色的顶点进行比较 if (G[k][i] == 1 &amp;&amp; color[k] == color[i])//如果两个顶点连通且颜色一样那就不行 return false; } return true; } void output(int *color, int n) {//输出所有合法解 for (int i = 0;i &lt; n;i++) cout &lt;&lt; color[i] &lt;&lt; " "; cout &lt;&lt; endl; } void graphcolor(int k, int *color) { for (int i = 1;i &lt;= 3;i++) {//我们是三着色问题，所以只有三种颜色用于上色 color[k] = i;//着色1，2，3 if (iscolor(k, color)) {//合法解 if (k == 4)//且完全上好(一组)色了，这里k=4就是5个顶点都上好色了 output(color, 5); else//部分合法解 graphcolor(k + 1, color);//到下一个顶点着色了 } } } int main() {	//G的顶点的3着色 int color[5];//( x0 , x1 , x2 , x3 , x4 )顶点i所着颜色xi for (int k = 0;k &lt; 5;k++) color[k] = 0; graphcolor(0, color);//从0号顶点开始着色 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea9901a69c40bd573cca9caef4c224b/" rel="bookmark">
			浅谈Elastic Stack组件集成和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch 与 Elastic Stack 组件集成和应用 Elastic Stack（以前称为 ELK Stack）是一套开源的日志管理和分析解决方案，由 Elasticsearch、Logstash、Kibana 和 Beats 四个主要组件组成。本文将详细讲解 Elasticsearch 与其他 Elastic Stack 组件的集成和应用。
Elasticsearch Elasticsearch 是 Elastic Stack 的核心组件，负责存储、搜索和分析数据。它是一个分布式搜索和分析引擎，基于 Apache Lucene 构建。Elasticsearch 提供了实时的全文搜索功能，以及复杂的数据聚合和分析功能。
Logstash Logstash 概述 Logstash 是一个数据处理管道，负责收集、处理和转发数据。它可以从多种来源（如日志文件、消息队列等）收集数据，对数据进行过滤、转换和丰富，然后将数据发送到 Elasticsearch 或其他目标系统。Logstash 支持多种输入、过滤和输出插件，可以灵活地处理各种数据格式和场景。Logstash 可以应用于多种场景，如日志分析、指标收集、事件处理等。结合 Elasticsearch 和 Kibana，用户可以快速搭建强大的数据处理和分析系统，提高运维效率和数据洞察。
Logstash 架构 Logstash 的架构主要包括三个部分：输入插件、过滤插件和输出插件。
输入插件：输入插件负责从数据源收集数据。Logstash 支持多种输入插件，如 file（用于读取文件）、tcp（用于接收 TCP 数据）、syslog（用于接收 Syslog 数据）等。用户可以根据需要选择合适的输入插件。
过滤插件：过滤插件负责对收集到的数据进行处理。Logstash 支持多种过滤插件，如 grok（用于解析日志格式）、mutate（用于修改字段）、geoip（用于将 IP 地址转换为地理位置信息）等。用户可以根据需要选择合适的过滤插件。
输出插件：输出插件负责将处理后的数据发送到目标系统。Logstash 支持多种输出插件，如 elasticsearch（用于发送数据到 Elasticsearch）、file（用于写入文件）、kafka（用于发送数据到 Kafka）等。用户可以根据需要选择合适的输出插件。
Logstash 配置 Logstash 使用配置文件来定义数据处理管道。配置文件由输入、过滤和输出三个部分组成，每个部分可以包含一个或多个插件。以下是一个简单的 Logstash 配置示例：
input { file { path =&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ea9901a69c40bd573cca9caef4c224b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3216eb638049e49b30f75ac5d4215e11/" rel="bookmark">
			mysql存json数据时的查询办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多时候mysql的一列当中存的是json格式的数据，这时候如果要查询某个key对应的值的时候要如何查询呢，这里记录一种查询方法：
json列的值：
{“InventoryMainTypeCode”: 1, “InventoryMainTypeName”: “GOOD”}
现在要查询InventoryMainTypeCode为xxx或者InventoryMainTypeName为xxx的数据：（这里以springboot+mybatis为例子）
代码：
请求类：
Query query = new Query(); @Data public class Query implements Serializable { private Map&lt;String, Object&gt; featureMap = new HashMap&lt;&gt;(); public void setFeature(String feature) { if (StringUtils.isNotBlank(feature)) { featureMap = JSON.parseObject(feature, Map.class); } } public void addFeature(String key, Object value) { if (StringUtils.isBlank(key)) { return; } this.featureMap.put(key, value); } public void addFeatureMap(Map&lt;String, Object&gt; featureMaps) { if (MapUtils.isNotEmpty(featureMaps)){ this.featureMap.putAll(featureMaps); } } } 在代码中将key添加到Feature中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3216eb638049e49b30f75ac5d4215e11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba7a361d5281a59f38f1100b048b09f/" rel="bookmark">
			连C&#43;&#43;之父都推荐的《代码大全2》，你确定的不看看？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在阅读一本书，它就是被誉为程序员圣经、开发百宝书、计算机软件开发老大哥，可以和另一本被誉为程序员圣经、开发百宝书、计算机软件开发老大哥《人月神话》相媲美的《代码大全2》，它也是曾几何时风靡业内的计算机大部头——《Code complete》，译者出于完备性的考虑，将其翻译为了“代码大全”。
这本书究竟怎么样，让我们听听大众的声音吧：
先来看看某乎网友们对这本书的评价吧
哦！我的老天爷！这位网友都读出来境界来了，简直高手哇。
接下来，一位悉尼大学的软件硕士如是说：
显然，这位悉软硕士，曾几何时坐在办公桌上，飞快地敲着代码，然后扭头看了一眼《代码大全2》，突然放慢速度，他的瞳孔瞬间放大，嘴里嘟囔着：“卧槽，原来是…是这样！”，他不禁张大了嘴巴，眼眶慢慢被热泪浸湿，而这，便是醍醐灌顶的感觉，而这种感觉又有多少人能体会到呢？（咳咳，虽然略显夸张，但是那种醍醐灌顶的感觉，希望大家都会体会到）
再来看看有点参考价值的豆瓣评分：
9.3的含金量，不用我说了吧，什么？还想看看豆油们的评价？
那就来吧：
开发者，最重要的是踏实与热情，现在某些培训班打着21天精通xxx，一个月搞定xx开发，来博眼球，可以说一点都不务实，热情倒是被抬到了不属于它的高度。
接下来我们就来学习学习本书中我格外喜欢的章节：
点击这里跳转（跳转不了，就说明还在更（狗头））
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a972268ff52a488df9b91f33139b2608/" rel="bookmark">
			TMS320F28034 eCAN特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eCAN特性: eCAN特性:
与CAN 协议，版本2.0B 完全兼容
支持高达1Mbps 的数据速率
拥有32 个邮箱，每个邮箱都可配置为以下四种消息对象：
（1）发送消息对象 --------》 只能传输消息
（2）接收消息对象 --------》 只能接收消息
（3）远程请求消息对象 ---------》用于发送远程请求帧，并等待接收另一个节点返回的相应数据帧
（4）自动应答消息对象 ---------》此模式下当邮箱接收到相应的请求帧后，便会自动发送应答的数据帧
eCAN结构： eCAN 模块的架构，如图所示，是由一个CAN协议内核(CPK) 和一个消息控制器组成。根据CAN 协议，CPK 的两个功能的是解码在CAN 总线上接收到的所有消息，并把这些消息转移到接收缓冲器。CPK 的另一个功能是根据CAN 协议传输CAN 总线上的消息。CAN 控制器的消息控制器是负责确定CPK 接收到的任何信息是否必须被保留以便用于CPU 使用还是被丢弃。在初始化阶段，CPU 指定消息控制器应用所使用的所有消息标识符。根据消息的优先级，消息控制器还负责发送下一条消息传输到CPK。
eCAN模式 SCC模式 SCC 模式是eCAN 的一种精简功能模式。在这种模式下，只有16 个邮箱（0 到15）可用。不提供时 间戳功能，并且可用的接受屏蔽数量也被减少。缺省情况下，这种模式被选中。通过SCB 位(CANMC.13)，SCC 模式或功能齐全的eCAN 模式被选择。
eCAN模式 此模式下可以使用32个邮箱，并且每个邮箱都配有一个标识符屏蔽器，非常强大方便。本次实验实验eCAN模式。
控制和状态寄存器的32 位访问 需要注意，eCAN模块的控制和状态寄存器只允许32 位访问。
这些寄存器的16 位访问可能会破坏该寄存器的内容或返回错误数据。
这时可以自己定义一个影子寄存器来进行配置，影子寄存器没有位访问限制，配置好影子寄存器后，在给控制和状态寄存器赋值即可。
例如：
//写操作 ECanaShadow.CANTIOC.all = ECanaRegs.CANTIOC.all; // 执行一个32 位读取以复制整个寄存器内容到它的影子寄存器中 ECanaShadow.CANTIOC.bit.TXFUNC = 1; // 修改影子寄存器中所需要的一个或多个位 ECanaRegs.CANTIOC.all = ECanaShadow.CANTIOC.all; // 执行一个32 位写入以复制修改后的影子寄存器内容到原始寄存器中。 //读操作 // 首先复制整个CANTA 寄存器到它的影子寄存器（使用32 位读取），然后检查相关位，重复此操作，直到该条件得到满足。 do { ECanaShadow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a972268ff52a488df9b91f33139b2608/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/35/">«</a>
	<span class="pagination__item pagination__item--current">36/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/37/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>