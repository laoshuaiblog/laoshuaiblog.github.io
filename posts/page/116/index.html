<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b22ca3a0889c76696447852ee0f0407/" rel="bookmark">
			org.springframework.jdbc.support.SQLErrorCodesFactory - SQLErrorCodes loaded: [DB2, Derby, H2, HSQL,
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误信息：
org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loading XML bean definitions from class path resource [org/springframework/jdbc/support/sql-error-codes.xml] org.springframework.jdbc.support.SQLErrorCodesFactory - SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase] 一般出现这个错误都是由于sql语句的输入参数还有数据库字段类型等不一致导致的。
自己排查的时候异地那个不能忽略细节：
我检查了我的 parameterType="xxx" 还有sql语句并没有发现错误
将sql放到数据库测试的时候才发现 数据表有一个字母打错了。
数据表名是d_products 所以一定要仔细看自己写的代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c3e5ab7f3b6eea1b070f35f4abe71f/" rel="bookmark">
			python--binary文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #以二进制方式读文件 def read_b(): #f = open("e:/input.txt",'rb') f = open("e:/1.jpg",'rb') print(f.read()) f.close() #以二进制方式写入到文件 def write_b(): f = open("e:/output.txt","wb") f.write(b'\xd6\xd0\xb9\xfa') s = '\n中华人民共和国\n' length = f.write(s.encode('utf-8')) print("写入：{}-- 共写入：{}个字节".format(s,length)) f.close() #主函数 def main(): try: read_b() #write_b() except IOError: print("读取失败") main() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889edd093760465d0dcd0072641e3c1a/" rel="bookmark">
			kubectl exec 遇到Error from server forbidden问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
[root@k8s-master yaml_all]# kubectl get po NAME READY STATUS RESTARTS AGE nginx-648b5cc477-7b5pt 1/1 Running 0 3h41m nginx-648b5cc477-mplmg 1/1 Running 0 3h41m nginx-648b5cc477-zw8jq 1/1 Running 0 3h41m 执行下面这条后报错了
[root@k8s-master yaml_all]# kubectl exec -it nginx-648b5cc477-7b5pt bash error: unable to upgrade connection: Forbidden (user=system:anonymous, verb=create, resource=nodes, subresource=proxy) 临时解决方法：
绑定一个cluster-admin的权限
[root@k8s-master yaml_all]# kubectl create clusterrolebinding system:anonymous --clusterrole=cluster-admin --user=system:anonymous clusterrolebinding.rbac.authorization.k8s.io/system:anonymous created [root@k8s-master yaml_all]# kubectl exec -it nginx-648b5cc477-7b5pt -- bash root@nginx-648b5cc477-7b5pt:/# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var root@nginx-648b5cc477-7b5pt:/# exit exit 转载于:https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/889edd093760465d0dcd0072641e3c1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28e9ac177bc8b0f38c271402f503069/" rel="bookmark">
			RedisTemplate常用方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多公司都将redisTemplate进行了封装，封装成业务所需要的RedisUtil工具类方便进行调用，本篇文章总结了redisTemplate常用的一些方法。
文章目录 Redis常用的数据类型：String类型Hash类型List类型Set类型zSet类型 Redis常用的数据类型： StringHashListSetzSetSorted set String类型 判断是否有key所对应的值，有则返回true，没有则返回false
redisTemplate.hasKey(key) 有则取出key值所对应的值
redisTemplate.opsForValue().get(key) 删除单个key值
redisTemplate.delete(key) 批量删除key
redisTemplate.delete(keys) //其中keys:Collection&lt;K&gt; keys 将当前传入的key值序列化为byte[]类型
redisTemplate.dump(key) 设置过期时间
public Boolean expire(String key, long timeout, TimeUnit unit) { return redisTemplate.expire(key, timeout, unit); } public Boolean expireAt(String key, Date date) { return redisTemplate.expireAt(key, date); } 查找匹配的key值，返回一个Set集合类型
public Set&lt;String&gt; getPatternKey(String pattern) { return redisTemplate.keys(pattern); } 修改redis中key的名称
public void renameKey(String oldKey, String newKey) { redisTemplate.rename(oldKey, newKey); } 返回传入key所存储的值的类型
public DataType getKeyType(String key) { return redisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e28e9ac177bc8b0f38c271402f503069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/662810d0ce97615ce70c6fa82cc78502/" rel="bookmark">
			通过IDEA将项目git到coding上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Coding上新建一个项目 创建项目本地仓库位置 VCS→Import into VersionControl→Create Git Repository
选择一个文件夹作为本地仓库，我选择项目所在的文件夹
提交代码到本地仓库 将项目放入缓存区（一次就可以了）
项目点击右键→Git→Add
commit到本地仓库
项目点击右键→Git→Commit Directory……
选择需要commit的文件，不需要的可以取消
建立本地仓库与远程仓库的连接 项目右键→Git→Repository→Remotes
添加coding分配的地址
上传到远程服务器 项目点击右键→Git→Repository→Push
大功告成 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527fe9713ee306434d0ba9c15b2b5bcf/" rel="bookmark">
			Vue中computed、methods和watch之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于那些开始学习Vue的人来说，对于方法、计算属性和观察者之间的区别有点混淆。
尽管通常可以使用它们中的每一个来完成或多或少相同的事情，但了解每个人在哪里胜过其他人还是很重要的。
在这个快速提示中，我们将了解Vue应用程序的这三个重要方面及其用例。我们将通过使用这三种方法中的每一种构建相同的搜索组件来实现这一点。
Methods
在一个方法中，或多或少是您所期望的——一个对象属性的函数。您可以使用方法对发生在DOM中的事件作出反应，或者可以从组件中的其他位置调用它们，例如，从计算属性或观察者中调用它们。方法用于对公共功能进行分组-例如，处理表单提交，或构建可重用的功能，如发出Ajax请求。
在Vue实例中的methods对象内创建方法：
new Vue({ el: "#app", methods: { handleSubmit() {} } }) 当您想在模板中使用它时，您可以这样做：
&lt;div id="app"&gt; &lt;button @click="handleSubmit"&gt; Submit &lt;/button&gt; &lt;/div&gt; 我们使用v-on指令将事件处理程序附加到dom元素，该元素也可以缩写为@符号。
现在，每次单击按钮时都会调用handleSubmit方法。对于要传递方法体中需要的参数的实例，可以执行以下操作：
&lt;div id="app"&gt; &lt;button @click="handleSubmit(event)"&gt; Submit &lt;/button&gt; &lt;/div&gt; 这里我们传递一个事件对象，例如，它允许我们在表单提交的情况下阻止浏览器的默认操作。
但是，当我们使用一个指令来附加事件时，我们可以使用一个修饰符来更优雅地实现相同的事情：@click.stop=“handleSubmit”。
现在我们来看一个使用方法过滤数组中数据列表的示例。
In the demo, we want to render a list of data and a search box. The data rendered changes whenever a user enters a value in the search box. The template will look like this:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/527fe9713ee306434d0ba9c15b2b5bcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/380940c73f080cdd5ee1eff1071120e5/" rel="bookmark">
			IDEA中的lombok失效的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不知道是怎么回事，IDEA突然打不开正在做的项目了，但是原来的项目都可以正常用，一气之下卸载了IDEA，重装了最新版的IntelliJ IDEA 2019.1 x64，然而先是@Data失效，再是识别不了基本类型String等和包装类型Interger。所以需要检查配置。
一 我的问题呢，是新下载的IDEA最新版和原来的lombok不兼容了。。 项目中经常使用bean，entity等类，绝大部分数据类类中都需要get、set、toString、equals和hashCode方法，虽然eclipse和idea开发环境下都有自动生成的快捷方式，但自动生成这些代码后，如果bean中的属性一旦有修改、删除或增加时，需要重新生成或删除get/set等方法，给代码维护增加负担。而使用了lombok则不一样，使用了lombok的注解(@Setter,@Getter,@ToString,@@RequiredArgsConstructor,@EqualsAndHashCode或@Data)之后，就不需要编写或生成get/set等方法，很大程度上减少了代码量，而且减少了代码维护的负担。故强烈建议项目中使用lombok，去掉bean中get、set、toString、equals和hashCode等方法的代码。
检查插件是否安装完成。File---&gt;Settings---&gt;Plugins
二 SDK也要更新咯 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7839c816ab888a51aecc1267b2b5c51/" rel="bookmark">
			计算机视觉——增强现实（Augmented Reality）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、增强现实原理及介绍1、增强现实介绍2、增强现实原理介绍 二、增强现实应用1、应用背景介绍2、AR应用2.1、相机矩阵标定2.2、作为目标背景的图片2.3、代码部分2.4、合成结果 一、增强现实原理及介绍 1、增强现实介绍 增强现实，是将物体和相应信息放置在图像数据上的一系列操作的总称。事实上，增强现实在我们生活中的应用已经相当广泛了。比如任天堂的pokeman go，这个产品可以使你看到皮卡丘，杰尼龟出现在现实世界的场景里， 并捕捉他们，这个应该是无数90后小时候的梦想，AR使它变成了现实。
2、增强现实原理介绍 对于背景场景，我们需要首先给定标记，通过计算，获得自己计算机的标定信息，使用获取信息，放置目标模型的图像，获得我们需要的增强现实结果。
二、增强现实应用 1、应用背景介绍 应用目的是将一个茶杯图像放置到一段视频里，下面我们将进行计算机标定，以及目标合成。
2、AR应用 2.1、相机矩阵标定 下面这张是用来进行相机矩阵标定的图片
首先，相机到目标物体的距离d为500mm，计算出书的边长fX,fY。以及相片里书的边长fx,fy
利用
Px=fx/fX∗d
fy=fy/fY∗d
计算出相机的焦距。
2.2、作为目标背景的图片 2.3、代码部分 import math import pickle from pylab import * from OpenGL.GL import * from OpenGL.GLU import * from OpenGL.GLUT import * import pygame, pygame.image from pygame.locals import * from PCV.geometry import homography, camera from PCV.localdescriptors import sift def cube_points(c, wid): """ Creates a list of points for plotting a cube with plot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7839c816ab888a51aecc1267b2b5c51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad285999138c789d7df507a8c564002/" rel="bookmark">
			window环境下使用Qemu运行自己制作的img映像文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载安装qemu软件
网上有甚多资源，自己搜索然后下载就可以了
https://www.cr173.com/soft/794471.html
二、获取一份映像文件
注意：映像文件中需要有启动引导的功能，否则会报错
三、如何使用qemu创建虚拟机
百度有详细的步骤讲解，请自行查阅：
https://jingyan.baidu.com/article/c74d6000bf900d0f6a595ded.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1978ddb3d8f78885e480999f3fc366a1/" rel="bookmark">
			SpringMVC中使用Ajax请求以json格式返回null值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：问题demo展示 在开发新需求，调试代码的时候发现一个问题，就是HttpServletRequest 获取不到ajax post请求的json参数！下面是伪代码是整个请求的逻辑！
1.前台JS请求代码(伪代码) var _phoneId = "123456789"; var closeUrl=contextPath+"/close"; ajax(closeUrl,{"phoneId":_phoneId},"post",false,callbackForSessionClose,null,'json'); function ajax(url,reqData,type,async,successBack,errorBack,statusText,dataType){ $.ajax({ type : type, url : url, dataType : dataType, async : async, timeout : "60000", contentType : "application/json", data : JSON.stringify(reqData), success : function(data) { // 成功的处理逻辑 }, error : function(data) { // 错误的处理逻辑 } }); } 2.后台代码(伪代码) @RequestMapping(value="/close",method=RequestMethod.POST) @ResponseBody public String closeSession(HttpServletRequest request){ String response; try{ String phoneId = request.getParameter("phoneId"); if(phoneId == "123456789"){ response = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1978ddb3d8f78885e480999f3fc366a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94fa15d8c641286e79c41d8cf629670a/" rel="bookmark">
			【Linux】半同步半异步线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先来复习一下什么是：阻塞、非阻塞、同步、异步
阻塞：调用方在得到结果之前会一直等待；
非阻塞：调用方在不能得到结果时，不会等待。
打个比喻：David准备钓鱼回家买菜做饭。
阻塞：钓鱼时一直守在鱼竿前等鱼上钩，就这样钓到鱼后去做别的事情。
非阻塞：David抛出鱼竿后，没有鱼上钩，于是开始先买菜洗菜玩手机，鱼上钩后，再去处理鱼。
同步：被调用方得到最终结果之后才返回给调用方。所有的操作都做完，才返回给用户。这样用户在线等待的时间太长，给用户一种卡死了的感觉（就是系统迁移中，点击了迁移，界面就不动了，但是程序还在执行，卡死了的感觉）。这种情况下，用户不能关闭界面，如果关闭了，即迁移程序就中断了。
异步：不用等所有操作等做完，就相应调用方的请求。即先相应请求，然后慢慢去处理，调用方的体验比较好。
打个比喻：David叫nana去吃饭，而nana此刻正在化妆，收拾屋子，穿衣服......
同步：David叫了一声，没有得到任何回应，David听到后很可能去一个人走了；nana收到消息后没有回应，一直忙着自己的事情，化妆换衣服之后，给David发消息：我收好了，可以和你去吃饭。
异步：David叫了一声，nana说等等我有事情，David听到后就阻塞住；nana忙完后又告诉David：我收好了，可以和你去吃饭。
然后两个人手牵手去吃饭。
-------------------
这里同步的理解好像有些不恰当，
举例线程同步：
总之，同步讲的是被调用者的事情。 -------------------
由此可见：异步是最优的解决方案，能够满足调用方和被调用方；同步可能让双方都达不到目的。
同步模式编程简单，但是I/O的利用率低；
而异步模式编程复杂，但是I/O利用率高。
综合同步异步的有优点，就有了半同步半异步的设计模式。
---------------------------------------------------------------------------------------------------------
半同步/半异步线程池中：添加一个共享队列（单例模式并保证线程安全）
【1】主线程只管理监听socket、连接，得到新的连接socket由工作线程来管理。当有新的连接到来时，主线程就接受并将新返回的连接socket派发给某个工作线程，此后，该连接套接字clifd上任何I/O操作都由被选中的工作线程来处理，知道客户端关闭连接。
【2】主线程向工作线程派发socket的方式，是通过一个共享队列，连接套接字clifd上有事件，主线程就将clifd添加到queue中。工作线程检测到queue上有数据，如果是，就处理该事件。（扩充：工作线程可以写成一个epoll事件处理模式）
【3】此模式每个线程都做自己的事件。
总结起来线程池就是： 1. 同步服务层：不断的将新任务添加到同步队列中，可以用多路复用或者多线程来完成。一开始没看懂任务是什么，其实一个函数就是一个任务，C++11通过std::function将函数封装为类模板对象，可以将这些任务（函数）放到容器中保存起来，以进行添加读取任务操作。 2. 排队层：就是一个同步队列，处于核心地位。所有待处理的任务都存在这里，要保证队列中共享数据线程安全（加锁），还要控制任务的数量，上层服务层往队列添加任务，下层从这里取任务去执行。 3. 异步服务层： 预先创建好线程，来并行处理队列中的任务。
//项目中的代码分析：
共享队列：
//共享队列：单例，保证线程安全 队列为空，则阻塞等待。所以后面的锁需要重新new class ShareQueue { public: static ShareQueue* getShareQueue(); void Share_push(int clifd) { _queue-&gt;push(clifd); } int Share_pop() { Mylock::getMylock()-&gt;lock(); while(_queue-&gt;empty()) { sleep(1); } int clifd = _queue-&gt;front(); _queue-&gt;pop(); Mylock::getMylock()-&gt;unlock(); return clifd; } private: ShareQueue() { _queue = new queue&lt;int&gt;; } queue&lt;int&gt; *_queue; static ShareQueue* _instance;//单例中的唯一实例对象 }; 线程池：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94fa15d8c641286e79c41d8cf629670a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5799d611534bf5e9b941f30b61e15b82/" rel="bookmark">
			电脑连不上WiFi，右下角出现红叉怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的电脑经常出现这个问题，后来解决得多了就知道方法了，是我的电脑无线网卡驱动的问题，解决办法：
1.电脑桌面单击此电脑，右键选择属性
2.选择网络适配器，一般出现问题就是因为网络适配器列表里面的一些东西被禁用了，看下面有出现问号的项，右键属性
3.进去之后，点击高级，，属性里面未启动的都设为启动，disabled都设为enabled就行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88b4ca2d863549f2ed13f507170ea79/" rel="bookmark">
			CAS单点登录(十)——通过Restful协议请求认证和退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面我们讲解了一些列的CAS文章，对CAS有了很多了解。今天我们讲解一个现在服务常用的REST协议来完成CAS的登录、认证，不需要我们手动登录跳转到CAS的登录页面就可以完成CAS的一些列操作。
我们知道CAS认证支持包括多种协议去认证，包括CAS、OAuth、SAML1、SAML2、REST Protocol等协议，这里我们采用REST协议去获取TGT，然后获取到TGT后获取到ST，最后拿到ST后再去访问服务。
一、认证服务 首先我们加入Rest服务依赖：
&lt;!-- Restful support --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-rest&lt;/artifactId&gt; &lt;version&gt;${cas.version}&lt;/version&gt; &lt;/dependency&gt; 开启Rest认证方式，我们在前面的文章介也绍过CAS单点登录(三)——多种认证方式。
在application.properties中，我们配置restful的链接。
## # Rest配置 # cas.authn.rest.uri=http://localhost:8088/login cas.authn.rest.name= 这里需要注意，这个是自定义Rest认证配置的相关参数，与这里是通过公开方法RESTful来获取票证授予票证然后使用它来获取服务票证来实现的是不一样的。
所以这里我们可以不用配置Rest认证配置的参数，这里提出来为了区分一下区别。
注意：这里通过REST协议去获取TGT，暂时支持用户名和密码，我们在前面demo应用中加入了验证码的，因此继续使用该demo时，需要在CustomAuthenticationConfiguration配置中启用CustomUsernamePasswordAuthentication来实现认证。如下：
/** * @author anumbrella */ @Configuration("customAuthenticationConfiguration") @EnableConfigurationProperties(CasConfigurationProperties.class) public class CustomAuthenticationConfiguration implements AuthenticationEventExecutionPlanConfigurer { @Autowired private CasConfigurationProperties casProperties; @Autowired @Qualifier("servicesManager") private ServicesManager servicesManager; @Bean public AuthenticationHandler myAuthenticationHandler() { // 参数: name, servicesManager, principalFactory, order // 定义为优先使用它进行认证 return new CustomUsernamePasswordAuthentication(CustomUsernamePasswordAuthentication.class.getName(), servicesManager, new DefaultPrincipalFactory(), 1); // return new CustomerHandlerAuthentication(CustomerHandlerAuthentication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b88b4ca2d863549f2ed13f507170ea79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a5d6604dc0ddf63c06d676bcc9af4a9/" rel="bookmark">
			输入一个年份和一个月份，输出该年此月天数；知道日期，计算该日是本年的第几天（c语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		养成好习惯，点个赞 再走；有问题，欢迎私信、评论，我看到都会回复的
一年12个月2月是个特殊的（闰年有29天，否则有28天）1，3，5，7，8，10，12月有31天（口诀：一三五鸡八死了），12月又称为腊月其余有30天判断闰年很简单（口诀：4年一闰，百年不闰，四百必闰） 文章目录 输入一个年份和一个月份，输出该年此月天数用结构体存放日期，计算该日是本年的第几天 输入一个年份和一个月份，输出该年此月天数 #include &lt;stdio.h&gt; int main() { int year, month, day; //请输入一个年份和一个月份 scanf("%d%d", &amp;year, &amp;month); printf("year = %d, month= %d\n", year, month); if(1 &lt;= month &amp;&amp; month &lt;= 12){ switch(month){ case 1: case 3: case 5:	case 7: case 8 : case 10: case 12:day = 31; break; case 4: case 6: case 9:	case 11:day = 30; break; case 2: if((year % 4 == 0 &amp;&amp; year % 100 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a5d6604dc0ddf63c06d676bcc9af4a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d62bf29261d9c54461c6b964e45c9cf6/" rel="bookmark">
			AHCI、RAID、IDE三种硬盘模式优缺点对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的时候我们在安装系统的时候，往往会进入BISO，查看SATA mode (硬盘模式) 。尤其是安装win7系统的时候，我们会选择“AHCI模式”，这究竟是为什么呢？今天小编就简单的为大家带来硬盘3种模式各自的优缺点教程，希望对大家有所帮助。
AHCI、RAID、IDE三种硬盘模式优缺点对比
一：IDE模式 （“IDE接口”也叫“ATA接口”，“台式机硬盘”的默认模式）
IDE是表示硬盘的传输接口。我们常说的“IDE接口”，也叫ATA（Advanced Technology Attachment）接口，现在PC机使用的硬盘大多数都是IDE兼容的，只需用一根电缆将它们与主板或接口卡连起来就可以了。就目前来说，大部分台式机电脑默认是IDE模式！
优点：易于使用与价格低廉，问世后成为最为普及的磁盘接口
缺点： &lt;1&gt; 速度慢 &lt;2&gt; 只能内置使用 &lt;3&gt; 对接口电缆的长度有很严格的限制
二：RAID模式
“PADI模式”即“磁盘阵列模式”，简单说就是利用多个硬盘同时工作，来保证数据的安全以及存取速度的。它共有九个模式，以数字命名，为RAID 0、RAID1到RAID 7以及RAID 0+1，而目前最常见的是RAID 0、RAID 1、RAID 5和RAID 0+1这四种模式
优点：
1、设置与组建方便
2、能够“叠加硬盘容量"避免容量浪费
3、两倍于单块"机械硬盘"传输性能
4、相比“升级SSD”节省大量资金
缺点：
1、缺少数据冗余 数据可靠性低
2、无法使用Ghost软件备份镜像。
三：AHCI模式（“笔记本硬盘”的默认模式）
AHCI英文全称：Serial ATA Advanced Host Controller Interface（串行ATA高级主控接口/高级主机控制器接口）
AHCI本质是一种"PCI类设备"，在系统"内存总线"和"串行ATA设备"内部逻辑之间扮演一种通用接口的角色（即它在不同的操作系统和硬件中是通用的）。这个类设备描述了一个含控制和状态区域、命令序列入口表的通用系统内存结构；每个命令表入口包含SATA设备编程信息，和一个指向（用于在设备和主机传输数据的）描述表的指针。
笔记本则大多默认已经采用AHCI模式。
优点：
1.ACHI支持"NCQ技术"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2fcf1c0726cfd5472f3ff560f0aa34/" rel="bookmark">
			win10 64位下go编译dll给C#调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先下载安装mingw-w64-install.exe，安装的时候根据go的架构选择64位或i686，安装后将mingw下的bin加入到PATH环境变量，打开控制台，输入gcc，查看是否安装成功。
2、编写go代码：
package main import "C" import "fmt" //export PrintBye func PrintBye(){ fmt.Println("From dll:Bye!") } //export Sum func Sum(a int, b int) int{ return a + b; } func main(){ // Need a main function to make CGO compile package as C shared library } 注意两个函数上面的注释//export XXX，这是函数导出的标记，不加的话导致生成的dll无任何导出内容。
3、运行命令行编译dll：go build -buildmode=c-shared -o 生成的DLL名称.dll go源码文件名称.go 4、确保安装的go版本支持编译动态链接库，如果版本低，会提示-buildmode=c-shared not supported on windows/amd64等错误，这时下载最新的go，当前是go 1.12版本可以正常编译。
5、在C#中导入并调用：
public partial class Form1 : Form { [DllImport("exportgo.dll", EntryPoint = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa2fcf1c0726cfd5472f3ff560f0aa34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36aeeb62b5fe3bfd112d0aa379f059af/" rel="bookmark">
			怎样写好git comment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Git提交的comment是为了别人能够快速了解代码提交的目的，下面给出了实践中总结的写好git comment的方式。
基本格式 简单：只有标题， git commit –m “&lt;类型&gt;: &lt;主题&gt;”详细：标题+内容，git commit 会车，然后编辑输入：&lt;类型&gt;: &lt;主题&gt; // 空一行 &lt;内容&gt; 内容一般缩进4个字符 常用类型 Feature：新特性BugFix：bug修复Optimize：优化和改善，用户可见的提升，不会影响基本逻辑和功能，比如性能提升，界面美化Refactor：重构，功能完全等价，实现方式上的变更，比如把重复代码提取到公共类，把超大的函数拆分成几个意义明确的小函数等等 怎样写好内容 BugFix
标题写：问题现象，比如：Cannot manage xxx server Exception while manage xxx server 内容：可以写的比较多，一般写：
Why：问题根因是什么
What：解决方案是什么
如果有什么遗留问题，有什么待改进的也可以写在这Feature
标题写：需求描述，比如：Support xxx for yyy Support xxx management 内容：一般不用写，也可以详细写一下需求内容，比如具体有哪些子功能，特性支持哪些字段 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa08eab068a9bf9e69ce7ab98d6f8b2/" rel="bookmark">
			SIFT（尺度不变特征变换）原理与简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、SIFT（Scale Invariant Feature Transform）简介 1.1、SIFT算法的操作步骤
兴趣点的检测：
特征方向的赋值：
特征点描述：
1.2、SIFT算法的适用范围
2、尺度空间
2.1、传统图像金字塔
2.2、高斯金字塔
2.3、高斯模糊
3.DOG空间极值检测
4.删除边缘响应点
二、SIFT算法的简单应用与和Harris角点匹配的对比
1.Harris特征匹配处理
2.Harris算法在图像间寻找对应点
3.SIFT算法检测与Harris角点检测对比
4.SIFT算法匹配
未完待续。。。（代码跑得有点慢）
一、SIFT原理及简介
1、SIFT（Scale Invariant Feature Transform）简介 传统的图像匹配算法一般是利用图像的角点与边缘进行匹配，鲁棒性较差，在光照变换，角度变换的时候容易出现误差。
SIFT（尺度不变特征变换）算法是有David G.Lowe教授在1999年提出，2004年加以完善。SIFT算法在光照不同，角度不同，尺度不同的情况下应用良好。
1.1、SIFT算法的操作步骤 兴趣点的检测： 在尺度空间（第二节有详细介绍）上，利用高斯微分函数，识别尺度和旋转不变的兴趣点。
特征方向的赋值： 基于特征点的梯度方向，给特征点分配8个方向，选取主方向，与辅方向（在直方图里等于主方向80%）
特征点描述： 把特征点的梯度方向转换成特定表示。
1.2、SIFT算法的适用范围 1.目标图像的旋转，平移，尺度变换。
2.反光图像
3.目标有障碍物
2、尺度空间 在不同的尺度下的同一物体计算机不会认为是同一物体，因此，需要将物体的不同尺度提供给计算机。
2.1、传统图像金字塔 传统的图像金字塔是对图像进行简单的缩放，放大等操作。这种做法简单粗暴，但容易造成采样信息的丢失，降低匹配结果的精确度。
2.2、高斯金字塔 1.对图像做高斯平滑
2.对平滑后得图像做采样
2.3、高斯模糊 高斯模糊的目的是为了拟合人类视觉中对远近不同图像所产生的尺度差异与清晰度差异。
经过高斯模糊的图像会体现出总体模糊化，边缘清晰化的特征
高斯模糊的具体做法是：
L(x,y,σ)=G(x,y,σ)∗I(x,y)
L(x,y,σ)=G(x,y,σ)∗I(x,y)
其中，GG是高斯函数：
G(x,y,σ)=12πσ2ex2+y22σ2
G(x,y,σ)=12πσ2ex2+y22σ2
其中，σσ是尺度空间因子，是高斯正态分布的标准差，反映了图像被模糊的程度，其值越大图像越模糊，对应的尺度也就越大，L(x,y,σ)L(x,y,σ)对应高斯尺度空间。
--------------------- 作者：呆呆的猫 来源：CSDN 原文：https://blog.csdn.net/jiaoyangwm/article/details/79986729 3.DOG空间极值检测 DOG层是由两个相邻的高斯空间图像层相减得到的，其目的是简化计算复杂度。
4.删除边缘响应点 一些噪声点会产生边缘响应，会影响匹配结果。可以通过尺度空间DoG函数进行曲线拟合寻找极值点，去除边缘响应点。
二、SIFT算法的简单应用与和Harris角点匹配的对比 这次采用的实验原图片是集美大学的中山纪念馆。
首先我们任意选取两张图片分别进行Harris特征匹配处理与SIFT特征匹配处理的对比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaa08eab068a9bf9e69ce7ab98d6f8b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c10a3c0eeebee23fe88bcc8e06dead6/" rel="bookmark">
			Linux系统下安装nginx详细步骤！（亲测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在实际开发项目中有可能会经常用到nginx，你们也许会拿它做负载均衡，或者转发请求做动静分离，用来加载前端项目；或者解决跨域的问题等等，今天这篇文章就讲解下在Linux下如何安装nginx。
正文： 一、安装前准备，我们先检验下系统是否安装g++、gcc、openssl-devel、pcre-devel和zlib-devel，这些安装nginx所需要的依赖包。
yum list installed | grep gcc //这个指令既可以检查gcc又可以检查g++ yum list installed | grep openssl-devel yum list installed | grep pcre-devel yum list installed | grep zlib-devel 知识补充：
因为Linux下软件安装的方式很多，没有一个通用的方式查看软件包是否安装，所以总结下来就是这几类。
rpm包安装的，可以用 rpm -qa 看到，如果要查找某软件包是否安装，用 rpm -qa | grep "软件或者包的名字" 以deb包安装的，可以用 dpkg -l 看到。如果是查找指定软件包，用 dpkg -l | grep "软件或者包的名字"yum方法安装的，可以用 yum list installed 查找，如果是查找指定包，用 yum list installed | grep "软件名或者包名"如果是以源码包自己编译安装的，例如.tar.gz或者tar.bz2形式的，这个只能看可执行文件是否存在了。 我经常用的安装方式是yum安装依赖包，tar去安装软件包，比如安装nginx。
运行结果如下图：
如果没有安装的话，就先安装一下。
1、gcc安装
安装nginx需要将nginx的源码进行编译，编译依赖gcc环境，所以需要安装gcc，指令：
yum install gcc-c++ 2、 pcre pcre-devel 安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c10a3c0eeebee23fe88bcc8e06dead6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc6de5837c9d81e8e43e1c29743e974/" rel="bookmark">
			如何从HDFS导入数据到ClickHouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从ClickHouse 18.16.0版本开始支持从HDFS读文件，在 19.1.6 版本对HDFS访问功能进行了增强，支持读和写，在 19.4 版本以后开始支持Parquet格式。本文介绍了如何从HDFS中读数据到ClickHouse中，测试版本为：19.4
在访问HDFS之前需要定义一个访问HDFS的表，指定表引擎为HDFS。表创建完成后，就可以对这张表进行查询。
目录
一、查询CSV文件
二、查询Parquet文件
三、从HDFS导入数据
四、总结
五、参考资料
一、查询CSV文件 例如，在HDFS上有一个数据文件：books.csv，内容如下：
hadoop fs -cat /user/hive/ck/book_csv/books.csv
0553573403,book,A Game of Thrones,7.99 0553579908,book,A Clash of Kings,7.99 055357342X,book,A Storm of Swords,7.99 0553293354,book,Foundation,7.99 0812521390,book,The Black Company,6.99 0812550706,book,Ender's Game,6.99 0441385532,book,Jhereg,7.95 0380014300,book,Nine Princes In Amber,6.99 0805080481,book,The Book of Three,5.99 080508049X,book,The Black Cauldron,5.99 在ClickHouse上创建一个访问books.csv文件的表：
CREATE TABLE hdfs_books_csv ( isbn String, cat String, name String, price Float64 ) ENGINE = HDFS('hdfs://host123:9000/user/hive/ck/book_csv/books.csv', 'CSV') 查询hdfs_books_csv表：
SELECT * FROM hdfs_books_csv ┌─isbn───────┬─cat──┬─name──────────────────┬─price─┐ │ 0553573403 │ book │ A Game of Thrones │ 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dc6de5837c9d81e8e43e1c29743e974/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/115/">«</a>
	<span class="pagination__item pagination__item--current">116/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/117/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>