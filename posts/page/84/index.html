<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ea929e1f22e842dca91e0b10458bbb/" rel="bookmark">
			Uniapp之APP离线打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成wangyz.jks文件
命令行打开定位到.jks文件的位置进行以下操作
命令行输入：
keytool -list -v -keystore /Users/apple/Desktop/wangyz/wangyz.jks SHA1为我们需要的
DCLOUD官网配置离线打包所需要的keyhttps://dev.dcloud.net.cn
HBuilderX“生成本地打包APP资源”
点击就会在控制台生成相应的资源包，根据控制台返回的路径找到相应的文件
AndroidStudio离线打包配置
基础库配置
App离线SDK下载：https://nativesupport.dcloud.net.cn/AppDocs/download/android
最新配置方案，可以参考官文进行配置：https://nativesupport.dcloud.net.cn/AppDocs/usesdk/android
在下载好的离线SDK中找到以下文件，
将lib.5plus.base-release.aar、android-gif-drawable-release@1.2.23.aar、uniapp-v8-release.aar和oaid_sdk_1.0.25.aar拷贝到libs目录下
build. gradle文件下添加如下：
implementation fileTree(dir: 'libs', include: ['*.aar', '*.jar'], exclude: []) implementation "com.android.support:support-v4:28.0.0" implementation "com.android.support:appcompat-v7:28.0.0" implementation 'com.android.support:recyclerview-v7:28.0.0' implementation 'com.facebook.fresco:fresco:1.13.0' implementation "com.facebook.fresco:animated-gif:1.13.0" implementation 'com.github.bumptech.glide:glide:4.9.0' implementation 'com.alibaba:fastjson:1.1.46.android' signingConfigs { config { keyAlias 'key0' keyPassword '123456' storeFile file('wangyz.jks') storePassword '123456' v1SigningEnabled true v2SigningEnabled true } } buildTypes { debug { signingConfig signingConfigs.config minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84ea929e1f22e842dca91e0b10458bbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db794fa08bf58a49aea9034a5015a5b/" rel="bookmark">
			ES6模块化用法全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.模块化前世今生： 1.模块化就是把单独的一个功能封装到一一个模块(文件)中,模块之间相互隔离,但是可以通过特定的接口公开内部成员,也可以依赖别的模块。模块化开发的好处是方便代码的重用，从而提升开发效率，期方便后期的维护。
2.以前浏览器常用的模块化规范有 AMD（代表Require.js）和 CMD（代表Sea.js），但是都落伍了。服务端有 CommonJS规范。不过也不是标准的。最终ES6官方提出了大一统的模块化规范，这也是目前浏览器与服务端的通用规范。
3.Es6模块化规范中定义:每个js文件都是一个独立的模块。导入模块成员使用import关键字。暴露模块成员使用export关键字。
4.下面请看详细的使用。
二.详细用法： 首先，我同一个目录下新建一个export.js文件模拟其为要导出的模块，再建一个import.js文件模拟其要导入其它模块。同时为了在浏览器运行，新建一个index.html文件，并引入import.js文件。需要注意的是index.html引入import.js时要指定类型type="module"才能使用模块化。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 看这 --&gt; &lt;script type="module" src="./import.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 1.导出导入基本变量： 直接导出整句导出，导入变量名要跟导出的模块变量名一一对应否则报错，同时用{}包裹导入的变量名：
export.js内容：
export let name = 'jack'; export let age = 18; import.js内容
// 名称要跟导出的模块名称一一对应，同时from后为导入模块的路径 import {name,age} from './export.js' console.log(`我叫${name},今年${age}岁`); 运行结果：
2.导出导入基本变量（2）： 也可以先定义变量名，再直接导出变量名。
export.js内容：
let name = 'jack'; let age = 18; export { name, age } import.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db794fa08bf58a49aea9034a5015a5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b28689e0d5b8f6dacc52845aceaaef/" rel="bookmark">
			modelsim学习经验文章整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(61条消息) QuartusII13.1 详细开发步骤（半加器为例）（FPGA）_wlx嘿的博客-CSDN博客: https://blog.csdn.net/weixin_44620183/article/details/104770813
(61条消息) quartus调用modelsim仿真每次都要重新打开modelsim吗？联合仿真每次都要关闭modelsim再重新打开吗_星米豪乐园-CSDN博客: https://blog.csdn.net/kai73/article/details/105407697
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3754188b79ca2af16ab3a3ef9890630f/" rel="bookmark">
			安卓百度离线人脸识别SDK集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先申请百度离线人脸识别SDK以及验证码，申请好以后就可以集成环境了。
集成步骤还是比较详细的，看着文档基本就可以搞定，建议新手可将facelibrary和face-sdk-library以项目的新式集成在你的项目中，然后以外部库引入方式引入这两个项目，其中face-sdk-library依赖facelibrary，所以在你项目gradle中api project("face-sdk-library")就可以了，但是一定要在setting中加入这两个model。
新手可以根据官方demo选择需要的demo模板直接引入，方便以后使用，因为他里面都是封装好的，直接拿来用就可以了。
具体集成指南可参考官方文档
https://ai.baidu.com/ai-doc/FACE/pk37c1mqu#21-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D
值得一提的是安卓sdk在提取人脸特征(getFeature)的时候不支持多线程，比如你的设备正在进行人脸识别特征比对，此时你又操作图片获取人脸特征更新人脸库，这个时候就会报错崩溃。该问题也已经咨询官方明确不支持多线程调用。所以你在进行任何一种人脸特征提取操作时都需要保证没有别的地方在调用该方法以规避此问题。
集成成功后的效果，识别率还是可以的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d522d3e2f318cc3802d77858406073/" rel="bookmark">
			OrCAD DRC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Date and Time : 09/13/21 01:16:03
--------------------------------------------------
Checking Schematic: TX5105C_KIT_CORE
--------------------------------------------------
Checking Electrical Rules WARNING(ORCAP-1829): Possible pin type conflict VDD_3V3_EXT Power Connected to Bidirectional
TX5105C_KIT_CORE, 11-LCD 5 INCH MIPI (109.22, 220.98) WARNING(ORCAP-1829): Possible pin type conflict U13A,VDDIO2 Bidirectional Connected to Power
TX5105C_KIT_CORE, 09-MIPI TO USB3.0 (95.25, 128.27) WARNING(ORCAP-1829): Possible pin type conflict U35,VIN Power Connected to Bidirectional
TX5105C_KIT_CORE, 06-TX510 DPU MIPI (213.36, 228.60) WARNING(ORCAP-1829): Possible pin type conflict U34,VIN Power Connected to Bidirectional
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d522d3e2f318cc3802d77858406073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75100ee3cb49fa5a6750e67d6c44ae6e/" rel="bookmark">
			Vmware虚拟机NAT模式设置IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先查看自己的虚拟机服务有没有开启，选择电脑里面的服务查看；
1.计算机点击右键选择管理 2.进入管理选择VM开头的服务如果没有开启的话就右键开启 二、虚拟机服务开启后就查看本地网络虚拟机的网卡启动没有
1.电脑右下角网络标志右键进入网络和共享中心
2.点击更改适配器，查看虚拟机的虚拟网卡启动没有，没有启动的话右键点击启动 3.网卡开启后设置ip地址，此处设置的ip和本机的ip没有关系，设置成你虚拟机里面运行的计算机需要的ip地址网段
三、此时你的本机设置完成了，该设置虚拟机
1.打开虚拟机，选择你使用的操作系统打开详情页选择网络适配器，选择NAT模式并选择启动时连接，如下图； 2.选择完后点击虚拟机页面上的编辑进入虚拟网络编辑器 3.进来后会出现这个窗口，选择右下角更改设置，使用管理员进行修改 3.1.选择VMnet0，桥接时请注意自己选择的是无线网络还是本地连接
3.2此处为我电脑的网络连接，与上图一一对应
4.更改完成后，更改下方的ip地址，此处的ip地址段和你在本机网络虚拟网卡（二-3）里面设置的ip要在一个网段里面,本机设置的是ip地址，而在此处设置的是ip网段 5.选择DHCP,进行设置你的虚拟机分配虚拟计算机的ip地址范围 6.设置完DHCP后进行网关的设置，选择NAT设置，设置你虚拟计算机的网关地址。 四、这时候，必要条件就已经配合结束了，开启虚拟计算机，进入IPv4的设置。 1.通过
命令进入ifcfg-ens33文件设置ipv4的设置信息
1.1其中ip地址的范围需要在上文中DNCP分配的ip地址范围之内
1.2设置虚拟机的网管地址需要与主机保持一致
2.通过
设置
在配置文件中添加 两个nameserver 3.修改完成之后 通过 service network restart 重启网络连接
4.此时再进行ping的时候就可以成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b537cb2d9c6152bbb6666b9cdd1621f/" rel="bookmark">
			基于JAVA&#43;Servlet&#43;JSP&#43;MYSQL的党员信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目功能：
###用户角色：
超级管理员： 整个系统的信息维护，相当于学校党务负责人
测试账号admin 密码：123456
系管理员： 各院系党务办公室负责人，负责管理自己院系党员信息
测试账号zhangsan 密码：123456
实现功能：（超级管理员与系管理员权限不同） 用户个人信息管理 修改密码
学院信息管理 管理员对各学院党员人数管理
系管理员对本院近三年党员信息统计浏览
支部信息管理 超级管理员对各院系管理员信息管理
*入党积极分子信息
入党积极分子信息增删改查管理
预备党员信息 预备党员信息增删改查管理
正式党员信息 正式党员信息增删改查管理
党费信息 党费信息显示、按每人每年2.4元统计
组织活动信息 院系组织活动信息
系统公告信息 校园公告，超级管理员发布，院系管理员浏览
页面效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b5d30c723b115de68a594a814a2711/" rel="bookmark">
			【Java 并发编程】线程池机制 ( 线程池阻塞队列 | 线程池拒绝策略 | 使用 ThreadPoolExecutor 自定义线程池参数 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、线程池阻塞队列二、拒绝策略三、使用 ThreadPoolExecutor 自定义线程池参数 一、线程池阻塞队列 线程池阻塞队列是线程池创建的第 5 5 5 个参数 : BlockingQueue&lt;Runnable&gt; workQueue ;
public ThreadPoolExecutor(int corePoolSize,	// 核心线程数 , 这些线程基本不会被销毁 int maximumPoolSize, // 最大线程数 , 线程池能创建的最大线程数量 long keepAliveTime, // 空闲情况下 , 非核心线程存活时间 TimeUnit unit, // 空闲时间单位 BlockingQueue&lt;Runnable&gt; workQueue,// 任务的阻塞队列 ★ ThreadFactory threadFactory, // 创建线程的工厂类 RejectedExecutionHandler handler) // 拒绝策略 线程池阻塞队列 : 线程池中的阻塞队列 , 同一时刻 , 只能有 1 1 1 个线程访问队列 , 执行任务 入队 / 出队 操作 ; 队列都是 FIFO 先进先出 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b5d30c723b115de68a594a814a2711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d96f9ea96eb6d607e1fef7b702b5bc8/" rel="bookmark">
			vue2.x&#43;elementui2.x构建后台管理系统-登陆界面的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、登陆界面 登陆界面使用elementui加vue实现,首先我们要明确登陆界面实现的功能，这里只说在前端登陆界面上应该实现的功能， 首先登陆界面要实现登陆信息的采集，这样才能供后端判断该用户到底是不是系统用户，以避免信息泄露等事情发生。其次要对用户输入的信息做一定的判断，避免恶意登陆导致服务器崩溃。最后就是整个界面的美化程度了，这样就能实现一个最简单的登陆界面了。
接上篇文章 登录文件名发生了一些变化，修改登录文件名即可。
AdminLogin.vue &lt;template&gt; &lt;div class="login-main"&gt; &lt;div class="login-form-main"&gt; &lt;h3 style="color: #2ECCFA;"&gt;报表后台管理系统&lt;/h3&gt; &lt;el-form :model="ruleForm" status-icon :rules="rules" ref="ruleForm" label-width="100px" class="demo-ruleForm"&gt; &lt;el-form-item label="账号：" prop="pass"&gt; &lt;el-input type="text" v-model="ruleForm.pass" autocomplete="off" style="width:220px; float:left;"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="密码：" prop="checkPass"&gt; &lt;el-input type="password" v-model="ruleForm.checkPass" autocomplete="off" show-password style="width:220px; float:left;"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;div class="form-button"&gt; &lt;el-button type="primary" @click="submitForm('ruleForm')" &gt;提交&lt;/el-button&gt; &lt;el-button @click="resetForm('ruleForm')"&gt;重置&lt;/el-button&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { var validatePass = (rule, value, callback) =&gt; { if (value === '') { callback(new Error('请输入账号')); } else { callback(); } }; var validatePass2 = (rule, value, callback) =&gt; { if (value === '') { callback(new Error('请输入密码')); } else { callback(); } }; return { ruleForm: { pass: '', checkPass: '', }, rules: { pass: [ { validator: validatePass, trigger: 'blur' } ], checkPass: [ { validator: validatePass2, trigger: 'blur' } ], } }; }, methods: { submitForm() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d96f9ea96eb6d607e1fef7b702b5bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb83714f2792cc0331351c195176277/" rel="bookmark">
			cloud init error: Error: errCode: -601034 | errMsg: 没有权限，请先开通云开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序启动报错cloud init error: Error: errCode: -601034 | errMsg: 没有权限，请先开通云开发
解决方法：
点击云开发，进行基础项的配置，创建新环境，之后把云开发窗口关掉，再重启之后，报错就会解决掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389efe261e02bf4524be0af92151ac88/" rel="bookmark">
			ModbusTCP协议报文详细分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ModbusTCP协议分析 ModbusTCP与ModbusUDP的报文格式是一样的，它们之间的区别其实就是TCP与UDP的区别，因此下面就针对ModbusTCP的协议进行分析，ModbusTCP与ModbusRtu（ModbusASCII）之间的区别如下图：
从上图可以看出，ModbusTCP在Modbus串行通信的基础上，去除了校验（由于TCP本身就带有校验和）和设备地址（ModbusTCP弱化了设备地址，用IP地址来取代），再加上MBAP报文头（占7 bytes），下面针对MBAP进行分析说明：
域长度说明客户机服务器事务处理标识符2字节Modbus请求/响应事务处理的标识客户机启动复制响应协议标识符2字节0=Modbus协议客户机启动复制响应长度2字节长度之后的字节总数客户机启动服务器启动单元标识符1字节串行链路或其它总线的从站识别客户端启动复制响应 下面针对具体报文进行分析，Modbus协议在以太网链路上的报文格式如下所示：
事务处理标识符协议标识符长度单元标识符功能码数据2 bytes2 bytes2 bytes1 byte1 byteN bytes 有了以上理论基础之后，下面针对各个功能码进行详细分析：
读取输出线圈 发送报文格式如下：
发送报文含义：读取服务器1号从站输出线圈，起始地址为0x13=19，对应地址为00020，线圈数量为0x1B=27，即读取1号从站输出线圈，地址从00020-00046，共27个线圈的状态值。
这里值得注意一下，协议中的起始地址指的是索引，后面的地址指的是具体地址，对于任意一个存储区，索引都是从0开始的，但是对应的具体地址，与存储区是相关的，比如输出线圈，0对应00001；输入线圈，0对应10001；输入寄存器，0对应30001；保持寄存器，0对应40001。
返回报文格式如下：
返回报文含义：返回服务器1号从站输出线圈00020-00046，共27个线圈的状态值，返回字节数为4个，分别为CD 6B B2 05。
CD=1100 1101 对应 00020-00027
6B=0110 1011 对应 00028-00035
B2=1011 0010 对应 00036-00043
05=0000 0101 对应 00044-00046
读取输入线圈 发送报文格式如下：
发送报文含义：读取服务器1号从站输入线圈，起始地址为0xC4=196，对应地址为10197，线圈数量为0x1D=29，即读取1号从站输入线圈，地址从10197-10225，共29个线圈的状态值。
返回报文格式如下：
返回报文含义：返回服务器1号从站输入线圈10197-10225，共29个线圈的状态值，返回字节数为4个，分别为CD 6B B2 05。
CD=1100 1101 对应 10197-10204
6B=0110 1011 对应 10205-10212
B2=1011 0010 对应 10213-10220
05=0000 0101 对应 10221-10225
读取保持寄存器 发送报文格式如下：
发送报文含义：读取服务器1号从站保持寄存器，起始地址为0x6B=107，对应地址为40108，寄存器数量为0x02=2，即读取1号从站保持寄存器，地址从40108-40109，共2个寄存器的数值。
返回报文格式如下：
返回报文含义：返回服务器1号从站保持寄存器40108-40109，共2个寄存器的数值，返回字节数为4个，分别为02 2B 01 06，40108对应数值为0x022B，40109对应数值为0x0106。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/389efe261e02bf4524be0af92151ac88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac43ad9528bc8e34b3616e7c6cef546d/" rel="bookmark">
			latex报错|Undefined control sequence \subfloat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试试将包\usepackage{subfloat}改为\usepackage{subfig}
参考：https://www.jianshu.com/p/90923029d39d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f131b83461f37aa9aad286d0ed446951/" rel="bookmark">
			python||判断K-Means聚类最佳数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行K均值聚类之前，不知道聚成几类效果是最好的，经过查资料，发现有两种常用的方式。分别是：
1.肘方法
2.轮廓系数法
这篇文章记录使用肘方法判断聚类最佳数量，肘方法的原理是什么呢？
这是来自一个博友的解释，我一个没学过理科的人也看不懂。接下来直接开始操作：
这是我的原始数据：
看一下python代码实现：
import pandas as pd #导入pandas库 import numpy as np from sklearn.cluster import KMeans #导入k均值函数 import matplotlib.pyplot as plt import xlrd file_path=xlrd.open_workbook("cluster_MinMax.xls") #读取文件 table = file_path.sheets()[0] #读取文件，获取第一个sheet页，赋值给table my_data=[] #创建一个空列表 for i in range(table.nrows): #nrows为表的行数，遍历nrows的行数 if i == 0: #忽略第一行 continue else: my_data.append(table.row_values(i)[0:]) #把第i行的数据添加到data列表里去 featureList = ['0', '1', '2','3','4','5','6','7'] #创建了一个特征列表，这是我原始表格里的特征名 mdl = pd.DataFrame.from_records(my_data, columns=featureList) #把my_data里的数据放进来，列的名称=featurelist # '利用SSE选择k' SSE = [] # 存放每次结果的误差平方和 for i in range(1, 8): #尝试要聚成的类数 estimator = KMeans(n_clusters=i) # 构造聚类器 estimator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f131b83461f37aa9aad286d0ed446951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4bc19fb3fe1cbfa330a6e4ea3753667/" rel="bookmark">
			HTML&#43;CSS&#43;JavaScript 超具创意的网页生日快乐祝福网页模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML+CSS+JavaScript 超具创意的网页生日快乐祝福网页模板 是不是还没有给心爱的人准备小礼物呀，但是别担心，精心创作了一个“飘动爱心3D相册”网页，按照下面这个教程就可以给Ta做一个创意满满的祝福了呀~（很简单的哦）
作品介绍 1.网页作品简介方面 ：一个超具创意的网页 ,喜欢的可以下载，作品支持手机PC响应式布局 (可自定义12张相片和音乐)
2.网页作品编辑方面：任意HTML编辑软件（例如：DW、HBuilder、NotePAD 、Vscode 、Sublime 、Webstorm 所有编辑器均可使用）
文章目录 HTML+CSS+JavaScript 超具创意的网页生日快乐祝福网页模板作品介绍一、作品演示二、代码目录三、代码实现HTMLCSSJS 四、web前端入门到高级(视频+源码+资料+面试)一整套 (教程)五、源码获取六、更多表白源码 一、作品演示 ❤100款 html+css+JavaScript 表白源码演示地址
二、代码目录 三、代码实现 HTML &lt;head&gt; &lt;title&gt;Happy Birthday&lt;/title&gt; &lt;meta charset="UTF-8"/&gt; &lt;meta name="description" content="Happy Birthday"&gt; &lt;meta name="robots" content="index, follow"/&gt; &lt;link rel="author" href="https://plus.google.com/u/1/+AyushSharma1/"/&gt; &lt;meta name="keywords" content="Birthday, Happy"&gt; &lt;script src="assets/less.min.js"&gt;&lt;/script&gt; &lt;script src="config.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="loading"&gt;&lt;/div&gt; &lt;audio class="song" controls loop&gt; &lt;source src="assets/hbd.mp3"&gt;&lt;/source&gt; Your browser isn't invited for super fun audio time. &lt;/audio&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4bc19fb3fe1cbfa330a6e4ea3753667/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/299b363fc9482b5eb920667436bfe1a0/" rel="bookmark">
			JAVA垃圾回收算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。C++内存的申请和释放都可以由程序员手动进行，而Java则采用了自动垃圾回收机制使程序员更关注于业务而无需在内存分配和回收上花费太多的时间。但是我们仍然需要去学习Java的垃圾回收机制，要理清楚Java的垃圾回收机制，要搞清楚三点：
哪些内存需要回收什么时候回收怎么回收 如何判断对象已经成为垃圾 在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。
引用计数算法 很多教科书判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。笔者面试过很多应届生和一些有多年工作经验的开发人员，他们对于这个问题给予的都是这个答案。
客观地说，引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。也有一些比较著名的应用案例，例如微软COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言以及在游戏脚本领域得到许多应用的Squirrel中都使用了引用计数算法进行内存管理。但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。
可达性分析算法 当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。
定可作为GC Roots的对象，这个知识点在面试过程中问到垃圾回收的时候基本是必wen知识点：
在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。在本地方法栈中JNI（即通常所说的Native方法）引用的对象。Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。所有被同步锁（synchronized关键字）持有的对象。反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
简单地说，GC Root 就是经过精心挑选的一组活跃引用，这些引用是肯定存活的。那么通过这些引用延伸到的对象，自然也是存活的。 对象状态是生存还是死亡 用可达性分析算法进行判定时，如果对象与GC Root不再有引用链，那他们就是可以被回收的对象，但并不是“非死不可”，JVM里面还有一个引用的概念：强引用，软引用，弱引用，虚引用。要真正的判定一个对象死亡，在失去引用链之后，至少还要经历两次标记的过程。
回收方法区 方法区的垃圾回收主要回收两部分的数据：
废弃的常量不再使用的类型 判断一个常量是否需要废弃比较简单，但是判断类型是否不再使用就很难，需要同时满足下面的三个条件：
该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方 法。 垃圾回收算法 当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分 代假说之上：
1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。
这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那 么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有 效利用。在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域 ，因而才有了：
新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。整堆收集（Full GC）。
这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了
标记-复制算法标记-清除算法标记-整理算法 标记-清除算法 最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，在1960年由Lisp之父 John McCarthy所提出。如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回 收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回 收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。
之所以说它是最基础的收集算法，是因为后续的收集算法大多都是以标记-清除算法为基础，对其 缺点进行改进而得到的。它的主要缺点有两个：第一个是执行效率不稳定，如果Java堆中包含大量对 象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过 程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题，标记、清除之后会产生大 量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找 到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记-清除算法的执行过程如下图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/299b363fc9482b5eb920667436bfe1a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c20e6c103cd68a9da5086b653a17082f/" rel="bookmark">
			式非git账户密码提交的另外一种方式SSH转ppk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在github的项目中可以看到有一个
image.png git@github.com:qssq/FileRedirect.git 和之前的明文密码输入提交的地址 https://github.com/qssq/FileRedirect.git是不同的，这里已经举例了两种，https的方式提交目前已经不行了，这个我另外一篇文章 https://www.jianshu.com/p/f40a54e61ab4 有提到几种解决办法，现在这里又补充一种新的办法，这种办法也算比较古老，只是我给忘给老师了，因为那种直接输入git账号的方法让我习惯了，慢慢把这个技术忘记了。。我摸索了一下又把忘记的知识捡回来了。 上面的截图是因为我已经生成了一个，所以没有提示让我填写OpenSSH，有提示的会跳转到 https://github.com/settings/keys https://github.com/settings/ssh/new 也就是如下界面
image.png 添加界面
image.png 生成Open Keys 填写到Key输入框就好了，
格式大概是ssh-rsa 之类的开头 或者其它之类的ds,ecdsa ed25519 ssh-1之类的， 我就生成 接下来软件默认的。
这里讲的是使用 TortoiseGit。首选下载这个软件，它会携带PuTTY Key Generator 这个软件。
image.png 收线 点击生成，Generate然后上面的输入框内容会产生，把它完整的复制到github上去，然后把你的私钥ppk文件保存起来。。
image.png 然后在window文件夹右击 git clone 会弹出这样一个输入框，地址填写ssh地址，
加载putty秘钥就是上面保存的私钥。
I6Z$M`}C0~B35_Z{81ZP35G.png 点击确定让你输入密码，这个密码我之前说过是点击生成Open SSH的时候填写的密码。
然后来了个警告，点确定就行了。
image.png image.png 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa59d1d10627e591689bd9bfb982351/" rel="bookmark">
			SPI、I2C、UART（即串口）三种串行总线对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容转载自：https://blog.csdn.net/oqqHuTu12345678/article/details/65445338
以下内容均来源于网络资源的学习整理，如有侵权，请告知删除。
参考博客
https://blog.csdn.net/xiaodingqq/article/details/80342459
https://blog.csdn.net/weiqifa0/article/details/8845281
https://www.zhihu.com/question/22632011
http://www.360doc.cn/article/13253385_330564821.html
https://blog.csdn.net/zhuyongxin_6688/article/details/78001767（有图，荐）
https://blog.csdn.net/Setul/article/details/78968242
目录
一、名字
二、UART、SPI、I2C对比
三、串行外设接口：SPI
1、速览点
2、数据传输
3、spi读写
四、IC之间总线：I2C
1、速览点
2、详细介绍
3、时序
4、代码
五、通用异步收发器：UART
1、速览点
2、通信协议
3、详细介绍
4、代码学习
六、心得体会
1、通信接口分为物理层（硬件）和协议层
2、关于总线的选择问题
七、UART和RS232的联系和区别
1、RS232
2、UART
3、TTL和RS232
4、嵌入式常用串口实物图
一、名字 SPI(Serial Peripheral Interface：串行外设接口)，是Motorola公司提出的一种同步串行数据传输标准。I2C(INTER IC BUS：IC之间总线)，是由PHILIPS公司开发的两线式串行总线，用于连接微控制器及其外围设备，是微电子通信控制领域广泛采用的一种总线标准。UART(Universal Asynchronous Receiver Transmitter：通用异步收发器)，是电脑硬件的一部分，它把将要传输的资料在串行通信与并行通信之间加以转换，UART通常被集成于其他通讯接口的连接上。UART即我们通常说的“串口”。 二、UART、SPI、I2C对比 UART、SPI、I2C对比表格 对比项 UART SPI I2C信号线数目3根，RX、TX、GND4根，SDO、SDI、SCLK、SS2根，SDA、SCLK设备从属关系 ——存在主从设备。SPI用片选信号选择从机 存在主从设备。IIC用地址选择从机。通信方式全双工通信全双工通信半双工通信通信速率速度慢比I2C总线要快，速度可达到几MbpsI2C的速度比SPI慢应用领域 1、UART常用于控制计算机与串行设备的芯片
2、就是我们经常所说的串口，基本都用于调试。
主要应用在EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间I2C一般是用在同一个板子上的2个IC之间的通信 ，它可以替代标准的并行总线，连接各种集成电路和功能模块。传输距离 I2C需要有双向IO的支持，而且使用上拉电阻，抗干扰能力较弱，一般用于同一板卡上芯片之间的通信，较少用于远距离通信通信特征异步，一帧可以传5/6/7/8位同步，SPI允许数据一位一位的传送，甚至允许暂停。从最高位开始传。同步，电平信号，一次连续8bit。从最高位开始传协议复杂度结构比较复杂SPI实现要比UART简单，UART需要固定的波特率，就是说两位数据的间隔要相等，而SPI则无所谓，因为它是有时钟的协议。协议比SPI复杂，但是连线比标准的SPI要少对比 在点对点的通信中，SPI接口不需要进行寻址操作，且为全双工通信,显得简单高效。
在多个从器件的系统中,每个从器件需要独立的使能信号,硬件上比I2C系统要稍微复杂一些。
三、串行外设接口：SPI 1、速览点 （1）四条信号线：串行时钟(SCLK)、串行数据输出(SDO)、串行数据输入(SDI)、片选线（SS）。（所谓的进出，是针对信号进出主机而言）
（2）SPI总线可以实现多SPI设备互相连接。提供时钟的SPI设备为主设备(Master)，其他设备为从设备(Slave)。SCLK信号线只由主设备控制，从设备不能控制信号线。
（3）在SPI总线上，某一时刻可以出现多个从机，但只能存在一个主机。主机通过片选线来确定要通信的从机。这就要求从机的MISO口具有三态特性，使得该口线在器件未被选通时表现为高阻抗。
（4）主从设备间可以实现全双工通信，收发独立，操作简单，数据传输速率较高，但需要占用主机较多的口线（每个从机都需要一根片选线），而且只支持单个主机，没有指定的流控制，没有应答机制确认是否接收到数据。
（5）数据输出通过SDO线，数据在时钟上沿或下沿时改变（即发送），在紧接着的下沿或上沿被读取，从而完成一位数据传输。数据输入也使用同样原理。因此，8位数据的传输，至少需要8次时钟信号的改变（上沿和下沿为一次）。
（6）普通的串行通讯一次连续传送至少8位数据，而SPI允许数据一位一位的传送，甚至允许暂停，因为SCK时钟线由主控设备控制，当没有时钟跳变时，从设备不采集或传送数据。也就是说，主设备通过对SCK时钟线的控制可以完成对通讯的控制。
（7）SPI接口在CPU和外围低速器件之间进行同步串行数据传输，在主器件的移位脉冲下，数据按位传输，高位在前（先传？），低位在后，为全双工通信。
2、数据传输 （1）SPI在数据传输的时候，需要确定两件事情：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaa59d1d10627e591689bd9bfb982351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4d257857de09d8297a13ac6ddf7717/" rel="bookmark">
			python给类创建实例时提示无参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建了一个类，根据这个类创建实例后，运行程序显示：
仔细检查了代码，发现类的定义和方法的写法都没问题。但是忽略了一个细节，就是在定义__init__方法时少加了两个下划线：
__init__方法是字母前后有两个下划线，改了之后就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56e487f9d04f72282c8b995463e52c92/" rel="bookmark">
			Maven项目中配置build resource来防止资源导出失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在maven项目的pom文件中通过配置build，关闭对某些资源的过滤，从而防止资源导出失败。
&lt;!--在build中配置resources, 来防止我们资源导出失败问题--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 其中关闭了对xml文件和properties文件的过滤，如果还需要保留其他的文件可以通过include进行添加。
注意：在添加了此段代码后需要刷新maven，不然可能不能生效。
------------------------------------------------------------------------------------------------------------------------------
maven中的web.xml
web.xml ```xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0" metadata-complete="true"&gt; &lt;/web-app&gt; ``` maven中配置pom的父子模块之间的联系
父模块 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 父模块--&gt; &lt;modules&gt; &lt;module&gt;servlet-01&lt;/module&gt; &lt;module&gt;servlet-02&lt;/module&gt; &lt;module&gt;response&lt;/module&gt; &lt;module&gt;request_01&lt;/module&gt; &lt;module&gt;request-02&lt;/module&gt; &lt;/modules&gt; &lt;/project&gt; 子模块 &lt;?xml version="1.0" encoding="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56e487f9d04f72282c8b995463e52c92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf319e28297ef4f536abebc26e03b739/" rel="bookmark">
			python国内repository
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/83/">«</a>
	<span class="pagination__item pagination__item--current">84/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/85/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>