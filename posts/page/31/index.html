<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd578b280eced33bce7ef6d4c27107e3/" rel="bookmark">
			Vue中key的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue中key的作用 key的特殊attribute主要用在Vue的虚拟DOM算法，在新旧Nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改、复用相同类型元素的算法，而使用key时，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。此外有相同父元素的子元素必须有独特的key，重复的key会造成渲染错误。
描述 首先是官方文档的描述，当Vue正在更新使用v-for渲染的元素列表时，它默认使用就地更新的策略，如果数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时DOM状态的列表渲染输出，例如表单输入值。为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute，建议尽可能在使用v-for时提供key attribute，除非遍历输出的DOM内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。
简单来说，当在列表循环中使用key时，需要使用key来给每个节点做一个唯一标识，diff算法就可以正确的识别此节点，找到正确的位置直接操作节点，尽可能地进行重用元素，key的作用主要是为了高效的更新虚拟DOM。此外，使用index作为key是并不推荐的做法，其只能保证Vue在数据变化时强制更新组件，以避免原地复用带来的副作用，但不能保证最大限度的元素重用，且使用index作为key在数据更新方面和不使用key的效果基本相同。
示例 首先定义一个Vue实例，渲染四个列表，分别为简单列表与复杂列表，以及其分别携带key与不携带key时对比其更新渲染时的速度，本次测试使用的是Chrome 81.0，每次在Console执行代码时首先会进行刷新重新加载界面，避免浏览器以及Vue自身优化带来的影响。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Vue&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="item in simpleListWithoutKey" &gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for="item in simpleListWithKey" :key="item" &gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for="item in complexListWithoutKey"&gt; &lt;span v-for="value in item.list" v-if="value &gt; 5"&gt;{{value}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for="item in complexListWithKey" :key="item.id"&gt; &lt;span v-for="value in item.list" :key="value" v-if="value &gt; 5"&gt;{{value}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="https://cdn.staticfile.org/vue/2.2.2/vue.min.js"&gt;&lt;/script&gt; &lt;script type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd578b280eced33bce7ef6d4c27107e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46095ddafdca7f105fef68c22eb1c72/" rel="bookmark">
			【一】爬虫基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础概念 URI URI（Uniform Resource Identifier，统一资源标识符)是一个用于标识某一互联网资源名称的字符串。该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。URI由包括确定语法和相关协议的方案所定义。
Web上可用的每种资源，如，HTML文档、图像、视频片段、程序等，由一个通用资源标识符（Uniform Resource Identifier, 简称URI）进行定位。
URL 因特网上的可用资源可以用简单字符串来表示，而这些字符串则被称为URL（Uniform Resource Locator，简称URL，统一资源定位器）。一个URL由以下几个部分组成：
scheme：表示访问协议，比如http、https、ftp等；host：主机名，域名，比如，www.csdn.net；port：端口号，比如http协议默认使用80端口，https默认端口是443；path：查找路径，比如https://blog.csdn.net/nav/ai后面的/nav/ai就是path；query-string：查询字符串，比如https://www.baidu.com/s?wd=URL后面的wd=URL就是查询字符串；anchor：锚点，前端用来做页面定位。一些前后端分离的项目，也用锚点来做导航； 在浏览器中请求一个URL，浏览器会对URL进行一个编码。除了英文字母、数字和部分符号外，其它字符都会用%+十六进制码值的组合进行编码。
Http协议 HTTP协议（Hyper Text Transfer Protocol，简称HTTP，超文本传输协议）是一个简单的请求-响应协议；
HTTPS协议是在HTTP 的基础下加入SSL，SSL是HTTPS 的安全基础，通过传输加密和身份认证保证了传输过程的安全性。
常见的8种请求方法 HTTP协议中定义了8种方法：
GET: 通过给定的URI从给定服务器中检索信息，使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。HEAD: 与GET方法相同，但没有响应体，仅传输状态行和标题部分。POST: 用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。PUT: 用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。DELETE: 用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。CONNECT: 用来建立到给定URI标识的服务器的隧道;它通过简单的TCP/IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信(HTTPS)。OPTIONS: 用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。TRACE: 回显服务器收到的请求，主要用于测试和诊断。 常见的请求头参数 在HTTP协议中，向服务器发送一个请求，数据分为三部分：第一个是把数据放在URL中；第二个是把数据放在body中（在post请求中）；第三个就是把数据放在Header中。客户端向服务区发送请求时带的Header，称之为请求头，下面介绍一些会经常用到的请求头参数：
Accept：表示当前浏览器可以接受的文件类型。Accept-Encoding：表示当前浏览器可以接受的数据编码，如果服务器吐出的数据不是浏览器可接受的编码，就会产生乱码。Accept-Language：表示当前使用的浏览语言。Accept-Charset：表示当前浏览器可接受的字符集。 Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。Connection：表示是否需要持久连接。Content-Length：表示请求消息正文的长度。Host：初始URL中的主机和端口User-Agent：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的。如果我们是通过爬虫发送请求，那么我们的User-Agent就是Python，这对于那些有反爬虫机制的网站来说，可以轻易的判断你这个请求是爬虫。因此我们要经常设置这个值为一些浏览器的值，来伪装我们的爬虫。Referer：表明当前这个请求是从哪个URL过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。Cookie：http协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这时候就用cookie来做标识。一般如果想要做登录后才能访问的网站，那么就需要发送cookie信息了。 常见的响应状态码 200：请求成功。301：永久重定向。302：临时重定向。400：请求的URL在服务器上找不到。403：服务器拒绝访问。500：服务器内部错误。 TPS、QPS TPS：每秒传输的事物处理个数(Transactions Per Second)，即服务器每秒处理的事务数。
一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。
QPS：每秒查询率(Queries-per-second)，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。
因特网上，经常用每秒查询率来衡量域名系统服务器的机器性能，即为QPS。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。
流量 数据传输速率的常用单位为bps，也就是每秒传送的位数(bits per second)。数据通常是串行传输的，即一个比特接一个比特地传输。数据速率的单位是比特每秒（bps），含义是每秒串行通过的位数。
bit：信息技术中的最小单位。
Byte：字节，文件大小（例如文本或图像文件）通用的计量单位。
1 Byte = 8 Bits
1 KB = 1024 Bytes
1 MB = 1024 KB
1 GB = 1024 MB
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46095ddafdca7f105fef68c22eb1c72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7a5fd7ed8621d4fa8e239d0493e4fd2/" rel="bookmark">
			vmware虚拟机网络配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机网络
链接的网卡
是否可以链接主机
是否可以链接局域网
是否可以链接公网
桥接
真实网卡
可以
可以
可以
NAT
VMnet8
可以
不可以
可以
仅主机
VMnet1
可以
不可以
不可
桥接：
1、查询真实机IP地址：
1）图形方式：
右击网卡---网络和Internet设置----更改适配器设置----双击网卡图标（有线、无线）------详细信息
2）命令行方式：
搜索---cmd----ipconfig
2、设置虚拟机网络连接模式为：桥接
1）设置为：桥接
虚拟机---设置----网络适配器----桥接模式---确定
2）手工桥接到：有线网卡（无线网卡）
虚拟机---编辑---虚拟网络编辑器---更改设置----桥接模式----桥接到---有线（无线）---确定
3、设置虚拟机IP地址：
IP地址： 192.168.166.2-254
子网掩码： 255.255.255.0
网关： 192.168.166.1
DNS： 8.8.8.8
桥接模式优缺点：
优点：配置简单，网络特征和真实机一致，好理解
缺点：需要占用一个真实网段IP地址
虚拟机和真实机同一个网段，有可能有网络安全风险（病毒、攻击、需要和真实网段一致）
NAT模式：
查询VMnet8的IP地址：192.168.11.1
①建议：把VMnet8的地址手工固定
②冲突之后修改方式：
VMnet8改回自动获取
虚拟机——编辑——虚拟网络编辑器——更改设置——NAT模式——子网（IP）修改
虚拟机网络连接设置为：NAT模式
设置虚拟机IP地址信息：IP地址：192.168.11.3-254
子网掩码：255.255.255.0
网关：192.168.11.2
DNS：8.8.8.8
仅主机模式：
查询VMnet的IP地址：192.168.102.1
虚拟机网络连接设置为：仅主机模式
设置虚拟机IP地址信息：IP地址：192.168.102.2-254
子网掩码：255.255.255.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3579eb18e026cbf4abd6e9b77fd24943/" rel="bookmark">
			.net winform 使用NModbus4建立 modbus tcp通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用nuget引入NModbus4。
2、编写TCP访问modbus的方法
public void StartTcpClient(string ipstr,string portstr,ushort adress, ushort readLenth)
{
try
{
IPAddress myIP =IPAddress.Parse(ipstr);
int port = int.Parse(portstr);
IsListen = true;
TcpClient myclient = new TcpClient(ipstr, port);
ModbusMaster myMaster = ModbusIpMaster.CreateIp(myclient);
myMaster.Transport.ReadTimeout = 2000;
myMaster.Transport.Retries = 3;
myMaster.Transport.WaitToRetryMilliseconds = 250;
ushort[] value = myMaster.ReadHoldingRegisters(1, adress, readLenth);
}
catch (Exception ex)
{
Log4netHelper.MyErrorMsgLog("StartTcpClient 方法出错：" + ex.Message);
}
}
3、更多参数设置
连接参数设置：
master.Transport.ReadTimeout = 1000;//读取连接（串口）数据超时为
master.Transport.WriteTimeout = 1000;//写入连接（串口）数据超时
master.Transport.Retries = 3;//重试次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3579eb18e026cbf4abd6e9b77fd24943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20cbc8417c25c4098fce586bb41f3a1c/" rel="bookmark">
			Linux关于 用户 的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、用户的增删改查 1. 新增用户 test@DESKTOP:~$ adduser XXX 这样在创建用户名时，就创建了用户的主目录以及密码。
2、修改用户登陆密码 test@DESKTOP:~$ passwd XXX 为用户指定命令解释程序(通常为/bin/bash)：sudo usermod -s /bin/bash tt
为用户指定用户主目录：sudo usermod -d /home/tt tt
3、删除用户 test@DESKTOP:~$ deluser XXX 连同用户的主目录和邮箱一起删除：deluser --remove-home XXX
连同用户拥有的所有文件删除：deluser --remove-all-files XXX
只删除用户：userdel XXX
连同用户主目录一起删除：derlser -r XXX
4、获取用户列表 cat /etc/passwd：这个命令会显示系统中的所有用户信息，包括用户名、用户ID、用户组ID、用户家目录等。用户信息以冒号分隔。
cut -d: -f1 /etc/passwd：这个命令会仅显示用户名，使用冒号作为分隔符。
getent passwd：这个命令会显示系统中的所有用户信息，包括本地用户和网络用户。
awk -F: '{print $1}' /etc/passwd：这个命令会仅显示用户名，使用冒号作为分隔符。
注意，有些命令可能需要root权限才能执行。
二、 用户操作相关问题 1、用户 不在 sudoers 文件中。此事将被报告。 1.1 背景 普通linux用户使用sudo命令执行只有root用户才可以执行的命令时出现了该错误。
1.2 解决方案 1、切换到root su - root 2、给sudoers增加可写权限 chmod 640 /etc/sudoers 3、调整sudoers内容，在【root ALL=(ALL) ALL】下面增加XXX ALL=(ALL) ALL vim /etc/sudoers 4、查看是否修改成功 cat /etc/sudoers 5、给sudoers改成只读权限 chmod 440 /etc/sudoers 6、大功告成，现在普通用户就可以用sudo命令了 2、给某个用户赋予某个文件夹的权限 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20cbc8417c25c4098fce586bb41f3a1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1beba85f27129751839f7c7d2cd1e6ed/" rel="bookmark">
			Nginx安装（详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx-概述与安装 介绍 Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。
官网：https://nginx.org/
下载和安装 在Nginx的官网的下载页面中(http://nginx.org/en/download.html)，就展示了当前Nginx版本，并提供了下载的连接。 如下： 下载的是最新稳定版
安装依赖包
由于nginx是基于c语言开发的，所以需要安装c语言的编译环境，及正则表达式库等第三方依赖库。
yum -y install gcc pcre-devel zlib-devel openssl openssl-devel 下载Nginx安装包
yum install wget wget https://nginx.org/download/nginx-1.22.1.tar.gz wget : wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。 执行完wget指令后，就会在当前所在目录看到下载下来的文件。
解压 使用命令： tar -zxvf “你的Nginx压缩包”，我这里是：
tar -zxvf nginx-1.22.1.tar.gz 配置Nginx编译环境
cd nginx-1.22.1 -- 初始化Nginx ./configure --prefix=/usr/local/nginx 说明: --prefix 指定的目录，就是我们安装Nginx的目录。
编译&amp;安装
make &amp; make install 目录结构 安装完Nginx后，我们可以切换到Nginx的安装目录(/usr/local/nginx)，先来熟悉一下Nginx的目录结构
备注：
上述我们用到的一个指令 tree，该指令可以将我们指定的目录以树状结构展示出来。如果没有这个指令，可以通过以下指令进行安装。
yum install tree
重点目录和文件如下: 目录/文件说明备注conf配置文件的存放目录conf/nginx.confNginx的核心配置文件conf下有很多nginx的配置文件，我们主要操作这个核心配置文件html存放静态资源(html, css, )部署到Nginx的静态资源都可以放在html目录中logs存放nginx日志(访问日志、错误日志等)sbin/nginx二进制文件，用于启动、停止Nginx服务 查看Nginx是否成功安装 -- 查看Nginx的目录 位置 whereis nginx 出现Nginx的目录表示成功安装。 Nginx-命令 常用命令 Nginx中，我们的二进制可执行文件(nginx)存放在sbin目录下，虽然只有一个可执行文件，但是我们可以通过该指令配合不同的参数达到更加强大的功能。接下来，我们就演示一下Nginx常见指令, 在执行下面的指令时,都需要在/usr/local/nginx/sbin/目录下执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1beba85f27129751839f7c7d2cd1e6ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8dd56d6fab065af094db2c8ebd552ce/" rel="bookmark">
			文本分类识别系统Python&#43;卷积神经网络算法&#43;TensorFlow&#43;Django网页界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 文本分类系统，使用Python作为主要开发语言，通过选取的中文文本数据集（“体育类”, “财经类”, “房产类”, “家居类”, “教育类”, “科技类”, “时尚类”, “时政类”, “游戏类”, “娱乐类”），基于TensorFlow搭建CNN卷积神经网络算法模型，并进行多轮迭代训练最后得到一个识别精度较高的模型文件。然后使用Django框架开发网页端可视化界面平台。实现用户输入一段文本识别其所属的种类。
二、效果图片展示 三、演示视频 and 代码 and 安装 地址：https://www.yuque.com/ziwu/yygu3z/dm2c902i8cckeayy
四、卷积神经网络介绍 CNN（卷积神经网络）原本主要用于图像处理领域，但它也被成功应用于文本分类识别。在这个领域，CNN能够有效识别文本中的局部特征，例如词组或短语，并通过学习这些特征来进行文本分类。
在文本处理中，通常首先将文本转换为向量形式，比如使用词嵌入（word embeddings）如Word2Vec或GloVe。这些向量化的文本数据之后会作为CNN的输入。CNN通过其卷积层可以捕捉到文本中的局部相关性，例如词与词之间的关联。经过多个卷积和池化（pooling）层后，网络能够从文本中提取有用的特征，并通过全连接层进行分类。
下面是一个使用TensorFlow和Python的简短示例代码，展示了如何构建一个用于文本分类的简单CNN模型：
import tensorflow as tf from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Embedding, Conv1D, GlobalMaxPooling1D, Dense # 假设词汇表大小为10000，嵌入维度为128，分类数量为5 vocab_size = 10000 embedding_dim = 128 num_classes = 5 model = Sequential() model.add(Embedding(vocab_size, embedding_dim, input_length=500)) model.add(Conv1D(128, 5, activation='relu')) model.add(GlobalMaxPooling1D()) model.add(Dense(num_classes, activation='softmax')) model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy']) # 打印模型概览 model.summary() 这个例子中，我们首先定义了一个顺序模型（Sequential）。模型的第一层是Embedding层，用于将词汇索引映射到其嵌入向量。接下来是一个卷积层（Conv1D），用于提取文本特征。然后是一个全局最大池化层（GlobalMaxPooling1D），用于减少参数数量并防止过拟合。最后是一个全连接层（Dense），用于分类。
这段代码提供了构建文本分类CNN模型的基础框架，可以根据具体的应用场景进行调整和优化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b9f94ee12830023d589c640248d1684/" rel="bookmark">
			Android studio（hedgedog版本）开发（二）—— SDK的配置问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍
之前进行了对Android Studio的基本介绍，这篇文章给各位分享一些我在SDK配置上的经验。
二、SDK的配置
很多博主的安装教程中都有告诉各位在一开始选择custom安装进行SDK的配置，这是个很好的习惯，尤其是不要让他默认安装在你的C盘里，一个版本的包就几个G，堪称C盘爆破手。接下来我会为各位详细地说明SDK的配置方法。
首先，我们要进行SDK的配置，应该关注以下两个地方的设置：
1. Settings--搜索SDK（搜不出来重进setting窗口）
可以看到这里有三个SDK管理设置，我们主要关注的是SDK Platforms和SDK Tools两个。
（1）SDK platforms
即本地所安装的SDK本体版本，选择你想要安装SDK到的位置和下面想要安装的版本，AD会自动检测该路径下已有的文化你，然后把你选择的文件中没有的全部安装在里面。一般来说Android Studio的SDK下载不存在网络问题，不用挂梯子，请耐心等待。如果出现了下载失败，请检查是否预留了足够空间以及本身网络是否正常。也就是说如果你想把SDK从C盘移到其他地方，找到这里你的SDK路径，进去全部删了，然后换路径再安装即可。但是注意不要新建一个项目就进来点一次OK，因为你新建项目时很可能给你创建一个新文件夹在这，因为他觉得你之前设置的文件路径他看不爽。确认你的SDK版本都安装好了，不用每次再去重复下载。
这里多讲几句关于这个版本的问题，主要是厘清几个sdk版本之间的关系：
CompileSdkVersion 确定了当 Gradle 构建你的应用时所用的 Android API 版本，此时你的应用能够使用此版本以及较低版本的 API 功能。换句话讲，如果你在开发应用的过程中需要使用一些较新的 API 功能，那么你应该确保你的 compileSdkVersion 数值不低于这些 API 的级别。
TargetSdkVersion 按照字面意思理解就是目标 SdkVersion。如果没有设置，则默认值为minSdkVersion。TargetSdkVersion 是 Android 系统实现「前向兼容」的主要手段，当你设置了targetSdkVersion的时候，表示你已经充分测试过了你的App在该目标版本的运行情况（准确的说应该是从 minSdkVersion 到 targetSdkVersion 区间所有的系统版本），除非更新 targetSdkVersion，否则不改变应用的行为。也就是说
minSdkVersion(lowest possible) &lt;= targetSdkVersion &lt;= compileSdkVersion(latest SDK)
（这一小段是这位博主的内容，我觉得讲的很清楚详解 MinSdkVersion、CompileSdkVersion、TargetSdkVersion 三者的区别、作用与关系（超详细图文教程）-CSDN博客）
默认的项目模板是将这两个版本设置为最高版本（目前是API34，对应Android14.0），这确实是在开发一个新应用的要求，但是就目前而言我觉得新版本还是有不稳定的地方，也没有手机目前升级到了14.0。但是将compilesdk设成最高版本一般而言问题不大，因为编译API是向下兼容的。
如果你在开发应用时遇到了一些运行不稳定或者是无法运行的问题（特别是引入外部工程时），那么请考虑降低你的SDK版本。
（2）SDK Tools
下图即为SDK Tools的设置
请确保你安装了图上的包，其中Emulator和Google USB Driver是分别是虚拟机的仿真器和真机的调试驱动。如果你需要用命令行调用这些tools，请确保你添加了相应的环境变量。
2. Project Strcture-- SDK location
请确保你的路径是你之前下载SDK的路径。如果需要使用NDK，也是在这里配置。
三、一些常见问题
一般单独对于SDK的配置来讲不会出什么问题，所以这里重点讲一下JDK的一些问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b9f94ee12830023d589c640248d1684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b4e971a1879a35acc09bac56c071b9/" rel="bookmark">
			ST-Link调试器：功能、用途和引脚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ST-Link调试器：功能、用途和引脚 介绍 在嵌入式系统开发中，调试器是一种至关重要的工具，它允许开发人员调试和编程微控制器，以确保系统正常运行并解决潜在的问题。ST-Link是STMicroelectronics公司推出的一款强大的调试器，本文将介绍ST-Link的功能、用途以及其关键引脚的作用。
ST-Link简介 ST-Link是STMicroelectronics公司专为其STM32系列微控制器开发的调试和编程工具。它可以作为一个集成在开发板上的调试/编程器，也可以作为一个单独的模块使用。ST-Link的主要功能包括调试、编程以及复位。
ST-Link的功能 调试功能：ST-Link通过SWD（Serial Wire Debug）或JTAG（Joint Test Action Group）接口与目标微控制器通信，允许开发人员在目标设备上执行程序、观察变量和寄存器的值，并进行单步执行等操作，以便进行程序调试。
编程功能：ST-Link可以将编译好的程序下载到目标STM32微控制器的闪存中，实现对微控制器的固件更新或更改。
复位功能：ST-Link提供了对目标微控制器的复位功能，方便重新启动目标设备。
ST-Link的引脚 ST-Link的引脚通常包括以下几个关键引脚（这里以国内盗版）
SWDIO（Serial Wire Debug I/O）：用于调试和编程的数据线，用于与目标微控制器通信。
SWCLK（Serial Wire Clock）：调试时钟线，用于同步调试数据的传输。
RST（Reset）：复位线，用于向目标微控制器发送复位信号。
3.3V和GND：供电引脚，用于为ST-Link模块提供电源。
SWIM（Serial Wire Interface Mode）：用于STM8微控制器的调试接口
基本引脚连接： ST-Link V2的3.3V和GND引脚 分别连接到STM32的相应3.3V和GND引脚，以提供电源。
ST-Link V2的SWDIO引脚 连接到STM32的SWDIO引脚。
ST-Link V2的SWCLK引脚 连接到STM32的SWCLK引脚。
确保连接时极性正确，并遵循STM32芯片的引脚定义。连接完成后，你就可以使用ST-Link V2通过调试软件（如ST-Link Utility）进行调试、编程和复位STM32微控制器了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f9f6f8e1272ca0d66ecb40ad537b428/" rel="bookmark">
			k8s中netty服务器容器tcp连接数量优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		netty的http1服务器在运行一段时间后会无法提供服务，返回客户端socket hang up
使用apipost测试抓包显示三次握手后被reset，经查是连接数过多
ps：客户端使用了大量短连接，如果能改成长连接就会消耗更少的连接，但是客户端逻辑无法掌控，只能修改服务器。
另外能保证客户端完成四次挥手也可以避免，但同样客户端逻辑无法掌控。
修改连接数限制 限制取决于代码中option(ChannelOption.SO_BACKLOG) 和/proc/sys/net/core/somaxconn的最小值。
登录容器，cat /proc/sys/net/core/somaxconn显示128，对于一个服务器来说，这个限制太小了，可以放大。
但是k8s把容器的参数分类了，大部分的参数都属于unsafe，不能直接修改。
第一步：修改kubelet启动参数 kubelet启动增加参数：kubelet --allowed-unsafe-sysctls ‘net.core.somaxconn’
kubelet可能是通过配置文件启动的，比如/etc/systemd/system/kubelet.service.d/10-kubeadm.conf
修改后重启kubelet：systemctl restart kubelet
确认是否生效：
第二步：修改netty的yaml 在Deployment中spec-template-spec-containers下增加securityContext：
securityContext: sysctls: - name: net.core.somaxconn value: "1024" 启动pod后查看somaxconn：
根据连接状态优化 根据连接状态，如果是TIME_WAIT则修改TIME_WAIT等待时间（（主动关闭的一方是TIME_WAIT，被动关闭一方是CLOSE_WAIT），如果是ESTABLISHED且大部分是闲置不用的连接则增加闲置关闭逻辑。
cat /proc/net/tcp查看到tcp连接数非常多，连接状态01表示已连接，0A表示监听中，6表示TIME_WAIT
tcp状态值说明：
TCP_ESTABLISHED:1 TCP_SYN_SENT:2 TCP_SYN_RECV:3 TCP_FIN_WAIT1:4 TCP_FIN_WAIT2:5 TCP_TIME_WAIT:6 TCP_CLOSE:7 TCP_CLOSE_WAIT:8 TCP_LAST_ACL:9 TCP_LISTEN:10 TCP_CLOSING:11 修改 TIME_WAIT 连接数量 需要修改关闭连接的等待时间，这也是k8s的unsafe参数
步骤一 修改kubelet配置，增加： --allowed-unsafe-sysctls net.core.somaxconn,net.ipv4.* 步骤二 修改deployment： securityContext: sysctls: - name: net.core.somaxconn value: "1024" - name: net.ipv4.tcp_fin_timeout value: "30" 增加TCP空闲关闭逻辑 HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f9f6f8e1272ca0d66ecb40ad537b428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81ad732fb01c01a841120cd9a460b74/" rel="bookmark">
			vue3用reactive定义的对象直接赋值{}没用的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在项目开发时，有很多弹窗里面放的表单，如下图这个新增数据的弹窗，在每次打开弹窗时需要给表单定义的数据置空，否则你第二次打开弹窗的时候，表单还显示着上一个新增的数据。
vue3在定义响应式数据时我们一般用的是reactive：
let addAssetForm = reactive({ name: "", ip: "", mac: "", }); 需要在打开弹窗是将上面那个对象置空，但是vue2一般直接={}就可以，vue3的话这样不行，所以需要用到object.assign,如下：
const keys = Object.keys(addAssetForm); let obj = {}; keys.forEach((item) =&gt; { obj[item] = ""; }); Object.assign(addAssetForm, obj); 这样就可以将addAssetForm对象置空
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e88d2c0db4b8a78ae550de611061b0/" rel="bookmark">
			Android studio（hedgedog版本）开发（一）—— Android tudio基本介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 Android studio的更新换代很快，而且每一次调整的幅度很大，很多小白（比如我）在上手时参照以前的教程和博客去操作往往晕头转向。经过一段时间的安卓开发的上手，想跟各位分享一下我在Android开发中基础配置问题上的一些经验。
作为第一篇文章，简单跟各位介绍一下Android studio吧。Android studio的前身是大家耳熟能详的Eclipse Android Development Tools (ADT)，然而，Google在2013年的Google I/O开发者大会上推出了Android Studio，这个基于IntelliJ IDEA的新开发环境很快就被接受和欢迎，因为它具有许多针对Android开发优化的功能和提升工作效率的工具。从那时起，Android Studio就成为了Android开发的官方IDE。
Android Studio的下载可参考CSDN上其他博主的文章。
二、基本概念 那么接下来介绍一下小白在刚上手时需要厘清的一些概念，其中有部分我的做工程的师兄也没有完全搞清楚，但我认为把Android studio的整体架构组成搞清楚还是很有必要的。
1. SDK, NDK, 和JDK 先看看chat给的大致定义吧：
NDK 对于NDK，简单来讲，如果你需要使用的一个硬件库是用C/C++写的，而你需要在安卓程序中调用这个硬件的控制函数，那么这时候你就需要通过NDK在Android studio中做交叉编译了。同时像chat说的，当你的app需要实现某些特殊功能的时候，你可能会需要C/C++。顺便提一嘴，对于python的交叉编译，Android studio也有一个插件库叫做chaquopy，有需要的可以去搜一下，官网上有详细的配置过程。对于NDK,这位博主的文章有详细的配置过程：Android Studio 进行NDK开发，实现JNI，以及编写C++与Java交互（Java调用本地函数）并编译出本地so动态库_android studio jni-CSDN博客
SDK和JDK 对于 Android Studio中的SDK，它和你在其他地方看到的SDK含义完全相同。如果你对SDK了解甚少，我有一个不是很恰当但是形象的理解：SDK是一种“操作系统”，它提供了控制底层元件活动的一套软件包，和Windows，linux一样，它们虽然各有不同，但都是依据电脑底层的硬件芯片的结构设计的，目的是要让用户控制芯片给其指令来控制其他硬件从而实现功能。Android Studio这里的sdk其实就是提供构建安卓应用架构的方式，而你使用的代码就是API，用于给出你的指令，表达你希望程序干什么。需要注意的是安卓系统自身的sdk其实和这里开发时的sdk是同一个sdk，这也是我为什么强调他是一种操作系统。
那么由于Android Studio最初的底层sdk库是用Java写的，你所使用的语言也是java/kotlin，故而需要一个JDK编译工具来编译你的项目。Kotlin语言是Jetbrain公司（是的，就是那个做IDEA和Pycharm的公司）为了弥补Java语言自身的缺点而开发的语言，是Java的延申，所以JDK当然也兼容Kotlin。Google也注意到了Kotlin的优势，于是在2017年将kotlin作为Android Studio的首推语言，当然时至今日Java依旧占大头，但是两者其实很相似。很多初学者在使用较新版本的Android Studio设置模板的语言时会发现没有这个选项，那是因为选择了新推出的混合编译模板，默认使用两种语言，所以记得选择基础空白模板，第二个会为你设置一个默认视图界面，请自己选择：
（新版本里面连个注释都没，确实令人迷惑）
说回两种语言，由于Kotlin语言的介入，即使你选择了Java模板中的gradle配置文件也是用kotlin生成的：（因为官方推荐的是Kotlin DSL,你也可以自己在新建时改成Groovy DSL)
但是就如我之前说的，Java短时间内不可能被完全取代。
2. Gradle Android Studio开发的核心，用于将你的安卓工程构建并打包成能在手机上运行的apk。刚刚说的SDK，NDK，JDK的设置都必须和gradle的设置相配合，当你的gradle能够正确地管理你的项目中使用的各种开发包，配置需要的依赖时，你的项目才能运行。其实对于刚上手Android Studio的开发者来说，gradle的配置简直是恶梦，特别是当你没有基础但是想通过Android Studio运行一个样例应用时，gradle版本和配置的不统一会让人束手无策。但是gradle相对复杂的配置方式同时也确保了应用运行的稳定性。Gradle本身就是一个构建工具，在Android Studio中使用的是 gradle plugin，请注意区分gradle版本和Android Studio的gradle插件版本。在每一次更改gradle文件后请记得同步（sync）：
3. 工程的基本框架 没有安卓开发经历的开发者可以先试着打开一个模板的工程，看看他的框架结构。
首先，作为一个需要开发视图和用户交互的安卓工程，各种配置界面和app的前端文件是少不了的。Android Studio里用的是XML文件，我们需要重点关注的.xml文件主要有以下两个：
（1）AndroidManifest.xml
它是整个应用程序的"章程"，描述了应用程序的基本特性和相关组件。这里也可以说是对后续代码和组件的一个配置，如目标系统的sdk版本，应用的权限设置（如能否联网），应用本身特性的设置（图标，标签，主题等等），以及各种activity的类别和彼此之间的关系（如mainactivity）
（2）activity_main.xml
位于layout文件夹下的文件，设置的界面的布局样式以及按钮和输出，后续的代码如果需要改变布局均需要从这里调用相应对象。
其他的xml配置文件还有很多，但是作为初学者可以不用急于搞清楚里面的所有内容。
说完前端的配置文件，让我们来看看代码主体。app\src\main\java，这个路径下的代码文件是我们需要重点编辑的地方，你可以看到一个默认生成的mainactivity文件，这是生成模板中默认的一个主活动，可以看到之前在manifest里是默认设置其为主活动的，也即启动后运行的活动。
这个mainactivity可以根据你的需要选择其继承的父类，比如默认是继承于AppCompatActivity这个类的，目的是为了兼容老版本安卓系统的一些配置，一些具体的Java特性这里不过多阐述。 写完你的主体代码后，别忘了进行gradle的配置，如果你使用的是官方支持的第三方库，请按照官网的说明进行配置。那么我们需要重点关注的gradle配置文件有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e88d2c0db4b8a78ae550de611061b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab2236d8d865b64d385ba60bff2f1f2/" rel="bookmark">
			泰克Tektronix DPO4054示波器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		美国DPO4054泰克数字荧光示波器
美国泰克TektronixDPO4054数字荧光示波器主要产品特色： 1.Wave Inspector智能存储管理
2.串行触发和分析
3.10.4”更大的显示器, 前面板上USB和CompactFlash端口, 及TekVPI™改善的探头接口, 更强的操作渐变性
美国泰克TektronixDPO4054数字荧光示波器主要特点：
1. 500 MHz带宽
2. 4通道
3. 2.5GS/s的取样速率
4. 所有通道上10 M样点的记录长度
5. Wave Inspector控制功能，提供了前所未有的波形分析效率
6. I2C, SPI, CAN串行触发和分析
7. 10.4英寸(264毫米) XGA彩色显示器
8. 前面板上USB和CompactFlash，快捷简便地存储数据
9. TekVPI™探头接口支持有源探头、差分探头和电流探头，自动定标和确定单位
10. 体积小，重量轻 – 仅厚5.4 英寸(137毫米)，仅重11磅(5公斤)
美国泰克TektronixDPO4054数字荧光示波器产品技术数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e707801040e5f3e845c84833e462d42d/" rel="bookmark">
			泰克Tektronix DPO3052示波器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DPO3000系列混合信号示波器拥有高达500 MHz的带宽和2.5 GS/s的采样率，为当前许多主流应用提供了所需的性能。由于多达20条通道，您可以使用一台仪器，同时分析模拟信号和数字信号。
主要特点和优点
主要性能指标
500, 300, 100 MHz 带宽型号
2 通道和4 通道型号
16 条数字通道（MSO 系列）
所有通道上2.5 GS/s 的采样率
所有通道上5 M 点的记录长度
&gt;50,000 wfm/s 的zui大波形捕获速率
成套高级触发
简便易用功能
Wave Inspector® 控制功能，轻松导航和自动搜索波形数据
29 种自动测量FFT 分析，简化波形分析
TekVPI® 探头接口支持有源探头、差分探头和电流探头，自动定标和确定单位
9 英寸（229 mm） WVGA 宽屏彩色显示器
体积小，重量轻- 仅厚5.8 英寸（147mm），仅重9 磅（4 公斤）
连接能力
前面板和后面板上的USB 2.0主机端口，迅速简便地存储数据、进行打印及连接USB 键盘
后面板上的USB 2.0 设备端口，简便地连接PC 或直接打印兼容PictBridge® 的打印机
集成10/100 以太网端口，用于联网和视频输出端口，把示波器显示画面导出到监视器或投影仪上
选配串行触发和分析功能
I2C、SPI、CAN、LIN、RS-232/422/485/UART和I2S/LJ/RJ/TDM 自动串行触发、解码和搜索选项
混合信号设计和分析（MSO 系列）
并行自动触发、解码和搜索功能
多通道建立时间和保持时间触发
MagniVuTM高速采集技术，在数字通道上提供了121.2 ps的精细定时分辨率
选配应用支持
电源分析
HDTV 和自定义视频分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e707801040e5f3e845c84833e462d42d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6d9cd85711569d1a5280419020d9d2/" rel="bookmark">
			uniapp微信小程序-秋云u-charts层级过高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、先说问题 想在这个每个圆环上面定位一些百分比或者定位一些东西,微信小程序端可以，真机调试不行，打算提高层级不行
二、解决 点击底下开启2d就可以， 也就是在你的图表上加上
:canvas2d="true" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc1198f6a84dfa2392d11aa25d98756/" rel="bookmark">
			Spring @Async 原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring @Async 原理 @EnableAsyncAsyncConfigurationSelectorProxyAsyncConfigurationAbstractAsyncConfigurationAsyncConfigurerAsyncAnnotationBeanPostProcessorAsyncAnnotationAdvisorAnnotationAsyncExecutionInterceptorAsyncUncaughtExceptionHandler @EnableAsync 开启异步功能需要 @EnableAsync 注解，可以以此作为切入点。
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented // 导入了 AsyncConfigurationSelector，很重要 @Import(AsyncConfigurationSelector.class) public @interface EnableAsync { // 可以自定义异步的注解来代替 @Async，一般不会使用 Class&lt;? extends Annotation&gt; annotation() default Annotation.class; // 是否使用 CGLIB 代理，这个配置会影响所有使用代理的地方，不止是 @Async boolean proxyTargetClass() default false; // 代理的 advice 是使用 JDK 还是使用 ASPECTJ，一般不修改 AdviceMode mode() default AdviceMode.PROXY; /** * Indicate the order in which the {@link AsyncAnnotationBeanPostProcessor} * should be applied. * &lt;p&gt;The default is {@link Ordered#LOWEST_PRECEDENCE} in order to run * after all other post-processors, so that it can add an advisor to * existing proxies rather than double-proxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc1198f6a84dfa2392d11aa25d98756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf78828beeefc957f607ca3c8e2b1b44/" rel="bookmark">
			LSTM的多变量时间序列预测（北京PM2.5预测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客
文章目录 LSTM简介数据集简介数据预处理多元LSTM预测模型数据准备：定义和拟合模型评估模型 训练多个滞后时间步 LSTM简介 LSTM（Long Short-Term Memory）是一种特殊类型的循环神经网络（RNN），它在处理序列数据和时间序列数据时表现出色。
相比于传统的RNN，LSTM引入了记忆单元（memory cell）和门控机制（gate mechanism），以解决传统RNN中的梯度消失和梯度爆炸问题，从而更好地捕捉长期依赖关系。
LSTM的核心组件是记忆单元，它可以存储和访问信息，并通过门控机制来控制信息的流动。LSTM中的三种门控单元是：
输入门（Input Gate）：控制是否将新输入信息添加到记忆单元中。 遗忘门（Forget Gate）：控制记忆单元中的哪些信息需要被遗忘。 输出门（Output Gate）：控制从记忆单元中读取哪些信息并输出。 这些门通过使用sigmoid激活函数来产生0到1之间的输出，表示信息的通过程度。
LSTM在训练过程中可以学习到如何选择存储和遗忘信息，从而对输入序列建模并捕捉到长期依赖关系。除了标准的LSTM，还有一些变种模型，如双向LSTM（Bidirectional LSTM）、多层LSTM（Multi-layer LSTM）和注意力机制LSTM（LSTM with Attention），它们进一步扩展了LSTM的能力和灵活性。 数据集简介 北京PM2.5数据集
下载数据集并将其放在当前工作目录中，文件名为 “ raw.csv ”。
这是一个报告了中国北京美国大使馆五年每个小时的天气和污染程度的数据集。
No：行号year：这一行中的数据年份month：此行中的数据月份day：这一行中的数据日hour：此行中的小时数据pm2.5：PM2.5浓度DEWP：露点TEMP：温度PRES：压力cbwd：综合风向Iws：累计风速Is：累积下了几个小时的雪Ir：累积下了几个小时的雨
我们可以使用这些数据，并构建一个预测问题，在前一时刻的天气条件和污染情况下，我们预测下一个时刻的污染情况。 数据预处理 原始数据：
对原始数据处理：
from pandas import read_csv from datetime import datetime # 加载数据 def parse(x): return datetime.strptime(x,'%Y %m %d %H') dataset=read_csv('data/raw.csv',parse_dates=[['year','month','day','hour']],index_col=0,date_parser=parse) dataset.drop('No',axis=1,inplace=True) # 手动更改列名 dataset.columns=['pollution','dew','temp','press','wnd_dir','wnd_spd','snow','rain'] dataset.index.name='data' # 把所有NA值用0替换 dataset['pollution'].fillna(0,inplace=True) dataset=dataset[24:] # 输出前五行 print(dataset.head(5)) # 保存到文件中 dataset.to_csv('pollution.csv') 对以上代码进行解释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf78828beeefc957f607ca3c8e2b1b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc782f6fb94223b3e77cba41fa70ac79/" rel="bookmark">
			【零基础C语言】C语言的概念初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言的常识 C语言是什么？ 首先我们从字面意思来理解，语言是一种人与人之间交流的工具。如：汉语，英语等等。如果你想让别人听懂理解你所想表达的意思，那么正确的语言是必不可少的，举个例子，和中国人我们要说汉语，和美国人我们要说英语，那么我们想要与机器对话自然也需要一种语言，那么C语言就可以充当这个交流的工具,而我们称这种工具叫做计算机语言。当然C语言只是众多语言中的一种，C++/Java/Go/Python等等也是属于计算机语言的。 C语言的历史发展 编译器的介绍 何为编译器 首先我们要知道计算机的底层逻辑是二进制运算，也就是0和1，而我们编写的代码形式大多如下,看起来是一堆英文和数字的结合，虽然在编写时这可以有效的使人理解，但是计算机是不懂的，就好像一个外国语专家和一个没学过英语的人交谈一样，所以我们需要一个“翻译家”，恰恰编译器就是充当这个角色的。 #include &lt;stdio.h&gt; int main() { return 0; } C语言源代码我们称之为源文件，后缀是.c 而要运行的必须是可执行文件，后缀是.exe 通过编译器的编译和链接两步骤我们的源文件就可以变成可执行文件。简单来说编译器可以将我们编写的代码通过编译和链接两个过程来实现我们代码的运行。 编译器推荐 新手推荐vs编译器 第一个C语言程序 main函数 在写c语言之前我们要先了解一个主要的函数-main函数 main函数是一个程序项目的入口main函数有且只能有一个 格式应当是：
int main() printf函数 printf函数是一个输出型函数，使用该函数需要在头文件包括: #include &lt;stdio.h&gt; 程序Hello World ！ 程序的整体书写如下：
#include &lt;stdio.h&gt; int main() { printf("Hello World !"); return 0; } 注意：
在输入代码时要保证是英文输入法 main函数不可以写成mianprintf函数后面要有“ ；”分号 关键字的介绍 常见的关键字：
关键字是有特殊意义的，它不可以创造你在创建标识符时不可以与关键字重名 字符和Ascll码表 字符 我们在键盘上敲出的‘a’,‘@’,‘p’这些都称之为字符 ，字符在C语言中要使用英文输入的单引号括起来，前面讲过我们计算机底层是以二进制进行存储，那么字符如何表示存储呢，由此为了管理和表达美国国家标准学会（ANSI）出台了⼀个标准 ASCII 编码，C语⾔中的字符就遵循了 ASCII 编码的⽅式。
打印字符 #include &lt;stdio.h&gt; int main() { printf("%c",'q'); return 0; } Ascll码表 字符串 故名思意就是一串字符的意思，字符串需要用“”双引号来括起来，如“abcdefghijk”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc782f6fb94223b3e77cba41fa70ac79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e551fa178e0f4ed02998059ff2f6d2e/" rel="bookmark">
			flask web 学习之用户认证与会话管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装及初始化二、设置用户加载回调函数三、定义User类四、实现登陆操作五、自定义登陆过程六、使用请求加载器自定义登录七、匿名用户功能八、记住我功能 Flask-Login是一个用于处理用户认证和会话管理的Flask插件。它简化了在Flask应用程序中实现用户登录、登出以及保护视图等功能的过程。
一、安装及初始化 flask-login官方文档
pip install flask-login 在flask中进行配置：
from flask import Flask from flask_login import LoginManager app = Flask(__name__) login_manager = LoginManager() # 初始化LoginManager对象 login_manager.init_app(app) 完成初始化之后，就可以在应用中使用login_manager对象来处理用户认证和会话管理等功能。例如设置用户加载回调函数
保护视图函数等。
二、设置用户加载回调函数 此回调用于从会话中存储的用户ID重新加载用户对象。它应该获取用户的ID，并返回相应的用户对象。例如：
@login_manager.user_loader def load_user(user_id): # 根据用户 ID 查询用户对象 user = User.query.get(int(user_id)) return user 三、定义User类 定义 User 类：创建一个 User 类，表示应用程序中的用户，该类需要实现以下几个方法：
is_authenticated()：返回 True 如果用户已经通过认证，否则返回 False。is_active()：返回 True 如果用户是活跃的，否则返回 False。如果用户被禁用，可以返回 False。is_anonymous()：返回 True 如果当前用户是匿名用户，否则返回 False。get_id()：返回一个唯一标识符的字符串，用于标识用户。 class User: def __init__(self, user_id, username, password): self.id = user_id self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e551fa178e0f4ed02998059ff2f6d2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9525ad221319163d7b8a5f8a81fc71f/" rel="bookmark">
			一文带你梳理Python的中级知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、文件操作二、正则表达式三、异常处理四、面向对象编程（Object-Oriented Programming）五、Python高级特性1 生成器（Generator） 2 装饰器（Decorator）总结Python技术资源分享1、Python所有方向的学习路线2、学习软件3、入门学习视频4、实战案例5、清华编程大佬出品《漫画看学Python》6、Python副业兼职与全职路线 前言 Python是一种高级编程语言，它在众多编程语言中，拥有极高的人气和使用率。本文主要带大家梳理一下Python中常用的中级知识，希望对大家有所帮助
一、文件操作 Python中的文件操作通常使用内置的open()函数来打开文件。以下是一个简单的示例：
with open("file.txt", "r") as f: content = f.read() print(content) 在这个示例中，我们打开了名为"file.txt"的文件，并将其读入变量content中，最后将其打印出来。
open()函数的第一个参数是文件名，第二个参数是打开文件的模式。以下是一些常用的模式：
“r”：只读模式“w”：写入模式（会覆盖已有文件）“a”：追加模式（不会覆盖已有文件） 二、正则表达式 正则表达式是一种强大的工具，可以帮助我们从文本中提取信息或进行文本替换。Python中可以使用内置的re模块来进行正则表达式操作。以下是一个示例：
import re text = "The quick brown fox jumps over the lazy dog." pattern = r"fox" matches = re.findall(pattern, text) print(matches) 在这个示例中，我们定义了一个正则表达式模式r"fox"，然后使用re.findall()函数来查找匹配该模式的所有字符串。最后，我们将匹配的结果打印出来。
三、异常处理 在编写程序时，经常需要处理可能出现的错误或异常情况。Python中可以使用try和except语句来实现异常处理。以下是一个简单的示例：
try: x = 1 / 0 except ZeroDivisionError: print("Error: division by zero") 在这个示例中，我们尝试计算1除以0，这将引发一个ZeroDivisionError异常。我们使用try和except语句来捕获该异常并打印出一条错误消息。
四、面向对象编程（Object-Oriented Programming） 面向对象编程是一种重要的编程范式，Python是一种面向对象的语言。以下是一个简单的示例：
class Person: def __init__(self, name, age): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9525ad221319163d7b8a5f8a81fc71f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/30/">«</a>
	<span class="pagination__item pagination__item--current">31/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/32/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>