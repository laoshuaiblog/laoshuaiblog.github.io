<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d2b9bb40c5b1f34e636fbfa1792e33/" rel="bookmark">
			全面盘点17个C&#43;&#43;17的高级特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全面盘点17个C++17的高级特性 C++17是目前比较常用的版本之一，今天花时间来梳理一下17个重要特性，所有的特性也不止这么点。
目录
1. 并行算法
2. If Initializers
3. 类模板参数推导（CTAD）
4. template `&lt;auto&gt;`
5. std::optional 和 std::variant
6. 折叠表达式
7. 结构化绑定
8.模板模板参数
9. 内联变量
10. 属性改进
11. 嵌套命名空间
12. 字面量改进
13. constexpr lambda
14. 捕获*this
15. 扩展的if和switch语句
16. 泛化的基于范围的for循环
17. if constexpr
总结
1. 并行算法 C++17引入了许多并行版本的标准库中的算法。这些算法可以并行执行，因此在多核系统上可能会带来显著的性能提升。
之前写过一篇全面介绍这个特性的文章，可以看这篇：未来已来：C++17 并行STL性能测评
例子：
#include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;execution&gt; int main() { std::vector&lt;int&gt; v = {1, 2, 3, 4, 5}; std::sort(std::execution::par, v.begin(), v.end()); } 在此例子中，std::sort是并行执行的，以并行方式对向量v的元素进行排序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d2b9bb40c5b1f34e636fbfa1792e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08956cd553a8030d929c1dd5fc65552/" rel="bookmark">
			uniapp微信小程序_购物车_下单页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说下整体逻辑以方便总体理解
1、首先画出下单页面
2、此次画出结算价格页面
3、怎么点击下完单变成结算页面？其实就是把下单页面的信息传递给结算页面就行
问题难点？
点击加号的时候把物品加入一个数组传到下单页面，但是点击的时候不能把所有物品加上，需要把重复的物品转换成数量
点击减号为0的时候需要减去商品，使用过滤api过滤掉次数为0的就相当于删除次数为0的商品
最后将物品总价使用computed一算就可以
一、解决购物车加购的时候重复问题 mergeDuplicateItems(cartItems) { // 创建一个空对象来存储合并后的商品 const mergedItems = {}; // 遍历购物车中的每个商品 cartItems.forEach(item =&gt; { // 使用商品名称作为键来查找是否存在该商品 const existingItem = mergedItems[item.name]; if (existingItem) { // 把这边的点击次数传出去 existingItem.content = item.content; } else { // 如果商品不存在，则将其添加到合并后的对象中 mergedItems[item.name] = { ...item }; } }); // 将合并后的对象转换回数组 // 把汉字就去掉了 const mergedCartItems = Object.values(mergedItems); return mergedCartItems; }, 以上把加购重复的商品加购进去
mergedItems[item.name] = { ...item }; 这个解释一下
mergedCartItems是这个但是得转换一下 { exampleName1: { name: 'exampleName1', value: 'value1' }, exampleName2: { name: 'exampleName2', value: 'value2' }, exampleName3: { name: 'exampleName3', value: 'value3' } } Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08956cd553a8030d929c1dd5fc65552/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a257f01163c5f93b1aef0680e0da29ea/" rel="bookmark">
			真心建议大家搞个香港身份，再不冲就晚了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		香港一直有“互联网荒漠”之称，疫情这三年，香港开始大力扶持互联网 科技工程 /IT产业，公布了《香港智慧城市蓝图》。目前规划已经覆盖到交通、医疗、经济、教育、环境等多个方面。
目前在智能制造，5G网络、智慧城市等领域人才，通过香港优才计划入境都极具优势。
什么是香港优才计划 优才计划，全称优秀人才入境计划，香港政府于2006年2月公布，是一项设有配额的移民吸纳计划，旨在吸引高技术人才和行业优秀人才来港定居，藉以提升香港的竞争力。
汤唯代言香港优才计划
而就在前段时间，香港入境处批准了史无前例的707名申请者获得名额。并且配额也在逐年不断翻倍，从最初的每年1000个名额增至2022年的4000个。但面对大量的申请人，4000个配额仍然是杯水车薪。然而就在2022年10月19日香港特首最新的《施政报告》中提出，取消优才计划配额，进入两年“无限”申请时代！
也就是说，只要你符合优才计划申请资格，是香港想要的优秀人才，都有更大的机会通过优才计划获得香港身份！可见，香港优才申请的窗口期已经到来，为期两年，港府招揽内地人才的坚定决心不言而喻，现在正是抓住香港身份的红利期！
申请方式及资格评测 80分及以上可联系申请香港身份：
香港优才计划优势 一、采用计分制，同拿内地户口+香港身份
香港优才计划采用计分制，根据申请人的年龄、学历、工作经验等综合计分，最高245分，80分可申请；
香港看重人才、培养人才，一人申请，配偶及未成年子女可同步拿香港身份，享受香港福利；
通过香港优才拿香港身份并不是意味着放弃内地户口，香港由于其制度优势，可同时拥有内地户口+香港居民两种身份，尽享两地工作生活、商机、教育、机遇等资源。
二、事业发展空间广阔，拒绝内卷
香港不仅在金融领域处于全球领先，其科研影响力也处于全球第一梯队，一个城市就有5所大学排名进入全球前100，拥有16个国家重点实验室和6个国家工程技术研究中心。
香港薪资水平高，据港府统计处公布的数据，2022年第二季度的工资中位数为20000港元，薪酬福利放眼全球仍具有很强竞争优势。其中科技、金融、医疗、环保、贸易等行业发达，不止薪酬福利有前景，同时推动着个人发展。
三、子女享国家化教育，升学途径多样
拥有香港身份，孩子不仅可以享受香港优质的国际化教育资源，还可以获得多样化的升学途径，为子女留下一个内地、香港、出国都能便利升学的路。
申请方式及资格评测 80分及以上可联系申请香港身份：
香港身份优势 ★教育优势
在香港，不管是永久居民还是非永久性居民，均可享有同等的教育权利。
香港实行15年免费教育，它的国际化教育、两文三语、灵活的小班教学、雄厚的师资力量等等特色，是吸引内地家长送孩子来香港读书的重要原因。
而且，现在针对港宝无法回香港读书的情况，在内地就读，港府也有学券补贴（相当学费免费）。
来源：香港教育局
另外，除了选择香港公立学校，也可以选择私立和国际学校。
★升学优势（无需参加高考）
▶参加“DSE考试”（简称：香港高考）低分就读内地大学
拥有香港永居身份，凭DSE成绩，通过“免试招生计划”直接升读内地132所高校（含清华北大复旦上交等名校）。
图源：广东教育考试院
而且DSE成绩还被海外多所大学认可，可凭DSE成绩直接申请海外大学。
▶参加“华侨生联考”：除此之外，香港永居学生还可以通过“华侨生联考”，报读内地高校。华侨生总分750分（考试内容与内地考生相似），录取分数线：一本400分，二本300分，艺考生200分。
通过香港DSE考试和华侨生联考，很多原本考不上大学的孩子，都圆了名校梦。
申请方式及资格评测 80分及以上可联系申请香港身份：
★买房优势
▶内地买房：香港居民可以在大湾区9市自由购买一套自用房，且无需内地工作、学习时间证明等限购条件。
以深圳为例，非深户的建设者需要交够5年的社保才可买一套房，香港居民则无需缴纳社保，即可在深圳购置房屋。
★香港高薪工作
大家都知道香港工资高，但想要去香港打工，是有条件的，拿到香港身份就可以。
根据香港政府公布2021年最新港人收入及工时统计调查结果，发现2021年5月至6月香港雇员每月工资中位数为18,700元。
这还只是公共职业，如果你是金融行业，技术行业，医生，律师，那么薪资就更高了。
数据来源：港府统计处
想要香港身份？
长按二维码识别添加老师微信
离香港身份更近一步！
👇👇
★护照免签171个国家和地区
香港特区护照可以免签171个国家和地区，还能在第三国中转，而且申请移居国外的排期更短，条件更宽松。
★税收优势
有了香港身份，在香港创业就业：
▶进口商品关税：一般商品进口至香港并不需要缴纳进口关税（特殊商品除外）
▶公司营业税：香港对企业主要是征收利得税和物业税。世界银行分析，内地企业综合税率为67.3%，而香港只有22.9%
▶个人税：香港政府规定，薪俸税率最高为15%，而且，每年每人居然有13.2W港元的免税额，这就使得全港有一半以上的在职人士无须交薪俸税，另外20%的人全年交税也不到1000元。
★更好的营商环境
香港开放自由的营商环境下，注册香港公司可享受少税种，低税率，更易打造企业国际品牌效应，开拓国际市场，增强竞争优势，且无外汇管制。
★超强的医疗
香港患乳腺癌的患者存活率是89.8%，为全世界第二。
香港治愈胃癌率是世界第一，比西方国家高13%。
香港治愈肺癌率是世界第一，高于美国6%。
香港治愈肝癌率是世界第二，仅次于美国。
香港治愈直肠癌率是世界第二，比欧洲更高。
★粤港澳大湾区机遇/优势
首先对在粤港澳大湾区工作的境外高端人才和紧缺人才，其在珠三角九市缴纳的个人所得税已缴税额超过其按应纳税所得额的15%计算的税额部分，由珠三角九市人民政府给予财政补贴。
图源：广东省财政厅
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a257f01163c5f93b1aef0680e0da29ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c639b61693fe25f0a78b24eac9a680/" rel="bookmark">
			AI绘画自动生成器有哪些?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI绘画自动生成器是一种利用人工智能技术实现自动绘画的系统。通过学习大量的绘画作品和艺术规律，AI绘画生成器能够生成具有艺术性和创造性的绘画作品。下面将介绍几种常见的AI绘画自动生成器。
DeepArt.io DeepArt.io是一种基于神经网络的AI绘画生成器。用户可以上传一张图片并选择一个艺术风格，DeepArt.io会通过神经网络将原始图片转化为该艺术风格的绘画作品。DeepArt.io的神经网络模型参考了大量的艺术作品，能够生成具有艺术性和创造性的绘画作品。
Prisma Prisma是一款移动应用程序，也是一种AI绘画生成器。用户可以通过Prisma将手机拍摄的照片转化为不同的艺术风格的绘画作品。Prisma使用了深度学习技术，能够在短时间内将照片转化为艺术画作，并且可以调整画作的风格和效果。
AICAN AICAN是由新加坡南洋理工大学开发的一种AI绘画生成器。AICAN是一个基于深度学习的系统，它通过学习大量艺术作品的视觉和感知规律，能够生成全新的艺术作品。AICAN的独特之处在于它不仅能够模仿现有的艺术风格，还可以创造出全新的艺术风格。
DALL·E DALL·E是由OpenAI开发的一种AI绘画生成器。DALL·E使用了强化学习和生成对抗网络等技术，可以根据用户的文字描述生成相应的绘画作品。用户可以输入一句话描述，DALL·E会根据描述生成对应的绘画作品。DALL·E的独特之处在于它能够理解自然语言描述并将其转化为绘画作品。
Gatys等人的神经风格迁移算法 神经风格迁移算法是一种通过神经网络将一张图片的风格应用到另一张图片上的技术。该算法由Leon A. Gatys等人提出，它通过将一张风格图片与一张内容图片输入神经网络，通过网络的优化过程实现将风格应用到内容图片上。神经风格迁移算法可以生成具有艺术性的绘画作品。
以上是几种常见的AI绘画自动生成器，它们利用人工智能的技术实现自动绘画，并且能够生成具有艺术性和创造性的绘画作品。随着人工智能技术的不断发展，相信AI绘画自动生成器将会有更多的创新和突破。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa4f09511451d6a9ed275c63d215f6b/" rel="bookmark">
			【GHG Protocol】对于温室气体清单核算模型的进一步思考（2024-01-05））
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 主要的内容 Improvements to the location-based method,Improvements to the market-based method, as well asElevation of the role of and improvements to reporting emission impacts from projects and interventions. 对基于位置的会计的改进包括要求提高该方法的准确性、特异性和可访问性。提案作者强调，需要在各组织之间建立可比较的第2类排放清单，并与作为共享资源分布在电网上的电力的不可区分性相一致。呼吁改进基于市场的会计方法的提案作者引用了与基于位置的会计方法类似的改进(准确性、专用性、可及性)，以及一系列研究，这些研究关注的是如何通过使用能源属性证书来改善所声称的范围2库存减少，从而更紧密地反映现实世界的温室气体减排。最后，一些提案作者指出，基于项目或干预的间接温室气体核算是捕捉电力相关项目全系统影响的重要工具。除了对技术指南进行更新外，这些作者还指出，需要更加强调在目标或目标设定计划中报告基于项目的评估，并制定强制性排放披露法规。在努力达成与《温室气体议定书》决策标准一致的基于共识的结果的过程中，《温室气体议定书》秘书处将通过审查这些改进的技术基础并评估其应用和纳入温室气体排放报告的情况，开始正式的利益攸关方磋商进程。
一、通过增加范围2数据和质量标准要求的时间和位置粒度，改进基于位置和市场的方法
描述
•要求使用与能源消耗发生时间更紧密匹配的电网排放因子，以确定两种方法与电力消耗相关的排放。使用小时匹配，而不是匹配按年为基础，目前是需要的。
•在确定与两种方法的电力消耗相关的排放时，要求使用与能源消耗发生地点更紧密匹配的电网排放因子。使用有可能实际输送到报告公司用电地点的发电排放因子。
•在基于市场的方法中，大多数提案都要求每小时匹配和可交付的市场边界，以获得任何能源属性证书(例如，rec, go等)。提案的子集更直接地只关注可交付的市场边界。
•在以市场为基础的方法中，许多人还建议，在确定与电力消耗相关的排放时，还需要一个具有细粒度地理边界的小时剩余混合。
•一些建议建议，在无法获得每小时数据的过渡阶段，报告组织可以根据其建筑物或设施类型，按月或按年使用能耗负荷概况。
•这些改进的支持者都认为，这些对现有范围2方法的更新将更好地将与电网发电和输电相关的排放与与组织电力消耗相关的排放声明相一致。
•支持者还强调，与目前的要求相比，增加时间和地点要求的粒度可以更好地激励负载管理和采购策略，从而支持电力系统的脱碳。
•在基于市场的方法中，一些建议还包括对资源资格的限制(例如，只有新资源或报告组织可以声称帮助造成存在的资源才符合条件)。这些拟议的资格标准源于几项同行评议的研究结果得出结论，它们对保证使用范围2的基于市场的方法断言的任何减排有效促进全系统的脱碳。
•在基于市场的方法中，其他建议列出了所有生成资源类型，包括现有的和新的，应符合市场方法权利要求的启用条件将发电量完全分配给电力消费者。
二、通过对基于市场的第2范围权利要求要求附加性来改进基于市场的方法
•要求报告机构与该报告机构计算的排放率之间存在某种因果关系，以便对与电力消耗相关的排放提出基于市场的方法索赔。
•提案作者提出了各种可能构成附加性的方法，包括将来源限制为在提出索赔之前不存在的来源，限制某些类型的来源，如未捆绑的电力产品，或者以其他方式证明与报告组织的范围2市场方法索赔更紧密相关的减排。
•更好地确保范围2的基于市场的方法库存所声称的减少反映了电网的实际脱碳。
•减少企业库存中被认为是“漂绿”的情况。
三、通过小的更新改进范围2的定位和基于市场的方法
描述:
•维持历史范围2的会计方法，只做小的更新，为用户增加清晰度和特异性。
•提案作者引用了两种方法的更具体的市场边界要求，并在基于市场的方法中为全球市场的证书跟踪系统提供了更新的指导，增加了基于市场的质量标准层次，以反映最近的市场发展，在选择基于市场的方法声明的排放因子方面更加明确，并对现有的范围2指南语言进行了其他调整。
基本原理
•保持历史会计方法，使其与现有惯例、合同安排、目标和目标保持连续性。小的更新可以提高可行性，并允许进一步采用强制性报告。
•通过利用现有的第二类基于市场的方法，鼓励广泛参与电网脱碳行动。
四、提高项目会计的作用，以报告由组织的干预措施引起的排放变化
•使用边际排放因子报告能源生产中估计的避免或诱导排放，使用边际或电网平均排放因子报告能源消耗排放，并将两者计算相加以报告单个值。
•将最佳的实时、时间和地点颗粒排放因子应用于所有量化方法的发电和消费数据。
•避免排放索赔可以来自位于报告组织用电的当地电网区域或市场内部或外部的项目(例如，位于世界一个区域的公司可以在另一个区域投资清洁能源，并说明该项目的避免排放效益)。
•方法与基于项目或干预的会计方法有许多相似之处，用于量化相对于反事实的避免或诱导排放。
•这些建议的支持者对该方法是否应该尝试将项目会计原则(例如，结果性方法)与库存会计方法(例如，归因方法)相结合，或者在基于库存的范围2总数之外报告，他们的偏好各不相同。
•建立一个排放报告框架，激励企业将目标定位在脱碳影响最大的地区，而不考虑其运营消耗电力的电网或市场边界。在全球范围内实现减排要求，同时避免对市场边界限制和当地电网消耗的限制。
•在赞成混合方法的提案倡导者中，理由包括必须在企业标准范围2清单报告中采用这种方法，以得到认可，并纳入目标和目标设定计划以及强制性气候披露规则。
关于存货和项目会计的说明在提交的范围2提案中，有一些建议来自存货/归因会计和项目/干预/结果会计方法。作者对这些工具的作用有不同的看法，一些人呼吁两种方法分别使用和报告，另一些人则呼吁开发一种新的混合治疗方法，寻求结合方法并报告单一指标。《温室气体议定书》《企业会计和报告标准》和《项目核算温室气体议定书》提供了两种核算排放和排放影响的方法。分别，实体层面的温室气体清单核算描述了如何量化和分配一个组织的大气排放份额，其中包括范围2中的当前位置和基于市场的方法，而基于项目的温室气体核算描述了如何评估一个项目或行动相对于没有项目或行动的反事实基线情景的排放影响。在《企业准则和范围2指南》中，基于项目的会计核算目前被列入存货之外的额外披露。有关这些方法的背景及其预期用途的进一步信息，请参阅本备忘录。
针对特定行业指导的各种不同提案要求对各种技术和用例**(例如，如何计算与储能资源相关的第2类排放、用于生产能源的氢的具体排放、数据中心的能源使用、废物焚烧排放与能源回收的分配等)进行额外的澄清或核算方法。**对于一些特定部门的指导建议，在制定具体建议的更多细节之前，可能需要进一步明确如何处理上述不同的关键改进。详细阅读请参阅范围2调查摘要中的F和H部分。
范围2调查摘要(完成于2023年11月)和范围2提案摘要(即本文件)的发布标志着更新《温室气体议定书》范围2报告要求过程的初始反馈审查阶段的结束。在2021年底至2023年底期间，超过400份调查提交，70份提案提交以及与1000多名利益相关者进行的对话显示出对基于位置，市场和项目的会计的强烈兴趣，并揭示了上述改进的几个关键建议。尽管这些建议的改进在技术细节上有所不同，但许多作者在他们的建议中提出了上述改进的各种组合。总的来说，这些建议强调了四种可能的报告结构组合:•按照现有的范围2指南的要求，报告基于地点和基于市场的范围2总数，•报告单一的基于市场的范围2总数，•报告基于地点的总数和基于项目的总数(使用相应的会计工具)，或者
•
报告基于位置、基于市场和基于项目的总数(使用相应的会计工具)。
涉及的网站：
https://ghgprotocol.org/survey-need-ghg-protocol-corporate-standards-and-guidance-updates
https://forms.office.com/pages/responsepage.aspx?id=QWZDCkI3h0aBBzpgyB4TF9dzplMoHuVLuhMdeKagbldUN05VMEVUNFRTSVYzQVRZNlVXOUhaSE5OOS4u
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/370d16cbf4a194cb1f4d5bfc86c39b4a/" rel="bookmark">
			指令的装载和运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 指令的工作原理指令装入的三种方式绝对装入（不重要）可重定位装入（不重要）动态运行时装入（重要） 从写程序到程序运行段寄存器段寄存器结构：逻辑地址线性地址 链接的三种方式静态链接装入时动态链接运行时动态链接 指令的工作原理 注：指令和数据的地址是分开的；
内存并不是单独给某个程序使用的。对于多任务架构计算机，一个内存往往装载了多个程序的可执行二进制文件。程序装载的内存基地址也并不都从内存0地址开始。
指令装入的三种方式 绝对装入（不重要） 绝对装入只适用于单进程环境。在编译或汇编时（装载前），产生绝对地址的目标代码。程序中使用绝对地址。
可重定位装入（不重要） 动态运行时装入（重要） 动态重定位
可执行文件装入内存后，依然使用逻辑地址。需要一个重定位寄存器的支持。~这个重定位寄存器后来演进为段寄存器。
从写程序到程序运行 编译阶段：使用逻辑地址，每个目标模块地址都是从0开始。分为代码段、数据段。
链接阶段：统一修改了地址。代码段归档、数据段归档、BSS段归档。
加载后：根据链接后的地址+重定位寄存器=最终的物理地址。
代码段和数据段 有各自的重定位寄存器，即段寄存器。
段寄存器 段寄存器有ES、CS、SS、DS、FS、GS、LDTR、TR共8个。
ES：扩展段。在串操作时(比如cmovs)目标操作数的基址是ES，源操作数是DS。
CS：代码段，配合EIP使用。
SS: 堆栈段，凡是基址是EBP或ESP的，段前缀就是SS。
DS：数据段，默认的都是DS。
FS、GS：80386 之后定义的。
段寄存器结构： 只有段选择符对程序员是可见的。
qemu monitor中info registers可以看到段寄存器：
从左到右依次是： sc-&gt;selector, sc-&gt;base, sc-&gt;limit, sc-&gt;flags &amp; 0x00ffff00 ES =0000 0000000000000000 ffffffff 00c00000 CS =0010 0000000000000000 ffffffff 00a09b00 DPL=0 CS64 [-RA] SS =0018 0000000000000000 ffffffff 00c09300 DPL=0 DS [-WA] DS =0000 0000000000000000 ffffffff 00c00000 FS =0000 0000000000000000 ffffffff 00c00000 GS =0000 ffff8b053bc00000 ffffffff 00c00000 LDT=0000 0000000000000000 ffffffff 00c00000 TR =0040 fffffe12484d7000 00004087 00008b00 DPL=0 TSS64-busy 逻辑地址 在 Linux 操作系统中，用户态的虚拟地址通常指的是线性地址。在 Linux 中，逻辑地址通常指的是由段选择符和段内偏移量组成的地址，这种地址表示方式主要用于 x86 架构的机器。而线性地址是指一种平坦的统一地址空间，它不涉及任何段的概念。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/370d16cbf4a194cb1f4d5bfc86c39b4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d41e0abd971959e0f377b4e67f34cb/" rel="bookmark">
			Amazon SageMaker &#43; Stable Diffusion 搭建文本生成图像模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果我们的计算机视觉系统要真正理解视觉世界，它们不仅必须能够识别图像，而且必须能够生成图像。文本到图像的 AI 模型仅根据简单的文字输入就可以生成图像。
近两年，以ChatGPT为代表的AIGC技术崭露头角，逐渐从学术研究的象牙塔迈向工业应用的广阔天地。随着下游行业对快速处理柔性商业业务的需求日益增长，如何提供一个便捷、高效且完整的企业级人工智能解决方案成为了业界亟待解决的问题。幸运的是，亚马逊云服务推出了Amazon SageMaker平台，为企业提供了一站式的人工智能解决方案，满足了市场的迫切需求。
本篇文章将采用Amazon SageMaker+Stable Diffusion实现文本生成图像Demo！
一、Amazon SageMaker简介 Amazon SageMaker是一款亚马逊云服务旗下的全面托管机器学习平台。该平台集成了众多高效工具和服务，使得构建、训练和部署机器学习模型变得前所未有的简单。Amazon SageMaker拥有灵活的计算资源及配置选项，无论项目规模大小，它都能以强大的计算能力，助力训练大型模型。此外，它还提供了强大的管理和监控功能，确保机器学习工作流程的顺畅运行。
Amazon SageMaker机器学习平台提供了一系列能够快速构建、训练和部署机器学习模型的工具和服务，使机器学习工作流程更加高效、易用和可扩展。现在进入
亚马逊云科技: https://mic.anruicloud.com/url/1037
可以免费试用！
​
二、Amazon SageMaker + Stable Diffusion实践 2.1、创建Amazon SageMaker实例 首先打开亚马逊云控制台，在查找服务处搜索关键词SageMaker，进入Amazon SageMaker环境：
​
随后，在界面左侧定位至“笔记本”选项并点击。接着，依次选择“笔记本实例”和“创建笔记本实例”，进入配置页面。在此页面中，需注意选择适合的“笔记本实例类型”申请资源的类型，这里建议选择加速型g4dn.xlarge实例，确保高效的计算性能。
​
在操作系统方面，推荐选择Amazon Linux 2，并搭配Jupyter Lab 3这一交互式编程环境。“卷大小”可根据个人需求进行选择，建议至少设置为20GB，最后点击确定。
2.2、简单测试（可选） 创建实例成功后，可以新建一个初始notebook，复制并粘贴以下代码片段到笔记本的单元格，安装所需依赖
pip install --upgrade -q aiobotocore pip install -q xgboost==1.3.1 然后复制并粘贴以下代码片段，点击run运行：
import pandas as pd import boto3 import sagemaker import json import joblib import xgboost as xgb from sklearn.metrics import roc_auc_score # Set SageMaker and S3 client variables sess = sagemaker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34d41e0abd971959e0f377b4e67f34cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/624d2a2fc27a918e38518979e929ab26/" rel="bookmark">
			若依微服务跑起来-微服务小白入门（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 若依的基本框架系列，已经构建起来，请参照 小白入门系列 - 鸡毛掸子
这些东西理解，并且实际板砖以后，有必要对现在流行的一些概念做一些升级，现在我们就进入到所谓的cloud版本，其实，前面的概念如果比较清晰，这里就是概念多一些，很多都是人家造好的轮子，直接怼就行。
关键是理解人家的思想和这些场景何时会用到，用到的时候深入也不晚，看一张让人晕的图，这个里面的模块一个个理顺了，这个系列就基本目标达到了。
技术梗概 与若依单体版的相对比，多了要给很重要的主框架
Spring Cloud Hoxton.SR9 这个框架有个初步认识
SpringCloud框架 1、介绍
Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发， 如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。 Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来， 通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。
2、优点
把模块拆分，使用接口通信，降低模块之间的耦合度。
把项目拆分成若干个子项目，不同的团队负责不同的子项目。
增加功能时只需要再增加一个子项目，调用其他系统的接口就可以。
可以灵活的进行分布式部署。
环境部署 前置配置 JDK &gt;= 1.8 (推荐1.8版本) Mysql &gt;= 5.7.0 (推荐5.7版本) 5.6试验没问题 Redis &gt;= 3.0 必须安装 Maven &gt;= 3.0 Node &gt;= 12 nacos &gt;= 2.0.4 (ruoyi-cloud &lt; 3.0 需要下载nacos &gt;= 1.4.x版本) sentinel &gt;= 1.6.0 需要启动redis，nocos配置容易出问题；
下载ruoyi的源码
1、前往Gitee下载页面(https://gitee.com/y_project/RuoYi-Cloud(opens new window))下载解压到工作目录
2、idea 打开pom
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/624d2a2fc27a918e38518979e929ab26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6254de9cd6dafaf3acd169e682b9dee/" rel="bookmark">
			凯特信安云签解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		联合解决方案 凯特信安基于《电子签名法》设计“云签服务方案”，应用人脸识别、电子签章签名云服务等技术，支持多个自然人、多个企业等签名，满足各种移动终端签署的应用场景。面向不动产登记、工改系统等社会公众服务系统，针对自然人和企业等公众用户。实现多场景合同签约，满足各种移动终端应用场景；支持区块链存证、司法举证等法律服务，实现司法闭环。
实现“一趟不用跑”、“跨省通办”，提升涉企涉民办事便利度和获得感，促进营商环境的不断优化。该解决方案采用SinoDB数据库作为底层基础数据库软件，在整体架构中SinoDB数据库数据极高的安全性机制，具有多种安全体系认证。数据库通过访问控制的特性，确保只有经过授权的用户可以访问敏感的签署数据。这有助于维护签署数据的安全性和隐私性。针对一些签署的敏感数据进行数据加密的处理，以此来保护数据的机密性。除此之外还提供了完善的安全审计跟踪，数据库记录每个文档的签署历史和相关事件，以提供完整的审计跟踪。这有助于验证文档的完整性和签署过程的合规性。
方案价值 该方案中的基础数据库软件是一款拥有自主知识产权的国产数据库产品，其内置的访问控制能力可以过滤非授权用户的登录查看；数据加密能力可以保证在数据传输或储存时相关的敏感数据不会被非法获取；数据库审计能力可以确保数据库记录每个文档的签署历史和相关事件以便回溯。简化不动产登记、房屋交易等服务流程，优化政务审批流程，实现“零见面审批”，提升涉企涉民办事便利度和获得感，促进营商环境的不断优化。
更多信息内容请移步星瑞格官方社区，期待大家加入
Sinoregal Tech ForumAsk questions, share solutions, and get to know the Sinoregal community.https://forum.sinoregal.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768453184470f1cd7a215c6518b0d2c0/" rel="bookmark">
			Android Studio实现内容丰富的安卓校园助手班级成绩天气管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取源码请点击文章末尾QQ名片联系，源码不免费，尊重创作，尊重劳动
1.开发环境 android stuido3.6
jak1.8
eclipse
mysql
tomcat
2.功能介绍 安卓端：
1.注册登录
2.校园公告
3.课程列表
4.成绩列表，天气列表
5.个人中心
6.留言中心
1.公告管理
2.用户管理
3.课程管理
4.班级管理
5.成绩管理
6.天气管理
7.系统管理
3.系统截图 1.服务端功能，管理员登陆
2.安卓端功能截图，包括注册，登录，底部导航栏。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a0d9645498ee8edc19231cce71e882/" rel="bookmark">
			【Spring Cloud】微服务通信概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SueWakeup 个人主页：SueWakeup
系列专栏：学习技术栈
个性签名：人生乏味啊，我欲令之光怪陆离
本文封面由 凯楠📷 友情赞助播出 目录 前言
1. Dubbo（Spring Cloud Alibaba）和 Spring Cloud 的适用场景
2. Dubbo（Spring Cloud Alibaba）实现 RPC 调用
3. Dubbo（Spring Cloud Alibaba）和传统 Dubbo 的区别
4. 处理服务之间同步和异步通信（Spring Cloud Alibaba）
5. 实现服务间的安全通信
前言 什么是微服务通信？
微服务通信指的是在微服务架构中，应用程序被拆分成多个小型的、独立部署的服务单元，微服务通信通过网络协议帮助不同的微服务之间进行数据传输、调用对方的功能，实现系统的整体业务逻辑。
1. Dubbo（Spring Cloud Alibaba）和 Spring Cloud 的适用场景 场景DubboSpring Cloud通信协议主要适用 RPC 协议，适合内部高效的服务间同步调用倾向于 RESTful HTTP 协议，适用于跨网络的异构系统集成性能和延迟 在性能和延迟方面表现更优
适合对性能要求较高的内部服务通信
在通用性和易用性方面更强生态和集成 专注于服务调用和性能优化
提供更全面的微服务解决方案
如配置管理、服务发现等
社区和支持适用于对性能有特殊要求的场景社区更活跃，与各种云平台的集成更深入 2. Dubbo（Spring Cloud Alibaba）实现 RPC 调用 依赖配置：在项目中引入 Dubbo 和 Spring Cloud Alibaba 相关依赖服务提供者配置：在服务提供者端配置 Dubbo 的服务暴露相关参数，如接口、版本等服务消费者配置：在服务消费者端配置 Dubbo 的服务引用相关参数，如接口、版本等注册中心配置：配置适用 Nacos 、ZooKeeper 等作为 Dubbo 的注册中心服务调用：通过 Duubo 提供的代理机制实现远程服务的透明调用 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31a0d9645498ee8edc19231cce71e882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c3a77003c27c0f5307c04dc2984de6/" rel="bookmark">
			Python断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python断言 1 什么是Python断言2 使用场景3 常用断言函数 1 什么是Python断言 断言就是断定指定条件一定成立，若不成立则抛出异常。Python断言关键字为：assert，断言也可以理解为简单版的 if 语句，判断条件的值，若为True继续运行，否则停止运行并抛出AssertionError异常。语法格式如下：
assert 条件表达式
if 语句格式如下：
if not 条件表达式:
… raise AssertionError
2 使用场景 断言是为了让开发者知道程序发生异常了，主要应用于程序的调试和自检，不是为了处理错误，程序的bug还是要靠 try… except 解决。
以下示例，call_some函数中获得的列表元素个数必须是100个，否则程序就有问题，这种情况下就可以使用断言：
def some(): my_list = [] ... ... return my_list def call_some(): """调用 some 函数""" res = some() # 列表个数必须为100个 assert len(res) == 100 pass 3 常用断言函数 assertEqual(a,b,msg=msg)：判断两个值是否相等assertNotEqual(a,b,msg=msg)：判断两个值是否不相等assertTrue(a,msg=none)：判断变量是否为 TrueassertFalse(a,msg=none)：判断变量是否为 FalseassertIsNone(obj=‘’)：判断 obj 是否为空assertIsNotNone(obj=‘’)：判断 obj 是否不为空assertIn(item, list)：判断item是否在list中assertNotIn(item, list)：判断item是否不在list中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a868c436226938fd0a64dfefc9aae83/" rel="bookmark">
			收集一些PostgreSQL的题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 详述PostgreSQL的MVCC（多版本并发控制）机制是如何工作的，并解释它如何帮助处理并发事务？2. 在PostgreSQL中，一个查询是如何从用户输入转化为实际的数据返回的？请描述一下查询执行的生命周期。3. 解释PostgreSQL中的Write-Ahead Logging (WAL) 机制。它是如何帮助保证数据的持久性和恢复的？4. 在PostgreSQL中，索引是如何工作的？请解释B-Tree, Hash, GiST, SP-GiST, GIN和BRIN索引的工作原理和适用场景。5. 描述一下PostgreSQL中的VACUUM操作，为什么它是必要的，以及它是如何工作的？6. 在PostgreSQL中，如何使用EXPLAIN命令来优化查询性能？7. 如何在PostgreSQL中实现分布式事务？可以使用哪些工具或技术？8. 描述PostgreSQL的流复制，它的工作原理是什么？如何设置和管理流复制？9. 在PostgreSQL中，如何设置和管理高可用性和故障转移？10. 在PostgreSQL中，如何进行备份和恢复？请解释物理备份和逻辑备份的区别，以及点时间恢复（PITR）的工作原理。11. PostgreSQL如何支持JSON数据？你可以使用哪些函数和操作来处理JSON数据？12. 描述PostgreSQL中的并行查询，它的工作原理是什么？在什么情况下，PostgreSQL会选择使用并行查询？13. **解释PostgreSQL中的TOAST (The Oversized-Attribute Storage Technique) 技术。它是如何帮助存储大型数据的？15. 如果你需要在PostgreSQL中实现全文搜索，你会如何做？16. 解释PostgreSQL中的事务隔离级别，以及它们如何帮助处理并发事务中的问题？ 1. 详述PostgreSQL的MVCC（多版本并发控制）机制是如何工作的，并解释它如何帮助处理并发事务？ PostgreSQL中的每个事务都有一个唯一的事务ID。当行被修改时，PostgreSQL不会直接覆盖旧的行，而是创建一个新的版本，并标记它是由哪个事务创建的。旧的版本被保留，以便那些开始于新版本创建之前的事务能够看到。这就是MVCC的基本思想。MVCC可以提供非阻塞的读操作，因为读操作总是可以看到一个一致的快照，而不需要等待其他事务。
2. 在PostgreSQL中，一个查询是如何从用户输入转化为实际的数据返回的？请描述一下查询执行的生命周期。 查询的生命周期主要包括以下步骤：解析、重写、优化和执行。在解析阶段，查询被转换为一个抽象语法树（AST）。在重写阶段，查询重写规则（如视图和规则）被应用。在优化阶段，查询优化器生成一个最佳的执行计划。在执行阶段，执行引擎按照执行计划执行查询，并返回结果。
3. 解释PostgreSQL中的Write-Ahead Logging (WAL) 机制。它是如何帮助保证数据的持久性和恢复的？ WAL是一种日志技术，所有的修改操作在被应用到数据文件之前，都会先被写入到WAL。这样在系统崩溃时，可以通过回放WAL来恢复数据库到一个一致的状态。WAL还可以被用于主从复制，从服务器可以通过读取和应用主服务器的WAL来达到和主服务器相同的数据库状态。
4. 在PostgreSQL中，索引是如何工作的？请解释B-Tree, Hash, GiST, SP-GiST, GIN和BRIN索引的工作原理和适用场景。 索引是一种数据结构，用于快速查找特定条件的行。B-Tree索引是最常见的索引类型，适用于所有可以排序的数据类型。Hash索引只支持等值查询。GiST（Generalized Search Tree）索引是一种可扩展的索引类型，支持多种复杂的查询，如范围查询、多维查询等。SP-GiST（Space-Partitioned GiST）索引适用于数据可以被划分为不重叠的部分的情况。GIN（Generalized Inverted Index）索引适用于包含多个组成部分的数据，如数组和全文搜索。BRIN（Block Range INdex）索引适用于数据具有自然排序的情况，它按照数据的物理位置进行索引。
5. 描述一下PostgreSQL中的VACUUM操作，为什么它是必要的，以及它是如何工作的？ 在PostgreSQL中，由于MVCC的设计，旧的行版本在被新的行版本替换后不会立即被删除，而是被标记为可回收。VACUUM操作就是用来回收这些可回收的空间，以供将来使用。VACUUM还可以更新表的统计信息，以供查询优化器使用。VACUUM操作通过扫描表中的所有行，找出那些所有活动事务都不再需要的行，然后将它们标记为可回收。
6. 在PostgreSQL中，如何使用EXPLAIN命令来优化查询性能？ EXPLAIN命令可以显示查询的执行计划，包括每个操作的成本、行数和宽度的估计，以及实际的时间和行数（如果使用EXPLAIN ANALYZE）。通过分析执行计划，你可以找出查询的瓶颈，如全表扫描、嵌套循环连接等，然后通过添加索引、调整查询、改变配置参数等方式来优化查询。
7. 如何在PostgreSQL中实现分布式事务？可以使用哪些工具或技术？ PostgreSQL本身不支持分布式事务，但你可以使用第三方工具如Postgres-XL和Citus来实现。这些工具通过分片、复制和两阶段提交等技术，将一个大的数据库分布到多个节点上，每个节点运行一个PostgreSQL实例，然后协调这些节点来执行分布式事务。
8. 描述PostgreSQL的流复制，它的工作原理是什么？如何设置和管理流复制？ 流复制是一种复制方法，允许从服务器实时地接收和应用主服务器的WAL。这需要在主服务器上设置wal_level、max_wal_senders和wal_keep_segments等参数，然后在从服务器上设置standby_mode并指定主服务器的连接信息。流复制可以通过pg_basebackup命令来初始化，然后通过复制插槽（replication slot）来管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a868c436226938fd0a64dfefc9aae83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b69ddf3627577b0c23dc7e676378dc4/" rel="bookmark">
			Python文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python文件 1 文件与文件路径1.1 什么是文件和文件路径1.2 绝对路径1.3 相对路径 2 文件的基本操作2.1 路径检查方法2.2 目录操作方法2.3 信息获取方法 3 文件读写3.1 打开文件3.2 读取文件3.3 文件写入3.4 关闭文件3.5 示例3.6 with as 上下文语法 4 文件复制4.1 复制文件4.2 复制目录 5 文件移动5.1 移动文件5.2 移动目录5.3 重命名文件或目录 6 文件删除6.1 删除非空目录 7 文件压缩和解压缩7.1 文件压缩7.2 文件解压缩 8 编码知识 1 文件与文件路径 1.1 什么是文件和文件路径 文件就是一种存储在存储设备上的信息集合，文件路径就是文件在计算机上的存储位置，文件路径有绝对路径和相对路径。
1.2 绝对路径 就是绝对不变的路径，比如在目录 D:\user\001 下有一个文件 a.txt，那么‘D:\user\001’就是该文件的绝对路径，绝对路径也可以说是从根目录开始描述的路径。
1.3 相对路径 是相对与当前路径开始描述的路径，一个点 . 表示当前目录，两个点 … 表示上级目录。
2 文件的基本操作 在Python中对文件进行操作，主要使用两个模块，os模块和os.path模块。
2.1 路径检查方法 判断文件或路径是否存在 os.path.exists(path) # 若path文件或目录存在返回True，否则返回False
判断是否绝对路径 os.path.isabs(path) # 若path为绝对路径返回True，否则返回False
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b69ddf3627577b0c23dc7e676378dc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45609b664c5f792bf31e2945509873b/" rel="bookmark">
			dom元素&#43;CSS实现阶梯动画效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.效果 2.代码实现 &lt;template&gt; &lt;div class="container"&gt; &lt;div class="Box"&gt; &lt;div class="box" style="background-color: red;"&gt;&lt;/div&gt; &lt;div class="box" style="background-color: orange;"&gt;&lt;/div&gt; &lt;div class="box" style="background-color: yellow;"&gt;&lt;/div&gt; &lt;div class="box" style="background-color: green;"&gt;&lt;/div&gt; &lt;div class="box" style="background-color: skyblue;"&gt;&lt;/div&gt; &lt;div class="box" style="background-color: blue;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { mounted () { this.setActions() }, methods: { setActions () { //选中所有盒子 const arr = document.querySelectorAll('.box') //循环添加事件监听 arr.forEach(e =&gt; { e.addEventListener('mouseenter', () =&gt; { //通过添加类名实现盒子上移 e.classList.add('boxMoveTwoStep') //判断前后的兄弟节点是否存在 if (e.previousElementSibling) {//上一个节点 e.previousElementSibling.classList.add('boxMoveOneStep') } if (e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45609b664c5f792bf31e2945509873b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f4802ea9bfb7bf5e1d8c721b255e4c/" rel="bookmark">
			119.设计链表（力扣）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码解决 class MyLinkedList { public: // 定义链表节点结构体 struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; MyLinkedList() { dummyhead =new LinkedNode(0); size=0; } int get(int index) { if (index &gt; (size - 1) || index &lt; 0) { return -1; } LinkedNode*node=dummyhead-&gt;next; while(index){ node=node-&gt;next; index--; } return node-&gt;val; } void addAtHead(int val) { LinkedNode*node=new LinkedNode(val); node-&gt;next=dummyhead-&gt;next; dummyhead-&gt;next=node; size++; } void addAtTail(int val) { LinkedNode*node=new LinkedNode(val); LinkedNode*cur=dummyhead; while(cur-&gt;next!=nullptr){ cur=cur-&gt;next; } node-&gt;next=cur-&gt;next; cur-&gt;next=node; size++; } void addAtIndex(int index, int val) { if(index &gt; size) return; if(index &lt; 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = dummyhead; while(index){ cur=cur-&gt;next; index--; } newNode-&gt;next=cur-&gt;next; cur-&gt;next=newNode; size++; } void deleteAtIndex(int index) { if (index &gt;= size || index &lt; 0) { return; } LinkedNode* newNode = dummyhead; LinkedNode* cur = dummyhead; while(index){ cur=cur-&gt;next; index--; } LinkedNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; tmp=nullptr; size--; } private: int size; LinkedNode* dummyhead; }; /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */ 实现思路 当创建一个 MyLinkedList 对象时，它会初始化一个虚拟头节点 dummyhead，并将链表的大小 size 初始化为 0。链表的每个节点都包含一个整数值 val 和一个指向下一个节点的指针 next。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29f4802ea9bfb7bf5e1d8c721b255e4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1893206faa5ec69de179476a49cfe79d/" rel="bookmark">
			百度智能云&#43;SpringBoot=AI对话【人工智能】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度智能云+SpringBoot=AI对话【人工智能】 前言版权推荐百度智能云+SpringBoot=AI对话【人工智能】效果演示登录AI对话 项目结构后端开发pom和propertiessql_table和entitydao和mapperservice和implconfig和utilLoginController和ChatController 前端开发css和jslogin.html和chat.html 后言 最后 前言 2024-3-20 19:41:47
使用百度千帆平台的大模型，完成一个简单的AI对话聊天
以下内容源自《【人工智能】》
仅供学习交流使用
版权 禁止其他平台发布时删除以下此话
本文首次发布于CSDN平台
作者是CSDN@日星月云
博客主页是https://jsss-1.blog.csdn.net
禁止其他平台发布时删除以上此话
推荐 Gitee项目地址： 日星月云 / AI对话
GitHub项目地址：jsss-1/qianfan
百度千帆模型初次体验【人工智能】
百度智能云+SpringBoot=AI对话【人工智能】 通过上篇，我们成功地完成了初次对大模型的使用
本篇，我将带大家开发一个AI对话聊天框
效果演示 登录 输入用户名，点击登录
返回“登录成功”
查询状态
AI对话 页面
输入内容，点击回车即可提问
项目结构 后端开发 pom和properties pom.xml
SpringBoot2.4.2+JDK8
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;qianfan&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;qianfan&lt;/name&gt; &lt;description&gt;qianfan&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1893206faa5ec69de179476a49cfe79d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05340dbb2fae703c5bbfeb4a20c3b4f6/" rel="bookmark">
			[BT]BUUCTF刷题第2天（3.20）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第2天（共5题） Web [ACTF2020 新生赛]Exec Payload：target=127.0.0.1;cat /flag
分号;在许多shell中用作命令分隔符，意味着在执行完前一个命令（这里是设置target变量）后，接着执行cat /flag命令。
[GXYCTF2019]Ping Ping Ping Paayload：
http://4caf85f2-dc7a-47ae-a50f-683bb207ece6.node5.buuoj.cn:81?ip=1;cat$IFS$9`ls` 反引号的「优先级」很高，会先执行反引号中的命令，而后在将执行的「结果」结果配合其他命令执行，也就是说，执行的语句时下面这样：
?ip=1;cat flag.php index.php
根据提示，是要在url后面加上/?ip=参数值来进行解题，这道题类似上道题都是需要执行多个命令获取flag，但是多了过滤。
初始Payload：?ip=1;ls
发现能够返回目录下的文件：flag.php index.php
加上访问文件：?ip=1;cat flag.php
发现网站过滤空格
绕过空格的几种方式：
${IFS}$IFS$9 $9可改成其他数字&lt;&lt;&gt; 重定向符{cat,flag.php} 用逗号,实现了空格功能 本题中$IFS$9可行
绕过空格：?ip=1;cat$IFS$9flag.php
发现过滤flag字样
绕过flag的几种方式：
编码绕过关键词。变量拼接绕过关键词。（?ip=1;b=ag;cat$IFS$9fl$b.php）反引号执行绕过关键词 以上三种方式均可以显示文件内容
flag藏在注释
[强网杯 2019]随便注 Payload：
?inject=0';handler `1919810931114514` open;handler `1919810931114514` read first; -- a 使用0' or True -- a查询表中所有数据
0后面的`用于结束前面的SQL语句，True使查询语句为真，–是SQL里的注释，a为注释的一部分
源码过滤了select、update、delete、drop、insert、where等关键字，因此本题考点为堆叠注入（即通过分号将多条SQL语句一起执行）
初始Payload：
?inject=0';show tables; -- a 这里直接查询所有表，发现了1919810931114514和word表，由于select被过滤了，show命令又不能查看表中的数据，因此需要使用「handler 命令」来查看表中的数据
添加查询表中数据的Payload：
?inject=0';handler `1919810931114514` open;handler `1919810931114514` read first; -- a 注意表名用反引号括起
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05340dbb2fae703c5bbfeb4a20c3b4f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15bb27cf03312dc5eb631a4d221e2c51/" rel="bookmark">
			hive sql实现查找商品表名称中包含敏感词的商品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 用户上传的商品表一般会包含商品名称，由于这些商品名称是用户自己起的，里面可能包含了敏感词，需要通过sql找出来哪些商品的商品名称包含了敏感词汇
hive sql实现查找商品表名称中包含敏感词的商品 实现思路：
1.商品表和敏感词表进行join时的连接条件设置成name contains 敏感词的形式
2.一般来说join的on条件都只是需要有一个equal等值连接，所以我们每个表设置一个虚拟列，仅仅是为了满足join的on条件有一个等值操作
结果sql如下所示：
SELECT merchandise_const.mid, merchandise_const.name FROM ( SELECT mid, name, 'constant_value' AS constant_col FROM merchandise ) AS merchandise_const JOIN ( SELECT key, 'constant_value' AS constant_col FROM sensitive ) AS sensitive_const ON merchandise_const.constant_col = sensitive_const.constant_col AND merchandise_const.name LIKE CONCAT('%', sensitive_const.key, '%'); 这样就可以查找到商品名称中包含了敏感词的商品列表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a87e6484139be0b83b71cf45a1051b0/" rel="bookmark">
			java 数据结构 排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
排序
插入排序
直接插入排序
希尔排序( 缩小增量排序 )：
直接选择排序
堆排序
交换排序
冒泡排序
快速排序递归
Hoare法
挖坑法
前后指针法
快速排序优化
快速排序非递归
归并排序
归并排序非递归
排序算法复杂度及稳定性分析
计数排序
排序(Sort) 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来
的操作,所有的排序默认都是从小到大排序
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录
的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]
之前，则称这种排序算法是稳定的；否则称为不稳定的。
内部排序：例如定义了一个数组,在哪开辟的呢？当程序运行起来在内存上开辟的,在内存中存储
的，那我们叫内部排序
外部排序：例如你要排序的数据在磁盘上存储着，那叫外部排序,例如如果有10个G数据,你的运行
内存只有8个G,只能借助外部来进行排序
常见的排序算法
插入排序 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的
记录插入完为止，得到一个新的有序序列 实际中我们玩扑克牌时，就用了插入排序的思想
直接插入排序 思路：设置两个变量记录，设置一个temp变量存储i下标的元素，j从下标为i-1的开始，i从下标为1
的开始，i递增,j递减，每次temp跟j下标的进行比较,如果小于，j+1下标的位置放入temp，如果大于
就不变还是放在i下标的位置
代码实现：
//直接插入排序 //适用于:带排序已经基本趋于有序 //稳定性:稳定的,如果是本身就是稳定的排序,一定可以实现不稳定的排序 public static void insertSort(int[] array) { for (int i = 1; i &lt; array.length; i++) { int temp = array[i]; int j = i - 1; for (; j &gt;= 0; j--) { //这里加不加等号 和稳定有关系 if (temp &lt; array[j]) { array[j + 1] = array[j]; } else { //array[j + 1] = temp; break; } } array[j + 1] = temp; } } 疑问：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a87e6484139be0b83b71cf45a1051b0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/16/">«</a>
	<span class="pagination__item pagination__item--current">17/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/18/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>