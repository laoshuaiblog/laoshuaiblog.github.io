<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81862521a4a935bb8c5ce47ef6cb870c/" rel="bookmark">
			网页插入mp4_简单快速的视频上传分享网站，可做mp4外链，非常实用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站简介我们有时候需要分享一些视频，比如MP4后缀之类的，当然其实的方法是有很多的，比如上传到自己的服务器、OSS、COS之类的，但这样费用就非常大，不值得，要么就是上传到快手抖音，让别人搜，这样针对性不强，也是不够痛快，并且如果你想要插入其他地方外链也是不可以的。这次小编就给大家分享一些国外的视频存储网站，名字叫做streamja，streamja是一个专门提供视频存储的在线网站，你可以自由上传视频，并且可以生产视频地址，然后分享出去，还可以生成外链插入到其他地方，比如插入到网站播放，下面请看一些操作吧。 网站图片 我们打开streamja主页，可以看到一个上传按钮和提示，我们可以直接把想要上传的视频拖进网页，也可以点击Upload video上传，上传速度还是非常不错的。 比如我们上传一个小视频，上传完成的地址就是：https://streamja.com/rPy2，大家可以点开链接播放。当然也可以点击下面的播放按钮播放，这句是streamja的外链功能了，非常不错。 注册账号直接输入邮箱，输入密码，再次确认密码，然后点击SIGN UP即可注册完成，不需要验证邮箱，当然你也可以通过脸书和谷歌账号登录，特别说明的一点就是你不注册账号也是可以上传视频到streamja的。 传送地址 网站名称：streamja
网站地址：https://streamja.com/
点击右下角“阅读原文”获取更多干货！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71ea4693a077bf748b334ff3e80d1fc/" rel="bookmark">
			图片合并打印_Word操作技巧：简单3步，批量打印工作证就是这么容易
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前两天的文章中，我已经向大家展示了邮件合并的强大功能，轻松实现批量打印邀请函和工资条。
我相信大家只要稍作练习，就可以轻易掌握这些操作，成为高效办公的职场达人。
但是，前面的内容，我们都只是在用邮件合并处理文字内容，并没有涉及到图片的处理。
今天，我继续跟大家分享邮件合并功能的高级使用技巧，实现批量打印工作证，显著提高我们的工作效率！
只需要简单3个步骤：
1、准备数据和照片
2、设置工作证模板
3、细节调整
就可以解决批量打印工作证的问题。
步骤1：准备数据和照片 这是一份员工的信息表，里面列出了每个员工的部门和职务明细。
与一般的表格不同，我们还需要增加一列放置员工的照片，然后把员工照片导入到Excel中。
这是我们准备的员工照片，放置在同一个文件夹内。
我们根据员工的照片名称，对Excel表格中的员工照片这一列进行文字填充。
这样，工作证的数据和照片就准备完成了。
步骤2：设置工作证模板 (1)制作Word模板
工作证的尺寸一般为8.6 * 5.4CM，所以我们也用Word制作一个这样的页面。
新建一个Word文档，点击【布局】选项卡中的【纸张大小】，在打开的对话框中，调整纸张的宽度和高度。(如果提示页边距过大，就把页边距都调整为1cm)
(2)插入表格
在【插入】选项卡下，点击【表格】，插入一个3列5行的表格。
然后对表格进行一些处理，合并单元格，并输入一些员工信息，调整位置，方便我们后续制作工作证。
(3)插入合并域
跟我们之前的操作相同，点击【邮件】选项卡中的【选择收件人】，然后选择【使用现有列表】。
在打开的【选取数据源】对话框中，找到我们准备好的员工信息表，然后点击确定。
在表格中相应的空格处，插入合并域，但是左下方放图片的空格处先不处理，就可以得到下图所示的结果。
(4)插入图片
把鼠标放在图片的位置处，在【插入】选项卡中，找到【合并部件】，点击【域】。
在打开的对话框中，找到域名【IncludePicture】，因为我们是要插入多个图片文件，所以不能直接写入文件名。
在文件名处输入 “占位”，点击确定。
然后，调整图片大小到合适的位置，现在图片还不能够显示出来。
按住Alt + F9，然后把引号中的 “占位”删除，然后点击【插入合并域】中的【图片】，这样就把图片的路径插入到域代码当中了。
再按住Alt + F9，恢复正常状态，点击完成并合并，在【邮件】选项卡中点击【完成并合并】下的【编辑单个文档】，在打开的对话框中，勾选【全部】，点击确定。
这样就批量生成了每一个员工的工作证，但是员工的照片还不能正常显示。
按住F12，把这个文档另存到我们存放员工图片的文件夹内。
再按住Ctrl + A ，全部选中文件中的工作证，然后再按住F9键刷新文档，所有图片都可以正常显示了。
步骤3：细节调整 这个工作证现在看起来，还比较单调，我们可以为它添加一些背景。
在【插入】选项卡下，点击【图片】，选择我们已经准备好的图片，插入到文档中，然后调整布局格式为浮于文字下方，并调整图片的大小。
然后，再对文档进行一些细节处理。
再重新进行一遍文档合并操作即可。
总结： 1、准备数据和照片：数据表需要添加照片列，名称与照片一模一样，表格要和照片放在用一个文件夹
2、设置工作证模板 ：工作证尺寸一般是8.6 * 5.4CM，我们需要插入一个3*5的表格
3、图片域：插入图片域名要选择IncludePicture，文件名先任意填入，起到占位的作用
4、保存位置：打印文档要保存到照片所在文件夹
5、快捷键：Ctrl + A：全选；Alt + F9：隐藏域代码；F9：刷新
想要了解更多高效办公技巧，请点击关注！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa1b9e647413707a2a2b309849fffc5/" rel="bookmark">
			机器学习(一)：基于Logistic回归模型的分类预测(算法实践)——阿里云天池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、逻辑回归的介绍和应用1.1 逻辑回归的应用 二、逻辑回归案例2.1.引入库2.2读入数据2.3.调用函数拟合数据2.4.设置边界2.5.预测数据2.6.预测数据值 总结 前言 随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。 一、逻辑回归的介绍和应用 逻辑回归（Logistic regression，简称LR）虽然其中带有"回归"两个字，但逻辑回归其实是一个分类模型，并且广泛应用于各个领域之中。虽然现在深度学习相对于这些传统方法更为火热，但实则这些传统方法由于其独特的优势依然广泛应用于各个领域中。
而对于逻辑回归而言，最为突出的两点就是其模型简单和模型的可解释性强。
逻辑回归的优劣势：
优点：实现简单，易于理解和实现；计算代价不高，速度很快，存储资源低；缺点：容易欠拟合，分类精度可能不高 1.1 逻辑回归的应用 逻辑回归模型广泛用于各个领域，包括机器学习，大多数医学领域和社会科学。例如，最初由Boyd 等人开发的创伤和损伤严重度评分（TRISS）被广泛用于预测受伤患者的死亡率，使用逻辑回归 基于观察到的患者特征（年龄，性别，体重指数,各种血液检查的结果等）分析预测发生特定疾病（例如糖尿病，冠心病）的风险。逻辑回归模型也用于预测在给定的过程中，系统或产品的故障的可能性。还用于市场营销应用程序，例如预测客户购买产品或中止订购的倾向等。在经济学中它可以用来预测一个人选择进入劳动力市场的可能性，而商业应用则可以用来预测房主拖欠抵押贷款的可能性。条件随机字段是逻辑回归到顺序数据的扩展，用于自然语言处理。逻辑回归模型现在同样是很多分类算法的基础组件,比如 分类任务中基于GBDT算法+LR逻辑回归实现的信用卡交易反欺诈，CTR(点击通过率)预估等，其好处在于输出值自然地落在0到1之间，并且有概率意义。模型清晰，有对应的概率学理论基础。它拟合出来的参数就代表了每一个特征(feature)对结果的影响。也是一个理解数据的好工具。但同时由于其本质上是一个线性的分类器，所以不能应对较为复杂的数据情况。很多时候我们也会拿逻辑回归模型去做一些任务尝试的基线（基础水平）。 二、逻辑回归案例 Demo实践：
Step1:库函数导入Step2:模型训练Step3:模型参数查看Step4:数据和模型可视化Step5:模型预测 2.1.引入库 代码如下：
## 基础函数库 import numpy as np ## 导入画图库 import matplotlib.pyplot as plt import seaborn as sns ## 导入逻辑回归模型函数 from sklearn.linear_model import LogisticRegression 2.2读入数据 代码如下：
## 构造数据集 x_fearures = np.array([[-1,-2], [-2,-1], [-3,-2], [1,3], [2,1], [3,2]]) y_label = np.array([0, 0, 0, 1, 1, 1]) 2.3.调用函数拟合数据 代码如下：
## 调用逻辑回归模型 lr_clf = LogisticRegression() ## 用逻辑回归模型拟合构造的数据集 lr_clf = lr_clf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaa1b9e647413707a2a2b309849fffc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3510767551b914196f0b8ab6f1210a29/" rel="bookmark">
			Python qrcode模块（生成二维码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python qrcode模块（生成二维码） 一、Qrcode类解释1、QR Codede 由来2、QRCode二维码版本 二、Qrcode类构造函数及参数含义1、version=None2、error_correction=constants.ERROR_CORRECT_M3、box_size=10,4、border=45、image_factory=None6、mask_pattern=None 三、Qrcode类常用方法1、qr.make(self, fit=True)2、qr.add_data(self, data, optimize=20)3、qr.print_tty(self, out=None)4、qr.make_image(fillcolor=None, backcolor=None,image_factory=None)5、qr.clear()6、qr.get_matrix() 四、image_factory参数的详解1、生成 SVG 图像2、生成 PNG 图像 五、实例： 一、Qrcode类解释 qrcode模块里包含：Qrcode类 调用Qrcode类时，首先实例化对象 1、QR Codede 由来 QR Code码是由日本于1994年9月研制的一-种矩阵二维码符号，它具有一维条码及其它二 维条码所具有的信息容量大、可靠性高、可表示汉字及图象多种文字信息、保密防伪性强等优点。
依赖于
qrcode模块是Github_上的一-个开源项目，提供了生成二维码的接口。qrcode默认使用PIL库用于生成图像。由于生成qrcode图片需要依赖Python的图像库，所以需要先安装Python图像库PIL(Python Imaging Library)。
二维码（2-dimensional bar code），是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的。它能将数字、英文字母、汉字、日文字母、特殊符号（如空格，%，/ 等）、二进制等信息记录到一个正方形的图片中。
2、QRCode二维码版本 QR码符号共有40种规格,分别为版本1、版本…版本40版本1的规格为21模块x21模块，版本2为25模块x25模块，以此类推，每一版本符号比前一版本每边增加4个模块，直到版本40，规格为177模块X177模块。其中最高版本40可容纳多达1850个大写字母或2710个数字或1108个字节，或500多个汉字，比普通条码信息容量约高几十倍。由于其高密度编码，信息容量大，所以被广泛采用。
# 实例化 ： qr = qrcode.Qrcode(version=None, error_correction=constants.ERROR_CORRECT_M, box_size=10, border=4, image_factory=None, mask_pattern=None) 二、Qrcode类构造函数及参数含义 Qrcode类构造函数 def __init__(self, version=None, error_correction=constants.ERROR_CORRECT_M, box_size=10, border=4, image_factory=None, mask_pattern=None): _check_box_size(box_size) self.version = version and int(version) self.error_correction = int(error_correction) self.box_size = int(box_size) # Spec says border should be at least four boxes wide, but allow for # any (e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3510767551b914196f0b8ab6f1210a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f6cd9270a7bb261ecae93d039f54ea/" rel="bookmark">
			解决网页无法复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些网页非会员不能复制
在console控制台中输入以下代码即可：
javascript:"use strict";!function(){var t=function(t){t.stopPropagation(),t.stopImmediatePropagation&amp;&amp;t.stopImmediatePropagation()};["copy","cut","contextmenu","selectstart","mousedown","mouseup","keydown","keypress","keyup"].forEach(function(e){document.documentElement.addEventListener(e,t,{capture:!0})})}();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706771e0b356bd66b7d98145dea1e946/" rel="bookmark">
			百钱买百鸡问题的最优解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决百钱买百鸡问题，某人有100元钱，要买100只鸡，公鸡5元钱一只，母鸡3元钱一只，小鸡一元钱3只，问可买到的公鸡，母鸡，小鸡各为多少只，请把所有的可能性打印出来。 一，普通解法
思路：我们设a,b,c分别代表公鸡，母鸡以及小鸡。
由题可得到a+b+c=100和5a+3b+1/3*c=100这两个关系式，以及a,b,c的取值范围。下面是相关代码。
然后大概计算了660次。
for (int a = 0; a &lt; (100/5); a++) { for (int b = 0; b &lt; (100/3); b++) { int c = 100 - a - b; if (c%3==0&amp;&amp; 5*a+3*b+c/3==100) { Console.WriteLine("公鸡{0}只，母鸡{1}，小鸡{2}", a, b,c); } } } 二，最优解法
思路：
1.首先我们可以得到各鸡的
数量关系式：a+b+c=100。 （1）
以及钱的关系式：5a+3b+1/3*c=100 ;（2）
2.根据各鸡的数量关系式我们可以得到各鸡得数量范围：
0&lt;=a&lt;=20;
0&lt;=b&lt;=100/3,由于鸡的数量都是大于等于0的整数，所以0&lt;=b&lt;=33
根据数量关系式a+b+c=100,得47&lt;=c&lt;=100;
3.我们用3*(2) -（1）化简得：b=25- 7/4*a,由于鸡的数量都是大于等于0的整数，所以a必须是4得倍数。假如num是一个大于等于0的整数则a可表示为4num;则b可表示为25-7num,c可表示为75+3num;
4.我们根据0&lt;=a&lt;=20;得到num得范围为0&lt;=num&lt;=5;
根据0&lt;=b&lt;=33;得到num得范围为0&lt;=num&lt;=3;
根据0&lt;=b&lt;=33;得到num得范围为0&lt;=num&lt;=8;
所以num的最终范围为0&lt;=num&lt;=3;
然后用for循环遍历即可得到所有可能结果。
for (int num = 0; num &lt;= 3; num++) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/706771e0b356bd66b7d98145dea1e946/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49142382770b1ee2edfa2575aa26b1c5/" rel="bookmark">
			wince6.0升级7.0系统_黑群晖升级到DSM7.0失败后的处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个办法通过重装系统实现，不需要去修改硬盘的etc.defaults文件，直接重装系统，但是所有配置会丢失，只保留数据。
1、U盘重新制作6.2.3版本的引导，记得修改好U盘的PID和VID值。
2、插上U盘，正常开机，这个时候可以看到群晖助手显示"系统可恢复"，搜索后这里记得千万不要去点击，否则会失败。
3、先把U盘拔了，然后再双击IP，这时候会进入恢复模式，但是因为没引导U盘会提示恢复失败，这时候再把U盘插回去。
4、群晖助手重新搜索下，系统状态会变成“可移转”。
5、浏览器输入IP，点击安装。
6、这里必须选择重新安装系统，如果选择迁移，会失败，因为硬盘上etc.defaults版本还是7.0的，迁移并不会降级。
7、点击立即安装，或者手动安装都可以。
8、耐心等待安装完成
9、系统安装好，配置好自己的个人信息。
10、打开文件管理器，可见之前的数据还在。
必须知道的问题：
黑群晖的升级风险很大，因为遇到问题无法引导，就必须断电重启，
为了测试重启引导，我因为反复热插拔断电，最终把这个硬盘给弄坏了。
升级前建议备份好重要数据，别手贱最后把硬盘和数据都弄丢了。
上面教程只供学习参考，数据丢失概不负责。
最简单办法，直接购买白群晖，换上去重新迁移系统即可完美解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aafd7e0be6c7e4b9c073c67d7742680/" rel="bookmark">
			Linux设置时区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 首先要确定时区 时区设置用tzselect 命令来实现。但是通过tzselect命令设置TZ这个环境变量来选择的时区，需要将变量添加到.profile文件中。
[root@test tmp]# tzselect 执行tzselect命令 --&gt; 选择Asia --&gt; 选择China --&gt; 选择Beijing Time--&gt; 选择Yes。 选择后会提示：
You can make this change permanent for yourself by appending the line TZ='Asia/Shanghai'; export TZ to the file '.profile' in your home directory; then log out and log in again. Here is that TZ value again, this time on standard output so that you can use the /usr/bin/tzselect command in shell scripts: Asia/Shanghai 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aafd7e0be6c7e4b9c073c67d7742680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/990a87e325d950d272b8d6253d6ea4b8/" rel="bookmark">
			vue源码解析pdf_Vue源码全面解析八 callHook函数（触发生命周期函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们打开‘src/core/instance/lifecycle.js'文件，代码如下：
export function callHook (vm: Component, hook: string) { pushTarget() const handlers = vm.$options[hook] const info = `${hook} hook` if (handlers) { for (let i = 0, j = handlers.length; i &lt; j; i++) { invokeWithErrorHandling(handlers[i], vm, null, vm, info) } } if (vm._hasHookEvent) { vm.$emit('hook:' + hook) } popTarget()} 可以看到这个函数比较简单，主要有3点：
1、禁止Dep的依赖收集
2、调用 "invokeWithErrorHandling" 触发对应的生命周期函数
3、触发对应是钩子函数，如果存在的话
pushTarget()// 函数代码如下export function pushTarget (target: ?Watcher) { targetStack.push(target) Dep.target = target} 可以看调用该函数的时候没有传任何参数，那就是 “target” 参数的 “undefined”，就没有收集对象了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/990a87e325d950d272b8d6253d6ea4b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae968ebc3f7591044914afdc3eeb766a/" rel="bookmark">
			verilog实例_Verilog中的assign 语句y会生成latch么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字芯片实验室之前深度分析过Verilog建模的组合逻辑在什么样的条件下会生成Latch？
实例解析Verilog综合出锁存器的问题 今天数字IC设计交流群中讨论到一个assign语句生成Latch的问题。下面是两个实例
示例1
module test1(out,a,b); input a ,b ; output out ; assign out = (a&amp; b) + (!b &amp; out) ;endmodule 示例1不会生成Latch。
elaborate结果
Vivado工具elaborate之后，可以看出上述代码是一个纯组合逻辑，满足逻辑关系
out = (a &amp; b) + (!b &amp; out) ; synthesis结果
Vivado工具综合之后，将设计映射到一个LUT3上。
示例2
module test2(out,a,b); input a ,b ; output out ; assign out = b?a:out ; endmodule 示例2会生成Latch。
elaborate结果
Vivado工具elaborate之后，可以看出上述代码是一个Latch逻辑，满足逻辑关系
out =b?a:out ; synthesis结果
造成上述两个相同逻辑，不同综合结果差异的根本原因是：过程赋值和连续赋值的差异。
过程赋值和连续赋值我在之前的文章verilog重点解析(13题)中讨论过。
过程赋值在Verilog中主要用来赋值给reg变量，用来生成时序和组合逻辑。例如
always@(*) 连续赋值主要用来赋值给wire变量，用来生成组合逻辑。例如
assign 特别的是，Verilog中的
assign out =b?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae968ebc3f7591044914afdc3eeb766a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238839af03b3dd750301048a6b002c70/" rel="bookmark">
			面试三连问：你这个数据量多大？分库分表怎么做？用的哪个组件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方蓝色“码猿技术专栏”，选择“设为星标”
来源：cnblogs.com/cjsblog/p/13154158.html
1. 概述
1.1. ShardingSphere-JDBC
1.2. ShardingSphere-Proxy
1.3. ShardingSphere-Sidecar
1.4. 混合架构
2. 概念 &amp; 功能
2.1. 数据分片
2.2. 读写分离
3. 示例：水平分库分片
4. 写在最后
1. 概述
ShardingSphere是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（计划中）这3款相互独立的产品组成。他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。
ShardingSphere定位为关系型数据库中间件，旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力。
1.1. ShardingSphere-JDBC Sharding-JDBC 定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。
适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。
支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。
支持任意实现JDBC规范的数据库。目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238839af03b3dd750301048a6b002c70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91dbd504f65677e724e7cba5e2f269ab/" rel="bookmark">
			python batchnorm2d_PyTorch 卷积与BatchNorm的融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020-05-27 更新PyTorch已经官方支持了合并操作：Captain Jack：MergeBN &amp;&amp; Quantization PyTorch 官方解决方案​zhuanlan.zhihu.com
2. 有用户爸爸/妈妈(我是讲女权的)在用我的这套代码的时候出现了各种错误，如果还是打算用这套，我将最新版同步到了github上，后面也会不定期同步：https://github.com/qinjian623/pytorch_toys/blob/master/post_quant/fusion.py​github.com
原文：2018-11-11(本文最后一次更新的时间，神tm的日子...)
融合Conv和BatchNorm是个很基本的优化提速方法，很多框架应该都提供了功能。自己因为一个Weekend Project的需求，需要在PyTorch的Python里直接这个事情给做了。
这个融合优化属于经济上净赚的事情，精度理论上无损(实际上有损，但是很小，既然都提速了，八成要弄量化，这个精度掉的更夸张)，速度有大幅度提升，尤其是BN层接的特别多的情况。
融合原理
卷积的工作：
BN的工作：
带入的话可以推出来，融合后的新卷积：
新的卷积就直接顺路完成BN的工作。
测试结果：
在我的笔记本上的测试，CPU版本应该是同步的吧，否则这个结果也是不靠谱的，当然这个结果也不是严肃结果，没平均，没热机。不过能定性说明问题就OK，单位是秒。
import torch
import torch.nn as nn
import torchvision as tv
class DummyModule(nn.Module):
def __init__(self):
super(DummyModule, self).__init__()
def forward(self, x):
# print("Dummy, Dummy.")
return x
def fuse(conv, bn):
w = conv.weight
mean = bn.running_mean
var_sqrt = torch.sqrt(bn.running_var + bn.eps)
beta = bn.weight
gamma = bn.bias
if conv.bias is not None:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91dbd504f65677e724e7cba5e2f269ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea74810ceb14183fa880040f161e748/" rel="bookmark">
			python format函数_如何用format函数保留小数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家有没有想过一个问题，为什么我们通常会使用四舍五入的方法保留小数，而不是采用其他方式？其实呀，四舍五入是一种精确度的保留法，与其他方法本质相同。但特殊之处在于，采用四舍五入，能使被保留部分的与实际值差值不超过最后一位数量级的二分之一，这种保留法的误差总和是最小的。在我们python编程中，通常也是采用四舍五入保留小数，那具体如何操作？可以用format函数保留小数吗？
python中format函数用于字符串的格式化，主要是用来构造字符串，所以是可以保留小数的。
代码：
print(format(1.23456, '.2f')) print(format(1.23456, '.3f')) print(format(1.23456, '.4f')) 1.23 1.235 1.2346 用这个方法就可以进行四舍五入的保留小数啦，为了避免小数太多难以计算使用，快使用这样的便捷方式吧~更多python常见问题解决方法：
Python常见问题 - Python学习网​www.py.cn 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f895cac4a2bcd4826ecc6959fd04d4db/" rel="bookmark">
			redis对象编码源码阅读——有序集合编码和转码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis对象编码源码阅读——有序集合编码和转码 1. 有序集合对象的编码类型 类型编码对象REDIS_ZSETREDIS_ENCODING_ZIPLIST使用压缩列表对象实现的有序集合对象REDIS_ZSETREDIS_ENCODING_SKIPLIST使用跳跃表和字典实现的有序集合对象 2. 两种编码的转换 void zsetConvert(robj *zobj, int encoding) { zset *zs; zskiplistNode *node, *next; robj *ele; double score; if (zobj-&gt;encoding == encoding) return; 2.1 压缩列表转跳表 if (zobj-&gt;encoding == REDIS_ENCODING_ZIPLIST) { unsigned char *zl = zobj-&gt;ptr; unsigned char *eptr, *sptr; unsigned char *vstr; unsigned int vlen; long long vlong; if (encoding != REDIS_ENCODING_SKIPLIST) redisPanic("Unknown target encoding"); 重新申请空间 zs = zmalloc(sizeof(*zs)); zs-&gt;dict = dictCreate(&amp;zsetDictType,NULL); zs-&gt;zsl = zslCreate(); 得到 eptr = ziplist[0] 和 sptr = ziplist[1] = ziplist[0]-&gt;next 指针 eptr = ziplistIndex(zl,0); redisAssertWithInfo(NULL,zobj,eptr !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f895cac4a2bcd4826ecc6959fd04d4db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d0518904d0b0451071cea1a5893fe39/" rel="bookmark">
			bic准则 python实现_python机器学习---时间序列算法 0117-2020
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间序列概念
时间序列建模步骤
时间序列python实现时间序列概念
时间序列是指将同一统计指标的数值按其发生的时间先后顺序排列而成的数列。时间序列分析的主要目的是根据已有的历史数据对未来进行预测。ARIMA时间序列建模步骤
本文利用 ARIMA构建高性能时间序列模型，来预测医保支出费用。对整个建模的步骤及步骤用到的技术进行总结：
1 建模步骤
ARIMA是一个非常强大的预测时间序列数据的模型，但是数据准备和参数调整过程是非常耗时的。在实现ARIMA之前，需要使数据保持平稳，并使用前面讨论的ACF和PACF图确定p和q的值，一般情况下，下面是实现ARIMA应该遵循的步骤：
(1) 加载数据，动态数据预处理：包括平稳性检验，及非平稳性数据处理，正太性检验；
(2) 时间序列模型ARIMA参数估计：包括q、d、p确定
(3) 建模，指标评估，残差检验
(4) 在验证集上进行预测：在验证集基础上进行预测
(5) 计算RMSE：用验证集上的预测值和实际值检查RMSE值
1.1 动态数据预处理
1.1.1 平稳性检验
时间序列的平稳性是我们建模的重要前提。一般说来，某个实测过程如果它的系统参数和运行时周围的条件不改变，即可视为平稳的。
平稳性要求序列的均值和方差不发生明显变化。
平稳性检验细化分为严平稳与弱平稳：
(1)严平稳：严平稳表示的分布不随时间的改变而改变。如：白噪声(正态)，无论怎么取，都是期望为0，方差为1。
(2)弱平稳：期望与相关系数(依赖性)不变，未来某时刻的t的值Xt就要依赖于它的过去信息，所以需要依赖性。
建模时，首先要对加载的原始数据进行平稳性检验，对于平稳的数据可直接进入下一步骤，对于非平稳数据，可进行差分处理，再进行后续步骤。
1.1.2 差分法
差分法：时间序列在t与t-1时刻的差值。
1.2 ARIMA模型参数估计
1.2.1 AR模型
自回归模型(AR)是描述当前值与历史值之间的关系，用变量自身的历史时间数据对自身进行预测。自回归模型必须满足平稳性的要求。
p阶自回归过程的公式定义：
其中，
是当前值， 是常数项，p是阶数， 是自相关系数， 是误差。
自回归模型的限制：
(1)自回归模型是用自身的数据来进行预测
(2)必须具有平稳性
(3)必须具有自相关性，如果自相关系数(
)小于0.5，则不宜采用
(4)自回归只适用于预测与自身前期相关的现象
1.2.2 MA模型
移动平均模型(MA)关注的是自回归模型中的误差项的累加，移动平均法能有效地消除预测中的随机波动。
q阶自回归过程的公式定义：
其中，
是当前值， 是常数项，q是阶数， 是误差。
1.2.3 APIMA模型
自回归移动平均模型(ARMA)是自回归与移动平均的结合。
自回归移动平均模型(ARMA)公式定义：
ARIMA(p，d，q)模型全称为差分自回归移动平均模型，AR是自回归， p为自回归项； MA为移动平均，q为移动平均项数，d为时间序列成为平稳时所做的差分次数。
原理：将非平稳时间序列转化为平稳时间序列，然后将因变量仅对它的滞后值，以及随机误差项的现值和滞后值进行回归所建立的模型。
1.2.4 自相关函数ACF
有序的随机变量序列与其自身相比较，自相关函数反映了同一序列在不同时序的取值之间的相关性。
公式定义：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d0518904d0b0451071cea1a5893fe39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe7d57b4bd4889fc8b10c572d0d8eec/" rel="bookmark">
			【神器】这三款网络抓包工具在手，同事想甩锅都难！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、聊一聊
一首非常有感染力的电音歌曲，party必备！
2、正文部分
大家都知道在进行稍微大一点的系统软件项目开发中，一般都会分为上、下位机软件开发，而使用以太网进行系统通信集成是一种比较常规的处理办法，协议上会相对会复杂一点，一旦协议双方确定以后剩下的就是编码和联调工作。
然而在前期设备运行过程中难免会发生通信问题，“到底是上位机没发数据包，还是下位机解析出了问题”，两波人老是扯不清楚。
对于研发态度不太好的同事，总是想着让另外一方去分析定位问题，导致一个问题拖沓很长时间，那么使用第三方抓包工具进行数据分析，并定位问题成为了终结这种通信“扯皮”的好方式！
而抓包工具目前来说也是种类繁多，收费工具一般需求不高的也不会去购买，个人开源的软件难免会有些bug，所以有时候即使你确定了是对方的问题定位了，而对方以你所使用的抓包工具不够权威、靠谱为借口，而再陷入瞎扯中，所以bug菌这里跟大家介绍三款比较靠谱且稳定的网络抓包工具！
No1、Wirshark
官方网站 : https://www.wireshark.org/
1
介绍
Wireshark算是目前网络分析非常广泛的专业分析工具，如果你没有听说过，那你应该不是一个专业的网络分析人员，后者算是刚入行吧。
其中一个非常重要的理由是Wireshark是免费的，是开源的，是根据GNU通用公共许可证（GPL）发布的。
你可以在你喜欢的任何数量的计算机上自由使用Wireshark，而不必担心许可证密钥或费用之类的问题。此外，所有源代码都可以在GPL下免费获得。
而且很容易向Wireshark添加新的协议，要么作为插件，要么内置到源代码中！可以说是目前最好的网络数据包分析工具，如果你足够感兴趣可以尝试编译源码进行软件的优化和定制自身项目需求的插件。
2
特点
适用于UNIX和Windows等系统。
从网络接口捕获实时数据包数据。
打开包含用tcpdump/WinDump、Wireshark和许多其他包捕获程序捕获的包数据的文件。
从包含数据包数据十六进制转储的文本文件导入数据包。
显示包含非常详细的协议信息的数据包。
保存捕获的数据包。
捕获或导出一些文件格式的数据包。
根据许多条件筛选、过滤、搜索、统计数据包。
3
体验
1、在上面的官方路劲中下载安装包，然后一路next到最后安装完成，最后显示如下图标。
2、双击打开显示过滤器和所要监控的网口，加入数据获取界面。
3、如下就到了该软件的详细监控数据界面，这样就可以通过网络上的数据分析数据包内容，同时还可以根据该工具规定的协议包过滤功能编写过滤规则，过滤掉我们不太关心的部分，比如只需要查看Udp或者只需要某端口的数据等等。
No2、Microsoft Network Monitor
官网地址:http://www.microsoft.com/en-us/download/details.aspx?id=4865
1
介绍
Microsoft Network Monitor是一个款免费网络数据包分析器，其为微软开开发用来进行协议分析的工具，可想而知，其对微软的私有协议的识别和解解码无疑是最完善的，所以在win上对于协议比较敏感的项目可以优先使用。。它可以扑捉和查看300多个公共和微软专有网络协议，包括无线网络数据包。
2
特点
解析器配置管理：解析器现在安装了配置文件，允许您使用解析器配置文件工具栏按钮在解析器配置之间轻松切换。
“实时”专家：专家现在可以在实时捕获过程中运行。另外，最近安装的专家现在会自动出现在“专家”菜单中，而不需要您打开另一个选项卡。
高性能筛选：当您使用UI或nmcap中的某些字段（例如。Frame.Ethernet.IPv4.TCP.端口==8080）。
UTC时间戳：网络监视器现在将在跟踪中捕获和保存时区相关的信息。默认情况下，使用时区信息打开的跟踪将自动将时间调整为本地时区。可以通过添加“时间和日期”列或查看“文件”菜单下的属性来查看原始时间或时区。
高精度时间戳：网络监视器现在可以在Windows Vista和更高版本以及Windows Server 2008和更高版本上以微秒精度捕获。
802.11n和原始IP帧支持：网络监视器现在支持Microsoft Windows Vista SP1和更高版本操作系统上的802.11n网络上的监视模式，以及Microsoft Windows 7上的原始IP帧。
NMCap中的进程跟踪：现在可以在NMCap命令行工具中捕获进程跟踪信息。可以使用实时捕获上的“/CaptureProcesses”标志启用它。
3
体验
1、同样在上面的官方路劲中下载安装包，然后一路next到最后安装完成，最后显示如下图标，双击打开。
2、微软是通过加载不同的解析文档parsers来进行网络协议包的解析，否则capture出来的都是一些字节流数据，比较难分析，微软把这一块进行了分离。
3、所以在使用的时候优先选择windows解析器。
4、新建一个捕捉窗口，然后点击start开始捕获。
5、下图是所捕捉的解析以后数据。
No3、IPTool
IPTool又叫网路岗抓包工具，是一款局域网抓包工具。该软件是一款非常小型的免安装软件，所以对于分析比较常规的通信协议包是非常便捷的。
直接点击即可运行使用,如下图所示,通过选择包过滤，可以过滤掉不同的网卡，不同的协议，不同的端口等等，完全可以满足一般的协议分析和应用。
设置好上面的图形过滤等配置后，直接通过点击启动，实时捕获协议包，捕获结果如下图所示，通过点击list列表中的选项，下方即可显示更为详细的包信息，方便网络监控和分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbe7d57b4bd4889fc8b10c572d0d8eec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45fd58e8b0003107eb33aa297bb7b1eb/" rel="bookmark">
			python爬取qq好友_利用Python爬取QQ好友空间数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：利用Python爬取QQ好友空间数据
程序思路
构造请求链接
先获取所有的好友
获取说说
获取留言
获取个人信息
把数据存到数据库
以上就是整个过程中的大思路，然后在逐步把大思路化解成小的具体的问题去解决。
本人对于Python学习创建了一个小小的学习圈子，为各位提供了一个平台，大家一起来讨论学习Python。欢迎各位到来
Python学习群：960410445一起讨论视频分享学习。Python是未来的发展方向，正在挑战我们的分析能力及对世界的认知方式，因此，我们与时俱进，迎接变化，并不断的成长，掌握Python核心技术，才是掌握真正的价值所在。
基本环境配置
环境：Ubuntu 16.04
IDE： PyCharm
python 3.5
selenium : 用于模拟登录获取cookies
requests : 用于保存会话
json : 用于把数据进行清理，整合
urllib : 用于对链接的构造
pymongo : 用于对mongodb数据库的调用
模拟登录
首先QQ空间是需要登录的，我们利用selenium进行模拟登录
我们使用账号密码登录，通过如下代码可以进行模拟登录：
构造链接
有过爬虫经验的朋友肯定知道，构造链接在爬虫过程中是经常会遇到的，特别是数据需要动态加载的时候。
我们仔细来分析一下它的请求链接：
在chrome的Network下的js中找到qzfl_v8_2.1.65.js
这里就是获取g_tk的算法部分，转换成python版本就是：
这个就是整个程序的核心部分，只要拿到了这个g_tk，其他的就不是什么困难的地方了。
获取所有好友的账号
请求链接构造如下：
获取好友信息如下：
获取所有的好友的说说
先上代码：
总结
这次对QQ空间的爬取总体来说收获还是很大的，文章中只是大体介绍了一下过程，具体细节我希望各位能够亲自动手去做一下，授人以鱼不如授人以渔，要想学好程序，不动手是肯定不行的。返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/188bb5e6f9b8ca8c731d19573148a757/" rel="bookmark">
			clickhouse的SQL参考——（五）system、set和权限相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 https://clickhouse.tech/docs/en/sql-reference/statements
版本:v20.11
目录 SYSTEM语句
RELOAD EMBEDDED DICTIONARIES
RELOAD DICTIONARIES
RELOAD DICTIONARY
DROP DNS CACHE
DROP MARK CACHE
DROP REPLICA
DROP UNCOMPRESSED CACHE
DROP COMPILED EXPRESSION CACHE
FLUSH LOGS
RELOAD CONFIG
SHUTDOWN
KILL
Managing Distributed Tables
STOP DISTRIBUTED SENDS
FLUSH DISTRIBUTED
START DISTRIBUTED SENDS
Managing MergeTree Tables
STOP MERGES
START MERGES
STOP TTL MERGES
START TTL MERGES
STOP MOVES
START MOVES
Managing ReplicatedMergeTree Tables
STOP FETCHES
START FETCHES
STOP REPLICATED SENDS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/188bb5e6f9b8ca8c731d19573148a757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d051aa320484f6fcec954f978770be/" rel="bookmark">
			handleRequest()参数报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于入门的新手来说，刚编好的程序，一跑，卧槽怎么这两个鬼东西一直出错。
其实呢，是项目没有构建路径。
项目中，点击右键–构件路径–配置构建路径–库–Add library…–Server Runtime，点击下一步，然后选择Apache Tomcat，并点击应用即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa365596d16d2d88525763868affebe5/" rel="bookmark">
			html中ul和li标签的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普通的显示数据的时候，ul就是项目列表，li就是列表项。可以用来显示数据。 如果用于DIV＋CSS布局的话，ul+li可以替换表格的作用，具体的设置，如果宽度高度、行间距、背景边框等需要配合CSS一起设置。 一.做导航，居中 &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;做导航&lt;/title&gt; &lt;style type="text/css"&gt; #menu{ width:1000px; height:35px; float:right; margin:0px; clear:both; vertical-align:bottom; } #ul li{ list-style-type:none; /*去掉项目符号的，比如你用了&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;默认的li里边的字是有列表符号的，小圆点。这个list-style-type: none就是不要列表符号*/ clear:both; width:100px; display:inline; /*li {display: inline} 让 li 不再独占一行, 宽度上只会得到必要的而不是占有所在容器的全宽*/ font-size: larger; text-decoration:none; } a{ text-decoration:none; /*去掉下划线*/ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="menu"&gt; &lt;ul id="ul"&gt; &lt;li&gt;&lt;a title="" href="http://localhost:1435/BookShop/index.aspx"&gt;首页 &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a title="" href="http://localhost:1435/BookShop/hybooks.aspx"&gt;行业图书 &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a title="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa365596d16d2d88525763868affebe5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/97/">«</a>
	<span class="pagination__item pagination__item--current">98/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/99/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>