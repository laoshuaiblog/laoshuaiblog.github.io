<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f5ae4f6e08447feb8a5ba81a020f198/" rel="bookmark">
			Putty连接登录Linux .ppk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载Putty并安装
安装完成后会有两个重要的软件
Putty是用于连接Linux的客户端
PuTTYgen是通过客户端下载的service.ppk生成本地登录要用到的key
2、通过PuTTYgen生成本地key
File=&gt;Load private key，选择service.ppk文件
提示导入成功后，点击save private key 按钮，生成本地需要的key
3、通过PuTTY登录Linux
选择 “Session”，在 “Host Name (or IP address)” 输入框中输入想要访问的 主机名 或 IP。
端口号（Port）根据使用的协议有所区别，SSH 默认使用 22，Telnet 默认使用 23，Rlogin 默认使用 513。
Saved Sessions里可以起个名字
然后选择Connection=&gt;SSH=&gt;Auth,点击 浏览 按钮，选择通过PuTTYgen生成的key,格式为ppk
再回到Session选项，点击Save，保存下配置。下次直接使用此配置，点击Open按钮连接Linux;
输入用户名，出现这些说明成功连接上了Linux
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/502a538a4e10510f164a42199ad55fad/" rel="bookmark">
			转：python之qrcode模块生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Python的qrcode包来生成二维码很简单
一、前期准备： pip install qrcode
qrcode 依赖 Image 这个包：
pip install Image
二、安装好之后就可以通过代码实现二维码了 1. 简单生成二维码： import qrcode # 模块导入 # 调用qrcode的make()方法传入url或者想要展示的内容 img = qrcode.make('http://www.baidu.com') # 写入文件 with open('test.png', 'wb') as f: img.save(f) 生成的二维码：
此处并没有使用add_data()添加数据，make_image()生成二维码，而是使用qrcode.make(data)的方式获取im对象。qrcode.make()是qrcode提供简单调用接口。
2. 正常生成二维码的步骤： 创建QRCode对象add_data()添加数据make_image()创建二维码（返回im类型的图片对象）自动打开图片，im.show() 3.QRCode参数详细说明： version: 一个整数，范围为1到40，表示二维码的大小（最小值是1，是个12×12的矩阵），如果想让程序自动生成，将值设置为 None 并使用 fit=True 参数即可。error_correction: 二维码的纠错范围，可以选择4个常量：
··1. ERROR_CORRECT_L 7%以下的错误会被纠正
··2. ERROR_CORRECT_M (default) 15%以下的错误会被纠正
··3. ERROR_CORRECT_Q 25 %以下的错误会被纠正
··4. ERROR_CORRECT_H. 30%以下的错误会被纠正boxsize: 每个点（方块）中的像素个数border: 二维码距图像外围边框距离，默认为4，而且相关规定最小为4 4.参数配置后生成自定制二维码 import qrcode data = 'http://www.baidu.com/' img_file = r'保存路径' # 实例化QRCode生成qr对象 qr = qrcode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/502a538a4e10510f164a42199ad55fad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/590f622d737b3598bd76d9b91fa16525/" rel="bookmark">
			操作系统—— I/O 相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、I/O 设备的概念和分类二、I/O 控制器三、I/O 控制方式1、程序直接控制方式2、中断驱动方式3、DMA 方式4、通道控制方式 四、I/O 软件层次结构五、I/O 核心子系统1、假脱机技术2、设备的分配与回收⑴设备分配时应当考虑的因素⑵静态分配和动态分配⑶设备分配管理中的数据结构⑷设备分配的步骤 3、缓冲区管理⑴缓冲区的作用⑵单缓冲⑶双缓冲⑷循环缓冲区和缓冲池 总结 前言 本文的主要内容是操作系统中与 I/O 相关的一些基础知识，包括 I/O 设备的概念和分类、I/O 控制器、I/O 控制方式、I/O 软件层次结构以及 I/O 核心子系统，重点理解 I/O 控制方式和 I/O 核心子系统中完成工作。
一、I/O 设备的概念和分类 I/O 就是 Input/Output 的缩写，即输入/输出。I/O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，I/O 设备属于计算机中的硬件部件。例如鼠标、键盘就是输入设备，显示器就是一个输出设备，而移动硬盘是既可输入又可输出设备。
UNIX 系统中将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。Read 操作就是从外部设备读入数据，Write 操作就是向外部设备写出数据。
I/O 设备按照使用特性分类可以分为：人机交互类外部设备(键盘、鼠标、打印机等)、存储设备(移动硬盘、光盘等)和网络通信设备(调制解调器等)。其中，存储设备的数据传输速度在三者中最快，网络通信设备次之，人机交互类外部设备最慢。
I/O 设备按照传输速率分类可以分为：低速设备、中速设备和高速设备。低速设备传输速率为每秒几个到几百个字节，例如鼠标、键盘等；中速设备传输速率为每秒数千至上万个字符，例如打印机等；高速设备传输速率为每秒数千字节至千兆字节，例如硬盘、磁盘等。
I/O 设备按照信息交换的单位分类可以分为：块设备和字符设备。块设备例如移动硬盘、磁盘等，其数据的传输单位是块，传输速率较高，可寻址，也就是对它可以随机地读或写任意一块。字符设备例如鼠标、键盘等，其数据的传输单位是字符，传输速率较慢，不可寻址，在输入输出时常采用中断驱动方式。
对 I/O 设备的概念和分类这部分的内容简单的总结一下，如下图所示。
二、I/O 控制器 I/O 设备由机械部件和电子部件组成，电子部件就是 I/O 控制器，也称为设备控制器。
I/O 设备的机械部件主要用来执行具体的 I/O 操作，比如鼠标和键盘的按钮，显示器的屏幕等。I/O 设备的电子部件通常是一块插入主板扩充槽的印刷电路板。
由于 CPU 无法直接控制 I/O 设备的机械部件，因此 I/O 设备需要一个电子部件作为 CPU 和 I/O 设备机械部件之间的媒介，用于实现 CPU 对设备的控制。这个电子部件就是 I/O 控制器，CPU 可以控制 I/O 控制器， I/O 控制器来控制设备的机械部件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/590f622d737b3598bd76d9b91fa16525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c342d953d74aa34914e351d03b4aabf0/" rel="bookmark">
			操作系统——进程的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.进程的概念1.1 进程初始1.2 进程控制块—test_struct1.3 进程组织 2.人为管理进程的操作2.1 查看进程2.2 进程标识符的获取2.3 创建进程fork()2.4 消灭指定进程 3. 进程的状态3.1 基本的进程状态(1)R运行状态。(2)S和D睡眠状态(3)T暂停状态(4)X状态进程结束 3.2 特殊的进程状态(1)Z状态僵尸进程(2)孤儿进程 4.进程的优先级4.1 查看进程的优先级4.2 修改进程优先级 前言： 进程是什么？为什么有进程？怎样管理进程？这是本篇文章要搞定的问题。同学们注意了，鸡汤来喽！！！ 1.进程的概念 1.1 进程初始 操作系统只认识二进制文件，所谓程序就是一个二进制文件，操作系统要运行程序时，该怎么操作呢？这就需要进程：程序被触发后，执行者的权限与属性，程序的代码与所需数据都会被加载到内存中，这个过程就是进程。
进程：程序代码+相关数据集
加载进内存该如何管理呢?操作系统需要直接面向加载到内存中的代码嘛？答案是不需要。
举个例子：
操作系统(校长)，老师(进程控制块)，学生(程序)。校长想要了解某个学生的学习情况，会去直接找学生嘛？一般不会，会去找对应的老师，向她问候一下学生情况，结果表示学生的成绩好，可以考虑保送(优先级高)，校长说那就保送吧(开始执行)，校长通过老师把学生给办了。
1.2 进程控制块—test_struct 所以每个程序在进入内存时，操作系统会自动创建一个PCB结构体来存放进程信息，Linux操作系统的PCB是task_struct，大家可能好奇程序代码也存在task_struct中嘛？task_struct存信息，它存的是指向程序代码的指针，程序代码是加载到内存中的。
可以看下task_struct中的内容：
struct task_struct { //说明了该进程是否可以执行,还是可中断等信息 volatile long state; //Flage 是进程号,在调用fork()时给出 unsigned long flags; //进程上是否有待处理的信号 int sigpending; //进程地址空间,区分内核进程与普通进程在内存存放的位置不同 mm_segment_t addr_limit; //0-0xBFFFFFFF for user-thead //0-0xFFFFFFFF for kernel-thread //调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度 volatile long need_resched; //锁深度 int lock_depth; //进程的基本时间片 long nice; //进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHER unsigned long policy; //进程内存管理信息 struct mm_struct *mm; int processor; //若进程不在任何CPU上运行, cpus_runnable 的值是0，否则是1 这个值在运行队列被锁时更新 unsigned long cpus_runnable, cpus_allowed; //指向运行队列的指针 struct list_head run_list; //进程的睡眠时间 unsigned long sleep_time; //用于将系统中所有的进程连成一个双向循环链表, 其根是init_task struct task_struct *next_task, *prev_task; struct mm_struct *active_mm; struct list_head local_pages; //指向本地页面 unsigned int allocation_order, nr_local_pages; struct linux_binfmt *binfmt; //进程所运行的可执行文件的格式 int exit_code, exit_signal; int pdeath_signal; //父进程终止是向子进程发送的信号 unsigned long personality; //Linux可以运行由其他UNIX操作系统生成的符合iBCS2标准的程序 int did_exec:1; pid_t pid; //进程标识符,用来代表一个进程 pid_t pgrp; //进程组标识,表示进程所属的进程组 pid_t tty_old_pgrp; //进程控制终端所在的组标识 pid_t session; //进程的会话标识 pid_t tgid; int leader; //表示进程是否为会话主管 struct task_struct *p_opptr,*p_pptr,*p_cptr,*p_ysptr,*p_osptr; struct list_head thread_group; //线程链表 struct task_struct *pidhash_next; //用于将进程链入HASH表 struct task_struct **pidhash_pprev; wait_queue_head_t wait_chldexit; //供wait4()使用 struct completion *vfork_done; //供vfork() 使用 unsigned long rt_priority; //实时优先级，用它计算实时进程调度时的weight值 //it_real_value，it_real_incr用于REAL定时器，单位为jiffies, 系统根据it_real_value //设置定时器的第一个终止时间.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c342d953d74aa34914e351d03b4aabf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/640134a3353bdc848d47c1f33e5840b7/" rel="bookmark">
			CentOS配置jmeter或-bash: /root/apache-jmeter-5.5/bin/jmeter: Permission denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前置条件：系统已安装jdk 一、下载jmeter包，通过客户端放在安装目录 1.本次安装的版本为unzip apache-jmeter-5.5.zip unzip apache-jmeter-5.5.zip 或者使用Xftp7拖到CentOS root文件中 2.配置环境变量 执行 vim /etc/profile 在后面加入： export JMETER_HOME=/root/apache-jmeter-5.5 exportCLASSPATH=$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar:$CLASSPATH export PATH=$JMETER_HOME/bin:$PATH:$HOME/bin 3.执行： source /etc/profile 让配置生效 4.验证安装 jmeter -v 如果出现: -bash: /root/apache-jmeter-5.5/bin/jmeter: Permission denied 则给jmeter执行文件授权： 执行： chmod 777 /root/apache-jmeter-5.5/bin/jmeter 若看到如下图，则安装成功 ----------------------------------- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b0246e5301e6fe1c3b3192e4224688/" rel="bookmark">
			【Python】关于字节串的解析小坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于python字节串 a = b'\x01\x02\x03\x04'
用索引取值 a[0]直接返回对应字节的十进制值1，
小坑: 这里不需要用struct.unpack("&gt;B", a[0])[0] 这样做反而会报错
TypeError: a bytes-like object is required, not 'int' 用切片取值 a[:1] 返回还是字节串
b'\x01' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34dfff485fe6733546c6d763a67a3a2e/" rel="bookmark">
			SQLserver 批量删除表（drop）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中有一些随着使用而生成的数据表，当新的机器或者其他地区需要同样的数据库时，从已有数据库复制过来的库中这些表都需要删除。
比如 存在大量格式为为M_RealValue_YYYYmmDD和M_TrendData_YYYYmmDD的表，可以通过以下语句生成的结果
select 'drop table '+name+';' from sys.tables where name like 'M_RealValue_%' or name like 'M_TrendData_%' 直接复制后执行就可删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b87e7b4f4ecebabffbda46713e88c57/" rel="bookmark">
			python利用pandas.DataFrame批量写入clickhouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 包引入 import json import logging import math import os import pandas as pd import datetime import requests from clickhouse_driver import Client from cmc.config import config #在类外定义全局变量,这样当前这个py文件都可以共享 process_date = datetime.datetime.now().strftime("%Y%m%d") class MyPyClassDemo: def __init__(self, api_key: str): self.api_key = api_key def tstFuctions(self): pass .... def getClickHouseClient(self): try: host_name = 'xxxx.xxx.com' client = Client( host=host_name, database='your db name', user='root', password='123123', send_receive_timeout=20, settings={'use_numpy': True} ) return client except Exception as e: print("Error: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b87e7b4f4ecebabffbda46713e88c57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f23172373cc1aaf487a3c090615274/" rel="bookmark">
			VScode Remote SSH连接失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步、先删除两个文件： 第一个：C:\Users\xxx\AppData\Roaming\Code 文件夹。
第二个：/home/XXX/.vscode_server 文件夹。在远程linux系统里面。
第二步、重启远程 重新启动linux系统：reboot、shutdown -r now
第三步、使用ssh连接远程 先在windows下的cmd 中ping一下远程，能ping通
然后在cmd中输入ssh user@ip 尝试连接远程，如果连接不通找其他原因
第四步、使用VScode连接远程 联网然后使用remote-ssh插件连接远程
到这里如果卡在Setting up SSH Host XX: Downloading VS Code Server这里，请耐心等待，中间不要更换网络或断网，否则失败。
如果不想耐心等待，可以在百度或者知乎搜索一下“Downloading VS Code Server”或者怎么直接下载vscode-server-linux-x64.tar.gz并安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e35857b19c1ed584d7ecbf286981ab/" rel="bookmark">
			工作中常见的linux命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pwd命令 查看当前的工作目录，而且是以绝对路径显示的
ls命令 查看当前下的文件和目录
mkdir命令 在当前目录下创建目录
rm -rf命令 删除一个文件或者目录
cd命令 进入指定目录
grep命令 查询制定关键字日志 例如：grep -n ‘查询关键字’ xxx.log
二级关键字查询
tail命令 tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。
例如：tail -100f xxx.log #查询指定文件100行日志
sed命令 查询指定开始行到结束行的日志 -n选项：只显示匹配处理的行
例如：sed -n ‘10,20p’ xxx.log #查询第10行至20行的日志
vim命令 修改文件内容：
vim a.java 进入一般模式
i(按键) 进入插入模式(编辑模式)
ESC(按键) 退出
:wq 保存退出
:q！ 不保存退出(强制退出，不保留更改内容)
:q 不保存退出（没有内容更改）
ps命令 查询所有java进程
zip/unzip命令 压缩zip
zip aa.zip ee.jar //将单个文件压缩(aa.zip)
解压缩(unzip)
unzip file.zip //解压一个zip格式压缩包
curl命令 GET请求：curl URL?a=1&amp;b=nihao
POST请求：curl -X POST -d ‘a=1&amp;b=nihao’ URL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e35857b19c1ed584d7ecbf286981ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b63b122b2c4e359a02051abc581b71/" rel="bookmark">
			PostgreSql简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数据库的概念 数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。
2. 数据库分类 通过数据的保存格式进行分类，现阶段流行的数据库主要分为以下两种：
关系型数据库
关系型数据库采用表格的存储方式，数据以行和列的方式进行存储。存储的格式可以直观地反映实体间的关系。使用SQL(Structured Query Language,结构化查询语言) 对数据进行操作。
常见的有Oracle、MySQL、微软的SQL Server、PostgreSQL、IBM的DB2等。
非关系型数据库
伴随着互联网技术快速发展，传统关系型数据库在应对大数据量，比如大规模和高并发动态网页时，已经有些力不从心，曝露了许多难以克服的难题。因此出现了针对大规模数据量场景，以性能卓越和应用便捷为目的的的数据库产品——NOSQL数据库。
非关系型数据库主要是根据“非关系实体模型”的数据库，也称之为NoSQL数据库，NOSQL的原意是“Not only SQL”，NoSQL的出现并不是要完全否认关系型数据库，只是做为传统关系型数据库的一个合理补充。NoSQL数据库在特殊的情景下能够充分发挥出高效率和卓越性能。
非关系型数据库分类：
键值型数据库：Redis
列储存数据库：Hbase
文档型数据库：MongoDB
图型数据库: Neo4j
3. PostgreSQL 3.1. 简介 PostgreSQL是一个开源的，特性非常齐全的对象-关系型数据库，同时还支持NoSql的文档型存储。
3.2. 特性 复杂查询
外键
触发器
可更新视图
事务完整性
多版本并发控制
数据类型：
函数：
操作符：
聚集函数：
索引方法
过程语言
3.3. PostgreSQL的特征 多版本并发控制：PostgreSQL使用多版本并发控制（MVCC，Multiversion concurrency control）系统进行并发控制，该系统向每个用户提供了一个数据库的"快照"，用户在事务内所作的每个修改，对于其他的用户都不可见，直到该事务成功提交。
数据类型：包括文本、任意精度的数值数组、JSON 数据、枚举类型、XML 数据等。
全文检索：通过 Tsearch2 或 OpenFTS。
NoSQL：JSON，JSONB，XML，HStore 原生支持，甚至 NoSQL 数据库的外部数据包装器。
数据仓库：能平滑迁移至同属 PostgreSQL 生态的 GreenPlum，DeepGreen等，使用 FDW（Foreign data wrappers） 进行 ETL（Extract-Transform-Load）。
函数：通过函数，可以在数据库服务器端执行指令程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31b63b122b2c4e359a02051abc581b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b08100befe7d004942c1d4467bb183f/" rel="bookmark">
			解决unsupported class file major version 62 gradle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题原因是：gradle版本和java版本没有对齐我的配置如下 。
上面的Gradle user home要置空，
下面这个勾不能勾上。
distributionUrl=https\://services.gradle.org/distributions/gradle-7.5.1-bin.zip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5affdc571011bf129c5886bb9c8347/" rel="bookmark">
			Java高级语法之反射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java高级语法之反射 目录
一、什么是反射
二、准备测试：实体类的创建
三、反射中的几个重要类及方法
（一）反射中的重要类之Class
1. Class类测试实例
（二）反射中的重要类之Field
1. Field类的获取与常用方法
2. Field类测试实例
（三）反射中的重要类之Constructor
1. Constructor类的获取与常用方法
2. Constructor类测试实例
3. 利用Constructor类实例化对象
4. Constructor实例化对象测试实例
（四）反射中的重要类之Method
1. Method类的获取与常用方法
2. Method类测试实例
3. 利用Method调用非构造方法
4. Method调用非构造方法测试实例
四、综合实战：利用反射机制编写对象拷贝工具类
（一）业务分析
（二）实体类准备
（三）工具类编写
一、什么是反射 java.lang包提供java语言程序设计的基础类，在lang包下存在一个子包：reflect，与反射相关的APIs均在此处；
官方对reflect包的介绍如下：
Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b5affdc571011bf129c5886bb9c8347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7192fa32fe52df02c604121e18d6dd3/" rel="bookmark">
			Verilog——`include等预编译指令实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Verilog与C语言包含头文件类似的预编译指令包括以下：
`define`include`ifdef`elsif`else`endif 需要注意 `include指令后面对.vh文件的引用必须包含文件的 绝对路径！
1）下面是使用预编译指令的一个实例。通过 ifdef ,elsif,`endif设置仿真和实际代码led0的翻转时间。 module top( input clk50M , input rst_n , output led0 ); //localparam //========================================================= `define TEST ; `ifdef TEST //仿真程序代码 localparam TIME_1S = 50_000 ;//1ms localparam TIME_500ms = 25_000 ;//0.5ms `elsif TRUE //实际程序代码 localparam TIME_1S = 50_000_000 ;//1s localparam TIME_500ms = 25_000_000 ;//0.5s `endif //========================================================= reg [31:0] num; //========================================================= //num //--------------------------------------------------------- always @(posedge clk50M or negedge rst_n) begin if(~rst_n) num &lt;= 32'd0; else if(num &gt;= TIME_1S - 1) num &lt;= 32'd0; else num &lt;= num + 1'b1; end //led0 assign led0 = (num &gt;= TIME_500ms) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7192fa32fe52df02c604121e18d6dd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64aa2a5f909a022cd0525173328a9c6e/" rel="bookmark">
			CompletableFuture
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CompletableFuture利用静态方法创建对象时，如果没有传入自定义的线程池，会利用默认的线程池，但该线程池类似于守护线程，主线程完成会关闭，有可能使得CompletableFuture的任务未完成，所以提倡自定义线程池，进行链式编程时，如果中间实现了异步调用，切换为默认的线程池ForkJoinPool(源码会判断是否异步的方法，如果是，会切换线程池)，不过有可能处理太快，系统优化切换原则，直接使用main线程处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815f5753632fe39a1632e30d60a9a81f/" rel="bookmark">
			mach-o file, but is an incompatible architecture (have ‘x86_64‘, need ＞ ‘arm64e‘解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 首先是报错信息，其实从我加粗的地方就会发现是因为这个需要x86，但是我用的是arm64，用这个还要从一开始写的文章说起，mac m1 用idea写java非常卡？这样设置直接起飞！！！
java.lang.UnsatisfiedLinkError:
/private/var/folders/_2/vkmftvzn2dz6b6gtmlpmlljc0000gn/T/librocksdbjni4131103974229553282.jnilib:
dlopen(/private/var/folders/_2/vkmftvzn2dz6b6gtmlpmlljc0000gn/T/librocksdbjni4131103974229553282.jnilib,
0x0001): tried:
‘/private/var/folders/_2/vkmftvzn2dz6b6gtmlpmlljc0000gn/T/librocksdbjni4131103974229553282.jnilib’
(mach-o file, but is an incompatible architecture (have ‘x86_64’, need
‘arm64e’)), ‘/usr/lib/librocksdbjni4131103974229553282.jnilib’ (no
such file)
但发现测试时 RocksDB 报错了，版本号不支持。
在参考了
https://blog.csdn.net/wumingdashen/article/details/124068695?spm=1001.2014.3001.5506
文章后，
发现m1芯片不支持这nacos的rocksDB，采取的方式为更换jdk为x86的形式，虽然性能上不如m1配置的arm64，但还是勉强可以接受的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2574b1f0a368c835f059349ccdc06259/" rel="bookmark">
			Unity编辑扩展：功能篇之Json数据编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 编辑器扩展算是比较纯粹的功能开发，基本没有什么理论知识，都是一些Unity相关接口的使用与数据类型的设计操作等。在本篇文章主要的文字描述基本都是在做代码解释，为了使内容接受度更高，我会尽量描述到代码结构中的每个细节。如果有对此不太了解又很感兴趣的小伙伴可以尝试手动过一遍代码，相信很快很快就可以掌握编辑器开发方面的使用技巧
在前篇文章中有对编辑器扩展UI控件方面的一些基础内容做了简单的描述，大概说明了Unity编辑器界面相关控件的创建接口，链接为：
Unity编辑器扩展 UI控件篇
在掌握编辑器界面控件使用的基础上，利用该控件完成数据编辑工具，对于编辑器扩展来说，通常来说都是以数据编辑为基础的功能扩展。而数据的存储通常以Json为媒介来记录信息，掌握了Json数据的编辑后，可以很方便的在此基础上扩展自己的功能逻辑
一、 设定数据类结构 通常来说，功能模块使用数据的结构通常以类为基本单位。在本数据编辑工具开发案例中，需要先设定几个数据类，作为数据转换的基础
在文章开头的动图中，核心数据块的结构如下，排序数值字段与唯一标识身份ID，除此之外就是一些功能性数据。在本案例中设定了一些字符串与枚举类型的数据字段
为提升通用性，封装排序数值字段与唯一标识身份ID到BaseData作为数据类的基类，基于其特性直接设定两个Int数据值类型即可。而后续所有需编辑数据类作为BaseData的派生类设定。如下面代码中的CharacterData，在继承基类的基础上设定自身需编辑器的核心数据字段，这里简单的设计了字符串与枚举等几个数据，该数据类的数据内容与上图中的UI节点相对应，后面提到的数据节点代指该类
public class BaseData { /// 编辑器状态下排序 public int SortNum; /// 唯一ID public int ID; } public class CharacterData : BaseData { public string name; public CharacterType type; public DetialCharacterData detialData; } public class MainData { public Dictionary&lt;string, CharacterData&gt; CharacterDatas; } 除了需要编辑的数据类外，编辑器本身也需要设定缓存一组数据来维护界面显示的相关格式，如节点的位置、节点被选中的状态等状态。创建数据类命名为EditorNodeData，并代称节点编辑器数据，而关于类中相关字段的具体使用方式会在后面数据初始化时提到：
public class EditorNodeData { public int sortNum; public int DataID = 0; public bool isInstace; public bool isSelect; public Rect rect; } 二、将缓存数据初始化 开始编辑器界面绘制前，定义一些数据字段作为临时缓存使用， 并对数据做初始化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2574b1f0a368c835f059349ccdc06259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b24843f6bfd9194e9f2568b0d2b89fb/" rel="bookmark">
			springboot利用mybatis批量写入clickhouse报错及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot利用druid和mybatis批量数据写入clickhouse时，刚开始的时候，完全按照mysql的写法，出现无法写入的问题。经过不断的尝试，发现所使用的驱动包，驱动类配置以及sql写法上都需要特别注意，不然批量写入会抛出各种异常导致写入失败。
虽然clickhouse的官方说明中能够支持大部分的sql语法，在某些特定的场景下，比如批量写数据，还是需要做一些特别的配置。
这里用的clickhouse的版本是：version 22.2.2.1
1. 添加依赖 这个是可以实现批量写入的版本。
&lt;!--clickhouse--&gt; &lt;dependency&gt; &lt;groupId&gt;com.clickhouse&lt;/groupId&gt; &lt;artifactId&gt;clickhouse-jdbc&lt;/artifactId&gt; &lt;version&gt;0.3.2-patch8&lt;/version&gt; &lt;/dependency&gt; 刚开始的时候添加的是下面这个版本：
&lt;!-- &lt;dependency&gt; &lt;groupId&gt;ru.yandex.clickhouse&lt;/groupId&gt; &lt;artifactId&gt;clickhouse-jdbc&lt;/artifactId&gt; &lt;version&gt;0.2.4&lt;/version&gt; &lt;/dependency&gt; --&gt; 使用这个版本的时候，批量写入数据总是报错。
2. 配置连接信息 url: jdbc:clickhouse://192.168.17.81:8123/default username: username password: password # driverClassName: ru.yandex.clickhouse.ClickHouseDriver driverClassName: com.clickhouse.jdbc.ClickHouseDriver 之前配置为ru.yandex.clickhouse.ClickHouseDriver时，批量写入报错。
3. mapper.xml中的sql写法 &lt;insert id="insertBatchCkPerm" useGeneratedKeys="false" parameterType="java.util.List"&gt; insert into plat_access_perm(access_id, developer_id, developer_name, access_key, access_secret) FORMAT Values &lt;foreach collection="list" item="item" index="index" separator=","&gt; (#{item.accessId},#{item.developerId},#{item.developerName},#{item.accessKey},#{item.accessSecret}) &lt;/foreach&gt; &lt;/insert&gt; 这里需要特别说明的是：按照mysql的写法，只需要values关键字即可，但是这里使用values的时候，单条记录写入是可以的，但是多条记录就会报错，报的是空指针错误。需要修改为FORMAT Values
useGeneratedKeys="false" 设置时为了避免自动生成主键id，clickhouse不支持。
4. mapper接口的写法 public int insertBatchCkPerm(List&lt;PlatAccessPerm&gt; list); 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b24843f6bfd9194e9f2568b0d2b89fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0acfefbe7b20a84ed6484e3580869b6/" rel="bookmark">
			VMware 配置虚拟机固定IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、搭建VMnet8虚拟局域网 打开VMware软件，点击编辑，点击列表中的虚拟网络编辑器 进入虚拟网络编辑器页面 选择NAT模式 勾选将主机虚拟适配器连接到此网络 取消DHCP服务 子网IP和网关IP都先记下来 二、使用配置VMnet8虚拟网卡 安装VMware软件之后，就会有VMnet8这个虚拟网卡。进入我们自己电脑的 网络和Internet设置(右击网络图标)，进入更多网络适配器页面 就可以看到VMnet8这个虚拟网卡，我们首先配置一下网卡参数。右击VMnet8网卡，选择属性，双击IPv4协议进入编辑页面。 与上方图中网关一致 注意： 默认网关：这个是通过VMnet8搭建起来的虚拟网络的网关，就是编辑VMnet8虚拟网络时进行设置的网关地址，如果设置错误，宿主机访问不到虚拟机，虚拟机访问不到外网。 IP地址：这个地方设置的IP地址，是宿主机访问VMnet8局域网内虚拟机时，宿主机使用的IP地址，代表宿主机在VMnet8虚拟网络中的地址， 需要注意的是他并不是网关，并且不能使用已经分配给网关的地址。它需要单独占用一个VMnet8局域网内的主机地址，供宿主机使用。让VMnet8网络中的虚拟机可以看到宿主机，宿主机也可以看到虚拟机。 ———————————————— 三、CentOS系统配置 桥接模式网络配置 1、配置ip地址等信息在/etc/sysconfig/network-scripts/ifcfg-ens33 vi /etc/sysconfig/network-scripts/ifcfg-ens33 配置如下：（若原文件无引号，则不加引号，没有的就新增） TYPE="Ethernet" # 网络类型为以太网 BOOTPROTO="static" # 手动分配ip NAME="ens33" # 网卡设备名，设备名一定要跟文件名一致 DEVICE="ens33" # 网卡设备名，设备名一定要跟文件名一致 ONBOOT="yes" # 该网卡是否随网络服务启动 IPADDR="192.168.×.×" # 该网卡ip地址就是你要配置的固定IP GATEWAY="192.168.×.×" # 网关 NETMASK="255.255.255.0" # 子网掩码 DNS1="8.8.8.8" # DNS，8.8.8.8为Google提供的免费DNS服务器的IP地址 2 、 配置网络工作 在/etc/sysconfig/network文件里增加如下配置 NETWORKING=yes 3、配置公共DNS服务(可选)（不用选） 在/etc/resolv.conf文件里增加如下配置 nameserver 8.8.8.8 4、关闭防护墙 systemctl stop firewalld # 临时关闭防火墙 systemctl disable firewalld # 禁止开机启动 5、重启网络服务 service network restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c8144d08acae5d5b663c75c42ae0074/" rel="bookmark">
			python实现常见算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、o-1背包
代码实现 class Goods: def __init__(self, weight, value): self.weight = weight self.value = value self.priceRitio = weight/value def GetMaxValue(): value = 0 weight = 30 weightOfCurrent = 0 goods = [Goods(4, 3), Goods(2, 8), Goods(9, 18), Goods(5, 6), Goods(5, 8), Goods(8, 20), Goods(5, 5), Goods(4, 6), Goods(5, 7), Goods(5, 15)] goods.sort(key=lambda Goods: Goods.priceRitio) #按照重量/价值从小到大排序 for i in goods: if weightOfCurrent+i.weight &lt;= weight: #从小到大选择 value += i.value weightOfCurrent += i.weight else: break return value if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c8144d08acae5d5b663c75c42ae0074/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/68/">«</a>
	<span class="pagination__item pagination__item--current">69/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/70/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>