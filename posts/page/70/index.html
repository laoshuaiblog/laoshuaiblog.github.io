<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3011c25231d0693fa0d0ec73ccb163ec/" rel="bookmark">
			npm ERR! code ELIFECYCLEnpm ERR! errno 134
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==== JS stack trace ========================================= 0: ExitFrame [pc: 000002AACBF079E0] Security context: 0x00b4d151e6e9 &lt;JSObject&gt; 1: byteLength(aka byteLength) [000000CEB10F80D9] [buffer.js:~509] [pc=000002AACE049EB0](this=0x038bfc4826f1 &lt;undefined&gt;,string=0x00fee4577be1 &lt;Very long string[88972273]&gt;,encoding=0x00b4d153e311 &lt;String[4]: utf8&gt;) 2: arguments adaptor frame: 3-&gt;2 3: fromString(aka fromString) [0000025E642117B9] [buffer.js:~334] [pc=000002AACE2A0EF0](this=0x038b... FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 1: 00007FF774B6F04A v8::internal::GCIdleTimeHandler::GCIdleTimeHandler+5114 2: 00007FF774B4A0C6 node::MakeCallback+4518 3: 00007FF774B4AA30 node_module_register+2032 4: 00007FF774DD20EE v8::internal::FatalProcessOutOfMemory+846 5: 00007FF774DD201F v8::internal::FatalProcessOutOfMemory+639 6: 00007FF7752F2BC4 v8::internal::Heap::MaxHeapGrowingFactor+9556 7: 00007FF7752F10CB v8::internal::Heap::MaxHeapGrowingFactor+2651 8: 00007FF774EACA3B v8::internal::Factory::AllocateRawWithImmortalMap+59 9: 00007FF774EAF4ED v8::internal::Factory::NewRawTwoByteString+77 11: 00007FF774DC582B v8::internal::StringHasher::UpdateIndex+219 12: 00007FF774DEAB26 v8::String::Utf8Length+22 13: 00007FF774B3370C node::Buffer::New+4332 14: 000002AACBF079E0 npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3011c25231d0693fa0d0ec73ccb163ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a65c03831e959b37ae65d5e5fff747a/" rel="bookmark">
			坑3：jenkins中allure报告为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题如下：
解决方法：
allure-results是一个中间结果，里面只有数据，没有html报告
allure-reports是一个最终结果文件，里面是html文件
pytest test_allure_demo.py --alluredir ./report
–alluredir参数的作用是指出生成的报告文件夹
1. 查看控制台日志，检查是否读取到结果文件
首先我们要知道，allure生成报告有两步，第一步是生成json、txt这种结果文件。
第二步是根据生成的结果文件，去生成报告
所以是我们jenkins上读取结果文件设置地址不对，所以报告打开就是空的
2.我们在配置中设置读取结果文件的地址在这里，下面提示说要输入workspace的相对路径
那当前的workspace路径是什么呢？
看这里。这个就是
然后weatherInterface是我的jenkins的项目名称（你们可以打开你们自己的这个路径看看，然后下面的结构就清晰了）
注意：我是先进到了weatherInterface这个目录 ，使用的相对路径，是相对于jenkins的当前的workspace路径（即进到了：/root/jenkins_home/workspace/weatherInterface这个路径）
然后执行我的weather_test.py。那我生成的结果文件的路径就是 /root/jenkins_home/workspace/weatherInterface/allure-results/allure-report
然后我们设置读取结果文件的地址，以及存放报告的地址，就是这样
为什么要带上weatherInterface？是因为这里的workspace还是jenkins的workspace，并不是我执行py文件的路径。所以加上就可以了。
这样就可以读取到结果文件了。然后打开报告也ok了
————————————————
版权声明：本文为CSDN博主「SometimeSy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：jenkins生成allure报告，打开是空白的，日志提示allure-results does not exist_SometimeSy的博客-CSDN博客_jenkins生成allure报告为空
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2785b83a625429a590c96968a43fa833/" rel="bookmark">
			PyTorch1.5的下载安装，ERROR: Could not find a version that satisfies the requirement pytorch==1.5.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误提示：
ERROR: Could not find a version that satisfies the requirement pytorch1.5.1 (from versions: 0.1.2, 1.0.2)
ERROR: No matching distribution found for pytorch1.5.1
安装流程
下载whl 网址 ：
https://download.pytorch.org/whl/torch_stable.html
我这里需要pytorch==1.5.1
对应下载了
对应的版本下载如下图：
我将其保存在了一个指定的目录下
（我这里是 E:/pyorch_env/ 目录之下，保存了两个文件）
记住目录，打开终端，pip下载，注意使用镜像下载，可以加快下载速度
pip install E:/pyorch_env/torch-1.5.0+cpu-cp37-cp37m-win_amd64.whl -i http://pypi.mirrors.ustc.edu.cn/simple --trusted-host pypi.mirrors.ustc.edu.cn ——————————————————————————————————————————————
后续我又下载了py=3.8.0 &amp; torch=1.8.0 &amp; torchvision=0.9.0
对应下载
pip install D:\torch_vision_py8\torch-1.8.0+cpu-cp38-cp38-win_amd64.whl -i http://pypi.mirrors.ustc.edu.cn/simple --trusted-host pypi.mirrors.ustc.edu.cn pip install D:\torch_vision_py8\torchvision-0.9.0+cu111-cp38-cp38-win_amd64.whl -i http://pypi.mirrors.ustc.edu.cn/simple --trusted-host pypi.mirrors.ustc.edu.cn 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/017b1390735aa38dc81af0c042867f72/" rel="bookmark">
			CHERRY樱桃机械键盘按键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FN+F1：静音
FN+F2：音量减少
FN+F3：音量增大
FN+F4：灯光开关
FN+F5：灯光亮度调节
FN+F6：灯光亮度调节
FN+F7：灯光速度调节
FN+F8：灯光速度调节
FN+F8：锁定键盘中的窗口键
FN+F10：打开浏览器
FN+F11：打开我的电脑
FN+F12：灯光模式调节
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb90ad15fdb54a33a1e7dadace39a1a/" rel="bookmark">
			BSP概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BSP即Board Support Package，板级支持包。它来源于嵌入式操作系统与硬件无关的设计思想，操作系统被设计为运行在虚拟的硬件平台上。对于具体的硬件平台，与硬件相关的代码都被封装在BSP中，由BSP向上提供虚拟的硬件平台，BSP与操作系统通过定义好的接口进行交互。BSP是所有与硬件相关的代码体的集合。
一个成熟的商用操作系统，其被广泛应用的必要条件之一就是能够支持众多的硬件平台，并实现应用程序的硬件无关性。一般来说，这种无关性都是由操作系统实现的。
但对于嵌入式系统来说，它没有像PC机那样具有广泛使用的各种工业标准、统一的硬件结构。各种嵌入式系统各不同的应用需求就决定了它一般都选用各自定制的硬件环境，每种嵌入式系统从核心的处理器到外部芯片在硬件结构上都有很大的不同。这种诸多变化的硬件环境就决定了无法完全由操作系统来实现上层软件与底层硬件之间的无关性。
因此各种商用实时操作系统，都采用了分层设计的方法，它将系统中与硬件直接相关的一层软件独立出来，称之为Board Support Package，简称为BSP。顾名思义，BSP是针对某个特定的单板而设计的。如果没有单板支持软件包，则操作系统就不能在单板上运行。并且它对于用户（指开发者）也是开放的，用户可以根据不同的硬件需求对其作改动或二次开发。BSP在嵌入式系统中的角色，很相似于在PC系统中的BIOS和驱动程序的地位。
BSP的具体结构和组成根据不同的嵌入式操作系统而不同。BSP的开发要求设计人员具备软硬件方面的综合知识。
BSP软件与其他软件的最大区别在于BSP软件有一整套模板和格式，开发人员必须严格遵守，不允许任意发挥。在BSP软件中，绝大部分文件的文件名和所要完成的功能都是固定的。所以，BSP软件的开发一般来说都是在一个基本成型的BSP软件上进行修改，以适应不同单板的需求。 针对某类CPU的硬件单板，嵌入式操作系统(如vxWorks)通常提供有其DEMO板的BSP, 这些程序位于指定的目录之下。也就是我们所说的最小系统BSP。一般来说，我们在硬件系统设计好之后，都会先找到一个与自己系统相近的DEMO板BSP（最起码是使用相同的CPU）。并以此为基础,开发自己单板的BSP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f847c733aec58ce48c760cb4723e1a51/" rel="bookmark">
			Android MVVM架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MVC,MVP,MVVVM 1.1什么是MVVM 1.MVVM，是Model-View-ViewModel的简写，是M-V-VM三部分组成。它本质上就是MVC 的改进 版。MVVM 就是将其中的View 的状态和行为抽象化，其中ViewModel将视图 UI 和业务逻辑分 开，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。
2.MVVM采用双向数据绑定，view中数据变化将自动反映到viewmodel上，反之，model中数据变化 也将会自动展示在页面上。把Model和View关联起来的就是ViewModel。ViewModel负责把Model 的数据同步到View显示出来，还负责把View的修改同步回Model。
3.MVVM核心思想，是关注model的变化，让MVVM框架利用自己的机制自动更新DOM，也就是所 谓的数据-视图分离，数据不会影响视图。
如图(重点):
1.2 Android MVVM MVVM分为Model，View，ViewModel 三个部分
Model:数据层，包含数据实体和对数据实体的操作,和MVP的model没有区别。
View: 界面层，对应于Activity，XML，负责数据显示以及用户交互。相比MVP的view，这里面的 view视图数据一般是在xml中使用DataBinding进来双向绑定数据的。 ViewModel：关联层，作为中间桥梁 去通知model数据层处理数据业务，并将结果回调给 UI 层处 理 UI 逻辑。ViewModel中只有activity持有vm引用，vm是不持有view的引用的，所以vm的构造方 法中不能传入视图相关的对象。所以重点在于怎么通知view，可以通过观察者回调的方式。但是现 在一般是结合Jetpack来进行view的更新的。
2.MVVM项目框架 如图：
3 MVVM核心构成 3.1 DataBinding (重点)(详细讲解) 数据和UI双向绑定 3.2 LifeCycle 界面生命周期感知 3.3 ViewModel 业务逻辑 3.4 LiveData 可观察数据项 3.5 MVVM项目框架搭建 通用性的快速开发框架 可应用各项目中 4 DataBinding 4.1 DataBinding的简介 1.Data binding 在2015年7月发布的android Studio v1.3.0 版本上引入，在2016年4月Android Studio v2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f847c733aec58ce48c760cb4723e1a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98bb28f081cd35f9330362d4b5704b26/" rel="bookmark">
			大批量数据快速写入数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近由于项目需要存储传感器采集的海量数据，考虑使用clickhouse进行存储和分析。
于是打算做一下性能测试。做测试之前，肯定得有数据，所以就打算造些数据。于是编写java代码模拟一天的数据（约5千万条）插入。
首先是导入驱动
&lt;dependency&gt; &lt;groupId&gt;ru.yandex.clickhouse&lt;/groupId&gt; &lt;artifactId&gt;clickhouse-jdbc&lt;/artifactId&gt; &lt;version&gt;0.3.1&lt;/version&gt; &lt;/dependency&gt; 一开始使用拼接sql的方式，每个sql拼接18000条数据,sql语句大致如下
insert into tab_test values(*,*,*),(*,*,*) 然后通过如下方法执行
Statement.execute(sql); 执行一次插入需要4到5秒种，也就是一秒钟写入大概6K的数据，感觉这个写入速度有点低，照这个样子，一天的测试数据要好几个小时呢。
后来在网上找，看到有人用prepareStatement.executeBatch()来做，于是就想着试试看，最后测试结果，写入性能稳定在10W/s左右，一天的数据500多秒就写完了。
于是网上查了下原因，是因为prepareStatement采用的预编译机制，也就是数据库只编译一次sql，后面就只发送参数就可以了。而Statement.execute每次都要发送全量的sql语句，数据也要解析语句，所以性能就慢了。这个是jdbc的特性，对所有的数据库都这样，看来还是数据库基础不扎实啊。所以大家以后如果在mysql又大批量数据需要写入的时候，尽量采用prepareStatement来执行，不过要注意的是mysql4.1之前的版本事不支持prepare Statement特性的，使用prepareStatement反而会降低性能。
最后，在写入clickhouse数据的时候，最好采用批量数据插入，官方建议一次不少于1000条，不然性能很差。
完整代码如下
import ch.qos.logback.classic.Level; import ch.qos.logback.classic.Logger; import ch.qos.logback.classic.LoggerContext; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.StringUtils; import org.apache.http.client.utils.DateUtils; import org.slf4j.LoggerFactory; import ru.yandex.clickhouse.except.ClickHouseUnknownException; import java.net.SocketException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.Statement; import java.util.Date; import java.util.List; import java.util.Random; import java.util.UUID; @Slf4j public class ClickhouseJDBC { static { LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory(); List&lt;Logger&gt; loggerList = loggerContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98bb28f081cd35f9330362d4b5704b26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b2fa43264343e5cac700931aad33fd/" rel="bookmark">
			Java--Spring之AOP面向切面编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JDK动态代理 具体可参考之前博文 Java--JDK动态代理(AOP)
在这里只做简单说明
动态代理是指代理类在程序运行时进行创建的代理方式。这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据Java代码中的“指示”动态生成的。（动态代理中的代理类并不要求在编译期就确定，而是可以在运行期动态生成，从而实现对目标对象的代理功能）
相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数
动态代理又分为两种方式
（1）JDK动态代理：
使用java反射包中的类和接口实现动态代理的功能。反射包 java.lang.reflect , 里面有三个类 ： InvocationHandler , Method, Proxy
（2）Cglib动态代理：
一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。 通过继承目标类，在子类中重写父类同名方法，实现功能修改（重写的方法不能是final）
JDK原生动态代理
JDK原生动态代理主要是使用Java中的反射机制，使用了反射包 java.lang.reflect下的三个类
InvocationHandler , Method, Proxy
JDK动态代理步骤
（1）创建接口，定义目标类要完成的功能
（2）创建目标类实现接口
（3）创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能（调用目标方法，增强功能）
（4）使用Proxy类的静态方法，创建代理对象。 并把返回值转为接口类型
如下创建一个MyInvocationHandler
public class MyInvocationHandler implements InvocationHandler { //目标对象 private Object target; public MyInvocationHandler(Object target){ this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object res = null; System.out.println("执行了InvocationHandler中的invoke()方法：" + method.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b2fa43264343e5cac700931aad33fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/501e7ecd58e2f1da78ed05a883f68612/" rel="bookmark">
			spark on yarn运行日志查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 在webUI界面直接查看日志信息 进入8088端口可以查看日志信息，如下图：
2. 在服务器本地查看 根据applicationID在本地直接查看
yarn logs -applicationId appID #appID是实际的spark任务的id 3. yarn on cluster 和 yarn on client日志信息的差别 yarn on cluster
此模式下任务会提交到yarn，yarn会在集群中随机指定一个节点启动driver，执行日志只能在webUI界面查看。任务提交之后就跟提交程序的客户端无关了，该客户端关停了也不影响程序的执行。一般生产用此模式。yarn on client
此模式会在本地客户端启动一个driver，所以运行的日志信息和println的数据会显示在提交程序的客户端。所以此时该客户端的关停会直接影响程序，一般自己测试可以用此模式。 4. shell脚本提交spark程序，生成spark运行日志文件 生产环境下，spark submit命令经常会放在shell中去调起执行，这种情况下要怎样才能在shell中生成spark日志信息，写到具体的路径下呢？
我们可以将shell中的submit命令作如下的处理：
appId=` spark-submit \ --class cn.com.Test \ --master yarn \ --deploy-mode cluster \ /jarPath/test.jar 2&gt;&amp;1 | tee /dev/tty | grep -i "Submitting application" | grep -o application_.*[0-9] ` yarn logs -applicationId $appid &gt; /logPath/${appid}.log 上述的submit命令执行结束后，会将spark运行的程序写入需要的log路径下，日志名为appId.log
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa6a12a9677c9067b543a388ab5e451/" rel="bookmark">
			学习使用 Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目前我们的 前端项目和后端项目，都已经可以使用 Spug自动构建打包，配置完成后，前后端打包，只需要登陆网站，选择仓库的代码版本，进行打包构建，非常简单和方便。
我今天恰好碰到东哥，东哥仔细的给我讲了关于Docker在Spug的配置，并且花了1个多小时，在我身边完成了“前端自动化构建”。这个过程受益匪浅，为了更好的理解自动化构建，学习了一下Docker容器这个概念。
一、通过菜鸟教程学习使用Docker 1. 安装Docker //使用国内 daocloud 一键安装命令 curl -sSL https://get.daocloud.io/docker | sh 如果没有配置，就会默认安装，那么如何查看默认docker安装路径
输入：docker info 命令
在docker root 就可以看到安装目录
Docker Root Dir: /var/lib/docker （这里就是安装的目录）
Debug Mode: false Registry: https://index.docker.io/v1/
Labels: Experimental: false Insecure
Registries: 127.0.0.0/8
Live Restore Enabled: false
2. 启动Docker //启动 systemctl start docker 3. 查看Docker状态 和 版本 //状态 systemctl status docker //版本 docker version 4. 在Docker里添加Centos7 Docker 安装 CentOS | 菜鸟教程
5. 查看Docker容器运行信息 docker ps 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d42c7533eadeade477012bb8d2658d/" rel="bookmark">
			干了三年java外包，我转AI了....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 谈及到程序员外包这件事，我想我是比较有发言权的一个，即使我现在已经从一个外包公司的JAVA开发转行做人工智能算法。
我是2018年毕业的，一毕业找的第一份工作就是一家外包公司，主要做的是承接甲方的项目，按照客户的需求把代码写好，没日没夜的工作，拿到一点点的收入。
三年的CRUD，自身没有任何成长，头发倒是掉了不少。至于为什么外包公司不利于成长，因为一般来讲，外包公司对于甲方产品的研发不够谨慎，只要能够完成客户提出的需求即可，缺乏对于产品的设计和真正做出好产品的态度。当然这是外包公司性质决定的。
没办法，当时不想再安于现状，于是在和好友的一次促膝长谈之后，我觉得转AI算法方向。
从java程序员转AI这个方向绝对是正确的，也是一部分人的必经之路，因为java开发人员最终也一定会分流到很多个领域去，其中有一部分人就会往更高层次的人工智能方向走去，以突破现有的瓶颈。
如果要转ai算法方向，一定要提前布局以及规划学习路线，后面我会说到如何入门人工智能。
首先，要从一个机器学习框架入手，Spark-ml sklearn tensor flow,精通它的工程实现，不要管那么多内部细节，就像你做java调用api一样，要精通调用和参数传递，就可以很好的使用，而不用懂这个算法本身，现在大部分的AI公司也都是这样，能落地出结果就是首要目标;
然后，就是拼命积累实战经验，入行或者转行后，再做深挖，再做精通，有框架+实战经验做为基础就更加容易，而此时的薪资也一定会比你之前高很多以至于数倍了。
这里说到实战的项目经验，这个的重要性更比框架，学历更加重要，这是你未来能否进入著名公司，以及薪资能否和同行拉开差距的重要标准，此处没有捷径，必须要一个个项目的积累，虽然没有捷径，但是也有选择，比如你参与实训或者实习的企业?参与培训学习的机构?转行就业的公司?是否专门做人工智能机器人的？是否能学到真正的算法？能否接触到真正的机器人？这些都是非常关键的。
免费分享一些我整理的人工智能学习资料给大家，整理了很久，非常全面。包括一些人工智能基础入门视频+AI常用框架实战视频、图像识别、OpenCV、NLP、YOLO、机器学习、pytorch、计算机视觉、深度学习与神经网络等视频、课件源码、国内外知名精华资源、AI热门论文等。
下面是部分截图，文末扫码加我免费领取（AI技术问题我也可解答一二） 目录
一、人工智能免费视频课程和项目
二、人工智能必读书籍
三、人工智能论文合集
四、机器学习+计算机视觉基础算法教程
五、深度学习机器学习速查表（共26张）
学好人工智能，要多看书，多动手，多实践，要想提高自己的水平，一定要学会沉下心来慢慢的系统学习，最终才能有所收获。
点击下方名片，扫码免费下载文中资料。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54496ee0e8d67da8dba171ac333a2aa8/" rel="bookmark">
			STConvS2S: Spatiotemporal Convolutional Sequence to Sequence Network for weather forecasting 论文理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：
将机器学习模型应用于气象数据为地球科学领域带来了许多机会，例如更准确地预测未来的天气状况。近年来，使用深度神经网络对气象数据进行建模已成为相关研究领域。这些工作要么应用循环神经网络 (RNN)，要么应用一些混合 RNN 和卷积神经网络 (CNN) 的混合方法。在这项工作中，我们提出了 STConvS2S（时空卷积序列到序列网络），这是一种仅使用卷积层来学习空间和时间数据依赖关系的深度学习架构。我们提出的架构解决了卷积网络使用历史数据预测序列的两个限制：（1）它们在学习过程中违反了时间顺序，（2）它们要求输入和输出序列的长度相等。使用来自南美的气温和降雨数据的计算实验表明，我们的架构捕捉时空背景，并且它优于或匹配用于预测任务的最先进架构的结果。特别是，我们提出的架构的一种变体在预测未来序列方面比用作基线的基于 RNN 的模型快 23%，训练速度快 5 倍。
重点：
我们没有对 3D 卷积层采用传统的 t d d 内核，其中 d 和 t 分别是空间 (H W) 和时间 (T) 维度的内核大小，我们使用从 R( 2 + 1) D 网络，由 Tran 等人提出。
[24]。分解后的内核 1 d d 和 t 1 1 将一层的卷积操作分成两个连续的操作，在他们的工作中称为空间卷积和时间卷积。在我们的新架构中，我们采用了不同的方法：每个卷积层内的操作不是连续的。相反，分解后的内核被分成两个块，赋予它们特定的学习技能。时间块在其层中应用 t 1 1 内核以仅学习时间依赖关系，而下一个组件空间块使用 1 d d 内核封装空间依赖关系。图 2 示意性地说明了这三种方法之间的区别。
分析：
主要提出一种处理时间的卷积方法 参考文献24提出 使用的数据集也是再分析数据集
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf22bd5f6a33d4f3e2e8477f9b3bcac8/" rel="bookmark">
			Vscode ssh远程连接失败解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： Vscode 通过remote - ssh连接远程ubuntu时出现"192.168.x.x" has fingerprint “SHA256:…”，如下图所示：
按照提示选择“continue”，然后输入正确密码却显示Permission Denied（以往连接都很顺利，没有出现过问题）
尝试根据报错提示找到解决问题的办法：
从输出的错误提示显示似乎是无法添加信息到用户目录的.ssh/konwn_hosts文件中。通过查询了解了一下这个文件的作用：ssh会把你每个你访问过计算机的公钥(public key)都记录在 ~/.ssh/known_hosts。
接着直接打开这个文件查看后里面发现里面记录了以前连接成功过的一些ubuntu主机的公钥，但确实没有关于我要访问的这个ip的公钥。于是继续搜索解决方法，按照网上有些博客说的：将.ssh/known_hosts文件删除然后重新连接，结果还是没有解决问题。
还有博客说是拒接连接可能是因为.ssh文件夹的权限问题，要将远程主机的ssh文件夹权限改为755或者700，修改权限命令：
cd /etc sudo chmod 755 ssh 按照这个方法修改后依旧无法连接成功
最终发现是环境配置的问题，本机同时装有openssh和git时，就会引起环境冲突，因为git本身自带了ssh。可以在git bash中输入 where ssh 查询是否同时装有openssh和git
解决办法：
修改Vscode的默认ssh命令路径，改成git自带的ssh路径。打开Vscode，点击左下角管理-&gt;设置，搜索remote ssh Default Forwarded Ports，点击 在settings.json中编辑
在文件中添加一条设置，指定ssh的默认路径为Git下的ssh
"remote.SSH.path": "（你的Git安装路径）\\usr\\bin\\ssh.exe" 修改完重新测试就成功连接了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec7d5079835fcfce8d460b9ff609ed6/" rel="bookmark">
			seata:Error creating bean with name ‘globalTransactionScanner‘ defined in class path resource
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误描述 产生原因: 我idea默认用的是jdk17，在jdk17中很多类都弃用或者删了，切换成jdk8即可。
在spring整合seata时出现的错误，错误如下：
Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2022-08-09 14:03:16.565 ERROR 15912 --- [ main] o.s.boot.SpringApplication : Application run failed org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'globalTransactionScanner' defined in class path resource [io/seata/spring/boot/autoconfigure/SeataAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [io.seata.spring.annotation.GlobalTransactionScanner]: Factory method 'globalTransactionScanner' threw exception; nested exception is java.lang.ExceptionInInitializerError at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:658) ~[spring-beans-5.3.22.jar:5.3.22] at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ec7d5079835fcfce8d460b9ff609ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f6af0893c0118521cc275f29a3d11e8/" rel="bookmark">
			【Collectors.toMap key重复会报错】Collectors.toMap Duplicate key 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息 Collectors.toMap Duplicate key 1 看源码发现，默认mergeFunction使用的throwingMerger() public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper) { return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new); } throwingMerger遇到重复就直接报错了 private static &lt;T&gt; BinaryOperator&lt;T&gt; throwingMerger() { return (u,v) -&gt; { throw new IllegalStateException(String.format("Duplicate key %s", u)); }; } 所以需要自定义mergeFunction public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f6af0893c0118521cc275f29a3d11e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c04cc84c6a689e71a87335b3cb39f4/" rel="bookmark">
			Django Web 项目在Linux环境的在线部署（补充记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境介绍：
系统：CentOS 8 64位
工具：Nginx + uWSGI
语言：python
框架：Django
数据库：Mysql
上篇记录的是离线环境下的部署，本篇对在线环境下部署项目做个记录：
软件版本对应：
Nginx --- 1.20.2
python --- 3.10.4
Django --- 4.0.4
MySQL --- 5.7.37
一、相关软件安装：
在线环境下相关软件都使用 yum 进行安装，便以版本以及软件依赖管理，首先使用yum对系统内核及软件方面做个更新
由于centos 版本的原因之前的源已经搬家了需要更改yum源 手动去修改容易出问题，使用 sed 工具统一替换修改：
sed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-*
sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-*
修改后 sudo yum update 等待更新完成
1、下载安装 python
系统默认安装了3.6.8
而 yum 源中并没有 python-3.10.4 的 rpm 包，最高的就是python39,所以下载源码 python-3.10.4安装
解压、编译安装
安装依赖：
sudo yum install libffi-devel gdbm-devel libtirpc-devel openssl-devel readline-devel sqlite-devel python3-pyOpenSSL tk-devel
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6c04cc84c6a689e71a87335b3cb39f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/094b303f39cc4f7c35c82202a564ff80/" rel="bookmark">
			stm32的timer-trgo &#43; DMA &#43; DAC 播放WAV格式音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、考虑到stm32F103的flash大小有限，所以音频数据存在spi-flash中，WAV文件有6段语音。合成在一起大概有1.3M(客户给的文件)。所以用Audition软件把WAV文件转换成8k采样频率和8位数据格式(PS：音质效果还可以),文件大小变为126k，spi-flash有4M字节, 完全可以存下。
2、考虑到CPU的效率问题，采用TIMER+DMA的方式输送音频数据，下面贴出DAC的配置，采用的是DAC的通道1，即对应的PA4引脚，下面贴出DAC配置代码。
GPIO_InitTypeDef GPIO_InitStructure; DAC_InitTypeDef DAC_InitStructure; uint8_t i; RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA ,ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4; //| GPIO_PIN_5; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); DAC_InitStructure.DAC_Trigger = DAC_Trigger_T5_TRGO; // 不生成波形 DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None; DAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0; // 输出缓存开启 DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable; DAC_Init(DAC_Channel_1, &amp;DAC_InitStructure); // PA4 DAC_DMACmd(DAC_Channel_1, ENABLE); DAC_SetChannel1Data(DAC_Align_8b_R, 0); //8位右对齐数据格式设置DAC 值 说明: DAC触发信号配置为定时器5的TRGO触发, 开启DAC输出缓存功能，使DAC驱动增大。
3、下面是播放音乐的详细代码
/*************************************************************************************** 函数名称: void play_music(uint8_t data) 函数功能: 播放音乐函数 输入参数: 第几段音乐 返 回 值: 无 ***************************************************************************************/ void play_music(uint8_t data) { uint32_t play_addr, play_len, len; uint32_t file_addr, file_len; //================================================================================== //================================================================================== file_addr = music_file_offset(data, &amp;file_len, &amp;play_len); if (file_len == 0) return; play_addr = file_addr + sizeof(wav_typedef); //================================================================================== // dma-dac输出音乐数据 //================================================================================== while (play_len !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/094b303f39cc4f7c35c82202a564ff80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f13557098af0e1c1e7892309b7106b1/" rel="bookmark">
			mac m1 用idea写java非常卡？这样设置直接起飞！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里目前只针对mac 是 m1的，因为我的也是，有问题的小伙伴也可以在下面进行评论
文章目录 查看电脑配置idea类型jdk选择 查看电脑配置 首先我们看一下电脑是不是m1的。
比如我这个就是 m1的。
idea类型 那么对应的idea也有专门为m1 准备的。
去官网下载：https://www.jetbrains.com/zh-cn/idea/download/#section=mac
Apple M1芯片选择 Apple Silicon
Intel 芯片选择 Intel
选择的版本为VM这的。
jdk选择 其次我们还应该选择对应的jdk版本。
Apple M1芯片需要选择后边 aarch64 的JDK版本
下载完成之后，复制 JAVA_HOME 地址配置到自己的终端里，比如 ~/.zprofile 或者 ~/.zshrc
export JAVA_HOME=/Users/oker/Library/Java/JavaVirtualMachines/azul-1.8.0_312/Contents/Home 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b2086e8a96073137de21c5385eec1e2/" rel="bookmark">
			零知识证明——zkSNARK证明体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本笔记整理摘录自Steven Yue大佬
三个核心算法：
setup约定电路，生成随机参数
prove：证明方生成零知识证明
verify：验证方进行验证
完整性：
知识证明：（非常关键）
证明，证明方确实有一些我们不知道的信息，也就是这个w确确实实存在
简短证明：简短高效
零知识：公有输入x和证明pi不能暴露w
PCP定理(概率可验证定理） 所有NP难问题，都可以通过随机抽样，通过随机验证方法证明
不是直接看pi了，只能在里面抽取k位
总的来说就是抽查，抽查的正确次数越多，作假的可能性越低（有点假设检验内味了）
Kilian SNARK PCP可能有庞大的只读存储区域
我们将readonly那里编程一个commitment
证明方展示数据的时候只需要附带一个Merkle Proof证明自己提交的数据确实是在pi中的即可
这样就可以避免存储大量的pi信息
非交互的Killian SNARK 证明方在提交证明的时候验证方无需在线，它可以在后面随机事件点来验证
需要Fiat-Shamir-Heuristic，它可以把任何交互式的随机验证协议转换为非交互式的
首先需要一个安全哈希函数H（随机预言机，无论输入的是什么，输出的值我们都可以看作是一个和输入没有关联的随机数）
改造的关键就是把验证方的随机值依赖于安全哈希函数来生成
LCPC（线性） 两个d阶的不同系数的多项式，最多只会有d个点重合
通过把证明的值当作多项式的系数，然后验证多项式在某个点的值是否相等即可
因此我们把SNARK转成多项式的形式
但是电路很难变成多项式的形式，所以需要一个叫做R1CS的程序矩阵
多项式插值，范德蒙德多项式，还原多项式的每一项系数
构造成多项式子P, Q, R
证明P® * Q® = R®
总结 PCP定理是通过随机抽查的方法来快速验证任何NP问题的解。
LPCP是约束版的PCP，讲了通过随机抽查多项式取值的方法来快速验证多项式的系数。
Fiat-Shamir Heuristic可以把一个交互式协议变成一个非交互式协议。
从一个数学运算电路出发，变换成R1CS程序矩阵之后，可以最后还原成多项式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f330653332f25cf9b96a63e00fec1f/" rel="bookmark">
			nginx安装http_ssl_module模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章是基于已经安装好了nginx的情况下补充安装nginx的其它模块
如果你在nginx.conf的配置文件中用到ssl，但是安装的时候又没有开启SSL模块，启动则会报错，提示如下错误：
nginx: [emerg] the “ssl” parameter requires ngx_http_ssl_module in /usr/local/nginx/conf/nginx.conf:xxx
nginx缺少http_ssl_module模块，编译安装的时候带上–with-http_ssl_module配置就行了。
本场景是服务器已经安装过nginx，但是未安装http_ssl_module。
1.进入到源码包，如： cd /data/zhang/nginx-1.23.1
2、使用./configure 命令 解释：–prefix=后面是指定文件目录 --with-http_stub_status_module --with-http_ssl_module是需要安装的模块
./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module
3、使用make命令安装 make
注意：不需要执行make install，否则就覆盖安装了。
4、备份原有的nginx，如： cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx_bak
5、然后将刚刚编译好的nginx覆盖掉原有的nginx（nginx需要停止） cp /data/zhang/nginx-1.23.1/objs/nginx /usr/local/nginx/sbin/
6、查看安装情况： /usr/local/nginx/sbin/nginx -V
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/69/">«</a>
	<span class="pagination__item pagination__item--current">70/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/71/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>