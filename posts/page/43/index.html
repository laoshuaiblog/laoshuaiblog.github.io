<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23117ce30b1472e7f434ba3d311e8e58/" rel="bookmark">
			ES6新特性--模块化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.模块化概述
模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。
2.模块化的好处
使用模块化有以下的几种优点:
(1).防止命名冲突
(2).代码复用
(3).高维护性
3.ES6之前的模块化规范有:
(1) CommonJS =&gt; NodeJS、Browserify
(2) AMD =&gt; requireJS
(3) CMD =&gt; seaJS
4.模块化相关的语法
模块功能主要由两个命令构成：export 和 import。
其中:
export 命令用于规定模块的对外接口。
import 命令用于输入其他模块提供的功能。
5.模块化应用示例--暴露数据汇总
(1).基本使用
创建一个名称为test.js的文件，如下所示:
//分别暴露 export let stu = '张三'; export function play() { console.log("we can playGame"); } 然后在页面中引入使用
&lt;script type="module"&gt; //模块化的引入 import * as st from "./js/test.js"; console.log(st); &lt;/script&gt; (2).暴露的方式2
let stu = '李四'; function play() { console.log("wo should study hard"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23117ce30b1472e7f434ba3d311e8e58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9195d28cb120607ef6b58306a001df18/" rel="bookmark">
			记一次愚蠢的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用DataGrip的时候,这里老是爆红
并且该表有这个字段
最后在上边找到了
问题是这句创建这个表的sql, 只写了固定内容没有添加其他字段, 其他字段是之后加的, 两句在同一个sql 文件中
注释了创建表的sql就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ee424e2ea86d42986cf45f5529e443/" rel="bookmark">
			SSH连接出现错误 WARNING REMOTE HOST IDENTIFICATION HAS CHANGED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、原因 出现如下图错误，其原因两个：
1、黑客攻击
2、host key 改变（一般重装系统出现）
本文出现问题是第二个原因，重装系统导致 host key 改变
二、解决 有三种方式：
1、找到 know_hosts 位置（上图红色框就是），找到有问题的 ip（10.7.67.43）所在行删除
vim know_hosts 2、找到 know_hosts 位置，对所有的进行删除
rm -rf know_hosts 3、移除有问题的 ip key
ssh-keygen -R 10.7.67.43 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35fcd9317b1c8ddec96c5372534dc57d/" rel="bookmark">
			E8267D 是德科技矢量信号发生器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述 最先进的微波信号发生器 安捷伦E8267D PSG矢量信号发生器是业界首款集成式微波矢量信号发生器，I/Q调制最高可达44 GHz，典型输出功率为+23 dBm，最高可达20 GHz，对于10 GHz信号，10 kHz偏移时的相位噪声为-120 dBc/Hz。除了高性能微波源的高输出功率和出色的相位噪声之外，它还具有先进的宽带内部基带发生器，能够灵活地回放任意波形或产生复杂的实时信号。E8267D PSG还内置宽带I/Q调制器，可提供高达2 GHz的RF调制带宽，是安捷伦N6030A独立宽带任意波形发生器的完美补充，可用于最高1 GHz RF带宽的I/Q波形模拟。这一突破性的集成矢量功能仅在E8267D PSG中提供，极大地简化了复杂调制信号的产生，适合航空航天、国防、卫星通信和宽带无线领域的设计和制造测试应用。
定制PSG以满足您的需求 针对当今的RF和微波测试应用完全定制PSG，同时在未来需求变化时轻松升级。从各种可选增强功能中进行选择，以配置E8267D PSG，用于从失真测试到基带编码算法开发和高级数字微波收发器设计验证的各种应用。
信号特征 250 kHz至20、31.8或44 GHz(0.001Hz分辨率)。可扩展至75、90、110、140、220、325或500 GHz毫米波源模块。0.4至20 GHz范围内+23 dBm，40 GHz输出功率时+18 dBm(典型值)160 MHz(可扩展至2 GHz)射频调制带宽带UNY选项的业界最佳单边带相位噪声:对于1 GHz信号，10 kHz偏移时为-143 dBc/Hz(典型值) 调制和扫描 调幅、调频、调幅和脉冲询问、FSK、MSK、PSK、QAM、自定义I/Q步进、列表和斜坡扫描频率和功率使用PSA系列选件215进行源控制 基带生成和信号创建 内部基带发生器(80 MHz RF带宽):任意波形和实时I/Q兼容宽带(1 GHz) N6030A任意波形发生器创建参考信号:雷达，多频音，NPR，自定义调制，无线局域网，全球定位系统，MATLAB和更多-信号创建利用N5106A PXB基带发生器和通道仿真器实现多通道基带产生、数字I/O、MIMO衰落和RF至RF衰落 自动化和通信接口 局域网和GPIBSCPI和IVI-COM驱动程序向后兼容所有PSG信号发生器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98533fd021137288f1f8ffac46cbe56a/" rel="bookmark">
			git提交规范示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git规范 1、提交注释的格式 格式：(type): (subject) 注释包括2部分：类型(type)和主题(subject)。类型表示提交的种类，主题简要描述提交修改的内容。 例如：feat: 添加用户登录模块。 2、type类型 type类型可以根据具体情况进行适当的增删改，下面是一些常用的type类型： （1）feat：新功能（feature）。 （2）fix：修复bug。 （3）docs：文档（documentation）修改。 （4）style：格式（不影响代码运行的变动）。 （5）refactor：重构（即不是新增功能，也不是修改bug的代码变动）。 （6）perf：优化相关，比如提升性能、体验。 （7）test：增加测试。 （8）chore：构建过程或辅助工具的变动。 3、subject主题 subject主题是提交注释的核心部分，它应尽量简单、清晰、易于理解。以下是几个subject的示例： （1）feat: 添加用户登录模块。 （2）fix: 修复用户注销失败的问题。 （3）docs: 更新用户手册。 4、正文 注释正文可以更详细地说明代码修改细节和原因，如果有需要可以单独占用一行注释。 正文应该在注释首行下空一行，以增加可读性。 5、示例代码 // commit f0b9a2e feat: 添加了忘记密码功能 为用户提供重置密码的选项，以便于在忘记密码时可以通过邮箱的方式来进行重置操作。 - 添加忘记密码的路由 - 添加忘记密码页面的模板和样式 - 实现了发送邮件功能，并同步将信息存入数据库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e3004a280ef869d5190c2b85bdc2ed/" rel="bookmark">
			python&#43;pyecharts&#43;flask&#43;爬虫实现实时天气查询可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简介 本项目使用python语言编写，采用Flaskweb框架来实现前后端交互，利于开发，维护，前端使用Html和jQuery处理事件，发送数据等，后端采用requests库，BeautifulSoup库实现爬取中国气象局的数据，清洗转化成对应表格数据格式，再使用pyecharts绘制图形，返回给前端页面实现实时展示，注意运行本项目需要联网！！！
二、项目演示 输入你要查询的城市，点击搜索即可，由于网速，pyecharts的图形渲染等因素，图形展示需等待几秒才出现。
注意：水球图的渲染有时出不来，可多次点击搜索即可，我是这样的啦！！（与pyecharts图形渲染有关）
三、项目的实现 1.项目包结构展示： 其中app.py为项目的启动文件及路由，templates包存放前端页面的，service包存放后端逻辑代码venv为排除目录（没啥用可不创建），包可以自己标记为对用的资源目录，我没有使用flask模板创建，而是自己标记的
创建好包就可以书写代码啦！！！
2.Service包代码编写 2.1.WeatherDate(爬取天气数据) import sys import pandas as pd import requests from bs4 import BeautifulSoup # 请求头可写，但我看没报错，就没写 headers = { 'user-agent': '', 'Cookie': '' } # 列表划分，例如[1,2,3,4]=&gt;[[1,2],[3,4]],目的适应pyecharts数据 def chunk_list(lst, size): return [lst[i:i + size] for i in range(0, len(lst), size)] # 数据图一的部分数据列表 def data1(soup): seven_dayList = [i.text.strip().replace(' ', '').replace('\n', '') for i in soup.select('.day-item')] temp = [] # 数据清洗 j = 0 for i in seven_dayList: if j % 10 == 0: temp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59e3004a280ef869d5190c2b85bdc2ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf6df95cfbc8c0bb10d25dbadf19302/" rel="bookmark">
			数据结构初阶--带头双向循环链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.带头双向循环链表的定义
二.带头双向循环链表的功能实现
2.1.带头双向循环链表的定义
2.2.带头双向循环链表的结点创建
2.3.带头双向循环链表的初始化
2.4.带头双向循环链表的打印
2.5.带头双向循环链表的判空
2.6.带头双向循环链表的尾插
2.7.带头双向循环链表的头插
2.8.带头双向循环链表的尾删
2.9.带头双向循环链表的头删
2.10.带头双向循环链表的在pos位置之前插入
2.11.带头双向循环链表的删除pos位置的结点
2.12.带头双向循环链表的求链表长度
2.13.带头双向循环链表的销毁
2.14.完整程序
List.h
List.c
test.c
三. 顺序表和链表的比较
逻辑结构
存储结构
基本操作
创建
销毁
增加与删除
查找
一.带头双向循环链表的定义 循环单链表虽然能够实现从任一结点出发沿着链能找到其前驱结点，但时间耗费是O(n)。如果希望从表中快速确定某一个结点的前驱，另一个解决方法就是在单链表的每个结点里再增加一个指向其前驱的指针域prior。这样形成的链表中就有两条方向不同的链，称之为双(向)链表。
与单链表类似，双链表也可增加头结点使双链表的某些运算变得方便。同时双向链表也可以有循环表，称为双向循环链表。
由于在双向链表中既有前向链又有后向链，寻找任一结点的直接前驱结点与直接后继结点都变得非常方便了。
二.带头双向循环链表的功能实现 2.1.带头双向循环链表的定义 //定义 typedef int LTDataType; typedef struct ListNode { struct ListNode* next; struct ListNode* pre; LTDataType data; }LTNode; 与单链表的定义不同，带头双向循环链表要定义两个指针：前驱指针pre和后继指针next。前驱指针pre用于指向当前结点的上一个结点，后继指针next用于指向当前结点的下一个结点。
2.2.带头双向循环链表的结点创建 LTNode* BuyListNode(LTDataType x) { //动态开辟一个结点node LTNode* node = (LTNode*)malloc(sizeof(LTNode)); //判空 if (node == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf6df95cfbc8c0bb10d25dbadf19302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ef0d4477b2ffaeb9c508a84d15234fb/" rel="bookmark">
			azure data studio SQL扩展插件开发笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node.js环境下拉取脚手架 npm install -g yo generator-azuredatastudio yo azuredatastudio 改代码 运行 调试扩展，在visual studio code中安装插件即可
然后visual studio code打开进行修改运行即可
image.png 运行后自动打开auzre data studio了，
下面是我开发的扩展，
image.png 打包成vsix 下面是我的存储过程转sql的包https://github.com/lozn00/AzureSQLProcConvertSQL/raw/master/StoredProcedureConverter-0.0.1.vsix
npm install -g @vscode/vsce``` vsce package 发布市场 官网的介绍
若要将新扩展发布到 Azure Data Studio，请执行以下操作：
将扩展添加到扩展库。
我是没看懂泽呢么个添加扩展库方法，我打开这个json里面有Microsoft.AzureDataStudio.DownloadPage，我进行x之后修改提交给他们审核？？没明白，懂得朋友吐槽下
我们目前不支持托管第三方扩展。 Azure Data Studio 不会下载扩展，但提供了浏览到下载页面的选项。 若要为扩展设置下载页，请设置资产“Microsoft.AzureDataStudio.DownloadPage”的值。
针对发布/扩展分支创建 PR。
向团队发送评审请求。
你的扩展将接受评审并添加到扩展库中。
2023-8-24 13:58:16
通过PR github项目进行调整，成功上架
image.png 更多参考https://learn.microsoft.com/zh-cn/sql/azure-data-studio/extensions/extension-authoring?view=sql-server-ver16
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc06b8c2ee38002d8673fb34ea2754c/" rel="bookmark">
			nginx服务启动之后关闭不了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决nginx服务器启动后关不掉的问题 nginx服务器启动后关不了原因解决方法 nginx服务器启动后关不了 使用./nginx -s stop命令关闭nginx服务器，发现nginx服务没有成功停掉，进入http://127.0.0.1/还是正常显示
再次./nginx -s stop或./nginx -s quit命令，报错
nginx: [error] CreateFile() “D:\newFold\nginx-1.25.2/logs/nginx.pid” failed (2: The system cannot find the file specified)
原因 nginx启动了多个，但只关闭了一个
解决方法 命令行中输入以下内容
taskkill /f /t /im nginx.exe 强制终止运行中的 nginx.exe 进程及其所有子进程
成功停止服务器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7079aac5a7a53e686a2d579b6567ba70/" rel="bookmark">
			vscode插件开发笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://code.visualstudio.com/api/get-started/your-first-extensionnpm install -g yo generator-codeyo code
正常开发选择ts或者js
结果如下，package.json 的contributes.commands节点控制命令生命，
contributes.menus定义菜单
extension.ts里面注册事件
export function activate(context: vscode.ExtensionContext) { context.subscriptions.push(vscode.commands.registerCommand('extension.sqltool.execSql', () =&gt; { // vscode.window.showInformationMessage('not implemention!'); const editor = vscode.window.activeTextEditor; if (editor) { const document = editor.document; const inputText = document.getText(); editor.edit(editBuilder =&gt; { const start = new vscode.Position(0, 0); const end = new vscode.Position(document.lineCount, 0); const range = new vscode.Range(start, end); editBuilder.replace(range, '处理后的结果'); }); } })); } image.png image.png tsc -watch -p .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7079aac5a7a53e686a2d579b6567ba70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40bb6c8788aa8f26372345816e80dc95/" rel="bookmark">
			js基础（查漏补缺版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只记录了不了解的知识
有兴趣可以详细了解一下JavaScript 基础知识
一、类型 1. BIgInt BigInt 用于任意长度的整数。数字后面带n 例如 10n BigInt 不支持一元加法不可以把 bigint 和常规数字类型混合使用 const a = 1234567890123456789012345678901234567890n //1n const b = BigInt（1） //1n 可以进行数学运算,比较运算符 除法 5/2 的结果向零进行舍入，舍入后得到的结果没有了小数部分。对 bigint 的所有操作，返回的结果也是 bigint。 由于 number 和 bigint 属于不同类型，它们可能在进行 == 比较时相等，但在进行 ===（严格相等）比较时不相等当在 if 或其他布尔运算中时，bigint 的行为类似于 number。 console.log(1n + 3n) //4n alert(1n + 3n);//4 alert(5n / 2n); // 2 alert( 1 == 1n ); // true alert( 1 === 1n ); // false alert( 2n &gt; 1 ); // true 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40bb6c8788aa8f26372345816e80dc95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7114f7cb62a09b6160904547e2a63337/" rel="bookmark">
			asp.net docker编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DockerFile
# 使用官方 .NET SDK 作为基础镜像 FROM mcr.microsoft.com/dotnet/sdk:7.0 AS build-env WORKDIR /app # 将项目文件复制到镜像中 COPY . ./ ARG build_channel=XX RUN dotnet publish -c $build_channel -o /app # 构建运行时镜像 FROM mcr.microsoft.com/dotnet/aspnet:7.0 WORKDIR /app COPY --from=build-env /app. # 启动应用程序 ENTRYPOINT ["dotnet", "webapi.dll"] 如果包含aot需要加上这玩意
#RUN dotnet tool install -g dotnet-runtime # 将项目文件复制到镜像中 COPY . ./ # AOT #ENV PATH="${PATH}:/usr/local/bin" RUN apt-get update &amp;&amp; apt-get install -y gcc g++ zlib1g-dev\ &amp;&amp; export PATH="${PATH}:/usr/local/bin" 编译
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7114f7cb62a09b6160904547e2a63337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ce3bd890576a5411843cb59ac84d0a/" rel="bookmark">
			vue3中使用mock.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是mockjs Mock.js 是一个用于生成随机数据的模拟数据生成库。它可以帮助开发人员在前端开发中创建模拟接口，以便进行测试和开发。
以下是 Mock.js 的一些主要功能和用法：
生成随机数据：Mock.js 提供了丰富的数据模板语法，可以根据指定的规则生成各种类型的随机数据，包括数字、字符串、布尔值、日期等。拦截 Ajax 请求：使用 Mock.js，你可以拦截前端的 Ajax 请求，并根据模板定义生成模拟数据返回给前端，以模拟后端接口的行为。生成随机数据集合：Mock.js 可以生成符合特定格式的大量随机数据，例如生成一个包含多个用户、文章或其他实体的数据集合。支持自定义扩展：Mock.js 允许你自定义扩展方法，从而根据需要生成符合特定规则的数据。 使用 Mock.js，你可以在前端开发中快速创建模拟接口，节省后端开发的时间，加快前端开发的速度。它被广泛应用于前后端分离的项目，以及进行单元测试和功能开发时的数据模拟。
如何使用mockjs 安装mockjs 与 axios (mockjs用来模拟数据，axios用来发起请求）
npm install mockjs axios创建模拟接口，在你的 Vue 3 项目中，创建一个单独的文件来定义和管理模拟接口。例如，你可以在 src/mocks 目录下创建一个 mock.js 文件。在 mock.js 文件中，可以编写模拟接口的代码。以下是一个简单的示例： import Mock from 'mockjs'; // 使用 Mock.js生成随机数据 export const lineData = Mock.mock({ 'list|5': [{ 'id|+1': 1, 'name': '@cname', 'age|18-60': 1, 'email': '@email' }] }); 在你的 Vue 3 组件中，创建一个 mocks 目录，并在其中创建一个mocks/mockInterceptor.js文件。在 mockInterceptor.js 文件中，你可以使用 axios 拦截请求并返回模拟数据。例如，拦截请求url为’/api/lineData’与请求方法为’get’得请求，返回mockdata.js中生成得模拟数据。 import { lineData} from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ce3bd890576a5411843cb59ac84d0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6dee52624c0c5ab8477e094ff48d0ca/" rel="bookmark">
			首页模块丨前端uniapp微信小程序项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小兔鲜儿 - 首页模块 涉及知识点：组件通信、组件自动导入、数据渲染、触底分页加载、下拉刷新等。
自定义导航栏 参考效果：自定义导航栏的样式需要适配不同的机型。
操作步骤
准备组件
隐藏默认导航栏，修改文字颜色
样式适配 -&gt; 安全区域
静态结构
新建业务组件：src/pages/index/componets/CustomNavbar.vue
&lt;script setup lang="ts"&gt; // &lt;/script&gt; &lt;template&gt; &lt;view class="navbar"&gt; &lt;!-- logo文字 --&gt; &lt;view class="logo"&gt; &lt;image class="logo-image" src="@/static/images/logo.png"&gt;&lt;/image&gt; &lt;text class="logo-text"&gt;新鲜 · 亲民 · 快捷&lt;/text&gt; &lt;/view&gt; &lt;!-- 搜索条 --&gt; &lt;view class="search"&gt; &lt;text class="icon-search"&gt;搜索商品&lt;/text&gt; &lt;text class="icon-scan"&gt;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;style lang="scss"&gt; /* 自定义导航条 */ .navbar { background-image: url(@/static/images/navigator_bg.png); background-size: cover; position: relative; display: flex; flex-direction: column; padding-top: 20px; .logo { display: flex; align-items: center; height: 64rpx; padding-left: 30rpx; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6dee52624c0c5ab8477e094ff48d0ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf71ba0b238f7025c6f8290d5266eb8f/" rel="bookmark">
			clickhouse-数据导入导出方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 clickhouse有多种数据的导入导出方式，可以灵活使用，下面对这些方式分别做些介绍，导入导出的写法与格式和格式设置有关。
二、导入 1.从s3导入 详情可查看官网，也可以在这里获取数据集
-- 建库建表 CREATE DATABASE git; CREATE TABLE git.commits ( hash String, author LowCardinality(String), time DateTime, message String, files_added UInt32, files_deleted UInt32, files_renamed UInt32, files_modified UInt32, lines_added UInt32, lines_deleted UInt32, hunks_added UInt32, hunks_removed UInt32, hunks_changed UInt32 ) ENGINE = MergeTree ORDER BY time; -- 导入数据 INSERT INTO git.commits SELECT * FROM s3('https://datasets-documentation.s3.amazonaws.com/github/commits/clickhouse/commits.tsv.xz', 'TSV', 'hash String,author LowCardinality(String), time DateTime, message String, files_added UInt32, files_deleted UInt32, files_renamed UInt32, files_modified UInt32, lines_added UInt32, lines_deleted UInt32, hunks_added UInt32, hunks_removed UInt32, hunks_changed UInt32') 0 rows in set.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf71ba0b238f7025c6f8290d5266eb8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c8d5ed1fb30290892ad2670e39a63fa/" rel="bookmark">
			介绍一些编程语言— Perl 语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍一些编程语言— Perl 语言 Perl 语言 简介 Perl 是一种动态解释型的脚本语言。 最初的设计者为拉里・沃尔，它于 1987 1987 1987 年 12 12 12 月 18 18 18 日发表。Perl 借取了 C、sed、awk、shell scripting 以及很多其他编程语言的特性。其中最重要的特性是他内部集成了正则表达式的功能，以及巨大的第三方代码库 CPAN。
产生背景 1987 1987 1987 年 Larry Wall 发布 Perl1.0 以来，用户数一直急剧增加，同时越来越多的程序员与软件开发者参与 Perl 的开发。从最初被当做一种跨平台环境中书写可移植工具的高级语言开始，Perl 被广泛地认为是一种工业级的强大工具，可以在任何地方用来完成你的工作。perl 的前身是 Unix 系统管理的一个工具，被用在无数的小任务里。后逐渐发展成为一种功能强大的程序设计语言，用作 Web 编程、数据库处理、XML 处理以及系统管理；在完成这些工作时，同时仍能处理日常细小工作，这是它的设计初衷。Perl 特别适合系统管理和 Web 编程。实际上已经被用在所有 Unix 捆绑在一起作为标准部件发布，同时也用于 Microsoft Windows 和几乎所有操作系统。Perl 的应用非常广泛。
Perl 优点 相比 C、Pascal 这样的"高级"语言而言，Perl 语言直接提供泛型变量、动态数组、Hash 表等更加便捷的编程元素。
Perl 具有动态语言的强大灵活的特性，并且还从 C/C++、Basic、Pascal 等语言中分别借鉴了语法规则，从而提供了许多冗余语法。
在统一变量类型和掩盖运算细节方面，Perl做得比其他高级语言(如：Python）更为出色。
由于从其他语言大量借鉴了语法，使得从其他编程语言转到 Perl 语言的程序员可以迅速上手写程序并完成任务，这使得 Perl 语言是一门容易用的语言。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c8d5ed1fb30290892ad2670e39a63fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76020e680bf5772350e2b16ad9c07a8a/" rel="bookmark">
			「JSON对象互转工具」JSON转对象、对象转JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON对象互转工具 一、Fastjson二、ObjectMapper三、Gson四、总结五、建议 一、Fastjson Fastjson 是一款高性能的 JSON 解析库，提供了丰富而强大的方法来处理 JSON 数据。下面是一些常用的 Fastjson, 方法的详解：
Fastjson 的 Maven 依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.76&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; toJSONString(Object object)：将 Java 对象转换为 JSON 字符串。 String jsonString = JSON.toJSONString(myObject); parseObject(String text, TypeReference&lt;T&gt; type)：将 JSON 字符串解析为指定类型的对象。 MyObject myObject = JSON.parseObject(jsonString, new TypeReference&lt;MyObject&gt;() {}); parseArray(String text, Class&lt;T&gt; clazz)：将 JSON 数组字符串解析为指定类型的 List 集合。 List&lt;MyObject&gt; myList = JSON.parseArray(jsonArrayString, MyObject.class); toJSONBytes(Object object, SerializerFeature... features)：将 Java 对象转换为 JSON 字节数组。 byte[] jsonBytes = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76020e680bf5772350e2b16ad9c07a8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/189c35fc99cac3c6e81474cd9a22acfd/" rel="bookmark">
			C#上位机：Modbus TCP通讯实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#上位机：Modbus TCP通讯实例 前言所需驱动程序设计读写线圈 前言 前文中讲述了使用串口通讯操作Modbus协议报文，但在实际生产环境中，也有很多硬件需要通过TCP接口来操作Modbus 协议。在理解了Modbus的线圈寄存器（可见前文）之后，Modbus TCP可不通过报文的形式来进行读写。在这里我们运用NModbus4，来直观的进行操作。
附上前文链接：
C#上位机：串口通讯
C#上位机：Modbus RTU
一些重点：
所需驱动 在Nuget中引用添加NModbus4，这个包里有着全面的读写函数可直接使用，让我们不用再去复杂的预设报文。
然后添加库
using System; using System.Windows.Forms; using System.Net; using System.Net.Sockets; using System.Threading; using Modbus.Device; 程序设计 现在我们来从零设计一个Demo。首先，核心的流程如下：
画一个简易页面：
完成了设置的确认，我们来写连接部分：
首先在Load添加接口
Task task1 = new Task(() =&gt; { ConnectServer(); }); task1.Start();//启动Task1 我们采用Socket类的TcpClient方式来连接，并异步进行减少卡顿。
public void ConnectServer() { if (tcpClient != null) tcpClient.Close(); tcpClient = new TcpClient(); //开始异步 string IP = IPaddress.Text; IAsyncResult con = tcpClient.BeginConnect(IPAddress.Parse(IP), 502, null, null); con.AsyncWaitHandle.WaitOne(2000); if (tcpClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/189c35fc99cac3c6e81474cd9a22acfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473a22e4583f478da159f6a5601428da/" rel="bookmark">
			java垃圾回收机制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、垃圾回收机制是什么？二、机制运行原理三、机制运行步骤 一、垃圾回收机制是什么？ Java的垃圾回收（Garbage Collection，GC）机制是Java内存管理的核心部分，它可以自动回收不再被程序使用的内存空间，防止内存泄漏和崩溃等问题，是Java语言的一个重要特性。
二、机制运行原理 垃圾回收机制通过一个被称为垃圾收集器（Garbage Collector）的程序来实现，它使用Mark and Sweep算法定期自动扫描内存中的对象，然后把不再被使用的对象标记为垃圾。接下来，垃圾收集器会将这些垃圾对象所占用的内存空间释放掉，以便给其他对象使用。 将对象标记为垃圾有引用计数法和可达性分析法两种方式。引用计数法是通过计算对象被引用的次数来判断是否应该标记，如果引用计数为0，则认为是垃圾。可达性分析法则是通过判断对象是否能够被其他对象所引用来判断是否是垃圾，如果一个对象不再被任何其他对象所引用，则认为是垃圾。 三、机制运行步骤 假设我们有如下的Java代码：
public class Example { public static void main(String[] args) { Person person = new Person("John"); person = null; } } class Person { String name; public Person(String name) { this.name = name; } } 在上述代码中，我们创建了一个Person对象并赋值给person变量。然后我们把person变量设为null。当person被设为null时，原本的Person对象就不再有任何引用指向它，因此它就成为了垃圾，可以被回收。
1. 标记：垃圾回收器会识别出那些对象不再被引用，标记出这些对象。在我们的例子中，垃圾回收器会发现`Person`对象不再被`person`引用，因此会被标记为垃圾。 2. 删除：垃圾回收器会删除标记为垃圾的对象，释放它们占用的内存。在我们的例子中，`Person`对象会被删除，它占用的内存会被释放。 3. 整理：垃圾回收器会整理内存空间，把剩余的对象移动到内存的一端，以便能连续分配内存。在我们的例子中，如果有其他对象存在，垃圾回收器会将它们移动到内存的一端。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005e7e5f8fd68e22cecf9208fead0408/" rel="bookmark">
			I2C_GetFlagStatus()函数返回值说明，IIC的标志位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 I2C_GetFlagStatus()函数是用于获取I2C外设的特定标志位的状态。它的参数可以是以下几个值之一：
I2C_FLAG_TXE：表示I2C数据寄存器为空的标志位。返回值可以是以下两个值之一：
SET：表示I2C数据寄存器为空。RESET：表示I2C数据寄存器非空。 I2C_FLAG_RXNE：表示I2C数据寄存器非空的标志位。返回值可以是以下两个值之一：
SET：表示I2C数据寄存器非空。RESET：表示I2C数据寄存器为空。 I2C_FLAG_ADDR：表示I2C地址发送完成的标志位。返回值可以是以下两个值之一：
SET：表示I2C地址发送完成。RESET：表示I2C地址未发送完成。 I2C_FLAG_AF：表示I2C Acknowledge失败的标志位。返回值可以是以下两个值之一：
SET：表示I2C Acknowledge失败。RESET：表示I2C Acknowledge成功。 I2C_FLAG_STOPF：表示I2C停止条件检测标志位。返回值可以是以下两个值之一：
SET：表示I2C停止条件已检测到。RESET：表示I2C停止条件未检测到。 I2C_FLAG_BTF：表示I2C数据传输完成的标志位。返回值可以是以下两个值之一：
SET：表示I2C数据传输已完成。RESET：表示I2C数据传输未完成。 I2C_FLAG_BUSY：表示I2C总线忙的标志位。返回值可以是以下两个值之一：
SET：表示I2C总线忙。RESET：表示I2C总线空闲。 I2C_FLAG_TRA：表示I2C当前处于发送模式的标志位。返回值可以是以下两个值之一：
SET：表示I2C当前处于发送模式。RESET：表示I2C当前处于接收模式。 I2C_FLAG_MSL：表示I2C当前为主模式的标志位。返回值可以是以下两个值之一：
SET：表示I2C当前为主模式。RESET：表示I2C当前为从模式。 I2C_FLAG_SB：表示I2C起始条件检测标志位。返回值可以是以下两个值之一：
SET：表示I2C起始条件已检测到。RESET：表示I2C起始条件未检测到。 I2C_FLAG_OVR：表示I2C数据溢出的标志位。返回值可以是以下两个值之一：
SET：表示I2C数据溢出。RESET：表示I2C数据未溢出。 I2C_FLAG_PECERR：表示I2C PEC错误的标志位。返回值可以是以下两个值之一：
SET：表示I2C PEC错误。RESET：表示I2C PEC正确。 I2C_FLAG_TIMEOUT：表示I2C超时的标志位。返回值可以是以下两个值之一：
SET：表示I2C超时。RESET：表示I2C未超时。 I2C_FLAG_SMBALERT：表示I2C SMBus警报的标志位。返回值可以是以下两个值之一：
SET：表示I2C SMBus警报。RESET：表示I2C无SMBus警报。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/42/">«</a>
	<span class="pagination__item pagination__item--current">43/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/44/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>