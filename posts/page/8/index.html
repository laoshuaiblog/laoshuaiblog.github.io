<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83784f320d091fb793718603d854e98a/" rel="bookmark">
			ThinkPHP8多应用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Think PHP官方手册上说的很笼统，这里详细盘点多应用模式的配置。
1.配置文件打开多应用模式支持 config/app.php文件里需要加上：
'auto_multi_app' =&gt; true, 默认里是没有这个配置的，需要自己手动加上。也可以随手将default_app设置好。
2.删除app文件夹下默认的controller文件夹 3.安装TP多应用拓展 composer require topthink/think-multi-app 注意：这条命令一定要在项目的根目录下运行，不然是没有效果的
4.使用命令生成多应用 php think build 应用名 这条命令同样也是在项目根目录下执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163b0b1cffa0df261b6cd22d5d84c1b3/" rel="bookmark">
			Web实现名言生成器：JavaScript DOM基础与实例教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟 前言
欢迎来到我的技术小宇宙！🌌 这里不仅是我记录技术点滴的后花园，也是我分享学习心得和项目经验的乐园。📚 无论你是技术小白还是资深大牛，这里总有一些内容能触动你的好奇心。🔍
🤖 洛可可白：个人主页
🔥 个人专栏：✅前端技术 ✅后端技术
🏠 个人博客：洛可可白博客
🐱 代码获取：bestwishes0203
📷 封面壁纸：洛可可白wallpaper
文章目录 Web实现名言生成器：JavaScript DOM基础与实例教程JavaScript DOM基础实例：名言生成器实现效果创建HTML结构编写JavaScript逻辑初始化名言列表获取随机名言更新名言显示 样式美化 全部代码结语🎉 往期精彩回顾 Web实现名言生成器：JavaScript DOM基础与实例教程 名言生成器是一个简单而有趣的Web应用，它可以随机显示历史上著名人物的名言。通过这个教程，我们将学习如何使用JavaScript DOM API来实现这个功能，并介绍相关的JavaScript DOM基础知识。
JavaScript DOM基础 DOM（Document Object Model）是HTML文档的编程接口，它允许我们通过JavaScript访问和操作网页元素。在JavaScript中，我们可以使用DOM API来获取元素、修改内容、绑定事件等。
实例：名言生成器 实现效果 体验地址：
http://8.210.131.139/QuoteGenerator.html
创建HTML结构 首先，我们需要创建一个包含名言显示区域和生成按钮的HTML结构。
&lt;div class="quote-box"&gt; &lt;p class="text"&gt;这是名言部分&lt;/p&gt; &lt;p class="author"&gt;我是作者&lt;/p&gt; &lt;button id="new-quote"&gt;生成名言&lt;/button&gt; &lt;a class="tweet-quote" href="https://blink.csdn.net/"&gt;分享到 CSDN&amp;Blink&lt;/a&gt; &lt;/div&gt; 编写JavaScript逻辑 初始化名言列表 在JavaScript中，我们首先定义一个包含名言和作者的数组。
const quotes = [ { quote: "生命不止，奋斗不息。", author: "方志敏", }, { quote: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/163b0b1cffa0df261b6cd22d5d84c1b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e42bd78ad795c451a2bf1ac1c6cfbf/" rel="bookmark">
			Web实现井字棋游戏：JavaScript DOM基础与实例教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟 前言
欢迎来到我的技术小宇宙！🌌 这里不仅是我记录技术点滴的后花园，也是我分享学习心得和项目经验的乐园。📚 无论你是技术小白还是资深大牛，这里总有一些内容能触动你的好奇心。🔍
🤖 洛可可白：个人主页
🔥 个人专栏：✅前端技术 ✅后端技术
🏠 个人博客：洛可可白博客
🐱 代码获取：bestwishes0203
📷 封面壁纸：洛可可白wallpaper
文章目录 Web实现井字棋游戏：JavaScript DOM基础与实例教程JavaScript DOM基础实例：井字棋游戏实现效果创建HTML结构编写JavaScript逻辑初始化游戏事件绑定更新游戏状态检查胜利条件和平局电脑AI移动渲染棋盘重置游戏 全部代码 结语🎉 往期精彩回顾 Web实现井字棋游戏：JavaScript DOM基础与实例教程 井字棋（Tic-Tac-Toe）是一款经典的两人对战游戏，适合作为学习JavaScript DOM操作的实践项目。本文将通过一个简单的实例，介绍如何使用JavaScript和DOM API来实现一个井字棋游戏，并讲解相关的JavaScript DOM基础知识。
JavaScript DOM基础 DOM（Document Object Model）是HTML和XML文档的编程接口。在JavaScript中，DOM提供了一种结构化的方式来表示和操作网页内容。通过DOM，我们可以获取元素、修改样式、绑定事件等。
实例：井字棋游戏 实现效果 体验地址：
http://8.210.131.139/Tictactoe.html
创建HTML结构 首先，我们需要创建一个包含游戏板和结果显示的HTML结构。
&lt;div class="board"&gt; &lt;!-- 游戏格子 --&gt; &lt;div class="cell"&gt;&lt;/div&gt; &lt;!-- ... 其他格子 ... --&gt; &lt;/div&gt; &lt;div id="result"&gt;&lt;/div&gt; 编写JavaScript逻辑 初始化游戏 在JavaScript中，我们首先定义游戏板的状态、玩家当前回合以及游戏是否结束的状态。
const board = ["", "", "", "", "", "", "", "", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6e42bd78ad795c451a2bf1ac1c6cfbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38b9b18cc2d7b05ed2229fb442e1e79/" rel="bookmark">
			[BT]BUUCTF刷题第6天（3.24）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第6天 Web [极客大挑战 2019]PHP Payload：
O:4:"Name":3:{s:14:"%00Name%00username";s:5:"admin";s:14:"%00Name%00password";s:3:"100";} 这道题考点是网站源码备份文件泄露和PHP反序列化，有篇介绍PHP反序列化考点的文章：PHP序列化反序列化漏洞总结（一篇懂）
打开网站是一个小游戏，根据题目提示得知需要找到网站的备份文件，这里使用dirsearch进行扫描（由于使用dirsearch自带的字典完整扫描一遍耗时过长，因此根据网上的题解我自己写了一个包含正确备份文件的字典，缩短扫描时间）
返回状态码200，说明确实存在该文件，访问下载
经过查看，flag.php中不包含正确flag，然后打开index.php进一步查看（发现关键内容：include 'class.php';和$res=unserialize(@$select);）
打开class.php文件
&lt;?php include 'flag.php'; error_reporting(0); class Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ /*__construct()当对象被创建即new之前， 会触发进行初始化，但在unserialize()时是不会自动调用的。*/ $this-&gt;username = $username; $this-&gt;password = $password; } function __wakeup(){ //__wakeup()将在反序列化之后立即调用 $this-&gt;username = 'guest'; } function __destruct(){ /* __destruct()在到某个对象的所有引用都被删除 或者当对象被显式销毁时执行*/ if ($this-&gt;password != 100) { echo "&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;"; echo "You name is: "; echo $this-&gt;username;echo "&lt;/br&gt;"; echo "You password is: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f38b9b18cc2d7b05ed2229fb442e1e79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a8f94b822204b2493803a6cae8bfcfe/" rel="bookmark">
			Euler angles and Quaterean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		what is Euler angles ?（欧拉角是什么东西？）
The Euler angles are three angles introduced by Leonhard Euler to describe the orientation of a rigid body with respect to a fixed coordinate system (被欧拉引入用三个角度来描述刚体相对于固定参考系的旋转)
Euler angles are typically denoted as α, β, γ, or ψ, θ, φ. Different authors may use different sets of rotation axes to define Euler angles, or different names for the same angles. Therefore, any discussion employing Euler angles should always be preceded by their definition.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a8f94b822204b2493803a6cae8bfcfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b73e3d0bdf623efab3dd4112bf04fd/" rel="bookmark">
			Kafka broker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. zk中存储的kafka信息 /kafka/brokers/ids存储了在线的broker id。
/kafka/brokers/topics/xxx/partitions/n/state存储了Leader是谁以及isr队列
/kafka/controller辅助Leader选举，每个broker都有一个controller，谁先在zk中注册上，谁就辅助Leader选举。
2. broker总体工作流程 1）每台broker启动后在zk中注册，即/kafka/borkers/ids
2）每台broker去抢占式注册controller，用于后面Leader选举
3）由注册的controller监听/kafka/borkers/ids节点变化
4）开始Leader选举，选举标准是以isr中存活为前提，以AR中排在前面的优先（AR是所有副本的集合，启动时会有一个固定的AR顺序，比如ar[1, 0, 2]）
5）controller将选举出来的信息（Leader和isr信息）传到zk中，即/kafka/brokers/topics/xxx/partitions/n/state
6）其他broker的controller会从zk中同步相关信息
Kafka生产者发送数据到broker，数据在底层以Log方式（逻辑概念）存储，实际上是Segment（物理概念），一般1个Segment是1G，包含.log文件和.index文件，.index文件是索引，用于快速查询数据
7）如果Leader挂了，controller监听到节点变化，选举新的Leader，选举标准依然是以isr中存活为前提，以AR中排在前面的优先，最后更新Leader和isr队列信息
3. 新节点服役 新节点服役后，以前的topic所在的分区不会出现在新节点，即新节点不会分摊旧节点的存储压力。如果需要新节点参与进来，就需要进行一种类似于负载均衡的配置。先创建一个topic-to-move.json配置文件：
{ "topics": [ {"topic": "first"} ], "version": 1 } 生成一个负载均衡的计划：
bin/kafka-reassign-repartitions.sh --bootstrap-server hadoop102:9092 --topics-to-move-json-file topics-to-move.json --broker-list "0,1,2,3" --generate 上面一行是当前的分区分配，下面一行是建议的分区分配计划，创建副本存储计划increase-replication-factor.json，里面内容是上面得分建议计划。最后执行存储计划：
bin/kafka-reassign-repartitions.sh --bootstrap-server hadoop102:9092 --reassignment-json-file increase-replication-factor.json --execute 还可以验证计划：
bin/kafka-reassign-repartitions.sh --bootstrap-server hadoop102:9092 --reassignment-json-file increase-replication-factor.json --verify 查询这个topic的分区详情
bin/kafka-topics.sh --bootstrap-server hadoop102:9092 --topic first --describe 4. 退役旧节点 退役旧节点与服役新节点有一些类似，先创建一个topic-to-move.json配置文件，与服役新节点时一样，然后生成一个计划，只不过--broker-list 改为"0,1,2"，接着执行计划，验证计划，都与服役新节点一样。
最后在退役节点关闭kafka服务
bin/kafka-server-stop.sh 5. Leader选举验证 创建四个分区四个副本的topic并查看：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b73e3d0bdf623efab3dd4112bf04fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70eb7eb50dddd31792b47adbbdd08c72/" rel="bookmark">
			【WEEK4】 【DAY5】AJAX - Part Two【English Version】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.3.22 Friday
Following the previous article 【WEEK4】 【DAY4】AJAX - Part One【English Version】
Contents 8.4. Ajax Asynchronous Data Loading8.4.1. Create User.java8.4.2. Add lombok and jackson support in pom.xml8.4.3. Change Tomcat Settings8.4.4. Modify AjaxController.java8.4.5. Create test2.jsp8.4.5.1. Note: At the same level as WEB-INF!8.4.5.2. Verify Click Event8.4.5.3. Output the Content of userList8.4.5.4. Update the JavaScript Version8.4.5.5. Further Modify test2.jsp to Directly Display userList on the Web Page 8.4.6. Run 8.5. Ajax Username Verification Experience8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70eb7eb50dddd31792b47adbbdd08c72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7406289e060d754723643b2d9c1fe648/" rel="bookmark">
			Android内存优化项目经验分享 兼顾效率与性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 项目上线一段时间后,回顾重要页面 保证更好用户体验及生产效率，做了内存优化和下载导出优化，具体效果如最后的一节的表格所示。
下面针对拍摄流程的两个页面 预览页 导出页优化实例进行介绍：
一.拍摄前预览页面优化 预览效果问题 存在内存回收不及时情况 问题描述 在预览页面两分钟的情况时： 内存回收不及时 会持续上涨到阈值 才会触发回收情况
对比图 处理前 AddCaptureActivity
处理后 AddCaptureActivity
原因 预览图未及时清除 到达阈值的时候才会回收
解决方案 对临时预览图不光置空 还要对其标记回收
效果 减少40%常驻值
后续提升 针对低性能设备可以降低预览视频 帧率及分辨率
二.拍摄保存页面 目标 业务目标：在减少导出时间 减少预览加载时间
技术目标：兼顾效率的情况下内存优化
现状 进入页面会加载预览图（全屏可滑动的全景图 ）,点击下方保存按钮会下载图片。
需要导出的图片规格 6720x3360 预览组件 在compose下用个webview实现 下载好了图片转为base64通过js桥传到web中 web中负责渲染
组件布局 加载的具体实现 下载组件 通过网络请求对数据下载 默认重试时间10s 失败有toast提示 成功返回房源编辑页面
内存情况 内存常驻值为628 峰值780
内存情况 现状总结 现状情况总结:预览组件和下载导出是独立的组件
优点:独立进行加载 保证了两个业务相互独立 可以在没有预览的情况下 仍能够正常导出
缺点:导出时间长 且没有及时反馈,10s重试、占用内存峰值高
整改 第一步 打通两个组件的加载逻辑 实现缓存共用 打通两个组件的加载逻辑 实现缓存共用 实现以空间换时间实现速度提升,就是将预览组件的缓存 在导出的时候使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7406289e060d754723643b2d9c1fe648/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c59cf339d4f10f4f76bc1492b83ed9/" rel="bookmark">
			无极低码SQL模板引擎使用教程示例，自己手撸一个sql模板引擎进行动态sql生成。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 无极低码 ：https://wheart.cn
无极低码SQL模板使用教程 一、模板结构与规则 无极低码SQL模板通过简洁的Markdown格式，使SQL语句具有更强的灵活性和适应性，简化了根据业务需求定制SQL的过程。
无极低码SQL模板是一种基于Markdown格式的特殊SQL语句表示方式，它利用∮符号作为动态条件的标识符，使得SQL语句能够在运行时根据变量值动态生成。
下面是无极低码SQL模板的一般结构：
select方法名，用于定位执行语句
===分隔符
sql语句，为查询输出前端的值，where 1=1 结束 也可以直接跟参数
∮bypositioncode为动态参数 与下一个sql之间使用“;”分割 ∮byIn_id表示非空时拼接如下sql and id in('#byIn_id#')“#byIn_id#”会被替换为实际值 动态拼接时间查询条件 ∮bystartpubTime&amp;&amp;byendpubTime and pub_time between '#bystartpubTime#' and '#byendpubTime#' 动态拼接模糊查询 ∮byname and name like'%#byname#%' 二、动态条件的应用 对于每个∮开头的条件行，如果关联的变量存在且非空，那么该行条件将被包含在最终执行的SQL查询中。如果变量不存在或为空，则对应的SQL条件将被忽略。 三、示例sql模板 select === select positioncode ,id,positionname,picurl ,pichref ,pictitle ,picdes ,sort from travelpositionpics where 1=1 ∮bypositioncode and positioncode=#bypositioncode# ∮bypositionname and positionname='#bypositionname#' ∮bypicurl and picurl='#bypicurl#' ∮bypichref and pichref='#bypichref#' ∮bypictitle and pictitle='#bypictitle#' ∮bypicdes and picdes='#bypicdes#' ∮bysort and sort=#bysort# ; selectOneByid === select positioncode ,picurl ,pichref ,pictitle ,picdes ,sort from travelpositionpics where 1=1 ∮bypositioncode and positioncode=#bypositioncode# ∮bypicurl and picurl='#bypicurl#' ∮bypichref and pichref='#bypichref#' ∮bypictitle and pictitle='#bypictitle#' ∮bypicdes and picdes='#bypicdes#' ∮bysort and sort=#bysort# ; delete === delete from travelpositionpics where 1=1 ∮bypositioncode and positioncode=#bypositioncode# ∮bypicurl and picurl='#bypicurl#' ∮bypichref and pichref='#bypichref#' ∮bypictitle and pictitle='#bypictitle#' ∮bypicdes and picdes='#bypicdes#' ∮bysort and sort=#bysort# ∮byIn_id and id in('#byIn_id#') ; insert === insert ignore into travelpositionpics(positioncode,positionname,picurl,pichref,pictitle,picdes,sort) VALUES(#positioncode#,'#positionname#','∮#picurl#','#pichref#','#pictitle#','#picdes#',#sort#); update === update travelpositionpics set ∮positioncode positioncode=#positioncode#, ∮positionname positionname='#positionname#', ∮picurl picurl='#picurl#', ∮pichref pichref='#pichref#', ∮pictitle pictitle='#pictitle#', ∮picdes picdes='#picdes#', ∮sort sort=#sort# where 1=1 ∮bypositioncode and positioncode='#bypositioncode#' ∮bypicurl and picurl='#bypicurl#' ∮bypichref and pichref='#bypichref#' ∮bypictitle and pictitle='#bypictitle#' ∮bypicdes and picdes='#bypicdes#' ∮byid and id=#byid# ∮bysort and sort='#bysort#' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8937665de3b339ee90310f7187999c0/" rel="bookmark">
			知攻善防应急靶场-Linux(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 堕落了三个月，现在因为被找实习而困扰，着实自己能力不足，从今天开始 每天沉淀一点点 ，准备秋招 加油
注意： 本文章参考qax的网络安全应急响应和知攻善防实验室靶场，记录自己的学习过程，还希望各位博主 师傅 大佬 勿喷，还希望大家指出错误
靶场前言： 看监控的时候发现webshell告警，领导让你上机检查你可以救救安服仔吗！！
靶场要求： （1）提交攻击者IP
（2）提交攻击者修改的管理员密码(明文)
（3）提交第一次Webshell的连接URL
（4）提交Webshell连接密码
（5）提交数据包的flag1
（6）提交攻击者使用的后续上传的木马文件名称
（7）提交攻击者隐藏的flag2
（8）提交攻击者隐藏的flag3
过程： 查看本机网卡
查询管理员最近登录情况命令 grep "Accepted " /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 根据对比本机IP可以得知该 192.168.20.1即为攻击者的IP，解决（1） 问题，然后照常检查系统有没有运行什么可疑的程序
发现mysql运行了， 这样的话我们就可以去找管理员密码了，目标就很明确了，先去获取数据库密码，然后在www目录的access.log发现路由phpmyadmin
那估计网站搭建数据库是使用了phpmyadmin ,那我们直接去找配置文件config.inc.php就可以
最终在/www/wwwroot/127.0.0.1/lib目录下找到了
得到数据库账号密码
kaoshi: 5Sx8mK5ieyLPb84m 然后登入数据库 查到id为1 的为管理员
寻找id为1 得到密码
得到密码为加密的形式
f6f6eb5ace977d7e114377cc7098b7e3 解码得到：管理员密码（问题2）：Network@2020
我们在root目录下发现了一个 1.pcapng文件 那就的用wireshark进行分析了,直接过滤 攻击者ip ip.addr == 192.168.20.1 然后就看到flag1路径 打开得到flag1(问题5) flag1{Network@_2020_Hack} 然后其他的数据流全是index.php?user-app-register和version2.php ，追踪得到
url解码得到PHP代码
Network2020=@ini_set("display_errors", "0"); @set_time_limit(0); $opdir=@ini_get("open_basedir"); if($opdir) { $ocwd=dirname($_SERVER["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8937665de3b339ee90310f7187999c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f3d6fc2d0e1f320b5afa90339f8122f/" rel="bookmark">
			tewa-707e光猫超级密码获取方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这款光猫很魔性，没有WIFI，没有USB接口，没有Telnet，试了很多方法去获取超级密码都不行。后来偶尔的机会找到了方法，现与大家共享。
1、用FTP登录，用户名和密码就是光猫背面标签上的。FTP软件比较好使的是：FlashFXP
2、进入/userconfig/cfg目录，将db_user_cfg.xml文件下载下来。
3、这个文件是用AES加密了的，直接打开是乱码，所以得用AES解密，key为16个字节的 x00。
4、附解密用的python代码。
from Crypto.Cipher import AES
from binascii import a2b_hex
KEY = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
def decrypt(text):
cryptor = AES.new(KEY, AES.MODE_ECB)
plain_text = cryptor.decrypt(a2b_hex(text))
return plain_text
cfg_file = open("db_user_cfg.xml", "rb")
dec_file = open("db_user_cfg.decode.xml", "w")
file_header = cfg_file.read(60)
while 1:
trunk_info = cfg_file.read(12)
trunk_data = cfg_file.read(65536)
trunk_real_size = int.from_bytes(trunk_info[0:4], byteorder='big', signed=False)
trunk_size = int.from_bytes(trunk_info[4:8], byteorder='big', signed=False)
next_trunk = int.from_bytes(trunk_info[8:12], byteorder='big', signed=False)
print(trunk_real_size, trunk_size, next_trunk)
dec_file.write(decrypt(trunk_data.hex()).decode(encoding="utf-8"))
if next_trunk==0:
break
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f3d6fc2d0e1f320b5afa90339f8122f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb58bfa102b47c1f350dc235ebbb9779/" rel="bookmark">
			【C&#43;&#43;】手撕哈希表的闭散列和开散列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&gt; 作者：დ旧言~
&gt; 座右铭：松树千年终是朽，槿花一日自为荣。
&gt; 目标：手撕哈希表的闭散列和开散列
&gt; 毒鸡汤：谁不是一边受伤，一边学会坚强。
&gt; 专栏选自：C嘎嘎进阶
&gt; 望小伙伴们点赞👍收藏✨加关注哟💕💕
🌟前言 谈到哈希表，大家都做过这样的题目，统计字符串的字母个数，像这样的题目可以创建一个数组，每个字母采用 a['ch']++ 计入数组中，这样的数组我们称之为哈希表，这种哈希表也是最简单的，如果说为了方便直接调用哈希表，那这个哈希表该如何模拟呢？这个问题也是今天我们所探讨的，手撕哈希表。
⭐主体 学习手撕哈希表的闭散列和开散列咱们按照下面的图解：
🌙哈希概念 知识回顾
在顺序结构以及平衡树中，由于元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较；比如顺序表中需要从表头开始依次往后比对寻找，查找时间复杂度为 O(N)，平衡树中需要从第一层开始逐层往下比对寻找，查找时间复杂度为 O(logN)；即搜索的效率取决于搜索过程中元素的比较次数。
分析探讨
如果构造一种存储结构，可以通过某种函数 (hashFunc) 使元素的存储位置与它的关键码之间能够建立一对一的映射关系，那么在查找时通过该函数就可以很快找到该元素；当向该结构中：
插入元素时：根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放；搜索元素时：对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。 总结归纳
该方法即为 哈希 (散列) 方法，哈希方法中使用的转换函数称为哈希 (散列) 函数，构造出来的结构称为哈希表 (Hash Table) (或者称散列表)。
注意事项
我们上面提到的不管是顺序搜索、平衡树搜索还是哈希搜索，其 key 值都是唯一的，也就是说，搜索树中不允许出现相同 key 值的节点，哈希表中也不允许出现相同 key 值的元素，我们下文所进行的所有操作也都是在这前提之上进行的。
🌙哈希冲突 不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。
哈希冲突有两种常见的解决办法：
闭散列 (开放定址法)：当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把 key 存放到冲突位置中的 “下一个” 空位置中去；开散列 (链地址法)：首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码 (哈希冲突) 归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中；也就是说，当发生哈希冲突时，把 key 直接链接在该位置的下面。 🌙哈希函数 哈希函数有如下设计原则：
哈希函数的定义域必须包括需要存储的全部关键码，而如果哈希表允许有m个地址时，其值域必须在0到m-1之间；哈希函数计算出来的地址要尽量能均匀分布在整个空间中；哈希函数应该比较简单。 💫直接定址法 什么是直接定址法：
直接定址就是根据 key 值直接得到存储位置，最多再进行一个简单的常数之间的转换。
分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb58bfa102b47c1f350dc235ebbb9779/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7edbb08136dff19f61357326c8d4c653/" rel="bookmark">
			qinakun实现全局状态管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 qinakun实现全局状态管理基座 src / index.tsx子应用 src / index.tsx qinakun实现全局状态管理 qiankun提供了一个全局的 initGlobalState 来共享数据，基座初始化之后，子应用可以监听到这个数据的变化，也能提交这个数据。 基座 src / index.tsx import { start, registerMicroApps, initGlobalState } from 'qiankun' // root.render(XXX) // qiankun加载子应用 + 启动 。。。 const state = { count: 1 } const actions = initGlobalState(state); // 主项目项目监听和修改 actions.onGlobalStateChange((state, prev) =&gt; { // state: 变更后的状态; prev 变更前的状态 console.log('基座onGlobalStateChange',state, prev); }); actions.setGlobalState(state); start() // 3. 启动微服务 子应用 src / index.tsx 在子应用挂载的时候 监听主应用的共享数据 // 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法 export async function mount(props: any) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7edbb08136dff19f61357326c8d4c653/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd2fb8ce0fd667622456461e4fe00a8e/" rel="bookmark">
			6.windows ubuntu 子系统 测序数据质量控制。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一个分享，我们对测序数据进行了质量评估，接下来我们需要对数据进行数据质量控制。
数据预处理（Data Preprocessing）：包括去除接头序列（adapter trimming）、去除低质量序列（quality filtering）、去除含有未知碱基的序列等，以净化原始测序数据。
进行质量控制的软件有fastp,Trimmomatic, trim_galore等，这里我们对这三个软件进行简要使用。
fastp的用法：以a1.fq.gz a2.fq.gz为例。
fastp --thread 4 -i ./a1.fq.gz -I ./a2.fq.gz -o ./a1.clean.fq.gz -O ./a2.clean.fq.gz -h L.html
fastp 是一个用于快速处理高通量测序数据的工具，主要用于质量控制和数据预处理。
-i, --in1：指定输入文件的路径，这通常是第一对（read1）原始测序数据的文件路径。
-I, --in2：指定第二个输入文件的路径，这通常是第二对（read2）原始测序数据的文件路径。
-o, --out1：指定第一个输出文件的路径，这是处理后的第一对测序数据（read1）的输出路径。
-O, --out2：指定第二个输出文件的路径，这是处理后的第二对测序数据（read2）的输出路径。
-h, --html：生成 HTML 格式的质量控制报告文件。
-j, --json：生成JSON格式的质量控制报告文件。
--thread：指定线程数，用于加速数据处理过程。
-q, --qualified_quality_phred：设定质量值阈值，低于该值的碱基将被截断。
-n, --low_complexity_filter：开启低复杂度序列过滤功能，用于去除包含低复杂度序列的 reads。
-e, --correction：开启错误校正功能，用于纠正测序错误。
-w, --overrepresentation_analysis：进行富集分析，检测PCR重复、接头污染等问题。
conda install -c bioconda Trimmomatic -y #安装 Trimmomatic，Trimmomatic是基于Java开发的，因此需要提前安装Java，才能使用Trimmomatic。
Trimmomatic -h #出现技术参数说明即可使用。
trimmomatic PE -phred33 -threads 4 a1.fq.gz a2.fq.gz a1_paired.fq.gz a1_unpaired.fq.gz a2_paired.fq.gz a2_unpaired.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd2fb8ce0fd667622456461e4fe00a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/246a48ed7af45328b818ab46d7de13ad/" rel="bookmark">
			面试题---区别函数节流与防抖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 事件高频触发处理的问题 如果更新界面 =&gt; 界面更新卡顿如果发送ajax请求 =&gt; 发送了很多没必要的请求 2. 解决办法 函数节流函数防抖 3. 区别: 节流函数 (throttle)：
接受两个参数：需要节流的回调函数callback和延迟时间delay。通过保存上一次处理事件的时间start，确保在连续触发事件时，只有当当前时间与上一次处理事件的时间差大于设定的延迟时间delay时，才会执行回调函数callback。 防抖函数 (debounce)：
同样接受两个参数：需要防抖的回调函数callback和延迟时间delay。每当事件触发时，如果存在尚未执行的定时器，则清除它，然后重新启动一个延迟时间为delay的新定时器。只有当事件触发后，在指定延迟时间内没有再次触发事件时，才会执行回调函数callback。 简单来讲：当事件高频发生很多次时, 防抖只执行最后一次, 而节流执行少量几次
4. 应用场景 节流: 窗口调整（resize）/ 页面滚动（scroll）/ OM元素的拖拽功能实现（mousemove）
防抖: 输入搜索联想功能
5.自定义函数节流与防抖 // 节流函数 (throttle) function throttle(callback, delay) { let start = 0; // 用于保存处理事件的时间，初始值为0，保证第一次会执行 // 返回事件监听函数 =&gt; 每次事件发生都会执行此返回的函数 return function(event) { console.log('-- throttle --'); // 发生事件的当前时间 const current = Date.now(); // 与上一次处理事件的时间差大于delay的时间 if (current - start &gt; delay) { // 执行处理事件的函数 callback.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/246a48ed7af45328b818ab46d7de13ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe64a49a1e78d308ef3e55eb3c596560/" rel="bookmark">
			C数据类型（C语言）---变量的类型决定了什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数据类型（Data Type）
变量的类型决定了什么？
（1）不同类型数据占用的内存大小不同
如何计算变量或类型占内存的大小
（2）不同数据类型的表数范围不同
（3）不同类型数据的存储形式不同
整型数
定点数与浮点数
字符型数据（英文字母、数字、控制字符）
（4）不同数据类型可参与的运算不同
整型
实型
字符型
指针类型
小结
不同类型的变量
讨论
数据类型（Data Type） 在冯·诺依曼体系结构中
*程序代码和数据都是以二进制存储的
*对计算机系统和硬件本身而言，数据类型的概念并不存在
问题：高级语音为什么要区分数据类型？
*更有效地组织数据，规范数据的使用
*有助于提高程序的可读性，方便用户的使用
在程序设计语音中引入数据类型的好处
*带来了程序的简明性和数据的可靠性
*有助于提高程序执行效率、节省内存空间
变量的类型决定了什么？ *占用内存空间的大小
*数据的存储形式
*合法的表数范围
*可参与的运算种类
（1）不同类型数据占用的内存大小不同 int ——基本整型，C标准未规定，系统相关
*在目前大多数系统上占4个字节
short int ,简写为short
*短整型，2个字节
long int,简写为long
*长整型，4个字节
unsigned——无符号整型（正整数和0）
*用来修饰int、short和long
float
*单精度实型，4个字节
double
*双精度实型，8个字节
long double
*长双精度实型，IEEE规定10个字节，系统相关
*VC++中占8个字节
char *字符型，1个字节
注意：绝对不能对变量所占的内存字节数想当然
如何计算变量或类型占内存的大小 问题：如何计算变量占内存空间的大小？
用sizeof运算符
一元运算符
用sizeof运算符计算变量占内存空间的大小的好处
增加程序的可移植性
编译时执行的运算符，不会导致额外的运行时间开销
一般形式：
语法形式运算结果sizeof（类型）类型占用的内存字节数sizeof（变量或表达式）变量或表达式所属类型占的内存字节数 （2）不同数据类型的表数范围不同 有符号和无符号整数的表数范围也不同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe64a49a1e78d308ef3e55eb3c596560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee124ec890fac62c8d423834578ad61/" rel="bookmark">
			【WEEK4】 【DAY5】AJAX第二部分【中文版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.3.22 Friday
接上文【WEEK4】 【DAY4】AJAX第一部分【中文版】
目录 8.4.Ajax异步加载数据8.4.1.新建User.java8.4.2.在pom.xml中添加lombok、jackson支持8.4.3.更改tomcat设置8.4.4.修改AjaxController.java8.4.5.新建test2.jsp8.4.5.1.注意：和WEB-INF平级！8.4.5.2.验证点击事件8.4.5.3.输出userList的内容8.4.5.4.修改JavaScript版本8.4.5.5.再修改test2.jsp，使userList直接在网页上显示 8.4.6.运行 8.5.Ajax验证用户名体验8.5.1.修改AjaxController.java8.5.2.新建login.jsp8.5.3.运行 8.6.获取百度接口demo 8.4.Ajax异步加载数据 8.4.1.新建User.java package P24.project; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String gender; } 8.4.2.在pom.xml中添加lombok、jackson支持 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;SpringMVC_try1&lt;/artifactId&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;P24&lt;/groupId&gt; &lt;artifactId&gt;springmvc-06-ajax&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ee124ec890fac62c8d423834578ad61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb98041a8a799ec68b2bfa21887fbec/" rel="bookmark">
			unity学习（69）——多人位置同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的很，每个客户端向服务器发送位置信息，服务器再把这些位置信息发送给其他客户端。
1.客户端发送。
1.1在SocketModel脚本中添加一个新的类MoveDTO
public class MoveDTO { public string Id{get; set;} public int Dir{get;set;} public Assets.Model.Vector4 Rotation{get;set;} public Assets.Model.Vector3 Point{get;set;} } 一个新的PlayerStateConstans类
public class PlayerStateConstans { public const int FORWARD=0; public const int BACK=1; public const int LEFT=2; public const int RIGHT=3; public const int IDLE=4; public const int ATTACK=5; public const int SKILL=6; public const int DIE=7; } 1.2在JoystickPlayerExample脚本中的FixedUpdate()中添加如下代码，不停的向服务器发包。
MoveDTO dto = new MoveDTO(); dto.Id = SelectMenu.nowPlayer.id; dto.Dir = PlayerStateConstans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adb98041a8a799ec68b2bfa21887fbec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/215bc1b659e05fb9d42820af7f007856/" rel="bookmark">
			【CSS】1995- 15个CSS 常见错误，请一定要注意避免
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在不断发展的 Web 开发领域，掌握 CSS（层叠样式表）对于制作视觉上令人惊叹且响应迅速的网站至关重要。
然而，陷阱比比皆是，即使是经验丰富的开发人员也可能会发现自己陷入了常见的 CSS 错误中。
本文剖析了 15 个常见错误，提供分步说明和代码示例，帮助您创建完美的网页设计。
1. 过度依赖!important：
问题：
过度使用 !important 会导致代码混乱。
解决方案：
对于更干净和可维护的样式，优先考虑特异性而不是 !important。
/* Incorrect */ .element { color: red !important; } /* Correct */ section.element { color: blue; } 2. 使用通用选择器进行全局样式设置：
问题：
当使用通用选择器 (*) 设计所有元素的样式时，会出现意想不到的后果。
解决方案：
选择特定的选择器来精确定位元素。
/* Incorrect */ * { margin: 0; padding: 0; } /* Correct */ body { margin: 0; padding: 0; } 3.忽视响应式设计：
问题：
忽视响应式设计会影响不同设备上的用户体验。
解决方案：
实施媒体查询以实现自适应布局。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/215bc1b659e05fb9d42820af7f007856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed25c514d2efd05a98d2ee477f1a508/" rel="bookmark">
			由浅入深一步步了解什么是哈希（概念向）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是哈希哈希函数直接定址法除留余数法 哈希冲突闭散列线性探测法二次探测法负载因子和闭散列的扩容 开散列开散列的扩容 非整形关键码 什么是哈希 我们来重新认识一下数据查找的过程：
在顺序结构以及平衡树中，记录的关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O( l o g 2 N log_2 N log2​N)，搜索的效率取决于搜索过程中元素的比较次数。
顺序结构： 指的是顺序表、链表等线性数据结构，具体在C++中表现为像vector、list这样的容器；
平衡树： 指的是AVL树、红黑树等树形数据结构，具体在C++中表现为map、set这样的容器；
记录： 指的是容器或数据结构中存储的元素（或者说数据），为了方便后面表述什么哈希的相关知识，特地用这个名词来指代；
关键码： 它是一个记录的唯一标识，可能是记录本身或者记录中的某一项。举个例子，假如说记录是一个整数 or 字符串，记录的关键码就是记录本身，假设记录是一个键值对，记录的关键码就是键值对中的key；假设记录是某个类对象，记录的关键码就是对象中的某几个成员变量；
存储位置： 顾名思义，就是一个记录在 容器 or 数据结构 之中的存储位置。
这里有一组水果相关的英文单词，它们存储在不同容器之中，可以看到记录的关键码与其存储位置之间没有对应的关系。
正因为没有关系，假设我现在查找的目标记录是"watermelon"，就只能从起点开始，挨个地比较每个记录的关键码和目标记录的关键码的值是 “ = ” 还是 “ ≠ ”，直到出现相等或者找完才算是有结果，所以才说，元素的查找效率取决于关键码的比较次数。
那么有没有一种理想化的状态：查找的过程中，可以不通过任何的比较，而是让记录的关键码和记录的存储位置通过某种手段建立起一种一对一的映射关系，通过关键码直接就可以找到目标记录。
而达成这种理想化的查找状态的方法就是 “ 哈希 ”（或者说 “ 散列 ”），通过这个方法实现的存储结构，我们称之为 “ 哈希表 ”（或者说 “ 散列表 ”），记录的关键码和记录的存储位置建立映射关系的手段我们称之为 “ 哈希函数 ”（或者说 “ 散列函数 ”），哈希函数的作用是将记录的关键码转换成记录在哈希表的地址，对于这个地址我们一般称之为 “ 哈希值 ”（或者 “ 哈希地址 ”）。
" 哈希 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ed25c514d2efd05a98d2ee477f1a508/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/7/">«</a>
	<span class="pagination__item pagination__item--current">8/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/9/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>