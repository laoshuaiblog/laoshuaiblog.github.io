<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f42c07a5e2e945441fdd4fd80ff49e2/" rel="bookmark">
			设置tableLayoutPanel行列百分比大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		this.tableLayoutPanel1.ColumnStyles[1] = new ColumnStyle(SizeType.Percent, 100);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d838cd14fdce3801d5b2fbb1efab887f/" rel="bookmark">
			API【国内城市天气指数】（空气、湿度、风向、日出）- 0303
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口介绍： 查询国内城市天气常用指数（含空气指数，湿度指数，风向指数，日出日落时间等数据）
示例： 查询“北京”天气常用指数 { "code": 200, "message": "Succeed", "data": { "weather_night": "晴", "weather_light": "晴", "temperature_data_low": "4", "temperature_data_high": "20", "air_data": "35(优)", "humidity_data": "71%", "wind_data": "北风,一级", "sunset_data_out": "06:40", "sunset_data_in": "17:15", "status": "ok" } } 参考链接： 国内城市天气指数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c34a65f77eda291f19675deb8858ab/" rel="bookmark">
			数据挖掘——时间序列算法之ARIMA模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘——时间序列算法之ARIMA模型 前言差分定义ARIMA模型实践1、检验序列的平稳性2、进行一阶差分后，进行平稳性和白噪声检验3、对一阶差分之后的平稳非白噪声序列拟合ARMA模型1）人为识别方法2）相对最优模型识别 4、使用ARIMA预测 关于时间序列的其他模型，请参考本人的以下博文：
1、平滑法
2、趋势拟合法
3、组合模型
4、AR模型
5、MA模型
6、ARMA模型
7、ARIMA模型
8、ARCH模型
9、GARCH模型及其衍生模型
前言 前面几篇对平稳序列进行分析，然而实际上大多数时间序列都是非平稳的。对非平稳时间序列的分析方法可以分为确定性因素分解的时序分析和随机时序分析两个大类。
确定性因素分解的方法把所有序列的变化都归结为4个因素：长期趋势、季节变动、循环变动和随机波动。其中长期趋势和季节变动的规律性信息通常比较容易提取，而由随机因素导致的波动则非常难确定和分析，对随机信息浪费验证，会导致模型拟合精度差。随机时序分析法的发展就是为了弥补确定性因素分解方法的不足。根据时间序列的不同特点，随机时序分析可以建立的模型有ARIMA模型、残差自回归模型、季节模型、异方差模型。 差分定义 相距d期的两个序列值之间的减法运算称为d阶差分运算。（定义这个是为了后面用）
ARIMA模型 ARIMA模型（Autoregressive Integrated Moving Average model），差分整合移动平均自回归模型，又称整合移动平均自回归模型（移动也可称作滑动），是时间序列预测分析方法之一
许多非平稳序列差分后会显示出平稳序列的性质，这时非平稳序列为差分平稳序列。对差分平稳序列就可以使用ARMA模型进行拟合了。
ARIMA的数学表达：
x t = μ + φ 1 ∗ x t − 1 + . . . + φ p ∗ x t − p + θ 1 e t − 1 − . . . − θ q e t − q x_{t}= \mu + \varphi_{1}* x_{t-1}+ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66c34a65f77eda291f19675deb8858ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bf9aab9523d95b10133e5f6bec83505/" rel="bookmark">
			数据挖掘——时间序列算法之平滑法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘——时间序列算法之平滑法 前言平滑法1、简述2、移动平均法2.1、简单移动平均 2.2、加权移动平均法3、指数平滑法3.1、一次指数平滑3.2 二次平滑指数3.3、三次平滑指数 前言 时间序列是许多数据挖掘任务重最常见的类型之一，同时也比较难处理。这篇记录下我所理解下的时间序列模型的算法。注意，这不是特征工程，而是算法（暂时是这样理解的，毕竟目前还没使用过这些方法做特征工程）。
关于其他时间预测算法详见我的其他博文：
1、平滑法
2、趋势拟合法
3、组合模型
4、AR模型
5、MA模型
6、ARMA模型
7、ARIMA模型
8、ARCH模型
9、GARCH模型及其衍生模型
平滑法 1、简述 所谓时间序列平滑预测是指用平均的方法，把时间序列中的随机波动剔除掉，使序列变得比较平滑，以反映出其基本轨迹，并结合一定的模型进行预测。所平均的范围可以是整个序列（整体平均数），也可以是序列中的一部分（局部平均数）；所用平均数可以是简单平均数，也可以是加权平均数。在一次平均之后，就局部平均而言，还可以进行第二次、第三次以至更多次的平均，进行多层次的平滑。
所以，平滑预测的方法也是多种多样的。
平滑法常用于趋势分析和预测，利用修匀技术，削弱短期随机波动对序列的影响，使序列平滑化。根据所使用的平滑技术的不同，可具体分为移动平均法和指数平滑法。
2、移动平均法 移动平均法是用一组最近的实际数据值来预测未来一期或几期内公司产品的需求量、公司产能等的一种常用方法。移动平均法适用于即期预测。当产品需求既不快速增长也不快速下降，且不存在季节性因素时，移动平均法能有效地消除预测中的随机波动，是非常有用的。------来自百度百科 移动平均法根据预测时使用的各元素的权重不同，可以分为：**简单移动平均法**和**加权移动平均法。** 2.1、简单移动平均 简单时间序列平滑法是指用简单平均数进行预测的一类预测方法。当给定一组数据或观测值后，这些数值的平均数的种类很多，常见的有算术平均数、几何平均数、调和平均数、加权算术平均数、移动平均数与指数平滑平均数等。这些平均数各有各的计算方法，各有各的特点与用途，在使用平均法进行预测时，首先要判断使用哪一种或哪几种能够满足需要，然后再根据相应的计算方法求之。
由于算术平均数、几何平均数、调和平均数、加权算术平均数的计算方法相对其余几种来说，比较简单，故常称这几种平均数的求法为“简单平均法”。
举例：这里仅使用算数平均数来求预测值：
对应公式：
F ( t + 1 ) = V ( 1 ) + V ( 2 ) + . . . + V ( t ) t (1) F(t + 1) = \frac{V(1)+V(2)+...+V(t)}{t}\tag{1} F(t+1)=tV(1)+V(2)+...+V(t)​(1)
其中V(t)是第t时刻的实际值，F(t+1)是使用平均值得到的未来预测值
例如：某家商店在2047年、2048年、2049年的限售量分别为，25,35,30，那么预测在2050年该家商店的限售量为 25 + 35 + 30 3 = 30 \frac{25+35+30}{3}=30 325+35+30​=30
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bf9aab9523d95b10133e5f6bec83505/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f511f05171d2c27a938e9205aab5a16d/" rel="bookmark">
			matplotlib和imagemagick  用于GIF动画保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先安装imagemagick http://www.imagemagick.org/script/download.php
安装系统，选择相应的文件下载安装即可，具体可参考 Windows系统安装及初步使用ImageMagick
代码测试
import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation fig, ax = plt.subplots() xdata, ydata = [], [] ln, = plt.plot([], [], 'ro',animated=True) def init(): ax.set_xlim(-np.pi,np.pi) ax.set_ylim(-1, 1) return ln, def update(frame): xdata.append(frame) ydata.append(np.sin(frame)) ln.set_data(xdata, ydata) return ln, anim = animation.FuncAnimation(fig, update, frames=np.linspace(-np.pi,np.pi, 90),interval=10, init_func=init,blit=True) anim.save('test_animation.gif',writer='imagemagick') plt.show() 报错如下：
OSError: Error saving animation to file (cause: [Errno 22] Invalid argument) Stdout: b'' StdError: b''.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f511f05171d2c27a938e9205aab5a16d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d756cff4b31b5bac667b617c8bfa11/" rel="bookmark">
			时间序列模型之Arima Model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arima model应该是时间序列数据处理中最有名的方法之一了把，之前花了几周看了《Time Series Analysis with Application in R》的前12章，基本上是把基础的Arima模型都学完了，今天就按照R in Action中的代码依样画葫芦实际操作了一遍。
Arima Model思路 先写一下看完此书的一些感想把，具体的理论公式今天就先不写了，之后来补充把！
首先是MA model，也就是Yt可以完全由{ e t e_t et​}序列线性回归得到,{ e t e_t et​}是一个white noise。
然后是AR Model，也就是{ Y t Y_t Yt​}序列的自回归模型，AR Model可以看成是一个无穷阶的MA Model。
然后将这两个合起来也就是ARMA(p,q) Model了。
由于前面的推导都要求序列是平稳的（否则会出现参数估计不准的问题），但是实际数据往往是不平稳的，因此就需要差分，一阶差分可以消去线性趋势，二阶差分可以消去二次项趋势，三阶差分可以消去三次项趋势。当然还有log等等很多其他的平稳数据的方法了。
这就引出了Arima(p,d,q) Model了，也就是AR§,d阶差分平稳数据,MA(q)。
但是这只是普通的Arima Model模型，还有复杂带有季节性趋势的数据，这时就需要Arima(p,d,q)*(P,D,Q) Model了，也就是乘积季节Arima模型，这也就是上一篇博文里说的乘积模型(时间序列处理之Holt-Winters Model)，当然可以想到也有相加的Arima Model，只需要季节项中的P,Q均为0也就是相加模型了。所以说可以认为乘积Arima Model是更一般的Model。
季节Arima Model的公式如下所示：
Φ ( B S ) = 1 － Φ 1 B S － Φ 2 B 2 S － … － Φ P B P S Φ( B^S)= 1 － Φ_1B^S － Φ_2B^{2S} － … － Φ_PB^{PS} Φ(BS)=1－Φ1​BS－Φ2​B2S－…－ΦP​BPS， Θ ( B S ) = 1 － Θ 1 B S － Θ 2 B 2 S － … － Θ Q B Q S Θ( B_S) = 1 － Θ_1B^S－ Θ_2B^{2S} － … － Θ_QB^{QS} Θ(BS​)=1－Θ1​BS－Θ2​B2S－…－ΘQ​BQS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37d756cff4b31b5bac667b617c8bfa11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f46e64b377e0c0cb4b725e4d78ebcc/" rel="bookmark">
			MySQL约束类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性。
MYSQL中，常用的几种约束：
约束类型：主键自增外键唯一非空默认关键字primary keyauto_incrementforeign keyuniquenot nulldefault 主键约束 primary key 主键约束相当于 唯一约束 + 非空约束 的组合，主键约束列不允许重复，也不允许出现空值。
每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别创建。
当创建主键的约束时，系统默认会在所在的列和列组合上建立对应的唯一索引。
-- 基本模式 create table temp( id int primary key, name varchar(20) ); -- 组合模式 create table temp( id int , name varchar(20), pwd varchar(20), primary key(id, name) ); -- 删除主键约束 alter table temp drop primary key; -- 添加主键约束 alter table temp add primary key(id,name); -- 修改主键约束 alter table temp modify id int primary key； 自增约束 auto_increment 如果某一列是数值类型，使用可以完成值的自动增长（一般与主键一起使用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f46e64b377e0c0cb4b725e4d78ebcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03769251867dc85311b94c41c47fb1c/" rel="bookmark">
			详解聚类评估
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详解聚类评估 详解聚类评估估计聚类趋势方法一：观察聚类误差是否随聚类类别数量的增加而单调变化方法二：Hopkins Statistic（霍普金斯统计量） 判定数据簇数方法一：经验法方法二：手肘法方法三：交叉验证法 测定聚类质量外在方法（有监督方法）Jaccard Coefficient, JC（Jaccard系数）purity(纯度)sklearn 中 Purity 的实现 Fowlkes and Mallows Index, FMI（FM指数）sklearn中FMI的实现 Rand Index, RI（兰德系数）Adjusted Rand index, ARI （调整兰德系数）sklearn中Adjusted Rand index ，ARI 的实现 Normalized Mutual Information, NMI（标准化后的互信息）sklearn 中 Normalized Mutual Information, NMI 的实现 Adjusted Mutual Information, AMI（标准化后的互信息）sklearn 中 Adjusted Mutual Information, AMI 的实现 Homogeneity, completeness and V-measuresklearn 中Homogeneity, completeness and V-measure 的实现 内在方法 （无监督方法）Silhouette Coefficient（轮廓系数）sklearn 中 轮廓系数的实现 Calinski-Harabaz Indexsklearn 中 Calinski-Harabasz Index 的实现 详解聚类评估 估计聚类趋势 这一步骤是检测数据分布中是否存在非随机的簇结构 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c03769251867dc85311b94c41c47fb1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d88d398cf9376ab9c65df54fd445cdeb/" rel="bookmark">
			hadoop搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要的安装包：
1.jdk压缩包 2.hadoop压缩包 请前往百度云上上下载相关安装包(密码：8op1)
开始搭建hadoop集群
一.使用VMvare创建两个虚拟机，我使用的是ubuntu16.04版本的,并关闭全部虚拟机的防火墙
1.因为默认的虚拟机主机名都是ubuntu，所以为了便于虚拟机的识别，创建完成虚拟机后我们对虚拟机名进行修改，我们把用于主节点的虚拟机名称设为master(按自己的喜好创建)，把用于从节点的虚拟机名称设为slave1
修改主机名的命令:sudo gedit /etc/hostname
把原主机名ubuntu改为master（在从主机上则改为slave1)
2.为了虚拟机之间能ping通，需要修改虚拟机的ip地址（这里以在master机器操作为例子，从节点的虚拟机也要进行一致的操作）
命令：sudo gedit /etc/hosts 把/etc/hosts中yangcx-virtual-machine修改为刚刚改过的主机名master，同时将前面的ip地址改为实际的ip地址
怎么知道自己虚拟机的ip地址?
命令：ifconfig -a
上图红框标记的就是虚拟机的真实ip地址，因此我们把/etc/hosts中的内容修改为：
slave1的ip地址就是从虚拟机slave1的真实ip地址。同样，我们在slave1虚拟机上也要进行这一步操作。
3.关闭虚拟机的防火墙 一般来说，ubuntu默认都是安装防火墙软件ufw的，使用命令 sudo ufw version,如果出现ufw的版本信息，则说明已有ufw 使用命令 sudo ufw status查看防火墙开启状态：如果是active则说明开启，如果是inactive则说明关闭 开启/关闭防火墙 (默认设置是’disable’) sudo ufw enable|disable 我们使用sudo ufw disble来关闭防火墙，并再次用sudo ufw status 查看防火墙是否关闭 二.安装jdk(所有虚拟机都要安装配置)
将jdk的压缩文件拖进master和slave1虚拟机中，压缩(右键文件，extract here)，或者用命令行
tar -zxvf jdk1.8.0_161.tar.gz(使用自己的压缩文件名)
配置环境jdk环境：
命令：sudo gedit /etc/profile 将jdk的路径添加到文件后面(根据自己的文件路径来，我这里jdk1.8.0_161文件夹的路径是/home/hadoop/java)
export JAVA_HOME=/home/hadoop/java/jdk1.8.0_161
export JRE_HOME=/home/hadoop/java/jdk1.8.0_161/jre
export CLASSPATH=.: J A V A H O M E / l i b : JAVA_HOME/lib: JAVAH​OME/lib:JRE_HOME/lib:$CLASSPATH
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d88d398cf9376ab9c65df54fd445cdeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b5b089c41bb018374292f62c5752e38/" rel="bookmark">
			antd中如何给form表单做数据的返显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Ant-DesignUI库中的Form组件时，怎样在编辑页面时将之前保存过的数据返显在页面？
思路：
1、在componentDidMount生命周期中调用api获取后台数据；
2、通过form的setFieldsValue()方法将后台数据绑定到Form表单控件中。
注意：使用 getFieldsValue， getFieldValue， setFieldsValue 等时，应确保对应的 field 已经用 getFieldDecorator 注册过了。
页面展示如下：
实际代码如下：
index.jsx文件，
import React, { PureComponent } from 'react'; import { connect } from 'dva'; import Link from 'umi/link'; import { Form, Input, Button, Row, Col, message, Card} from 'antd'; import PageHeaderWrapper from '@/components/PageHeaderWrapper'; import router from 'umi/router'; import styles from './index.less'; // 设置input框的label以及input框的占比 const formItemLayout = { labelCol: {span: 9}, wrapperCol: {span: 15} }; // 绑定全局state @connect(state =&gt; { return { submitting:state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b5b089c41bb018374292f62c5752e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6989619df5aa5a843861286acced6f7e/" rel="bookmark">
			关于原生ajax获取后台servlet的response返回的数据问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一次回顾原生ajax获取后台数据时遇到了如下问题：
后台servlet使用了重定向将前端页面ajax传过来的值做了一个判断，然后返回结果给前端去弹框显示，如下代码：
response.getWriter.print(); response.sendRedict("index.html"); 前端接收主要代码：
var msg = xhr.responseText; alert(msg); 然后弹窗直接显示的是一块HTML的代码，后来把重定向代码注释后，显示的才是msg的内容，之后又把response.getWriter.print();进行注释（重定向未注释），发现弹窗是代码片段，所以认为重定向返回的是一个页面并且会覆盖,又想了一下感觉不严谨，如果是 response.getWriter.print()**;和response.sendRedict(“index.html”);
这两行返回的数据间隔太短，所以导致前端接收的太快才认为是重定向的数据覆盖，所以servlet改了一下代码
response.getWriter().print(msg);
Thread th = new Thread(); th.run(); try { th.sleep(5000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } response.sendRedirect("index.html"); 让程序在两行代码卡5秒看会不会看到两个弹窗，结果就是没有msg的弹窗，等5秒后才有代码段的弹窗，那么是不是*response.getWriter().print(),*返回的数据是跟随重定向的页面而去返回的呢！？但是开头就试验过没有重定向，他也能回传数据，所以创建了一个新的test.html页面，运行的时候发现重定向功能居然没执行!
天哪! servlet的重定向居然没有执行，然后上网查了一下，别人也有这样的问题（此处可上网搜索 关键词“ajax会不会重定向”）原来ajax只会做获取数据的工作，其他请求一概无视
想到这里，就是重定向返回的代码片段把上面一行的msg的数据覆盖了，所以如果在重定向后面再加一个返回msg那是不是就能返回msg了
结果最终返回的还是代码段，把代码段注释，又加了几个response.getWriter().print(),都能返回但是只要有重定向，重定向后面的数据好像返回不了
总结：ajax只做获取返回数据的工作，不会处理其他的请求
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02f22b67a88a848619b580c34737d28/" rel="bookmark">
			推荐几个可在线运行的Linux环境，可供学习使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文链接：https://www.jianshu.com/p/8b25f290e547 1.Unix Terminal Online 打开连接：http://www.tutorialspoint.com/unix_terminal_online.php 进入以下页面：
输入命令：ls -l
2.www@cb.vu 打开网址：http://cb.vu/进入以下页面：
输入命令：ls -l
3.JS/UIX - Terminal 打开网址：https://www.masswerk.at/jsuix/index.html
显示以下页面
点击&gt;open terminal，进入终端：
第一次输入命令：cd /
第二次输入命令：ls
结束 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfcb7b6eba64b2d2db6958549f5007fe/" rel="bookmark">
			spring security登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 用户名+密码 的方式来登录，用户名、密码存储在数据库，并且支持密码输入错误三次后开启验证码，通过这样一个过程来熟悉 spring security 的认证流程，掌握 spring security 的原理。
1、基础环境
① 创建 sunny-cloud-security 模块，端口号设置为 8010，在sunny-cloud-security模块引入security支持以及sunny-starter-core：
② 开发一个TestController
③ 不做任何配置，启动系统，然后访问 localhost:8010/test 时，会自动跳转到SpringSecurity默认的登录页面去进行认证。那这登录的用户名和密码从哪来呢？
启动项目时，从控制台输出中可以找到生成的 security 密码，从 UserDetailsServiceAutoConfiguration 可以得知，使用的是基于内存的用户管理器，默认的用户名为 user，密码是随机生成的UUID。
我们也可以修改默认的用户名和密码。
④ 使用 user 和生成的UUID密码登录成功后即可访问 /test 资源，最简单的一个认证就完成了。
在不做任何配置的情况下，security会把服务内所有资源的访问都保护起来，需要先进行身份证认证才可访问， 使用默认的表单登录或http basic认证方式。
不过这种默认方式肯定无法满足我们的需求，我们的用户名和密码都是存在数据库的。下面我们就来看看在 spring boot 中我们如何去配置自己的登录页面以及从数据库获取用户数据来完成用户登录。
2、自定义登录页面
① 首先开发一个登录页面，由于页面中会使用到一些动态数据，决定使用 thymeleaf 模板引擎，只需在 pom 中引入如下依赖，使用默认配置即可，具体有哪些配置可从 ThymeleafProperties 中了解到。
② 同时，在 resources 目录下，建 static 和 templates 两个目录，static 目录用于存放静态资源，templates 用于存放 thymeleaf 模板页面，同时配置MVC的静态资源映射。
③ 开发后台首页、登录页面的跳转地址，/login 接口用于向登录页面传递登录相关的数据，如用户名、是否启用验证码、错误消息等。
View Code
④ 从 spring boot 官方文档可以得知，spring security 的核心配置都在 WebSecurityConfigurerAdapter 里，我们只需继承该适配器覆盖默认配置即可。首先来看看默认的登录页面以及如何配置登录页面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfcb7b6eba64b2d2db6958549f5007fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c989cec798a456bae086e51b3a7d69c/" rel="bookmark">
			Jenkins 配置全局Http代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景：Jenkins在企业内网，不能直接联网，必须通过HTTP/HTTPS代理联网，通过NAT上网不算HTTP 代理范围。而有些情况需要联网，比如一些Public Cloud 插件必须联网（通过云API操作云），再必须连接外网的Slave Node等。
两种启动方式：
通过java -jar启动war包，这种情况直接在java启动的时候加参数： java -Dhttp.proxyPort=8080 -Dhttp.proxyHost=192.168.1.11 -Dhttps.proxyPort=8080 Dhttp.nonProxyHosts='localhost|127.0.0.1" -Dhttps.proxyHost=192.168.1.11 -Dhttps.nonProxyHosts='localhost|127.0.0.1" -jar jenkins.war Jenkins 运行在Tomcat中，这种情况修改Tomcat_home/bin/catalina.sh 文件，加入 JAVA_OPTS="$JAVA_OPTS -Dhttp.proxyPort=8080 -Dhttp.proxyHost=192.168.1.11 -Dhttps.proxyPort=8080 Dhttp.nonProxyHosts='localhost|127.0.0.1' -Dhttps.proxyHost=192.168.1.11 -Dhttps.nonProxyHosts='localhost|127.0.0.1' " 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc07628587a141b832dd821b83db03b/" rel="bookmark">
			Android NDK开发 Android.mk 转化 CMakeList.txt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译使用jni有两种构建方式，：
CMake：Android studio新的构建方式，Project Path需要选择CMakeList.txt文件路径，jni会按照这个脚本来进行编译，具体脚本的编写看下面。ndk-build：老eclipse的构建方式，也就是Android.mk的形式。
编写CMakeList.txt,以及跟Android.mk的对比
1.设置需要设置构建jni所需的CMake的最低版本
cmake_minimum_required(VERSION 3.4.1) 2.设置生成的so动态库最后输出的路径,如果项目的so库不需要给别人使用，也可以不设置，不设置的话会生成在build里面，如果给别人使用，寻找的话还是比较麻烦，所以指定一下路径更方便。
#设置生成的so动态库最后输出的路径，set后面两个参数， #前面一个是命令，后面是路径。 set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}) CMAKE_LIBRARY_OUTPUT_DIRECTORY : 指定的命令，用于设置输出的路径${PROJECT_SOURCE_DIR} :是指当前路径，也就是CMakeList.txt所在的路径,其实也可以不写，因为默认就是以CMakeList.txt所在的路径为起点。…/jniLibs: …两个点是回到上一层，一般来说我们都是建个jni文件夹用于放置c文件，CMakeList.txt是在jni文件夹下，也就是回到上一层，存放在jniLib里面。${ANDROID_ABI} 会根据架构来生成不同的文件夹放置对应的so文件。
3.设置头文件搜索路径，如果跟CMakeLists.txt同路径则不需要设置，同路径下文件夹不行。
#设置头文件搜索路径（和此txt同个路径的头文件无需设置），可选
include_directories(Cipher Core Core/Common Core/DB Core/DG) 对应于Android.mk 下的 LOCAL_C_INCLUDES 4.设置生成so库的名称，并为源文件提供一个相对路径
file(GLOB jni "*.cpp")//设置统配符 file(GLOB Cipher "Cipher/*.cpp")//设置统配符 add_library( # Sets the name of the library. 设置库的名称，也就是生成的so名称，在java代码中加载so库需要与此一致 demo # Sets the library as a shared library. 将library设置为一个共享库 SHARED # Provides a relative path to your source file(s).为源文件提供一个相对路径,可以使用通配符，也可以一个一个文件的引入 demo.cpp ${jni}//引用上面设置到通配符 ${Cipher} ) 对应于Android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fc07628587a141b832dd821b83db03b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3086758013ca4b219bdbf9a5d79f3c75/" rel="bookmark">
			jquery插件库免费下载，原生下载非扣代码，jq22 vip下载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复制jq22 地址到解析框就可以下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37e1bbde1df73e198aa881df898f696d/" rel="bookmark">
			ES6的模块化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你对模块化已经了解，可以直接从第三点开始阅读。
一、模块化的概念：
在进行项目分析或者编码时，先把项目进行拆分，拆分成很多的类，对象，很多的函数等等。能够提高代码的复用性。这些被拆分出来的类型，对象，函数就是模块。就像一辆汽车是由很多的零部件组成，每个零部件就是一个小模块，而由很多零件组成的发动机之于一辆汽车可以认为是一个大模块；或者说，一台计算机，由主板，cpu，内存，硬盘，显示器，键盘等大模块组成。而一个内存或者cpu又分别由很多的小模块组成。以模块为单位管理代码，会更加独立，调试方便，维护也很方便。
二、模块化经历的阶段：
1. 函数封装
这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。不同js文件里有相同的全局变量，如果被引入到同一个html文件中，全局变量就会互相影响。
2. 对象
这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系，看似不错的解决方案，但是也有缺陷，外部（对象之外）可以随意修改内部成员(属性)
对象的属性就是对象中每个方法的全局变量。
var p = { id:"007", name :"芙蓉", age:25, eat:function(str){ alert(this.name+"在吃"+str); }, work:function(str){ alert(this.name+“在干"+str); } } //存在问题： //如：对于p对象的年龄,有效取值应该是在0-150之间的整数。 // 而以下代码的执行， p.age = 151; 都会使得项目内部出现了不合法的数据。这是程序的健壮性不好。 所以，对于对象的成员变量(属性)，应该不能被外部访问才对。 3. 立即执行函数
可以通过立即执行函数，来达到隐藏细节的目的
var p = (function (){ var name="芙蓉"; var age=25; function eat(str){ alert(this.name+"在吃"+str); } function setAge(age){ if(age&lt;0 || age&gt;150){ alert("亲，年龄超出有效值（0-150）的范围"); return; } age = age; } function getAge(){ return age; } return { eat:eat, setAge:setAge, getAge:getAge } })(); var p = (function (){ var name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37e1bbde1df73e198aa881df898f696d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f58f861cc9c5bbab730435c9907fb3/" rel="bookmark">
			AttributeError: module &#39;PIL&#39; has no attribute &#39;open&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做数据增强读图的时候，会出现AttributeError: module 'PIL' has no attribute 'open'情况，如下图：
在程序中加了一句，就能读图了。
import Image
希望对你有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/435687bd50c875844974c5db362994c5/" rel="bookmark">
			STM32 IIC问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 IIC问题 1、卡在while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));
（1）检测硬件总线空闲时是否都为高电平
（2）先GPIO时钟使能，再I2C时钟使能，然后才配置IIC（注意顺序！！）
2、 卡在while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
同1
3、卡在while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
一般是由于从设备速度不够快造成的，将STM32主机IIC总线速度适当降一些即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd7e48f6821367f2c241f4bb63ab338/" rel="bookmark">
			STM8 串口波特率与设置值不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近调试STM8L串口通讯，发现设置了波特率115200，实际波特率却是57600。心想这种问题一般是串口的时钟分频设置不对，找了半天没有找到单独设置串口时钟的地方，费了不少时间。
void Uart1_Configer(void)
{
CLK_PeripheralClockConfig (CLK_Peripheral_USART3,ENABLE); //开启ADC/USART时钟
GPIO_Init(GPIOA, GPIO_Pin_2, GPIO_Mode_Out_PP_High_Fast); //TX
GPIO_Init(GPIOA, GPIO_Pin_3, GPIO_Mode_In_FL_No_IT); //RX
USART_Init(USART1,115200,USART_WordLength_8b,USART_StopBits_1,USART_Parity_No,
(USART_Mode_TypeDef)(USART_Mode_Rx|USART_Mode_Tx)); //USART初始化
USART_ClearITPendingBit(USART1,USART_IT_RXNE);
ITC_SetSoftwarePriority(USART1_RX_IRQn,ITC_PriorityLevel_3); //优先级最高
USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);
USART_Cmd (USART1,ENABLE); //使能USART
}
最后发现在固件库文件里有设置外部晶振频率的宏定义，这个坑确实大。
把HSE_VALUE由16000000改成8000000就好了。
/**
* @brief In the following line adjust the value of External High Speed oscillator (HSE)
used in your application
Tip: To avoid modifying this file each time you need to use different HSE, you
can define the HSE value in your toolchain compiler preprocessor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efd7e48f6821367f2c241f4bb63ab338/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/110/">«</a>
	<span class="pagination__item pagination__item--current">111/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/112/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>