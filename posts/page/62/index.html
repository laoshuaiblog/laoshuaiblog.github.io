<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec93325166f407d6f03981bfa566ebc/" rel="bookmark">
			C语言入门第七讲（应用二：水仙花数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 所谓"水仙花数"是指一个三位数，其各位数字立方和等于该本身。 例如：153是一个水仙花数，因为153=1^3+5^3+3^3。
分析：可以用前面讲过的循环来遍历所有的三位数，对每个三位数进行验证，符合要求就对其进行输出。具体代码如下：
#include &lt;stdio.h&gt; int main(){ int a,b,c; int sum; for(int i=100;i&lt;1000;i++){ a=i%10; b=(i-a)/10%10; c=i/100; sum=a*a*a+b*b*b+c*c*c; if(sum==i){ printf("%d ",i); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8339391177fffa45d2c2ea4248ecf4d6/" rel="bookmark">
			新华三 HCL模拟器配置ssh远程登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：
SSH 是建立在应用层基础上的安全协议。
SSH 是较可靠，专为远程会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。
开启ssh服务更方便后续对网络设备的管理
实验需求：在R1开启ssh服务并在本地主机登录至R1
实验拓扑：
1.ip地址配置
查看本地虚拟网卡的ip地址
将路由器接口的ip配置在与虚拟网卡同一网段即可
&lt;H3C&gt;sy System View: return to User View with Ctrl+Z. [H3C]sysna R1 [R1]int g0/0 [R1-GigabitEthernet0/0]ip add 192.168.56.2 24 连通性测试
2.在R1路由器配置ssh服务 [R1]ssh server enable //开启ssh服务 [R1]line vty 0 4 //进入vty用户试图，允许五个用户同时登陆 [R1-line-vty0-4]authentication-mode scheme //设置认证模式，scheme表示用户名和密码组合模式 [R1-line-vty0-4]user-role level-15 //配置用户权限为最高权限 [R1-line-vty0-4]protocol inbound ssh //用于ssh协议 [R1-line-vty0-4]qu [R1]local-user h3c //新建用户h3c New local user added. [R1-luser-manage-h3c]password simple 123 //用户密码为123 [R1-luser-manage-h3c]service-type ssh //协议类型为ssh [R1-luser-manage-h3c]authorization-attribute user-role level-15 //配置用户权限为最高权限 [R1-luser-manage-h3c]authorization-attribute user-role network-admin //认证策略。登陆的用户为管理员用户 [R1-luser-manage-h3c]qu 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8339391177fffa45d2c2ea4248ecf4d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ebbba7fc1b5534f960facf4da98db7/" rel="bookmark">
			钉钉机器人报警设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		钉钉机器人报警设置 1. 钉钉机器人相关设置 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传
2. 添加机器人 3. 选择自定义机器人 4. 选择一个安全标签 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传
5. 添加完生成一个webhook 参考文档
6. java 代码 package com.cjpension.ppmshttpbaffle.aspect; import cn.hutool.core.date.DateUtil; import cn.hutool.core.net.NetUtil; import cn.hutool.http.HttpUtil; import com.alibaba.fastjson.JSONObject; import lombok.extern.slf4j.Slf4j; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.AfterThrowing; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.concurrent.atomic.AtomicInteger; /** * @ClassName ExceptionLogAspect * @Description TODO * @Author maido * @Date 21:11 2022/12/12 * @Version 1.0 **/ @Slf4j @Aspect @Configuration @Profile(value = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ebbba7fc1b5534f960facf4da98db7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e26dceeb37daa9e61b76efe7aa6fbab0/" rel="bookmark">
			Modbus TCP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Modbus协议
Modbus是一种工业总线协议标准，包括ASCII、RTU、TCP三种报文类型，其物理层接口有RS-232、RS-485、RS-422、及以太网，采用主/从方式进行通信。
2、Modbus-TCP基于以太网TCP/IP协议，将数据以Modbus格式进行传输
以太网格式：
目标地址（6B）+源地址（6B）+类型（2B）+数据（46-1500B）+CRC（4B）
Modbus-TCP帧格式：
报头（7B）+帧结构PDU
报头格式：
事务处理标识（可理解为报文的序列号2B）+协议标识（2B，0000表示Modbus-TCP协议）+长度（接下来的数据长度2B）+单元标识（可理解为设备地址1B）
帧结构PDU
功能码（1B）+数据（n）
Modbus的操作对象有4种：
线圈：PLC的输出位，开关量，在Modbus中可读可写
离散量：PLC的输入位，开关量，在Modbus中只读
输入寄存器：PLC中只能从模拟量输入端改变的寄存器，在Modbus中只读
保持寄存器：PLC中用于输出模拟量信号的寄存器，在Modbus中可读可写；
Modbus的功能码：
0x01：读线圈
线圈数量1-2000个
请求（5B）：0x01+起始地址H+起始地址L+线圈数量H+线圈数量L
响应：0x01+字节数+线圈状态（NB）—一个地址的数据为1位
0x02：读离散量
同上
0x03：读保持寄存器
请求（5B）：0x03+起始地址H+起始地址L+寄存器数量H+寄存器数量L
响应（2+寄存器数量2): 0x03+字节数+寄存器数据
0x04：读输入寄存器
同上
0x05：写单个线圈
0xFF00值对应ON、0x0000值对应OFF
请求（5B）：0x05+线圈地址H+线圈地址L+线圈值H+线圈值L
响应（5B）：0x05+线圈地址H+线圈地址L+线圈值H+线圈值L
0x06：写单个保持寄存器
请求（5B）：0x06+寄存器地址H+寄存器地址L+寄存器值H+寄存器值L
响应（5B): 0x06+寄存器地址H+寄存器地址L+寄存器值H+寄存器值L
0x0F：写多个线圈
数量1-0x78
请求（6+输出数量B）：0x0F+起始地址H+起始地址L+输出数量H+输出数量L+字节数（1B，值为N）+输出值（N个）
响应（5B): 0x10+起始地址H+起始地址L+输出数量H+输出数量L
0x10：写多个个保持寄存器
数量1-0x78
请求（6+寄存器数量2B）：0x10+起始地址H+起始地址L+寄存器数量H+寄存器数量L+字节数（1B，值为2N）+寄存器值（2N个）
响应（5B): 0x10+起始地址H+起始地址L+寄存器数量H+寄存器数量L
3、Modbus-TCP通信方式
Modbus分为主站和从站，主站只有一个，从站有多个，主站给从站发送请求帧，从站响应。在使用TCP通信时，主站为client端，主动建立连接，从站为server端，等待连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3f99c22f880ddca4ba2279579c78fb/" rel="bookmark">
			QT下的Modbus TCP 通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、关于Modbus二、Modbus TCP Master的实现1.封装自己的Modbus类2.Modbus 通过TCP/IP进行连接3.Modbus 通过TCP/IP读取数据（1）读取线圈数据（2）读取保持寄存器数据（3）给线圈写入数据（4）给保持寄存器写数据 总结 #已有最新文章，使用第三方C库更加方便、高效、稳定。
#已有最新文章，使用第三方C库更加方便、高效、稳定。
#已有最新文章，使用第三方C库更加方便、高效、稳定。
https://blog.csdn.net/weixin_44894312/article/details/128289001?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128289001%22%2C%22source%22%3A%22weixin_44894312%22%7D
前言 Modbus在工业控制中的应用非常多，由于其免费使用加上一定的历史环境，Modbus在PLC上的通讯应用非常多，本文主要介绍Mosbus TCP master（主站）的实现。
一、关于Modbus Modbus是由MODICON公司开发的一种工业现场总线协议标准，随后施耐德推出了基于TCP/IP的MOdbus协议：Modbus tcp；
Modbus协议是一项应用层报文传输协议，包括ASCII、RTU、TCP三种报文类型。
标准的Modbus协议物理层接口有RS232、RS422、RS485和以太网接口，采用master/slave方式通信。
####################################################
Modbus有4种操作对象：线圈、离散输入、输入寄存器、保持寄存器
Coils、DiscreteInputs、InputRegisters、HoldingRegisters
线圈：PLC的输出位，开关量，在MOdbus中可读可写；
离散输入：PLC的输入位，开关量，在Modbus中只读；
输入寄存器：PLC中只能从模拟量输入端改变的寄存器，在MODBUS中只读
保持寄存器：PLC中用于输出模拟量信号的寄存器，在MODBUS中可读可写
由于是基于QT去实现的ModbusTCP通讯，所以对Modbus的功能码不需要做过多的掌握，了解即可。
二、Modbus TCP Master的实现 //主站的实现，一般都是上位机做主站，PLC做从站 1.封装自己的Modbus类 QT.pro文件中添加 serialbus 模块：
QT += core gui sql serialbus
让自定义类继承QObject，在头文件中添加相应的头文件 QModbusTcpClient 类 和 QModbusDataUnit 类
在自定义类中创建modbus TCP client 对象指针。
QModbusTcpClient *My_client;
2.Modbus 通过TCP/IP进行连接 自定义类的构造函数中实例化Modbus tcp对象：
My_client = new QModbusTcpClient(); Modbus TCP/IP协议进行连接的时候需要通过IP + Port ；
//端口号一般用502
/******************************************** * 函数名称：Connect_to_modbus(QString IP_address,int Port) * 功能：连接到modbus设备 * 工作方式： * 参数： 参数1：modbus设备的IP地址 QString 类型 参数2：modbus设备的端口号(一般用502) int 类型 * 返回值：成功返回true，失败返回fasle。 * 备注： * 修改记录 *********************************************/ bool My_modbus_tcp::Connect_to_modbus(QString IP_address,int Port) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3f99c22f880ddca4ba2279579c78fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741cb0b1f1e95eb422ce5db67b5e381e/" rel="bookmark">
			C# 网口通信（modbus），自动重连
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建接收线程。
Com2Ups60Thread = new Thread(Com2Ups60);
Com2Ups60Thread.IsBackground = true;
Com2Ups60Thread.Start();
2.线程函数。
private void Com2Ups60()
{
try
{
Logger.Info("Com2Ups60() Start");
ModbusFactory modbusFactory = new ModbusFactory();
NModbus.IModbusMaster master = modbusFactory.CreateMaster(new TcpClient(_nameValueCollection["UPSYiDun_IP"], int.Parse(_nameValueCollection["UPSYiDun_Port"])));
master.Transport.ReadTimeout = 1000;
master.Transport.Retries = 1000;
//参数(分别为站号,起始地址,长度)
byte slaveAddress = 1;
ushort startAddress = 200;
ushort numberOfPoints = 125; // 这个长度不能超过125
isups60Connect = true;
while (true)
{
ushort[] registerBuffer = master.ReadInputRegisters(slaveAddress, startAddress, numberOfPoints);
for (int i = 0; i &lt; registerBuffer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741cb0b1f1e95eb422ce5db67b5e381e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d94a431fa4e9269056f7b8dc3f373e/" rel="bookmark">
			vue——VM对象和基础指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、VUE 简介： Vue.js是前端的主流框架之一，和Angular.js、React.js并称为前端三大主流框架。是一款用于构建用户界面的 JavaScript 框架。Vue.js 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助用户高效地开发用户界面。是个很多js工具代码的js文件。 Vue.js 的特点：
数据驱动Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 Vue.js 的目标
通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件 前端三大主流框架： vue.js 数据驱动和组件化开发，轻量级，分层渐进式框架
React.js 数据驱动和组件化开发，灵活性很高，需要什么都得自己构建逻辑自己写
Angular.js 数据驱动 1.0 ，加上了组件化开发2.0，重量级框架;大型企业OA办公（指令系统）
引入方式： 第一类：
1.本地js文件引入
2.CDN引入
3.webpack 打包
4.编辑器生成(HBuilder)
第二类：(vue脚手架 需要加载器转码再引入到网页中)
1.自己打包配置加载器（自己构建vue脚手架）
2.官方脚手架
npm i @vue/cli -g
vue create app
cd app
npm run serve
3.可视化项目管理方式 vue ui
4.编辑器直接生成脚手架环境的方式(HBuilder)
包的版本管理： 示例版本：7.18.6 已更新到12.3.8
"~7.18.6" ：直接下载最新版 即12.3.8
"^7.18.6" ：下载7-版本号的最新版 如 7.20.8(7开头的版本中的最新版)
"7.18.6" ：下载固定版本 即7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5d94a431fa4e9269056f7b8dc3f373e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db98f7c09f8efa9f8dc3a7b184c22b6b/" rel="bookmark">
			Jedis的介绍和使用，教你在Java中操作Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是Jedis二、测试Jedis2.1 操作Key2.2 操作String2.3 操作List2.4 操作Set2.5 操作Hash 三、事务四、SpringBoot整合4.1 整合测试4.2 序列化介绍4.3 自定义RedisTemplate4.4 自定义RedisUtil 还不了解Redis的同学可以查看我的Redis入门教程！适合零基础小白的Redis入门学习教程
一、什么是Jedis Jedis是Redis官方推荐的Java连接开发工具，使用Java操作Redis的中间件。如果你要使用Java操作Redis吗，那么一定要对Jedis十分熟悉。
二、测试Jedis 1、导入对应的依赖
依赖可在Maven依赖官网中搜索得到
前往Maven依赖官网
&lt;!-- 导入Jedis包 --&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- fastjson --&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、编码测试
连接数据库操作命令断开连接 连接数据库：
public class TestPing { public static void main(String[] args) { //new一个Jedis对象 Jedis jedis = new Jedis("127.0.0.1", 6379); //Jedis的所有命令就是我们之前学的所有命令，指令学习很重要！ System.out.println(jedis.ping()); } } 连接结果：
2.1 操作Key public class TestKey { public static void main(String[] args) { Jedis jedis = new Jedis("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db98f7c09f8efa9f8dc3a7b184c22b6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f946b03a74e9bfdcc1189f3bbcec6a36/" rel="bookmark">
			浮点数的运算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浮点数的运算方法 一、浮点数的表示1.浮点数的表示2.IEEE 754标准3.浮点数类型 二、浮点数的加减法1.定义2.运算步骤 三、运算部件四、强化练习 一、浮点数的表示 1.浮点数的表示 Ms表示尾数的符号位，E中1bit保存阶码的符号位其余空间存放阶码值，M中存放规格化后的尾数。
因为尾数规格化后其绝对值应大于或等于0.5D，故小数点后第一位都是1，故从小数点后第二位开始保存即可，节省空间并提高精度。
机器零的表示：
2.IEEE 754标准 预备知识：
◆ 单精度浮点数(32位)，阶码8位，尾数为24位(内含1位符号位)
◆ 双精度浮点数(64位)，阶码为11位，尾数为53位(内含1位符号位)
◆ 基数为2
◆ 阶码采用增码(即移码)，尾数采用原码
◆ 规格化原码尾数最高位 1 不在尾数中表示出来
➢ 恒为1，计算时在尾数的前面自动添加1.
➢ 隐含的1是一位整数（即位权为20）
为什么阶码采用移码：便于比较浮点数的大小
移码(增码)的特点
◆ 最高位为符号位，1表示正数，0表示负数（不同于原码，补码，反码的符号位规定，更符合人们对数值大小的认知。）
◆ 移码只执行加减法运算—专为阶码而生
◆ 需要对运算结果修正，修正量为2n
◆ 数据零有唯一的编码
IEEE 754标准：
单精度浮点数(32位)，阶码8位，尾数为24位(内含1位符号位) ，偏置值127（二进制：1111111）
◆ 基数为2
◆ 阶码采用增码(即移码)，尾数采用原码
◆ 规格化原码尾数最高位 1 不在尾数中表示出来
➢ 恒为1，计算时在尾数的前面自动添加1.
➢ 隐含的1是一位整数（即位权为 2 0 2^{0} 20）
标准化过程：
3.浮点数类型 C语言中的浮点数类型
◆ float (十进制有效数字位数为7位)
◆ double(十进制有效数字位数为17位)
◆ 扩展双精度 long double
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f946b03a74e9bfdcc1189f3bbcec6a36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c805089991e2884e39c102066c753cc9/" rel="bookmark">
			基于LSTM递归神经网络的多特征电能负荷预测（Python代码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓个人主页：研学社的博客 💥💥💞💞欢迎来到本博客❤️❤️💥💥
🏆博主优势：🌞🌞🌞博客内容尽量做到思维缜密，逻辑清晰，为了方便读者。
⛳️座右铭：行百里者，半于九十。
📋📋📋本文目录如下：🎁🎁🎁
目录
💥1 概述
📚2 运行结果
🌈3 Python代码实现
🎉4 参考文献
💥1 概述 电能负荷预测按细粒度划分可分为粗度预测和细度预测。其中粗度预测则是将整个时间段的电能负荷数据进行训练，进而进行预测。而细度预测这是要考虑电能负荷季节，时间周期影响因子。
在进行城市居民电能负荷粗度预测时需要考虑比较如下三种情况的准确率：
利用上一时刻的电能负荷（power），温度（temperature），湿度（humidity），风速（speed）预测此刻的电能负荷，power_load_forecasting_V1利用上一时刻的电能负荷（power）和此刻的温度（temperature），湿度（humidity），风速（speed）预测此刻的电能负荷，利用上一若干时刻的电能负荷（power），温度（temperature），湿度（humidity），风速（speed）预测此刻的电能负荷，
在进行城市居民电能负荷细度预测时，除了要考虑如上问题时，还需要考虑季节，时间周期等影响因子：电力负荷往往具有周期性，夏季，冬季，过渡季（春季和秋季）用户用电量往往差距很大，因此在预测是可以考虑分开预测，在各个季节进行预测是，我们还可以按天，周，月进行划分， 📚2 运行结果 122/122 - 0s - loss: 0.0303 - val_loss: 0.0392 - 167ms/epoch - 1ms/step Epoch 41/50 122/122 - 0s - loss: 0.0303 - val_loss: 0.0391 - 170ms/epoch - 1ms/step Epoch 42/50 122/122 - 0s - loss: 0.0303 - val_loss: 0.0393 - 170ms/epoch - 1ms/step Epoch 43/50 122/122 - 0s - loss: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c805089991e2884e39c102066c753cc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ccd6db00d64565fda550318d0b31a30/" rel="bookmark">
			成功解决-\venv\Scripts\activate.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 ht
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 问题
2. 解决方式
管理员运行powershell
进入项目执行
2.1 get-ExecutionPolicy
2.2 set-ExecutionPolicy RemoteSigned
按y 结束，自此解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3375dca12b0fbb6fe0ecb9ff0bba452/" rel="bookmark">
			针对mysql批量删除表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 项目进行微服务拆分，拆分之后，需要把以前的表清理掉，但是删除表的语句，都是一个个执行的，但是服务下面50多张表，一个个执行，比较麻烦，如果表在多些，还不把人累死，那我们可以批量删除表嘛，可以的，只不过是曲折路线
方案： 步骤1： 执行如下sql,拼接删除表语句
select CONCAT( 'drop table ', table_name, ';' ) FROM information_schema.tables Where table_name LIKE 't_promotion_%'; 注意：我这查询出来表名字有重复的，sql可以稍微修改下
Select DISTINCT(CONCAT( 'drop table ', table_name, ';' )) FROM information_schema.tables Where table_name LIKE 't_promotion_%'; 步骤2： 导出查询结果，处理下不需要的字符，然后执行对应sql就行
注意：这里处理不必要的特殊字符时候，用notepad的批量替换功能就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2428058f2ac4f2e337c7a682ce0dfaeb/" rel="bookmark">
			NGINX最常用的指令（最全的查询）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务管理
sudo systemctl status nginx # nginx当前状态
sudo systemctl reload nginx # 重新加载 nginx
sudo systemctl restart nginx # 重启nginx
sudo nginx -t # 检查语法
nginx # 启动
nginx -s reload # 重启
nginx -s stop # 关闭进程
nginx -s quit # 平滑关闭nginx
nginx -V # 查看nginx的安装状态，
Docker 安装
docker run --name some-nginx -v /some/content:/usr/share/nginx/html:ro -d nginx
简单代理
location / {
proxy_pass http://127.0.0.1:3000;
proxy_redirect off;
proxy_set_header Host $host;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2428058f2ac4f2e337c7a682ce0dfaeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262b23bbb94ad798a5ab20873730eb1c/" rel="bookmark">
			@Validated注解不生效问题汇总大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 项目框架应用的是validation进行检验的，但是最近一直不生效，然后排查了下问题，总结了失效的常见几个原因：
原因1： 在2.3.0版本之前spring-boot-starter-web是集成了validation检验的
但是在2.3.0开始就去掉了该依赖，所以需要自己添加该依赖，
添加依赖为：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; 下面截图对照下：
2.7.2版本
2.0.1.RELEASE版本
原因2：
参数如果是非对象格式，需要在controller类上面添加@Validated注解
截图如下：
原因3：
参数如果是对象的话，属性的前面的需要添加 @Valid注解，截图如下：
原因4：
如果是嵌套对象的话，里面的对象还要添加 @Valid注解，截图如下：
这里要注意，如果是集合对象，同样需要添加@Valid注解，不然不生效的
截图如下：
基本上就是上面这些原因
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8c0a8c1cd4051e6d5bb687e34bf092/" rel="bookmark">
			4.将数组a中的n个整数按逆序存放。即：a[0]与a[n-1]交换，a[1]与a[n-2]交换......。交换要调用函数 void(int *a,int n)。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; #define N 10 void sort(int *a,int n) { int i,j,temp; for(i=0,j=n-1; i&lt;n/2,j&gt;=n/2; i++,j--) { temp=a[j]; a[j]=a[i]; a[i]=temp; } } int main() { int a[N],i,n=10; printf("输入10个数字:"); for(i=0; i&lt;N; i++) { scanf("%d",&amp;a[i]); } sort(&amp;a,n); for(i=0; i&lt;N; i++) { printf("%d ",a[i]); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e147a7f942903558ea1bc834f0140370/" rel="bookmark">
			java高级编程之反射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是反射 1.1对反射的简单理解 就像我上面所画的图，反射就相当于一个逆过程，比如我们正常的创建一个对象是通过
Person person = new Person; 但如果我们想通过反射创建一个对象就需要这样
Class clazz = Person.class; Person person =(Person)clazz.newInstance(); 1.2对反射的深入理解 能够分析类能力的程序称为反射，反射机制的功能极其强大反射可以用来：
1.在运行时分析类的能力
2.在运行时检查对象，例如编写一个适用于所有类的toString方法
3.实现泛型数组操作代码
4.利用Method对象，这个对象很像C++中的函数指针
2.Class类 2.1获得Class类对象的三种常用方法 通过运行时类的对象获取Class类对象
Person person = new Person(); Class clazz = person.getClss(); 通过全类名获取Class类对象
Class clazz = Class.forName("Person类的全路径")； 通过运行时的类名获取Class类对象
Class clazz = Person.class; 我们常用第二种方法获取Class类实例，因为这能更好的体现反射的动态性！提到反射的动态性我觉得有必要来聊一聊编译时和运行时，第一种和第三种方法一样，如果在编译阶段没有找到Person类，那么就会报错(就相当于我们平时说的写死了！)而第三种方法是在运行时阶段去找这个全路径下的类，没有找到才会抛异常(很活。。。很动态。。。)
3.检查类的结构 在java.lang.Reflect包中有三个类Field、Method、Constructor分别用于描述类的字段、方法、和构造器，这三个类都有一个叫getName的方法，用来返回字段，方法，或构造器的名称
Field类有一个getType方法，用来描述字段类型的一个对象，这个对象的类型同样是Class，Method类还有一个报告返回类型的方法，这三个类都有一个名为getModifiers的方法，它将返回一个整数，用不同的0/1位描述所使用的修饰符，如public和static。
Class类中的getFields、getMethods和getConstructors方法将分别返回这个类支持的公共字段、方法和构造器的数组，其中包括超类的共同成员
Class类中的getDeclareFields、getDeclareMethods、getDeclareConstructors方法将分别返回类中声明的全部字段、方法、和构造器的数组，其中包括私有成员、包成员和受保护成员，但不包括超类的成员 package com.atguigu.java; import java.lang.reflect.Field; class Person{ public String name; private int age; public String address; public Person(){ } private Person(String name){ } } class Student extends Person{ public char sex; public void read(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e147a7f942903558ea1bc834f0140370/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9eb666c0b0b069ceedc1178526d274b/" rel="bookmark">
			Linux学习笔记1：Linux及虚拟机的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装虚拟机15的链接：
https://www.jianshu.com/p/552179808ebf
https://www.jianshu.com/p/ce08cdbc4ddb?utm_source=tuicool&amp;utm_medium=referral
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d65d57bc9b6ec2adffff9df8ba6adc/" rel="bookmark">
			用HttpClient发送HTTPS请求报SSLException: Certificate for ＜域名＞ doesn‘t match any of the subject alternative
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误 ：
httpclient 版本
处理方式：
CloseableHttpClient httpclient = null; try { SSLConnectionSocketFactory scsf = new SSLConnectionSocketFactory( SSLContexts.custom().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build(), NoopHostnameVerifier.INSTANCE ); httpclient = HttpClients.custom().setSSLSocketFactory(scsf).build(); // CloseableHttpClient httpclient = HttpClients.createDefault(); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } catch (KeyStoreException e) { throw new RuntimeException(e); } catch (KeyManagementException e) { throw new RuntimeException(e); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49af8a7b538662a87c847e99771ed02b/" rel="bookmark">
			40个高质量ssm&#43;vue毕设项目分享【源码&#43;论文】（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言 课题1 : 基于SSM与VUE的旅游信息分享管理平台 &lt;br /&gt; 课题2：基于SSM+VUE的中医商城管理系统 &lt;br /&gt; 课题3 : 基于SSM的汽车租赁系统&lt;br /&gt; 课题4 : 基于SSM与VUE的汉服销售论坛系统 &lt;br /&gt; 课题5 : 基于SSM的疫情校园师生登记备案系统 &lt;br /&gt; 课题6 : 基于SSM与VUE的农产品商品信息管理系统 &lt;br /&gt; 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的java web缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的java web管理系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享5个优质ssm+vue毕业设计项目，需要的自取。
课题1 : 基于SSM与VUE的旅游信息分享管理平台 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、用户管理、景点信息管理、购票信息管理、酒店信息管理、客房类型管理、客房信息管理、客房预订管理、交流论坛、系统管理用户：首页、个人中心、购票信息管理、客房预订管理、我的收藏管理前台首页：首页、景点信息、酒店信息、客房信息、交流论坛、红色文化、个人中心、后台管理、客服 🥇 项目详细描述地址:
https://gitee.com/sinonfin/L-javaWebSha/tree/master
课题2：基于SSM+VUE的中医商城管理系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：会员管理、药材分类管理、药材信息管理、保健药方管理、送礼套餐管理、入库记录管理、出库记录管理、管理员管理、系统管理、订单管理会员前台：首页、药材信息、保健药方、送礼套餐、新闻资讯、我的、跳转到后台、购买车、客服会员后台：我的收藏管理、订单管理 🥇 项目详细描述地址:
https://gitee.com/sinonfin/L-javaWebSha/tree/master
课题3 : 基于SSM的汽车租赁系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49af8a7b538662a87c847e99771ed02b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c604e7be7c990736d2f87e3466257b03/" rel="bookmark">
			avue 弹框自定义按钮内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;basic-container&gt; &lt;avue-crud :option="option" :table-loading="loading" :data="data" :page.sync="page" :permission="permissionList" :before-open="beforeOpen" v-model="form" ref="crud" @row-update="rowUpdate" @row-save="rowSave" @row-del="rowDel" @search-change="searchChange" @search-reset="searchReset" @selection-change="selectionChange" @current-change="currentChange" @size-change="sizeChange" @refresh-change="refreshChange" @on-load="onLoad" &gt; 自定义 列表按钮 &lt;template slot="menu"&gt; &lt;el-button type="text" size="small" icon="el-icon-s-order" @click="detailLookFn" &gt; 查询详情 &lt;/el-button&gt; &lt;/template&gt; 自定义头部按钮 &lt;template slot="menuLeft"&gt; &lt;el-button type="primary" size="small" icon="el-icon-s-release" v-if="permission.reviewer_delete" @click="SendFn(2)" &gt;发布至内网 &lt;/el-button&gt; &lt;/template&gt; &lt;!-- 插入 --&gt; 弹框内容 &lt;div slot-scope="{}" slot="bindForm" style="display: inline-block"&gt; &lt;el-upload style="width: 60px; display: inline-block" class="upload-demo" action="/api/blade-resource/oss/endpoint/put-file" :on-success="handleSuccess" :show-file-list="false" :headers="headers" &gt; &lt;el-button size="small" type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c604e7be7c990736d2f87e3466257b03/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/61/">«</a>
	<span class="pagination__item pagination__item--current">62/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/63/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>