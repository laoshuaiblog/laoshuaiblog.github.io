<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd12617fc5ed5b88a5cf0514c97fb9eb/" rel="bookmark">
			【数学理论】随机矩阵理论-20240104
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学到理论：
随机矩阵理论（random matrix theory）：在电力行业目前的博士论文在上海交大主要是做监测，设备状态评估、故障定位、异常检测、用电特征分析、电网态势感知和稳定评估等方面。
关注：Terence Tao VPN-美国数学学会-361755
研究：全新求解特征向量的公式，如果公式是正确的，就表示只需要通过删除原始矩阵的行和列，创建子矩阵。再将子矩阵和原始矩阵的特征值组合在一起，就可以计算原始矩阵的特征向量。简而言之，已知特征值，一个方程式就可以求得特征向量。
Eigenvector from Eigenvalue（2019）
书本：普林斯顿概率论读本、数学分析读本、微积分读本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a6ac23d377397d00cf53a68e5c57f08/" rel="bookmark">
			R进阶绘图--散点箱线图&#43;显著性 / 组间差异比较 / ggpubr包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R进阶绘图系列主要是带领大家绘制一些科研中常用到的组合图形，力争在表达更多信息的同时而又不失美观，该系列会持续更新，有需要的小伙伴赶紧关注起来吧。
预备知识 今天的内容是连续型变量的组间差异比较，首先来说独立样本。
两组独立样本：如果数据同时满足正态性和方差齐性，可以采用独立样本t检验或者Wilcoxon秩和检验，如果不满足可采用Wilcoxon秩和检验。
两组以上独立样本：如果数据同时满足正态性和方差齐性，可以采用方差分析（ANOVA）或者Kruskal检验，如果不满足可采用Kruskal检验。
独立样本t检验检验和方差分析（ANOVA）都是参数检验，对数据分布具有一定的假设，在符合检验假设的情况下，建议采用参数检验。
Wilcoxon秩和检验和Kruskal检验都是非参数检验，可用于呈偏态分布或者组间不满足方差齐性的数据，对数据分布无要求。
接下来说非独立样本。
两组非独立样本：如果数据满足正态性，可以采用配对t检验或者Wilcoxon符号秩检验，如果不满足可采用Wilcoxon符号秩检验。
两组以上非独立样本：如果数据同时满足正态性和方差齐性，可以采用重复测量方差分析（Repeated Measures ANOVA）或者Friedman M检验，如果不满足可采用Friedman M检验。
配对t检验和重复测量方差分析（Repeated Measures ANOVA）都是参数检验，Wilcoxon符号秩检验和Friedman M检验都是非参数检验。
大家在绘图前要首先为自己的数据选择合适的检验方法，不要只求出图哦。
写上面一段话，我都快把自己给绕晕了，个人能力有限，如果大家发现任何问题，欢迎后台留言指正，我会在公众号底部做一个纠错专栏，所有出现错误然后纠正后的内容会放在那里（ps：因为基本上改不了原文）。
绘图 加载包和数据 # 加载包、导入数据 library(ggpubr) # 继承ggplot语法 library(patchwork) # 拼图包 library(ggsci) #配色包 data("ToothGrowth") ToothGrowth$dose=factor(ToothGrowth$dose) 数据介绍 ToothGrowth数据集结构如图所示，这是一项评估维生素C对豚鼠牙齿生长的影响的研究数据，len是牙齿长度；supp是两种给药方式，一种是橙汁OJ，另一种是抗坏血酸VC；dose是三种给药水平。对于该数据集我们后续均采用非参数检验方法。
散点箱线图 # 绘制散点箱线图----------------------------------------- p &lt;- ggplot(ToothGrowth, aes(x=dose, y=len,color=dose)) + # 绘制箱线图 geom_boxplot(aes(fill=dose), alpha=0.1)+ # 设置透明度 # 绘制散点 geom_jitter()+ # 设置颜色 scale_color_manual(values = pal_npg('nrc')(9))+ scale_fill_manual(values = pal_npg('nrc')(9))+ # 设置主题 theme_bw()+ # 去除网格线 theme(panel.grid = element_blank()) p stat_compare_means( )参数解读 method（方法）：指定要执行的统计检验。对于非配对检验： "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a6ac23d377397d00cf53a68e5c57f08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8422cfa7e1b7508b5018d601d5da8dc/" rel="bookmark">
			Python 柱状图的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.通过Bar来构建基础柱状图：2.基础的时间配置动态图表：3.动态柱状图的绘制：Python技术资源分享1、Python所有方向的学习路线2、学习软件3、入门学习视频4、实战案例5、清华编程大佬出品《漫画看学Python》6、Python副业兼职与全职路线 1.通过Bar来构建基础柱状图： （如以下代码）
from pyecharts.charts import Bar from pyecharts.options import * # 构建柱状图对象 bar = Bar() # 添加x轴数据 bar.add_xaxis(["中国", "美国", "英国"]) # 添加y轴数据 bar.add_yaxis(["GDP",[30, 20, 10]]) # 绘图 bar.render("基础柱状图.html") 运行结果：
从以上代码中可得出要构建一个基础的柱状图首先要导入pyecharts中的bar模块，接着是构建柱状图的对象，然后再分别给x和y轴添加上数据，最后再绘图即可。使用bar.reversal_axis()就可以实现x和y轴的反转了，因为我们这个柱状图不是从下往上去看的，而是从左往右去看的。然后反转之后可以通过使用labelOpts模块去把数据（10，20，30）放到最右边。
2.基础的时间配置动态图表： （1）Time line()-时间线：时间线就是创建一个x轴，轴上每一个点就是一个图表对象。如下面的图所示：
它是由点1变动到点2的，并以此来实现动态的图表。
from pyecharts.charts import Bar, Timeline from pyecharts.options import LabelOpts # 构建柱状图对象 bar1 = Bar() # 添加x轴数据 bar1.add_xaxis(["中国", "美国", "英国"]) # 添加y轴数据 bar1.add_yaxis("GDP", [10, 20, 10], label_opts=LabelOpts(position="right")) # 反转x和y的轴 bar1.reversal_axis() bar2 = Bar() bar2.add_xaxis(["中国", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8422cfa7e1b7508b5018d601d5da8dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e2c6207e47a910d77d59a38dcc805f7/" rel="bookmark">
			Python速度大比拼：与主流编程语言的速度对决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、Python与C/C++的比较2、Python与Java的比较3、Python与JavaScript（Node.js）的比较4、Python与Go的比较5、Python与R的比较 结论Python技术资源分享1、Python所有方向的学习路线2、学习软件3、入门学习视频4、实战案例5、清华编程大佬出品《漫画看学Python》6、Python副业兼职与全职路线 前言 在评估用于具体业务的编程语言时，经常考虑的一个关键指标之一是执行速度。Python以其简单性和可读性而闻名，但有时却因其性能而受到质疑。在这个领域，我们需要深入比较分析Python在执行速度方面与其他流行的编程语言相比的情况。
程语言执行速度开发速度生态支持应用领域工具和技术优势Python中等高大量库、社区支持通用Cython, asyncio, Pandas, NumPy, SciPy简单性、快速开发C/C++高中等大量库、社区支持性能关键应用直接系统资源访问、编译型语言原始性能、系统级控制Java高高大量库、生态丰富服务器应用JVM, Jython高性能、广泛应用JavaScript (Node.js)高高大量库、生态丰富异步I/O非阻塞I/O、事件驱动模型高并发处理、I/O密集任务Go (Golang)高中等丰富生态、大量库并发应用静态类型、编译型语言、并发支持原始性能、并发处理Rust高中等不断增长的生态系统编程Zero-cost abstractions、内存安全原始性能、内存安全R中等中等专业生态支持数据分析统计计算、图形绘制专业统计工具 1、Python与C/C++的比较 C/C++ : 自古以来，C和C++一直是性能关键应用程序的首选语言。它们是编译型语言，能够直接访问系统资源。
Python: 作为一种解释型语言，Python在原始性能上通常不如C/C++。
然而: 借助像Cython这样的工具，Python代码可以转换为C扩展，从而显著缩小性能差距。
2、Python与Java的比较 Java: 运行在Java虚拟机（JVM）上，通常比Python更快，特别是对于长时间运行的服务器应用程序而言。
Python: 尽管Python的原始性能可能不及Java，但其由简单语法驱动的开发速度通常导致项目能够更快地完成。
提示: 对于那些需要Java速度但希望保留Python灵活性的应用程序，Jython允许Python代码在JVM上运行。
3、Python与JavaScript（Node.js）的比较 JavaScript（Node.js） : 以非阻塞I/O和事件驱动模型而闻名，Node.js可以同时处理多个连接，因此在处理I/O密集型任务时速度较快。
Python: 随着asyncio的出现，Python在异步编程领域正在迎头赶上，允许进行非阻塞I/O操作。
4、Python与Go的比较 Go（或Golang） : 这是一种静态类型、编译型语言，具备内置的并发支持。通常情况下，Go程序在原始执行速度方面胜过Python。
Python: 虽然Python可能无法与Go的性能直接竞争，但Python拥有庞大的库生态系统和社区支持，这可以加速许多项目的开发。
5、Python与R的比较 R: 主要用于统计计算和图形绘制，特别在数据分析任务中表现出色。
Python: 借助像Pandas、NumPy和SciPy等库，Python已经成为数据科学领域的强大工具。尽管R可能具有Python中没有的特定统计工具，但在许多数据任务中，两者之间的一般速度差异通常可以忽略不计。
结论 Python的优势不一定在于原始性能，而在于其多才多艺、简单性以及开发人员能够从构思到项目完成的速度。尽管如此，这门语言已经发展，现在存在的工具显著缩小了Python与传统更快语言之间的性能差距。
在选择项目的编程语言时，必须考虑更广泛的因素：开发时间、可用的库、社区支持以及当然还有执行速度。通常，采用混合方法，充分利用多种语言的优势，才能取得最佳效果。
Python技术资源分享 小编是一名Python开发工程师，自己整理了一套 【最新的Python系统学习教程】，包括从基础的python脚本到web开发、爬虫、数据分析、数据可视化、机器学习等。
保存图片微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
如果你是准备学习Python或者正在学习，下面这些你应该能用得上：
1、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
2、学习软件 工欲善其事必先利其器。学习Python常用的开发软件都在这里了，给大家节省了很多时间。
3、入门学习视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
4、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
5、清华编程大佬出品《漫画看学Python》 用通俗易懂的漫画，来教你学习Python，让你更容易记住，并且不会枯燥乏味。
6、Python副业兼职与全职路线 这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
👉CSDN大礼包：《Python入门资料&amp;实战源码&amp;安装工具】免费领取（安全链接，放心点击）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d03280fa73eaba3a6c7de8f51e6af8/" rel="bookmark">
			再也不用手写爬虫了！推荐5款自动爬取数据的神器！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、八爪鱼二、集搜客三、webscraper四、AnyPapa五、you-get总结1、Python所有方向的学习路线2、学习软件3、精品书籍4、入门学习视频5、实战案例6、清华编程大佬出品《漫画看学Python》7、Python副业兼职与全职路线 网络信息的时代，想要收集信息，爬虫是一项必不可少的工具。对于很多小伙伴们来说，只是想利用爬虫进行快速的内容抓取，而并不想太过深入的学习爬虫。 利用python编写爬虫程序虽然炫酷，但是需要耗费时间和精力去学习。学习成本非常高，有的时候就是为了几页的数据，学了几个月的爬虫，实在是伤不起。
有没有啥好的办法，既快又省事，当然有！今天就带领大家来分享五款免费的数据抓取工具，帮你省时又省力。
一、八爪鱼 八爪鱼是一款较为流行的爬虫软件，即便用户不会编程，也能够轻松抓取数据。八爪鱼对于数据抓取的稳定性较强，并且配备了详细的使用教程，可以很快的上手使用。
传送门：https://www.bazhuayu.com/
我们以采集名人名言为例，网址为：https://www.mingyannet.com/mingyan/234813297
打开八爪鱼软件后，打开网页，然后点击单个文本，选择右侧的“选中全部”，软件会自动识别所有的名言文本。接下来按照操作，选择采集文本，并启动软件进行采集。
采集完成后，选择文本导出的文件类型，点击确定，导出数据。
二、集搜客 集搜客针对于一些比较大众的热门网站设置了快捷的爬虫程序，但是学习成本相对于八爪鱼较高。
传送门：https://www.jisouke.com/index.html
我们以知乎关键词作为抓取目标，网址为：https://www.zhihu.com/search?type=content&amp;q=python 。首先需要按照爬取玩个类别进行分类，然后输入网址之后，点击获取数据，开始抓取。抓取的数据如下图所示：
可以看到，集搜客抓取信息是非常丰富的，但是数据的下载需要消耗积分，20条数据花费1个积分。集搜客会赠与新用户20积分。
以上介绍的两款都是非常好用的国产数据抓取软件，接下来为大家介绍的则是chrome浏览器下的爬虫插件。
三、webscraper Web scraper插件是一款非常好用的简易爬虫插件，对于Web scraper的安装，可以参考之前分享的文章。
对于简单的数据抓取，Web scraper可以很好的完成任务。我们同样以名人名言的网址数据抓取为例。
通过选中Multiple，来抓取页面中的所有名言。数据抓取完毕后，通过点击“Export data as CSV“来导出所有的数据。
四、AnyPapa 将网页翻到评价部分，然后点击AnyPapa插件下的”本地数据“，会自动跳转到AnyPapa的数据页面。
首先点击切换数据源，找到”京东商品评论“的数据源，此时界面中会显示出手机评论页面中的当前全部评论内容。点击”导出“，评论数据会以csv文件下载到本地。
五、you-get you-get是GitHub上的一个非常火爆的爬虫项目，作者提供了近80个国内外网站的视频图片的抓取，收获了40900个赞！
传送门：https://github.com/soimort/you-get
对于you-get的安装，可以通过pip install you-get的命令进行安装。
通过命令：
you-get -o ./ 'https://www.bilibili.com/video/BV1y64y1X7YG?spm_id_from=333.851.b_7265636f6d6d656e64.3' --format=flv360 可以实现视频的下载，其中-o 指的是视频下载的存放地址，–format是指视频下载的格式和清晰度。
总结 以上就是今天为大家带来的五款自动提取数据的工具，如果对于偶尔一次的爬虫，或者很低频率的爬取需求，完全没有必要去学习爬虫的技术，因为学习成本很高。好比如果你只是想P几张图，直接用美图秀秀了，不需要学Photoshop 。
如果是对爬虫有很多定制的需求，需要对收集的数据进行分析和深度挖掘，而且是高频的，或者你想通过爬虫把Python技术运用的更深入，学习的更扎实，这个时候才考虑学爬虫。
好了，以上几个工具都是不错的，有兴趣的同学可以试试
【读者福利】 如果你对Python感兴趣，学好 Python 不论是就业、副业赚钱、还是提升学习、工作效率，都是非常不错的选择，但要有一个系统的学习规划。
小编是一名Python开发工程师，自己整理了一套 【最新的Python系统学习教程】，包括从基础的python脚本到web开发、爬虫、数据分析、数据可视化、机器学习等。
如果你是准备学习Python或者正在学习，下面这些你应该能用得上：
1、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
2、学习软件 工欲善其事必先利其器。学习Python常用的开发软件都在这里了，给大家节省了很多时间。
3、精品书籍 书籍的好处就在于权威和体系健全，刚开始学习的时候你可以只看视频或者听某个人讲课，但等你学完之后，你觉得你掌握了，这时候建议还是得去看一下书籍，看权威技术书籍也是每个程序员必经之路。
4、入门学习视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
5、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
6、清华编程大佬出品《漫画看学Python》 用通俗易懂的漫画，来教你学习Python，让你更容易记住，并且不会枯燥乏味。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10d03280fa73eaba3a6c7de8f51e6af8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a664ef7e53c5a1b79f1d1e472fc0dc2d/" rel="bookmark">
			【tensorflow&amp;flutter】自己写个机器学习模型用在项目上？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 拍摄APP项目上线有一阵了，每天的拍摄数据呈现波动上升状态、业务方需要对数据进行加工，如果能有对未来的数据量的预测就好了 。
目标 在端侧展示拍摄数据可视化趋势图等、并能推断数据（选择预测日期） 简单实现个demo
gif背景有点问题 先写总结 现在来看、出来的东西很简单，但是整个流程时串通起来了。至于什么是tensorflow lite 初识TensorFlow Lite -CSDN博客
总体流程图是这样的 从左侧的数据来源开始、到tensorflow 模型训练 到云上、动态下发、再到预测数据。生产数据的 再次收集数据运行的全流程正循环。 模型训练在本篇下方 其他后续写
一.数据处理 数据来源 目前只有日志数据 以单个数据为维度的： 2023年x月x日 张某 所属部门 拍摄时间 等数据
数据预处理 通过pyhton 统计当日共拍摄多少套、都属于哪个部门
数据清洗 去除前三天刚上线数据（不准）、和当日的数据（未统计完全）等特殊数据
数据分析、抽取 根据数据判断 不光跟当日部门数、时间、还有星期有关 比如 周五周六周天相对较高 将星期也为参数。
输出关系图
sns.pairplot(train_dataset[["拍摄数量","事业部数量","weekday","index"]], diag_kind="kde") 拆分训练数据集和测试数据集 拆除80%的数据进行训练、20%进行测试
train_dataset = dataset.sample(frac=0.8,random_state=0) test_dataset = dataset.drop(train_dataset.index) 从标签中分离特征 把预测值分离出来
train_labels = train_dataset.pop("拍摄数量") test_labels = test_dataset.pop("拍摄数量") 数据规范化 使用不同的尺度和范围对特征归一化是好的实践。尽管模型可能 在没有特征归一化的情况下收敛，它会使得模型训练更加复杂，并会造成生成的模型依赖输入所使用的单位选择。
就是将数据统一差不多的大小 def norm(x): return (x - train_stats['mean']) / train_stats['std'] normed_train_data = norm(train_dataset) normed_test_data = norm(test_dataset) 结果类似于 输入 ：部门数 35 星期 3 日期 202
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a664ef7e53c5a1b79f1d1e472fc0dc2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/735e818391078c7b88949c4373e218f1/" rel="bookmark">
			java时间监视器System.currentTimeMillis()的平替StopWatch！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用System.currentTimeMillis()获取程序运行时间：
longstartTime=System.currentTimeMillis();//运行主程序 longendTime=System.currentTimeMillis(); System.out.println("程序运行时间：" (endTime-startTime) "ms"); System.currentTimeMillis…这种方式统计耗时确实是用的最多的，因为它不用引入其他的 JAR 包，JDK 就能搞定，但是它用起来有几个不方便的地方：
1）需要定义初始时间值，再用当前时间进行手工计算；
2）统计多个任务的耗时比较麻烦，如果 start 赋值搞错可能还会出现逻辑问题；
目前spring-framework提供了一个StopWatch类可以做类似任务执行时间控制，也就是封装了一个对开始时间，结束时间记录工具：
package com.ypk.swagger.utils.file; import org.springframework.util.StopWatch; /** * Stopwatch Java用法 Stopwatch类是Java中一个计时器类,用于测量运行时间的简单工具 * @author lgn * @date 2024/1/5 14:24 */ public class SpringStopWatchExample3 { public static void main (String[] args) throws InterruptedException { getTotalTimeMillis(); } //以优雅的格式打出所有任务的耗时以及占比 public static void prettyPrint() throws InterruptedException { StopWatch sw = new StopWatch(); sw.start("A"); Thread.sleep(500); sw.stop(); sw.start("B"); Thread.sleep(300); sw.stop(); sw.start("C"); Thread.sleep(200); sw.stop(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/735e818391078c7b88949c4373e218f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310c7af429cd07a267dfa60ab71e2207/" rel="bookmark">
			支持 input 函数的在线 python 运行环境 - 基于队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持 input 函数的在线 python 运行环境 - 基于队列 思路两次用户输入三次用户输入 实现前端使用 vue + element uiWindows 环境的执行器子进程需要执行的代码 代码仓库参考 本文提供了一种方式来实现支持 input 函数，即支持用户输的在线 python 运行环境。效果如下图所示：
思路 前端使用一个数组 input_queue 记录用户从点击运行按钮到现在的所有输入
点击运行按钮时将 code、input_queue 传给后端
后端将参数传给执行 python 代码的子进程
子进程重写 input() 函数，假设新的实现为 input_wrapper，代码如下，到用户代码运行到 input() 函数时，会执行重写的 input_wrapper()， 在 input_wrapper 中获取到 input_queue，然后使用 input_queue.pop(0) 弹出用户输入最早的信息，如果 input_queue 为空，则说明需要用户输入，通过抛出 InputRequestException 异常的方式通知后端
def input_wrapper(prompt=''): if input_queue: input_str = input_queue.pop(0) sys.stdout.write(str(prompt) + input_str + "\n") return input_str raise InputRequestException(str(prompt)) 后端通过处理子进程的标准输出、标准错误，知晓需要用户输入，然后向前端返回以下 json，event.type 为 input_request 代表需要用户输入，prompt 是提示信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310c7af429cd07a267dfa60ab71e2207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0af28ba21a54242e323edcee27071a6/" rel="bookmark">
			全球大气二氧化碳浓度2°x2.5°栅格模拟数据集（1992-2020）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全球大气二氧化碳浓度2°x2.5°栅格模拟数据集（1992-2020）
全球大气二氧化碳浓度2°x2.5°栅格模拟数据集（1992-2020）是以2002-2012年全球对流层CO2浓度卫星遥感产品（AIRS，AIRx3C2M 005）为基础，对改进的CO2浓度正弦估算模型进行逐像元参数计算；在此基础上，利用基于像元的模型进行CO2浓度模拟回溯至1992，预测至2020。最后，利用站点观测数据对产品精度进行验证与分析。 该数据集覆盖范围为60°S – 88°N，180°W-180°E，空间分辨率为2° x 2.5°。数据集由两部分组成：（1）1992-2020年全球逐月CO2浓度均值数据集；（2）1992-2020年全球逐年CO2浓度均值数据集。数据集以.nc格式存储，由58个数据文件组成，数据量为31.5 MB（压缩为1个文件，23.9 MB）。
数据时间：1992-2020年
数据空间位置：全球
数据格式：nc
数据空间分辨率：2*2.5度
数据坐标系：WGS 1984
欢迎大家关注、收藏和留言，如果您想要什么数据，可以在搜索网址地球资源数据云，我会分享更多的好的数据给大家~~~~~
以上是关于全球大气二氧化碳浓度2°x2.5°栅格模拟数据集（1992-2020）详情，欢迎小伙伴们一起学习和分享。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec43436da2ab2625e2adbbc000b4a643/" rel="bookmark">
			Stable Diffusion汉化插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为大家介绍Stable Diffusion的两种UI汉化包，一种是汉化包，就中文界面，方便大家对于繁杂的参数的模型的操作，一种是中英文对照界面，在中文提示下，同时显示英文，不但方便设置也同时学习了英文单词。就如下面这个界面：
好了不多说了，我们开始我们的插件安装。
一：SD的汉化插件
1、项目名称：stable-diffusion-webui-localization-zh_CN
2、安装方法：
登录Stable Diffusion，点击“Extensions”，找到“Available”选项卡，然后装载所有插件，如下图操作：
点击Load from:如下图。
然后在输入框中输入zh_CN，如下图
安装完成后，点击Installed选项卡如下图：
Apply后重启SD。然后进入Settings选项卡，找到“User interface”，在Localization（requires Reload UI）中选择zh_CN。
保存设置并重启UI。然后界面就变成中文的了。
汉化后的界面如下图。
二：安装SD中英文对照语言包
假如你想看到中文的同时，也能看到原始的英文，那么请安装中英文对照语言包。方法如下：
1、首先们要把stable-diffusion-webui-localization-zh_CN插件卸载。
然后到extensions目录下，将stable-diffusion-webui-localization-zh_CN插件删除。
然后，执行：python launch.py，重新启动SD。
2、中英文对照的项目地址
项目地址：https://github.com/journey-ad/sd-webui-bilingual-localization
语言包地址：https://github.com/VinsonLaro/stable-diffusion-webui-chinese
这两个包需要从"Install from URL"中安装，如图。
点击Install开始安装，安装完成后，再安装语言包：stable-diffusion-webui-chinese
回到Install选项卡
登录界面后，进入Settings 选项卡，步骤在图上了。
注意中英文对照要选“Chinese-english-1024”这个语言包。接下来，我们的界面就变成下面这个样子了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ff39e38e13d8ebf57939bb054c287ee/" rel="bookmark">
			【无标题】关于碳监测数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 城乡规划专业相关的分析数据、工具和方法 https://www.zhihu.com/column/c_1686523770133688320 可视化网站
https://www.chiplot.online/
1.国家地球系统科学数据中心
http://www.geodata.cn
3.Landscan Global全球人口密度空间分布数据2022
https://landscan.ornl.gov/
5.碳排放数据合集
先上测评结论，推荐用 5.4全球基础设施排放数据库GID 这个数据，分辨率是0.1°×0.1°，数据质量较好。有地表碳总量的，也有六个部门（电力、工业、居住、交通、航运、航空；Power, Industry, Residential, Transport, Shipping, Aviation）的单独碳排放数据。
5.1 2021年全球0.1°x 0.1°CO2排放数据，EDGAR
数据来源：荷兰环境评估机构（Netherlands Environmental Assessment Agency，PBL）的全球大气研究排放数据库(Emissions Database for Global Atmospheric Research，EDGAR)
edgar.jrc.ec.europa.eu/
下载裁剪后会发现ta的数据精度不太ok，我猜ta的分辨率没有0.1°，0.1°大概是10km的样子，这个数据精度明显没有10km。ta只是栅格的大小是0.1°。所以在这里给大家测评避雷了。
5.2中国碳核算数据库（China Emission Accounts and Datasets, CEADs）
https://www.ceads.net.cn/data/
5.3中国多尺度排放清单模型（Multi-resolution Emission Inventory for China，MEIC）
http://meicmodel.org.cn/
中国多尺度排放清单模型是一套由清华大学开发的基于云计算平台开发的中国大气污染物和温室气体人为源排放清单模型，通过建立源分类分级体系和排放因子数据库，研发基于技术和动态过程的排放清单技术，开发多尺度高分辨率排放源模式，并在此基础上基于云计算平台技术进行集成，建立中国多尺度排放清单模型（MEIC），为科学研究、政策评估和空气质量管理等工作提供规范、准确、更新及时的高分辨率动态排放清单数据产品。
这个数据库需要邮箱注册账号然后下载数据，且只有机构邮箱可以注册账号，会在1-2个工作日后收到邮件回复，账号和登陆密码。
我注册账号看了一下数据申请，需要填申请表盖机构公章并邮寄，学生申请需要导师签名。太麻烦了，遂放弃。
5.4全球基础设施排放数据库GID
http://gidmodel.org.cn/
GID是由清华大学团队研发，将全球（电力、水泥、钢铁）数据库、汽车、船舶排放等多源数据流整合建立形成全球高分辨率碳排放网格数据集（Global Carbon Grid）。目前版本为Global Carbon Grid v1.0版本，提供了2019年六个来源的全球0.1°×0.1°二氧化碳排放数据，包括电力、工业、住宅、运输、航运和航空。
分辨率为0.1°×0.1°，时间尺度为2019年。
这个数据库也需要邮箱注册账号然后下载数据，且只有机构邮箱可以注册账号，会在1-2个工作日后收到邮件回复，账号和登陆密码。
然后，就可以直接点击下载数据了。有地表碳总量的，也有六个部门（电力、工业、居住、交通、航运、航空；Power, Industry, Residential, Transport, Shipping, Aviation）的单独碳排放数据。质量还不错，推荐下载这个。下面是数据展示，第一张是地表碳排总量的，第二张是交通碳排放的。
5.5中国高分辨率碳与大气污染物排放清单（CHRED3.0A）。
https://www.ieimodel.org/chred-3-0a/
结合在线监测数据、环境统计、排放许可实施报告以及国家统计局等多个数据库，以2018年为基准年，构建了中国的CO2和SO2、NOx、VOCs、CO、PM10、PM2.5、BC、OC九种大气污染物的高分辨率（10 km×10 km）排放清单，即CHRED 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ff39e38e13d8ebf57939bb054c287ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9293477c45400ead6db0fa1e5e626a66/" rel="bookmark">
			收藏的100套html5网页静态模板无密打包分享 /国内外优秀网页模板 /网页设计html模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里分享个人收藏的100套html5网页静态模板，无密打包，它们是国内外优秀网页模板，国内外优秀网页模板。分有不同行业，有科技、电商、餐饮、个人、旅游、家居等。已打包了，自取，要是对你有用欢迎点赞！
在这里分享的超过100套来自国内外的优秀网页模板。这些模板不仅包括个人主页网站HTML模板，还包括经典实用的扁平化网站源码。所有模板均经过精心挑选，以满足不同行业的需求，涵盖了科技、电商、餐饮、个人、旅游和家居等多个领域。
这些网页模板设计风格简洁大方，采用了最新的HTML5制作而成，确保了其在各种浏览器和设备上的兼容性。作为经典的实用网页设计模板，它们不仅具有视觉上的吸引力，还注重用户体验和功能性。
将这些模板无密分享给大家，可根据自己的需求自由选择并下载使用。为了方便使用，已将这些模板进行了打包处理。
html5网页静态模板合集链接： 模板源码 密码：A688
下面的部分预览图及源码： index源代码： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;Codester | Home&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="icon" href="http://dzyngiri.com/favicon.png" type="image/x-icon"&gt; &lt;link rel="shortcut icon" href="http://dzyngiri.com/favicon.png" type="image/x-icon" /&gt; &lt;meta name="description" content="Codester is a free responsive Bootstrap template by Dzyngiri"&gt; &lt;meta name="keywords" content="free, template, bootstrap, responsive"&gt; &lt;meta name="author" content="Inbetwin Networks"&gt; &lt;link rel="stylesheet" href="css/bootstrap.css" type="text/css" media="screen"&gt; &lt;link rel="stylesheet" href="css/responsive.css" type="text/css" media="screen"&gt; &lt;link rel="stylesheet" href="css/style.css" type="text/css" media="screen"&gt; &lt;link rel="stylesheet" href="css/touchTouch.css" type="text/css" media="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9293477c45400ead6db0fa1e5e626a66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/313f9f53b56c30b70fd7614bebea648f/" rel="bookmark">
			Sharding Sphere 教程 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 文档简介 1.1 分库分表诞生的前景 随着系统用户运行时间还有用户数量越来越多，整个数据库某些表的体积急剧上升，导致CRUD的时候性能严重下降，还容易造成系统假死。
这时候系统都会做一些基本的优化，比如加索引、缓存、读写分离/主从复制，增删改都走主库，查询走从库。（数据量过大基本优化方式参考：百度安全验证）
但是这样没法提升主库写的能力，因为主库只有一个。这时候就要考虑分库分表了，一般数据库在设计的时候就会提前考虑到是否有分库分表场景需要，避免后期带来迁移的问题，而且最好对表的查询足够简单，尽量避免跨表跨库查询。
1.2 单表数据量的分析 业界流传着单表数量建议最大2kw条；（但是实际情况还可以进行具体分析：https://linpxing.cn/mysql_big_table_limit_990912/）https://linpxing.cn/mysql_big_table_limit_990912/）
在阿里巴巴开发手册中建议：预估三年内单表行数超过500万行或者单表容量超过2GB才推荐进行分库分表。
二 分表详述 2.1 分库分表的方式（垂直拆分，水平复制） 一般系统模块都是访问同一个数据库资源，所有的表都存放在一个库里面；
2.1.1 垂直分库 把单一的数据库进行业务划分，专库专表
经过垂直拆分之后，每个模块都使用各自独立的数据库，减轻了数据库的压力，业务也更加清晰，拓展也更容易了，但是会增加连表查询以及事务处理的复杂度，无法解决单表数据量太大的问题
2.1.2 垂直分表 垂直拆分表主要解决一张表太多字段某个字段存储值为大文本会对io查询有损耗所以把本来属于同一个对象描述的属性拆分多个表，分布式微服务分库分表尽量不要严苛遵守数据库的3大范式，可参考不可严格遵循
相当于把一个大表根据字段拆分成多个小表 ，一个10w数据的表，变成两个10w数据的表
这样拆分的好处就是，假如只显示列表，不需要显示详细信息就很方便，例如一个订单是包含很多信息的，但是在后台通常不需要去获取订单的详情信息用作展示，一般只需要展示概要信息：下单用户、下单时间、金额等等重要信息。于是可以把一个订单表垂直拆分为两个表来处理
2.1.3 水平分库 把一个数据库分散成多个结构相同的数据库，本质就是复制操作
2.1.4 水平分表 一个表数据量太大，将一个表按不同的条件分散多个表中，把1000w的表拆分为两个500w的表
2.2 分表的规则 2.2.1 取范围 根据时间范围或者id范围分布到不同的库中，例如把2020年前的数据放到一个表中，之后的数据放到一个表中。把用户ID 0～100000放到一个表中，100000～200000的数据放到一个表中。
优点：使用分片字段范围查询比较方便
缺点：某段范围内热点数据可能被频繁读写，其他数据很少被查询
时间维度：使用ShardingJDBC实现按时间维度分表轻松支撑千万级数据_sharding jdbc按时间分表-CSDN博客；参考链接；
2.2.2 数值hash取模运算 根据某个字段进行运算均匀的分配到不同的表中
优点：分散比较均匀，不容易存在热点数据
缺点：数据太分散，导致范围查询比较麻烦，需要查询分库之后再合并
水平拆分的时候会导致多库多表的联合查询难度变大，以及多数据源管理的问题
2.3 分表的中间件 2.3.1 Cobar 阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。由于Cobar发起人的离职，Cobar停止维护
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/313f9f53b56c30b70fd7614bebea648f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5df0be0cad062faab064d86167cb57c/" rel="bookmark">
			netty http3功能从零开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、windows安装jdk和mvn、gradle、gloovy 配置环境变量JAVA_HOME CLASSPATH MVN_HOME GRADLE_HOME GLOOVY_HOME mvn和gradle都是用来管理和编译java项目的，mvn比较老，现在一般用gradle 2、vscode环境 vscode安装extension：Extension Pack for java 设置-&gt;extension-&gt;java 修改setting.json { "java.jdt.ls.java.home": "D:\\Program Files\\Java\\jdk-20", "java.semanticHighlighting.enabled": true, "editor.suggestSelection": "first", "vsintellicode.modify.editor.suggestSelection": "automaticallyOverrodeDefaultValue", "java.configuration.checkProjectSettingsExclusions": false, "git.ignoreWindowsGit27Warning": true, "java.requirements.JDK11Warning": false, "java.eclipse.downloadSources": true, "java.maven.downloadSources": true, "java.configuration.maven.globalSettings": "D:\\Program Files\\apache-maven-3.9.2\\conf\\settings.xml", "java.debug.settings.exceptionBreakpoint.skipClasses": [ ], } 修改环境变量（JAVA_home）：
3、创建新项目 idea可以直接创建，但我用的vscode，不知道怎么创建
在cmd内使用gradle命令创建（gradle init --type java-application）：
执行完毕后可以看到生成了一些文件：
修改build.gradle文件：
plugins { id 'java' //配合shadowJar将依赖的jar打在一个包里 id 'com.github.johnrengelman.shadow' version '2.0.4' } group 'hyper.http.server' version '1.0-SNAPSHOT' //很多镜像被墙或者速度很慢，需要设置代理 repositories { maven { url 'https://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5df0be0cad062faab064d86167cb57c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e0d694e1771d205d582a7a33071f8f/" rel="bookmark">
			用idea跑起十多年前的项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、eclipse的项目
先删掉一些eclipse的配置文件
二、在idea中导入项目
1、导入成功后，先【锤一下】
2、然后发现编译不通过，非常多的报错信息，逐一解决报错
（1）tomcat7配置报错
（2）先删除tomcat7
（3）重新配置本地tomcat7
add selected
这样，没有了编译的错误，只剩下一些警告，因为是老项目了很多都jar都是过时的了
项目是可以编译通过了，现在就剩下怎么放到tomcat中了
（4）
这是idea自动配置的，项目输出到这里，绝对是没有进入到我们自己的tomcat的，所以我们自己要设置一下
先在tomcat7的webapps目录下，新建一个和项目同名的文件夹用来放项目
然后把idea的配置改成
最后在idea配置tomcat
然后这边就会自动配置了
启动成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e785b3924c0abab8832c953d347462/" rel="bookmark">
			Python的五种常见算法，一文解读，清晰易懂~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、选择排序二、快速排序三、二分查找四、广度优先搜索五、贪婪算法总结关于Python技术储备一、Python所有方向的学习路线二、Python基础学习视频三、精品Python学习书籍 四、Python工具包+项目源码合集①Python工具包②Python实战案例③Python小游戏源码五、面试资料 六、Python兼职渠道 前言 这篇文章主要介绍了如何用Python实现几种常见算法，文中代码简单易懂非常适合零基础刚刚入门的小伙伴，方便大家更好的学习，感兴趣的朋友可以了解下~
一、选择排序 选择排序是一种简单直观的排序算法。它的原理是这样：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的后面，以此类推，直到所有元素均排序完毕。算法实现如下：
#找到最小的元素def FindSmall(list): min=list[0] for i in range(len(list)): if list[i]&lt;min: min=list[i] return min #选择排序def Select_Sort(list): newArr=[] for i in range(len(list)): minValue=FindSmall(list) newArr.append(minValue) list.remove(minValue) return newArr testArr=[11,22,33,21,123]print(Select_Sort(testArr)) 二、快速排序 快速排序的运行速度快于选择排序，
它的工作原理是这样：
设要排序的数组是N，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。
可以使用python用递归式的方法来解决这个问题：
def Quick_Sort(list): if len(list)&lt;2: return list else: temp=list[0] less=[i for i in list[1:] if i&lt;=temp] more=[i for i in list[1:] if i&gt;temp] return Quick_Sort(less)+[temp]+Quick_Sort(more) testArr= [13,44,53,24,876,2]print(Quick_Sort(testArr)) 三、二分查找 二分查找的输入是一个有序的列表，如果要查找的元素包含在一个有序列表中，二分查找可以返回其位置。
打个比方来说明二分查找的原理：比如我随便想了个范围在1~100以内的整数，由你来猜，以最少的次数来猜出这个数字，你每次猜完给出个数字，我会回复大了或小了，第一种方法是你从1开始依次往后猜，那如果我想的数字是100，那么你就要猜100次；第二种方法是从50开始，如果我说小了，那你就猜75，就这样依次排除掉一半的剩余数字，这就是二分查找法。
可以看出二分查找法更加快速。
对于包含n个元素的有序列表，用简单查找最多需要n步，而二分查找法则最多只需lon2 n步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05e785b3924c0abab8832c953d347462/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee89b28db3a8c29e79e7d491ca46034/" rel="bookmark">
			业务分析走向业务架构（元旦读物）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新的一年马上开始了，2024有什么规划呢，不妨假期里思索一番，立下个flag，以待明年回眸一笑。2024年关于企业数字化平台构建，小目标：掌握业务分析，流程分析，项目分析 三大基础内容，然后构建数字化平台的几个小工具，组织管理、流程管理、低代码基础版，基本能对付基本的企业数字化需求。言归正传，送给各位过节小读物， “Business Analyst’s guide to Business Architecture” 这里面的内容如果各位能够很容易读懂，说明这个系列您就不用再用太多精力，直接去落地核心部件的构建，DDD就不会是无源之水，一些基本的元素如下： 识别他们之间的异同。
企业架构，我们已经了解一些了，够用。
业务架构元素，还待继续精进。
是否有业务架构的区别。
业务需求的方法论。
价值流+能力。
业务场景。
资源下载，见顶部链接。
Duster.print("新年快乐")! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998f4f88df64287a3eb1a3df45deec8e/" rel="bookmark">
			VM16&#43;Centos7下载、安装和配置教程-2023年12月29日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VM+Centos7下载、安装和配置教程-2023年12月18日 一、vm下载二、CentOS下载三、vm安装四、centos安装 这里提供网盘版本：VM16+Centos7，链接里含有2个文件，按需自取。下载后即可直接跳转至安装步骤
链接：https://pan.baidu.com/s/1CJlz73Rt8HBCzLHkLV5Agg?pwd=9jtj
提取码：9jtj
–来自百度网盘超级会员V6的分享
一、vm下载 1.vm官网 https://customerconnect.vmware.com/en/downloads/#all_products
2.点击Products A-Z
3.鼠标下滑，滑到底，找到VMware Workstation Pro，点击右侧的Download Product
4.调为16版本的，然后根据你的系统来下载，我这里是win 10系统
5.点击下载会自动跳转到vm登录页，登录之后，点击继续（continue）按钮
6.下载完成后如图：
二、CentOS下载 1.CentOS网易开源镜像网 https://mirrors.163.com/centos/7.6.1810/
不必打开此网站，因为打开如下图，如果你需要下载其他的，这个网站是个路径
2.下载这个readme（同样不用下载，这里只是做演示），下载打开如下图
3.打开框选的网站链接，https://vault.centos.org/然后选择7.6.1810，然后选择isos再选择x86_64/最后选择CentOS-7-x86_64-DVD-1810.iso，这里不用操作直接看下一步，这里纯做演示，直接看就行了
4.上一步的操作直达链接：https://vault.centos.org/7.6.1810/isos/x86_64/
,点击下载CentOS-7-x86_64-DVD-1810.iso，这里我直接国内下载的时候是报403,如下图，但是我直接定飞机票1秒出国了哈，在国外是可以下载的，国内的朋友要自行安排飞机票或者用我的百度网盘链接哈
三、vm安装 1.双击下载的exe
2.可能会弹出如下，提示重启电脑，再次安装，照做就行了，再次执行上一步
3.点击下一步
4.我接受，点击下一步
5.选择安装位置，选择好后，点击下一步
6.这2个选项，看你心情，可要可不要，我是选择的取消勾选，然后点击下一步
7.点击下一步
8.点击安装，安装过程中我有闪烁情况，不知道你们有没有，但是不影响安装
9.最后点击完成
10.原神！启动！啊，呸呸呸，说错了啊 vm 启动！启动让你输入激活码
ZF3RO-FHED2-M80TY-8QYGC-NPKYF
四、centos安装 1.打开vm，点击创建新的虚拟机
2.点击下一步
3.选择稍后安装，点击下一步
4.选择Linux，选择centos 7，点击下一步
5.选择安装位置和名字，点击下一步
6.检查，点击下一步
7.点击自定义
8.我这里改为2g，你们根据电脑配置来，他有个建议内存，比他大点没问题，处理器我选的2*2，cd,dvd选择使用iso镜像，然后选择我们下载的文件，这个iso文件要保存好，放到稳定位置，然后点击关闭，
9.点击完成
10.单击开启此虚拟机
11.启动后出下图，双击红框区，然后键盘上下键选择Install CentOS 7，白色为当前被选中的，下图当前被选中的就是Test那个
12.等待一会，然后会黑一下，然后进入下界面，选择中文，选择简体中文，根据你自己的习惯来，然后点击继续
13.等一下，等到如下图，点击软件选择
14.根据自己的习惯来，但是新手一般都是点个桌面，你也可以选择最小安装，然后点完成
15.选择安装位置
16.点击我要配置分区，点击完成
17.点击完成后，点击蓝色字：点这里自动创建。。。
18./boot 文件系统选择ext4，
19.点击swap，检查：设备类型标准分区，文件系统swap，容量2048
20.左侧点击/ ，右边检查：设备类型标准分区，文件系统ext4，17g,然后点击完成
21.点击接受更改
22.点击网络和主机名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/998f4f88df64287a3eb1a3df45deec8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22aa35ec5fdf4597d1c11b9127e75ee0/" rel="bookmark">
			切面编程的理解和使用，Java小白入门（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们进入ruoyi-framework,立刻看到的内容
了解一下aspectj 这个概念
概念 面向切面编程（AOP） 面向切面编程（AOP）是一种编程范式，重点聚焦于软件应用程序中的关注点分离。AOP 背后的思想是软件应用程序具有多个切面，其中一些切面跨越了模块化编码的典型划分，就是可能多个模块化代码都会使用，导致代码分散和混乱。
在软件开发中，有些功能包括日志记录、安全检查、错误处理和数据验证。在面向对象编程 (OOP) 等传统编程范式中，这些横切关注点通常与核心业务逻辑纠缠在一起，导致代码难以维护和扩展。
AOP（Aspect Oriented Programming）面向切面编程的概念比较抽象，主要涉及下面这些术语：
Aspect（切面）：切入一个或多个类的模块Join point（连接点）：程序执行的节点，例如执行方法或处理异常Advice（通知）：切面在连接点执行的动作，例如前置通知Pointcut（切点）：用于匹配连接点，一般通过表达式匹配Target object（目标对象）：被切入的对象，可以被一个或多个切面切入 一个目标类可以被多个切面切入，多个切面也可以切入一个目标类。
切面实现的本质是一个或多个基于连接点的拦截器。
AOP的运行 AOP提供了一种分离关注点的新维度，AOP会将这些关注点模块成称为“切面”的单独单元，这些切面可以独立开发、测试和重用。然后，将它们在需要的地点“编织”到主代码库中，确保核心逻辑保持不变且连贯。这种编织可以在不同的时间发生：
编译时：编译应用程序时会编织各个切面。加载时：加载应用程序类时会编织各个切面。运行时：各个切面是在应用程序执行期间编织的。 AOP的好处 OOP非常适合使用类和对象对现实世界的对象和行为进行建模。但是，当涉及到跨模块间的的功能，OOP就显得不够用了。例如：如果你想在OOP结构中实现记录日志，你可能会在多个类中添加日志记录代码，这就显得非常冗余，随着时间的推移，这些重复的代码会扰乱主要逻辑，导致阅读、修改、调试变得非常困难。除了模块化之外，AOP还提供了高度的灵活性。由于切面与主要业务逻辑分离，因此对它们的更改不会影响核心代码。例如，如果更改日志记录的实现方式（也许切换到不同的日志库），则可以修改日志记录切面，而无需修改代码的任何其他部分。这种架构极大地简化了维护、减少了错误并提高了代码清晰度。 Spring AOP VS Full AspectJ 值得注意的是，虽然 Spring AOP 涵盖了许多常见用例，但它并没有提供 AspectJ 等成熟 AOP 框架提供的所有功能。 Spring AOP 专注于通过代理进行运行时编织，而 AspectJ 可以在编译时或加载时编织切面，提供更广泛的连接点（如字段访问）。AspectJ 是一个独立于 Spring 的，功能强大的 AOP 框架。它通过编译时植入（CTW, Compile-Time Weaving）或者运行时植入（LTW, Load-Time Weaving）来实现切面逻辑的织入。与 Spring AOP 相比，AspectJ 提供了更多的切面功能和更高的性能。Spring AOP 和 AspectJ 可以结合使用，利用 AspectJ 的强大功能和 Spring AOP 的简便配置。使用 AspectJ，需要在 Java 代码中创建切面类，并使用 @Aspect、@Pointcut、@Before、@After、@Around 等注解来定义切面和切点。编译时需要使用 AspectJ 编译器（ajc）编译代码，或者在运行时使用 Load-Time Weaving 实现切面逻辑的植入。 AOP原理 Spring AOP 的核心 Spring AOP 机制的核心是代理。当您定义一个切面来应用于应用程序的某些部分时，Spring 会创建advice对象的代理（子类或接口实现）。该代理拦截调用并将它们委托给原始对象，这种动态代理方法可确保不存在字节码操作，从而使过程透明且不易出错。Spring AOP 底层是基于动态代理实现的，对实现接口的类进行代理，默认使用 JDK 动态代理，对没实现接口的类，使用 CGLIB 动态代理。 JDK 动态代理通过实现接口生成代理类，使用拦截器加反射机制生成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22aa35ec5fdf4597d1c11b9127e75ee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e1bedaf7cd81d1d2349cb6c0efa2a19/" rel="bookmark">
			Winform数字输入文本框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、目的
使文本框只输入数字（包括小数）
2、步骤
在控件库中添加自定义控件（窗体）；
修改代码；
3、代码
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace Lib { public partial class GTextBox : TextBox { public GTextBox() { InitializeComponent(); } protected override void OnPaint(PaintEventArgs pe) { base.OnPaint(pe); } #region 自定义属性 private int maxIntegerLength = 10; private int minIntegerLength = 0; private int maxDecimalLength = 4; private int minDecimalLength = 0; private int integerLength; private int decimalLength; #endregion #region 自定义属性 /// &lt;summary&gt; /// 最大整数位 /// &lt;/summary&gt; public int MaxIntegerLength { get { return maxIntegerLength; } set { if (value &gt;= 0 &amp;&amp; value &gt;= minIntegerLength) { maxIntegerLength = value; } else { throw new Exception("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e1bedaf7cd81d1d2349cb6c0efa2a19/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/35/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>