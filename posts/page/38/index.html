<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2fd82a5accf8c30029b027a1b5249d5/" rel="bookmark">
			vue3-----单个赋值解决对象直接赋值导致对象响应式失效(里面的属性值会改变不了) &#43; 路由传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接收路由跳转传过来的参数
//接收路由跳转传过来的参数 const route = useRoute() const searchForm = reactive({ dateTime: route.query.dateTime }) Object.assign解决不了（因为Object.assign外层是深拷贝，内层是浅拷贝），只能单个赋值（用变量捯一遍），对象直接赋值导致对象响应式失效(里面的属性值会改变不了)================本篇重点===============
// params = ...searchForm 重新赋值后会，params会变成普通对象,失去响应式的效果,需要单个赋值或者使用 Object.assign // const params = {...searchForm, gsType: route.query.gsType,ydGs: route.query.ydGs,deptId: deptId.value} //上面这种直接赋值就会出错，加reactive也没用，试过了，别犟 const params = Object.assign({},{ ...searchForm, gsType: route.query.gsType,ydGs: route.query.ydGs,deptId: deptId.value }) const getStatisticsInfo = () =&gt;{ isIndex.value = false; statisticsInfo(params).then( res =&gt;{ let data = res.data.data.list districTElecTableData.value = data; }).catch( error =&gt;{ console.log( 'error',error ) }) } //上面那个拷贝没用，响应式还是没有，老老实实写在参数括号里面 // 列表 const getDistricTElecList = () =&gt; { isIndex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2fd82a5accf8c30029b027a1b5249d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0d1072e11b3c5386e82a1b0918cadf/" rel="bookmark">
			RabbitMQ之延迟消息实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ之延迟消息实战 使用死信交换机实现延迟消息
使用死信交换机的过期时间以及没有消费者进行消费，时间到了就会到死信队列中，由此可以实现延迟消息使用延迟消息插件
前提：需要mq配置插件
延时信息案例实战
把一个30分钟的延迟消息可以拆分成各个小时间段来优化MQ大量信息的压力
代码实现
（1）定义消息体对象 @Data public class MultyDelayMessage&lt;T&gt;{ // 消息体 private T data; // 记录延迟时间的集合 private List&lt;Long&gt; delayMillis; public MultiDelayMessage(T data List&lt;Long&gt; delayMilis){ this.data = data; this.delayMillis = delayMillis; } public static &lt;T&gt; MultiDelayMessage&lt;T&gt; of(T data,Long ... delayMillis){ return new MultiDelayMessage&lt;&gt;(data,Collutils.newArrayList(delayMilis)); } //获取并移除下一个延迟时间,返回队列中的第一个延时时间 public Long removeNextDelay{ return delayMillis.remove(0); } // 判断是否有下一个延时时间 public bollean hasNextDelay(){ return !delayMilis.isEmpty(); } } （2）定义队列名称
public interface MqConstants{ String DELAY_EXCHANGE = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f0d1072e11b3c5386e82a1b0918cadf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d243a818f69061d5a2ab56a94e0797f/" rel="bookmark">
			Linux 环境下搭建 ElasticSearch （CentOS 7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、执行解压操作 创建一个安装目录，解压到此文件夹。
mkdir /usr/local/es
将上传的 es 包进行解压到指定文件夹位置，注意后面的-C 大写。 tar -zxvf elasticsearch-7.4.0-linux-x86_64.tar.gz -C /usr/local/es
二、创建新用户 因为安全问题，不允许root用户直接运行，先进行创建新用户。
useradd caojun
passwd caojun
接着输入自己的密码即可。接着授权
chown -R caojun:caojun /usr/local/es/elasticsearch-7.4.0
三、修改配置文件 elasticsearch.yml 这是没有安装vim 导致，安装vim命令如下
yum -y install vim*
vim /usr/local/es/elasticsearch-7.4.0/config/elasticsearch.yml
主要修改一下五处：按照截图中修改，只需要注释前面的 #
cluster.name：配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称
node.name：节点名，elasticsearch会默认随机指定一个名字，建议指定一个有意义的名称，方便管理
network.host：设置为0.0.0.0允许外网访问
http.port：Elasticsearch的http访问端口
cluster.initial_master_nodes：初始化新的集群时需要此配置来指定参与选举的master（注意：需要添加自己虚拟机的地址，图中没有显示["192.168.101.128"]）
四、启动 ElasticSearch 切换到刚刚自己新建的用户
第一步：su caojun
第二步：cd /usr/local/es/elasticsearch-7.4.0/bin
第三步：./elasticsearch
出现问题如下：需要修改虚拟机配置文件了
五、修改虚拟机配置文件 第一步：su root
第二步：sudo vi /etc/security/limits.conf
添加如下两句配置
caojun soft nofile 65536
caojun hard nofile 65536
退出保存成功
第三步：sudo vi /etc/security/limits.d/20-nproc.conf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d243a818f69061d5a2ab56a94e0797f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9cf958a23798ecc4eca857e704aeae1/" rel="bookmark">
			pytorch 卷积层 padding_mode=‘circular’ 的小 bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在写conv2d卷积的时候发现一个小问题，当我的2D卷积层定义为
nn.Conv2d(self.input_channels,self.hidden_channels, self.input_kernel_size, self.input_stride, self.input_padding, bias=True, padding_mode='circular')) 时，当我的输入shape=(1,2,128,128)，输入channel=2，hidden_channel=8，kernel_size=4，stride=2，padding=1时，经过卷积之后我的输出shape=(1,8,63,63)，这样官方给的卷积size计算公式不符。输出大小=（输入大小-卷积核大小+2*padding）/步长+1，,out_size = （input_size - K + 2P）/ S +1。
最后发现是padding_mode设定为‘circular’是会出现问题，当使用其他padding_mode（'zeros', 'reflect', 'replicate'）方式时，会正常计算。而源码中没对这个问题进行解释。
conv2d父类_ConvNd部分：
conv2d源码部分：
因此使用'circular' 模式时需要注意，可能会出现后续处理shape不匹配问题。
import torch import torch.nn as nn x = torch.ones((1, 1, 32, 32)) print(x.shape) conv_zeros = nn.Conv2d(in_channels=1, out_channels=8, kernel_size=4, stride=2, padding=1, bias=True,) out1 = conv_zeros(x) print('默认zeros卷积后的shape= ', out1.shape) conv_reflect = nn.Conv2d(in_channels=1, out_channels=8, kernel_size=4, stride=2, padding=1, bias=True, padding_mode='reflect') out2 = conv_reflect(x) print('reflect卷积后的shape= ', out2.shape) conv_replicate = nn.Conv2d(in_channels=1, out_channels=8, kernel_size=4, stride=2, padding=1, bias=True, padding_mode='replicate') out3 = conv_replicate(x) print('replicate卷积后的shape= ', out3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9cf958a23798ecc4eca857e704aeae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b645b50a4598339cc6b8e342bbc9bd3/" rel="bookmark">
			蓝桥杯第一天-----时间显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、题目描述二、测试用例三、题目分析四、具体代码实现总结 前言 本章中将相信介绍蓝桥杯中关于时间显示的题目。
链接：https://www.lanqiao.cn/problems/1452/learning/
一、题目描述 二、测试用例 三、题目分析 1.输入的时间为毫秒，毫秒与秒之间是相差1000的关系。同时注意下用什么类型比较好 2.要求计算当前时间，我们其实不用关心这天具体是那天，那计算起来就复杂了。
🏉首先将所输入数字除以1000，得到距离1970年1月1日凌晨当天所经过的秒数s，再s%60，就是当天的秒数
🏉首先s1/60，得到距离1970年1月1日凌晨当天经过了多少分钟m
再用m%60，得到当天在分钟
🏉s1/60/24,得到距离1970年1月1日凌晨当天经过了多少小时h,
再用h%24，得到当天在几点。
3.输出要求时分秒不足两位补前导0 四、具体代码实现 总结 以上就是我们对时间显示解题的详细介绍，希望对大家的学习有所帮助，仅供参考 如有错误请大佬指点我会尽快去改正 欢迎大家来评论~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53825c94f2c37effe33121e478547ee6/" rel="bookmark">
			在Vue中使用Echarts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Echarts1. 介绍2. 体验NPM 安装 Echarts定义 Echarts 容器引入 Echarts 3. 基础配置 Echarts 1. 介绍 常见的数据可视化库：
D3.js 目前 Web 端评价最高的 Javascript 可视化工具库(入手难)ECharts.js 百度出品的一个开源 Javascript 数据可视化库Highcharts.js 国外的前端数据可视化库，非商用免费，被许多国外大公司所使用AntV 蚂蚁金服全新一代数据可视化解决方案 等等Highcharts 和 Echarts 就像是 Office 和 WPS 的关系 ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。
大白话：
是一个JS插件性能好可流畅运行PC与移动设备兼容主流浏览器提供很多常用图表，且可定制。 折线图、[柱状图](Examples - Apache ECharts)、散点图、饼图、K线图 2. 体验 NPM 安装 Echarts 你可以使用如下命令通过 npm 安装 Echarts
npm install echarts --save 定义 Echarts 容器 &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; 引入 Echarts import * as echarts from 'echarts'; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53825c94f2c37effe33121e478547ee6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e94a5f130e2bc4accc30f4a8a8b1c6/" rel="bookmark">
			基于5G&#43;物联网&#43;SaaS&#43;AI的农业大数据综合解决方案：PPT全文44页，附下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键词：智慧农业大数据，5G智慧农业，物联网智慧农业，SaaS智慧农业，AI智慧农业，智慧农业大数据平台
一、智慧农业大数据建设背景 1、应对全球人口快速增长带来的粮食生产压力，未来的粮食生产力必须提高60%。面对可种植耕地的不断缩小，以及越来越严峻的天气，传统农业面临着巨大挑战。
2、信息技术的进步为农业转型提供了新的机遇。大数据、物联网、云计算等技术的普及为传统农业向智慧农业的转变提供了技术支持。
3、大数据技术的快速发展，能够将不同格式、不同业务领域的海量数据整合成标准统一的数据源，进行分析应用，从而产生巨大的经济社会价值。
二、智慧农业大数据建设思路 1、构建农业数字化基础设施 在农业领域，数字化基础设施是实现智慧农业和智能化农业的关键。因此，建设农业数字化基础设施是首要任务。这包括构建高速、稳定、覆盖面广的5G网络，建设物联网设备和应用平台，以及提供SaaS服务所需的服务器、操作系统等基础设备。
2、数字农业信息化应用 在数字化基础设施的基础上，通过应用多种新技术，如卫星遥感技术、物联网技术等，实现农业信息化应用。例如，利用卫星遥感技术获取农业地理信息数据，通过可视化系统将数据呈现出来，构建农业数据可视化平台；利用物联网技术采集农田数据，通过云计算和大数据分析技术处理数据，为农业生产提供科学依据。
3、智慧农业大数据平台建设 将农业数字化基础设施、数字农业信息化应用以及农业领域的相关数据整合到一起，构建智慧农业大数据平台。该平台能够实现数据共享、数据分析、预测预警等功能，为政府、企业和农户提供决策支持和服务。
三、智慧农业大数据建设架构 1、感知层：利用卫星遥感技术、射频识别、二维码、传感器件、北斗以及物联网等技术，通过各种传感器、摄像头等设备采集农田数据，如土壤湿度、温度、光照强度等，以及农作物生长情况、病虫害情况等信息。
2、网络层：利用5G网络将采集到的数据传输到云端服务器，同时为各种应用提供稳定的网络连接。
3、应用层：基于SaaS模式的应用平台，利用云计算和大数据分析技术处理和分析数据，为政府、企业和农户提供决策支持和服务。例如，通过分析土壤湿度、温度等数据，为农户提供灌溉建议；通过分析农作物生长情况、病虫害情况等信息，为农户提供防治建议。
智慧农业大数据系统平台建设还要充分考虑要能够有效地整合农业领域的各种数据资源，提高农业生产效率和管理水平，满足人类对粮食生产的需求，推动农业的可持续发展。并且要不断优化和更新完善系统平台，提高系统的稳定性和性能。
“方案365”2023年全新整理智慧城市、数字孪生、乡村振兴、智慧乡村、元宇宙、数据中台、智慧园区、智慧社区、智慧矿山、城市生命线、智慧水利、智慧应急、智慧校园、智慧工地、智慧农业、智慧文旅、智慧交通等300+行业全套解决方案。
四、农业大数据综合解决方案内容 五、获取全套解决方案 提示：智慧农业等300+行业最新解决方案，百度搜索 "方案365”官方网站 或点击下方链接获取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a9ce8d7fbab39cfb8d8e45e204169c/" rel="bookmark">
			浏览器事件环--节流--防抖--详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件环： 先执行同步代码
如果遇到一个宏任务，会把这个任务放到一个宏任务队列，如果遇到一个微任务，就把这个微任务放到微任务任务中
当同步代码执行完毕后，先去清空微任务队列。
当微任务队列清空完毕后，从宏任务队列中取出一个宏任务，去执行，在执行过程中，你的宏任务中可能还有同步代码或宏任务或微任务，重复上面的步骤，执行完一个宏任务，肯定要清空微任务队列。这就是所谓的事件环
宏任务：ajax，setTimeout，setInterval，DOM事件监听，UI渲染…微任务：promies中的then回调 Mutaion Observer … &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是一个p标签01&lt;/p&gt; &lt;!-- &lt;script&gt; console.log('start') setTimeout(() =&gt; { console.log('timeout') }) Promise.resolve().then(() =&gt; { console.log('promise then') }) console.log('end') &lt;/script&gt; --&gt; &lt;script&gt; const p = document.createElement('p'); p.innerHTML = '我是一个p标签02'; document.body.appendChild(p); const list = document.getElementsByTagName('p') console.log('length----', list.length) console.log('start') setTimeout(() =&gt; { const list = document.getElementsByTagName('p') console.log('length----', list.length) alert("阻塞 timeout") }) Promise.resolve().then(() =&gt; { const list = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8a9ce8d7fbab39cfb8d8e45e204169c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c252cc32bca62a36be8a9bf22dbcd25/" rel="bookmark">
			js中for-in和for-of遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for in 遍历的是数组的索引(index)
for of 遍历的是数组元素值（value）
区别： for in 和 for of 都可以循环数组，for in 输出的是数组的index下标，而for of 输出的是数组的每一项的值。 const arr = [1,2,3,4] // for ... in for (const key in arr){ console.log(key) // 输出 0,1,2,3 } // for ... of for (const key of arr){ console.log(key) // 输出 1,2,3,4 } for in 可以遍历对象，for of 不能遍历对象，只能遍历带有iterator接口的，例如Set,Map,String,Array。 const object = { name: 'lx', age: 23 } // for ... in for (const key in object) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c252cc32bca62a36be8a9bf22dbcd25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547dd3cbc242c4ff8aa86547136452e5/" rel="bookmark">
			创维55Q40通过SMB局域网播放电影卡解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SMB 1.0的最大传输速度约为100 Mbps（每秒传输1亿位）。SMB 2.0及以上的版本在吞吐量和性能方面都有了显著的改进。根据Microsoft的官方文档，SMB 2.0的理论最大速度约为2 Gbps（每秒传输2亿位），而SMB 3.0甚至可以达到10 Gbps的传输速度。
1，开启电脑上的SMB1
2.电脑端启用SMB2
3.电视端通过SMB连接电脑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e34e6aa0fb8c556657dd7187140a64c/" rel="bookmark">
			P1036 [NOIP2002 普及组] 选数 (判断素数，dfs）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下为代码
主要涉及到判断素数和dfs两个知识点
判断素数的模板 int isprime(int n) { if(n &lt;= 1) return 0; for(int i = 2; i * i &lt;= n; i++){ if(n % i == 0) return 0; } return 1; } dfs 重点理解这里的dfs，借助样例理解。
void dfs(int dep,int k1,int sum){//depth深度初始为1 //以样例为例子，我们要拿三个数的和，k1用来判断是否到达3 //sum是这三个数的和，初始为0 if(dep == n + 1)//到达最深处的下一个就判断一次 { if(k1 != k) return; //加的数不到三个则返回到上一次dfs if(isprime(sum)) ans++; return; } dfs(dep+1,k1+1,sum+x[dep]); //若选了这数，则将它加上，深度加一，选的数的数目加一 dfs(dep+1,k1,sum); //若没选这个数，就不加，深度加一，选的数的数目不变 } #include&lt;bits/stdc++.h&gt; using namespace std; using ll = long long; int x[30]; int n,k; int ans = 0; int isprime(int n) { if(n &lt;= 1) return 0; for(int i = 2; i * i &lt;= n; i++){ if(n % i == 0) return 0; } return 1; } void dfs(int dep,int k1,int sum){//depth深度初始为1 //以样例为例子，我们要拿三个数的和，k1用来判断是否到达3 //sum是这三个数的和，初始为0 if(dep == n + 1)//到达最深处的下一个就判断一次 { if(k1 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e34e6aa0fb8c556657dd7187140a64c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1630f6c8d1c3443b383595365223f54/" rel="bookmark">
			让Stable Diffusion一秒出图！清华硕士加速神器爆火，已有公司接入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		克雷西 发自 凹非寺 量子位 | 公众号 QbitAI AI图像生成，已经进入了秒速级别，只要4步推理就能完成绘制，最快更是能在1秒之内完成。
现在，清华大学联合HuggingFace的研究人员，推出了全新的绘图模型加速模块。
作者给出的体验版当中，点击生成按钮后，模型只用了几秒钟就绘制出了4张清晰的图像。
这个加速模块叫做LCM-LoRA，发布后不久就斩获了2k+次GitHub星标。
它不仅加速能力强、泛化性能好，适配的模型也很广泛，SD系和LoRA模型都能用它来加速。
团队基于LCM-LoRA自行优化的文生图模型已在HuggingFace上开放体验，图生图模型也推出了CoLab等版本。
AI绘图工具迅速接入 LCM-LoRA开源后不久，就有AI绘图工具厂商Scenario宣布将基于它推出“实时绘图”功能。
Scenario的CEO还在𝕏上亲自展示了即将上线的实时绘图功能DEMO。
只见一边在绘制草图，另一边AI就把相应的画作绘制好了，时间上几乎同步。
调整提示词和有关参数，模型响应得也是干脆利落。
这些DEMO发布后，引发了众人的一致赞叹。
那么，LCM-LoRA这个加速模块到底有多强，又是怎样实现的呢？
“跳步”降低内存开销 LCM-LoRA将LoRA引入潜在一致性模型（LCM）的蒸馏过程，显著减少了训练内存开销，从而提高性能。
而LCM是从潜扩散模型（LDM）中蒸馏出来的，“蒸馏”的过程也可以看做是对扩散模型的微调。
它的核心思想是在图像的隐变量空间中学习一致性映射函数，该函数可以直接将扩散过程中的任意点映射到终点，即微分方程的解。
通过这种一致性映射，LCM可以跳过迭代采样过程，直接进行少步甚至一步采样，从而极大地加速了图像的生成。
而隐变量空间操作相比基于像素空间的方法，计算复杂度和内存需求也更低。
结合LoRA后，只需要训练低秩分解矩阵，可训练参数量和内存开销进一步减少，应用范围也从单纯的文生图扩展到了图生图和视频生成。
最直观体现的就是我们看到的秒速出图，而训练时间上，LCM-LoRA优化后的模型在A100上训练只需32个GPU时。
训练时间缩短的背后，也于训练参数量大幅减少密切相关：
SD-V1.5全量参数为9.8亿，使用LoRA后可训练参数减少到6750万，约减少了93.1%。
SSD-1B参数从13亿减少到1.05亿，约减少了91.9%。
SDXL参数从35亿减少到1.97亿，约减少了94.3%。
不仅是训练消耗的降低，推理过程中的步数也大幅减少，一般只需要4步推理就能绘制出质量不错的图像。
有时甚至只要一步就能完成，用时还不到1秒，FID分数（越低越好）在50以下。
不仅加速性能优异，LCM-LoRA的适配性也十分广泛。
LCM-LoRA训练得到的LoRA参数又称为加速向量，可以数据集上微调得到的LoRA参数直接线性组合，不需要额外训练。
这种组合方式使得LCM-LoRA成为一个可直接插接到各种微调模型中的通用图像生成加速模块。
作者简介 LCM和LCM-LoRA论文的两位主要作者是来自清华大学交叉信息研究院的研究生骆思勉（Simian Luo）和谭亦钦（Yiqin Tan）。
清华叉院的黄隆波副教授、李建副教授和赵行助理教授也参与了这两项研究。
在LCM-LoRA的工作中，来自HuggingFace的研究人员亦有贡献。
论文地址：
[1]https://arxiv.org/abs/2310.04378
[2]https://arxiv.org/abs/2311.05556
关注公众号【机器学习与AI生成创作】，更多精彩等你来读
卧剿，6万字！30个方向130篇！CVPR 2023 最全 AIGC 论文！一口气读完
深入浅出stable diffusion：AI作画技术背后的潜在扩散模型论文解读
深入浅出ControlNet，一种可控生成的AIGC绘画生成算法！ 经典GAN不得不读：StyleGAN
戳我，查看GAN的系列专辑~！
一杯奶茶，成为AIGC+CV视觉的前沿弄潮儿！
最新最全100篇汇总！生成扩散模型Diffusion Models
ECCV2022 | 生成对抗网络GAN部分论文汇总
CVPR 2022 | 25+方向、最新50篇GAN论文
ICCV 2021 | 35个主题GAN论文汇总
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1630f6c8d1c3443b383595365223f54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e88d61b43533fdc5e18f1b1c885a62e4/" rel="bookmark">
			JavaScript 运行机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JavaScript 运行机制目标知识要点一、进程与线程1.1 概念1.2 区别1.3 多进程与多线程1.4 JS 为什么是单线程1.5 浏览器1.5.1 浏览器包含哪些进程1.5.2 为什么浏览器要多进程1.5.3 渲染进程1.5.3.1 GUI 渲染线程1.5.3.2 JS 引擎线程1.5.3.3 事件触发线程1.5.3.4 定时触发器线程1.5.3.5 异步HTTP请求线程 二、事件循环（Event Loop）基础三、宏任务与微任务3.1 宏任务（macrotask）3.2 微任务（microtask） 四、完整的事件循环（Event Loop）五、Promise &amp; async/await5.1 Promise5.2 async/await JavaScript 运行机制 原文链接：JavaScript运行机制
目标 1.了解进程与线程的基础概念，明确在浏览器中的进程与线程机制；
2.了解浏览器与Node中的事件循环；
知识要点 一、进程与线程 1.1 概念 进程：CPU资源分配的最小单位。——可以独立运行且拥有自己的资源空间的任务程序。（包括运行中的程序和程序中所用到的内存和系统资源）。
eg：每打开一个软件就会产生一个进程，浏览器中每开一个Tab页也会产生一个进程。进程之间相互独立。
线程：CPU调度的最小单位。——建立在进程基础上的一次程序运行单位。一个进程可以有多个线程。一个程序中可以同时运行多个不同的线程来执行不同的任务。
1.2 区别 进程包含了线程，一个进程可以对应多个线程。线程相当于是进程中的不同执行路线。
调度和切换：线程上下文切换比进程上下文切换要快得多。
1.3 多进程与多线程 多进程：允许同一计算机系统中同时运行两个或两个以上的进程。比如在打开网易云听歌的同时还可以打开编辑器敲代码，而这两个进程之间不会相互干扰。多线程：指一个程序中包含多个执行流来执行不同的任务，而这多个不同的执行流是并行的。 1.4 JS 为什么是单线程 JS主要用途是与用户互动，以及操作DOM。
如果JS是多进程的话，那么它可以同时在某个DOM节点上添加内容，又可以删除这个节点，从而导致浏览器不知该以哪个为准。
1.5 浏览器 1.5.1 浏览器包含哪些进程 浏览器包含以下进程：
Browser进程第三方插件进程GPU进程（Graphics Processing User）渲染进程 1.5.2 为什么浏览器要多进程 若浏览器是单进程，那么如果某个Tab页崩溃了，则会导致整个浏览器瘫痪，同理，如果插件崩溃了则会影响整个浏览器，这样体验感非常差。
1.5.3 渲染进程 页面渲染，JS的执行，事件的循环，都在渲染进程中执行，所以需要重点了解渲染进程。
渲染进程是多线程的，以下是一些常用较为主要的线程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e88d61b43533fdc5e18f1b1c885a62e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43e55e54c82ff8a604003f91ee1aa58/" rel="bookmark">
			JdbcTemplate.queryForObject
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		queryForObject(String sql, Class&lt;T&gt; requiredType, @Nullable Object... args)这个方法中的Class类型是基本数据类型，或者他们的包装类型，再或者是String.class，这个方法的返回值为单列，用于查询结果只有单列的数据(感觉这个也不用查)或者聚合查询更好。 queryForStream(String sql, RowMapper&lt;T&gt; rowMapper, @Nullable Object... args)这个可以用来查询自己根据数据库中数据定义的bean类，spring会自动把查询的结果封装成你想要的实体类，可以用它的实现类BeanPropertyRowMapper&lt;T&gt;(T.class)来作为实参。 //道阻且长
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6e883110956c5ceb4415443db4c735/" rel="bookmark">
			【数据结构初阶】链表（上）——无头单向非循环链表的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、链表
1.链表的概念及结构
2.链表的分类
&lt;2.1&gt;单向链表和双向链表
&lt;2.2&gt;带头节点链表和不带头节点链表
&lt;2.3&gt;循环和非循环链表
二、无头单向非循环链表的实现
1.创建无头单向非循环链表的节点
2.为无头单向非循环链表添加数据
&lt;2.1&gt;在链表尾部插入数据
&lt;2.2&gt;在链表头部插入数据
&lt;2.3&gt;在链表pos节点位置之后插入数据
3.为无头单向非循环链表删除数据
&lt;3.1&gt;在链表尾部删除数据
&lt;3.2&gt;在链表头部删除数据 &lt;3.3&gt;在链表pos节点之后删除数据
4.遍历链表
5.在链表中查找数据
6.销毁链表
三、无头单向非循环链表实现完整代码
四、运行测试
经过上期博客的学习我们发现顺序表存在着一些缺陷：
&gt; 扩容时有一定的代价，尤其是异地扩容时。其次还会造成空间的浪费（空间碎片的产生）。
&gt; 从头部或中间插入（删除）数据时需要挪动其他数据，效率低下。
那我们是否有一种可以按需申请释放内存、在插入删除数据时不挪动数据的存储方式呢？
链表就很好的解决了以上问题：
一、链表 1.链表的概念及结构 概念:链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 下面是链表的模拟图：
我们每次要存储要存储数据时需要向系统空间的堆区申请所存储数据外加一个指针的大小的空间（我们称这样一个大小的空间叫做节（结）点），其中指针空间所存的是下一个节点的地址（如果该节点后无节点该指针指向的地址则为空）。
从上图可看出：
1.链式结构在逻辑上是连续的，但是在物理上不一定连续。
2.现实中的结点一般都是从堆上申请出来的。
3.从堆上申请的空间，是按照一定的策略来分配的，两次申请的空间可能连续，也可能不连续。
2.链表的分类 &lt;2.1&gt;单向链表和双向链表 &lt;2.2&gt;带头节点链表和不带头节点链表 &lt;2.3&gt;循环和非循环链表 虽然链表的种类很多，但是我们最常用的是无头单向非循环链表和带头双向循环链表：
无头单向非循环链表:结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构,如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
带头双向循环链表:结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了。
下面我们来对无头单向非循环链表来进行实现：
二、无头单向非循环链表的实现 在实现单链表之前我们先要确定节点类型：
typedef int SLTDataType;//数据类型 typedef struct SListNode//节点类型 { SLTDataType Data;//数据 struct SListNode* next;//节点指针 }SListNode; 注：这里的对int类型进行重定义是为了我们更好的看懂Data只是一种数据而不仅仅是int类型。所以我们在使用链表时存储的数据并不限制于int类型，这里仅仅是举例。
1.创建无头单向非循环链表的节点 SListNode* BuySListNode(SLTDataType x)//x传入要添加的数据 { SListNode* p = (SListNode*)malloc(sizeof(SListNode));//为单链表创建一个节点的空间 if (p == NULL)//判断堆区空间是否申请成功 { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb6e883110956c5ceb4415443db4c735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26abba8e5691dfbd83ee572418451afc/" rel="bookmark">
			go语言 ｜ 图解字节青训营抖音（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文大致介绍了本人及本人所在小组为第五届字节跳动青训营后端专场大项目需求 —— 「实现一个极简版抖音」的部分实现细节。
需求 本届后端青训营大项目要求实现一个极简版抖音的后端服务，该后端服务通过 HTTP 协议向已被设计好的前端 App 传递数据，并通过 URL Query 获得请求参数。
该服务大致有如下类别的接口：
用户鉴权用户基本信息用户社交视频投稿视频流视频互动 我们现在先简单把项目跑起来，看看效果
后端安装 首先进入链接https://github.com/a76yyyy/tiktok，下载相应的后端源码
git clone https://github.com/RaymondCode/simple-demo.git 在终端执行如下命令。
go build &amp;&amp; ./simple-demo 跑前端 apk 下载：链接: https://pan.baidu.com/s/11RvbJf7V2HGwsyNabBpslg?pwd=sd8v 提取码: sd8v
下载好apk拖入模拟器自动安装。
双击右下角 我 进入高级设置
2.在 cmd 中查看IP信息 ipconfig，找到无效局域网的 Ipv4 地址
3 填入BaseUrl中
总结 本文介绍抖音极简版demo的安装，帮助大家先对项目有个了解，接下来会介绍相关的结构以及api接口，并进行实际测试。
参考 https://juejin.cn/post/7201195953691836471
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579f929b7cf17fa4135a2de97d9ecb85/" rel="bookmark">
			JavaScript算法44- 最小处理时间（leetCode:2895middle）周赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2895. 最小处理时间
一、题目 你有 n 颗处理器，每颗处理器都有 4 个核心。现有 n * 4 个待执行任务，每个核心只执行 一个 任务。
给你一个下标从 0 开始的整数数组 processorTime ，表示每颗处理器最早空闲时间。另给你一个下标从 0 开始的整数数组tasks，表示执行每个任务所需的时间。返回所有任务都执行完毕需要的 最小时间 。
注意：每个核心独立执行任务。
示例
输入：processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5] 输出：16 解释： 最优的方案是将下标为 4, 5, 6, 7 的任务分配给第一颗处理器（最早空闲时间 time = 8），下标为 0, 1, 2, 3 的任务分配给第二颗处理器（最早空闲时间 time = 10）。 第一颗处理器执行完所有任务需要花费的时间 = max(8 + 8, 8 + 7, 8 + 4, 8 + 5) = 16 。 第二颗处理器执行完所有任务需要花费的时间 = max(10 + 2, 10 + 2, 10 + 3, 10 + 1) = 13 。 因此，可以证明执行完所有任务需要花费的最小时间是 16 。 提示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/579f929b7cf17fa4135a2de97d9ecb85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403fe80af243b66d190a654422381311/" rel="bookmark">
			Maven编译报错：javacTask: 源发行版 1.8 需要目标发行版 1.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错截图：
IDEA中的jdk检查都正常设置的1.8一点毛病没有。参考其他帖子链接如下：
https://blog.csdn.net/zhishidi/article/details/131480199https://blog.51cto.com/u_16213460/7197764https://blog.csdn.net/lck_csdn/article/details/125387878 逐一排查后都没能解决，到最后https://segmentfault.com/q/1010000042873871这篇帖子给了个提示最后问题得以解决，其实很简单如果是父子工程的话，将下边编译器插件依赖仍到父节点下的pom文件中即可成功，子工程如果报错就仍到子工程里边。
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; maven-compiler-plugin 这个插件是springboot的maven插件,能够将springboot项目打包为可执行的jar/war包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/540a918e6e1942f890c74a6d0a56021a/" rel="bookmark">
			uniapp Android如何打开常用系统设置页面？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uniapp Android 如何打开常用系统设置页面？ 在使用App过程时，有时候会对一些权限获取，比如打开蓝牙、打开通知栏通知等设置，我们如何快速跳转到需要的设置页面？
文章目录 uniapp Android 如何打开常用系统设置页面？效果图打开蓝牙打开定位打开 WIFI其他其他 效果图 打开蓝牙 实现开发过程中，可进行封装，传入参数即可。 var main = plus.android.runtimeMainActivity(); var Intent = plus.android.importClass("android.content.Intent"); var mIntent = new Intent('android.settings.BLUETOOTH_SETTINGS'); main.startActivity(mIntent); 打开定位 var main = plus.android.runtimeMainActivity(); var Intent = plus.android.importClass("android.content.Intent"); var mIntent = new Intent('android.settings.LOCATION_SOURCE_SETTINGS'); main.startActivity(mIntent); 打开 WIFI var main = plus.android.runtimeMainActivity(); var Intent = plus.android.importClass("android.content.Intent"); var mIntent = new Intent('android.settings.WIFI_SETTINGS'); main.startActivity(mIntent); 其他 设置：WIRELESS_SETTINGS应用管理：APPLICATION_SETTINGS 其他 设置：WIRELESS_SETTINGS应用管理：APPLICATION_SETTINGS… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457372c0427d1875c98d85b87f9e2682/" rel="bookmark">
			Python爬取京东双十一商品可视化价格曲线示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言抓取京东价格总结关于Python技术储备一、Python所有方向的学习路线二、Python基础学习视频三、精品Python学习书籍四、Python工具包+项目源码合集①Python工具包②Python实战案例③Python小游戏源码五、面试资料六、Python兼职渠道 前言 一年一度的双十一已经结束了，不管是双十一之前还是双十一之后各种优惠券降价提示。玩过多次双十一活动的小编表示一顿操作猛如虎，一看结果2毛5。浪费时间不说而且未必得到真正的优惠，双十一电商的“明降暗升”已经是默认的潜规则了。打破这种规则很简单，可以用 Python 写一个定时监控商品价格的小工具。
思路第一步抓取商品的价格存入 Python 自带的 SQLite 数据库每天定时抓取商品价格使用 pyecharts 模块绘制价格折线图，让低价一目了然。
抓取京东价格 从商品详情的页面中打开 F12 控制面板，找到包含 p.3 的链接，在旁边的 preview 面板中可以看到当前商品价格
defget_jd_price(skuId):
sku_detail_url = 'http://item.jd.com/{}.html' sku_price_url = 'https://p.3.cn/prices/get?type=1&amp;skuid=J_{}' r = requests.get(sku_detail_url.format(skuId)).content soup = BeautifulSoup(r, 'html.parser', from_encoding='utf-8') sku_name_div = soup.find('div', class_="sku-name") if not sku_name_div: print('您输入的商品ID有误！') return else: sku_name = sku_name_div.text.strip() r = requests.get(sku_price_url.format(skuId)) price = json.loads(r.text)[0]['p'] data = { 'sku_id': skuId, 'sku_name': sku_name, 'price': price } return data 把抓取的价格存入 sqlite 数据库，使用 PyCharm 的 Database 功能创建一个 sqlite 数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/457372c0427d1875c98d85b87f9e2682/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/37/">«</a>
	<span class="pagination__item pagination__item--current">38/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/39/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>