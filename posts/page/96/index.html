<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c1eb5d668caef83c075055043cf1aa0/" rel="bookmark">
			小程序生成二维码(使用weapp-qrcode)以及相应的bug汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果展示 github 地址 github 地址 https://github.com/MrITzhongzi/small_routine_components/tree/master/6.create_qr_code
下载weapp-qrcode 可以通过小程序的npm功能下载：
npm i weapp-qrcode -S
小程序引入 方法一
import drawQrcode from 'weapp-qrcode'; 方法二 把npm下载的程序包中dist文件夹中的文件引入（任意引入一个都可以）
需要把这个js文件复制到自己的项目，然后
import xxx from 'xxxxx'; 使用方法 核心代码展示 // 页面被展示 console.log(typeof drawQrcode) const ctx = wx.createCanvasContext('myQrcode', this); let that = this; // 在组件实例进入页面节点树时执行 drawQrcode({ width: 200, height: 200, ctx: ctx, text: that.data.showData, callback(){ } }) 小程序 组件封装好 createQrCode.json { "component": true, "usingComponents": {} } createQrCode.wxml &lt;view class="qrcode-box" style="width: 200px; height: 200px;margin: 0 auto;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c1eb5d668caef83c075055043cf1aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb68371df1f7b173a3687be9da7b82f/" rel="bookmark">
			JVM学习笔记 - 第一章  什么是JVM？JVM基础入门和Java体系架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 JVM和Java体系架构 目录：0.什么是JVM？1.学习JVM的目的2.Java VS C++3.Java的跨平台性4.字节码5.Java生态圈6.虚拟机介绍6.1虚拟机的概念6.2Java虚拟机6.3.JVM的位置6.4 JVM的整体结构 7. Java代码的执行流程8. JVM架构模型9. 两种架构的举例10. 反编译字节码文件11. 架构总结12. JVM的生命周期 目录： 0.什么是JVM？ JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。
Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，
使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 打个比方，如果数学公式是Java程序，那么公式的推导过程就是JVM干的事
关系图：
1.学习JVM的目的 面试的需要（BATJ、TMD，PKQ等面试都爱问）中高级程序员必备技能：项目管理、调优的需求追求极客的精神，比如：垃圾回收算法、JIT（即时编译器）、底层原理能够明白为什么Java最早期被称为解释型语言为了今后更好的解决线上排查问题可以通过调整JVM相关参数提高Java应用的性能可以清楚知道Java程序是如何执行的 2.Java VS C++ 垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。 3.Java的跨平台性 每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理。随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。
4.字节码 我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。
5.Java生态圈 Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。
作为一个平台，Java虚拟机扮演着举足轻重的作用 Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分 作为一种文化，Java几乎成为了"开源"的代名词。 第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。 作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。 6.虚拟机介绍 6.1虚拟机的概念 所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。
大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。 6.2Java虚拟机 Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。
特点： 一次编译，到处运行自动内存管理自动垃圾回收功能 6.3.JVM的位置 JVM是运行在操作系统之上的，它与硬件没有直接的交互
Java的体系结构
6.4 JVM的整体结构 HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器（JIT)并存的架构。在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。执行引擎包含三部分：解释器，即时编译器，垃圾回收器
这个图要背下来↑ 7. Java代码的执行流程 8. JVM架构模型 Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：
基于栈式架构的特点 设计和实现更简单，适用于资源受限的系统避开了寄存器的分配难题：使用零地址指令方式分配指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现不需要硬件支持，可移植性更好，更好实现跨平台 基于寄存器架构的特点 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差性能优秀和执行更高效花费更少的指令去完成一项操作在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deb68371df1f7b173a3687be9da7b82f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc6afa4f5b3820bb541f49f85e254b6/" rel="bookmark">
			百度地图 路径规划   错误 errorcode: 230
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纯记录，百度路径规划
02-22 14:00:02.775 31156-31156/com.example.baidudemo E/baidumapsdk: Authentication Error
=============================================
----------------- 鉴权错误信息 ------------
sha1;package:D***********7;com.example.baidudemo
key:y********************bs
errorcode: 230 uid: -1 appid -1 msg: APP Mcode码校验失败
请仔细核查 SHA1、package与key申请信息是否对应，key是否删除，平台是否匹配
errorcode为230时，请参考论坛链接：
http://bbs.lbsyun.baidu.com/forum.php?mod=viewthread&amp;tid=106461
=============================================
02-22 14:00:03.096 31156-31156/com.example.baidudemo I/Surface
要注意修改，其中key alias 是指别名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84148eb8e9c1a00fca7395598e6d2848/" rel="bookmark">
			链表的创建、遍历、查找、插入、删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		温馨提示 可以画图来模拟链表操作，其中要注意指针的指向，注意指针赋值的先后关系。
一、链表的创建（头插法、尾插法） 1、准备工作：
引入头文件及创建基本数据结构
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;	//提供 malloc 和 free 函数 typedef struct node{ //typedef 是重新定义数据类型 struct node int data; struct node *next; }NODE,*PNODE; 2、头插法：
//头插法创建链表 PNODE HeadInsert(int n) { int i,temp; PNODE head,p; head = (PNODE)malloc(sizeof(NODE)); head-&gt;next = NULL; for(i = 0;i &lt; n;i++) { scanf("%d",&amp;temp); p = (PNODE)malloc(sizeof(NODE)); p-&gt;data = temp; p-&gt;next = NULL; //头插法，顺序不能换 p-&gt;next = head-&gt;next; head-&gt;next = p; } return head; } 输入数据的顺序和表中数据的顺序是相反的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84148eb8e9c1a00fca7395598e6d2848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1c5cd27ebec7c37ba499c1ea2b968d/" rel="bookmark">
			判断树是否是二叉排序树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本数据结构 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct Node{ int data; struct Node *lchild,*rchild; }Node,*PNode; 一、创建二叉排序树： 指针s 和 p 的先后关系要注意，p 最后会为 NULL。
//创建二叉排序树 PNode CreateBiTree(int a[],int n){ int i,j,k,flag; PNode p,q,s,t; if(n&lt;=0) return NULL; t=(PNode)malloc(sizeof(Node)); t-&gt;data=a[0]; t-&gt;lchild=NULL; t-&gt;rchild=NULL; printf("%d 进树\n",a[0]); for(i=1;i&lt;n;i++) { flag = 0; p = t; while(p) { s = p;	//保存要加子节点的节点，因为 p 之后会为 NULL if(a[i] &gt; p-&gt;data) { p = p-&gt;rchild; flag = 2; } else { p = p-&gt;lchild; flag = 1; } } q=(PNode)malloc(sizeof(Node)); q-&gt;data=a[i]; q-&gt;lchild=NULL; q-&gt;rchild=NULL;	printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1c5cd27ebec7c37ba499c1ea2b968d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abaec2668dc1e24c25702b3313ef177b/" rel="bookmark">
			常见查找和排序算法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要内容： 顺序查找、折半查找-------查找算法
冒泡排序、简单选择排序、直接插入排序、希尔排序、归并排序、快速排序、堆排序------排序算法
一、查找 1、顺序查找
从最后一个记录开始，逐个进行比较，若相等则查找成功，否则查找失败。
//顺序查找 a[1 - len] int Sq_Search(int a[],int key,int len) { int i; //哨兵，使内循环不用判断数组是否越界，提高程序运行效率，减少查找时间 a[0] = key;	for(i = len;a[i] != key;i--) ; return i; } 2、折半查找
在折半查找中，查找一个值相当于在一个满二叉树中查找，计算平均查找次数时可利用满二叉树性质。
//折半查找 a[0 - len-1] int Bi_Search(int a[],int key,int len) { int i,low,mid,high; low=0;high=len-1; while(low&lt;=high) { mid = (low+high)/2; if(a[mid] == key) return mid; else if(a[mid] &gt; key) high = mid-1; else low = mid +1; } return -1;	//查找失败返回-1 } 二、排序（升序） 1、冒泡排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abaec2668dc1e24c25702b3313ef177b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2031d44087d826382f6c0555a41b6a4/" rel="bookmark">
			python pandas.DataFrame.loc函数使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方函数
DataFrame.loc
Access a group of rows and columns by label(s) or a boolean array.
.loc[] is primarily label based, but may also be used with a boolean array.
# 可以使用label值，但是也可以使用布尔值
Allowed inputs are: # 可以接受单个的label，多个label的列表，多个label的切片A single label, e.g. 5 or ‘a", (note that 5 is interpreted as a label of the index, and never as an integer position along the index). #这里的5不是数值指定的位置，而是label值A list or array of labels, e.g. [‘a"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2031d44087d826382f6c0555a41b6a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0eaf347b83e40ed31cb30856107d619/" rel="bookmark">
			java必须会js么_JavaScript和Java之间有什么关系？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：JavaScript和Java之间有什么关系？
今天是刘小爱自学Java的第79天。
感谢你的观看，谢谢你。
话不多说，开始今天的学习：
一、JavaScript概述
JavaScrip和Java到底有什么关系呢？
令我无比惊讶的是，就本质而言它们竟然半毛钱关系都没有。
简直不敢相信，那你们为何长的那么像？
就历史来源来说它们还是有一定的渊源的，事实上JavaScript早期叫LiveScript。
那个时候Java就已经是炙手可热的状态了，所以LiveScript就被改名成Javascript。
说白了这不就是现在典型的蹭热点么？
很多Java程序员想学门脚本语言，一看它怎么和Java这么像，很有亲切感，那干脆就学它了。
JavaScrip蹭了Java的热点，从而对其发展有了很大的帮助，当然其语言本身也很优秀，慢慢地也得到了大众的认可。
编程语言排行榜中也一直都是名列前茅的存在，提到前端JavaSrcipt也是一个绕不开的坎。
前几天学了HTML，如果说：
HTML的作用主要是创建网页的结构。
CSS的作用主要是美化页面。
那么JavaScript的作用主要是与用户进行交互。
JavaScript和Java又有什么区别？
Java是一门编译性语言，运行前会产生字节码文件。
JavaScript是一门解释性语言，不会生成中间文件。
Java需要有Jvm虚拟机才能运行。
JavaScript基本上只要有浏览器就可以运行。
但是js和Java的注释格式又是一模一样的，接下来我们就仔细学习下js的语法。
二、JavaScript语法
1JavaScript的引入
其引入方式和CSS很相似，CSS是style标签，而js是script标签。
①内部引入
直接在HTML文件中编写js代码，其代表标签为script标签。
在标签内编写对应的js语法即可。
其中一个HTML文件里可以存在多个script标签。
②外部引入
在外部创建一个专门的js文件，JavaScript代码都写在里面。
需要时就在HTML文件中使用script标签中的src属性引入即可。
src：即需要导入的外部js文件地址，一旦导入了js文件，此标签体中的js代码就失效了。
type： 指定脚本的类型，固定写法：text/javaScript
其中script标签可以放在HTML文件中的任意位置，但一般都会放在head标签中。
2JavaScript规范
js的加载顺序是从上至下的。
①关于分号的编写
js中每一句后面的分号是可以省略的，但是为了规范一般都不会省略，就和Java中一样。
因为如果一行中有几句的话，不用分号编译会报错。
省略分号的前提必须是一句占用一行。
②关于语法报错
js中的语法报错了照样还能执行，这和Java不一样，Java编译期间报错是没法运行的。
并且更有趣的是，
也就是说第一个
这也行？
3JavaScript变量
js的变数据类型是弱类型。什么叫弱类型呢？
就是有类型，但是不强调类型，具体用代码来说明五大原始数据类型：
js中的变量特有意思，定义都是用var关键字来修饰的，var也就是variate(变量)的缩写。
并且var关键字不是必须的，可以省略，但为了规范又不建议省略。
但是它又是有类型的，typeof(变量名)可以判断指定变量的数据类型。
①number类型
变量a，将其定义为100，本身没有说明它是什么类型，但是其类型就是number类型。
如果是在Java中，需要这样定义：number a=100；
但在js中，只需要记住一个var关键字就好了。
并且更厉害的是，变量a可以不停地变化数据类型，这在Java中简直是不可想象的。
②boolean类型
在①中a还是number类型，在②中又能重新将其定义成boolean类型。
③string类型
其string类型包含了字符串和字符。
字符串之间运算也是互相拼接，这和Java中倒是一样。
④null类型
null类型就是一个object类型，object类型没有赋值就是一个空型。
⑤undefined类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0eaf347b83e40ed31cb30856107d619/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8b2a551a1604acfd674e1875544db9/" rel="bookmark">
			java 引用被回收_Java 中的四种引用及垃圾回收策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中有四种引用：强引用、软引用、弱引用、虚引用；
其主要区别在于垃圾回收时是否进行回收：
1.强引用
使用最普遍的引用。如果一个对象具有强引用，那就 类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
2.软引用(SoftReference)
如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
软引用可以和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
3.弱引用(WeakReference)
如果一个对象只具有弱引用，那就类似于可有可物的生活用品。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
4、虚引用
又称为幽灵引用或幻影引用，，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。
测试代码：
packagecom.pt;importjava.lang.ref.SoftReference;importjava.lang.ref.WeakReference;importorg.junit.Test;public classRefTest {
@Testpublic voidtestStrongRef() {
User user= new User("pan");
User strongRef=user;
user= null;
System.gc();try{
Thread.sleep(1000);
}catch(Exception e) {//TODO: handle exception
}
System.out.println("Strong: " +strongRef.getUserName());//------测试发现，String不会被回收------//{//String str = "hello";//String strongRef = str;//强引用//str = null;//System.gc();//垃圾回收//try {//Thread.sleep(1000);//} catch (Exception e) {// //TODO: handle exception//}//System.out.println("Strong: " + strongRef);//}
}
@Testpublic voidtestWeakRef(){
User user= new User("pan");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae8b2a551a1604acfd674e1875544db9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df454681f438c1edb33d5ed3a38837de/" rel="bookmark">
			python矩阵运算库效率_python - 布尔矩阵运算的最快方法_performance_酷徒编程知识库...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需在compute中进行一些小的更改：def compute(m, n):
m = np.asarray(m)
n = np.asarray(n)
# Apply mask N in advance
m2 = m &amp; n
# Pack booleans into uint8 for more efficient bitwise operations
# Also transpose for better caching (maybe?)
mb = np.packbits(m2.T, axis=1)
# Table with number of ones in each uint8
num_bits = (np.arange(256)[:, np.newaxis] &amp; (1 &lt;&lt; np.arange(8))).astype(bool).sum(1)
# Allocate output array
out = np.zeros((m2.shape[1], m2.shape[1]), np.int32)
# Do the counting with Numba
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df454681f438c1edb33d5ed3a38837de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f652c6cf428a502048f2f49d0d06e84d/" rel="bookmark">
			我的西皮优学习笔记（五）-＞二进制及其表示法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进制的运算 1、十进制的对比分析 在十进制的数字中，每一列的权都是前一列的10倍，从右到左，每一列的权分别是1，10，100，1000…
看到十进制数的时候会发现其右下角有一个小小的10，这个小小的数称为十进制的c基,也就是说十进制的基是10
例：比如说：2345这个数是个十进制数
我们的一般就是个直接理解2345，这种思想是我们的常识思想，其实它真正的数字意义是在我们学习数字的时候刚开始的思维方式，
两个一千，三个一百，四个10，五个1，拿过来作为机器思想的描述就是：
每一位上的数字乘上他们对应位的权，再将结果加起来得到最终的数值
2、二进制 每一位上的数字只有0和1两个值，最后将多位合并起来就组成了一个二进制数
二进制的基是2
每一列的权从右到左分别是：1，2，4，8，16…，以此类推，也就是说个位的权是20,十位21…等等，同样通过机器的思想去理解
二进制就是：每一位上的数字(0/1)去乘上对应位的权（2的几次方）
1）二进制转换为十进制 个位权对应十进制：1
十位权对应十进制：2
百位权对应十进制：4
千位权对应十进制：8
…
例：1011
描述过来就是：1 * 1+1 * 2+0 * 4 + 1 * 8
通过二进制权对应的十进制的数来实现二进制到十进制的转化
2）十进制转二进制 比如说：给定十进制数84需要转换为二进制数
那么84中含的二进制的最大权就是64
所以64这一位上的数是1
然后 通过 84+64 = 20
64的下一位上的权是32，但是20&lt;32，所以32这一位上的数就是0
32的下一位上的权是16，同时20&gt;16，所以16这一位上的数就是1
以此类推
得到的 84》》》1010100
3、半字节，字节和字 对于二进制 8位一组称为字节，它能表示2^8 = 256 个数字，计算机中存储数据习惯于用字节作为单位，而不是用位作为单位。
4位的一组或者说半个字节称为半字节，能表示 2^4 = 16个数字（也就是一个十六进制数占用一个半字节），不常用，1024个字节称为1千字节（kilobyte ，KB），1024比特称为1千比特（kilobit，Kb或者Kbit），相似的MB，Mb称为兆字节，和兆比特，GB和Gb称为吉字节和吉比特。内存的容量一般用字节作为单位，但是信息传输率一般用比特/秒，作为单位。
对于微处理器来说，处理的一块数据称为字，字的大小取决于微处理器的结构。64位的处理器表示对64位的字进行操作，32位的处理器
对于32位的字进行处理。比较简单的微处理器也有8位或者16位字的
**最低有效位：**在一组位中，权为1的那位称其为最低有效位（lsb）
**最高有效位：**这组的位的另一端称为最高有效位（msb）
对于一个字来说可以通过十六进制来表示，这样就可以通过最低有效字节和最高有效字节来表示：
比如说：DEAFDAD8
最低有效字节是D8
最高有效字节是DE
4、二进制的溢出： 进行十进制的加法运算的时候经常会发生一个情况就是进位，比如说两个千位极的数相加就有可能生成一个万位级的数，但是正常在进行十进制的加法的时候并不会对这个有什么疑惑，因为十进制的数字加法一般是数字长度可变的，但是对于二进制的加法来说并不一样，一般在操作二进制数的时候都是操作的定长的数字。
比如说在两个四位的二进制数相加的时候，就有可能会产生一个五位的二进制数，但是用于接收这个结果的还是四位的长度，那么此时就会产生溢出（overflow），这个时候会将生成的第五位抛弃。从而产生了一个不正确的结果。
5、有符号的二进制数 二进制用于表示数当然是可以表示正负的，之前我们一直在考虑的是表示正数的无符号数（unsigned），那么就存在可以同时表示正数和复数的有符号数（signed），而用于表示有符号的二进制数的表示方法常用的有两种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f652c6cf428a502048f2f49d0d06e84d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d997cbc647f6b92781fea7c9a267468/" rel="bookmark">
			PIL生成图像验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		验证码图像生成的原理是这样的：随机地生成若干个字符，并绘制到图像中，然后对图像的背景或前景进行识别难度的处理，处理措施包括：
（1）随机绘制不同颜色的背景点；（
2）使用随机色绘制字符；
（3）在图像中绘制随机的线段；
（4）对图片进行变形、模糊等处理。
（5）显示花、球等实物图像让操作者识别，以增加提交的难度。
#PIL生成图像验证码 from PIL import Image,ImageDraw,ImageFont from numpy.random import randint,random def rndChar(): #产生随机字符 s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%&amp;*" return s[randint(0,len(s))] def rndColor():#生成随机颜色 return tuple(randint(64,256,3)) w=50*6;h=60 #设置图像的宽度和高度 a=Image.new('RGB',(w,h),(255,255,255)) #创建新图像（颜色模式，尺寸，颜色数值） font=ImageFont.truetype("C:\\Windows\\Fonts\\simsunb.ttf",48) b=ImageDraw.Draw(a) #创建Draw对象 def createLines(n): #绘制干扰线 for i in range(n): begin=(randint(0,w),randint(0,h)) #起始点 end=(randint(0,w),randint(0,h)) #结束点 b.line([begin,end],fill=rndColor(),width=2) def createPoints(rate): #绘制干扰点 for x in range(w): for y in range(h): if random(1)&lt;=rate: b.point((x,y),fill=rndColor()) def drawStr(): #绘制字符 Str='' for t in range(6): Chr=rndChar() Str=Str+Chr b.text((50*t+10,5),Chr,font=font,fill=rndColor()) print(Str) createLines(6) createPoints(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d997cbc647f6b92781fea7c9a267468/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5c9e469d3a065cf35c77d17b2dacd8d/" rel="bookmark">
			凑微分公式_高等数学–求积分的一些方法（IV 凑微分法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨咯各位朋友！鸽了太久，还记得我咩？
首先说声抱歉，因为学业繁忙，所以就没再写下去了.(毕竟我对我的学业还是比较认真的，不管是主修还是选修(´ . .̫ . `))
emmmmmm扯远了，还是进入正题
引入
我们先来回顾一下，求
可能大家的反应是：换元！
没错，这道题用换元法的确可以很快做出来。
但是，还有其他的解法，即凑微分法：(为了方便理解，我引入了中间量t，实际解题过程中我们没有必要引入这个量)
好的我们来解读上面的过程：
首先我们凑了微分，关注这个dx是如何变成d(2x)的
在前面学导数的时候，我们知道导数可以用d[f(x)]/dx表示，即
所以有d(2x)=2 dx，即dx=d(2x)/2
于是代入，就有
接下来就是很简单的解积分了。
(其实凑微分法本质还是换元)
提升
我们不可能停留在上面的例题，那道题太简单了
例1.求
过程如下：
解析：
首先我们要关注x∧4+1，因为它的导数就是4x∧3
因此就有
于是dx=d(x∧4+1)/4x∧3，代入就转换成解幂函数的积分问题了
例2.求
看起来有些复杂，其实方法还是一样的：
来看以上的过程，关注2-5x
对它求导 即d(2-5x)=-5 dx
也就是dx=-d(2-5x)/5，代入就转换为解幂函数的问题
是不是很简单？下面的例题就有难度了。
例3.求
首先看到这个积分，你会怎么凑微分?是把-x∧2+x+1看做一个整体然后求导?好像不行吧......
我是这么解的：
是不是很懵逼？没事，且听我分解。
首先我把这个被积函数进行恒等变换，在这里也就是将分母配方了(配方法是初中学的，所以这里不再细讲如何配方)
我们神奇的发现，这个x–1/2貌似求导后为1，也就是
所以就把这个积分变成了
问题又来了，这个积分又怎么解啊？
接下来我们要利用三角换元法来求解这个积分(这个方法我会在下一节讲解)
我们先建立一个三角形△
根据分母，可以得到根据分母的形式以及勾股定理，可以设出这样的三角形
因此就有
把这个x–1/2代入到被积函数，就有
又因为
代入，得
又因为
所以
即
OK.
最后祝大家新年快乐哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4e36c987b8e86a69bf5e30561f3ab8/" rel="bookmark">
			使用Jlink-RTT和Scope调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 使用Jlink-RTT 单片机开发过程中，除了debug调试之外，还可以使用调试工具-RTT来代替串口进行信息的交互。
RTT是什么？ RTT（ Real Time Terminal）是SEGGER公司新出的可以在嵌入式应用中与用户进行交互的实时终端。J-Link驱动4.90之后的版本都支持RTT。RTT既可以从MCU上输出信息、也可以向应用程序发送信息，由于其高速的特性，所以不影响MCU的实时性。
RTT实现原理就是J-link与MCU共享内存。操作也非常简单，安装好JLINK之后，会在JLink_V622c\Samples\RTT目录下有一个压缩包，解压之后就可以得到RTT的源码和example。如下图：
使用方法 在主函数文件的起始处添加SEGGER_RTT.h，就可以使用了。使用方法如下：
SEGGER_RTT_ConfigUpBuffer(0,NULL,NULL,0,SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL)：初始化SEGGER_RTT_WriteString(0,"字符串")：直接输出字符串SEGGER_RTT_printf（0，"字符串"，输出格式）：相当于printf，可以输出各种数据类型然后就可以使用RTTViewer或者RTTClient显示打印输出了 2. 使用Jlink-scope J-Scope是什么？ J-Scope是SEGGER公司推出的，可以在目标MCU运行时，实时分析数据并图形化显示的软件。它不需要SWO或目标上的任何额外引脚等功能，但使用可用的标准调试端口。J-Scope可以以类似示波器的方式显示多个变量的值。它读取elf或axf文件并允许选择多个变量进行可视化。只需将目标微控制器连接到J-Link并启动J-Scope。只需几个步骤即可配置J-Scope，并选择要显示的符号。配置可以存储在项目文件中，以便于重复使用和移植。在J-Scope中选择的每个符号都可以单独配置。上下移动图形以更改零基线或更改其分辨率。选择是在图表中显示符号还是仅在监视面板中显示其值。分析收集的数据，滚动可视化图形，放大和缩小或将数据保存到文件中以供进一步分析。J-Scope可以与调试环境并行使用，并扩展IDE的调试体验。J-Scope是Jlink的一个强大的功能，可以在MCU运行时，实时查看全局变量的值，并以图形化显示，就像示波器一样。它是通过SWD接口或者JTAG接口，读取axf文件来选择要显示的变量。
软件准备 要使用J-Scope功能，除了一个JLink V9外，还需要安装J-Flash和J-Scope软件:
JLink_Windows_V614b.exeSetup_JScope_V611m.exe 使用方法 1. 编写测试代码 while (1) { delay_1000us(); icnt += 2; delay_1000us(); icnt -= 2; } 2. J-Scope软件的配置 3. 选择要观察的变量，如下图： 4. 点击红色按钮开始运行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d8e703bcdc30de20ba1696b5cd086ec/" rel="bookmark">
			mysql批量删除表操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 今天在做项目自测的时候需要将80张表删掉，建表的语句有现成的，删表语句虽然简单，但删除80张表还是挺费劲的，今天就使用了一个操作，可以先获取删表语句，然后在运行这些sql语句就可以完成批量删除操作
执行步骤 从元数据表里获取表名拼接删表语句： Select CONCAT( 'drop table ', table_name, ‘;’ ) FROM information_schema.tables Where table_name LIKE ‘app_tchcont_%’;
将sql语句复制到文本编辑器中奖无用字符替换掉执行只写sql语句就可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704e0e59f726ac05fc04cb7b9e42dda6/" rel="bookmark">
			爱的魔力转圈圈-流水灯电路原理详解-PCB系列教程4-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为第二个案例，流水灯电路，比贴片元件焊接练习板稍微复杂一点。它的主要功能是：通过拨码开关来配置哪个灯亮，电路可以自动或手动产生周期脉冲，调整灯“流水”的速度。它的效果如下。
设计原理图，当然需要知道它的原理了。
供电电路 电路采用type-C接口，5V供电，也可以使用其它5V直流电源，通过测试点T1与T2供电。SW1是电源总开关，F1是自恢复保险丝，D1是稳压管（又称齐纳二极管），稳定电压是5.1V。R1与LED1构成电源指示电路。
F1与D1构成了经典的防反接电路，如果电源正负极接反，或者输入电源电压过大，会烧坏保险丝，保护后续电路。下图是简化的电路。
当正负极接反时，稳压二极管D导通，导通电压不到1V，不会烧坏后面的电路；导通电流非常大，瞬间把保险丝F熔断，电源断开。
即便正负极没有接反，如果输入电压太高，超过稳压二极管的稳定电压，导致稳压二极管反向击穿，同样会把保险丝熔断，保护后续的电路。
C1到C6，按照功能，被称为去耦电容。电容相当于蓄水池，避免由于电流的突变而使电压下降。有时会与去耦电容就近并联小容值的旁路电容，去除高频噪声。
虽然原理图中，这几个电容放在一起，但是布局时，这几个电容要分散开，各自靠近芯片的电源入口。
非对称式多谐振荡器 流水灯电路将以一定的速度来“流水”，必然需要周期变化的脉冲信号作为系统的“心跳”。流水灯电路中使用反相器产生多谐振荡器。它的原理以前的文章有提到，这里放个视频回顾一下：
产生脉冲的环节中，限流电阻设置为阻值可调的电位器，可以大幅度改变脉冲的频率。按键K2可以产生手动的脉冲，拨动开关SW2可以选择是自动产生脉冲或手动产生脉冲。LED2可以作为产生脉冲的指示灯，每个脉冲周期内LED2都会闪烁一次。74HC14的C部分用于提升脉冲的带负载能力，因为B部分的输出端既要为电容充电，又要为LED2供电，可能会影响脉冲周期的稳定性。
LED配置电路 流水灯电路用拨码开关来控制某个LED亮灭，但是又不想让开关与LED一一对应，因为对应的太死，就没办法实现流水的效果。可以先用一个“并入串出”芯片，获取所有拨码开关的状态，再用一个“串入并出”的芯片，来控制多个LED。
74HC165是一个8位串行或并行输入，串行输出的移位寄存器。74HC165具有一个串行输入（SI引脚），8个并行数据输入（A-H）和两个互补串行输出的功能。当S/L引脚为低时，A-H端的数据进入移位寄存器。当S/L引脚为高时，数据从DS引脚串行进入寄存器。当使能时钟时，数据在时钟CP上升时按位输出。74HC165的“并入串出”，是指数据一下子全部进入（并行进入）寄存器，然后一位一位的输出。
引脚
名称
别名
功能
说明
1
S/L
___
PL
并行/串行输入选择
为低时，并行数据进入移位寄存器；
为高时，串行数据进入移位寄存器。
2
CLK
CP
时钟输入
上升沿有效
3-6，11-14
A-H
D0-D7
并行数据输入
7
___
QH
___
Q7
末级互补输出
与末级串行输出极性相反
9
QH
Q7
末级串行输出
上升沿时，把移位寄存器的数据按位从此引脚输出。
10
SI
DS
数据串行输入
数据在此引脚上一位一位输入。
15
CLKINH
___
CE
输入时钟使能
低电平有效
8
16
GND,VCC
地，电源
供电引脚。
它的常见用法为在PL为低电平的时候，装载并行数据。然后时钟使能，在时钟输入上升沿的时候，把移位寄存器从高位开始，按位移出。串行输入可以接上一级的串行输出，实现级联，或者接自身的串行输出，形成循环。
74HC165的1引脚接按键，默认情况下为高电平，装载串行数据；按下时变为低电平，装载并行数据，也就是读取拨码开关的状态，因此这个按键的功能就是“更新设定”。由于串行输入的数据也是自身串行输出的数据，所以默认状态下，按照之前显示的内容周期循环；如果按下了按键，会根据当前拨码开关配置的状态，更新下一个周期的状态。拨码开关默认为低电平，拨动后变为高电平。拨码开关的8个下拉电阻阻值完全一样，故可以使用排阻，简化设计。
LED驱动电路 74HC164芯片与74HC165相对应，是“串入并出”的芯片。它有两个串行数据输入(A和B)， 8个并行数据输出(QA到QH)。数据在时钟输入上升沿时移位输出。复位引脚低电平可以清除寄存器，并且强制输出为低。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704e0e59f726ac05fc04cb7b9e42dda6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b415109b589e5a213ae45004495a946/" rel="bookmark">
			识别波峰波谷算法_马丁普林格：趋势交易波峰波谷演进法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝字
关注我们
我们有很多方法来识别趋势，计算机可以轻易地帮助我们实现各种复杂的想法。而在技术允许的条件下，我们还总是有把事物复杂化的倾向。事实也的确如此，目前市面上有无数复杂的方法、指标和程式化黑箱。但很显然，这些复杂的东西除了把事情变得更复杂以外，似乎不会对交易盈利有任何帮助，反而让我们忽略了原本简单原始的交易技术——波峰-波谷演进法(Peak-and-Trough Progression)就是其中之一。 波峰-波谷演进法的本源来自于道氏理论中对价格趋势的定义，但马丁·普林格在其名著《技术分析》一书中，专门对波峰-波谷演进法进行了深入全面的阐述，并将该方法认定为最基本的趋势识别方法。
加之《技术分析》一书非常畅销，从而让更多交易者回归本源，重新用道氏理论的视角来简单地理解趋势，从而进一步扩大了该方法的影响力。
笔者非常喜欢波峰-波谷演进法，并且本人一直也在使用此方法来分析市场。
波峰-波谷演进的基本原则
上升趋势必须对应更高的波峰和更高的波谷，下跌趋势则必须对应更低的波峰和更低的波谷——这就是该方法的核心原则。
图1无比清晰地展示了波峰-波谷演进技术。
在近期的德国DAX30日线图中，市场首先呈现出一波完美的下跌趋势。在这波下跌趋势中，出现了一系列逐渐走低的波峰和波谷。
而随后价格反弹，先前波峰-波谷不断走低的模式被打破，出现了波峰-波谷逐渐抬高的上升趋势。
根据波峰-波谷演进法，目前德国DAX30日线图中的上升趋势依然成立，因为波峰-波谷逐渐升高的走势未被打破。
如果波峰-波谷的演进符合趋势结构，那我们就应当按照趋势的方向进行交易；只有当波峰-波谷的演进遭到破坏时，我们才能考虑逆势操作。
同时，价格的波峰和波谷常常构成重要的支撑位和阻力位。如果能将波峰-波谷演进法与支撑/阻力的技巧结合使用，将会对交易决策起到更好的指导作用。
为了避免识别波峰波谷时的主观性，这里为大家引入一个辅助指标：Zigzag。
该指标主要通过价格的波动幅度和回撤比例来自动判断波峰和波谷。只要选择适当的参数，该指标就能发挥很好的作用。
目前大多数交易软件中均内置了Zigzag指标，只是算法和规则有些差异，但使用效果大致相同。
波峰-波谷演进法仅是一种趋势识别技术，它并不能指示我们进出场的时机。对于交易时机的选择，我们还需要额外引入其他方法。比如123，2B法则。
笔者认为，波峰-波谷演进技术的重点在于领会道氏理论趋势的精髓，让我们不要盲目地逆势，白白亏钱。同时，波峰-波谷演进法可以作为搭建更为完善顺势交易方法的底层基础。
编辑｜澄良
审核｜马修
公众号｜马修笔记
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13133c6bde90189b9297ff3bc6fd637c/" rel="bookmark">
			【招聘】欢迎热衷于微服务框架、中间件、云原生方向的同志！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OPPO基础技术部，支撑OPPO移动互联网业务，海量用户和数据，等你来！
希望能招募到热衷于高并发、高可用、高性能，面向云原生技术架构的同志！
有意向的同志，欢迎发简历到aitangyong@oppo.com！
岗位名称：
数据库中间件工程师
工作内容：
1、负责数据库网格产品的架构设计和系统研发，不断优化产品的性能、扩展性和可用性
2、指导并协助公司多业务线使用数据库网格产品，降低业务线的开发运维成本
3、践行开源社区理念和价值观，逐步推广和运营数据库网格产品
任职要求：
1、扎实的计算机和编程基础，熟练使用Java/Go/Rust至少一种编程语言及其生态圈
2、3年以上工作经验，有大规模分布式系统的研发经验，熟悉微服务基础框架和中间件
3、有强烈的技术热情，良好的自我驱动能力和责任心，良好的团队合作精神和沟通技能
4、了解云原生生态，有Kubernetes/Docker/ServicMesh等云原生技术者优先
5、有开源社区贡献者优先，熟悉Apache ShardingSphere者优先
6、擅长使用开源框架，在某个领域内对开源框架有一定的审美，做过选型研究，解读过源码，掌握实现原理者优先
岗位名称：
云原生研发工程师
岗位职责：
1、负责云原生服务框架产品设计和研发，如Web服务框架、RPC框架、服务治理框架等
2、负责云原生服务网格产品技术方案设计和实现，如控制面，数据面
3、负责服务网格产品，框架产品的接入落地，性能调优等
任职要求：
1、3年以上工作经验，1年以上高并发、高可用平台的设计开发经验
2、扎实的编程基础,，能熟练使用一种编程语言，Java/Go/Rust
3、熟悉云原生生态，包括但不局限于Kubernetes/Docker/Istio/Envoy/Linkerd等
4、学习能力强，热爱技术，有后端框架产品开发、定制优化经验
5、有开源产品维护，开源社区贡献者优先
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4fbe5a7e1312a1749c3b98b80e66f51/" rel="bookmark">
			mysql批量删除多个表_mysql怎么批量删除多个表？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql批量删除多个表
使用 DROP TABLE 语句可以删除一个或多个数据表，语法格式如下：
DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...]
对语法格式的说明如下：
表名1, 表名2, 表名3 ...表示要被删除的数据表的名称。DROP TABLE 可以同时删除多个表，只要将表名依次写在后面，相互之间用逗号隔开即可。
IF EXISTS 用于在删除数据表之前判断该表是否存在。如果不加 IF EXISTS，当数据表不存在时 MySQL 将提示错误，中断 SQL 语句的执行；加上 IF EXISTS 后，当数据表不存在时 SQL 语句可以顺利执行，但是会发出警告(warning)。
两点注意：
用户必须拥有执行 DROP TABLE 命令的权限，否则数据表不会被删除。
表被删除时，用户在该表上的权限不会自动删除。
实例：
查询数据库中的数据表
mysql&gt; SHOW TABLES;
+--------------------+
| Tables_in_test_db |
+--------------------+
| tb_emp1 |
| tb_emp2 |
| tb_emp3 |
+--------------------+
2 rows in set (0.00 sec)
由运行结果可以看出，数据库中有 tb_emp1、tb_emp2 和 tb_emp3 3张数据表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4fbe5a7e1312a1749c3b98b80e66f51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f7c78d715243cc84bcf4cdeae6280b/" rel="bookmark">
			Maven配置教程（下载、配置、IDEA中配置详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven配置教程（下载、配置、Idea中配置详解） 1、什么是Maven？2、Maven安装和环境变量配置3、在IDEA中配置maven 1、什么是Maven？ 首先，Maven谐音“妹文”。
当我们写一个Spring的web动态项目时我们需要用到很多第三方库，按往常的方法，我们需要导入大量的jar包，有时缺少一个jar包项目就无法运行，并且大量jar包之间的依赖关系复杂，所以在平常的项目开发过程中，导入jar包搭建项目环境这个过程是比较耗费精力的事，而Maven就是用来解决这一问题的利器。我们只需要告诉Maven需要哪些Jar 包，它会帮助我们下载所有的Jar，极大提升开发效率。
Maven是一款服务于Java平台的自动化构建工具，是Apache的一款开源的项目管理工具。发展过程：Make→Ant→Maven→Gradle
2、Maven安装和环境变量配置 1）Maven下载官网：http://maven.apache.org/download.cgi
2）下载后解压到无中文的路径下：
3）（环境变量配置跟jdk配置方法一样，maven安装之前应该完成jdk的安装）右击 “我的电脑” → “属性” → “高级系统设置” → “环境变量”→ 点击下面的系统环境变量，新建变量MAVEN_HOME，变量值为解压所在路径；
接着找到系统变量Path，编辑，添加%MAVEN_HOME%\bin
4）打开cmd，通过命令mvn -version检测，出现下图结果表示配置成功；
安装成功后执行 mvn help:system 会下载各类文件。 最终输出成功则maven安装全部完成。
3、在IDEA中配置maven 其实Idea中也自带Maven插件，而且我们也可以给自带的Maven插件进行配置，所以我们可以使用自带的Maven，也可以使用我们安装的Maven核心程序。
首先，打开IDEA中的settings找到如下位置：
1）Idea中默认集成了Maven：
2）我们也可以用上面自己安装的3.6.3版本的：
其中，
Maven Home directory: maven的安装目录
User Settings File : 就是maven安装目录conf/setting.xml配置文件
Local Repository : 本机仓库的目录位置 （自己建的）
settings.xml是conf目录下的文件，是maven的核心配置文件/全局配置文件。这个文件里面包含仓库地址、镜像、插件、代理等配置，是maven中一个核心配置文件，我们会经常跟它打交道。
如果没有.m2目录，自己手动执行mvn命令：mvn help:system
3)接下来是本地仓库配置（IntelliJ IDEA自带的 / 自己安装的，反正都是找conf目录下的settings.xml文件）：
使用NotePad++打开文件,
①添加本地仓库存放目录配置信息：
②添加镜像仓库（如果仓库A可以提供仓库B存储的所有内容，那么就可以认为A是B的一个镜像。例如：在国内直接连接中央仓库下载依赖，由于一些特殊原因下载速度非常慢。这时，我们可以使用阿里云提供的镜像http://maven.aliyun.com/nexus/content/groups/public/来替换中央仓库http://repol.maven.org/maven2/。修改maven的setting.xml文件）
（ctrl+f搜索"mirrors"）：
③jdk的配置（当你的idea中有多个jdk的时候，就需要指定你编译和运行的jdk，在settings.xml中配置）：
这里配置的前提是你的idea中要有1.8的jdk
总结：
在核心配置文件settings.xml中：配置了三个信息：
【1】本地仓库
【2】镜像仓库
【3】JDK
在IDEA中完成上述配置即可开始Maven工程的书写。
下一篇介绍Maven的核心概念：
1）约定的目录结构
2）POM
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5f7c78d715243cc84bcf4cdeae6280b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/95/">«</a>
	<span class="pagination__item pagination__item--current">96/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/97/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>