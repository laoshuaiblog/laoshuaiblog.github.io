<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7416a216ee77758baf0b51df8e3ba9e3/" rel="bookmark">
			批量打印-----jsPDF将图片转为pdf，并合并pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装依赖并引入
import jsPDF from 'jspdf'; import { PDFDocument, } from 'pdf-lib'; 注意一、
使用jspdf将图片（jpg/jpeg/png/bmp）转pdf（记为pdfA），得到的pdf（pdfA）和需要合并的pdf(记为pdfB)类型不一致，需要将pdfA转为pdfB类型，才能合并，使用arraybuffer转，具体如下
// pdf--pdfA--是使用jspdf将图片生成的pdf // file--pdfB--是合并pdf需要的pdf格式 const jsPdfBytes = pdf.output('arraybuffer'); const file = await PDFDocument.load(jsPdfBytes); 注意二、
jspdf 可转pdf的图片类型有jpg、jpeg、png、bpm，
不支持 tif 和 tiff 图片类型
.tif和.tiff格式的文件需要通过安装依赖
“tiff.js”: “^1.0.0”,
也是使用arrayBuffer，将图片格式转为base64，（jpg/jpeg格式，然后将该格式通过jspdf转为pdf文件）
if(x.FILE_TYPE == '.tif' || x.FILE_TYPE == '.tiff' ){ const response = await fetch(imgUrl); const buffer = await response.arrayBuffer(); const Tiff = require("tiff.js"); const tiff = new Tiff({ buffer }); imgUrl = tiff.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7416a216ee77758baf0b51df8e3ba9e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe115242251db2d6c81b369b52df898/" rel="bookmark">
			【Spring Security权限框架】SpringBoot整合Spring Security实现权限控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spring Security介绍Spring Security案例1、快速搭建一个springboot工程2、导入SpringSecurity整合springboot工程3、认证3.1、登录流程校验3.2、入门案例的原理3.3、实现思路3.4、实现认证流程（自定义）3.5、正式实现3.5.1 实现数据库的校验3.5.2 密码加密存储3.5.3 自定义登陆接口实现3.5.4 自定义实现认证过滤器3.5.5 退出登录 4、授权4.1 授权基本流程4.2 授权实现（不结合数据库）4.2.1 限制访问资源所需权限4.2.2 封装权限信息 4.3 授权实现（结合数据库）4.3.1 设计数据库表4.3.2 代码实现4.3.3 测试 5、自定义访问失败处理5.1、自定义实现类5.2、配置给SpringSecurity 6、跨域问题7、扩展7.1、自定义权限校验方法7.2、基于配置的权限控制 8、 demo源码9、特别鸣谢 Spring Security介绍 要对Web资源进行保护，最好的办法莫过于Filter
要想对方法调用进行保护，最好的办法莫过于AOP。
Spring Security进行认证和鉴权的时候,就是利用的一系列的Filter来进行拦截的。
如图所示，一个请求想要访问到API就会从左到右经过蓝线框里的过滤器，其中绿色部分是负责认证的过滤器，蓝色部分是负责异常处理，橙色部分则是负责授权。进过一系列拦截最终访问到我们的API。
这里面我们只需要重点关注两个过滤器即可：
UsernamePasswordAuthenticationFilter负责登录认证，
FilterSecurityInterceptor负责权限授权。
一般Web应用的需要进行认证和授权。
​ 认证（Authentication）：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户
​ 授权（Authorization）：经过认证后判断当前用户是否有权限进行某个操作
​ 而认证和授权就是SpringSecurity作为安全框架的核心功能。
说明：Spring Security的核心逻辑全在这一套过滤器中，过滤器里会调用各种组件完成功能，掌握了这些过滤器和组件你就掌握了Spring Security！这个框架的使用方式就是对这些过滤器和组件进行扩展。
Spring Security案例 1、快速搭建一个springboot工程 此步骤省略
建议整合knif4j方便调试
访问接口文档：http://localhost:8081/doc.html（端口为自己设置的端口，默认是8080）
springboot工程搭建完成
2、导入SpringSecurity整合springboot工程 导入SpringSecurity依赖（版本跟随boot版本） &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 重新启动项目进行测试：访问路径：http://localhost:8081/ayo/hhy/1 这时我们可以看到当我们访问我们的接口的时候，就会自动跳转到一个SpringSecurity的默认登陆页面(后期是需要整合到自己系统的登录页面来做认证）
这时候需要我们登录才可以进行访问，我们可以看到控制台有一串字符串，其实那就是SpringSecurity初始化生成给我的密码
用户名默认为 ：user
密码在控制台打印出来了
输入用户和密码登录后，就可以正常访问接口了
3、认证 3.1、登录流程校验 核心是通过用户输入的用户名和密码去和数据库中的数据进行比对，如果比对无误
那么就会使用jwt工具根据用户名和密码去生成一个token传给前端存储起来
在登录过后用户想要访问别的资源都要在请求头里面携带token，后端会对前端请求的token拿到并且解析出来用户的id
根据用户的id获取相关的信息，来判断用户是否有访问资格，如果有，则访问目标资源返回给前端，若没有，则返回错误信息（无权限访问）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfe115242251db2d6c81b369b52df898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/775812eaf0435832138812db69eb7224/" rel="bookmark">
			【问题解决】uniapp-Vue3中u-popup滑动页面穿透问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp-Vue3中u-popup滑动页面穿透问题 在我们用uniapp写小程序或者APP的时候，有时候会用到一些弹出框组件
例如：
但在弹出框内部滑动会引起整个页面的滑动，让整个页面看起来不是和很好
解决方案 弹框最外层使用@touchmove.stop.prevent="preventHandler" 屏蔽触摸事件，屏蔽后如果弹框内还有列表，则列表此时无法滚动。 在下方定义事件
但是里边如果还是需要滑动的话，比如我这里吧需要有一个表情的列表，则可以使用 scroll-view,并设置scroll-y=“true”,scroll-view 不会受到@touchmove.stop.prevent=“preventHandler” 的影响。 这样整个问题就完美解决了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95dd8f6d0f6655a921de0c5dd97cc747/" rel="bookmark">
			python二进制转化模块struct
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 struct模块与C语言的类型匹配关系 struct模块 在pyton中，通过struct模块来对二进制进行转换，主要包括两大类函数，即用于打包的pack和用于解包的unpack。
其中，struct.pack的输入格式为struct.pack(format, v1, v2, ...)，其中format为格式字符串，v1,v2..为将要转成bytes的字符。
例如
&gt;&gt;&gt; import struct &gt;&gt;&gt; struct.pack('i', 15) b'\x0f\x00\x00\x00' &gt;&gt;&gt; struct.pack('iii', 15, 16, 17) b'\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00' &gt;&gt;&gt; struct.pack('b', 255) #b格式的取值范围是-128到127 struct.error: byte format requires -128 &lt;= number &lt;= 127 &gt;&gt;&gt; struct.pack('B', 200) b'\xc8' &gt;&gt;&gt; struct.pack('B', 71) #128以内可用ASCII表示 b'G' i代表int，15对应的二进制代码为F000，故其输出为b\x0f\x00\x00\x00。当格式字符串为iii时，说明要将三个数字以整数类型转化为二进制。
与C语言的类型匹配关系 格式化字符串中的每个字符都代表一种数据类型，其中整型相关的字符如下，左侧为带符号整型，右侧为无符号整型
C语言类型C语言类型标准大小bsigned charBunsigned char1hshortHunsigned short2iintIunsigned int4llongLunsigned long4qlong longQunsigned long long8nssize_tNsize_t 其他类型
格式C 类型Python 类型标准大小x填充字节无cchar长度为1的字节串?_Boolbool1efloat2ffloatfloat4ddoublefloat8schar[]字节串pchar[]字节串Pvoid*整数 struct中提供了获取标准大小的函数，calcsize:
&gt;&gt;&gt; struct.calcsize('B') 1 &gt;&gt;&gt; struct.calcsize('i') 4 除了声明被格式化时的数据类型，struct还可以指定对齐方式，例如
&gt;&gt;&gt; struct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95dd8f6d0f6655a921de0c5dd97cc747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9331b1b6a1e163bd5d49258e2ac3867a/" rel="bookmark">
			安捷伦Agilent E8257D信号发生器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是德（Keysight） E8257D 模拟信号发生器
Keysight E8257D (Agilent) PSG 模拟信号发生器提供业界领先的输出功率、电平精度和高达 67 GHz 的相位噪声性能（工作频率可达 70 GHz）。Agilent PSG 模拟信号发生器的高输出功率和卓越的电平精度通常无需外部放大器来测试高功率设备，并最大限度地减少测试不确定性，以便在设计过程的早期识别错误。世界一流的相位噪声性能（通常为 -116 dBc/Hz @ 10 GHz 载波和 10 kHz 偏移）是本地振荡器、低抖动时钟替代和相邻信道选择性测试的理想选择。在测试高级射频和微波雷达、通信和控制系统时，PSG 模拟信号发生器可提供您所需的性能。E8267D 信号发生器基于模块化微波信号发生器平台——可选择添加 AM、FM、ØM 和/或脉冲生成连续波 (CW) 信号，用于 LO 替代或扫描激励响应分析。可选择添加 AM、FM、ØM 和/或脉冲调制以准确表征射频和微波元件和设备。许多性能增强选项也可用于配置信号发生器以满足您的特定测试要求。为当今的射频和微波测试应用定制 PSG，并在未来根据您的需求变化轻松升级。
Keysight E8257D（安捷伦）的特性和规格包括：
广泛的频率范围选择（选项）- 250 kHz 至 20、31.8、40、50 或 67 GHz（工作至 70 GHz），分辨率为 0.001 Hz
高输出功率 - 典型性能为 +23 dBm @ 20 GHz、+ 17 dBm @ 40 GHz、+ 14 dBm @ 67 GHz，具有出色的电平精度
世界一流的 SSB 相位噪声 - Agilent 的超低相位噪声选项可提供最佳性能（带选项 UNX）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9331b1b6a1e163bd5d49258e2ac3867a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c0d229fef5e005b2a7b024ce0a85b1/" rel="bookmark">
			动态代理中的死循环导致的java.lang.StackOverflowError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题：循环打印直到栈溢出
二、代码：
1、接口及实现类
2、动态代理类
3、测试类
三、原因分析：
四、引申：$Proxy0其他可能出现死循环问题的代码及问题：
一、问题：循环打印直到栈溢出 ...
拒绝中间商赚差价
拒绝中间商赚差价
拒绝中间商赚差价
Exception in thread "main" java.lang.StackOverflowError
at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:77)
at sun.nio.cs.UTF_8.access$200(UTF_8.java:57)
at sun.nio.cs.UTF_8$Encoder.encodeArrayLoop(UTF_8.java:636)
at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:691)
at java.nio.charset.CharsetEncoder.encode(CharsetEncoder.java:579)
at sun.nio.cs.StreamEncoder.implWrite(StreamEncoder.java:271)
at sun.nio.cs.StreamEncoder.write(StreamEncoder.java:125)
at java.io.OutputStreamWriter.write(OutputStreamWriter.java:207)
at java.io.BufferedWriter.flushBuffer(BufferedWriter.java:129)
at java.io.PrintStream.write(PrintStream.java:526)
at java.io.PrintStream.print(PrintStream.java:669)
at java.io.PrintStream.println(PrintStream.java:806)
at designPattern.proxy.dynamic.DynamicProxyHandler.invoke(DynamicProxyHandler.java:13)
at com.sun.proxy.$Proxy0.toString(Unknown Source)
at java.lang.String.valueOf(String.java:2994)
at java.io.PrintStream.println(PrintStream.java:821)
at designPattern.proxy.dynamic.DynamicProxyHandler.invoke(DynamicProxyHandler.java:14)
at com.sun.proxy.$Proxy0.toString(Unknown Source)
at java.lang.String.valueOf(String.java:2994)
at java.io.PrintStream.println(PrintStream.java:821)
at designPattern.proxy.dynamic.DynamicProxyHandler.invoke(DynamicProxyHandler.java:14)
二、代码： 1、接口及实现类 public interface HouseRenting {
void rent(int money);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66c0d229fef5e005b2a7b024ce0a85b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34d3bd67189eb11877824197aea003c/" rel="bookmark">
			pve组网实现公网访问pve,访问电脑，访问pve中的openwrt同时经过openwrt穿透主路由地址nginx全公网访问最佳办法测试研究...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一台路由器 做主路由
工控机 装pve虚拟机 虚拟机里面装一个openwrt,
外网可以直接访问pve,可以访问pve里的openwrt
一台主机 可选择连
有4个口，分别eth0,eth1,eth2,eth3
pve有管理口 这个情况下 ，没有openwrt 直接电脑和pve管理口连在一起就能进pve管理界面
情况2 假设pve 的管理口味eth0
openwrt中桥接的是eth0 eth1 eth2
那么电脑连接eth3或者pve管理口设置eth3，那么openwrt也是无法访问eth3口的
情况3 openwrt的eth1连的主路由，外网经过主路由要访问pve口， 前提就是要eth1和eth0进行桥接，否则在eth1是无法访问eth0的。
让pve和电脑，pve中的openwrt互相ping通 管理口为eth0,eth0的网线连主路由， 电脑也连主路由或者旁路由其他口，
pve里面有一个虚拟机，是旁路由，这种情况ok.
确保pve添加4个虚拟设备
image.png 但是当电脑连的是4口的旁路由时，如果把openwrt关闭，那么桥接失去了作用，主机的eth0无法和eth其他通讯，因此此时电脑无法访问pve管理口。
当openwrt关闭(关闭桥接)也可通过电脑无线网卡连接主路由的wifi,然后再次访问发现又能通了，因此确认此时走的是从无线走的pve
openwrt情况
image.png 假如openwrt只桥接了eth0 eth1 eth2 没有桥接eth3 ，电脑连接eth3时，pve中的openwrt ping电脑本地网卡ip无法ping通
但是，当电脑网线插到eth2时，openwrt可ping通电脑
但是测试pve ping电脑ip ,eth0(pve)和eth3通讯(电脑网线,wifi未连主路由) ，正常
补充openwrt中的桥接配置，实现4口变成交换机可互相通讯，(旁路由不再是路由)
image.png 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc18057b4005fc0dadd1938408d69ff/" rel="bookmark">
			VMWare Workstation中NAT模式设置静态IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在虚拟Windows或者liunx下经常希望IP地址不定不变,而不是依靠DHCP来自动获取.看了不少文档都不是很清楚,自己摸索出来的,当做给自己的笔记.
1.打开虚拟网络编辑器设置(虚拟机开启关闭都无所谓)图一,图二.
图一
图二
2.配置虚拟网络编辑器中的类型为: NAT模式.设置为静态IP(图三)
2-1取消勾选:使用本地DHCP服务将IP地址分配给虚拟机
2-2例如我希望我的虚拟机IP段为172.20.20.1-254这个网段
那么这地方的子网IP就设置为: 172.20.20.0
(如果你想设置为192.168.10.1-254这个网段,这里就设置为192.168.10.0)
2-3子网掩码设置为255.255.255.0(两个末尾都是0)
2-4点击确定(不要做多余的操作,一定要确定,一定要确定,一定要确定)
图三
3.最关键的一部来了--我们重复步骤1,重新打开虚拟网络编辑器-选中NAT模式,点击左侧NAT设置(图四)
一定要重新打开这个界面,步骤二确定,后再重新打开.
可以看到新窗体(NAT设置)中第四行的网关IP,记下来一般为你步骤2中设置的IP末尾变成2.
例如我步骤2中设置的是172.20.20.0 那么这里会自动变成 172.20.20.2
假如你设置步骤2中的IP为 192.168.10.0 那么这里会自动变成 192.168.10.2 再次强调这个地方不需要更改,记下来就行了: 172.20.20.2
PS: 不做任何更改,不做任何更改,不做任何更改,只看一眼记住就行了.
图四
4.我们进入到Windows或者liunx里面,
配置本地IP
IP:172.20.20.3-254随便哪个IP都行,
子网掩码: 255.255.255.0
网关: 172.20.20.2(步骤三中让大家看一眼的)
DNS随便设置114.114.114.114
搞定.其实看一遍操作一遍才发现,如此简单,根本不用什么多余的步骤,一分钟不到搞定.
一定要记住步骤三,是在步骤二确定后,再返回点击看的,而不是在步骤二中直接看.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8047ed23b4735dbb1acd1cac5ae583c7/" rel="bookmark">
			Vue3的MVVM简介详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
​ MVVM旨在利用WPF中的数据绑定函数，通过从视图层中几乎删除所有GUI代码（代码隐藏），更好地促进视图层开发与模式其余部分的分离。不需要用户体验（UX）开发人员编写GUI代码，他们可以使用框架标记语言（如XAML），并创建到应用程序开发人员编写和维护的视图模型的数据绑定。角色的分离使得交互设计师可以专注于用户体验需求，而不是对业务逻辑进行编程。这样，应用程序的层次可以在多个工作流中进行开发以提高生产力。即使一个开发人员在整个代码库上工作，视图与模型的适当分离也会更加高效，因为基于最终用户反馈，用户界面通常在开发周期中经常发生变化，而且处于开发周期后期。
在Vue 3中，MVVM（Model-View-ViewModel）是一种常见的架构模式，用于将应用程序的数据模型（Model）与用户界面（View）分离，并通过ViewModel来进行交互和通信。
下面是对Vue 3中MVVM的详细解释：
Model（数据模型）：
Model代表应用程序的数据和业务逻辑。它可以是从后端API获取的数据、本地存储的数据或用户输入的数据等。在Vue中，数据模型通常是通过定义Vue实例的data选项来表示。这些数据可以是简单的变量、对象、数组等。 View（用户界面）：
View是用户直接与应用程序交互的界面。它通常由HTML模板和Vue指令组成，用于渲染数据和响应用户的操作。在Vue中，可以使用Vue的模板语法来定义视图。模板语法允许将数据绑定到HTML元素，使数据的变化能够自动更新到视图上。 ViewModel（视图模型）：
ViewModel是连接数据模型和用户界面的中间层。它负责处理数据的变化、用户输入的响应和与数据模型的交互。在Vue中，ViewModel由Vue组件扮演的角色。组件是可重用的Vue实例，它封装了特定的功能和视图，并通过props接收数据、通过methods响应事件、通过computed计算属性处理数据等。 MVVM模式的工作原理如下：
用户与View进行交互，例如输入表单、点击按钮等。View通过指令和数据绑定将用户的操作反映到ViewModel中。ViewModel接收到用户的操作后，可以对数据进行处理、验证、发送网络请求等。ViewModel将处理后的数据更新到数据模型中。数据模型的更新会触发View的重新渲染，用户界面随之更新。 Vue 3通过其响应式系统实现了MVVM模式的核心功能。它使用了Proxy对象来追踪数据的变化，并在数据发生变化时自动更新相关的视图。
总结：MVVM模式在Vue 3中提供了一种结构化的方式来组织应用程序的代码和数据。它通过将数据模型、用户界面和视图模型分离，使得应用程序更易于开发、测试和维护。Vue 3的响应式系统和组件化特性为MVVM的实现提供了强大的支持。
运行原理:
当view变化,VM监听后更改model
当model变化,VM监听后更改view
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342219160984d90f276520b69cbb56aa/" rel="bookmark">
			ts那些简单的语义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：ts保姆级教程，别再说你不会ts了 - 掘金 Typescript 类型 Typescript有哪些类型 1、Typescript 基本类型，也就是可以被直接使用的单一类型。
数字字符串布尔类型nullundefinedanyunknownvoidobject枚举never 2、复合类型，包含多个单一类型的类型。
数组类型元组类型字面量类型接口类型 3、如果一个类型不能满足要求怎么办？
可空类型，默认任何类型都可以被赋值成 null 或 undefined。联合类型，不确定类型是哪个，但能提供几种选择，如：type1 | type2。交叉类型，必须满足多个类型的组合，如：type1 &amp; type2。 类型都在哪里使用 在变量中使用 在变量中使用时，直接在变量后面加上类型即可。
let a: number; let b: string; let c: null; let d: undefined; let e: boolean; let obj: Ixxx = { a: 1, b: 2, }; let fun: Iyyy = () =&gt; {}; 在接口中使用 在接口中使用也比较简单，可以理解为组合多个单一类型。
interface IData { name: string; age: number; func: (s: string) =&gt; void; } 在函数中使用 在函数中使用类型时，主要用于处理函数参数、函数返回值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/342219160984d90f276520b69cbb56aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c888778320d1145efc5780fa4bbc11e9/" rel="bookmark">
			Java学习篇59-Redis-常用指令与Jedis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果对您有一丁点的帮助，劳烦动动手指点个赞，您的支持和鼓励是搬砖人不断创作的动力！
3. 常用指令 在这部分中呢，我们家学习两个知识，第一个是key的常用指令，第二个是数据库的常用指令。和前面我们学数据类型做一下区分，前面你学的那些指令呢，都是针对某一个数据类型操作的，现在学的都是对所有的操作的，来看一下，我们在学习Key的操作的时候，我们先想一下的操作我们应该学哪些东西:
3.1 key 操作分析 3.1.1 key应该设计哪些操作？ key是一个字符串，通过key获取redis中保存的数据
对于key自身状态的相关操作，例如：删除，判定存在，获取类型等
对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等
对于key快速查询操作，例如：按指定策略查询key
3.1.2 key 基本操作 删除指定key
del key 获取key是否存在
exists key 获取key的类型
type key 3.1.3 拓展操作
排序
sort 改名
rename key newkey renamenx key newkey 3.1.3 key 扩展操作（时效性控制） 为指定key设置有效期
expire key seconds pexpire key milliseconds expireat key timestamp pexpireat key milliseconds-timestamp 获取key的有效时间
ttl key pttl key 切换key从时效性转换为永久性
persist key 3.1.4 key 扩展操作（查询模式） 查询key
keys pattern 查询模式规则
*匹配任意数量的任意符号 ? 配合一个任意符号 [] 匹配一个指定符号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c888778320d1145efc5780fa4bbc11e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c20ecf56b7f7159d9ed4b6031b9603/" rel="bookmark">
			【PyTorch】nn.Conv2d函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nn.Conv2d 是 PyTorch 中的一个卷积层，用于实现二维卷积操作
torch.nn.Conv2d( in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros', device=None, dtype=None ) 参数解释 in_channels：输入的通道数，RGB 图像的输入通道数为 3
out_channels：输出的通道数
kernel_size：卷积核的大小，一般我们会使用 5x5、3x3 这种左右两个数相同的卷积核，因此这种情况只需要写 kernel_size = 5这样的就行了。如果左右两个数不同，比如3x5的卷积核，那么写作kernel_size = (3, 5)，注意需要写一个 tuple，而不能写一个 list。
stride = 1：卷积核在图像窗口上每次平移的间隔，即所谓的步长。
padding：指图像填充，后面的int型常数代表填充的多少（行数、列数），默认为0。需要注意的是这里的填充包括图像的上下左右，以padding=1为例，若原始图像大小为[32, 32]，那么padding后的图像大小就变成了[34, 34]
dilation：是否采用空洞卷积，默认为1（不采用）。从中文上来讲，这个参数的意义从卷积核上的一个参数到另一个参数需要走过的距离，那当然默认是1了，毕竟不可能两个不同的参数占同一个地方吧（为0）。更形象和直观的图示可以观察Github上的Dilated convolution animations，展示了dilation=2的情况。
groups：决定了是否采用分组卷积，groups参数可以参考groups参数详解
bias：即是否要添加偏置参数作为可学习参数的一个，默认为True。
padding_mode：即padding的模式，默认采用零填充。
nn.Conv2d 的使用方法一般如下： import torch.nn as nn
# 定义卷积层 conv = nn.Conv2d(in_channels=3, out_channels=32, kernel_size=3, stride=1, padding=1) # 输入数据 x = torch.randn(1, 3, 224, 224) # 前向计算 out = conv(x) 这里我们定义了一个输入通道数为 3，输出通道数为 32，卷积核大小为 3x3，步长为 1，边界填充数为 1 的卷积层。然后，我们定义了一个大小为 (1, 3, 224, 224) 的输入数据 x，执行前向计算得到输出 out。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1c20ecf56b7f7159d9ed4b6031b9603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3684cbbebce33462152b9a6b008dda96/" rel="bookmark">
			GATK4实用技巧丨如何正确设置线程数和内存大小？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GATK4 实用技巧 前言 本篇笔记围绕GATK4流程中注意事项进行介绍，包括如何选择合适的线程和内存？如何按步骤进行数据预处理。
GATK实战工作流程 脚本优化方法 参数设置技巧 GATK 全称“基因组分析工具箱” Genome Analysis Toolkit,它是一组命令行工具，用于分析高通量测序数据，主要侧重于变异发现。这些工具可以单独使用，也可以链接在一起形成完整的工作流程。
所需数据与软件 需要有简单的Linux知识储备和高通量基因组学基础，流程中用到的软件如下：
GATK 4.3.0.0
fastp 0.20.1
bwa 0.7.17
samtools 1.11
mosdepth 0.3.0
示例数据来自ERP001960项目，数据结构为illumina测序原始数据，包含三个样本，如果想重复测试需要大概700GB空间。 数据预处理 预处理的步骤包括质控、去接头、排序等，需要用到FATSP等工具，为了提高效率建议直接用fastp标准输出到BAM文件，避免不必要的磁盘读写，用管道串联起来能提高工作效率。
无论是否进行排序，都不要直接将未压缩的sam文件写入磁盘！最好用管道直接把两步合为一起生成排序去重之后的bam文件
fastp去除接头 使用fastp程序进行操作，为了提高数据吞吐效率，将默认输出信息定向到/dev/null中，避免磁盘读写。
fastp -i /lscratch/${SLURM_JOB_ID}/$(basename $r1) \
-I /lscratch/${SLURM_JOB_ID}/$(basename $r2) \
--stdout --thread $threads \
-j "${logs}/fastp-${SLURM_JOB_ID}.json" \
-h "${logs}/fastp-${SLURM_JOB_ID}.html" \
&gt; /dev/null
下图展示了不同线程与处理速度的关系，很显然啊！这里如果超过6个线程就没多大意义了，设置6个线程就能达到最佳计算效率。 bwa mem 序列比对 比对过程实际上是拿着参考基因组，然后把每个小片段进行对齐，举个比较抽象的例子，就好比是拼图的过程，目的是让每一个小碎片都找到匹配的位置。
使用bwa mem程序进行比对，注意这里每个样品需要两条序列（因为二代双端测序两个方向是一对儿）。
bwa mem -M -t ${threads} \
-R "@RG\tID:$id\tPL:ILLUMINA\tLB:$lb\tSM:$sm" \
$genome \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3684cbbebce33462152b9a6b008dda96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5231eea327ad77ead1ffee6bc1ac22a9/" rel="bookmark">
			Docker安装DolphinScheduler - mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认已安装Docker和Docker-compose环境
本案例安装海豚调度3.1.0 并将PostgreSQL 替换为mysql
这是官网docker部署教程：https://dolphinscheduler.apache.org/zh-cn/docs/3.1.0/guide/start/docker
但是官网教程里并没有表名基于docker的情况下如何将数据库替换为mysql
一、资源下载 源码下载：https://archive.apache.org/dist/dolphinscheduler/3.1.0/apache-dolphinscheduler-3.1.0-src.tar.gz mysql驱动下载：https://repo1.maven.org/maven2/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar 二、安装 解压后有很多文件夹，其实这些都是些源码。可以不用管，也可以删除
tar -zxf apache-dolphinscheduler-3.1.0-src.tar.gz cd apache-dolphinscheduler-3.1.0-src/deploy/docker ls -a 里面只有两个文件是我们需要用到的，.env文件是所有镜像需要用到的环境变量，平时是隐藏的 docker-compose.yml .env 打开docker-compose.yml文件将里面的PostgreSQL 删除加入mysql启动命令
同时将下载好的mysql镜像放到和docker-compose.yml同级目录
一下是我调整后完整的docker-compose.yml文件：
# Licensed to the Apache Software Foundation (ASF) under one # or more contributor license agreements. See the NOTICE file # distributed with this work for additional information # regarding copyright ownership. The ASF licenses this file # to you under the Apache License, Version 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5231eea327ad77ead1ffee6bc1ac22a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b7f2e5305acf3b04e10f9a864b70f2/" rel="bookmark">
			use strict 是什么意思？使用它区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 use strict 是什么意思？使用它区别是什么？ use strict 代表开启严格模式，这种模式下使得 JavaScript 在更严格的条件下运行，实行更严格解析和错误处理。
开启“严格模式”的优点：
消除 JavaScript 语法的一些不合理，不严谨之处，减少一些怪异行为；消除代码运行的一些不安全之处，保证代码运行的安全；提高编译器效率，增加运行速度为未来新版本的 Javascript 做好铺垫。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb07f1ec70da2734198fd20da0a5ca7/" rel="bookmark">
			【物联网】详解STM32的GPIO八种输入输出模式，GPIO各种输入输出的区别、初始化的步骤详解，看这文章就行了（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在STM32微控制器中，常见的输入输出(GPIO)模式有八种，分别是推挽输出、开漏输出、复用推挽输出、复用开漏输出、浮空输入、上拉输入、下拉输入和模拟输入。下面我将为你解释每种模式的特点和区别，并提供相应的示例代码。
文章目录 介绍区别初始化和配置例程步骤解释 介绍 推挽输出(Push-Pull Output)：推挽输出模式是最常见的GPIO输出模式。在该模式下，引脚可以输出高电平或低电平，同时具有一定的驱动能力。引脚在输出低电平时形成低阻抗，输出高电平时形成高阻抗，可以驱动外部电路。 // 初始化推挽输出模式的GPIO GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.Pin = GPIO_PIN_0; // GPIO引脚号 GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; // 推挽输出模式 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; // GPIO速度设置为高速 HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); // 初始化GPIOA 开漏输出(Open-Drain Output)：开漏输出模式是一种能够输出低电平和高阻抗的GPIO模式。在该模式下，引脚只能输出低电平，要输出高电平需要通过外部上拉电阻或其他方式。通常用于与外部器件连接，例如与开漏输出的I2C总线器件进行通信。 // 初始化开漏输出模式的GPIO GPIO_InitStruct.Pin = GPIO_PIN_0; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD; // 开漏输出模式 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; // GPIO速度设置为高速 HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); 复用推挽输出(AF Push-Pull Output)：复用推挽输出模式允许将GPIO引脚用作特定外设功能。在该模式下，引脚可以输出高电平或低电平，并具有一定的驱动能力。 // 初始化复用推挽输出模式的GPIO GPIO_InitStruct.Pin = GPIO_PIN_0; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; // 复用推挽输出模式 GPIO_InitStruct.Pull = GPIO_NOPULL; // 不设置上拉或下拉 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; // GPIO速度设置为高速 HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); 复用开漏输出(AF Open-Drain Output)：复用开漏输出模式允许将GPIO引脚用作特定外设功能。在该模式下，引脚只能输出低电平，要输出高电平需要通过外部上拉电阻或其他方式。 // 初始化复用开漏输出模式的GPIO GPIO_InitStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fb07f1ec70da2734198fd20da0a5ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/592aedc50ef10fc68f15a7fb4922609e/" rel="bookmark">
			List集合转树形结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发中，我们通常需要将从数据库中查询的集合数据转换成类似文件系统一样的树形集合，比如：省市单位，部门机构，书籍分类等 TreeNode对象 @Data @AllArgsConstructor @NoArgsConstructor public class TreeNode { /** * 节点内码 */ private Long id; /** * 节点名称 */ private String label; /** * 父节点内码 */ private Long pid; /** * 子节点集合 */ private List&lt;TreeNode&gt; children; } 转换工具类 方式一：foreach遍历
对所传递的treeList进行遍历，然后判断该节点的父id与传递的id是否相同，相同则递归设置其孩子节点，并将该节点的放入children集合中，用于统一返回父节点相同的所有TreeNode对象。
方式二：stream流
基于ﬁlter()实现数据过滤
该方法会接收一个返回boolean的函数作为参数，终返回一个包括所有符合条件元素的流。
基于map()对元素进行转换
它接收一个函数作为方法参数，这个函数会被应用到集合中每一个 元素上，并终将其映射为一个新的元素。
对集合中的元素进行过滤，通过filter将父id相同的所有节点过滤出来，然后在map中递归设置其孩子节点，并返回。
public class List2TreeList { //方式一: 使用foreach转换 public static List&lt;TreeNode&gt; buildTreeUseList(List&lt;TreeNode&gt; treeList,long id){ //收集传递的集合中父id相同的TreeNode List&lt;TreeNode&gt; children = new ArrayList&lt;&gt;(); for (TreeNode treeNode : treeList) { //判断该节点的父id，是否与传入的父id相同，相同则递归设置其孩子节点，并将该节点放入children集合中 if(treeNode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/592aedc50ef10fc68f15a7fb4922609e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c27e124e0042034c8e18844393f9ba/" rel="bookmark">
			【Linux】中如何安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种 linux系统
CentOS 7 64位
wget https://netix.dl.sourceforge.net/project/pcre/pcre/8.40/pcre-8.40.tar.gz
wget http://nginx.org/download/nginx-1.17.5.tar.gz
下载以下安装包，用xftp放入linux系统
第一步：安装pcre依赖
解压压缩文件，进入解压之后的目录执行./configure，然后执行make &amp;&amp; make install 查看是否安装成功 [root@localhost pcre-8.37]# pcre-config --version 第二步：安装其他依赖
[root@localhost pcre-8.37]# yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 第三步：安装nginx
解压nginx，进入nginx目录，执行./configure
执行make &amp;&amp; make install
去sbin文件夹下启动nginx cd /usr/local/nginx/sbin 检查是否启动成功
[root@localhost sbin]# ps -ef|grep nginx 第二种 linux系统
Red Hat Enterprise Linux Server release 6.5 (Santiago)
提前需要准备的 1.nginx 源码 ： http://nginx.org/en/download.html
2.yum
安装教程：https://blog.csdn.net/yujing1314/article/details/97237644
3.gcc-c++
[root@localhost ~]yum install gcc-c++
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c27e124e0042034c8e18844393f9ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d6d51a9cd6e693ff4e70927ede41a63/" rel="bookmark">
			记一次公司jmeter压测时cpu过高，jvm调优解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象 因为涉及到人行征信报文测试的报文有2.7M需要进行特征计算衍生。使用jmeter压力测试发现服务器cpu几乎打满，qps始终只有25左右。换成90k小报文后qps立马就能上到1200后来我使用了一下阿里巴巴的一款Arthas工具打算先分析一下是GC导致的cpu高还是代码中存在死循环之类的代码
解决过程 因为服务器不能连接外网所以从改地址先下载arthas 后再上传到服务器
下载 — Arthas 3.5.4 文档
启动命令：
java -jar arthas-boot.jar 然后回车输入：dashboard 用于查看cpu，内存，GC等情况
可以看出大半的cpu资源都是被GC回收所占用。
接下来的问题就是要解决GC频繁的问题了。
使用：jstat -gcutil 进程号 1000 1000 示例：jstat -gcutil 11051 1000 1000
查看到 full GC发生频繁，而且 O 列很明显每次GC后回收了一半的内存空间。（此处还有一种情况，就算full GC频繁，但是O列的内存空间几乎没什么变化，这种情况大概率就是代码里有很多对象放到老年代始终无法回收，需要具体到代码层面分析了,Arthas也可以做到，此处就不再讲述了）
那么很明显了，我了解到的对象会加入老年代有两种情况：1，对象经过15次gc后会从年轻代挪到老年代；2，一次插入的对象太大了超过了年轻代空间的1/2会直接挪到老年代。
很显然我们的问题应该是第二种情况，因为body体中的一个请求就有2.7M.
解决方法：由于jvm默认的年轻代和老年代空间大家比例是1：2。故将年轻代的空间调大即可，从而避免以上第二种情况的发生，同时也是减少年轻代垃圾回收的频率。
vi ~/.bash_profile 将年轻代调整为10G
source ~/.bash_profile 再测qps提升了近4倍，GC不再频繁
如果不是gc导致的cpu异常的高。可以通过thread -n 10这个命令来查看是什么代码消耗cpu资源比较多。
补充：thread -n 10 这个命令只能看到瞬时是cpu资源消耗，有时候为了精准的调优代码，可以通过arthas 输出一个火焰图，上面可以看到单位时间内的cpu消耗从而进行压测调优代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e19f43bd4eb7aa536a2d4e33b7a6052/" rel="bookmark">
			无网环境的GCC更新安装（适用于Redis6的编译）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、上传文件
二、升级gcc版本
此文档在虚拟机环境下进行的操作，系统为CentOS-UI版本。
因为在CentOS7版本中，默认GCC安装版本为4.8，无法满足Redis6的安装，所以需要更新GCC。
一、上传文件 文件已经上传至CSDN，具体详见无网环境的GCC7.1更新安装-依赖包资源-CSDN文库，也可以自行下载所需要的版本链接：Index of /sites/sourceware.org/pub/gcc/infrastructure (mirrorservice.org)
文件通过远程工具进行上传（如图），进入各个文件夹，随后执行命令并安装
rpm -Uvh *.rpm --nodeps --force 安装完成查看版本
gcc -v 二、升级gcc版本 解压‘gcc-7.1.0.tar.gz’文件至指定文件夹
tar -zvxf gcc-7.1.0.tar.gz --directory=/usr/local/ cd /usr/local/gcc-7.1.0/ # 查看gcc-7.1需要的依赖版本 vi contrib/download_prerequisites 如图，我已经提供更新所需的依赖。
解压上述包，并移动至‘gcc-7.1.0’解压过后的文件夹内
解压tar.bz2文件 tar jxvf filename.tar.bz2 解压tar.gz文件 tar -zxvf 文件名.tar.gz mv gmp-6.1.0 /usr/local/gcc-7.1.0/ mv isl-0.16.1 /usr/local/gcc-7.1.0/ mv mpc-1.0.3 /usr/local/gcc-7.1.0/ mv mpfr-3.1.4 /usr/local/gcc-7.1.0/ 进入到 /usr/local/gcc-7.1.0/ 文件夹
cd /usr/local/gcc-7.1.0/ 添加软连接
ln -sf gmp-6.1.0 gmp ln -sf mpfr-3.1.4 mpfr ln -sf mpc-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e19f43bd4eb7aa536a2d4e33b7a6052/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/43/">«</a>
	<span class="pagination__item pagination__item--current">44/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/45/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>