<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18ef500dba444137a9dc8d9772875c82/" rel="bookmark">
			Linux环境—在线安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux环境—在线安装nginx 一、使用步骤 1.安装依赖 注意：进入到服务器接收文件路径上
命令如下：
yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 2.验证安装 命令如下：
gcc -v 3.安装nginx 3.1 建目录，解压包 命令如下：
mkdir /usr/local/nginx tar -xzvf nginx-1.19.10.tar.gz cd nginx-1.19.10 注意：以nginx为nginx-1.19.10.tar.gz为例
3.2 配置 命令如下：
./configure --prefix=/usr/local/nginx --conf-path=/usr/local/nginx/conf/nginx.conf 3.3 编译和安装 命令如下：
make &amp;&amp; make install ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx 3.4 配置nginx.conf 命令如下：
cd /usr/local/nginx/conf ll 3.5 检查 命令如下：
cd /usr/local/nginx/sbin/ ./nginx -t 3.6 启动，关闭，软重启 启动：
./nginx 关闭：
./nginx -s stop 软重启：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18ef500dba444137a9dc8d9772875c82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe8c641403f1f94403b35217b5ef75f5/" rel="bookmark">
			解释Java的垃圾回收机制，Java中如何创建多线程？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java的垃圾回收（Garbage Collection, GC）机制是一种自动的内存管理技术，它是Java虚拟机（JVM）的核心特性之一。其主要目标是识别并回收那些在Java程序运行过程中已经不再使用的对象所占用的内存空间，从而避免了程序员手动去管理和释放内存，这降低了出现内存泄露等问题的风险，并简化了编程模型。
在Java中，当一个对象被创建后，它会被分配到堆内存上。如果这个对象随后不再有任何引用指向它（即没有可达路径能够访问到这个对象），那么根据GC的定义，这个对象就成为了“无用”或者“不可达”的对象，可以被当做垃圾进行回收。
Java垃圾回收的工作流程通常包括以下几个步骤：
对象可达性分析：通过根节点集合（通常是栈上的局部变量、方法区的类静态变量以及全局JNI引用等）作为起点，遍历整个引用树来判断对象是否可达。如果一个对象在GC Roots不可达，则被认为是可回收的。
标记（Marking）：一旦确定某个对象是不可达的，垃圾回收器会将其标记为待回收的状态。
清理（Sweeping）/整理（Compacting）：标记阶段结束后，垃圾回收器会清除所有标记为可回收的对象，释放它们占用的内存空间。在一些GC算法中，如CMS或G1，还会进一步进行内存空间的整理，避免内存碎片的产生，以优化后续对象分配的效率。
内存压缩（如果有必要）：在一些现代的垃圾回收器（如G1，ZGC，Shenandoah）中，为了减少内存碎片，会在清理后进行内存区域的压缩，即将存活对象移到一块连续的空间上，然后释放其余空闲区域。
Java提供了多种不同的垃圾回收算法实现，比如分代收集（Young Generation 和 Tenured/Old Generation）、并发标记清除（Concurrent Mark Sweep, CMS）、暂停预拷贝（Parallel Copy Collector）、低暂停时间的G1和ZGC等，这些算法在不同的场景下有着不同的优势和适用性。
总之，Java垃圾回收机制确保了内存的有效利用和系统的稳定性，使得开发人员无需关心内存的具体管理工作，从而更加专注于业务逻辑的实现。
在Java中，有多种方式可以创建多线程：
继承Thread类：创建一个新的类，该类继承自Thread类，并重写它的run()方法。然后创建该类的实例并调用start()方法来启动新线程。
示例代码：
class MyThread extends Thread { public void run() { // 线程的任务代码 } } public class Main { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); } } 实现Runnable接口：创建一个实现Runnable接口的新类，并实现其run()方法。然后将这个Runnable对象作为参数传递给Thread类的构造函数来创建新的线程。
示例代码：
class MyRunnable implements Runnable { public void run() { // 线程的任务代码 } } public class Main { public static void main(String[] args) { Thread thread = new Thread(new MyRunnable()); thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe8c641403f1f94403b35217b5ef75f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/765ae27a848f8d2b6d7a3a3f75f49438/" rel="bookmark">
			Spring全局异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 概述依赖导入创建全局异常处理总结 概述 在Spring框架中，全局异常处理主要是通过@ControllerAdvice（或其特化形式@RestControllerAdvice）注解和@ExceptionHandler注解来实现的。这种机制能够捕捉到控制器（@Controller或@RestController）中抛出的异常，并允许你定义全局的处理逻辑。
依赖导入 在使用Spring Framework构建应用程序，并希望集成全局异常处理器时，你实际上并不需要添加任何特定的依赖来实现这个功能，因为它是Spring MVC提供的一个内建功能。
但确保你的项目已经包含了Spring MVC相关的依赖。对于使用Spring Boot的项目，你可以通过添加spring-boot-starter-web依赖来集成Spring MVC：
&lt;!-- Maven配置示例 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 其他依赖... --&gt; &lt;/dependencies&gt; 对于非Spring Boot项目，你可以添加相应的Spring MVC依赖，如下所示：
&lt;!-- Maven配置示例 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.x&lt;/version&gt; &lt;!-- 使用最新的兼容版本 --&gt; &lt;/dependency&gt; &lt;!-- 其他依赖... --&gt; &lt;/dependencies&gt; 这些依赖将自动引入所需的所有组件，从而使你能够使用@ControllerAdvice或@RestControllerAdvice和@ExceptionHandler注解来处理全局异常。
创建全局异常处理 以下是一个例子，展示了如何使用这些注解来创建一个简单的全局异常处理器：
@ControllerAdvice // 或者使用 @RestControllerAdvice public class GlobalExceptionHandler { // 捕获特定类型的异常 @ExceptionHandler(CustomException.class) public ResponseEntity&lt;String&gt; handleCustomException(CustomException ex) { // 创建响应实体并自定义相应状态码和信息 return new ResponseEntity&lt;&gt;(ex.getMessage(), HttpStatus.BAD_REQUEST); } // 捕获所有类型的异常 @ExceptionHandler(Exception.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/765ae27a848f8d2b6d7a3a3f75f49438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/421b0cc24be6d55d645296fce2650dce/" rel="bookmark">
			vue报错：WebSocket connection to ‘ws://192.168.1.3:8080/ws‘ failed:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 webpack5中的决绝方式
解决方式：vue.config.js文件中加入
devServer:{ historyApiFallback: true, allowedHosts: "all", } const { defineConfig } = require('@vue/cli-service') module.exports = defineConfig({ transpileDependencies: true, lintOnSave:false, devServer:{ historyApiFallback: true, allowedHosts: "all", } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be08c23677c64175a1d26b1791d24511/" rel="bookmark">
			python中none的替换方法：pandas&amp;numpy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		none的替换方法： 1.pandas
# 将缺失的id值替换为None merged_df['id'].fillna('None', inplace=True) #这行代码使用了Pandas库中的`fillna`方法，对DataFrame中的'id'列进行了填充操作。具体来说，它将该列中的缺失值用字符串'None'进行填充，并通过`inplace=True`参数将修改应用到原始的DataFrame上，而不是返回一个新的DataFrame。 #这样的操作通常用于处理数据中的缺失值，将缺失的标识用一个特定的值替代，以便后续的数据分析或处理不受缺失值的影响。在这个例子中，如果DataFrame中的'id'列有缺失值，那么这些缺失值会被替换为字符串'None'。 np.nan_to_num是NumPy库中的一个函数，用于将数组中的NaN（Not a Number）值替换为特定的数值。NaN通常表示缺失值或无效的数值。
2.numpy
语法如下：
numpy.nan_to_num(x, copy=True, nan=0.0, posinf=None, neginf=None) 参数解释：
x: 要处理的数组。copy: 默认为True，表示是否创建输入数组的副本。如果设置为False，可能会在原地修改输入数组。nan: 用于替换NaN的值，默认为0.0。posinf: 用于替换正无穷大的值，默认为None，表示不替换。neginf: 用于替换负无穷大的值，默认为None，表示不替换。 这个函数的主要目的是确保数组中不包含NaN值，而是将其替换为给定的数值。这对于一些数学计算和统计操作是很有用的，因为NaN值可能会导致这些操作产生不确定的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c539c19ead38dfb4abcc96bc90e472d/" rel="bookmark">
			114.QTimer类和QWidget类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、QTimer类
定时器使用举例：
二、QWidget类 2.1设置父对象
2.2窗口位置
2.3窗口尺寸
2.4窗口标题和图标
2.5信号
2.6槽函数
示例代码：
一、QTimer类 QTimer 是 Qt 中用于实现定时器的类。它可以在一定的时间间隔内发射信号，用于执行一些特定的操作。要使用它，只需创建一个QTimer类对象，然后调用其 start() 函数开启定时器，此后QTimer对象就会周期性的发出 timeout() 信号。我们先来了解一下这个类的相关API。
// 构造函数 // 如果指定了父对象, 创建的堆内存可以自动析构 QTimer::QTimer(QObject *parent = nullptr); // 设置定时器时间间隔为 msec 毫秒 // 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发 void QTimer::setInterval(int msec); // 获取定时器的时间间隔, 返回值单位: 毫秒 int QTimer::interval() const; // 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔 [slot] void QTimer::start(); // 启动或重新启动定时器，超时间隔为msec毫秒。 [slot] void QTimer::start(int msec); // 停止定时器。 [slot] void QTimer::stop(); // 设置定时器精度 /* 参数: - Qt::PreciseTimer -&gt; 精确的精度, 毫秒级 - Qt::CoarseTimer -&gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度 - Qt::VeryCoarseTimer -&gt; 非常粗糙的精度, 精度在1秒左右 */ void QTimer::setTimerType(Qt::TimerType atype); Qt::TimerType QTimer::timerType() const;	// 获取当前定时器的精度 // 如果定时器正在运行，返回true; 否则返回false。 bool QTimer::isActive() const; // 判断定时器是否只触发一次 bool QTimer::isSingleShot() const; // 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false void QTimer::setSingleShot(bool singleShot); 定时器使用举例： #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c539c19ead38dfb4abcc96bc90e472d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db8cca37288076802c2bc3f2db09aa3f/" rel="bookmark">
			pandas的iloc函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pandas的iloc函数： iloc 是 Pandas 中用于基于整数位置进行索引和切片的方法。它允许你通过整数位置来访问 DataFrame 中的特定行和列。
语法格式如下：
DataFrame.iloc[row_indexer, column_indexer] row_indexer: 行的整数位置或切片。column_indexer: 列的整数位置或切片。 下面是一些使用 iloc 的示例：
import pandas as pd # 创建一个示例 DataFrame data = {'Name': ['Alice', 'Bob', 'Charlie', 'David'], 'Age': [25, 30, 35, 40], 'City': ['New York', 'San Francisco', 'Los Angeles', 'Chicago']} df = pd.DataFrame(data) # 使用 iloc 获取特定行和列的数据 # 获取第二行（索引为1）的所有列数据 row_1 = df.iloc[1, :] # 获取第一列（索引为0）的所有行数据 column_0 = df.iloc[:, 0] # 获取第二行到第四行（索引为1到3）的第一列和第二列的数据 subset = df.iloc[1:4, 0:2] print("Row 1:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db8cca37288076802c2bc3f2db09aa3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59a7dbc25393d7ea4cc389512f09099/" rel="bookmark">
			Linux系统安全及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.账号安全基本措施
系统账号清理
将非登录用户的shell设为/sbin/nologin设置为无法登录
(shell——/sbin/nologin比较特殊，所谓“无法登陆”仅是这个用户无法使用bash或其他shell来登陆系统而已，并不是说这个账号就无法使用系统资源。
举例来说，各个系统账号中，打印作业有lp这个账号管理，www服务器有apache这个账号管理，他们都可以进行系统程序的工作，但就是无法登陆主机而已)
锁定长期不使用的账号
删除无用的账号
锁定账号文件passwd , shadow
2.密码安全控制
chage [选项] 用户名（适合用于已有用户修改）
-m：密码可更改的最小天数。为零时代表任何时候都可以更改密码。
-M：密码保持有效的最大天数。
-w：用户密码到期前，提前收到警告信息的天数。
-E：帐号到期的日期。过了这天，此帐号将不可用。
-d：上一次更改的日期
chage -d 0 zhangsan 强制张三下一次登录一定修改密码（密码符合复杂性要求）
-i：停滞时期。如果一个密码已过期这些天，那么此帐号将不可用。
-l：例出当前的设置。由非特权用户来确定他们的密码或帐号何时过期。
如 使用chage命令进行修改用户thh密码有效期为30天：
进入配置文件修改（对新建用户）
如要求新建用户wangwu,他的密码有效期为20天
vim /etc/login.defs 20左边的0表示（下一次登录一定修改密码且密码符合复杂性要求）
3.命令历史 上面更改永久有效
也可以直接 echo $HISTSIZE=10 source /etc/profile
重启更改失效
临时清除历史命令
history -c 退出清空
vim .bash_logout ~/.bash_logout
echo " " &gt;~/.bash_history
开机后清除
vim .bashrc
echo " " &gt;~/.bash_history
4.设置超时时间
vi /etc/profile
export TMOUT=60
source /etc/profile
5.切换用户
su命令（ switch user），可切换用户身份，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f59a7dbc25393d7ea4cc389512f09099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f09c24b8dffade3f72c9d5431da59c2f/" rel="bookmark">
			flask web学习之表单（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、使用Flask-WTF处理表单1.1 安装Flask-WTF库1.2 定义WTForms表单类常用的WTForm字段实例化字段类常用参数常用的WTForm验证器 1.3 输出HTML代码使用render_kw属性在调用字段时传入 1.4 在模板中渲染表单 在web程序中，表单是用户交互最常见的方式之一。用户注册、登陆、撰写文章、编辑设置无一不用到表单。
一、使用Flask-WTF处理表单 1.1 安装Flask-WTF库 pipenv install flask-wtf pip install flask-wtf flask-wtf默认为每个表单开启CSRF保护，它会为我们自动生成和验证CSRF令牌。所以我们应该设置：
app.secret_key = 'dadesjdajdhadheuisdjakj' 1.2 定义WTForms表单类 from wtforms import Form, StringField, IntegerField, validators class MyForm(Form): name = StringField('name', [validators.Length(min=4, max=25)]) age = IntegerField('Age', [validators.NumberRange(min=0, max=100)]) 在这个例子中，我们使用了StringField和IntegerField来分别定义了name和age两个字段。每个字段都有一个标签（即’Name’和’Age’），以及一些验证器（validators）来验证用户提交的数据是否符合要求。例如，validators.Length(min=4, max=25)表示name字段的长度必须在4到25个字符之间，而validators.NumberRange(min=0, max=100)表示age字段的值必须在0到100之间。
常用的WTForm字段 字段类说明对应的html表示StringField（文本字段）用于接收文本输入&lt;input type="text"&gt;PasswordField（密码字段）用于接收密码输入&lt;input type="password"&gt;TextAreaField（多行文本字段）用于接收多行文本输入&lt;textarea&gt;&lt;/textarea&gt;IntegerField（整数字段）用于接收整数输入&lt;input type="number"&gt;BooleanField（布尔字段用于接收布尔值输入&lt;input type="checkbox"&gt;SelectField（下拉选择字段）用于从预定义选项中选择一个值。&lt;select&gt;&lt;option&gt;...&lt;/option&gt;&lt;/select&gt;RadioField（单选按钮字段）用于从预定义选项中选择一个值。&lt;input type="radio"&gt;FileField（文件上传字段）用于上传文件。&lt;input type="file"&gt; 实例化字段类常用参数 参数说明label字段的标签（Label）或名称（Name），用于在表单中标识该字段。validators包含一个或多个验证器对象的列表，用于验证输入数据是否符合指定规则。default字段的默认值。description字段的描述信息，通常用于在页面上显示字段的说明文本。render_kw包含一些HTML属性和值的字典，用于向字段的HTML表示中添加额外的属性和样式。choices可选的预定义选项列表，用于下拉选择字段和单选按钮字段。coerce指定将输入值转换为另一种类型的函数，例如将字符串转换为整数。filters包含一个或多个过滤器对象的列表，用于在表单提交前对输入数据进行处理。 常用的WTForm验证器 验证器说明DataRequired验证字段必须包含数据。Length验证输入数据的长度是否在指定范围内。Email验证输入数据是否为有效的电子邮件地址。EqualTo验证两个字段的值是否相等。NumberRange验证输入数据是否在指定的数字范围内。Regexp使用正则表达式验证输入数据是否符合指定模式。 name = StringField('Your name', validators=[DataRequired(message=u'名字不能为空')]) 当使用flask-wtf定义表单时，我们仍然使用WTForm提供的字段类和验证器，创建的形式也一样，只是表单类要继承flask-wtf提供的FlaskForm类。
from flask_wtf import FlaskForm from wtforms import StringField, IntegerField, validators class MyForm(FlaskForm): name = StringField('name', [validators.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f09c24b8dffade3f72c9d5431da59c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c797b891d680b39ee10317a2301b7e/" rel="bookmark">
			vue中，页面监听store中数据 的变化以及时做出相应，watch、computed与store的getter属性协调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue中，页面监听store中数据 的变化以及时做出相应，watch、computed与store的getter属性协调 如题目所示，今天来讲一个非常简单但是非常常见的使用场景。假设在用户登录的时候，store会全局用户的相关信息，当用户退出登录后，store里面的信息会清空，同时，在某一个页面，内容很多，你不想每次进入的时候都通过刷新一下来重新获取store内容，而是想要自动地监听store对应内容的变化，来自己做出响应。那么就可以参考下面的做法：
涉及到的设计内容：
storewatchcomputed 假设我现在有一个登录页面，在store存在用户信息时跳转到主页，如果没有，从主页跳转回登录页，也就说只有登录才可以访问主页：
登录页面如下所示：
&lt;template&gt; &lt;div&gt; 登录 &lt;button type="button" @click="changename"&gt;change&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import store from '@/store' export default { data () { return { name: '' } }, methods: { changename () { store.commit('getinfo', { name: 'zsy' }) } } } &lt;/script&gt; 然后在store中有如下信息：
export default new Vuex.Store({ state: { name: 'xjd', stunumber: '', school: '', sex: '' }, getters: { getname (state) { return state.name } }, mutations: { getinfo (state, a) { state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57c797b891d680b39ee10317a2301b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f3a4904bfa74d4981424ea4169016e/" rel="bookmark">
			审批流、工作流、业务流、BPM 几个概念澄清
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 每次听各类供应商售前专家在做产品宣讲时，经常看到牛人在讲坛上吐沫横飞，大讲各种流，信息流、业务流、物流、商流、资金流、单据流等，终于在《透明数字化供应链》一书中，看到对各类流的解释，现整理如下：供应链始于用户需求，终于用户服务享用/产品使用，包括采购、营销、生产、渠道整个过程。供应链管理本质：指对供应链要素及过程进行管理，从而使供应链的信息流、物流、资金流高效流动。
正三流：信息流、物流、资金流 1、信息流：最初为传递需求与供给信息，包括市场调研、需求预测、供应商寻源、采购招标、生产发运、交付的所有过程，都是信息流一部分。
2、物流：即商品在交易过程中所有权或控制权的转移，对实物流的管理也叫物流管理，包括销售物流、生产物流、采购物流、售后物流四个方向。
3、资金流：为促进交易，以一般等价物形式存在，包括应收、应付、现金、转账等，业务上也包括工资、服务费、差旅费、原料采购费、销售收入等。最终反应在财务相关报表上。
先有信息流，有了供求信息，才有交易，后有物流，即实物的转移，最后是资金流，交易结算。
副三流：商流、单据流、业务流 1、商流：信息流中关于交易信息或商品转移信息的确认。把这些每次需求确认的交易信息按时间顺序串起来，就是商流，包括内部与外部两种，内部指调拔单、工单等形式，外部包括合同、订单等形式
2、单据流：单据流转为单据流，单据流是对信息流的记录与确认，区分供应链中上下游角色之间权责关系。
3、业务流：即业务流程或操作流程，表示先做什么后做什么。
最早出现的是商流，口头确认交易环节。后来发展为各类单据以记录并确认商流的过程，最后细化为业务流，用于规范企业经营每个环节的具体操作。
正三流：体现的是企业商业模式，即谁在什么场景下需求什么，付出多少代价，谁提供服务/产品，副三流体现的更多是企业管理组织架构与业务流程设计。
供应链的相关问题：
1、信息流失真、滞后，包括需求滞后（失真）、供给滞后等。
2、物流失控：假货、物流成本与周期等。
3、资金流失控：资金流混乱、枯竭影响企业经营。
供应链数字化，同样是面向供应链过程的以上相关问题进行优化与提升。
流程 流程基础概念：价值链是给客户提供产品或服务的流程。一个组织中业务流程的典型数量：核心流程5-10个（高层的战略流程）、成千上百个支持和管理流程流程的分类：价值链流程（战略核心流程-研发、制造、销售、交付、服务）、支持流程（人财物料技术）、管理流程（计划、预算、变革、合规），管理和支持流程并不给客户提供任何直接价值流程的定义：重复的增值互动的集合，由组织的人和技术资源实施，其目的是实现共同的业务目标，生产出客户愿意买单的产品和服务价值链中的组织形式：市场营销、研发、产品服务设计、运营、销售、交付物流、服务价值链流程识别：为了实现组织愿景和目标而存在的，始终聚焦于驱动业务的关键部分 审批流 审批流：审批流主要是指企业在进行某项业务操作时，需要经过的审批环节和审批顺序。它是企业内部控制的重要手段，通过对审批流的管理，可以有效防止业务操作中的风险。审批流通常包括申请、审批和执行等环节。 工作流 工作流（Workflow）是指一系列任务和活动按照特定的顺序和规则进行组织、协调和执行的过程。通俗来说，工作流就是将一项业务或工作划分为多个任务或活动，按照一定的逻辑关系和执行顺序，通过自动化工具实现任务分配、执行、监控和控制等过程，从而达到提高工作效率、减少错误和提高工作质量的目的。 业务流 业务流程的简要定义——为了既定目标而采取的一系列步骤。流程就是让人们根据预先制订的行动方案和计划，以一种系统化的方式反复执行相关任务。流程就是把总体计划、方针转化成规范的决策和行动的一种方式。业务流程：它是关联的、结构化的活动或流程（事件或活动链）的集合业务流程通常横跨多个业务部门：运营、物流、IT、财务和法律等业务流程把组织里的不同部门链接起来，流程在独立工作者和职能部门之间扮演活动协调者的突出橘色业务流程沿着横向运行/纵向运行，一个流程输出成为另一个流程输入业务流程的重要性：更加廉价处理重复活动、清晰定义的业务流程确保决策和行动一致性、使管理者脱离职能组织思维模式，聚焦于真正处于核心的业务流程 业务流与审批流 业务流，是指在在执行业务活动过程中，信息、材料或任务的流动顺序和方式，它描述了为完成特定业务目标而需要遵循的步骤或阶段，业务流体现了业务价值创造和业务价值实现的全过程。比如，在人员招聘的业务流中，人员招聘会经过人员需求申请、人员需求审批、人员需求发布、人员招聘、候选人员面试、人员录用和新员工入职等活动环节，只有这些活动环节全部走完，少一个都不行，我们需要的人才能被招进来。而审批流，也被称为审批流程，是一种在企业内部用于处理和批准各种请求和事务的正式流程，这种流程通常涉及多个层级的审批，确保重要决策在执行前得到适当的审核和授权。审批流是业务流的一部分，仍以人员招聘的流程为例，人员招聘可能会涉及到一些审批流，如人员需求审批流和人员录用审批流，在不同业务规模和不同业务场景下，所需要的审批层级和审批人员会有很大的不同，比如，普通员工的招聘，只要是在编制内，只需要经过二级用人部门主管领导审批即可，编制外则需要上升一级，总监级人员的招聘需求，无论是在编制内还是在编制外，都需要董事长审批。审批流很多时候都是为了内控的需要而存在，审批活动在业务活动中，都是非增值的活动，如果风险可控，理论上讲，审批的环节和审批的层级应该越精简越好。真正搞清楚了像类似业务流和审批流这样的概念，我们就可以更容易在工作中和团队成员及相关同事就工作的相关标准和相关安排达成共识，我们才有可能更好的做好流程建设和流程运营的工作。 工作流与业务流 工作流（Workflow）是指将一系列相关的任务、活动和决策按照特定的顺序和规则组织起来，以实现特定的业务流程。工作流可以帮助组织和管理复杂的业务流程，提高工作效率和质量。 在工作流中，任务和活动按照预定义的流程顺序进行，每个任务的执行都依赖于前一个任务的完成。工作流可以自动化和规范化业务流程，通过定义流程规则和条件，自动分配任务、提醒参与者、监控进度等，从而提高工作效率和准确性。工作流系统是指用于管理和执行工作流的软件系统。它通常包括流程设计工具、流程引擎、任务分配和调度、流程监控和报告等功能，可以帮助组织实现业务流程的自动化、可视化和优化。工作流系统可以应用于各种领域，如审批流程、项目管理、客户服务等。 BPM BPM定义管理组织端到端的流程或价值链流程以改进执行的结果。BPM不只是流程自动化，把核心业务流程控制起来、管理起来才是BPM的真正目的。 BPM特征： BPM提供一种重新认识职能组织及其活动的方法，以看出核心业务流程——价值链如何运作(看价值）BPM提供一种图形化方式展示关键业务流程以及关键业务流程之间的关系（看关系）定义端到端的活动（工作）在组织内部如何得到执行，从而为客户交付价值（看执行）洞察组织的关键职能部门是如何执行业务流程的以及它们之间的依赖性洞察哪些活动需要测评、如何测评，以及如何与薪酬制度挂钩，如何采取优化措施BPM最大的特点：打破原有职能架构式的组织思维模式BPM将建立流程与业务目标和市场需求统一起来的模型BPM的关键概念：以客户为中心，是商业驱动、数据驱动的，持续改进是基础BPM强调从宏观流程进行定义，指定所有权，明确流程负责人的职责，对流程进行监控、改变或重新规划，通过不断改进创造更大价值或优化产出 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1f34b504499e9a46e760266b5b80ac/" rel="bookmark">
			解决 rasa 中 slot 不能为中文的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决 rasa 中 slot 不能为中文的问题 定位问题解决办法 定位问题 slots: 姓名: type: text mappings: - type: custom 如上的 slot 配置，在 rasa train 时会报以下错误：
YamlValidationException: Failed to validate 'D:\project\python\rasa_test\y\domain.yml'. Please make sure the file is correct and all mandatory parameters are specified. Here are the errors found during validation: in D:\project\python\rasa_test\y\domain.yml:38: Key '姓名' does not match any regex '[A-Za-z]+'. Path: '/slots' github 下载对应版本的源码 https://github.com/RasaHQ/rasa，我这里使用的是 3.6.4，直接全局搜索能找到 3 哥匹配项，都在 rasa/shared/utils/schemas/domain.yml 文件中。经过测试，发现这是 rasa 用来校验 domain.yml 文件格式的模板。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f1f34b504499e9a46e760266b5b80ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a8ffcda2a0b357f8e5283fb466deb98/" rel="bookmark">
			【大模型】大型模型飞跃升级—文档图像识别领域迎来技术巨变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 2023年12月31日，第十九届中国图象图形学学会青年科学家会议在广州举行，由中国图象图形学学会主办。
该会议的目标是促进青年科学家之间的交流与合作，以提升我国在图像图形领域的科研水平和创新能力。
由中国图象图形学学会和上海合合信息（INTSIG）联合承办的《垂直领域大模型论坛》中，专注于探讨大语言模型时代下以ChatGPT为代表的大模型技术对图像图形学领域研究方向或落地应用的潜在价值。包括合合信息丁凯博士在内的多位业内专家对大模型时代文档与图像识别领域的新探索进行了详细介绍。
一、技术难题&amp;挑战 文档图像分析识别与理解是计算机视觉和自然语言处理领域的一个复杂问题，涉及到从图像中提取文本信息、理解文档结构、识别语义等多个层面。下面是一些相关的技术难题：
具体问题如下：
场景以及版式多样性： 文档可能以不同的场景和版式出现，例如室内、室外、手写、打印等。每种场景和版式都可能导致不同的光照、视角、失真等问题。采集设备不稳定性：文档图像可能由不同的设备捕获，如摄像头、扫描仪等，这些设备的性能和参数可能存在差异，导致图像质量不稳定。用户需求多样性： 用户的需求可能各不相同，有的用户可能更关注文本内容的准确性，而另一些用户可能更注重图像的布局和格式。文档图形质量退化严重性： 文档图像可能因为老化、损坏、印刷质量差等原因而质量下降，导致文本和图像的清晰度减弱。文字检测及排版分析困难： 文字可能以不同的字体、大小、方向等形式出现，且可能与其他图像元素重叠或相似，使得文字检测和排版分析变得复杂。非限定条件文字识别率低：在非受限条件下，即不受特定规范或格式的限制，文字识别的难度增加，因为文本可能出现在任何位置、方向和形式。结构化智能理解能力差：对文档结构进行深入理解，包括标题、段落、表格等，是一个复杂的任务，尤其是在处理非结构化文档时。 二、ChatGPT-4模型 最新的版本GPT-4已经在多项测试中超越了其前身，获得了更高的评分。
它是一款高级的人工智能聊天机器人技术，它被训练得对各种问题和场景有深入的理解，并且可以生成富有事实性的响应。
它的主要特点可以归纳为以下几点：
大规模和高参数：GPT-4拥有超过1000亿个参数，是GPT-3的3倍，是GPT-2的300倍，是GPT-1的3000倍。这个庞大的规模远超过其他的语言模型，如谷歌的Gemini（300亿参数）、微软的ProphetNet（230亿参数）、百度的ERNIE-GEN（190亿参数）等。数据丰富和覆盖广泛：GPT-4的训练数据集非常庞大，包含了大量的自然语言文本，涵盖了多种语言和领域。高精度和高准确性：GPT-4在图像描述、翻译、生成代码和解答问题等方面的性能都有显著提高。然而，尽管其能力强大，GPT-4仍有可能出现错误或提供不完全准确的回答。多模态能力：GPT-4不仅可以处理文本信息，还可以处理图像内容。这使得GPT-4能够理解和解释图像内容，并将这些信息转化为自然语言。 2.1 在图像领域的优势 GPT-4在图像识别领域的优势主要体现在以下几个方面：
强大的识图能力：GPT-4拥有卓越的图像理解能力，可以接受图像和文本输入。这不仅使其在处理更复杂的任务时更具优势，也使其在理解和解释图像内容方面具有更高的精确度。零样本效果突出：在四个场景下，GPT-4的零样本效果超过了之前的GPT系列模型，这进一步证明了其在图像识别领域的优越性。回答准确性显著提高：与前一代模型相比，GPT-4在回答问题的准确性上有显著的提高，这对于图像识别任务来说是非常重要的。更强的创造力和灵活性：当任务的复杂性达到一定的阈值时，GPT-4表现出更可靠的性能，并且能够处理更细微的指令。这一特性使得GPT-4在处理一些需要精细分析和创新解决方案的图像识别任务时具有优势。更高的输入文字限制：GPT-4将文字输入限制提升至2.5万字，这意味着它可以处理更为复杂和详细的图像识别任务。 2.2 在图像领域的不足 尽管GPT-4V的水平达到了相当高的程度，但它并未完全解决OCR文档识别领域的所有挑战。
在测试中，它显露出一些明显的短板，首当其冲的是对中文的识别。无论是手写还是印刷文字，GPT-4V在识别后输出了大量与实际文章无关的内容。此外，对于一些简单的手写公式，GPT-4V也无法完美地进行识别。
对于长文档，仍然有文档解析和识别的前置依赖，ChatGPT调用了开源的PyPDF2，而该插件效果一般，且输出不支持表格结构、不支持扫描件、不支持处理复杂版式、不支持定位到原文
总结一下其不足主要有：
图像配准算法选择限制： 在图像配准时，缺乏指定算法的情况下，优先选择常见算法，如Threshold。这可能导致对于复杂和特殊图像任务处理能力的限制。
时间关系推理困难： GPT-4在理解和解释图像内容方面表现出色，但在推理多个图像之间的时间关系方面存在困难。
视觉依赖型问题的限制： GPT-4V在视觉问题类型中，对视觉依赖型问题的回答完全依赖于图像内容。缺乏图像信息时，其回答可能变得不确定或无法确切回答。
领域泛化能力与“编造”事实问题： 尽管GPT-4具有出色的领域泛化能力，但在测试中可能出现“编造”事实的情况。这可能影响其在特定领域的可靠性和准确性。
三、垂直大模型 通过对GPT-4V和文档识别领域的深入分析和思考，为OCR文档识别领域的研究开辟了新的方向。需求不断增长的背景下，提高识别精度和处理效率成为了迫切需要满足的新应用标准。在这一背景下，出现了：
素级OCR统一模型OCR大一统模型文档识别分析+LLM（Language Model） 等应用的新方向。
3.1 素级OCR统一模型 素级OCR统一模型，即UPOCR（Unified Pixel-Level OCR）模型，是一种文档图像像素级多任务处理的统一模型。该模型是由合合信息与华南理工大学联合实验室（以下简称“实验室”）研发的研究项目之一。
UPOCR模型的主要特点是引入了可学习的文本检测和识别模块，可以同时完成多个任务，包括文本检测、文本识别、端到端OCR等。这一特性使得UPOCR模型在处理文档图像时具有较高的效率和准确性。
此外，UPOCR模型还具有较好的通用性，不仅可以处理中英文文档，还可以处理包含公式、表格等复杂结构的文档。
在实际应用中，UPOCR的通用性在文本擦除、文本分割和篡改文本检测任务中经过广泛验证。
UPOCR采用ViTEraser[1]作为其主干网络，通过统一训练联合处理文本擦除、文本分割和篡改文本检测等三种不同任务的提示词。一经完成模型训练，即可无需专门的下游任务精调，直接用于各类下游任务。
总的来说，素级OCR统一模型UPOCR在文档图像预处理统一模型方面展现出了强大的实力和广泛的应用前景。
3.2 OCR大一统模型-SPTS v3 OCR大一统模型是一种创新的端到端文本检测和识别方法，是实验室正在研究的项目之一，也称为SPTS（Simultaneous Processing of Text Spotting and Recognition）。
这种方法颠覆了传统的文本检测和识别流程。在传统的方法中，文本检测和识别被视为两个独立的任务，这导致处理流程复杂且冗余。然而，SPTS将这两个任务融为一体，实现了从文本检测到识别的统一处理。
将文档图像识别分析的各项任务以序列预测的方式进行定义，包括对文本、段落、版面、表格、公式等内容的分析。通过采用不同的提示（prompt）来引导模型执行不同的OCR任务，实现了多任务处理的灵活性。该系统支持篇章级的文档图像识别分析，能够输出标准格式的文本，如Markdown、HTML等。
其中，通过引入LLM（Language Model）来处理文档理解相关的工作，进一步提高了系统对于文档结构和内容的理解能力。这种设计使得系统在处理多样性的文档图像时能够更全面、准确地进行分析，并以标准格式输出，为用户提供更便捷的文档处理和理解服务。
SPTS v3 介绍 多任务序列预测： SPTS v3通过将多种OCR任务抽象为序列预测问题，实现了对文本、段落、版面、表格、公式等不同元素的有序识别和分析。这种设计使得模型能够以一种统一的方式处理各种OCR任务。Prompt引导： SPTS v3采用了不同的prompt来引导模型完成不同的OCR任务。每个任务对应一个独特的提示，这样的引导机制使得模型在学习过程中能够专注于不同的目标，提高了系统的灵活性和适应性。模型架构： SPTS v3延续了SPTS的模型结构，包括了CNN（卷积神经网络）用于图像特征提取，以及Transformer Encoder和Transformer Decoder用于实现图像到序列的转换。这种结构旨在充分捕捉图像中的语义信息，同时具有较强的序列生成能力。任务通用性： 由于采用了序列预测的形式，SPTS v3在任务通用性上表现出色。这使得模型在不同场景和不同任务的OCR挑战中都能够取得良好的性能。 SPTSv3的任务定义，目前主要关注以下任务：端到端检测识别、表格结构识别、手写数学公式识别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a8ffcda2a0b357f8e5283fb466deb98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1f7e952ba645f36902f35d0ba94d1f/" rel="bookmark">
			贝叶斯算法的故事丨机器学习一文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天分享的内容是贝叶斯算法的核心原理与应用，接下来，通过一个小故事让你快速理解贝叶斯。
杰克是一位聪明的探险寻宝家，有一天，他得到了一张藏宝图，上面标记了宝藏可能埋藏的几个地点：一个古老的城堡、一个神秘的岛屿、一个深邃的洞穴和一个遥远的沙漠。
起初的信念（先验概率） 杰克初步估计，根据历史记录和传说，宝藏在城堡的概率是50%，在岛屿的概率是20%，在洞穴是20%，而在沙漠则是10%。
获得新线索（更新信念） 某天，杰克得到了新线索：宝藏附近有一棵罕见的蓝色花。他知道这种花在城堡和岛屿周围非常常见，在洞穴周围较少，在沙漠中则根本不生长。
更新后的信念（后验概率） 使用贝叶斯定理，杰克更新了他对宝藏位置的估计。因为蓝色花在城堡和岛屿周围更常见，他提高了宝藏在这两个地方的概率，而降低了它在洞穴和沙漠的概率。
最终结果 最终，经过一系列的探险和进一步的线索搜集，杰克在城堡找到了宝藏，这与他通过贝叶斯方法计算出的最高概率地点一致。
贝叶斯方法的体现 先验概率：杰克最初的判断（城堡50%，岛屿20%，洞穴20%，沙漠10%）是基于他之前的知识和经验。获取新证据：发现宝藏附近有蓝色花这一新线索。后验概率：结合新证据，杰克更新了宝藏可能的位置概率，这就是贝叶斯定理的应用。 一句话概括贝叶斯的原理：利用新的证据或信息来更新或改进对一个假设或事件概率的估计。
贝叶斯定理描述了两个条件概率之间的关系，其中公式左侧是在B事件发生条件下A的概率（后验概率），公式右侧的P(A)和P（B）是两个事件各自独立发生的概率（先验概率）。
先验概率与后验概率是什么？ 先验概率是在没有其他信息的情况下，对事件发生可能性的估计。后验概率是在考虑了新证据后对事件可能性的更新估计。
假设以创业为例，结果只有两种（成功或失败），按照频率论的方式，一个人创业成功的概率占50%（事件独立发生的概率），但是实际会有很多影响因素，例如他的想法、毅力、勇气等，如果雷军创业你会认为他成功的概率是80%，如果楼下地摊小哥创业，你认为他成功的概率不会特别高。
这种就是贝叶斯式思维，根据事情之间的某种联系，加入前提假设因素，从而推断结果。
贝叶斯原理的实际应用 机器学习: 在监督学习和非监督学习中，贝叶斯算法被用于建立预测模型。特别是在处理不确定性和估计概率时非常有效，机器学习预测的本质就是对信息的特征提炼，更新后验概率。
垃圾邮件过滤: 利用贝叶斯算法根据邮件内容来判断邮件是否为垃圾邮件，例如通过垃圾邮件的某些特征，更新系统对邮件分类的判断。
医学诊断: 在医学领域，它可以用来根据症状来估计疾病的概率，疾病的发生涉及到基因、环境、诱导因素等多重影响，贝叶斯方法能帮助找到他们的关系。
推荐系统: 在推荐系统中，贝叶斯算法可以帮助预测用户可能喜欢的项目，比如现在很火的抖音，通过大数据获取用户的喜好特征，在推荐指定类型的内容，也是蕴含贝叶斯原理。
科研领域：通过贝叶斯原理，能够辅助判断基因与性状之间的关联，捕获关键特征因素，辅助科研人员进行研究。
贝叶斯在生信领域的应用 贝叶斯算法在生物信息学领域有着广泛的应用，它通过对生物数据进行概率建模和推断，帮助科学家更好地理解生物过程，推动了生物研究的发展。
基因表达分析: 贝叶斯方法被用于分析基因表达数据，帮助识别在特定条件下表达变化显著的基因。这对于理解疾病机制和发现新的药物靶标至关重要。
生物序列分析: 在DNA、RNA和蛋白质序列分析中，贝叶斯算法被用来预测序列的功能区域、结构和进化关系。
蛋白质结构预测: 贝叶斯方法可以用于预测蛋白质的三维结构，这对于理解蛋白质的功能和设计药物有重要作用。
基因组注释: 在基因组注释中，贝叶斯算法有助于识别基因、预测基因功能和发现调控序列。
系统生物学: 在系统生物学中，贝叶斯网络用于模拟生物过程中的复杂相互作用，如代谢途径、信号转导途径和基因调控网络。
群体遗传学: 贝叶斯方法用于分析群体遗传数据，帮助理解种群的遗传结构、进化历史和物种形成过程。
个性化医疗: 在个性化医疗中，贝叶斯算法被用于分析个体的遗传信息，以预测疾病风险、药物反应和治疗效果。
表达谱分析: 在转录组学研究中，贝叶斯方法用于分析基因表达数据，以识别不同条件下表达变化的基因。
它也用于构建基因调控网络和理解基因表达的调控机制。
总的来说，贝叶斯算法的核心是利用概率来更新对某个事件或假设的认识，这在处理不确定性和进行复杂决策时非常有用。
本文由mdnice多平台发布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18038e3447117dcb5d34bb6ec0759c16/" rel="bookmark">
			linux系统中设置nginx开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux系统中设置nginx开机自启动 本文介绍了在linux系统中，设置nginx开机自启动的配置步骤，设置开机自启动的方式使用的是systemctl，详细介绍如下：
创建service文件 # /usr/lib/systemd/system/下新建nginx.service文件 cd /usr/lib/systemd/system touch nginx.service 编辑service文件内容 # 然后在nginx.service中写入如下内容， # 其中user和group为开启nginx的用户和对应用户组 [Unit] Description=Nginx After=nginx.service [Service] User=prouser Group=rd Type=forking ExecStart=/opt/app/nginx/sbin/nginx -c /opt/app/nginx/conf/nginx.conf ExecStop=/opt/app/nginx/sbin/nginx -s quit ExecReload=/opt/app/nginx/sbin/nginx -s reload Restart=on-failure PrivateTmp=true [Install] WantedBy=multi-user.target # 写入内容结束 使用systemctl管理服务 systemctl daemon-reload # 重载配置 systemctl enable nginx # 设置开机自启动 systemctl disable nginx # 取消开机自启动 systemctl start nginx # 启动 systemctl stop nginx # 停止 systemctl relaod nginx # 重启 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59878c622dc30e636b0b15fb547331f/" rel="bookmark">
			flask web学习之模板（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、模板结构组织1.1 局部模板1.2 宏1.3 模板继承 二、模板进阶2.1 空白控制2.2 加载静态文件2.3 消息闪现2.4 自定义错误页面2.5 在js和css中使用Jinja2 一、模板结构组织 1.1 局部模板 当多个独立模板中都会使用同一块HTML代码时，我们可以把这部分代码抽离出来，存储到局部模板中。这样，既可以避免重复，也可以方便统一管理。
{% include '_banner.html' %} # 为了和普通模板分开，局部模板的命名通常都以一个下划线开始 1.2 宏 宏是Jinja2提供的一个非常有用的特性，它类似Python的函数。使用宏可以把一部分代码封装到宏里，通过传递的参数来构建内容，最后渲染。
_macros.html # 在创建宏时，使用macro与endmaccro标签来声明宏。 { % macro qux(amount) = 1 %} {% if amount == 1 %} I am a boy. {% elif amount &gt;1 %} I am a girl. {% endif %} {%% endmacro %} 使用时，像Python中导入函数一样导入。
{% from '_macros.html' import qux %} .... {{qux(amount=5)}} 另外在使用宏的时候要注意上下文问题。出于性能的考虑，并且为了让这一切保持显式，默认情况下include一个模板时会传递上下文到局部模板中，但import不会。所以我们需要导入时显式的使用with context来声明传入当前模板的上下文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a59878c622dc30e636b0b15fb547331f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b67bf78aee5c0ddd2ed928f5c73acc63/" rel="bookmark">
			【活动系列】程序员面试技巧：现代科技领域的关键要素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 在当今科技领域，程序员的面试被视为一项至关重要的任务，宛如编写一段完美的代码一样。在这个技术战场上，我们需要展现出类似于忍者的灵活性，侦探般的聪明头脑，以及无敌铁金刚一样的坚定意志。仅有深谙这些关键技巧，方能在面试的舞台上脱颖而出，成为HR们心中令人瞩目的程序猿。
一、面试技巧 1. 精湛的编程技能： 作为程序员，首要技能是高超的编程能力。这不仅包括对算法和数据结构的深入理解，还需要在代码设计和调试方面游刃有余。通过在面试中展示项目经验，突显技术功底和实际问题解决的能力，能够深刻展现我们在编程领域的卓越水平。
2. 高效问题解决能力： 面对复杂问题，高效而准确地解决是程序员的基本要求之一。借助深入的问题分析能力和合理的解决方案，我们可以在面试中展示自己的问题解决能力。通过详细讲解实际案例，强调解决问题的方法和取得的成果，有助于向面试官展示我们在高压环境下的优越表现。
3. 卓越的沟通表达能力： 在面试中，沟通表达能力同样至关重要。清晰而简练地表达技术思想，用通俗易懂的语言解释复杂的技术概念，展现我们在技术领域中的专业性。同时，通过倾听并准确理解面试官的问题，确保我们的回答切合问题的核心要点，这样的沟通技巧有助于给HR留下深刻印象。
4. 突出的团队协作精神： 在现代软件开发中，团队协作是项目成功的关键因素之一。在面试中，展示积极主动的团队协作精神，并通过具体的案例强调自己在团队中的有效沟通和合作能力，有助于体现我们是一个具备团队精神的出色程序员。
5. 持续学习的意愿： 面对科技领域的不断发展，具备持续学习的意愿成为不可或缺的素质。通过分享个人学习新技术、参与开源项目以及在业余时间深化专业知识的经验，能够展示出我们对行业发展的敏感性和强烈的求知欲望。这种持续学习的态度显示出我们能够适应不断变化的技术环境。
6. 项目经验的精准展示： 在面试中，项目经验是展示实际工作能力的窗口。不仅要简单罗列项目，更要注重强调个人在项目中的角色和贡献。通过突出解决实际问题的能力、项目成功实施的关键因素，我们能够使HR对我们的实际工作经验有更为具体的了解。
7. 精湛的自我推销技巧： 在面试过程中，我们需要巧妙地展现自我优势。这不是夸夸其谈，而是通过合理的方式准确地表达个人成就和贡献。通过突出强调个人在之前工作中取得的具体成果，我们能够更好地打动HR，展现出自己的实力。
8. 全面了解公司文化和业务： 在面试前，深入了解目标公司的文化和业务是至关重要的。了解公司的价值观、愿景和工作氛围，能够使我们在面试中更好地展现自己的匹配度。提前准备有针对性的问题，展现我们对公司的深刻了解，表达对公司的浓厚兴趣，这有助于引起HR的共鸣。
9. 从容处理压力的本领： 面试过程中可能会受到各种压力测试，例如技术难题或突发状况。我们需要展现出从容处理压力的能力，冷静地分析问题，有条不紊地解决。这种表现不仅让HR看到我们的应对能力，同时也体现出在复杂环境中依然能够保持高效工作的稳健态度。
10. 出色的社交技能和人际关系： 在现代职场中，优秀的社交技能和人际关系至关重要。在面试中展示出色的人际沟通能力、团队协作精神以及与同事相处的和谐，能够使HR更加确信我们是一个愿意共事的优秀团队成员。
二、总结 总体而言，程序员在面试中需要展现出技术娴熟、问题解决能力高效、沟通表达清晰、团队协作默契以及持续学习的积极心态。
只有通过综合的表现，我们才能在面试舞台上展现出色，成为那个HR们眼中令人印象深刻的程序猿。通过不断提升自己的专业素养，我们将更有信心迎接未来职业生涯的挑战。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d77cda17a39c7eb2f25b9bcbc3d746e2/" rel="bookmark">
			linux系统中设置redis开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux系统中设置redis开机自启动 本文介绍了在linux系统中，设置redis开机自启动的配置步骤，设置开机自启动的方式使用的是systemctl，详细介绍如下：
创建service文件 # /usr/lib/systemd/system/下新建redis.service文件 cd /usr/lib/systemd/system touch redis.service 编辑service文件内容 # 在redis.service中写入如下内容： [Unit] Description=Redis persistent key-value database After=network.target [Service] User=prouser Group=rd Type=forking ExecStart=/opt/app/redis/bin/redis-server /opt/app/redis/bin/redis.conf ExecStop=/opt/app/redis/bin/redis-cli shutdown Restart=on-failure PrivateTmp=true [Install] WantedBy=multi-user.target # 写入内容结束 使用systemctl管理服务 systemctl daemon-reload # 重载配置 systemctl enable redis # 设置开机自启动 systemctl disable redis # 取消开机自启动 systemctl start redis # 开启 systemctl stop redis # 关闭 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0058830b1b65dff855cb9033afcf086/" rel="bookmark">
			一文弄懂电力系统101、103、104、modbus和61850规约
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 101规约103规约104规约iec101、iec103和iec104有什么异同点？modbus规约61850规约 101规约 IEC 101（International Electrotechnical Commission 101）是一种用于远程监控和控制系统的通信协议。它是国际电工委员会（IEC）制定的标准协议，用于在电力系统、水处理、工业自动化等领域中实现设备之间的通信。
IEC 101协议基于主从结构的请求/响应模式。在通信中，主站（也称为控制中心或主控站）负责发送查询命令，而子站（也称为终端设备或远程站）负责接收并响应这些命令。
IEC 101协议使用串行通信方式，通常在低速率的电信网络中使用。它支持多种物理层和数据链路层的传输方式，包括RS-232、RS-485等。协议规定了数据帧的格式和规范，包括起始字符、地址字段、控制字段、信息字段和校验字段等。
IEC 101协议主要用于传输监测数据、遥控命令和遥信信息等。它可以实现从主站向子站发送查询命令，获取子站的实时数据，并可以通过遥控命令实现对子站的控制操作。同时，它也支持遥信功能，用于传输设备状态、告警信息等。
IEC 101协议在一些老旧的远程监控系统中仍然广泛使用，但随着技术的进步和网络的发展，越来越多的系统开始采用更现代化的协议，如IEC 104和DNP3等。
103规约 IEC 103（International Electrotechnical Commission 103）是一种用于远程监控和控制系统的通信协议。与IEC 101相比，IEC 103协议在通信速率和传输方式上进行了改进。
IEC 103协议也是由国际电工委员会（IEC）制定的标准协议，用于在电力系统、水处理、工业自动化等领域中实现设备之间的通信。
IEC 103协议基于主从结构的请求/响应模式，类似于IEC 101。主站（也称为控制中心或主控站）负责发送查询命令，而子站（也称为终端设备或远程站）负责接收并响应这些命令。
与IEC 101不同的是，IEC 103协议引入了并行传输方式，提高了通信速率。它支持多个数据传输通道，可以同时传输多个数据项，增加了数据传输的效率和容量。
IEC 103协议也使用串行通信方式，通常在电信网络中使用。它支持多种物理层和数据链路层的传输方式，如RS-232、RS-485等。
IEC 103协议主要用于传输监测数据、遥控命令和遥信信息等。通过主站向子站发送查询命令，主站可以获取子站的实时数据，并可以通过遥控命令实现对子站的控制操作。同时，IEC 103协议也支持遥信功能，用于传输设备状态、告警信息等。
需要注意的是，IEC 103协议在现代化的远程监控系统中已经逐渐被更先进的协议取代，如IEC 104和DNP3等，因为这些协议在通信速率、功能和网络适应性方面更具优势。
104规约 IEC 104（International Electrotechnical Commission 104）是一种用于远程监控和控制系统的通信协议。它是国际电工委员会（IEC）制定的标准协议，用于在电力系统、水处理、工业自动化等领域中实现设备之间的通信。
IEC 104协议是在IEC 101和IEC 103的基础上进行了更大的改进，引入了基于TCP/IP的通信方式，能够在局域网和广域网上进行通信。
IEC 104协议是一种面向连接的协议，支持双向通信和多点传输。它使用TCP/IP作为传输层协议，利用IP网络进行数据传输。这使得IEC 104协议具有更高的通信速率、更可靠的数据传输和更强的网络适应性。
IEC 104协议采用了基于报文的通信结构，主站（也称为控制中心或主控站）通过发送ASDU（Application Service Data Unit）来请求子站（也称为终端设备或远程站）的数据。子站接收到ASDU后，对其进行解析并响应主站的请求。
IEC 104协议支持多种功能，包括遥测（传输测量数据）、遥信（传输状态信息）、遥控（传输控制命令）和遥调等。它具有较高的灵活性和可扩展性，可以根据实际需求进行定制和配置。
IEC 104协议相对于IEC 101和IEC 103来说，具有更高的通信速率和更强的网络适应性，因此在现代化的远程监控系统中得到了广泛应用。它能够支持大规模的数据传输和复杂的控制操作，适用于需要高性能和高可靠性的应用场景。
iec101、iec103和iec104有什么异同点？ IEC 101、IEC 103 和 IEC 104 是用于远程监控和控制系统的通信协议。它们有一些共同点，也有一些区别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0058830b1b65dff855cb9033afcf086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d534b95035314936405bd7921790ecf/" rel="bookmark">
			鱼类识别Python&#43;深度学习人工智能&#43;TensorFlow&#43;卷积神经网络算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 鱼类识别系统。使用Python作为主要编程语言开发，通过收集常见的30种鱼类（‘墨鱼’, ‘多宝鱼’, ‘带鱼’, ‘石斑鱼’, ‘秋刀鱼’, ‘章鱼’, ‘红鱼’, ‘罗非鱼’, ‘胖头鱼’, ‘草鱼’, ‘银鱼’, ‘青鱼’, ‘马头鱼’, ‘鱿鱼’, ‘鲇鱼’, ‘鲈鱼’, ‘鲍鱼’, ‘鲑鱼’, ‘鲢鱼’, ‘鲤鱼’, ‘鲫鱼’, ‘鲳鱼’, ‘鲷鱼’, ‘鲽鱼’, ‘鳊鱼’, ‘鳗鱼’, ‘黄鱼’, ‘黄鳝’, ‘黑鱼’, ‘龙头鱼’）图片作为数据集，然后使用TensorFlow搭建ResNet50算法网络模型，通过对数据集进行处理后进行模型迭代训练，得到一个识别精度较高的H5模型文件。并基于Django框架开发网页端平台，实现用户在网页上上传一张鱼类图片识别其名称。
二、效果图片 三、演示视频 and 完整代码 视频+代码：https://www.yuque.com/ziwu/yygu3z/faw6kga47czostik
四、TensorFlow图像分类介绍 TensorFlow是一个由Google开发的开源机器学习库，它被广泛应用于各种深度学习项目，尤其在图像分类和识别方面表现出色。在图像分类任务中，TensorFlow利用其强大的神经网络算法，能够训练模型识别和区分不同的图像和对象。
图像分类是一个将图像分配到不同类别（例如猫、狗、车等）的过程。TensorFlow通过使用卷积神经网络（CNN），一种专门用于处理图像的深度学习模型，有效地完成这一任务。CNN通过模拟人类视觉系统的工作原理来识别图像中的模式和特征，如边缘、形状和纹理。
在实践中，首先需要大量的图像数据集来训练模型。训练过程包括输入图像，让网络通过其层次结构提取特征，并使用这些特征来预测图像的类别。随着训练的进行，模型逐渐学会区分不同类别的图像。
下面是一个简单的TensorFlow图像分类示例代码。这个示例使用了TensorFlow的高级API——tf.keras，来构建一个简单的CNN模型，用于分类MNIST手写数字数据集：
import tensorflow as tf from tensorflow.keras.datasets import mnist from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense, Conv2D, Flatten # 加载数据集 (train_images, train_labels), (test_images, test_labels) = mnist.load_data() # 归一化图像数据 train_images = train_images.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d534b95035314936405bd7921790ecf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/32/">«</a>
	<span class="pagination__item pagination__item--current">33/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/34/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>