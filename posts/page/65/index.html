<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/370413c2f60b2e50dc533c03ae113693/" rel="bookmark">
			docker对已经启动的容器添加目录映射(挂载目录)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 背景2. 开始新增挂载目录3. 注意 1. 背景 在自己安装sharding-proxy时，使用docker run -v的方式启动时，只挂载了/opt/shardingsphere-proxy/conf和/opt/shardingsphere-proxy/ext-lib这两个目录，忘记挂载/opt/shardingsphere-proxy/logs日志目录，导致每次查看都得要进入容器内部去查看，很是麻烦，于是考虑如何在不删除容器重新启动部署的情况下进行新目录的映射与挂载
2. 开始新增挂载目录 查看容器存放目录 [root@iZ2zedqr9yeos47fg4uor5Z proxy-a]# docker info | grep 'Root' Docker Root Dir: /var/lib/docker [root@iZ2zedqr9yeos47fg4uor5Z proxy-a]# 查看要新增挂载的容器id [root@iZ2zedqr9yeos47fg4uor5Z proxy-a]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6f5f3c195304 apache/shardingsphere-proxy:5.1.1 "/bin/sh -c '${LOCAL…" 4 days ago Up 9 minutes 0.0.0.0:3321-&gt;3307/tcp server-proxy-a 进入要新增文件夹挂载的目录 [root@iZ2zedqr9yeos47fg4uor5Z proxy-a]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6f5f3c195304 apache/shardingsphere-proxy:5.1.1 "/bin/sh -c '${LOCAL…"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/370413c2f60b2e50dc533c03ae113693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c3f086b274eb518259ba9f767e75cb3/" rel="bookmark">
			AOP切面使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、主要设计注解： @Aspect @After @before @Pointcut @Around
pom文件引入
&lt;!--用于aop切面编程--&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.aspectj&lt;/groupId&gt;
&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
&lt;/dependency&gt;
二、AOP核心概念
1、横切关注点
对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点
2、切面（aspect）
类是对物体特征的抽象，切面就是对横切关注点的抽象
3、连接点（joinpoint）
被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器
4、切入点（pointcut）
对连接点进行拦截的定义
5、通知（advice）
所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类
6、目标对象
代理的目标对象
7、织入（weave）
将切面应用到目标对象并导致代理对象创建的过程
8、引入（introduction）
在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段
execution后面参数的定义
eg.
任意公共方法的执行：execution(public * *(..))任何一个以“set”开始的方法的执行：execution(* set*(..))AccountService 接口的任意方法的执行：execution(* com.xyz.service.AccountService.*(..))定义在service包里的任意方法的执行： execution(* com.xyz.service.*.*(..))定义在service包和所有子包里的任意类的任意方法的执行：execution(* com.xyz.service..*.*(..)) 第一个*表示匹配任意的方法返回值execution(* ， ..(两个点)表示零个或多个参数，第一个..表示service包及其子包,第二个*表示所有类, 第三个*表示所有方法，第二个..表示方法的任意参数个数
注解实现：
1、引入注解
2、顶一个切面类LogAspect ，要对下面Controller下面所有类进行切面
具体代码：
@Aspect @Order(1)//指定切面的优先级 @Component @EnableAspectJAutoProxy //使aspect起作用 自动匹配代理对象 public class LogAspect { @Pointcut("execution(* com.example.springbootproject.Controller.*.*(..))")//定义在Controller包里所有类，所有的方法的任意方法的执行 public void apilog() { } @Before("apilog()") public void doBefore() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c3f086b274eb518259ba9f767e75cb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38bed16d89baac66f5ec333b7b875692/" rel="bookmark">
			Dev C&#43;&#43;调试程序方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Dev-C++(或者叫做 Dev-Cpp)是 Windows 环境下的一个轻量级 C/C++ 集成开发环境(IDE)。它是一款自由软件，遵守GPL许可协议分发源代码。它集合了功能强大的源码编辑器、MingW64/TDM-GCC 编译器、GDB 调试器和 AStyle 格式整理器等众多自由软件，适合于在教学中供 C/C++语言初学者使用，也适合于非商业级普通开发者使用。
优点与缺点 Dev-C++ 的优点是功能简洁，适合于在教学中供 C/C++语言初学者使用。
例如:
(1)它集成了 AStyle 源代码格式整理器，只要点击菜单"AStyle --&gt; 格式化当前文件"，就可以把当前窗口中的源代码按一定的风格迅速整理好排版格式。
(2)它提供了一些常用的源代码片段，只要点击"插入"按钮就可以选择性地插入常用源代码片段。
Dev-C++ 的缺点是它的功能并不完善，各方面存在着一些错误。因此它也只适合于初学者使用，而并未在商业级的软件开发中使用。
Astyle 介绍 Astyle 即Artistic Style，是一个可用于C, C++, C++/CLI, Objective‑C, C# 和Java编程语言格式化开源工具。
官网：Artistic Style - Index
百度网盘链接：https://pan.baidu.com/s/11yloLOZWK0-7bnLSM4umRA#list/path 提取码：a6de
Dev C++调试程序方法详解 所谓调试程序，就是控制编译器一行一行地有效执行代码，在调试过程中可以清楚看到每个变量值的变化情况、函数的调用过程等，进而发现程序中隐藏的错误或者低效的代码。
作为一款免费、开源的 C/C++ IDE，Dev C++ 内嵌 GCC 编译器和 GDB 调试器，既能编译、运行程序，也能调试程序。
现在以一段完整的 C 语言程序为例，系统地学一下如何用 Dev C++ 调试程序。
#include &lt;iostream&gt; using namespace std; void fn(); int main() { fn(); fn(); fn(); return 0; } void fn() { static int n = 10; cout&lt;&lt;n&lt;&lt;endl; n++; } Dev C++调试程序 1、进入调试模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38bed16d89baac66f5ec333b7b875692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9575c98a0db50632d430e30adb5804a7/" rel="bookmark">
			PIC单片机应用开发实践教程（六）： 代码配置器（MCC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码基于 PIC16F15355开发板，想了解详情，请点 PIC16F15355开发板 1、简介 MPLAB 代码配置器（MPLAB Code Configurator，MCC）通过图形用户界面（Graphical User Interface，GUI）生成驱动程序代码。生成的驱动程序可用于控制 PIC单片机上的外设。 GUI 为设置外设配置提供了一种便捷的方法。 MCC 是 MPLAB X IDE 的一个插件。 另外，MCC用于配置和生成库，这允许用户对软件库和片外外设进行配置并生成代码。 生成的驱动程序或库可用于任何 Microchip PIC 器件应用程序。在启动 MCC 插件前， MCC 需要创建 MPLAB X IDE 项目或打开现有项目。必须进行上述操作，因为 MCC 需 要了解项目中使用的器件，进而访问器件特定的信息 （如寄存器、位和配置）并设置 MCC GUI。 MCC会根据在GUI中做出的选择生成源文件和头文件，并将生成的文件添加到MPLAB X IDE 的活动项目中。
2、mplab x ide安装mcc（代码配置器） 2.1 打开tools-plugins，在打开的plugins窗口中点击 Available Plugings, 然后找到 MPLAB Code Configurator,勾选，点击Install
2.2 点击next,在跳出窗口选择agree，等待安装结束之后，restart
2.3 打开tools-Embedded-MPLAB Code Configurator，启动代码配置器
3 MCC工作区 3.1 概述 MCC 用户界面包含以下三个主要工作区，
(1). Resource Area（资源区）：该区域显示可在选定器件中使用且受 MCC 支持的片 上外设、库和片外外设。资源区包括为项目选择的项目资源和显示器件中提供的 资源和本地机器上 MCC 库版本的器件资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9575c98a0db50632d430e30adb5804a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b967b072ae6a49d34b65b41a6c250a/" rel="bookmark">
			ShardingSphere学习（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc] 第01章 高性能架构模式1、读写分离架构2、数据库分片架构2.1、垂直分片2.2、水平分片 3、读写分离和数据分片架构4、实现方式4.1、程序代码封装4.2、中间件封装4.3、常用解决方案 第02章 ShardingSphere1、简介2、ShardingSphere-JDBC3、ShardingSphere-Proxy 第03章 MySQL主从同步1、MySQL主从同步原理2、一主多从配置2.1、准备主服务器2.2、准备从服务器2.3、启动主从同步2.4、实现主从同步2.5、停止和重置**2.6、常见问题**问题1问题2 第04章 ShardingSphere-JDBC读写分离1、创建SpringBoot程序1.1、创建项目1.2、添加依赖1.3、创建实体类1.4、创建Mapper1.5、配置读写分离 2、测试2.1、读写分离测试2.2、事务测试2.3、负载均衡测试 第05章 ShardingSphere-JDBC垂直分片1、准备服务器1.1、创建server-user容器1.2、创建server-order容器 2、程序实现2.1、创建实体类2.2、创建Mapper2.3、配置垂直分片 3、测试垂直分片常见错误 第06章 ShardingSphere-JDBC水平分片1、准备服务器1.1、创建server-order0容器1.2、创建server-order1容器 2、基本水平分片2.1、基本配置2.2、数据源配置2.3、标椎分片表配置2.4、行表达式2.5、分片算法配置2.6、分布式序列算法 3、多表关联3.1、创建关联表3.2、创建实体类3.3、创建Mapper3.4、配置关联表3.5、测试插入数据 4、绑定表4.1、创建VO对象4.2、添加Mapper方法4.3、测试关联查询4.4、配置绑定表 5、广播表4.1、什么是广播表4.2、创建广播表4.3、程序实现4.3.1、创建实体类4.3.2、创建Mapper4.3.3、配置广播表 4.4、测试广播表 第07章 启动ShardingSphere-Proxy1、获取2、使用二进制发布包安装3、使用Docker安装 第08章 ShardingSphere-Proxy读写分离1、修改配置文件2、实时查看日志3、远程访问测试4、应用程序访问Proxy4.1、创建项目4.2、添加依赖4.3、创建实体类4.4、创建Mapper4.5、配置数据源4.6、测试 第09章 ShardingSphere-Proxy垂直分片1、修改配置文件2、实时查看日志3、远程访问测试 第10章 ShardingSphere-Proxy水平分片1、修改配置文件2、实时查看日志3、远程访问测试 第01章 高性能架构模式 互联网业务兴起之后，海量用户加上海量数据的特点，单个数据库服务器已经难以满足业务需要，必须考虑数据库集群的方式来提升性能。高性能数据库集群的第一种方式是“读写分离”，第二种方式是“数据库分片”。
1、读写分离架构 **读写分离原理：**读写分离的基本原理是将数据库读写操作分散到不同的节点上，下面是其基本架构图：
读写分离的基本实现：
主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。读写分离是根据 SQL 语义的分析，将读操作和写操作分别路由至主库与从库。通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升系统的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。 下图展示了根据业务需要，将用户表的写操作和读操路由到不同的数据库的方案：
CAP 理论：
CAP 定理（CAP theorem）又被称作布鲁尔定理（Brewer’s theorem），是加州大学伯克利分校的计算机科学家埃里克·布鲁尔（Eric Brewer）在 2000 年的 ACM PODC 上提出的一个猜想。对于设计分布式系统的架构师来说，CAP 是必须掌握的理论。
在一个分布式系统中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。
C 一致性（Consistency）：对某个指定的客户端来说，读操作保证能够返回最新的写操作结果A 可用性（Availability）：非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）P 分区容忍性（Partition Tolerance）：当出现网络分区后（可能是丢包，也可能是连接中断，还可能是拥塞），系统能够继续“履行职责” CAP特点：
在实际设计过程中，每个系统不可能只处理一种数据，而是包含多种类型的数据，有的数据必须选择 CP，有的数据必须选择 AP，分布式系统理论上不可能选择 CA 架构。
CP：如下图所示，为了保证一致性，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。这时客户端 C 访问 N2 时，N2 需要返回 Error，提示客户端 C“系统现在发生了错误”，这种处理方式违背了可用性（Availability）的要求，因此 CAP 三者只能满足 CP。 AP：如下图所示，为了保证可用性，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。这时客户端 C 访问 N2 时，N2 将当前自己拥有的数据 x 返回给客户端 C 了，而实际上当前最新的数据已经是 y 了，这就不满足一致性（Consistency）的要求了，因此 CAP 三者只能满足 AP。注意：这里 N2 节点返回 x，虽然不是一个“正确”的结果，但是一个“合理”的结果，因为 x 是旧的数据，并不是一个错乱的值，只是不是最新的数据而已。 CAP 理论中的 C 在实践中是不可能完美实现的，在数据复制的过程中，节点N1 和节点 N2 的数据并不一致（强一致性）。即使无法做到强一致性，但应用可以采用适合的方式达到最终一致性。具有如下特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9b967b072ae6a49d34b65b41a6c250a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f19cda864dc3c88c78f3b4150e28a9e9/" rel="bookmark">
			docker创建keepalived镜像实现高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		必要条件：
1、在服务器中安装 centos 镜像2、进入centos_01容器安装keepalived（或者keepalived+nginx），若有前端则加上nginx 环境：
前提条件 -&gt; 已在 linux 中安装好docker环境。
1、在服务器中安装 centos 镜像
下载镜像：
1
docker pull centos:7.7.1908
查看镜像：
1
docker images
安装第一个centos容器：centos_01
#f1cb7c7d58b7 就是上图中的镜像ID
sudo docker run -it --name centos_01 f1cb7c7d58b7
#然后退出容器
exit;
2、进入centos_01容器安装keepalived+nginx
进入容器：
#efbad978d17f 是容器ID
docker exec -it efbad978d17f /bin/bash
安装keepalived 和安装nginx
#安装依赖环境
yum install -y gcc openssl-devel popt-devel
#安装keepalived
yum install -y keepalived
#或者本地安装指定版本
wget https://www.keepalived.org/software/keepalived-1.3.4.tar.gz
#使用yum安装nginx需要包括Nginx的库，安装Nginx的库
rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm
# 使用下面命令安装nginx
yum install -y nginx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f19cda864dc3c88c78f3b4150e28a9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8c40441e1cf2c230c3407b0de5fb08/" rel="bookmark">
			MindSpore 1.5 版本yolov4预训练权重问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在ModelArt上申请了一个MindSpore版本为1.5.1的昇腾设备，在modelZoo上想找个yolov4来训练以下自己的数据集，但是发现MindSpore1.5的yolov4预训练权重需要自己进行训练，有没有MindSpore1.5版本的CSPDrakNet预训练权重呀，或者 1.5 的能不能用1.6的预训练权重？之前在1.6上用SSD模型跑过自己的数据集，然后再310上的1.7转om是算子报错了，那1.6的算子和1.5之间的差距是否会影响到CSP的预训练权重，可以直接提供一个1.5的CSP权重嘛
https://download.mindspore.cn/models/r1.6/cspdarknet53_ascend_v160_imagenet2012_official_cv_top1acc78.48_top5acc94.00.ckpt
可以到下载中心下载到各个版本的，比如上面的是1.6的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39c46dc281b3be69c862fd82fb70335f/" rel="bookmark">
			Simulink 使用C语言发PWM波 (二)触发采样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.定义结构体
2.定义S-Function输出端口数量
3.定义采样时间
4.初始化参数
5.用代码实现三角波载波,根据调制波配置占空比并在计数器为0时采样电感电流
6.simulink图
至此实现了电感电流使用C语言采样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5653003f7b0f13fc49e54472ffc084e9/" rel="bookmark">
			Simulink 使用C语言发PWM波 (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在matlab中安装C语言模块mingw 2.在simulink中引用S-Function模块 和S-Function Examples模块
3.使用S-Function Examples模块创建C文件,双击S-Function Examples模块后再选择C-file再选择basic C-Mex
4.将创建的C文件模板另存到仿真文件所在文件夹,并将文件名重命名为工程名称如Boost.c,在S-Function中将名称更改为C文件名如Boost,在C的宏定义中将S_FUNCTION_NAME 后面名称改为文件名
5.在simulink中设置的 model properties中的initfcn中输入mex Boost.c,这样matlab在仿真前会先编译所生产的C文件
6.修改.c文件中的采样时间
7.修改S-Function的输入输出,如果为默认下图形式,并且将输入连接到采样,输出连接到示波器,会发现波形为100K的采样波形,到此就实现了采样保持器
8.使用C发PWM波 a.定义结构体变量Cnt和周期
b.初始化结构体变量,其中400为周期,计算方法为PWM的频率除以采样时间
Prd = Fre/Slample 例程中开关频率为100K(1e-5) 采样时间为2.5e-8
c.添加S-Function输出端口数量,如下改为2可以有两组输出
d.在模块中执行PWM运算,即可在示波器中看到PWM波
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda09ab72b759bf155c4e1791c0f1328/" rel="bookmark">
			PIC单片机应用开发实践教程（一）：MPLAB X IDE 开发环境安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码基于 PIC16F15355开发板，想了解详情，请点 PIC16F15355开发板 1 准备电脑一台 2 下载开发环境 MPLAB-X-IDE
点Download后，自动下载。 3 下载C编译器（以8位MCU用的xc8编译器为例） MPLAB XC8 Compiler
4 安装MPLAB-IDE 双击下载的MPLAB-IDE安装包进行安装
设置安装目录，根据自己电脑实际情况进行设置
注意：不能有中文路径
选择开发平台，默认全选，当然也可以单独选择，建议只安装自己所需要的即可。
然后，点击 Next，等待安装完成。
​​​​​​
安装完成后，会在桌面生成快捷菜单
打开后如下图，就可以正常使用了
5 安装xc8编译器 双击下载的编译器安装包进行安装
选择安装路径，最好和X IDE开发环境安装路径一致,如不想修改默认即可
最好勾选添加编译器到环境变量路径，不然还需要在IDE环境中手动添加
6 查看编译器是否正确安装 菜单---Tools---Options
选择Embedded选项卡下的Build Tools页
可以看到所安装的编译工具
如果上面安装xc8时，没有勾选添加到环境变量路径选项
Add xc8 to the PATH environment variable 前的勾没有选上
就需要手动添加编译工具，点击 Add
找到刚才安装的路径，添加进来就可以
至此，编译工具已经添加完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a3ab5ea40938eb01d095649e36bd562/" rel="bookmark">
			Navicat 现已支持 OceanBase 企业版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，PremiumSoft CyberTech Limited 公司发布了 Navicat 16.1.3 版本，正式支持蚂蚁集团旗下的 OceanBase 企业版（MySQL 兼容模式）。此次合作旨在帮助用户通过 Navcicat 进行 OceanBase 企业版的数据库开发及管理，更大程度地减少项目开发和管理的时间与成本。
Navicat Premium 连接 OceanBase 界面
Navicat作为 OceanBase 生态工具的合作伙伴，这是双方产品适配第二个的里程碑。今年7月份的首个里程碑，Navicat 已实现 OceanBase 社区版的功能性兼容。这次发布的新版本，进一步实现了针对 OceanBase 企业版（ MySQL 兼容模式）的接入和管理开发能力。目前，Navicat 还在积极测试 OceanBase 企业版（Oracle 兼容模式），预计最快明年发布。
Navicat 旗下最畅销的两款工具Navicat Premium 和 Navicat for MySQL 在最新发布的16.1.3版本中，已实现OceanBase 企业版（MySQL 兼容模式）3.2.3版本的适配能力，涵盖的功能包括：数据库连接、SQL 处理、协同工作、数据查看器和编辑器、数据可视化、数据建模、导入导出、结构同步、数据传输、数据同步、数据生成、表设计、视图设计、功能设计、备份与恢复、用户设计、服务器监控等。
此外，Navicat Premium 还能满足用户使用单一应用程序同时连接多种主流的数据库的需求。除本次合作的 OceanBase 外，还支持同时连接MySQL、MariaDB、Oracle、MongoDB、SQL Server、PostgreSQL 和 SQLite 数据库。这极大地满足了企业和用户在不同场景部署与管理多种数据库的个性化需求。
相关下载信息 - 点击 这里，下载 OceanBase 企业版（MySQL 兼容模式）。
- 点击 这里，下载 Navicat Premium 全功能试用版。
关于 OceanBase OceanBase 始创于 2010 年，是完全自主研发的企业级原生分布式数据库，连续 9 年稳定支撑双 11，凭借高性能和高可用真正实现应用无限扩展和服务永远在线 ，致力于为企业核心系统提供稳定可靠的数据底座。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a3ab5ea40938eb01d095649e36bd562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd5010c213bdfe6281bf42b3a88218d0/" rel="bookmark">
			flutter新项目导入运行时出现Unsupported class file major version 62
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FAILURE: Build failed with an exception.
Compiling settings file ‘E:\Plane\build\jsb-link\frameworks\runtime-src\proj.android-studio\settings.gradle’ using BuildScriptTransformer.
What went wrong:
Could not open settings generic class cache for settings file ‘E:\Plane\build\jsb-link\frameworks\runtime-src\proj.android-studio\settings.gradle’ (C:\Users\Angel.gradle\caches\6.7.1\scripts\4k9ijk2w469rcga7h4uxfsoka). BUG! exception in phase ‘semantic analysis’ in source unit ‘BuildScript’ Unsupported class file major version 62
可以看一下你的gradle-wrapper.properties文件中gradle的版本
如果你使用的javajdk的版本比较高呢尽量升级一下gradle版本
我这边使用的是distributionUrl=https://services.gradle.org/distributions/gradle-7.2-bin.zip
仅供参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bb77d191385be25afd64b6523607893/" rel="bookmark">
			基于Python实现的合同管理系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细设计说明书
1．引言 1
1.1编写目的 1
1.2项目背景 1
1.3定义 2
1.4参考资料 2
2．总体设计 2
2.1需求概述 2
2.2软件结构 2
3．程序描述 2
3.1功能 2
3.2性能 2
3.3输入项目 2
3.4输出项目 2
3.5算法 2
3.6程序逻辑 2
3.7接口 2
3.8存储分配 2
3.9限制条件 2
3.10测试要点 2
1.2项目背景
系统名称：合同管理系统 开发语言：JAVA 开发工具：MyEclipse
WEB服务器：Tomcat+Apache结合。Tomcat解析JSP/Servlet，Apache解析静态HTML文件；
数据库：SQL Server2005 开发环境：Windows 10
开发人员：
1.3定义
SQL SERVER:系统服务器所使用的数据库管理系统（DBMS）。
SQL:一种用于访问查询数据库的语言。
类图(class diagram):表述系统中各个对象的类型及其间存在的各种静态关系。 交互图(interactive diagram):是表述各组对象如何依某种行为进行协作的模型。
SQL(Structured Query Language):结构化查询语言。
1.4参考资料
a.项目开发计划；
b.需求规格说明书；
c.概要设计说明书；
d.测试计划（初稿）；
e.用户操作手册（初稿）；
f.文档中所引用的其他资料、软件开发标准或规范
2．总体设计
2.1需求概述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bb77d191385be25afd64b6523607893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bfcaf5b3d0afe0b8defccc920051167/" rel="bookmark">
			Springboot调整接口响应返回时长（解决响应超时问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Springboot调整接口/会话响应返回时长（解决响应超时问题） 配置Http会话超时 可以通过两种方式为Spring Boot应用程序配置HTTP会话超时。
application.properties中配置会话超时 最简单的方法是在你的application.properties中加入参数server.servlet.session.timeout。比如说
server.servlet.session.timeout=60s 还要注意的是，Tomcat不允许你将超时时间设置得少于60秒。
以程序方式配置会话超时 假设我们想让我们的HttpSession只持续两分钟。为了实现这一点，我们可以在我们的WebConfiguration类中添加一个EmbeddedServletContainerCustomizer Bean，内容如下。
@Configuration public class WebConfiguration { @Bean public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer() { return new EmbeddedServletContainerCustomizer() { @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setSessionTimeout(2, TimeUnit.MINUTES); } }; } } 这里再给出一个使用Java 8和lambda表达式的捷径写法。
public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer() { return (ConfigurableEmbeddedServletContainer container) -&gt; { container.setSessionTimeout(2, TimeUnit.MINUTES); }; } 在应用程序启动期间，Spring Boot自动配置检测到EmbeddedServletContainerCustomizer，并调用customize(…)方法，传递对Servlet容器的引用。
配置接口访问超时 SpringBoot设置接口访问超时时间有两种方式
一、配置文件方式 在配置文件application.properties中加了spring.mvc.async.request-timeout=120000，意思是设置超时时间为120000ms即120s
# [设置接口的超时时间] spring.mvc.async.request-timeout=120000 二、配置Config配置类 还有一种就是在config配置类中加入：
public class WebMvcConfig extends WebMvcConfigurerAdapter { @Override public void configureAsyncSupport(final AsyncSupportConfigurer configurer) { configurer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bfcaf5b3d0afe0b8defccc920051167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293c9c14d4d27d7c9869aac8b2e49d8a/" rel="bookmark">
			一篇让你彻底解决java:无效的目标发行版: 11或其它版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题及原因 平时工作学习中我们在使用idea开发中经常会遇到以下问题，java:“无效的目标发行版: 11、14”冲突。如下图：
出现问题的原因是：你clone 别人的代码。你的jdk版本为java8 或者更低，但是别人的JDK属于java11 或者java14。导致项目jdk和本地jdk版本不一致，所以会出现以下的问题，那应该如何解决呢？
2.解决 一般需要三个步骤就能彻底解决这个问题。部分同学可能需要四个步骤。
2.1步骤1 打开文件下的Project Structure 如下图：
把红色框中的改为你目前的jdk版本，我现在为jdk8,所以改为1.8
2.2步骤2 继续打开 Modules 模块修改每个项目中的 language level.切记是每个项目。如果只有那只就修改一个就行。我这里只有1个项目，所以只对这个项目进行修改。
2.3步骤3 一定要注意，很多网上的教程到这里就没有了，但是你还是会发现继续无效的目标发行版: 11这个问题，那么这个时候怎么办呢？？
打开文件下的settings，继续修改如下图：
到这里一般情况下重新编译项目然后启动可以正常启动。如果还报刚刚那个错误，请继续往下看
2.4步骤4 打开项目的pom.xml文件
找的你的java.version版本号改成8，没有的话就手动创建一个
最后找到org.apache.maven.plugins这行，把里面的configuration内容替换成下面格式
3.成功 4.后续问题 当你修改完之后你会发现项目有问题，比如有些高版本项目中给对象判空处理直接.isEmpty()
，但是在Java 9之前,您需要使用Object.isEmpty()而不是.isEmpty(),等以下问题，所以当你修改完之后就可以放心使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da7ad389a4970b607eaefb97c4db0e9/" rel="bookmark">
			修身以俟，顺受其正。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修身以俟，顺受其正。
知是心之本体，心自然会知：见父自然知孝，见兄自然知弟，见孺子入井自然知恻隐。
大学之道，在明明德，在亲民，在止于至善。
是什么：心即理。一直在说致良知，何谓良知。良知即是心之本体，亦即天理。
怎么办：知行合一。尽夫天理之极，而无一毫人欲之私。
为什么：为安心立命。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd9bdeb91edd216ac7e084d7feae0c12/" rel="bookmark">
			[免费]CAD批量清理与版本转换工具——无需打开图纸清理及转换版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件功能 CAD图纸批量清理、垃圾文件删除、图纸版本转换软件。
批量清理指定文件夹下（可包含子文件夹）的全部*.dwg图纸文件，清理效果等同于使用AutoCAD打开图纸后执行PURGE清理命令并勾选所有可清理选项，但本软件清理过程中不打开CAD图形界面，因此清理效率更高。在清理前识别图纸文件版本，以跳过当前CAD无法打开的图纸。批量删除*.bak、*.dwl、*.dwl2等垃圾文件，且可自定义要删除的垃圾文件类型。批量将图纸转换为指定版本保存。 以上三个功能可独立或组合使用。
使用方法 使用本软件前需安装AutoCAD 2013或更高版。
选择用于清理图纸的AutoCAD；
选择文件夹，可点“选择文件夹”按钮选择文件夹，或拖放文件夹到窗体空白处，若要清理子文件夹中的图纸，需勾选“包含子文件夹”选项；
视需求使用以下功能：
CAD图纸批量清理：“勾选清理图纸”复选框。垃圾文件批量删除：勾选 “删除垃圾文件”复选框，可设置要清理的垃圾文件类型。图纸文件版本批量转换：选择要保存的文件版本。 注意：若要仅批量删除垃圾文件，则不要勾选“清理图纸”且选择“保持文件版本不变”。
最后点“开始清理”以执行清理，点“终止”可提前结束清理。 下载地址 “CAD批量清理与版本转换工具”完全免费，可到【依云软件官网】（yiyunsoftware.com）下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d24e05e328dc6fb66b7d9aa13ef797c/" rel="bookmark">
			CAD弹窗拦截器/CAD字体自动替换工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当打开陌生图纸，有时仅仅是为了查看图纸，却常常遭遇大量字体弹窗；若是要批处理图纸，例如批量打印，弹窗更是致命的阻塞。CAD弹窗拦截器为解决这个问题而生！
不同于AutoCAD本身支持的编辑acad.fmp文件自动替换字体功能，其不支持通配符，也就是说需要先知道被替换字体的确切名称才能设置替换字体；本弹窗拦截自动替换字体功能支持通配符，可将未知体模糊替换为已安装的字体。还可拦截众多通常不必要的弹窗。
弹窗拦截功能 字体弹窗 自动替换字体自动取消选择形文件自定义字体替换规则其它弹窗 关闭教育版提示关闭外来DWG文件提示关闭只读提示关闭更新AEC对象提示不显示代理实体警告及设置代理实体显示方式 弹窗拦截效果演示 没有弹窗拦截打开图纸，手动替换字体及关闭弹窗：
开启弹窗拦截打开图纸，自动替换字体及关闭弹窗：
注意：使用弹窗拦截功能需先打开AutoCAD，后打开图纸。
下载地址及使用方法 “CAD弹窗拦截器”为“CAD批量打图精灵试用版”最新版的一个功能，安装其后该功能可单独使用，可到【依云软件官网】（yiyunsoftware.com）下载。
安装“CAD批量打图精灵试用版”后，打开打图精灵，切换到“更多可选设置”标签下，点击“CAD弹窗拦截”按钮，打开“CAD弹窗拦截器”，勾选“启用”以开启弹窗拦截功能，更详细的说明见官方文档。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a423a41dd5d1f25132ec998e2d95786e/" rel="bookmark">
			如何使用MCP2518FD外部CAN FD控制器实现速速CAN通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MCP2518FD外部CAN FD控制器具有小尺寸和SPI接口，可实现轻松连接。可将CAN FD通道轻松添加到缺少CAN FD外设或没有所需CAN FD通道的微控制器上。MCP2518FD支持经典格式 (CAN 2.0B) 和CAN灵活数据速率 (CAN FD) 格式中的CAN帧格式，符合ISO11898-1:2015标准。
框图：
本文实验板MCU：STM32F103C8T6
CAN FD控制器：MCP2518FD
CAN FD收发器：ATA6560
开发环境：Keil uVision5.28
想了解开发板更详细信息，请点击 MCP2518FD学习评估套件
MCP2518FD学习评估套件 电路图如下：
典型应用
上图有两部分组成，一部分是CAN控制器mcp2518fd，另一部分就是CANFD收发器ATA6563，我们实验板上用的是ATA6560，和ATA6563 PIN to PIN。
对于CAN 收发器，有两个引脚要特别注意，就是STBY和NSIL引脚，这两个引脚的状态控制CAN收发器工作状态，如下图：
CAN收发器STBY接地，VIO（NSIL）接3.3v，VDD接5V，VSS接地。
1、SPI时序 我们要配置寄存器，要通过SPI总线发数据过去，相对于外设就是SDI接口的数据：Command + Address + Data.
第一个字节：4位命令+4位地址；第二个字节：8位地址；第三个字节及以后：都是数据； 所以往寄存器写一个字节时序可以这么写：
// write one byte
spiTransmitBuffer[0] = (uint8_t) ((CMD &lt;&lt; 4) + ((ADDR &gt;&gt; 8) &amp; 0xF)); // 4位指令码+地址高4位
spiTransmitBuffer[1] = (uint8_t) (ADDR&amp; 0xFF); // 地址低8位
spiTransmitBuffer[2] = txdata; // 数据位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a423a41dd5d1f25132ec998e2d95786e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6697db7de04008ce157f44949dd8fb84/" rel="bookmark">
			数据结构（三）——LinkList与链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.链表 1.1链表的概念 链表是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的 。
1.2链表的结构 注意：
1.由此可得，链表在逻辑上是连续的，但是在物理上并不一定连续
2.现实中节点一般都是从堆上申请出来的，而每次从堆上申请的空间位置都是随机的。
1.3链表的实现 public class SingleLinkedList { //初始化 private static class Node{ int value; SingleLinkedList.Node next; public Node(int value){this.value=value;} } //头节点 public SingleLinkedList.Node head; //头插法 public void addFirst(int data){ SingleLinkedList.Node node=new SingleLinkedList.Node(data); node.next=head; head=node; } //尾插法 public void addLast(int data){ //首先new一个新节点 SingleLinkedList.Node node=new SingleLinkedList.Node(data); //判断链表是否为空 if(head==null){ head=node; return; } //临时变量current SingleLinkedList.Node current=head; while(current.next!=null){ current=current.next;//寻找尾节点 } current.next=node;//将尾节点next域指向新节点进行连接 } //任意位置插入,第一个数据节点为0号下标 public void addIndex(int index,int data){ checkIndex(index); if(index==0){ addFirst(data); return; } if(index==size()){ addLast(data); return; } Node node=new Node(data); Node prevNode=finprevNode(index); node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6697db7de04008ce157f44949dd8fb84/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/64/">«</a>
	<span class="pagination__item pagination__item--current">65/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/66/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>