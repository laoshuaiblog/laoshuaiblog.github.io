<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36989da4a6ee239dd91ea4a45735bdd1/" rel="bookmark">
			Weblogic，静默安装！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装JDK 第一步 安装软件
首先，将下载好的JDK文件放到/root目录中。
切换到 /usr/lib目录下
cd /usr/lib
新建jdk目录
sudo mkdir jdk
解压安装包
tar zxvf jdk-8u202-linux-x64.tar.gz -C /usr/lib/jdk/
第二步 配置java环境变量
这里是将环境变量配置在etc/profile，即为所有用户配置JDK环境。
使用命令打开/etc/profile文件
sudo vi /etc/profile
在末尾添加以下几行文字：
#set java env
export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_202
export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH
执行命令使修改立即生效
source /etc/profile
第三步 测试安装是否成功
在终端输入，出现版本号则表示安装成功！ java -version
出现版本即安装成功！
安装Weblogic useradd weblogic
passwd weblogic
密码：Weblogic123456
密码：Weblogic123456
mkdir /opt/weblogic
解压后上传，weblogic安装包：
fmw_14.1.1.0.0_wls_lite_generic.jar
mv fmw_14.1.1.0.0_wls_lite_generic.jar /opt/weblogic/
chown -R weblogic:weblogic /opt/weblogic
cd /opt/weblogic/
touch oraInst.loc
vi oraInst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36989da4a6ee239dd91ea4a45735bdd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70bc7aba7825d03d232417666f02bfb/" rel="bookmark">
			如何在CentOS使用Docker运行Nacos容器并实现无公网IP远程访问UI界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Docker 运行Nacos2. 本地访问Nacos3. Linux安装Cpolar4. 配置Nacos UI界面公网地址5. 远程访问 Nacos UI界面6. 固定Nacos UI界面公网地址7. 固定地址访问Plik Nacos是阿里开放的一款中间件,也是一款服务注册中心，它主要提供三种功能：持久化节点注册，非持久化节点注册和配置管理。
本例通过结合Cpolar内网穿透实现远程访问Nacos 提供的UI (控制台)界面,帮助管理所有的服务和应用的配置
Cpolar内网穿透是一种安全的内网穿透云服务，可以将内网下的本地服务器通过安全隧道暴露至公网，使得公网用户可以正常访问内网服务。它支持HTTP、HTTPS、TCP协议端口映射。
下面开始介绍在Docker运行Nacos并安装Cpolar 工具实现远程访问.
1. Docker 运行Nacos 执行Docker一键运行命令,下面是对应的命令参数解释,当然,不一定是docker部署,本例为了方便演示远程访问Nacos UI界面,所以采用docker快速部署方式.
docker run --name nacos -d -p 8848:8848 -p 9848:9848 -p 9849:9849 --privileged=true --restart=always -e MODE=standalone -e PREFER_HOST_MODE=hostname nacos/nacos-server:2.0.3 --name nacos：指定容器名称为 “nacos”，可根据自己的需要自定义修改名称 -d：在后台模式下运行容器 -p 8848:8848 -p 9848:9848 -p 9849:9849：将容器的端口 8848、9848 和 9849 映射到主机的相应端口，可以根据需要进行端口映射的修改。 --privileged=true：给容器赋予特权模式，以便容器内的进程可以访问主机的部分资源。 --restart=always：设置容器总是在退出后自动重启。 -e MODE=standalone：设置 Nacos 启动模式为单机模式。 -e PREFER_HOST_MODE=hostname：设置容器主机名作为 Nacos 的拓扑节点名称。 nacos/nacos-server:2.0.3：基于 nacos/nacos-server 镜像的 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d70bc7aba7825d03d232417666f02bfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f55521877df7ae3610f6858c0f682b/" rel="bookmark">
			uniapp vue-cli项目配置devServer和outPutDir
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 上一次说了使用vue-cli创建uni-app项目，然后使用第三方工具开发打包，利用jekins发布等。
这一次我想解决以下问题：
1我想配置devServer供开发环境使用，这样也可以解决开发环境的跨域问题
2以前我的每个版本信息都配置在package,json---uni-app----scripts里,然后配置不同的打包脚本：npm run build:custom h5-test(\(h5-prod),这样虽然能满足使用，但是每次部署新环境就要加对应的配置信息，操作起来还是有点繁琐，我想把他改为根据url自动识别api地址，这样就能一劳永逸，部署多少版本我都不用动代码了。
3能根据url自动识别api后，那我也就不需要设置多个打包脚本，我只用跟常规vue项目一样，npm run build就可以了，但是输出路径还是不一样，默认在dist/build/h5,我想改成跟常规vue项目一样，在dist下
一、配置devserver,需要在manifest.json文件的h5属性里配置以下代码
"devServer": { "proxy": { "/api": { "target": "https://www.qq.com", "changeOrigin": true, "ws": true, "secure": false } } } 配置完竟然不生效，发现在代码里根据环境设置了api地址，把开发环境的设为空，线上环境取路径url
const BASE_URL=process.env.NODE_ENV==='development'?'':window.location.host 如果请求的时候是用BASE_URL+API路径，那就注释掉
这样就可以代理请求访问api了，还解决跨域问题了。
二、以前都是每个版本在packages.json文件下配置 uni-app--scripts。现在直接注释掉就行。现在好了，url发布后岁路径变化，所以我就只需要npm run build一个打包命令就可以了，运行时自动会识别路径地址
三、在npm run build对应的命令中增加红色部分，这样打包产物就会在dist文件下，而不会还有build/h5了
"build": "cross-env NODE_ENV=production UNI_PLATFORM=h5 UNI_OUTPUT_DIR=dist vue-cli-service uni-build", 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0706fbd7ce8916af2cf64fcf970d075e/" rel="bookmark">
			Android CMakeLists.txt不同渠道加载对应目录动态库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在 Android JNI 开发中的 CMakeLists.txt 文件中根据不同渠道加载不同的动态库，可以通过在 build.gradle 中定义 productFlavors，并为每个 flavor 指定不同的 CMake 变量，然后在 CMakeLists.txt 中根据这些变量来加载对应的动态库。
首先，在 build.gradle 文件中定义 productFlavors 并为每个 flavor 指定对应的 CMake 变量
android { ... flavorDimensions "channel" sourceSets { flavor1 { jniLibs.srcDirs = ['src/main/jniLibs_flavor1'] } flavor2 { jniLibs.srcDirs = ['src/main/jniLibs_flavor2'] } } productFlavors { flavor1 { dimension "channel" externalNativeBuild { cmake { arguments "-DCHANNEL=flavor1" } } } flavor2 { dimension "channel" externalNativeBuild { cmake { arguments "-DCHANNEL=flavor2" } } } } } 为两个不同的 productFlavors 定义了对应的 CMake 变量。根据不同的 flavor，会传递不同的标志给 CMake。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0706fbd7ce8916af2cf64fcf970d075e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3520c71ebdb17a39aac2eb6e14924f6e/" rel="bookmark">
			基于ssm汽车养护管理系统论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 现代经济快节奏发展以及不断完善升级的信息化技术，让传统数据信息的管理升级为软件存储，归纳，集中处理数据信息的管理方式。本汽车养护管理系统就是在这样的大环境下诞生，其可以帮助管理者在短时间内处理完毕庞大的数据信息，使用这种软件工具可以帮助管理人员提高事务处理效率，达到事半功倍的效果。此汽车养护管理系统利用当下成熟完善的SSM框架，使用跨平台的可开发大型商业网站的Java语言，以及最受欢迎的RDBMS应用软件之一的Mysql数据库进行程序开发。实现了房屋基础数据的管理.汽车养护管理系统的开发根据操作人员需要设计的界面简洁美观，在功能模块布局上跟同类型网站保持一致，程序在实现基本要求功能时，也为数据信息面临的安全问题提供了一些实用的解决方案。可以说该程序在帮助管理者高效率地处理工作事务的同时，也实现了数据信息的整体化，规范化与自动化。
关键词：汽车养护管理系统；SSM框架；Mysql；自动化
Abstract The fast-paced development of the modern economy and the continuous improvement and upgrading of information technology have allowed the management of traditional data information to be upgraded to software storage, induction, and centralized management of data information. This book lending system was born in such a large environment, which can help managers to process huge data information in a short time. Using this software tool can help managers improve transaction processing efficiency and achieve double the result with half the effort.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3520c71ebdb17a39aac2eb6e14924f6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca8ed3824c4dc58f17bd99065cf3ad02/" rel="bookmark">
			ZK友好代数哈希函数安全倡议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引言 前序博客：
ZKP中的哈希函数如何选择ZK-friendly 哈希函数？snark/stark-friendly hash函数Anemoi Permutation和Jive Compression模式：高效的ZK友好的哈希函数Tip5：针对Recursive STARK的哈希函数 随着Incrementally Verifiable Computation（IVC）的发展，需要在电路内高效的哈希函数，电路中的算术表示是基于素数域的，而不是二进制域，因此需要对素数域表示友好的哈希函数。
哈希函数在IVC中的用途有：
Merkle tree opening proofs：Merkle tree opening证明Fiat-Shamir-transformed protocols：Fiat-Shamir转换协议Compression in recursive SNARKs：递归SNARKs中的压缩Provenance proofs：出处证明 当前设计的ZK友好哈希函数有：
这些ZK友好哈希函数可分为如下三大类：
尽管已设计了大量ZK友好哈希函数，但当前的问题在于：
不知道这些ZK友好哈希函数是否安全 其中有一些暂未被破解，但这并不代表其足够安全 因此，需要对这些ZK友好哈希函数有更多信心，为此以太坊基金会发起了：
1）ZK Hash Function Cryptanalysis Bounties 2021
其中包含了：
最有趣方案的简化版本奖励随目标强度和补充材料而增加 需要的反馈有：
弱化版本任何公平性问题规则评论 2）研究愿望清单：
对大量（因贡献低而）常被会议拒绝的（Groebner basis、大幅修改变种、增量成果）论文感兴趣。而以太坊基金会，对，所有与代数哈希函数安全性相关的论文，都感兴趣。这些被拒的论文可转投给以太坊基金会的研究愿望清单。 需要的反馈是：
相关建议 3）Special Journal Editions，期刊特刊
4）Extra entries in calls for papers，论文征集中的额外条目
参考资料 [1] 2024年3月25日FSE 2024 Rump Session视频以太坊基金会Dmitry Khovratovich分享 Algebraic Hashes Initiative
[2] 2024年3月25日至2024年3月29日比利时鲁汶30th Fast Software Encryption Conference
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81f281e82c5f1d095388a51e98ffd7bc/" rel="bookmark">
			pgAdmin4可视化软件如何设置中文显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下，pgAdmin4的界面显示语言是使用English，但是英语不好的小伙伴初次使用可能不知道如何在哪里设置软件的界面语言，本章教程主要简单介绍如何将本软件的默认语言设置成中文显示。
目录
一、打开软件pgAdmin4
二、设置界面用户语言
一、打开软件pgAdmin4 首先，你需要确保在电脑中安装过了PostgreSQL和pgAdmin4，然后打开运行软件。 二、设置界面用户语言 设置操作路径：
1、点击菜单【File】—【Preferences】，打开偏好设置。
2、在左侧找到【User Language】，右侧点击下拉框，选择 【简体中文】，然后点击【Save】保存。
然后就大功告成了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b485e652e176718231632cdc59e726/" rel="bookmark">
			【二叉树】Leetcode 230. 二叉搜索树中第K小的元素【中等】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉搜索树中第K小的元素 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。
示例1：
输入：root = [3,1,4,null,2], k = 1
输出：1
解题思路 二叉搜索树的中序遍历结果是有序的，因此可以通过中序遍历来找到第k个最小元素。
1、进行中序遍历二叉搜索树，递归地遍历左子树、当前节点、右子树。2、使用一个全局变量count记录当前已经遍历到的节点个数。3、在每次遍历到一个节点时，count加1，如果count等于k，则返回当前节点的值。4、如果count小于k，则继续递归遍历右子树。 Java实现 public class KthSmallestBST { static class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } } private int count; private int result; public int kthSmallest(TreeNode root, int k) { count = 0; result = 0; inorderTraversal(root, k); return result; } private void inorderTraversal(TreeNode root, int k) { if (root == null || count &gt;= k) { return; } // 中序遍历，先访问左子树 inorderTraversal(root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b485e652e176718231632cdc59e726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10ff644bf214b44e134847ecb990d4a1/" rel="bookmark">
			【二叉树】Leetcode 98. 验证二叉搜索树【中等】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		验证二叉搜索树 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 示例1：
输入：root = [2,1,3]
输出：true
示例2：
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4
解题思路1 判断一个二叉树是否是有效的二叉搜索树，可以通过中序遍历的方式来检查节点值是否按照升序排列。
1、进行中序遍历二叉树，递归地遍历左子树、当前节点、右子树。2、在遍历过程中，记录上一个节点的值prev，初始值为负无穷。3、每次访问一个节点时，比较当前节点的值与prev的值，如果当前节点的值小于等于prev的值，则二叉树不是有效的二叉搜索树。4、更新prev的值为当前节点的值。5、递归遍历左右子树，直到所有节点都遍历完毕 java实现1 public class IsValidBST { static class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } } TreeNode prev = null; public boolean isValidBST(TreeNode root) { return isValidBSTHelper(root); } private boolean isValidBSTHelper(TreeNode root) { if (root == null) { return true; } // 判断左子树 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10ff644bf214b44e134847ecb990d4a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b92ca1d1efeed2140824db8aba6b41/" rel="bookmark">
			❤️算法笔记❤️-(每日一刷-83、删除排序链表中的重复项)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目思路解答 题目 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。
示例 1：
输入：head = [1,1,2] 输出：[1,2] 示例 2：
输入：head = [1,1,2,3,3] 输出：[1,2,3] 提示：
链表中节点数目在范围 [0, 300] 内-100 &lt;= Node.val &lt;= 100题目数据保证链表已经按升序 排列 Related Topics
链表
👍 1115
👎 0
思路 快慢指针法其实这个和数组那个去重思路一模一样 解答 //给定一个已排序的链表的头 // head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 // // // // 示例 1： // // //输入：head = [1,1,2] //输出：[1,2] // // // 示例 2： // // //输入：head = [1,1,2,3,3] //输出：[1,2,3] // // // // // 提示： // // // 链表中节点数目在范围 [0, 300] 内 // -100 &lt;= Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b92ca1d1efeed2140824db8aba6b41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff1b4b83e0e42a06a0f54708501b62cf/" rel="bookmark">
			Cisco FirePower FMCv与FMC 300v部署 （待完善）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Cisco FirePower FMCv与FMC 300v部署 （待完善） 常见问题 版本可以降级吗？比如从7.2.5降级到7.2.3 FMC的版本只支持upgrade , 不支持downgrade
镜像文件的作用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b8d9a8cce5709a9c4c2a31cbc523b3/" rel="bookmark">
			软考中级(网络工程师考核要点)第一章 计算机网络系统(信道特性应用)第五期（曼彻斯特和差分曼彻斯特）重点考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补充上面一节小内容
双极性码是一种数字编码方式，用于在数据传输中表示二进制数据。它的特点是在传输过程中，数据信号在正电平和负电平之间交替变化，即信号值是正、负两种电压之间切换的。
在双极性码中，一般规定正电平表示二进制0，负电平表示二进制1。数据信号在传输过程中，每个位的间隔内都会出现一个电平转换，这样可以保持传输线路上的直流电平平衡，减少传输中可能产生的电流漂移问题。
双极性码的一个常见例子是非归零码（Non-Return-to-Zero, NRZ）码，它是常用的一种数据编码方式。在NRZ码中，高电平代表二进制0，低电平代表二进制1。在NRZ码中，数据信号的电平保持不会出现切换，因此它的传输速率相对较慢，易受到噪声的干扰。
双极性码还有其他变种，如差分双极性码（Differential Manchester Code, DMC）、双相码（Biphase Code）等，它们在电平变化规则和编码方式上略有不同，但都遵循了双极性码的基本概念。
典型会考的有：AMI信息交替反转编码---用零电平表示0,1则使电平在正负极间交替反转的数据编码
三极性码(仅做了解)
三极性码是一种数字编码系统，用于表示二进制数字。它由三个数字组成，分别表示正数、负数和零。
表示正数时，用0表示；负数时，用1表示；零时，用2表示。
例如，表示数字5的三极性码为：002
表示数字-5的三极性码为：111
表示数字0的三极性码为：222
需要注意的是，三极性码中的每个数字都是独立的，没有特殊的位数或顺序要求。
第四期的解析和答案
1.
分析:本题的考点就是对单极性码、极性码、双极性码的熟悉程度。按照上面的知识要点，可以得出这个是AMI，所以这题选C。
曼彻斯特编码的原则是：将数字0表示为高电平到低电平的跳变，将数字1表示为低电平到高电平的跳变。这样的编码方式使得每个时间间隔中信号的电平都会发生变化，可以保证信号的同步性和可靠性。
差分曼彻斯特定义:
逻辑1被编码为从高电平到低电平的过渡。即，当前的信号与前一个信号相比发生了过渡，表示逻辑1。逻辑0被编码为从低电平到高电平的过渡。即，当前的信号与前一个信号相比发生了过渡，表示逻辑0。 需要注意的是，差分曼彻斯特编码中并没有使用具体的电平来表示逻辑1和0，只通过过渡来表示。所以在实际的传输中，还需要将编码后的信号与特定电平相对应，以便接收方进行解码。
曼彻斯特和差分曼彻斯特效率只有50%，用于以百兆太网。
题目:
1.
2.
3.
4.
5.
6.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2da79ea2e40f4329328ee05c6258544/" rel="bookmark">
			aidl文件生成Java、C&#43;&#43;[android]、C&#43;&#43;[ndk]、Rust接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、Java二、C++[android]三、C++[ndk]四、Rust接口 前言 在 Android 开发中，AIDL 文件通常会被自动编译，生成对应语言的接口文件。对于应用层 Java 开发者来说，使用 AIDL 和 Binder 封装的接口可以让他们更加专注于应用逻辑，而不需要过多关注 Binder 的调用细节或 AIDL 的编译过程。
然而，对于中下层开发者来说，包括 framework 和 native 层开发，可能需要编写 native service，并且有必要理解 Binder 的底层机制。
关于编译 AIDL 文件的过程，通常是由构建系统自动完成。在编译过程中，AIDL 文件会被处理并生成相应的接口文件，以便后续开发使用。生成的接口文件内容会根据具体的需求和语言类型而有所不同，可以根据生成的接口文件来进行后续的开发工作。
如果使用 SDK 中的 aidl 工具，需要将其路径添加到系统的 PATH 环境变量中。通常位于路径：~/Android/Sdk/build-tools/33.0.2/aidl。而如果使用源码中的 aidl 工具，则在设置好源码编译环境后，这个工具会自动添加到系统的 PATH 环境变量中。源码中的 aidl 工具通常位于路径：out/soong/host/linux-x86/bin/aidl。 准备文件
ITestAudio.aidl
package henry.test.audio; interface ITestAudio{ int requestAudioFocus(int streamType, int durationHint); int abandonAudioFocus(); void requestAudioFocusForCall(int streamType, int durationHint); void abandonAudioFocusForCall(); void setMode(int mode); } 环境
源码环境：out/soong/host/linux-x86/bin/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2da79ea2e40f4329328ee05c6258544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/628768c2e3d89d49f3c95bd3217d3e9b/" rel="bookmark">
			vulnhub靶场之driftingblues-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.环境搭建 1.靶场描述 get flags difficulty: easy about vm: tested and exported from virtualbox. dhcp and nested vtx/amdv enabled. you can contact me by email (it should be on my profile) for troubleshooting or questions. This works better with VirtualBox rather than VMware 2.靶场下载 https://www.vulnhub.com/entry/driftingblues-2,634/ 3.靶场启动 虚拟机开启之后界面如上，我们不知道ip，需要自己探活，网段知道：192.168.1.0/24
二.信息收集 1.寻找靶场真实ip nmap -sP 192.168.1.0/24 arp-scan -l 靶场真实ip地址为192.168.1.7 2.探测端口及服务 nmap -p- -sV 192.168.1.7 发现开启了21端口，服务为ProFTPD 发现开启了22端口，服务为OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0) 发现开启了80端口，服务为Apache httpd 2.4.38 ((Debian)) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/628768c2e3d89d49f3c95bd3217d3e9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eed4faa18a88285e22d42d9f60c7a8c/" rel="bookmark">
			网络空间测绘系统的商业应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着网络空间的不断发展和扩展，网络安全已经成为当今社会面临的重要挑战之一。为了有效应对网络安全威胁，网络空间测绘系统应运而生，成为网络安全领域的重要工具。
网络空间测绘系统不仅能够帮助安全研究人员进行研究和管理，还能为企业评估网络暴露面、进行攻防演练以及实现态势感知提供支持。然而，尽管这些系统在网络安全中发挥着重要作用，但也面临着一些问题，特别是在用户使用简易度方面。那么网络空间测绘系统的具体应用场景都有哪些呢？
一、安全研究支撑服务
网络空间测绘系统为安全研究提供了重要支撑服务。通过采用互联网SaaS服务的交付模式，这些系统为用户开放了查询检索服务，让用户可以根据权限级别和购买积分的不同获取不同的查询和下载权限。这种服务主要服务于各企事业单位以及网络安全公司的安全研究人员，为他们提供了丰富的安全数据和信息。不仅如此，系统厂商还能够通过订阅和积分销售获得收益，并获取用户提供的查询数据和贡献的代码和知识。
二、全网测绘分析报告服务
另一个重要的应用场景是全网测绘分析报告服务。系统运营者能够以重要系统、重要厂商、重要漏洞、重要安全事件等不同维度为切入口，对全网资源数据进行探测和分析，并在此基础上提供全网的专题测绘分析报告。这种服务与最早的2012年互联网普查相似，但更加全面和深入，为用户提供了宝贵的数据和见解。
三、区域资产评估和测绘服务
除了全网测绘分析报告服务，网络空间测绘系统还提供了区域资产评估和测绘服务。这种服务通过主动扫描结合流量监控的资产采集方式，对关注区域内的联网资产进行分析和统计。
例如，利用常见漏洞库与资产库的关联，对区域内漏洞影响资产的分布、数量等进行统计分析和展示。这种应用模式不仅能够支持态势感知能力，还能够快速评估、定位和通报处置新爆发出的漏洞事件。
结语：
所以，不难看出网络空间测绘系统在网络安全领域的应用场景非常丰富，为安全研究、全网测绘分析、区域资产评估等提供了重要支持，而且它的用途不仅仅只在这几个方面，未来应用场景也会越来越广泛。
不过，当前这些系统在用户使用简易度方面存在一定问题，导致了一些使用上的不便。为了更好地发挥这些系统在网络安全领域的作用，需要进一步提升系统的易用性，使更多的用户能够受益于网络空间测绘技术的发展。
参考文献：
沈逸，江天骄．网络空间的攻防平衡与网络威慑的构建．世界经济与政治，2018(2):4970+157.
刘红,姚旺君,孙彻等.网络空间测绘系统分类及应用综述[J].信息技术与网络安全,2021,40(10):16-21+28.DOI:10.19358/j.issn.2096-5133.2021.10.003.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc84ac00d825146de564c20358678dc9/" rel="bookmark">
			Leo赠书活动-21期 《一篇讲明白 Hadoop 生态的三大部件》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好，我是Leo，热爱Java后端开发者，一个想要与大家共同进步的男人😉😉
🍎个人主页：Leo的博客
💞当前专栏： 赠书活动专栏
✨特色专栏： MySQL学习
🥭本文内容：Leo赠书活动-21期 《一篇讲明白 Hadoop 生态的三大部件》
📚个人知识库： Leo知识库，欢迎大家访问
目录 1.前言2.HDFS3.Yarn4.Hive5.HBase6.Spark及Spark Streaming7.总结8.🥇赠书活动规则 1.前言 进入大数据阶段就意味着进入NoSQL阶段，更多的是面向OLAP场景，即数据仓库、BI应用等。
大数据技术的发展并不是偶然的，它的背后是对于成本的考量。集中式数据库或者基于MPP架构的分布数据库往往采用的都是性能稳定但价格较为昂贵的小型机、一体机或者PC服务器等，扩展性相对较差；而大数据计算框架可以基于价格低廉的普通的硬件服务器构建，并且理论上支持无限扩展以支撑应用服务。
在大数据领域中最有名的就是 Hadoop 生态，总体来看，它主要由三部分构成：底层文件存储系统 HDFS（Hadoop Distributed File System，Hadoop 分布式文件系统）、资源调度计算框架 Yarn（Yet Another Resource Negotiator，又一个资源协调者）以及基于 HDFS 与 Yarn的上层应用组件，例如 H****Base、Hive 等。一个典型的基于 Hadoop 的应用如下图所示。
2.HDFS HDFS 被设计成适合运行在通用硬件（Commodity Hardware）上的分布式文件系统。它和现有的分布式文件系统有很多共同点，例如典型的 Master-Slave 架构（这里不准备展开介绍），也有不同点，**HDFS 是一个具有高度容错性的系统，适合部署在廉价的机器上。**关于HDFS 这里主要想说两点，默认副本数的设置以及机架感知（Rack Awareness）。
HDFS 默认副本数是 3，这是因为 Hadoop 有着高度的容错性，从数据冗余以及分布的角度来看，需要在同一机房不同机柜以及跨数据中心进行数据存储以保证数据最大可用。因此，为了达到上述目的，数据块需要至少存放在同一机房的不同机架（2 份）以及跨数据中心的某一机架（1 份）中，共 3 份数据。
机架感知的目的是在计算中尽量让不同节点之间的通信能够发生在同一个机架之 内，而不是跨机架，进而减少分布式计算中数据在不同的网络之间的传输，减少网络带 宽资源的消耗。例如当集群发生数据读取的时候，客户端按照由近到远的优先次序决定 哪个数据节点向客户端发送数据，因为在分布式框架中，网络 I/O 已经成为主要的性能瓶颈。
只有深刻理解了这两点，才能理解为什么 Hadoop 有着高度的容错性。高度容错性是Hadoop 可以在通用硬件上运行的基础。
3.Yarn Yarn 是继 Common、HDFS、MapReduce 之 后 Hadoop 的又一个子项目， 它是在MapReduceV2 中提出的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc84ac00d825146de564c20358678dc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2395030711a8bf69236c0ef02a311ee1/" rel="bookmark">
			Android 子module添加渠道配置异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目导入一个module编译出现如下错误：
The consumer was configured to find a runtime of a component, preferably optimized for Android, as well as attribute 'com.android.build.api.attributes.BuildTypeAttr' with value 'debug', attribute 'com.android.build.api.attributes.ProductFlavor:1.0' with value 'test1', attribute 'com.android.build.api.attributes.AgpVersionAttr' with value '7.3.0', attribute 'org.jetbrains.kotlin.platform.type' with value 'androidJvm'. However we cannot choose between the following variants of project :test_sdk: - test1DebugRuntimeElements - test2DebugRuntimeElements - test3DebugRuntimeElements All of them match the consumer attributes: - Variant 'test1DebugRuntimeElements' capability Health:health_sdk:unspecified declares a runtime of a component, preferably optimized for Android, as well as attribute 'com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2395030711a8bf69236c0ef02a311ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba21033a9a0f1905f0f95b9914790579/" rel="bookmark">
			【详细讲解PostCSS如何安装和使用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页:程序员不想敲代码啊🌈
🏆CSDN优质创作者，CSDN实力新星，CSDN博客专家🏆
👍点赞⭐评论⭐收藏 🤝
希望本文对您有所裨益，如有不足之处，欢迎在评论区提出指正，让我们共同学习、交流进步！
PostCSS安装和使用 0. 前言1. 安装 PostCSS1). 🏆使用npm安装2). 🏆使用yarn安装 2. 使用 PostCSS1). 🏆方法一：命令行工具2). 🏆方法二：与构建工具结合❤️Webpack中使用PostCSS❤️Gulp中使用PostCSS 0. 前言 PostCSS 是一个使用 JavaScript 插件转换CSS代码的工具。这些插件可以让你使用未来的CSS特性、优化CSS文件的大小，或者是在CSS文件中嵌入一些编程逻辑。
1. 安装 PostCSS 通常，PostCSS 是作为项目开发依赖安装的，你可以通过npm或者yarn这样的包管理器来进行安装。在你开始之前，确保你已经安装了Node.js和npm。
1). 🏆使用npm安装 npm install postcss postcss-cli --save-dev 这里同时安装了 postcss-cli，这是PostCSS的命令行接口，可以让你在命令行中运行PostCSS。
2). 🏆使用yarn安装 yarn add postcss postcss-cli --dev 2. 使用 PostCSS 安装完毕后，你就可以开始使用PostCSS了。假设你已经有了一些CSS文件并希望通过PostCSS进行处理。
1). 🏆方法一：命令行工具 创建一个简单的PostCSS配置文件 postcss.config.js，并在里面加入你所需要的插件：
module.exports = { plugins: [ // 在这里加入你要使用的插件 require('autoprefixer'), // 其他插件 ] }; 然后你可以通过CLI命令来转换CSS：
npx postcss src/css/style.css --output dist/css/style.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba21033a9a0f1905f0f95b9914790579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc542a755d7d182dc395ed21a4a64881/" rel="bookmark">
			子孙组件响应式传参之provide/inject
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Vue 2.0 类型：
provide：Object | () =&gt; Objectinject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } 详细：
这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。
用法
//父组件 provide(){ return { date:()=&gt;this.date } }, //孙组件 inject: ['date'], computed: { newDate() { return this.date() } }, 2. Vue3.0 用法 //父组件 &lt;script setup&gt; import { provide, ref } from 'vue' const location = ref('North Pole') function updateLocation() { location.value = 'South Pole' } provide('location', { location, updateLocation }) &lt;/script&gt; //孙组件 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc542a755d7d182dc395ed21a4a64881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/190acb2eca2f1bd6f3ee87ba36e1a47e/" rel="bookmark">
			春秋云境CVE-2023-0562
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 银行储物柜管理系统是一个基于网络的应用程序，用于处理存储银行客户贵重物品的银行储物柜。储物柜的所有详细信息都保存在数据库中。银行储物柜管理系统项目是使用 PHP 和 MySQLi 扩展开发的。
正文 进入靶场，首先就看到有个bankers，点进去一看发现是个登录界面，那么我就开始尝试弱口令爆破发现没用，然后修改密码，需要邮箱和电话，恰好在主页有邮箱和电话，我尝试输入进去，然后发现这根本就是一个陷阱，没有用。
找到注入点 发现这里有个输入的地方，随便输入进去发现是个查询功能，那么就可能存在sql注入，那就话不多说，抓包上sqlmap
开始抓包 sqlmap开爆 python sqlmap.py -r 2.txt -batch -dbs
python sqlmap.py -r 2.txt -batch -D blmsdb -tables
&gt;python sqlmap.py -r 2.txt -batch -D blmsdb -T fllllaaaag -columns
拿下靶场 python sqlmap.py -r 2.txt -batch -D blmsdb -T fllllaaaag -C flag -dump
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/4/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>