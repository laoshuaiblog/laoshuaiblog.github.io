<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/043fce1d3b1705b6a5119abf4ac5b72c/" rel="bookmark">
			「ShardingSphere」从简介到实践，一篇文章带你了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关链接：
水平分表实战
水平分库分表实战
目录
一、什么是 ShardingSphere？
1.ShardingSphere 的背景与意义
2.ShardingSphere 的特性和优势
二、如何使用 ShardingSphere？
1、实现分库分表
2.使用 ShardingSphere 进行数据分片
三、ShardingSphere 的应用前景与发展趋势
一、什么是 ShardingSphere？ 1.ShardingSphere 的背景与意义 ShardingSphere 是一款开源的分布式数据库中间件，由 Apache ShardingSphere 团队进行维护和更新。ShardingSphere 的目标是为分布式数据库提供一种高性能、易用、易扩展、易维护的解决方案。
在传统的关系型数据库中，数据规模的增大和访问量的提高会导致单个数据库的性能和可用性受到限制。为了解决这个问题，人们往往采用将数据分成多份存储的方式，称为“数据分片”。然而，这样带来了新的挑战：如何将数据的查询和更新操作在不同的分片之间协调执行。此时就需要使用数据库中间件。
相比于传统的数据库中间件，ShardingSphere 具有以下优势：
1. 支持多种数据库：ShardingSphere 可以适配 MySQL、PostgreSQL、Oracle 等多种主流的关系型数据库，具有很强的兼容性。
2. 实现分片、读写分离等功能：ShardingSphere 提供了分库分表、读写分离、分布式事务等核心功能，可以显著提高数据库的性能和可用性。
3. 易用性优秀：ShardingSphere 内置了很多自动化的特性，用户只需进行简单的配置即可实现分片和读写分离等功能，大大降低了使用难度。
由此可见，ShardingSphere 的出现填补了分布式数据库领域的空白，大大提高了应用程序的性能和可用性，受到越来越多企业和开发者的关注和青睐。
2.ShardingSphere 的特性和优势 ShardingSphere 是一款开源的分布式数据库中间件，具有以下特性和优势：
1. 数据分片：ShardingSphere 可以将数据按照一定规则进行分片存储在不同的节点上，实现水平扩展，提高系统的可伸缩性和性能。
2. 读写分离：ShardingSphere 支持主从复制、半同步复制等多种模式，可以实现读写分离，分担主库压力，降低延迟和丢失率。
3. 分布式事务：ShardingSphere 支持 XA、TCC、AT 等多种分布式事务协议，可以保障跨分片事务的原子性和一致性。
4. 强大的 SQL 解析和路由功能：ShardingSphere 能够解析 SQL 语句，并根据表达式提取分片键，然后将数据路由到对应的分片节点上，优化查询效率。
5. 高度兼容：ShardingSphere 可以适配 MySQL、PostgreSQL、Oracle 等多种主流的关系型数据库，具有很强的兼容性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/043fce1d3b1705b6a5119abf4ac5b72c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7b3e56e6a6e1ad0a23d326e399f469/" rel="bookmark">
			[报错]前端无法获取到后端传递的boolean类型的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说原因，后端boolean命名为了isXxx，前端解析获取到的是Xxx，因此前端再使用isXxx是没有数据的。
所以一般在使用boolean以及Boolean类型的数据时，都不推荐使用isXxx来命名。前者是基本数据类，在JavaBeans的规范中，其getter和setter方法分别是isXxx()和setXxx()；后者是包装类，其getter和setter方法分别是getXxx()和setXxx()。
这种方式在某些时候是可以正常运行的，但是在一些rpc框架里面，当反向解析读取到isXxx()方法的时候，rpc框架会“认为”其真正的属性值是xxx。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576c48f6ba0608ed43f01f35ea829420/" rel="bookmark">
			SpringMVC 源码分析之 DispatcherServlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC 源码分析之 DispatcherServlet FrameworkServletserviceprocessRequestLocaleContext 和 RequestAttributesLocaleContextRequestAttributes 事件发布 DispatcherServletdoService代码分析 doDispatch参数含义具体的处理逻辑： processDispatchResult 引用 SpringMVC 的核心是 DispatcherServlet，和所有的 Servlet 一样，DispatcherServlet 对请求的处理也是从 service 方法开始，而 DispatcherServlet 的 service 方法在父类 FrameworkServlet 中，因此我们先来看看 FrameworkServlet，这有助于我们理解 DispatcherServlet。
FrameworkServlet FrameworkServlet 继承自 HttpServletBean，而 HttpServletBean 继承自 HttpServlet，HttpServlet 就是 JavaEE 里边的东西了，这里我们不做讨论，从 HttpServletBean 开始就是框架的东西了，但是 HttpServletBean 比较特殊，它的特殊在于它没有进行任何的请求处理，只是参与了一些初始化的操作，这些比较简单，所以这里我们对 HttpServletBean 不做分析，就直接从它的子类 FrameworkServlet 开始看起。
service FrameworkServlet#service 源码如下：
/** * Override the parent class implementation in order to intercept PATCH requests. */ @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { HttpMethod httpMethod = HttpMethod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576c48f6ba0608ed43f01f35ea829420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c03e8cc811c9ff99efd8947e324f686/" rel="bookmark">
			Java高级编程——网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java高级编程——网络编程 目录
Java高级编程——网络编程
一、网络编程概述
1.概述
2.网络基础
二、 网络通信要素概述
1.如何实现网络中的主机互相通信
2.网络通信协议
三、通信要素1：IP和端口号
1.概述 2.InetAddress类
上代码
四、通信要素2：网络协议
1.网络通信协议
2.TCP/IP协议簇
3.TCP 和 UDP
4.TCP三次握手
5.TCP四次挥手
6.Socket
五、TCP网络编程
1.基于Socket的TCP编程
2.流程
2.1客户端创建Socket对象
2.2服务器建立 ServerSocket 对象
3.例 题
3.1 代码演示1
3.2 代码演示2
3.3 代码演示3
4.客户端—服务端
六、UDP网络编程
1.UDP网络通信
2.DatagramSocket 类的常用方法
3.流程 3.1 发送端
3.2 接收端
上代码
七、URL编程
1.URL类
2.URL类构造器 3.URL类常用方法
上代码
4.针对HTTP协议的URLConnection类
上代码
5.URI、URL和URN的区别
7.小 结 一、网络编程概述 1.概述 2.网络基础 二、 网络通信要素概述 1.如何实现网络中的主机互相通信 2.网络通信协议 三、通信要素1：IP和端口号 1.概述 域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成iP地址，这样才能和主机建立连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c03e8cc811c9ff99efd8947e324f686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56522a9d0e67a56085ff43f2eeb93c24/" rel="bookmark">
			将所有能力汇聚于一点，这就是“iVX编程盒子”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iVX平台概述... iVX，可以理解为一种可视化的“全栈代码生成器”，而且这种“代码生成”做得相当彻底，几乎所有应用都可以通过iVX在不写任何代码的情况下进行“自动代码生成”。iVX平台研发难度极大，涉及技术领域也非常广，在全球领域能自动生成全栈代码的，应该就这一家了。
虽然，市面上包括很多媒体都把iVX定义为“低代码”平台，但实际上，iVX和市面上其它“低代码/无代码”平台无论是“技术架构”、“实现方法”、“用户体验/操作”、“产品目的”都完全不一样。其他所有低代码产品，几乎可以认为是一种“企业内快速开发框架”，运行时和开发是一体的，也就意味着所有开发的应用，只能在这个低代码厂商的环境下运行，是应用是无法导出也无法独立部署的，表现形态就是“无法生成应用源代码”。
iVX并不是一个完全针对“企业”的产品，而是一种面向编程、面向程序员的一种新的“开发范式”，iVX始终只解决两个问题“如何让新手快速学会应用开发？”以及“如果让开发的效率更高一些？”。因此，无论是个人还是企业，都可以使用iVX，而且在网上使用就是免费的。（ivx.cn）
转入正题：
“iVX编程盒子”是什么呢？
简单的说就是将“iVX的生产力封装成一个硬件产品，通过本地化的方式提供给大家。”
以往，iVX用户通常会遇到这些问题：
1. “我们开发环境是内网，无法使用公网服务，而且无法满足企业对安全的审查...”
2. “我们是软件外包服务商，需要去驻场开发”，如果有一个方便移动的设备，无视客户方的网络和资源差异，即插即用，快速开发...”
3. “iVX专业定制服务器版本费用太高，我们开发人数还不少...”
4. “集成iVX基础能力，最好能提供一台内部开发机，性价比越高越好...”
5. “教学时，需要很多账号一起使用，需要在每个班或每个实验室配备一台开发设备...”
6. “网上调试，我们还是需要支付云计算费用，如果本地有一台开发机，这个费用都可以省了...”
...
总体来说，“iVX编程盒子”就是为了解决以上这些问题的，能力上不打折扣并标准化，尽可能提供更高的性价比，提供完美的本地开发体验...
由于产能有限，本次活动，我们只提供100台，而且尽在6.18期间提供销售。如有需求，请到 http://ivx.cn 首页购买和咨询。
为什么会采用“小盒子”呢（其实就是一个mini主机）？
现在市场上mini主机其实都非常内卷，换句话说一下，其实配置都挺不错的，性价比很高，而且非常便携小巧。如果去外地驻场开发，带一个不到一斤的小盒子就可以了，这种感觉应该比搬几台几十斤服务器要惬意很多。 另外，当然从技术上讲，由于iVX是基于浏览器的IDE，因此，开发时主要都是依赖浏览器的算力，只有在编译、预览、导出等低频操作的时候才会用到这个“小盒子”的算力，因此，对中心节点的压力不大，用一个小盒子完全可以解决几十人甚至上百人同时开发的问题。
别的低代码厂商是否也可以采用类似的方式来封装产品？
这个基本上很难，因为“低代码”产品（除了iVX），主体上就是“一个企业内部的应用快速开发框架”，基本上都是“运行时”产品，也就是说开发和运行时是一体的，如果用小盒子来承载“运行时”，很大概率会崩掉，也无法支持更复杂的业务和大规模并发和各种数据库的使用。
哪种情况不建议使用“编程盒子”？
如果需要定制开发整套iVX平台系统，例如需要和本地系统做各种接口对接；例如登陆、授权；或者代码仓库、代码审计；或者直接将代码导入生产或测试环境的；又或者需要定制IDE、定制logo、定制各种组件和模块的；
同时开发人数规模非常大，超过50人这个规模的，或者更大的，这种情况为了系统稳定，最好使用专业定制系统，通过搭建服务器来实现；
需要开发小程序、iOS/Android/Windows等本地原生应用的。
这种还是需要做专门定制，直接联系平台来解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11964f0495378fb334a71ecb9c4c42eb/" rel="bookmark">
			基于Java&#43;Vue&#43;uniapp微信小程序实现餐厅校园订餐平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝20W+,csdn特邀作者、博客专家、CSDN新星计划导师、java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
🍅文末获取联系🍅精彩专栏推荐订阅👇🏻👇🏻👇🏻👇🏻
java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
Java毕业设计参考题目-题目新颖（值得收藏）
目录
一、前言介绍：
二、主要技术： 2.1 Java技术架构介绍：
2.2 MYSQL数据库：
2.3 微信开发者工具
三、系统设计：
3.1 系统架构设计：
3.2 登录时序图设计：
四、功能截图： 4.1 微信小程序端：
4.1.1登录注册：
4.1.2 首页信息：
4.1.3 美食信息：
4.1.4 美食详情：
4.1.5 购物车信息：
4.1.6 我的模块： 4.2 后台管理员端：
4.2.1 管理员登录：
4.2.2 餐厅管理模块：
4.2.3 美食管理模块：
4.2.4美食资讯信息：
五、代码实现： 六、论文文档：
八、源码获取：
一、前言介绍： 传统的校园订餐管理方式都在使用手工记录的方式进行数据的登记，这种方式耗时，而且对于数据量比较大的情况想要快速查找某一数据非常慢，对于数据的统计获取比较繁琐，随着网络技术的发展，采用电脑管理相关数据信息管理与数据查询等诸多环节已成为必然趋势；数据情况的透明化，提高了信息管理的透明度，提高管理效率。
传统的校园订餐管理需要对各类信息及时的进行记录、规整、更新、收藏，这是对数据信息统计管理的极大消耗，在其进行过程中，还会出现因信息的重复传递，出现本可以避免的出错问题，例如：前后数据不一致、种类纰漏以及备注不详细等等一系列问题。在信息告诉更替的时代，信息的准确性，经济可行性也无疑是众人关注的焦点。那么我们系统的目的性也就很明确。
二、主要技术： 2.1 Java技术架构介绍： Java以Linux为基础并且使用Java语言进行开发的操作平台。Java的开放性让他允许所有人对系统进行修改和完善，这一点也让他在近些年成为便携设备上主要的操作系统。Java同时还内置了内置丰富的应用程序，比如电话、摄像头、播放器。这些都为在系统上开发程序提供了便利。该系统运用小程序完成前台的开发，包括登录注册、个性化特征的收集、用户使用我们这个校园订餐小程序只需一个Java手机就可以使用了，而且所有操作都是我们熟悉的操作手法。所有的操作通过手机就可以完成，用户不需培训，只要稍微提示一下即可。所以开发校园订餐小程序使用小程序技术不仅方便了开发者而且用户使用起来也非常方便，可以说是相对来说比较完美的开发平台了。
2.2 MYSQL数据库： MySQL数据库使用的语言是SQL语言。MySQL在保存数据时是根据数据的类型和特征分开保存在不同的表中，这样当用户在需要调用的数据时，就不再需要花费大量时间去寻找数据了，只要找到对应的表，就可以找到需要的数据了。MySQL可以完美的实现对于数据库的基本操作。因为 MySQL 数据库的占用的内存少，运行快，成本低，源代码开放，可移植性强，所以越来越多的数据来源简单的项目的开发都会选择 MySQL作为数据库，而MySQL也变得越来越流行。
2.3 微信开发者工具 在传统web浏览器中，在加载htm15页面时先加载视图层的html和css，后加载逻辑层的java script，然后返回数据并在浏览器中展示页面。而微信开发者工具的系统层是基于Native System的，视图层和逻辑层会同时被加载。微信小程序的这种逻辑方式大大的优化了页面响应速度，减少了页面加载的等待时间，提高了用户体验。微信开发者工具可以实现同步本地文件，开发调试，编译预览，上传，发布等一整套流程。
三、系统设计： 3.1 系统架构设计： 3.2 登录时序图设计： 四、功能截图： 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11964f0495378fb334a71ecb9c4c42eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb6ead0650595c731c237d87498963c4/" rel="bookmark">
			XShell7出现 Error Report Program has stopped working
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：长时间没打开xshell 了，一打开就出现如下图的错误，怎么输入点击都不行，最后发现是 区域编码 问题
解决办法：
1. 打开 控制面板
2. 点击更改日期、时间或数据格式
3. 切换管理选项卡，点击更改系统区域设置
4. 取消勾选Beta
5. 重启电脑，即可正常打开xshell7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241065d2308c598dfb475155bdb07929/" rel="bookmark">
			解决windows下的nginx服务关不掉问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决windows下的nginx服务关不掉问题 最近在学nginx，遇到的坑，记录一下
问题描述 使用./nginx -s stop命令停止nginx，结果发现nginx服务没有停掉
再次使用./nginx -s stop命令，报错
nginx: [error] CreateFile() “D:\download\nginx-1.24.0\nginx-1.24.0/logs/nginx.pid” failed (2: The system cannot find the file specified)
问题复现步骤： 官网下载windows版的nginx压缩包，解压双击nginx.exe再次双击nginx.exe使用./nginx -s stop命令停止nginx，结果发现nginx服务没有停掉 问题原因 nginx启动了多个，但只关闭了一个
解决方法 taskkill /f /t /im nginx.exe 以上命令的作用是强制终止运行中的 nginx.exe 进程及其所有子进程
附：
nginx常用命令
作用命令启动nginxstart nginx重启nginxnginx -s reload关闭nginxtaskkill /f /t /im nginx.exe查看端口占用netstat -aon 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4265ce3e3a3f8c9a349c006158028c63/" rel="bookmark">
			Java垃圾回收机制深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介二、Java内存结构三、什么是垃圾四、垃圾收集算法1. 标记-清除算法（Mark and Sweep）2. 复制算法（Copying）3. 标记-整理算法（Mark and Compact）4. 分代收集算法（Generational Collection） 五、垃圾收集器六、垃圾回收的触发时机结语 一、简介 Java垃圾回收机制是Java虚拟机（JVM）的核心组件之一，对于内存管理起到至关重要的作用。它能自动追踪并管理应用程序中创建的对象，当这些对象不再使用时，垃圾回收机制会自动回收其占用的内存，使这部分内存能够被再次利用。此机制极大地减少了开发者需要手动管理内存的负担，防止了因为疏忽导致的内存泄漏问题，是Java语言相较于C++等其他语言的一个显著优点。
二、Java内存结构 Java内存主要被划分为五个区域：
方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量等数据。堆（Heap）：Java Heap是JVM所管理的最大一块内存区域，几乎所有的对象实例以及数组都要在堆上分配。它还被划分为新生代和老年代两个部分，用于进行高效的内存分配和回收。虚拟机栈（Java Stack）：每个线程有一个私有的栈，其生命周期与线程同步。栈帧存储了局部变量表、操作数栈、动态链接和方法出口等信息。本地方法栈（Native Method Stack）：本地方法栈与虚拟机栈类似，只不过它是为本地（Native）方法服务的。程序计数器（Program Counter Register）：它是当前线程所执行的字节码的行号指示器。 其中，方法区和堆是Java垃圾收集器关注的主要区域，也是我们接下来讨论的重点。
三、什么是垃圾 在Java中，对象的生命周期从创建（new）开始，到不再被其他对象引用结束。换句话说，当一个对象没有任何引用指向它时，这个对象就成了垃圾，等待垃圾回收器的回收。值得注意的是，对象可能还在作用域中，但已经不可能被程序再次使用（如：对象只在一个局部作用域中使用），此时这个对象也会被视为垃圾。垃圾回收器的主要工作就是找出这些垃圾对象并释放它们占用的内存，从而为新的对象提供空间。
四、垃圾收集算法 1. 标记-清除算法（Mark and Sweep） 这是最基础的垃圾收集算法。它分为两个阶段：标记阶段和清除阶段。标记阶段会遍历所有的对象，找出还活着的对象。清除阶段则会清除掉所有未被标记的对象。如图：
虽然标记-清除算法很直观，但存在两个问题：一是效率问题，标记和清除两个过程的效率都不高；二是空间问题，标记清除之后会产生大量不连续的内存碎片。
2. 复制算法（Copying） 为了解决效率问题，可以采用"复制"算法。复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。这样使得每次都是对其中一块进行内存回收，内存分配时也就不用考虑内存碎片等问题。如图：
复制算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半，未充分利用内存。且存活对象增多的话，复制算法的效率会大大降低。
3. 标记-整理算法（Mark and Compact） 为了解决空间问题，可以使用"标记-整理"算法。标记过程仍然与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。如图：
4. 分代收集算法（Generational Collection） 当前商业虚拟机的垃圾收集都采用"分代收集"（Generational Collection）算法。这种算法把Java堆分为新生代和老年代，这样我们就可以根据各个年代的特点采用最适当的收集算法。在对象存活率低的新生代，可以选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，我们可以选择"标记-清理"或者"标记-整理"算法进行垃圾收集。
注意，Java本身并不提供直接控制这些垃圾收集算法的API，它们是由Java虚拟机在后台自动执行的。然而，理解这些基础的垃圾收集算法是理解更高级的垃圾收集技术（如：并行收集、并发收集、增量收集等）的基础。
五、垃圾收集器 Java HotSpot VM包含几种类型的垃圾收集器，每一种都有各自的特点，适用于不同的系统和使用场景。包括：
Serial收集器：单线程收集器，它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Parallel收集器：多线程收集器，它在垃圾收集时，会停止其他所有的工作线程，直到它收集结束。CMS (Concurrent Mark Sweep)收集器：并发收集器，它主要的设计目标是避免在老年代垃圾收集时出现长时间的卡顿。G1 (Garbage First)收集器：它是一款面向服务端应用的垃圾收集器，它能满足垃圾收集停顿时间可预测以及高吞吐量的需求。 需要注意的是，每种垃圾收集器都有其适用的场景，没有绝对的好坏之分。在实际的系统设计和开发中，我们需要根据应用的特性（如：是否对系统响应时间有较高要求等）和硬件资源来选择最合适的收集器。
六、垃圾回收的触发时机 在Java中，垃圾回收的触发时机是由JVM来决定的。虽然我们可以通过调用System.gc()方法来请求JVM进行垃圾回收，但这只是一个建议，JVM可以选择忽略这个请求。
在实际情况中，JVM通常会在以下几种情况下进行垃圾回收：
当JVM的堆内存空间不足时，JVM会触发垃圾回收，以释放不再使用的对象占用的内存，从而为新的对象分配空间。当一个Old Generation（老年代）空间满时，会触发一次Full GC，这会导致所有的Java应用线程暂停，直到GC结束。当系统空闲时，JVM也可能会选择执行垃圾回收，以提高系统的内存使用效率。 下面的Java代码将显示在运行过程中垃圾回收的执行情况：
public class GCDemo { public static void main(String[] args) { Runtime runtime = Runtime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4265ce3e3a3f8c9a349c006158028c63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706c896cac672ff6559de9fd9b9546e5/" rel="bookmark">
			基于多态的职工管理系统(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.总体设计: 二.各个模块实现细节 1.头文件 (1)职工类(worker.h) #pragma once #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; //职工类 class Worker { public: //显示个人信息 virtual void showInfo() = 0;//虚函数,只定义,暂时不做实现 //获取岗位名称 virtual string getDeptName() = 0; //职工编号 int m_Id; //职工姓名 string m_Name; //部门编号 int m_DeptId; }; (2)普通员工类(employee.h) #pragma once #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; #include "worker.h" //普通员工 class Employee :public Worker//继承Worker类 { public: //构造函数 Employee(int id,string name,int dId); //显示个人信息 virtual void showInfo();//虚函数,只定义,暂时不做实现 //获取岗位名称 virtual string getDeptName(); }; (3)经理类(manager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/706c896cac672ff6559de9fd9b9546e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46dc92c5aa55c5deac53352521c5ef5b/" rel="bookmark">
			通讯录管理系统(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.总体设计图: 使用VS软件编写: 二.各个函数模块 1.头文件(通讯录管理系统.h) #pragma once #include &lt;iostream&gt; using namespace std; #define MAX 100//最大人数 //设计联系人的结构体 struct Person { string m_Name;//姓名 int m_Sex;//性别:1男 2女 int m_Age;//年龄 string m_Phone;//电话 string m_Addr;//家庭住址 }; //设计通讯录的结构体 struct Addressbooks { Person personArray[MAX];//通讯录中保存的联系人数组 int m_Size;//通讯录中当前记录的联系人个数 }; void showMenu(); void addPerson(Addressbooks* abs); void showPerson(Addressbooks* abs); int isExist(Addressbooks* abs, string name); void deletePerson(Addressbooks* abs); void findPerson(Addressbooks* abs); void modifyPerson(Addressbooks* abs); void cleanPerson(Addressbooks* abs); 2. 显示菜单界面.cpp #include &lt;iostream&gt; using namespace std; //菜单界面 void showMenu() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46dc92c5aa55c5deac53352521c5ef5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9221b521208d45e12171135689792a16/" rel="bookmark">
			PAT 乙级 1050 螺旋矩阵（解题思路&#43;AC代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。
输入格式：
输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。
输出格式：
输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。
输入样例：
12 37 76 20 98 76 42 53 95 60 81 58 93 输出样例：
98 95 93 42 37 81 53 20 76 58 60 76 代码长度限制 16 KB
时间限制 200 ms
内存限制 64 MB
解题思路 首先确定m行n列，m和n需要满足3个条件：m*n=N；m&gt;=n；m-n要最小。一个数的平方根-平方根为最小，但是m和n为正整数，所以可以使用sqrt函数求出一个整数平方根向下取整的值，并用N来除以这个数，如果余数为0，那么令n为这个数，m为N除以n的数；如果余数不为0，那么n–，然后继续循环判断。这样可以保证m-n为最小，也就是最靠近平方根的一组数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9221b521208d45e12171135689792a16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ab2ea587e57d1e08be74d940287adc/" rel="bookmark">
			PAT 乙级 1049 数据的片段和（解题思路&#43;AC代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。
给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。
输入格式：
输入第一行给出一个不超过 105 的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以一个空格分隔。
输出格式：
在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。
输入样例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ab2ea587e57d1e08be74d940287adc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494f5adbbd6e54fdf061eee642ff016a/" rel="bookmark">
			H3C-HCL模拟器常用命令及其操作演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验拓扑图
二、实验设备
设备1：路由器"MSR36-20"；
设备2：真机；
三、常用命令
1）进入用户视图：启动默认就是用户视图 "&lt; &gt;"
2）进入系统视图："[ ]"
3）进入接口视图
4）配置接口IP地址
5）退出当前模式或返回上一级模式
6）Ctrl+z 或 Return：直接退到用户视图
7）用户视图查看接口IP地址
8）帮助命令：空格翻页，Ctrl+C终止显示
10）"空格+?"用于提示参数
11）Tab键命令补全
12）显示历史的最后10条命令
13）Ctrl+w：以字符串为单位进行删除；Ctrl+x：以行为单位进行删除
14）查看设备当前生效的配置参数
15）查看当前视图下配置了哪些参数
16）重新启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b10225287e5f17b70bc9e244e752cf/" rel="bookmark">
			数组快速求和方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个整数，并返回它们的数组下标。假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。按照任意顺序返回答案。
/** /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function (nums, target) { // 声明map数组 let myMap = new Map(); // 插入值到map数组中 nums.forEach((value, index) =&gt; myMap.set(value, index)); console.log(myMap) // [{2 =&gt; 0}, {7 =&gt; 1}, {11 =&gt; 2}, {15 =&gt; 3}] let ans = []; for (let index = 0; index &lt; nums.length; index++) { // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b10225287e5f17b70bc9e244e752cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c8fe100c06cf1ea343806d81dde4ec/" rel="bookmark">
			控制系统设计——三相永磁同步伺服电机双闭环控制系统设计方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 大三自动化专业学生一枚，在一次实习中学习了电机的双闭环控制系统的设计，过程颇为曲折，因此决定在此记录一下。
在此感谢吴老师和盛老师的细心教导。
本文主打得就是一个详细，不会跳过任何过程。但只涉及：
系统数学模型（传递函数）的建立和简化 调节器结构的选择和参数的确定（PI调节器的参数） 图1 关于双闭环控制系统具体是如何实现的，双闭环系统的实现思路，具体的电路等内容，本文并不涉及。
目录
1、背景
2、设计思路
3、系统方框图介绍
4、设计过程
4.1参数选定：
4.2电流环参数选取：
4.3速度环参数选取：
5、仿真验证
6、参考书目
2、设计思路 首先要明白，由于对我们来说，设计就是找经典的案例，分析并理解他的结构，然后把我们的数据带进去。因此设计这个电机的双闭环控制系统的主要任务与难点是：
两个控制器的参数的确定，即两个PI调节器的参数选取。
这是一个拥有两个反馈回路的双闭环系统，多环系统的设计步骤是：
先内环后外环。
3、系统方框图介绍 图2 速度、电流双环调速系统 这张图简单看过即可，不细说。其中ASR为速度调节器，ACR为电流调节器，它俩实际就是PI调节器。重点是下面这张图：
图3 系统方框图 图4 各个框图中传递函数所描述的对象已进行备注，请自行观看理解。需要说明的是：
这个双闭环方框图适用于控制不同的电机。例如：直流有刷电机、三相永磁同步电机、三相感应电机、无刷直流电机。只需要在受控对象方框中填入描述相应电机的传递函数即可。 电流环和速度环都需要两个低通滤波器。因为低通滤波器中包含惯性环节，在反馈中加入低通滤波器后，输入与反馈会产生时间差，因此在相应的输入也加入低通滤波器。 4、设计过程 4.1参数选定： 首先一定要明确哪些是确定的参数，哪些是未知待定，需要我们求的参数。在图三所示的方框图中： 系统固有参数： 预先选定的参数：电流反馈系数，速度反馈系数，电流反馈滤波时间常数，速度反馈滤波时间常数
需要计算求出的参数：电流调节器参数， 速度调节器参数，
下面以我实习的课题与参数为例：
电机：三相永磁同步电机
系统固有参数选取：
图5 ，
预先选定的参数：
电流反馈系数，速度反馈系数， 电流反馈滤波时间常数，，速度反馈滤波时间常数。
4.2电流环参数选取： 因为转速对于给定信号的响应时间比电流对于给定信号的响应时间长得多，因此在计算电流的动态响应时，可以把转速看作恒值量，即将反电动势E近似地视为不变，而恒值量对动态分量是没有影响的，所以在分析电流环动态响应时，
可以把反电动势E忽略不计，也就是把方框图里那个支路去掉。
将电流环动态结构图化解，并将参数带入：
先将目标聚焦于电流内环：
根据自控原理中动态结构图的等效变换与化简的原理，将综合点前移，化简步骤如下：
下面一步是化简的难点：
因为：
所以：
接下来进行两个操作：
，将二次项省略。利用速度环PI调节器，把大惯性（0.0196&gt;&gt;0.001，相较于逆变器，它是大惯性环节）环节约掉。 令，则可以将被控对象的惯性环节约掉。
最终化简为：
上面的公式是电流环的开环传递函数，我们将其化为典型 I 型的传递函数的形式：。
根据自控理论，当预期特性为典型 I 型系统时，当 ，可以获得较好的平稳性和快速型。
得到：，，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5c8fe100c06cf1ea343806d81dde4ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14ea5936be59a3fd7f92e4764accb74/" rel="bookmark">
			关于HTML面试题汇总之H5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、H5有哪些新特性，移除了哪些元素？如何处理h5新标签的浏览器兼容性问题，如何区分html和html5 1. html5不在是SGL（通用标记语言）的一个子集，而包含了：图像、位置、存储、多任务等功能
2. 新增的图像为canvas类，媒体回放video和audio元素；本地离线存储localStorage，在浏览器关闭后也可以保存数据；而sessionStorage在浏览器关闭后会自动删除数据
3.新增内容标签：article、footer、header、nav、section；新增加表单控件：calendar、date、time、email、url、search；控件元素：webworker、websocket、Geolocation。
4、移除的元素：basefont、big、center、font、s、strike、tt、u等内容修改标签、以及性能较差的frame、frameset、noframes。
5、处理h5新标签浏览器的兼容性问题
5.1、IE8-可以通过document.createElement来创建标签，并给标签默认的样式和能力 5.2、也可以引用html5shim框架
6、区分html与html5：主要是通过doctype头、新标签和功能元素。
二、html语义化的好处 1、在样式丢失的情况下，页面呈现的结构也是清晰的
2、屏幕阅读器完全可以根据语义标签来读取内容（如盲人网站）
3、pad、手机可以根据语义标签做不同的处理，如手机上标题显示粗体，而pad上标题显示较大字体
4、对搜索引擎和爬虫的友好
三、iframe优缺点 1、优点
1.1、在不刷新的情况下重新载入的新的页面； 1.2、方便用于后台管理，或不用于对搜索引擎友好的系统
2、缺点：
2.1、不利用搜索引擎，因为爬虫只能看到框架而见不到框架的链接 2.2、框架有时候会让人迷惑，尤其是多个框架出滚动条的时候 2.3、不容易打印（暂时只能分框架页的打印，而不能打印整个frameset） 2.4、浏览器后退按钮无效（他只能后退当前获得光标的iframe） 2.5、多数pad、手机不支持框架 2.6、增加http请求 2.7、iframe会阻塞页面的加载，包含iframe的页面的window.onload事件，只有等待iframe加载完成后才能触发，但可以通过js来动态设置iframe的src属性可以避免这种情况（chrome和safari支持）
3、iframe和frame的区别 3.1、iframe和frame实现的功能相同； 3.2、iframe可以单独使用，而frame必须和frameset一起使用 3.5、在html5中iframe仅支持src属性，而对frameset和frame不在受支持
四、label标签的作用、应用 1、lable标签主要是作为一种标题说明元素存储的，通常有：for关联、以及将form control放在label标签中的方式 2、lable标签主要属性： 2.1、for属性，做标签关联，但for关联的必须是一个form control标签 2.2、accesskey属性：用于设置热键，但不能与浏览器热键冲突，否则会先触发浏览器的热键 3、label的嵌套 3.1、labe标签内不能再嵌套label 3.2、label只能包含一个input子孙（包含checkbox、text等元素）、button、select、textarea元素 3.3、label嵌套时，事件的触发遵循冒泡原则
&lt;label id="inputOne" &gt; &lt;input id="inputOne_inner" type="button" value="Test" /&gt; &lt;/label&gt; 复制
&lt;script type="text/javascript"&gt; $(function(){ $('#inputOne').click(function(){ console.log('label.........'); }); $('#inputOne_inner').click(function(event){ event.stopPropagation(); console.log('input.........') }); }); &lt;/script&gt; 复制
由于在inputOne_inner的click事件中阻止的冒泡，所以单击时只输出 ‘input……………….’。 4、for关联 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c14ea5936be59a3fd7f92e4764accb74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b7b8915ff96c4f8e5527d386416190/" rel="bookmark">
			【Linux】Linux内核编译与入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😏★,°:.☆(￣▽￣)/$:.°★ 😏
这篇文章主要介绍Linux内核编译。
学其所用，用其所学。——梁启超
欢迎来到我的博客，一起学习知识，共同进步。
喜欢的朋友可以关注一下，下次更新不迷路🥞
文章目录 :smirk:1. Linux内核介绍:blush:2. Linux内核编译:satisfied:3. Linux内核使用 😏1. Linux内核介绍 Linux内核是一种开源操作系统内核，它是基于Unix系列操作系统的设计思想和原则。与其他操作系统内核相比，Linux内核具有很多特点，例如高度可定制、模块化设计、强大的网络支持、多处理器支持、安全性、稳定性等。
Linux内核最初由芬兰程序员Linus Torvalds于1991年创建，并在全球范围内得到了广泛的使用和支持。现在，Linux内核已经成为许多流行的操作系统的核心，包括Ubuntu、Red Hat、Debian、CentOS等。
在Linux内核中，各种设备和功能都采用模块化设计，这使得内核可以灵活扩展，只需加载必要的模块即可实现所需功能。此外，Linux内核还支持多种文件系统和文件系统类型，例如ext4、xfs、btrfs、nfs等。
总体来说，Linux内核是一个高度可定制的、功能丰富的、稳定的操作系统内核，其开放源代码和广泛的社区支持使其成为开发者和用户的首选之一。
😊2. Linux内核编译 首先准备一台Linux机器，查看内核版本：uname -r
根据获取的linux kernel版本，在www.kernel.org上面下载合适的kernel版本。（如我的Ubuntu18.04内核版本是5.4.0，安装版本选择5.4.244）
解压后，将boot下config文件拷贝到本地：cp -v /boot/config-$(uname -r) .config
然后编辑.config文件：
vim .config # 将该项原有内容删掉即可，如下 CONFIG_SYSTEM_TRUSTED_KEYS="" 输入make menuconfig 启动配置界面，小白直接保存即可；
安装依赖：
sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison dwarves 开始编译内核：
# 根据机器选择核数 -j x make -j 10	#（时间很长） # 安装模块 sudo make modules_install # 安装内核 sudo make install 完成后的结果如下（不容易呀）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39b7b8915ff96c4f8e5527d386416190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edd70132623873fa2119410631c5cce/" rel="bookmark">
			HCL网络实操之telnet登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目架构图 进入 g0/0 in g0/0 配置ip地址并退出 ip address 192.168.56.250 24 quit 开启telnet服务 telnet server enable 允许五个人登录 line vty 0 4 验证方式 authentication-mode scheme 添加账户并配置密码 local-user cmoc password simple lin1234567 授权用户权限为最高 authorization-attribute user-role level-15 设置服务类型 service-type telnet 使用telnet登录 telnet 192.168.56.250 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4e51580d9bb9dc52c2fc2b7aab67b4/" rel="bookmark">
			【架构设计】单点登录实现技术方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 你只管努力，其他交给时间，时间会证明一切。
文章标记颜色说明：
黄色：重要标题红色：用来标记结论绿色：用来标记一级论点蓝色：用来标记二级论点 1 基本介绍 1.1 什么是单点登录 单点登录（Single Sign-On，简称SSO）是一种身份认证的解决方案，它允许用户只需一次登录即可访问多个应用程序或系统。在一个典型的SSO系统中，用户只需通过一次身份认证，就可以获得访问多个应用程序的授权，而不需要在每个应用程序中单独进行身份验证。
1.2 单点登录的原理 单点登录（Single Sign-On，简称SSO）的实现原理通常涉及到以下几个步骤：
用户登录认证：用户在访问第一个应用程序时，需要进行身份验证并登录系统。这个过程可以使用任何一种常规的认证方式，比如用户名和密码、二次验证等等。
生成令牌：认证通过后，系统会生成一个安全令牌（Token），将它存储在用户的浏览器中，同时将该令牌的信息存储在SSO服务器中。
传递令牌：当用户访问其他应用程序时，应用程序将向SSO服务器发送令牌验证请求。SSO服务器会检查浏览器中的令牌信息，并确认用户的身份。
验证身份：如果令牌有效且用户已经进行过身份验证，SSO服务器会向应用程序返回一个授权令牌，授权用户访问该应用程序。
访问应用程序：应用程序会使用授权令牌来验证用户的身份，并允许用户访问应用程序的资源。
需要注意的是，SSO服务器需要能够识别和验证来自不同应用程序的令牌。为了实现这一点，通常使用标准的认证协议，如OAuth、OpenID Connect等，这些协议为应用程序提供了一种标准的方式来与SSO服务器交互。此外，SSO服务器还需要实现一些安全机制来防止令牌被盗用或伪造，如Token加密、过期时间等等。
1.3 单点登录实现方案 单点登录的实现方式通常有以下几种：
基于JWT实现同域下的单点登录
基于Cookie的SSO
基于Token的SSO
基于SAML的SSO
基于OpenID Connect的SSO
CAS（Central Authentication Service）
需要注意的是，不同的SSO实现方式有不同的优缺点，选择适合自己应用场景的实现方式非常重要。
此外，SSO系统的实现需要考虑安全性和可靠性问题，如令牌加密、过期时间、安全断言的验证等等。
今天详细讲解一下：
基于JWT实现同域下的单点登录CAS（Central Authentication Service） 2 方案介绍 2.1 基于JWT实现同域下的单点登录 同域单点登录（SSO）是一种允许用户在一个网站登录后，在访问其他同域网站时无需再次登录的技术。下面介绍一种基于基于JWT的单点登录的Token同域单点登录实现方案
2.1.1 JWT介绍 JSON Web Token（JWT）是一种轻量级的、基于标准JSON格式的身份验证和授权机制。
在SSO方案中，可以使用JWT作为Token，在JWT中存储用户信息和过期时间等信息。
JWT的签名和加密机制可以保证Token的安全性，防止Token被篡改和伪造。在每次访问其他同域网站时，前端将JWT发送给后端进行验证和解析，以获取用户信息和过期时间等信息。
2.1.2 详细步骤介绍 下面是基于JWT实现同域下的单点登录的详细步骤：
用户登录应用程序A，应用程序A将用户的身份信息打包成JWT，并设置有效期和其他必要的信息。JWT的生成可以使用各种JWT库，如jsonwebtoken。
应用程序A将JWT存储在cookie或localStorage中，并将其发送给浏览器。
用户访问应用程序B，应用程序B将检查cookie或localStorage中是否存在有效的JWT。
如果JWT存在且未过期，则应用程序B使用JWT库对JWT进行解码和验证，并从中获取用户的身份信息。
如果JWT验证成功，则应用程序B授权用户访问应用程序B。
如果JWT不存在或已过期，则应用程序B要求用户登录。
在用户注销或会话过期时，应用程序A和B都需要清除JWT。
需要注意以下几点：
应用程序A和B必须使用相同的JWT密钥，以确保JWT在不同的应用程序之间是可验证的。应用程序应该使用HTTPS协议来保护JWT的传输，以避免中间人攻击。应用程序应该设置JWT的有效期适当，以避免安全漏洞和用户体验之间的矛盾。应用程序应该定期更改JWT密钥，以增强安全性。 总之，基于JWT实现同域下的单点登录可以提高用户体验和应用程序的安全性，但需要注意确保JWT的安全性和可靠性。
2.1.3 图解步骤 2.1.4 JWT代码示例 不能直接放项目代码，所以放了示例，具体的规则，根据你的项目去设置，这个只是个示例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa4e51580d9bb9dc52c2fc2b7aab67b4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/47/">«</a>
	<span class="pagination__item pagination__item--current">48/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/49/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>