<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ff4492b6f8a2e0c651198c931fbf58/" rel="bookmark">
			【JS】JavaScript的隐式类型转换详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JavaScript中的数据类型 简单数据类型（原始类型）： String Number Boolean undefined null Symbol（ES6新增，用于表示独一无二的值，因为是原始类型，创建时不需new)
引用数据类型（复杂数据类型）： Object（Object、Array、Function本质上都是Object）
二、什么是隐式转换 当运算符在运算时，若两端数据类型不统一，编译器会帮我们自动转换成相同类型的数据，这就是隐式转换。
三、隐式转换规则 隐式转换是一步一步完成的，如果比较或运算的过程中数据类型仍不一致，最终会将两边数据都转成Number类型再进行运算。
转换步骤：
​ Object =&gt; String =&gt; Number
​ Boolean =&gt; Number
​ undefined/null =&gt; Number
四、什么情况下会发生隐式转换 当运算符两端的数据类型不一致，会触发隐式转换
1. +运算符 +可以拼接字符串 也是算术运算符
Number只有当与Number、Boolean、null、undefined+时，才是算术运算符
拼接字符串 非字符串数据先调用String()转成字符串 再进行拼接
对象toString()后为[object Object],第一个o小写，第二个大写
数组toString()
Number + String
console.log(1+"测试") // "1测试" Boolean + String
console.log(true+"测试") // "true测试" null + String
console.log(null+"1") // null1 undefined + String
console.log(undefined+"1") // undefined1 Array + String
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01ff4492b6f8a2e0c651198c931fbf58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3a86e73362f471c4fb97ea6b901074/" rel="bookmark">
			kingbaseESV8常用ksql命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		S = 显示系统对象 + = 显示详细信息
\d[S+] = 表、视图、序列
\d[S+] 名称 = 描述 表、视图、序列
\db[+] = 表空间
\du[+] = 用户 == \dg[S+] = 角色
\dp[+] = 对象权限
\dn[S+] = 模式
\dt[S+]= 表
\dv[S+] = 视图
\ds[S+] = 序列
\l[+] = 所有数据库
\s = 历史命令
test=# \i /aaa.sql 执行脚本
#下面命令，显示客户端ip和端口
select inet_client_addr(),inet_client_port() ;
#kingbase环境变量
export KINGBASE_HOST=127.0.0.1
export KINGBASE_PORT=54321
export KINGBASE_DATABASE=test
export KINGBASE_USER=system
#ksql执行sql
ksql test system -c 'select * from scott.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3a86e73362f471c4fb97ea6b901074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da4d285923b2fb10e7c3a6d120d638d2/" rel="bookmark">
			应用日志集成到ElasticSearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、阿里云sls平台集成日志 阿里sls集成日志步骤
2、filebeat 收集到指定es 安装docker容器
Docker安装
拉取镜像：
docker pull elastic/filebeat:7.5.1 启动：
docker run -d --name=filebeat elastic/filebeat:7.5.1 拷贝容器中的数据文件到宿主机：
mkdir -p /data/elk7 docker cp filebeat:/usr/share/filebeat /data/elk7/ 设置权限
chmod 777 -R /data/elk7/filebeat #go-w: 这个命令表示去掉文件的“组”和“其他用户”的写权限。其中， #g 代表组权限，o 代表其他用户权限，-w 表示去掉写权限。 chmod go-w /data/elk7/filebeat/filebeat.yml 配置filebeat
vim /data/elk7/filebeat/filebeat.yml 修改样例如下：
filebeat.inputs: - type: log enabled: true paths: - /var/log/*.log fields: AppId: "springbootadmin" ENV: "DEV" fields_under_root: true tags: ["服务ip地址自定义其他", "boot"] json.keys_under_root: true - type: log enabled: true paths: - /java/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da4d285923b2fb10e7c3a6d120d638d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98937db07a9f71d8436fe406fd3db52e/" rel="bookmark">
			看了一篇开源作者文章我沉默了良久还是发一篇心情文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源框架 NanUI 项目宣布将暂停开发，作者转行卖钢材的新闻让我心生悲意，开源作者生存现状很多人并不了解，在开源社区里能赚到钱的毕竟是少数丛林法则在开源社区同样适用，看了开源框架 NanUI 项目宣布将暂停开发，作者转行卖钢材报道：
公告如下：
作出此艰难决定本人只能深表抱歉。
由于 NanUI 项目一直以来都比较小众，因此社区生态并没有建立起来，至今为止几乎没有收到过任何 PR，这也造成项目目前还是由我一个人开发这种局面。
NanUI 项目目前在行业内已经有一定的用户基础，也不乏有像中国联通、百旺金赋、城市快捷酒店、申通等这些有点名头的用户，但目前项目依然采取开源免费的政策，之前偶尔会有朋友通过二维码 5 块 10 块的进行捐助，另外靠着提供支持 H264 编码的 CEF 编译库“逼捐”每年也最多有一两千的收入，但这对一个项目的维持和开发是远远不够的。
非常不幸的是，本人所在公司也因疫情的原因去年（2022 年）初彻底宣布裁减所有开发岗位，因此本人也只能顺应大流在 36 岁这个尴尬的年纪失业，原本在上班的时候可以靠着闲暇摸鱼时间开发和维护 NanUI，但这一失业，这种机会也完全丧失了。
失业后，经过深思熟虑我只能跨行业以销售钢材为生，写代码从曾经的职业变成了业余兴趣爱好，毕竟得生活，得吃饭，我也只能先解决好温饱问题。
经过一年的跨行业工作，俗话说隔行如隔山，本人只能耗费大量精力从 0 学起，加之这两年经济形势糟糕，即使消耗了我无数的时间和精力我还是很难在业绩上有所突破。为了生存，本人只能花费更多的时间和精力去谈单，去销售，去收款，因此已经很难再腾出时间来开发和维护 NanUI 项目，对此我深感无奈，也希望后面生活和工作稳定后能腾出时间来继续维护 NanUI。
目前 NanUI 的最新版本已经开发完成，本来打算把这个版本作为 NanUI 的 1.0 正式版进行发布，但是实在没有时间和精力去编写文档和制作示例程序，因此这个版本的发布只能延期，等后面有时间把文档和示例编写完成后再进行发布。只能辛苦各位继续使用目前的 0.9.109 版本的 NanUI 了。
当前 0.9.109 版本的 NanUI 在功能上已基本稳定，也没有什么致命的 Bug，因此可以用于开发各种生产环境的软件。如果遇到问题，可以到 QQ 群咨询已经开发有成熟产品的各位大佬，也可以私聊我留言，我有空的时候尽量回复。
感谢各位多年来会 NanUI 项目的支持和关注，后会有期！
此致，
林选臣 于 2023 年国庆。
隔着屏幕都知道一个优秀而热爱编程行业的人才离开编程界，深感遗憾，很多企业天天喊着引进人才、技术、观念说只要你优秀薪水不是问题，然而优秀人才没有发现，裙带关系倒挺多，最后都是走在套壳路上混得风生水起。我于2016年离开了专职编程岗位后也经历很多事情，热衷于技术的技术人才确实不易，由于热衷于技术人际关系也许很单一，没有什么抗风险能力。企业要裁员首先从技术入手成为一种风气，35岁以上不录用成为一种风尚，而年纪早过了40的我对于IT行业来说看着就瑟瑟发抖 。其实我经常在想很多人技术比我都差，为什么能领那么高薪水，能进那么好企业，美国很多程序员7-80岁还是主程，难道有什么其他我不知道的规则。哎！难与描述的心情。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d7f8656d4904c4b7e10e5c40faa7f8/" rel="bookmark">
			使用Elasticsearch处理大量数据,如何翻页查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用Elasticsearch处理大量数据时，从第一页直接跳转到第100页进行查询确实是一个挑战，因为需要计算跳过的记录数并有效地获取目标页的数据。以下是一些建议来实现这种跳页查询：
使用from和size参数：
Elasticsearch提供了from和size参数来实现分页。from参数指定了要跳过的文档数量，而size参数指定了每页返回的文档数量。要跳到第100页，你可以设置from为(100 - 1) * size，其中size是你每页想要显示的文档数。
GET /your_index/_search { "from": 99 * size, // 例如，如果每页10条记录，那么这里就是 990 "size": size, // 每页显示的记录数，例如10 "query": { // 你的查询条件 } } 注意：当from的值非常大时，这种分页方式可能会变得非常低效，因为Elasticsearch需要扫描并跳过指定数量的文档才能找到目标页的数据。对于非常大的数据集，这可能会导致性能问题。
使用search_after参数：
search_after参数允许你基于上一页的最后一个文档的排序值来进行分页。这种方法比使用from和size更高效，特别是在处理大量数据时。你需要保存上一页最后一个文档的排序字段的值，并将其作为search_after参数的值。
GET /your_index/_search { "size": size, // 每页显示的记录数 "query": { // 你的查询条件 }, "sort": [ { "your_sort_field": { // 用于排序的字段 "order": "asc" // 排序顺序，可以是asc或desc } } ], "search_after": [last_doc_sort_value] // 上一页最后一个文档的排序值 } 使用search_after时，你需要确保查询中的排序条件与search_after中使用的排序条件一致。
使用Scroll API：
对于需要遍历大量数据的情况，Elasticsearch提供了Scroll API。这种方法允许你保持一个“游标”来遍历查询结果，而不是一次性获取所有结果。Scroll API通常用于大量数据的导出或处理，而不是常规的分页展示。但它也可以用于实现高效的跳页功能，尤其是当跳过的页数非常多时。
优化索引和查询：
确保你的Elasticsearch索引已经针对查询进行了优化，例如通过合理的映射设置、分析器和过滤器配置。此外，优化查询本身也很重要，避免使用耗时的查询条件，尽量使用过滤器和聚合来提高性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d7f8656d4904c4b7e10e5c40faa7f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ef48c0053b4c90442dfa8a55e816a5/" rel="bookmark">
			【深度视觉】第十一章：语义分隔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十三、语义分隔 前面讲的都是视觉识别中的图像分类任务以及图像分类的几个经典算法，下面我们开始语义分隔任务。
1、视觉识别的四大任务
分类任务：就是用我们前面讲的经典架构和前沿网络来对图像进行分类，看图像是猫还是狗还是汽车还是青蛙的这种整图的分类任务，就是给一个整图打一个标就好了。
语义分隔：是像素级的分类任务，就是对图像中的每个像素都进行分类。就是对原图的每个像素都分是猫还是草还是树还是天空等这种分类任务。
目标检测：是在图像的区域中进行分类，就是滑窗滑动，判断滑窗图像的类别。相当于是区域级的分类问题。
实例分隔：也是像素级的分类任务，但比语义分隔更复杂。实例分隔是在语义分隔的基础上，还得分狗A狗B猫A猫B。就是不仅要区分一个像素是不是目标像素，还得区分这个像素是谁，是狗A还是猫B呀？
可见，分类、目标检测、语义分隔、实例分隔都是分类任务，只是对图片识别的程度不一样，所以它们对应的标签也是不一样的。
分类是对图像了解程度最浅的一个任务，分类模型得到的信息也是最少的，也就是标签只有"是"或"不是"这种简单的信息。
目标检测，模型得到的信息是一个区域级的信息，也就是训练数据的标签是图像某些区域的"是"或"不是"这种信息。
语义分隔，其训练数据的标签是一个像素级的标签。
实例分隔的标签就是基于实例的像素级，就是不仅要告诉你这个像素"是"或"不是"，还得告诉你这个"是"的像素是谁。
也所以，目标检测模型、语义分隔模型、实例分隔模型都是基于前面我们学的googlenet、resnet或者VGG改进而来的。
2、语义分隔思想及原理
就是给每个像素分配类别标签，不区分实例，只考虑像素类别。
（1）语义分隔思路1：
只要我们指定窗口的尺寸，上图的语义分隔思想就是可行的。但是这种操作效率太低！重叠区域的特征反复被计算，就是相邻很近的像素周围的区域不断被送入CNN被重复不断地进行特征计算，这样就非常低效。为了避免重复计算，就出现了全卷积神经网络。我们知道卷积层本来就是提取特征的，全卷积网络就可以一次性把一整张图的特征都计算出来，那所以最后只要一次性输出所有像素的类别即可：
（2）语义分隔思路2：
这种思路我们就基本不怎么care输入图像的尺寸了，只要我们只要padding保证上图红框部分的尺寸和原图一直保持一致就可以了。
上图我们的标答是一个四分类：牛、天空、草地、树，所以每张图片的每个像素的标答的one-hot形式就是长度为4，也就是上图的C就得是4。
思路2虽然比思路1的计算量小了，但也有很明显的弊端就是：处理过程中一直保持原始分辨率，对显存的需求就会非常庞大。我们知道要想提取更复杂的特征和语义就得加深网络，那特征图如果一直保持很大的尺寸，深度就必然要受到算力的制约！我们知道VGG加深网络是在不断减半特征图的基础上加深网络的，就这样vgg的参数都是天量的了。我们知道在CNN网络中，所有向前传播的参数和中间结果都是要保存的，用来反向传播计算梯度的，如果前向的变量实在是太多，硬件肯定是支撑不了的。所以对于大尺寸图片思路2也是无能为力的。
（3）语义分隔思路3：
至于上下采样的具体实现方法，我们的【深度视觉】第五章：卷积网络的重要概念及花式卷积，中的转置卷积部分写的非常清楚，有相关实现的api，大家可以参考。
另外，上图中的D1是必须等于类别个数的，和上图的C的值是一样的！
3、语义分隔模型：U-Net
（1）U-Net简介
U-Net可以说是最常用、最简单的一种分割模型了，简单、高效、易懂、易构建、可以从小数据集中训练，是2015年《U-Net: Convolutional Networks for Biomedical Image Segmentation》提出的模型。论文连接：https://arxiv.org/abs/1505.04597 大家可以自行下载原论文阅读。
（2）U-Net和FCN、Autoencoder之间的渊源
首先，U-Net和FCN都是在Autoencoder(AE)之后提出的，也就是说U-Net和FCN都是借鉴了Autoencoder的思想框架。Autoencoder是自动编码器，也就是编码和解码（encoder-decoder），早在2006年就被Hinton大神提出来并发表在nature上了，此后，经过业界的魔改，现在已经形成自动编码器家族Autoencoders，这个家族是深度学习领域经典的无 监督网络一派，不仅用在语义分隔，在图像生成领域、图像降噪、图像压缩、风格迁移等领域也是有不可撼动的绝对地位的。下图是自动编码器的网络架构：
其次，U-Net比FCN(Fully Convolutional Netowkrs)稍晚提出来，但都发表在2015年。和FCN相比，U-Net的第一个特点是完全对称，也就是左边和右边是很类似的，而FCN的decoder相对简单，只用了一个deconvolution的操作，之后并没有跟上卷积结构。第二个区别就是skip connection，也就是特征图融合环节，FCN用的是加操作(summation),就是把特征图对应位置的特征值相加来融合特征；U-Net用的是叠操作(concatenation),就是通过通道数的拼接，形成更厚的特征，当然这样会更佳消耗显存。
再次，在U-Net和FCN被提出后的几年中，有很多很多的论文去讲如何改进U-Net或者FCN，不过这个分割网络的本质的拓扑结构是没有改动的。举例来说，在ICCV上何凯明大神提出的Mask RCNN，相当于一个检测，分类，分割的集大成者，我们仔细去看它的分割部分，其实使用的也就是这个简单的FCN结构。这说明了这种“U形”的编码解码结构确实非常的简洁，并且最关键的一点是好用。
最后，从论文中我们可以知道，Unet提出的初衷是为了解决医学图像分割问题，而且unet也确实在这个领域大放异彩，效果非常好，目前大多数医疗影像语义分割任务都会首先用Unet作为baseline。而Unet在医疗图像分隔领域之所以这么好，我感觉是：我们知道浅层卷积关注的是图像的纹理特征，就是关注的是图像的细节点，而深层卷积则关注的是高层语义信息，就是图像的轮廓等更大感受野的信息。但是不管是深层特征还是浅层特征都是有各自的意义的。而医疗影像语义较为简单、结构固定。因此语义信息相比自动驾驶等较为单一，因此并不需要去筛选过滤无用的信息。医疗影像的所有特征都很重要，因此低级特征和高级语义特征都很重要，所以U型结构的skip connection结构（特征拼接）就能更好的派上用场。因为通过反卷积得到的更大的尺寸的特征图的边缘，是缺少信息的，毕竟每一次下采样提炼特征的同时，也必然会损失一些边缘特征，而失去的特征并不能从上采样中找回，因此通过特征的拼接，来实现边缘特征的一个找回是非常有意义的。
（3）U-Net架构
上图架构是U-Net原论文中的架构图，这个架构相对googlenet和resnet已经非常简单了，所以我也简单介绍一下：
这个架构呈现U型，左边部分就是用传统的卷积层不断实现下采样效果，不断提取图像特征，将图像信息进行压缩，或者说就是enconding的过程；右边部分就是用传统的转置卷积不断地对图像进行上采样，就是decoding的过程；中间的skip connection就是把对应左边的特征图进行crop and copy，就是先crop(因为从架构图上看，很明显左边的特征图尺寸和右边的不一样！所以必须得先crop)，然后再concat。
下面的代码是我严格按照上面架构图写的架构代码，完全是我自己的风格写的，所以仅供参考：
import torch import torch.nn as nn import torch.nn.functional as F class downsample(nn.Module): def __init__(self, in_channels, out_channels): super().__init__() self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7ef48c0053b4c90442dfa8a55e816a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7af4ac40a74fe498cfb742c9639df45/" rel="bookmark">
			用python写测试接口的状态的类测试例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**确保 Python 环境可用：**确保你已经安装了 Python 解释器，并且设置好了适当的开发环境。你可能需要安装依赖管理工具（如 pip）以及所需的库和框架。
**导入相关库：**根据你的测试需求，导入相关的库和框架。例如，常用的测试框架包括unittest、pytest和requests等。你可以使用pip安装所需的库。
**创建测试类：**使用 Python 编程语言创建一个新的测试类（通常是一个继承自测试框架的类）。你可以使用你喜欢的文本编辑器或IDE（如VS Code、PyCharm等）来编写和管理代码。
**编写测试方法：**在测试类中编写测试方法，每个方法用于测试接口的一个状态。例如，你可以编写一个方法来测试接口的成功响应，并编写另一个方法来测试接口的错误响应。使用适当的断言语句来验证接口返回的状态码、响应数据等。
**设置测试环境和数据：**在测试方法中，设置适当的测试环境和数据。这可能包括创建模拟对象、配置接口的 URL、准备测试数据等。
**编写测试逻辑：**在测试方法中编写逻辑，通过发送 HTTP 请求调用接口并获取响应数据。你可以使用第三方库（如requests）来发送 HTTP 请求。对于每个测试方法，你可以设置不同的请求参数和验证响应结果。
**运行测试：**使用测试框架提供的运行命令来执行测试类。比如使用unittest框架，你可以使用python -m unittest test_module.py命令来运行测试。
**分析测试结果：**查看测试运行的结果报告，检查通过的测试方法和失败的测试方法。如果有失败的测试，查看失败原因，并尝试调试和修复问题。
**集成到 CI/CD 流程（可选）：**如果你想将测试自动集成到 CI/CD 流程中，你可以使用持续集成工具（如Jenkins、GitLab CI/CD等）来自动运行测试并生成报告。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864c9e02cb9a141981b893e5af68f5dd/" rel="bookmark">
			微服务保护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务保护 1.初识Sentinel1.1.雪崩问题及解决方案1.2.服务保护技术对比1.3.Sentinel介绍和安装1.4.微服务整合Sentinel 2.流量控制2.1.簇点链路2.1.快速入门2.2.流控模式2.3.流控效果2.4.热点参数限流 3.隔离和降级3.1.FeignClient整合Sentinel3.2.线程隔离（舱壁模式）3.3.熔断降级 4.授权规则4.1.授权规则4.2.自定义异常结果 5.规则持久化5.1.规则管理模式5.2.实现push模式一、修改order-service服务二、修改sentinel-dashboard源码 1.初识Sentinel 1.1.雪崩问题及解决方案 雪崩问题
微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。
如图，如果服务提供者I发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I的业务似乎不受影响。
但是，依赖服务I的业务请求被阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：
服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，那么当前服务也就不可用了。
那么，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，雪崩就发生了：
超时处理
解决雪崩问题的常见方式有四种：
超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待 仓壁模式
方案2：仓壁模式
仓壁模式来源于船舱的设计：
船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。
于此类似，我们可以限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离。
断路器
断路器模式：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。
断路器会统计访问某个服务的请求数量，异常比例：
当发现访问服务D的请求异常比例过高时，认为服务D有导致雪崩的风险，会拦截访问服务D的一切请求，形成熔断：
限流
流量控制：限制业务访问的QPS，避免服务因流量的突增而故障。
总结
什么是雪崩问题？
微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。 可以认为：
限流是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种预防措施。
超时处理、线程隔离、降级熔断是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种补救措施。
1.2.服务保护技术对比 在SpringCloud当中支持多种服务保护技术：
Netfix HystrixSentinelResilience4J 早期比较流行的是Hystrix框架，但目前国内实用最广泛的还是阿里巴巴的Sentinel框架，这里我们做下对比：
SentinelHystrix隔离策略信号量隔离线程池隔离/信号量隔离熔断降级策略基于慢调用比例或异常比例基于失败比率实时指标实现滑动窗口滑动窗口（基于 RxJava）规则配置支持多种数据源支持多种数据源扩展性多个扩展点插件的形式基于注解的支持支持支持限流基于 QPS，支持基于调用关系的限流有限的支持流量整形支持慢启动、匀速排队模式不支持系统自适应保护支持不支持控制台开箱即用，可配置规则、查看秒级监控、机器发现等不完善常见框架的适配Servlet、Spring Cloud、Dubbo、gRPC 等Servlet、Spring Cloud Netflix 1.3.Sentinel介绍和安装 初识Sentinel
Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：https://sentinelguard.io/zh-cn/index.html
Sentinel 具有以下特征:
丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。
完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。
广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。
完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864c9e02cb9a141981b893e5af68f5dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e12efc31ef8bfce072dff2c8f925b8/" rel="bookmark">
			ES的集群节点发现故障排除指南（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文是ES官方文档关于集群节点发现与互联互通的问题排查指南内容，第二部分。
原文参考及相关内容：
英文原文（官网）
第一部分-（1）
已选出主节点但状态不稳定？ 当一个节点赢得主节点选举时，它会在日志中记录一条包含 “elected-as-master” 的消息。如果这种情况重复发生，则说明当选为主节点的节点处于不稳定状态。在这种情况下，应重点关注来自主节点候选节点的日志，以了解为什么选举胜出者停止作为主节点并触发新一轮选举。
排查步骤 如果日志显示主节点由于超时或网络相关问题而不稳定，那么请按照以下方式缩小问题范围进行排查。
垃圾回收暂停 垃圾回收暂停会记录在Elasticsearch默认生成的GC日志中，同时也会通常被JvmMonitorService记录到主节点日志中。利用这些日志可以确认节点是否正在经历高堆内存使用率以及长时间的GC暂停。如果是这样的话，对于高堆内存使用率的排查指南提供了一些进一步调查的建议，但通常情况下，你需要在堆内存高使用率期间捕获堆转储，以便全面理解问题所在。 虚拟机暂停 虚拟机暂停同时也会影响同一主机上的其他进程。虚拟机暂停通常会导致系统时钟出现不连续性，Elasticsearch会在其日志中报告这一现象。如果你看到有证据表明其他进程在同一时间暂停运行，或者出现了意外的时钟不连续，那么应当对运行Elasticsearch的基础架构进行深入调查。 数据包捕获 数据包捕获将揭示系统级和网络级的故障，特别是在所有相关节点同时捕获网络流量时。你应该能够观察到节点间连接中的任何重传、丢包或其他延迟情况。通过获取Elasticsearch主进程的堆栈转储（例如，使用jstack工具）或执行一段时间内的性能追踪（例如，使用Java Flight Recorder），可以识别出等待特定线程可用时的长时间等待。 节点热点线程API 节点热点线程API有时能提供有用的信息，但需注意该API在集群中的所有节点上都需要一定数量的transport_worker和generic线程。该API可能会受到你正试图诊断的问题的影响。相比之下，jstack更加可靠，因为它不需要任何JVM线程的支持。 参阅网络线程模型 参与发现和集群成员管理的线程主要是transport_worker和cluster_coordination线程，它们不应出现长时间等待的情况。在Elasticsearch日志中，尤其是来自org.elasticsearch.transport.InboundHandler的警告日志中，也可能存在有关线程长时间等待的证据。有关更多信息，请参阅网络线程模型文档。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097daab60c54ff1cba037427ba1c697a/" rel="bookmark">
			【报错】ResizeObserver loop completed with undelivered notifications
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在写项目（Vue3+TS）的时候遇见了报错
ERROR ResizeObserver loop completed with undelivered notifications. at handleError (webpack-internal:///./node_modules/webpack-dev-server/client/overlay.js:299:58) at eval (webpack-internal:///./node_modules/webpack-dev-server/client/overlay.js:318:7) 原因我也不是很清楚，问了GPT，回答如下
直接说解决方案：
在App.vue文件中加入防抖函数就行了，debounce方法可以自己写，我为了保持稳定性，采用了lodash
import { debounce } from "lodash"; const _ = (window as any).ResizeObserver; (window as any).ResizeObserver = class ResizeObserver extends _ { constructor(callback: (...args: any[]) =&gt; void) { callback = debounce(callback, 100); super(callback); } }; }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d60bc11b0f040a80531d0742c7e3876/" rel="bookmark">
			Web 常见的攻击方式有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的 Web 攻击方式有以下几种：
跨站脚本攻击（XSS 攻击）
跨站请求伪造（XSRF 攻击）
SQL 注入
XSS 攻击 MDN 定义如下：
跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。若受害者运行这些恶意代码，攻击者就可以突破网站的访问限制并冒充受害者。
简单来说，跨站脚本攻击利用恶意脚本发起攻击，通常这些恶意脚本可以任意读取 cookie、session tokens，或其他敏感网站信息。以下两种情况容易发生 XSS 攻击：
从一个不可靠的链接进入到一个 Web 应用程序。
没有过滤掉恶意代码的动态内容被发送给 Web 用户。
如果要过滤恶意代码，提交给后端，就能尽可能避免此类攻击。
DOM 中的内联事件监听器，如 location、onclick 等，a 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。
如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就能在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。
XSRF 攻击 CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。
如果你登录了 bank.com 网站，此时，你有了来自该网站的身份验证 cookie。浏览器将会在你的每次请求上带上 cookie，以便识别你，执行所有的敏感财务操作。
当你在另一个窗口中浏览网页时，不小心访问了一个 eval.com 的网站，该网站有一段提交表单的 JavaScript 代码： ，它含有交易字段。这时候，提交表单请求虽然由 eval.com 发起，当它携带了 bank.com 的 cookie，因此验证通过，攻击就完成了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d60bc11b0f040a80531d0742c7e3876/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c170867d266c61b9891c2eeec5e6dc1/" rel="bookmark">
			从原理到实践：深入探索Linux安全机制（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文将从用户和权限管理、文件系统权限、SELinux、防火墙、加密和安全传输、漏洞管理和更新等几个Linux安全机制中的重要方面，深入探索其工作原理和使用方法。在当今数字化时代，网络安全问题备受关注，Linux作为广泛应用的操作系统之一，其安全性至关重要。无论你是Linux系统的初学者还是资深管理员，本文都将为你提供宝贵的经验和启发，帮助你在保护网络安全的道路上行稳致远。
Linux Linux 是一种开源的类Unix操作系统内核，由Linus Torvalds在1991年首次发布，其后又衍生出许多不同的发行版（如Ubuntu、Debian、CentOS等）。Linux操作系统则是由Linux内核与各种应用程序、工具和库组成的完整操作系统，在其众多的特性中，Linux以其稳定性和安全性而闻名，这首先得益于开源社区的广泛参与和持续改进，其次就是Linux优秀的安全机制，这些保证了其能够提供一个高度稳定和安全的运行环境，事实上在服务器领域、嵌入式系统、超级计算机等多个领域也得到了广泛应用，并拥有庞大的用户群体和开发者社区。
下面将通过两篇文章来，从用户和权限管理、文件系统权限、SELinux、防火墙、加密和安全传输、漏洞管理和更新等几个Linux安全机制中的重要方面，和大家分享一下其工作原理和使用方法：
《从原理到实践：深入探索Linux安全机制（一）-CSDN博客》
《从原理到实践：深入探索Linux安全机制（二）-CSDN博客》
防火墙 Linux 内置了防火墙软件，如 iptables 或更现代的 firewalld，用于限制网络流量并保护系统免受恶意访问。
在 CentOS 系统中，默认的防火墙软件是 firewalld。Firewalld 是一个动态的守护进程，用于管理系统的防火墙规则，提供了一种简单而灵活的方式来配置和管理防火墙设置。通过 firewalld，用户可以轻松地定义不同区域、服务和端口的访问规则，以保护系统免受网络攻击。在 CentOS 7 及更新的版本中，firewalld 取代了之前版本中使用的 iptables 作为默认的防火墙管理工具。
其工作原理可以简单概括一下：
数据包过滤：防火墙通过检查进出网络的数据包，根据预定义的规则决定是否允许通过。这些规则通常基于源地址、目标地址、端口号等条件进行匹配。网络地址转换（Network Address Translation, NAT）：防火墙可以执行 NAT，将内部网络的私有 IP 地址转换为公共 IP 地址，从而隐藏内部网络的实际结构，增加安全性。状态跟踪：防火墙能够跟踪网络连接的状态，识别哪些数据包是属于已建立的连接，以便有效地管理网络流量。应用层代理：有些防火墙还支持深度数据包检查，能够检查数据包中的应用层信息，如 HTTP 头部，以提供更精细的访问控制。日志记录：防火墙通常会记录被阻止的连接请求或其他安全事件，以便管理员进行审计和排查问题。 日常工作中如何来管理Linux中的防火墙呢？这里以firewalld举例：
1、启动/停止/重启/检查状态：
启动 firewalld 服务
sudo systemctl start firewalld 停止 firewalld 服务
sudo systemctl stop firewalld 重启 firewalld 服务
sudo systemctl restart firewalld 检查 firewalld 服务状态
sudo systemctl status firewalld 2、查询防火墙状态和规则：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c170867d266c61b9891c2eeec5e6dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60530ac7ba91e043490eb4f8cc289ab3/" rel="bookmark">
			【CSS】实现文字描边
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过 -webkit-text-stroke 即可实现文字描边，这个复合属性接收两个参数，分别为描边宽度，以及描边颜色。
需要注意的是，-webkit-text-stroke是一个非标准属性，兼容性会出现问题。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h2 { -webkit-text-stroke: 1px #dfbdbd; color: transparent; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;千江有水千江月&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/796a34c117b23f83e34bfa7d00c413ef/" rel="bookmark">
			Docker的常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker是一个开源的应用容器引擎，它可以将应用程序及其依赖以容器的形式打包，提供了一套命令行工具来管理容器。
以下是Docker的一些常用命令及使用实例：
docker run：运行一个容器 示例：docker run -d --name mycontainer nginx 解释：运行一个名为mycontainer的容器，基于nginx镜像，并在后台运行。
docker ps：列出运行中的容器 示例：docker ps 解释：列出当前正在运行的容器。
docker stop：停止一个容器 示例：docker stop mycontainer 解释：停止名为mycontainer的容器。
docker rm：删除一个容器 示例：docker rm mycontainer 解释：删除名为mycontainer的容器。
docker images：列出本地的镜像 示例：docker images 解释：列出本地已经下载的镜像。
docker pull：下载一个镜像 示例：docker pull nginx 解释：下载nginx镜像。
docker push：推送一个镜像到远端仓库 示例：docker push username/repository:tag 解释：将本地镜像推送到远端仓库。
docker build：从Dockerfile构建镜像 示例：docker build -t myimage . 解释：根据当前目录下的Dockerfile构建一个名为myimage的镜像。
docker exec：在运行的容器中执行命令 示例：docker exec -it mycontainer bash 解释：在名为mycontainer的容器中执行bash命令。
docker logs：查看容器的日志 示例：docker logs mycontainer 解释：查看名为mycontainer的容器的日志。
以上是Docker的一些常用命令及使用实例，通过这些命令可以管理和操作容器、镜像等资源。具体命令的使用说明可以通过docker命令加上--help参数来查看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73034179f2da866d8accf9e379e38f14/" rel="bookmark">
			【WEEK4】 【DAY3】整合SSM框架之功能实现—修改、删除数据【中文版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.3.20 Wednesday
接上文【WEEK4】 【DAY2】整合SSM框架之功能实现—总览、添加数据【中文版】
目录 7.6.修改功能7.6.1.修改BookController.java7.6.2.修改allBook.jsp7.6.3.新建updateBook.jsp7.6.4.修改MyBatis-config.xml7.6.5.运行 7.7.删除功能7.7.1.修改BookController.java7.7.2.修改allBook.jsp7.7.3.修改BookDao.xml7.7.4.运行 7.6.修改功能 7.6.1.修改BookController.java （加上删除功能的完整BookController.java代码位于7.7.1.）
//跳转到修改页面 @RequestMapping("/toUpdate") public String toUpdatePaper(int id,Model model){ Books books = bookService.queryBookById(id); //返回一本书 model.addAttribute("QBook",books); return "updateBook"; } //修改书籍 @RequestMapping("updateBook") public String updateBook(Books books){ System.out.println("updateBook=&gt;"+books); bookService.updateBook(books); return "redirect:/book/allBook"; } 7.6.2.修改allBook.jsp &lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;书籍展示页&lt;/title&gt; &lt;%--BootStrap美化页面--%&gt; &lt;%--导入在线BootStrap--%&gt; &lt;link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.2.3/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;%--容器--%&gt; &lt;div class="row clearfix"&gt; &lt;%--标记栏，清除浮动--%&gt; &lt;div class="col-md-12 column"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73034179f2da866d8accf9e379e38f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691894ccc1f3991cf43c2b14f7fef075/" rel="bookmark">
			C#使用ASP.NET Core Razor Pages构建网站（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章讲了HTTP协议的基本概念、客户端Web开发技术以及ASP.NET Core框架的关键特点和创建项目方法
链接：C#使用ASP.NET Core Razor Pages构建网站（一）
接下来继续了解ASP.NET Core Razor Pages构建网站的后续内容
了解Razor Pages Razor Pages允许开发人员轻松地将HTML标记和C#代码混合在一起，这是使用.cshtml扩展名的原因。
默认情况下，ASP.NET Core在名为Pages的文件夹中查找Razor Pages。
1.启用Razor Pages 要在ASP.NET Core应用程序中启用Razor Pages，需要执行以下步骤：
在项目中的Startup.cs文件中，找到ConfigureServices方法，并添加以下代码以启用Razor Pages：
services.AddRazorPages(); 接着，在Configure方法中，确保添加以下代码以配置路由到Razor Pages：
app.UseEndpoints(endpoints =&gt; { endpoints.MapRazorPages(); }); 最后，在应用程序中创建一个Razor页面（.cshtml文件），并可以开始使用Razor语法构建动态内容了。
2.定义Razor页面 在您的ASP.NET Core项目中创建一个新的Razor页面。通常，Razor页面的文件扩展名为.cshtml。
在创建的Razor页面文件中，您可以使用Razor语法来构建动态内容。以下是一个简单的示例：
@page &lt;h1&gt;Hello, Razor Pages!&lt;/h1&gt; 您也可以在Razor页面中使用C#代码块来处理业务逻辑。例如，在页面模型（Page Model）中定义处理程序方法： public class IndexModel : PageModel { public void OnGet() { ViewData["Message"] = "Welcome to Razor Pages!"; } } 最后，确保将页面模型与Razor页面关联。您可以使用@model指令将页面模型与Razor页面相关联： @page @model IndexModel &lt;h1&gt;@ViewData["Message"]&lt;/h1&gt; 3.通过Razor页面使用共享布局 1.创建共享布局文件：
在您的ASP.NET Core项目中创建一个共享布局文件，通常以.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/691894ccc1f3991cf43c2b14f7fef075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d23b15ff9b830bd5b37374fbfcf9ea/" rel="bookmark">
			达梦数据库导出数据表结构为excel或html或文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基础版本二、优化版本 一、基础版本 select utc.column_name 字段名, utc.data_type 字段类型, utc.data_length 数据长度, utc.data_precision 数据精度, utc.nullable 是否为空 , ucc.comments 备注 from user_tab_columns utc,user_col_comments ucc where utc.column_name = ucc.column_name and utc.Table_Name = ucc.Table_Name and utc.Table_Name = '表名' and owner='模式名' 二、优化版本 select utc.Table_Name 表名称, tab.COMMENTS 表中文名称, utc.column_name AS 字段名, utc.data_type AS 字段类型, utc.data_length AS 数据长度, utc.data_precision AS 数据精度, utc.nullable AS 是否为空 , ucc.comments AS 备注 from user_tab_columns utc,user_col_comments ucc,SYS.USER_TAB_COMMENTS tab where utc.column_name = ucc.column_name and utc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05d23b15ff9b830bd5b37374fbfcf9ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b36204f05bc352bdd7e0be3e9eb1cab/" rel="bookmark">
			STM32学习笔记（2）- 软件keil5安装和新建工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无人问津也好，技不如人也罢，都应静下心来，去做该做的事。
最近在学STM32，所以也开贴记录一下主要内容，省的过目即忘。视频教程为江科大（改名江协科技），网站jiangxiekeji.com
软件安装 keil5 MDK 如果已经安装keil5 C51，可以放在同一个安装目录下，这样MDK和C51就可以共存。
安装时间较久，耐心等待即可。
安装器件支持包 因为ARM芯片型号太多，可选择特定的支持包安装
新建工程-Software Packs（为STM32系列支持包）
新建工程-Legacy Device Database（为C51系列支持包）
离线安装 双击安装STM32F1XX即可
在线安装（拓展部分） 防止以后开发新的芯片找不到型号 需联网，下载较慢
国产芯片GD32F103C8
安装完后关掉整个界面即可
然后新建工程选择对应的支持包就好。
软件注册 点击ADD LIC 安装STLINK驱动 此电脑-右键-属性-设备管理器
说明电脑没有安装STLINK的驱动 双击对应的安装即可，设备管理器-通用串行总线 查看到ST-LINK就是安装好了
安装JLINK驱动 安装USB转串口驱动 这个USB转串口的芯片是CH340，和51单片机一样
然后在设备管理器-端口-CH340表示安装成功。
新建工程 STM32程序编写分三种：
一是寄存器，和C51一样，直接对寄存器配置；
二是库函数，使用ST官方封装好的函数来间接配置寄存器。本教程使用此方法。
三是基于HAL库，用图形化界面快速配置STM32，能快速上手，但会对底层不了解。
以下为库函数的目录
下面开始新建库函数的工程
1、新建一个文件夹来存工程 如D:\software\STM32project
2、新建工程模板 打开keil5 - project - new uVision project -D:\software\STM32project - 新建文件夹（2-1 工程模板）- Project 3、复制启动文件 D:\software\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm 把这些启动文件复制到 2-1 工程模板 文件夹 的新建文件夹Start中
D:\software\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x的
stm32f10x.h文件是STM32的头文件、
两个system文件是用来配置时钟的，这三个文件同样复制到Start文件中。
4、内核寄存器的文件 D:\software\STM32入门教程资料\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport的两个cm3文件也复制到Start文件夹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b36204f05bc352bdd7e0be3e9eb1cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6a683fb654a78e2a565ce4741282b3/" rel="bookmark">
			基于SSM&#43;Jsp&#43;Mysql的高校二手交易平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于SSM+Jsp+Mysql的高校二手交易平台
基于SSM+Jsp+Mysql的高校二手交易平台的设计与实现
开发语言：Java框架：ssm技术：JSPJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 系统展示
前台首页
用户注册
用户登录
个人中心
商品信息
管理员登录
商品上架管理
商品信息管理
客服聊天管理
联系商家管理
订单信息管理
摘要
本文主要论述了如何使用JAVA语言开发一个高校二手交易平台，本系统将严格按照软件开发流程进行各个阶段的工作，采用B/S架构，面向对象编程思想进行项目开发。
高校二手交易平台的主要使用者分为管理员和用户，实现功能包括管理员：个人中心、用户管理、商品上架管理、订单信息管理、商品信息管理、联系商家管理、论坛管理、管理员管理、系统管理，用户：个人中心、商品上架管理、订单信息管理、商品信息管理、联系商家管理、我的收藏管理，前台首页；首页、商品信息、论坛信息、新闻资讯、我的、跳转到后台、客服等功能。
研究背景
随着网络不断的普及发展，高校二手交易平台依靠网络技术的支持得到了快速的发展，首先要从用户的实际需求出发，通过了解用户的需求开发出具有针对性的高校二手交易平台，利用目前网络给用户带来的方便快捷这一特点对系统进行调整，设计的系统让用户的使用起来更加方便，本系统的主要目的就是给用户带来方便与快捷，用户只要在家中就可以进行操作。同时随着电子商务的发展网上高校二手交易平台已经受到广大用户的关注。
关键技术
JSP(Java脚本页面)是Sun和许多参与建立的公司所提倡的动态web技术。将Java程序添加到传统的web页面HTML文件(*)。htm,*。Html)。
JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现像，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
系统实现
进行系统主要功能模块的界面展示。
高校二手交易平台，在系统首页可以查看首页、商品信息、论坛信息、新闻资讯、我的、跳转到后台、客服等内容。
管理员登录，通过填写用户名、密码进行登录。
用户登录进入高校二手交易平台可以查看个人中心、商品上架管理、订单信息管理、商品信息管理、联系商家管理、我的收藏管理等内容。
系统测试
测试系统的每一个功能是否能够正常运行，是否可以满足用户的需求。
结论
实现了JSP与MYSQL相结合构建的高校二手交易平台，要想吸引更多的用户，系统的界面必须要美观、有特色、友好，功能要健全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/401365ae3c1392512a85ce431380f195/" rel="bookmark">
			2.6、媒体查询（mediaquery）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 媒体查询作为响应式设计的核心，在移动设备上应用十分广泛。媒体查询可根据不同设备类型或同设备不同状态修改应用的样式。媒体查询常用于下面两种场景：
针对设备和应用的属性信息（比如显示区域、深浅色、分辨率），设计出相匹配的布局。当屏幕发生动态改变时（比如分屏、横竖屏切换），同步更新应用的页面布局。 我开发的 Demo 展示 以下代码均经过我 demo 的实战验证，确保代码和效果对应
引入与使用流程 媒体查询通过mediaquery模块接口，设置查询条件并绑定回调函数，在对应的条件的回调函数里更改页面布局或者实现业务逻辑，实现页面的响应式设计。具体步骤如下：
首先导入媒体查询模块。
import mediaquery from '@ohos.mediaquery'; 通过matchMediaSync接口设置媒体查询条件，保存返回的条件监听句柄listener。例如监听横屏事件：
let listener = mediaquery.matchMediaSync('(orientation: landscape)'); 给条件监听句柄listener绑定回调函数onPortrait，当listener检测设备状态变化时执行回调函数。在回调函数内，根据不同设备状态更改页面布局或者实现业务逻辑。
onPortrait(mediaQueryResult) { if (mediaQueryResult.matches) { // do something here } else { // do something here } } listener.on('change', onPortrait); 媒体查询条件 媒体查询条件由媒体类型、逻辑操作符、媒体特征组成，其中媒体类型可省略，逻辑操作符用于连接不同媒体类型与媒体特征，其中，媒体特征要使用“()”包裹且可以有多个。具体规则如下：
语法规则 语法规则包括媒体类型（media-type）、媒体逻辑操作（media-logic-operations）和媒体特征（media-feature）。
[media-type] [media-logic-operations] [(media-feature)] 例如：
screen and (round-screen: true) ：表示当设备屏幕是圆形时条件成立。(max-height: 800) ：表示当高度小于等于800vp时条件成立。(height &lt;= 800) ：表示当高度小于等于800vp时条件成立。screen and (device-type: tv) or (resolution &lt; 2) ：表示包含多个媒体特征的多条件复杂语句查询，当设备类型为tv或设备分辨率小于2时条件成立。 媒体类型（media-type） 类型说明screen按屏幕相关参数进行媒体查询。 媒体逻辑操作（media-logic-operations） 媒体逻辑操作符：and、or、not、only用于构成复杂媒体查询，也可以通过comma（, ）将其组合起来，详细解释说明如下表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/401365ae3c1392512a85ce431380f195/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/12/">«</a>
	<span class="pagination__item pagination__item--current">13/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/14/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>