<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63336d1fcaed2cd6f1e95bebcfae4124/" rel="bookmark">
			vue的组件之间方法以及变量的调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、父组件调用子组件 （1）方法 方式①：通过ref直接调用子组件的方法
父组件：
&lt;children ref="child"&gt;&lt;/children&gt; this.$refs.child.getDetail(); 子组件：
mounted(){ getDetail(){ console.log('子组件') } } 方式②：通过组件的$emit、$on方法（----此方式忽略-----）
（2）变量 方式①：通过子组件调用父组件的方法，子组件主动将值传递给父组件
父组件：
functionA(transVal){ this.getVal = transVal } 子组件：
this.$emit('functionA',this.tVal) 方式②：通过$refs来主动获取子组件中的值（与调用子组件方法一致） this.parenVal = this.$refs.child.childVal 2、子组件调用父组件 （1）方法 方式①：在子组件中通过this.$parent.event来调用父组件的方法
父组件：
hasCancleBtn(){ console.log('父组件') }, 子组件：
this.$parent.hasCancleBtn(); 方式②：父组件中将方法作为属性传入子组件，在子组件里props申明后直接调用这个方法即可 父组件：
&lt;children :hasCancleBtn="hasCancleBtn"&gt;&lt;/children&gt; hasCancleBtn(){ console.log('父组件') } 子组件：
&lt;div @click="hasCancleBtn"&gt;&lt;/div props: { hasCancleBtn: { type: Function, default:function() { console.log('test') } } }, 方式③：子组件中用$emit向父组件触发一个事件
父组件：
&lt;children @has-cancle-btn="hasCancleBtn"&gt;&lt;/children&gt; hasCancleBtn(){ console.log('父组件') } 子组件： &lt;div @click="$emit('has-cancle-btn')"&gt;&lt;/div&gt; （2）变量 父组件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63336d1fcaed2cd6f1e95bebcfae4124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4caeb41426172d4c2a66b3987ae44c78/" rel="bookmark">
			JAVA&#43;MYSQL可视化学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		掌握数据库连接Java程序可视化界面的流程，有效编写Java可视化界面程序及其功能（增删改查），了解数据库内容编写和连接的流程。
定义变量：Sno(String),Sname(String),_Class(String),Age(int),Sex(String)
public class HomeWork { private static PreparedStatement stmt=null; private static ResultSet rs= null; private static Connection conn = null; private static String Sno,Sname,_Class,Sex,sql; private static int Age; private static void createAndShowGUI() { JFrame f=new JFrame("菜单"); f.setLayout(new GridLayout(6,1)); f.setSize(400,300); f.setLocation(300,200); f.setVisible(true); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Button btn1=new Button("添加学生信息"); Button btn2=new Button("修改学生信息"); Button btn3=new Button("删除学生信息"); Button btn4=new Button("按性别查找学生信息"); Button btn5=new Button("按年龄查找学生信息"); Button btn6=new Button("按班级查找学生信息"); f.add(btn1);f.add(btn2);f.add(btn3); f.add(btn4);f.add(btn5);f.add(btn6); JPanel panel1=new JPanel(new GridLayout(6,2)); JLabel lab11=new JLabel("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4caeb41426172d4c2a66b3987ae44c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ca82554425143046b9b6d0063263d6/" rel="bookmark">
			【LaTeX】IEEE会议模板中插入双栏图片（解决报错：Undefined control sequence. \subfloat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、问题描述二、解决方案三、引用参考 一、问题描述 使用IEEE会议论文LaTeX模板时遇到的一个错误，问题描述为：使用Texstudio编译LaTeX模板报错，报错信息提示为Undefined control sequence. \subfloat。出现的原因为IEEE会议论文模板找不到定义\subfloat的包。
二、解决方案 笔者研究了模板中自带的文件《How to Use the IEEEtran LATEX Class》文件中X. FLOATING STRUCTURES 一节，将学习成果记录如下。
插入单栏图片
\begin{figure}[!t] \centering \includegraphics[width=2.5in]{fig1.png} \caption{Simulation results for the network.} \label{fig_sim} \end{figure} 插入双栏图片
手册中指示我们这样使用双栏图片 👇
实际使用中编译会不通过 👇
解决方案：添加subfig包之后编译可以通过
如果本文能给你带来帮助的话，点个赞鼓励一下作者吧！
三、引用参考 [1] IEEE - Manuscript Templates for Conference Proceedings：https://www.ieee.org/conferences/publishing/templates.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01e179dc322236f1761fa37510b0f01/" rel="bookmark">
			Ubuntu20.04安装gRPC-go
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu20.04安装gRPC-go 安装gRPC-go前你需要安装go和protobuf
第一步 根据前辈们经验
#实测发现直接下载源码包，无法编译。所以采用git方式。 git clone https://github.com/grpc/grpc.git #切换文件夹 cd grpc #更新第三方源码 git submodule update --init 第二步 #直接git，不用先配置环境。 git clone -b v1.30.0 https://github.com/grpc/grpc-go #启动server，这事如果没有配置环境的话，系统会先下环境依赖再运行 $ cd grpc-go/examples/helloworld/greeter_server $ go run main.go #启动client $cd grpc-go/examples/helloworld/greeter_client $ go run main.go 结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555feaf6f32df7d261861ab6339bbfeb/" rel="bookmark">
			recyclerview gridlayout 平分中间空白区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * @description recyclerview gridlayout 平分中间空白区域 */ class UserGradeItemDecoration(val width:Int,val itemWidth: Int, val columns: Int,val topPadding:Int) : RecyclerView.ItemDecoration() { override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) { var position = parent.getChildAdapterPosition(view); var totalCount = parent.adapter?.itemCount; // 可以适配任意列数（只要放的下） var w = (width - itemWidth * columns) / (columns * (columns-1)); var p = position % columns; outRect.left = (w*p); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4db91e78ab8c8c3cf66026e5f0110ba/" rel="bookmark">
			【Android】ConstraintLayout中RecyclerView 的底部数据显示不全以及覆盖其他View
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指定底部约束（app:layout_constraintBottom_toBottomOf=“parent”）的同时，还要设置高度为0dp（android:layout_height=“0dp”），基本完美解决超出遮挡、不从顶部排列、显示不全的问题。
将显示不全的View高度设置为 android:layout_height=“0dp” 代表填充上下约束包围的区域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93af355438049ec9a248dffadc62e57c/" rel="bookmark">
			react基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react的安装 首先，react需要两个第三方模块，react、react-dom
其中，react是核心库，react-dom则是负责将react生成的内容渲染到页面上
# 初始化项目 npm init -y #安装模块 npm i react react-dom react的简单使用 &lt;!-- 引入模块 --&gt; &lt;script src="./node_modules/react/umd/react.development.js"&gt;&lt;/script&gt; &lt;script src="./node_modules/react-dom/umd/react-dom.development.js"&gt;&lt;/script&gt; &lt;script&gt; const title = React.createElement('h1', null, 'Hello react') ReactDOM.render(title, document.getElementById('root')); &lt;/script&gt; React.createElement方法其实就是用于创建元素，类似document.createElement，但是前一个方法参数会更多，先来简单说说。
第一个参数是标签名，第二个是配置参数，可以不填，第三个则是标签内容。
其中标签内容是可以内嵌元素的，比如：
const content = React.createElement('p', null, 'Hello react') const title = React.createElement('div', null, content) 上面的代码其实就是一个div内嵌了一个p标签，p标签的内容则是‘hello react’
如果你学过vue，你会发现它和vue的h函数很类似。
react的脚手架 react的脚手架可以让我们快速搭建项目
npx create-react-app &lt;project-name&gt; 使用npx可以不用在全局安装create-react-app模块
npm install create-react-app -g create-react-app &lt;project-name&gt; #启动 cd &lt;project name&gt; npm start 脚手架中和引入React和ReactDOM的方式和常规方式不太一样。同样用上面的例子，我们在新建的项目中的index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93af355438049ec9a248dffadc62e57c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc23c8c970915a28850ae014d9fe1a9/" rel="bookmark">
			直流编码电机双闭环（速度&#43;角度）控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、PID框图
2、pid控制器的表达式
3、传感器数据获取
4、硬件设计
5、工程配置
6、软件部分程序配置
7、调参过程记录
本文已更新，加上曲线调试，更好效果，更多内容，详情：
编码电机PID调试（速度环|位置环|跟随）_桃成蹊2.0的博客-CSDN博客_编码器pid
串级控制系统介绍：
串级控制系统是改善控制质量的有效方法之一，在过程控制中得到了广泛的应用。所谓串级控制，就是采用两个控制器串联工作，外环控制器的输出作为内环控制器的设定值，由内环控制器的输出去操纵控制阀，从而对外环被控量具有更好的控制效果。这样的控制系统被称为串级系统。PID串级控制就是串级控制中的两个控制器均为PID控制器。
限于时间和篇幅，这篇仅记录用通用的pid方式进行感觉性的调参，等回家了有时间在把改进pid加上去试试效果
先把原理贴一遍
PID控制，就是对偏差进行比例、积分和微分的控制。PID由3个单元组成，分别是比例（P）单元、积分（I）单元、微分（D）单位。在工程实践中，一般P是必须的，所以衍生出许多组合的PID控制器，如PD、PI、PID等。
因为单片机是通过软件实现其控制算法的，所以必须对模拟调节器进行离散化处理，这样它只需根据釆样时刻的偏差值计算控制量。因此，我们需要使用离散的差分方程代替连续的微分方程。
通俗理解，用比例积分微分运算来消除误差，但是这个过程是连续的，周期性（一般是ms级的）的一次次计算来消除误差。
1、PID框图 速度环pid
位置环pid
2、pid控制器的表达式 经典的PID计算式如下所示：
将上述公式离散化，结果如下：
在使用ki和kd来代替积分就是下面的我们最常用的公式了（这个是比较常用的位置式pid版本）
之后我们再修改一种版本，如下所示（这种称为增量式pid）
可以看出这种仅统计当前误差和上一次误差，而上面的位置式统计了自起始以来所有的误差项，而上面的位置式版本输出后直接作为控制器输出值，而增量式则作为增加量叠加进入控制器的输出中。
3、传感器数据获取 霍尔码盘结构图：
编码电机上如下：
怎么读数据看下面这个，一张图一张表，对应着读取就知道了
这里注意：stm32用硬件编码器模式，这个读取的过程他是自动进行的，只要进行配置编码器模式就行了，但是其他没有硬件编码器模式的需要软件上模拟实现类似的功能，怎么模拟-就是按照下面的那个表，使用gpio中断加上if条件判读即可。
对应的上下信号说明如下所示：
读不懂就看口诀，立马懂：
CNT计数+：
A上升沿，B逻辑低B上升沿，A逻辑高B下降沿，A逻辑低A下降沿，B逻辑高 CNT计数-：
A下降沿，B逻辑低B下降沿，A逻辑高B上升沿，A逻辑低A上升沿，B逻辑高 4、硬件设计 硬件其实没什么要求，画了块板子只是为了使用方便，这块板子接口上是直接兼容编码电机的，市面上几款我都试过了，基本不需要改线，直接插上就可以使用。
关注一下这个电机部分的接口吧，毕竟就这个有点用了
5、工程配置 可能有些没用的，主要看电机的pwm接口，编码器捕获接口，还有电机方向的接口把
定时器8 1 3 2采用编码器模式，配置如下
pwm设置，这里一个定时器就够了，重装载设置为7199，那pwm最大就是7200了，这就这样OK
基本时间配置，这里我没有采用操作系统的写法，直接用一个定时器中断了（毕竟是老工程了，拿过来直接用比较方便），使用定时器6，可以看出定时时间为1ms一次。
综上：资源配置如下
接口类型外设资源模式编码器口TIM8 TIM1 TIM3 TIM2编码器模式(T12)电机接口M11 M12 M21 M22 M31 M32 M41 M42看原理图PWM口TIM4 （CH1 ~ 4）变化范围0-7200基本定时TIM61ms一次 6、软件部分程序配置 1、电机配置，这里把每一个电机封装成一个函数，内函限幅，电机换向，PWM设置，是比较方便的，墙裂推荐hhh
void AAC_MotorFL_Run(int16_t speed) { if(speed &gt; 0) {GPIOE-&gt;BRR = m11_Pin;GPIOE-&gt;BSRR = m12_Pin;} else {speed = -speed;GPIOE-&gt;BSRR = m11_Pin;GPIOE-&gt;BRR = m12_Pin;} if(speed &gt; 7100) speed = 7100; __HAL_TIM_SetCompare(&amp;htim4,TIM_CHANNEL_1,speed); } void AAC_MotorFR_Run(int16_t speed) { if(speed &gt; 0) {GPIOE-&gt;BRR = m21_Pin;GPIOE-&gt;BSRR = m22_Pin;} else {speed = -speed;GPIOE-&gt;BSRR = m21_Pin;GPIOE-&gt;BRR = m22_Pin;} if(speed &gt; 7100) speed = 7100; __HAL_TIM_SetCompare(&amp;htim4,TIM_CHANNEL_2,speed); } void AAC_MotorBL_Run(int16_t speed) { if(speed &gt; 0) {GPIOC-&gt;BRR = m31_Pin;GPIOC-&gt;BSRR = m32_Pin;} else {speed = -speed;GPIOC-&gt;BSRR = m31_Pin;GPIOC-&gt;BRR = m32_Pin;} if(speed &gt; 7100) speed = 7100; __HAL_TIM_SetCompare(&amp;htim4,TIM_CHANNEL_3,speed); } void AAC_MotorBR_Run(int16_t speed) { if(speed &gt; 0) {GPIOC-&gt;BRR = m41_Pin;GPIOC-&gt;BSRR = m42_Pin;} else {speed = -speed;GPIOC-&gt;BSRR = m41_Pin;GPIOC-&gt;BRR = m42_Pin;} if(speed &gt; 7100) speed = 7100; __HAL_TIM_SetCompare(&amp;htim4,TIM_CHANNEL_4,speed); } 2、编码器测速，定时器的编码器模式是特殊的计数模式，测量值还是保存在cnt中的，因此只要读取cnt的值就可以获取编码器当前的计数值了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dc23c8c970915a28850ae014d9fe1a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d86e877e7a3d5ef1cc97f607313ed1b0/" rel="bookmark">
			【微信小程序】使用webstorm进行开发，支持代码提示高亮等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【微信小程序】使用webstorm进行开发，支持代码提示高亮等 前言插件加入官方.d.ts文件完事 前言 最近有负责小程序开发的同事离职，无奈接手项目，使用过微信小程序的官方开发工具的同学应该都知道，这玩意做得有多差，写起代码来相当难受。作为一个android开发，最熟悉的莫过于android studio了，而android studio来自于jetbrains的IDEA，并且了解到jetbrains上还有个webstorm是专门用于web开发的，就希望能这个开发工具上开发微信小程序。
插件 幸运的是，在插件市场发现了小程序开发的支持插件，但使用后还是有些问题：
Wxapp Support（在2021.3.3版的webstorm上安装后重启会报错，无法正常使用，不建议安装）;Wechat mini program support（只支持样式代码，没有小程序API的代码提示，建议安装）; 加入官方.d.ts文件 经过一番查找，在微信官方的GitHub上找到了小程序的TS库
地址：https://github.com/wechat-miniprogram/api-typings
把整个库拉下来到本地，得到一个文件夹api-typings-master
打开webstorm的设置弹窗，找到 语言和框架 &gt; JavaScript &gt; 库
将下载下来的api-typings-master添加到库，名称可以填wxapp-api，可见性选全局，添加文件api-typings-master/index.d.ts和添加文件夹api-typings-master/types，最后点击确定即可。
使用webstorm打开小程序项目就能试下是否有代码提示了。
完事 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bccb7025e08a8af04590841263263a05/" rel="bookmark">
			VSCode Remote SSH远程连接失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
背景 Windows下使用vscode remote ssh连接到服务器容器，旧的容器被删了重新开一个容器，使用同一个端口，旧容器可以正常连接，同样的启动命令和sshd_config设置新容器却无法连接。
报错信息 vscode下连接报错主要信息： 过程试图写入的管道不存在[类似报错](VSCode Remote SSH远程连接失败过程试图写入的管道不存在_漫步量化-CSDN博客_试图写入的管道不存在)
git bash 下ssh报错主要信息 @@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
解决 通过git bash报错信息，应该是ssh密钥不正确导致的，旧的容器的ssh密钥仍然存在于本地的konwn host文件中，我的解决办法是到本地的.ssh文件夹（一般来说是位于C盘的用户文件夹中，我的路径：C:\Users\Adminstrator.ssh\know_host）中把known_host文件的信息清除，也可以只删除与你连接的ip相关的，清除后保存即可重新连接到远程容器对应的端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bccb7025e08a8af04590841263263a05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b92fc7a336886444b54b20a5baf0d3e/" rel="bookmark">
			clickhouse数据库使用jdbc存储毫秒和纳秒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clickhouse的DateTime DateTime32通常情况只能精确到秒存储，如果我们需要存储毫秒纳秒，需要DateTime64
数据库字段定义
毫秒
create_time` DateTime64(3) 纳秒
create_time` DateTime64(9) 使用新版jdbc 0.3.2+以上
&lt;dependency&gt; &lt;groupId&gt;com.clickhouse&lt;/groupId&gt; &lt;artifactId&gt;clickhouse-jdbc&lt;/artifactId&gt; &lt;version&gt;0.3.2&lt;/version&gt; &lt;/dependency&gt; 驱动类更改为
com.clickhouse.jdbc.ClickHouseDriver 对应java字段
毫秒存储 Date LocalDateTime
纳秒存储 LocalDateTime
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a38463ce3f6aa307e3348a65c65cc1f/" rel="bookmark">
			Caused by: java.sql.SQLException: SQL String cannot be empty 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
运行程序，报错Caused by: java.sql.SQLException: SQL String cannot be empty
问题排查
英文报错意思： sql里面字符串为空
查看源码，显示的跟英文意思是一样的：
猜测：组装sql的时候，传了什么空值进去了
查看调用的slq的代码：
发现批量插入的时候，没有赋值，直接给传了个空集合
问题原因：
批量插入的时候，没有赋值，直接给传了个空集合
解决方法：
1.进行批量插入的时候，记得给集合传值
2.调用批量插入方法的时候，先判断一下入参的集合是否为空
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde11fea2d207d04d5e5a094a2d0282f/" rel="bookmark">
			（一）vhdl如何转换转换verilog？（人肉翻译—保姆教学版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 其实在此之前我是学习verilog语言的，本以为以后工作都只会遇到或者用到verilog，但怎么也没有想到会遇到vhdl这个硬茬子，而且还是整个工程。
刚拿到工程，本以为只是单纯verilog，没想到一打开工程文件，这不妥妥的vhdl吗？乍一看，工程目录下的年份居然是2014年，好家伙八年前的东西，而且所有目录下的年份基本没有改变，是有多久没更新了，这不玩我吗？但这是交给我的任务，干不了只能卷铺盖走人了，没办法只能硬着头皮干。
起初我就在想现在开发平台都那么完善了，并且vhdl和verilog都是硬件描述语言，应该相差不会很大，所以就在想有没有什么平台或者软件直接将两者语言互换，结果我一搜还真有一款叫做 X-HDL的软件，可以随意互换两者语言。好了，现在有了这款软件就没有必要再讲这篇文章了，再见！
等等，当我怀着无比激动的心情下载了这款名叫X-HDL的软件，就长下面这样色儿的
心想不愧是网络时代啊，要啥有啥！然后就按照安装步骤将它安装好，点击打开，咦？怎么没有反应，是我安装错了？没有吧！然后等待了差不多一分钟左右，居然可以用！进到软件里面后突然眼前一亮，哇！感觉像是打开了新世界的大门，激动的心颤抖的手，话不多说，直接开整！我按照步骤把vhdl工程代码所在路径添加了进去，然后选择翻译后生成verilog语言的保存路径，之后又点击左上角语言互换。
好家伙，功能这么强大，心想这不捡到宝了吗？以后不得起飞？想怎么变就怎么变？正当我开心之余，点击Translate，念上咒语“如玉如玉，按我心意，快快显灵！”耶？翻译失败？怎么能够？我是按照步骤来的呀？不行，肯定是我哪个步骤错了，是不是翻译源文件和保存文件路径有中文啥的？我又重新起了一个文件，再翻译！耶？还是失败！这么玩的吗？后来我试很多次，多种方法，说啥vhdl代码里面注释不能有中文、按照步骤来不会出错等等，还是不得行。然后我看了各个介绍这款软件的博客里面的评论，我嘞个去！不看不知道，一看吓一跳呀！这都啥呀？评论区全是翻译失败的。给大家伙看看
为什么？为什么要给我刚刚燃起的希望浇灭了呀？后来我还是不相信，我命由我不由天！又试着安装重启等等一系列操作，最终结果都是翻译失败。失败得很彻底，直到我发现软件工具栏上面的版本日期2012年5月28，什么？！这玩意儿比我这个工程代码年份还要久远，也是没有更新过，那不奇怪了。现在电脑基本都是windows10了，版本不兼容也是常态，即使下载也不一定能用。我就好奇了，这么好的东西怎么就荒废了呢？可惜了可惜了，如果是跟着代码发展步伐一起更新到现在还能用，是多少像我这样多一事不如少一事的人的福音呀！
2.学习vhdl 经历了翻译失败的挫折，直到现在都还没走出来的我，终于硬着头皮到处找怎样把vhdl翻译成verilog，除了一大堆介绍这个x-hdl软件的，其他的都是寥寥无几。
走投无路只能开始接触vhdl了，靠人不如靠己，撸起袖子干，自学vhdl！于是当我打开哔哩哔哩想像当年学习verilog一样跟着视频学习，结果。。。。不是吧，连视频都没有几个，怎么搞？难度加大了呀！找来找去找到了窦衡教授讲解的考研课程（EDA技术），前面几个课程是讲解EDA技术，后面都是vhdl，而且语法内容讲得都很细，虽然视频有点年代感了。有兴趣的同学可以去学习学习。
跟着推荐我又找到几本对于学习vhdl的相关书籍《VHDL数字电路设计教程》、《VHDL实用教程 潘松》、《[VHDL入门.解惑.经典实例.经验总结].黄任》、《 VHDL与数字电路设计 卢毅 赖杰》，这些都是对于vhdl介绍比较全面的书籍，而且非常难找，有需要的同学可以在下面的下载链接里下载
链接：https://pan.baidu.com/s/1EAdVCg-ZLk_bEg07ut7xKw?pwd=vhdl 提取码：vhdl
当时正准备着手学习vhdl，想着在公司里学又太浪费上班时间，下班回去学嘛，累一天回去都没啥精神只想躺尸。但是好巧不巧三月底碰上了疫情，被封在家里整整两个月时间，正好利用了这段时间自学了vhdl，由于大部分资源都是文字上的，很少有实操，所以学习起来很吃力，两个月的结果也只是皮毛上的东西。
正常上班后由于浪费了之前两个月的时间，要开始赶进度了，于是我就着手开始翻译，把vhdl工程转为verilog，很多人看到这里很不能理解，为什么自己都学习了vhdl，干脆直接用vhdl源代码去维护源工程就行了，干嘛还得大费周章去转换它？我也有想过这样拿来直接用，但是考虑到两种情况，不得不迫使我去转换它。第一个就是现目前vhdl资源太少，基本被verilog取代了，况且verilog使用的人多了资源也就多，需要改动或者加功能网上一搜就是一大堆，而vhdl要改动的话相对于来说很困难。第二个就是考虑到以后可能不止我一个人会用到这个工程，万一他不熟悉vhdl的话又要和我一样重蹈覆辙了。
3.着手转换 注：着手转换的前提是要会一点vhdl基础哦 vhdl相对于verilog来说比较严谨，所以vhdl在国内的使用方面偏向于军工研发方面，而一般的研发公司都普遍使用verilog，不仅因为verilog语言使用起来方便、不拘束，而且还利于维护。
vhdl和verilog编译调试后的工程都是大同小异。并且现在modelsim软件可以让vhdl和verilog混合仿真，仿真结果都一样，所以能直接手撕代码的大佬可以直接看vhdl的仿真结果来写verilog代码，而看代码转换代码的方式只适合我这种小菜鸡，但可能后期编译报错会很多，所以还得再参考vhdl的仿真结果来修改。
拿到工程，直接用ise打开（因为我这个芯片型号是赛灵思sprantan6系列的，所以用ise集成开发环境），找到顶层文件top.vhd后点击文件下面工具栏里的【Synthesize - XST】里的创建RTL视图【View RTL Schematic】生成RTL视图，然后根据top.vhd顶层文件里的元件声明和RTL视图里面的各个端口结合起来定义verilog代码的端口。为什么要两个一起参考呢，因为vhdl中元件端口例化需要先声明在例化。而verilog相对灵活不需要这么严谨，所以结合二者方便verilog顶层文件的例化，而参考RTL视图来例化模块更好的确保不会漏掉任何一个端口。
在转换过程中理解最重要，其次就是各种语法等的用法。咱们就跟着代码步骤来，逐一转换。
顶层模块转换问题 先看vhdl顶层代码
library	IEEE; use	IEEE.STD_LOGIC_1164.ALL; use	IEEE.STD_LOGIC_UNSIGNED.ALL; library UNISIM; use UNISIM.VComponents.all; entity FPGA_TOP is port( OSC_CLK	: in	std_logic; FPGA_RST	: in	std_logic;	CMOS_PCLK_X	: in	std_logic; CMOS_HREF_X	: in	std_logic;	CMOS_VSYNC_X	: in	std_logic;	CMOS_D_X	: in	std_logic_vector( 7 downto 0);	CMOS_XCLK_X	: out	std_logic;	CMOS_FSIN_X	: out	std_logic;	CMOS_PWDN_X	: out	std_logic;	前面的库调用可以不用管，verilog中不需要调用库，直接定义端口，这里看到下面端口定义有区别，是因为我结合RTL视图把缺少的端口补充上去了，vhdl中也有定义，只不过是另起了一个人定义模块，verilog中则不需要这么复杂，咱们直接看着端口，直接定义，具体是wire型还是reg型也可参考RTL视图定义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dde11fea2d207d04d5e5a094a2d0282f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6411d9819ed3a133ca38127e2dfb1a0/" rel="bookmark">
			二叉树、B树(B-树)、B&#43;树、B*树详解，以及为什么MySQL选择B&#43;树做索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		温故而知新，可以为师矣。看到一篇介绍B数和B减树的文章，这里记录一下。
1. 简要 众所周知，MySQL的索引使用了B+树的数据结构。那么为什么不用B树呢？
先看一下B树和B+树的区别。
2. 二叉树 先介绍一下二叉搜索树。
顾名思义，二叉搜索树，即指最多拥有两个叉，这里的叉即为所有非叶子结点的儿子（Lift和Right）；所有的结点存储一个关键字；非叶子结点的左指针指向小于其关键字的结点，右指针指向对于其关键字的结点，结构如下图：
二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点关键字相等，则该结点为查询的结点，如果查询关键字比结点关键字小，则进入左子树，反之则进入右子树；如果左子树为空或者右子树为空，则返回查找不到响应的关键字；
如果二叉搜索树的所有叶子结点的左右子树的树木保持一个平衡即左右子树个数大致相等的话，其搜索则更接近与二分查找；但是它相比连续内存空的二分查找的优点是：改变二叉搜索树的结构（添加或者删除）不需要大段的移动数据，甚至通常都是常数开销；
如下图：
红色字体代表插入数据，搜索二叉树在插入结点时，只要根据插入数据的大小查找出他应该插入的位置即可，然而当在一个有序数组插入一个数据的时候，需要查询出他的位置，然后将其添加，后面的数据索引加一，这样的一个完整操作，相比下来二叉树的优点很明显了。
但是，当一个二叉树经历多次删除操作后，他就可能变换结构，如下图：
右边也是一个搜索二叉树，只不过不在平衡了，他的搜索功能也变成了线性的，同样的关键字可能导致不同的树结构索引，所以，在使用搜索二叉树时，还要考虑尽可能让B树保持左图的结构，避免和右图类似，这也有事所谓的平衡问题了。
实际使用的二叉搜索树都是在原二叉搜索树的基础上加上平衡算法，即平衡二叉树；如何保持B树节点分布均匀的平衡算法就是平衡二叉树的关键所在，平衡算法是一种在二叉搜索树的插入和删除结点时的一种策略。即：在插入或删除的同时保持二叉搜索树的平衡。
3. B树 B-树就是B树（可能有部分人会习惯上把B-树读为B减树，其实并不存在B减树，只是读法上的不同而已），B就是balanced，平衡的意思。B-树就是指的B树，特此说明一下。
维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。”
B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。
3.1定义 m阶B树：m阶指的是分叉的个数最多为m个。即一个非叶子节点最多可以有m个子节点。根节点至少有两个子节点，即根节点的儿子数为：[2，M]；定义任意非叶子节点最多可以有M个儿子节点；且M&gt;2；除根节点为的非叶子节点的儿子书为[M/2，M]；每个结点存放至少M/2 - 1 (去上整)且至多M -1 个关键字（至少为2）,并且以升序排列，超过上限就进行分裂存储；非叶子结点的关键字个数 = 指向子节点的指针书 -1；非叶子节点的关键字：K[1],K[2],K[3],…,K[M-1;且K[i] &lt; K[i +1];非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；所有叶子结点位于同一层； 下图是一个M=4 阶的B树:
M=4的B树
可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。
B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入
6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4 的演示动画：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6411d9819ed3a133ca38127e2dfb1a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c350c26a28d34cf2dfed89db5205241/" rel="bookmark">
			爬取网站视频命令行工具you-get的安装及使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取网站视频命令行工具you-get的安装及使用方法 软件简介
you-get 是一个跨平台命令行视频、音频与图像下载工具，支持国内外常用的各种多媒体网站。
下载方法
Step.01
下载Python，可以在python官网下载最新的python版本。
对于已经下载了Python的用户：由于you-get是Python的一个第三方库，所以可以使用pip工具进行下载。
Step.02
在命令行cmd下输入代码：pip3 install you-get
命令行输入you-get 如果有以下回显说明安装成功
使用方法
掌握you-get在命令行下的一些简单命令就可以轻松下载资源啦，下面列出常用命令以及使用方法。
you-get URL
注:这里URL即网址。其格式不是字符串，使用时直接从浏览器粘贴即可
功能：直接把目标网址的内容下载到C:\User\用户名目录下(后面的命令会提供自定义下载路径的方法)
you-get -i URL 或 you-get --info URL
功能:展示待下载的文件信息
下图展示该命令的使用
you-get -o 你想要保存的路径 URL
注:路径的格式也不是字符串，使用时直接复制即可
报错提示
有时候无法你会发现无法使用you-get，可能是版本过于老旧，这时候需要在命令行下输入更新命令：pip3 install --upgrade you-get
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7207c2e240883ebbb7d7a3ef7d50cbde/" rel="bookmark">
			离线环境下仅使用vscode remote ssh方式远程连接服务器操作指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.vscode配置2.安装步骤3.简单的使用方法说明4.vscode免密登录服务器配置5.vscode使用普通用户登录远程ubuntu服务器配置5.参考 1.vscode配置 由于vscode的跨平台的特点：vscode既可以安装在windows，也可以安装在Linux，也可以安装在macOS。下面的操作全都是在Linux（CentOS）上进行的remote ssh插件需要在客户端以及服务端都需要安装，如果是是连外网状态，配置好网络后，可以直接使用。如果是离线状态，则需要自己下载vscode的客户端插件和服务端插件，然后放置在Linux的合适位置。vscode的代码编辑器需要安装的插件是：
2.安装步骤 第一步：首先在Linux上安装vscode客户端代码编辑器
在vscode官网上下载：链接，
下载完毕后，使用rpm -ivh code-1.51.1-1605051791.el7.x86_64.rpm进行安装，安装过程中依赖的包，需要配置公司内部的镜像yum源进行下载，我在安装过程中依赖一个libXScrnSaver-1.2.2-6.1.el7.x86_64.rpm这个包，但是公司镜像源没有，我就从Centos下载的官方二进制包，链接
图中的链接放到浏览器中就可以下载：安装：rpm -ivh libXScrnSaver-1.2.2-6.1.el7.x86_64.rpm
到此位置vscode应该安装完毕
第二步：给vscode编辑器安装Remote-SSH插件：ms-vscode-remote.remote-ssh-0.56.0.vsix
（1）首先需要安装Remote-SSH插件在vscode客户端代码编辑器上，需要从Visual Studio | Marketplace中去搜索下载，
下载链接，如果是C/C++的开发，最好再下载一个ms-vscode.cpptools-0.29.0.vsx插件工具，以及MS-CEINTL.vscode-language-pack-zh-hans-1.51.2.vsx简体中文翻译插件工具
（2）将ms-vscode.cpptools-0.29.0.vsx工具在windows本地进行解压，然后压缩成ms-vscode.cpptools-0.29.0.zip文件上传至服务器的/root/.vscode/extensions这个目录下
接着新建目录，eg：mkdir ms-vscode-remote.remote-ssh-0.56.0，解压ms-vscode.cpptools-0.29.0.zip，将其中的extensions下的内容拷贝到ms-vscode-remote.remote-ssh-0.56.0目录中去，最后重启vscode客户端即可，此时vscode中应该可以看到安装好的remote ssh插件。
其他插件的安装方式类似，如果有错误请看vscode客户端界面的错误
第三步：vscode服务端的配置
（1）在客户端使用remote ssh方式连接服务器，以此来获取commit id
该config文件的内容，大致如下，都是可配的，其他选项自己配置尝试
Host 100.19.14.217 HostName 100.19.14.217 port 22 User root 免密登录参考：VsCode Remote SSh开启免密登录 输入：ssh root@192.168.122.155或者ssh -p 22 root@192.168.122.155
192.168.122.155为服务器的ip，root为服务器的用户
在vscode中打开：查看-&gt;输出，打开下面的remote-ssh，这里是vscode客户端的输出信息，commit id以及报错以及使用的日志在这里会输出，从这里我们可以获取commit id。
将commit id放到这个链接中：https://update.code.visualstudio.com/commit:commit id/server-linux-x64/stable
（2）eg：https://update.code.visualstudio.com/commit:6ab598523be7a800d7f3eb4d92d7ab9a66669390/server-linux-x64/stable
（3）清空/root/.vscode-server/bin/6ab598523be7a800d7f3eb4d92d7ab9a66669390下目录的内容
（4）将下载下来的vscode-server-linux-x64.tar.gz文件放到/root/.vscode-server/bin/6ab598523be7a800d7f3eb4d92d7ab9a66669390中下面（6ab598523be7a800d7f3eb4d92d7ab9a66669390这个id应该与vscode客户端看到的commit id应该是对应的）
（5）在这个目录下解压vscode-server-linux-x64.tar.gz，tar -xvzf vscode-server-linux-x64.tar.gz --strip-components 1
（6）所有工作做完，重启vscode客户端，右键下方，然后进行connect，会提示有2种方式，这2种方式随意
注意：连接过程中注意报错输出日志，如果报错了要按照日志进行百度等方式处理，这里列一下我做的配置改变，如果能直接使用，则不需要修改
因为remote ssh使用的是ssh，所以更改基本上都是/etc/ssh/sshd_config文件 AllowTcpForwarding yes打开 PermitRootLogin yes打开 上面这么做的一个好处是，只要一台服务器配置成功，其他服务器都不用配置了，都是可以直接用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7207c2e240883ebbb7d7a3ef7d50cbde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa5fc88d4af89f950a4a89e20ad961e/" rel="bookmark">
			基于JavaSwing和Mysql的学生成绩管理信息系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源下载地址：https://download.csdn.net/download/sheziqiong/85680485
资源下载地址：https://download.csdn.net/download/sheziqiong/85680485
目录
第一章 引言 1
1.1 本课题的研究背景 1
1.2 本课题的研究意义 1
1.3 现行研究存在的问题及解决办法 1
第二章 系统分析 2
2.1 可行性分析 2
2.1.1 技术可行性 2
2.1.2 操作可行性 2
2.1.3 社会效益可行性 2
2.2系统需求分析 3
2.3 采用的关键技术介绍 3
2.3.1报表输出功能 3
2.3.2 有关MySQL技术的应用 3
2.3.3 Java基础技术的应用 4
第三章 系统实现 5
3.1 系统开发环境 5
3.2 系统实现 5
3.2.1用户管理模块 5
3.2.2主界面实现 7
3.2.3选课管理模块 9
3.3 系统运行环境要求 13
第四章测试与分析 14
4.1测试分析 14
4.2测试设计 14
参考文献 15
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fa5fc88d4af89f950a4a89e20ad961e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70648a841fe39bb2e605cfe8cb227fe8/" rel="bookmark">
			x86 arm aarch64 linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.x86架构：计算机是x86架构
x86的32位架构
x86的64位架构
2.arm架构：手机都是arm架构
32位架构
arm内核指的是处理器内核
也是一种架构，非常适用于移动通信这种低成本，高性能，低电耗的领域
3.aarch64：
AArch64是ARMv8 架构的一种执行状态。
为了更广泛地向企业领域推进，需要引入 64 位构架。同时也需要在 ARMv8 架构中引入新的 AArch64 执行状态。AArch64 不是一个单纯的 32 位 ARM 构架扩展，而是 ARMv8 内全新的构架，完全使用全新的 A64 指令集。
4.linux：操作系统，像Windows一样，是操作系统
linux内核指的是操作系统软件的内核
5.指令集
计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/900d6484198c2812f96535dbe2b9e1bc/" rel="bookmark">
			soc,mcu,mpu相关概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.SoC: （System on Chip），称为系统级芯片，也有称片上系统
①如果拿SOC和MCU对比，大家可以理解成SOC就是定制功能版本的MCU。
当然，SOC不仅仅局限于MCU，还可以是更高端的CPU、MPU的功能定制版。
②低端的SOC就是内部集成了MCU+特定功能模块外设。
高端的SOC应该是内部集成MPU/CPU+特定功能模块外设，高端的我也没用过，我猜的，今天我们低端的SOC。
2.MCU：(Microcontroller Unit)微控制器，别名叫单片机
①MCU一般最多只运行实时操作系统(RTOS)，不会上Linux，更多的是”裸机”编程。
②在开发板中，MCU就像大脑，其它乱七八糟的按键、蜂鸣器、LED灯、数码管等等就相当于手、眼睛、嘴巴、脚等等。
3.CPU：（Central Processing Unit）中央处理器
4.MPU:(Micro controller Unit)微型处理器
5.BPU：(Brain Processing Unit,大脑处理器)
6.GPU:(Graphicd Processing Unit)图形处理器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813186c5cde82d07f98941669bbd75b8/" rel="bookmark">
			Navicat 16 是否支持原生苹果 Silicon M1 芯片？| 苹果用户必读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苹果 Silicon M1 是由苹果公司研发的处理器芯片，2020年11月正式发布。经过一年多的过渡期，苹果已开启全面转向苹果 Silicon 的时代。随之而来，性能越发成熟与稳定，用户选择苹果 M1 处理器的 Mac 产品也成了潮流。近期，我们也收到许多问询，欲了解 Navicat 16 是否支持原生苹果 Silicon M1 芯片？
「 Navicat 官方回答来了 」 今天，我们来深度解读 Navicat 16 所带来的惊喜之一！要知道上一代 Navicat 15 仅支持通过 Rosetta 2 转译后在 M1 上运行。Navicat 16 则大有不同，它可支持在 M1 芯片上运行大部分主流数据库，有效地提升苹果产品用户的使用体验感。现在就来细数一下支持原生 M1 运行的产品有哪些？
现在，大家对 Navicat 16 所支持原生 M1 的问题已有了基本认识。如果您有顾虑或想深入了解最新产品的百种增强功能和崭新的界面，欢迎点击下方链接下载 14 天免费全功能试用版，开启构建、管理、维护数据库的新方法。Navicat 16 让数据库管理变得更简单！
14 天免费试用「千言万语不如亲身体验」
试用教程「开启数据库管理新方法」
进入 Navicat 商店「每日花费低至 2 元起」
往期回顾 Navicat 被投毒了 | 真相来了！
Navicat 成为信通院数据库创新实验室成员
Navicat 学术伙伴计划 - 免费教育版申请
Navicat 技术智库 - 实战演练与各类热门问题解答
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/813186c5cde82d07f98941669bbd75b8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/71/">«</a>
	<span class="pagination__item pagination__item--current">72/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/73/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>