<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a23d75fad08d115f2cc7cb81622e150/" rel="bookmark">
			京东老矣，尚能饭否？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片｜《冰与火之歌》截图
©自象限原创
作者丨程心
编辑丨罗辑
从2004年1月，京东正式涉足电商至今，整整二十年过去了。
2024年3月6日，京东发布了2023年第四季度及全年财报。数据显示，2023Q4京东收入3061亿元人民币，同比增长3.6%；2023年全年收入10847亿人民币，同比增长3.7%。2023Q4经营利润（Non-GAAP）78亿元人民币，同比增长6.8%；2023全年经营利润（Non-GAAP）354亿元人民币，同比增长28.2%。
▲数据源京东财报，图为自象限自制
从连续几个季度的个位数营收增长来看，电商20年以后，京东这位“老大哥”明显进入了增长的艰难期。营收增长贴地飞行、经营利润增长持续下滑。哪怕2023Q4在双11的大促节日刺激下，非通下的经营利润仍然只有73亿元，成为了2023年利润最低的一个季度。
核心业务增长乏力，不是京东一家企业的问题。在刚刚披露的阿里巴巴集团财报中，截至12月31日起的三个月，淘天集团营业收入也仅获得了2%的增速。
但市场不会等人。2023年是电商的转折之年，市场从消费升级转换到低价主场，强劲的竞争对手层出不穷，拼多多提前卡位，抖音电商半路杀出，并在去年全年GMV快速达到了27000亿。
显而易见，电商走到了一个新的节点，低价、出海、AI电商，技术、模式的多重创新，倒逼着行业内玩家自我革命。
强烈的对比之下，京东自从2022年报中披露过全年GMV较2021年增加5.6%之后，便再也没有披露过GMV数据的变化。我们无法从财报中得知平台的整体情况，但就一些商家的反馈来看，无论是双十一还是年货节，商家在京东的经营情况并不乐观。
事实上，2023年也是京东求变的一年。2022年年底，刘强东在内部讲话中强调了低价张略是京东最重要的武器，为了呈现出低价，京东在2023年，不断扶持3P生态、持续百亿补贴、加码采销直播、实现采销分离。
一系列的动作之后，低价战略到底执行几何？这份财报或许给出了答案。
求稳还是求增长？ 在整个京东的财报中，能够感受到一种很强烈的“撕裂感”。
业务方面，为了刺激增长，京东在去年针对商家和消费者都推出了各类活动，京东百亿补贴、京东秒杀、将包邮基础额从89元下调至59元，甚至在四季度推出了9块9包邮的服务；京东采销直播间通过「不收坑位费、不收达人佣金、就是更便宜」的策略，在双十一前后小小的出圈了一把，总观看人数突破了3.8亿。
但在财务方面，整体的收入、利润、成本甚至现金流都并没有发生太大的改变，甚至持平。相比于早几年大肆百亿补贴的拼多多，动辄营销成本占到了总成本的一半，连着3年的持续亏损，京东的低价策略似乎并没有怎么在财务支出中得到突出体现。
简单的说是：想要增长，但并没有太多投入。但生存和突破，其实不可兼得。
整个2023年，京东其实一直在做“加法”。第一个大的动作是扶持3P商家。由于此前京东的自营业务以直营模式为主，在原来的流量分配规则下，利润更高、销量更高的自营产品往往会占据用户搜索结果的前几页。同时品牌和商家在京东的经营成本高，例如仓储服务抽点，最终会反映到商品定价上。
低价主场下，1P模式亟待改革。刘强东给出的方案是大力吸引3P入驻、放宽入驻条件、不要求仓储、物流、降低商家的经营成本并推动商品低价。
这一策略在短时间内似乎得到了效果，即便商家数量增长数据并未被写进财报中。但据京东官方公众号披露的数据显示：目前第三方商家数量近百万，全年第三方商家数量同比增长188%；新增商家数量同比增长4.3倍。
这当然也源于此前京东生态内3P商家的匮乏，基数较小，短期高速增长也是常态。但问题在于3P商家数量增多的同时，服务收入的增速却在持续下滑。
「自象限」整理了京东连续5个季度的商品收入和服务收入增长情况后发现，自2022Q4起，商品收入进入到了波动期，在2023Q1和2023Q3都出现了负增长的情况，四季度收到双11的拉动，商品收入转负为正同比增长2.99%。但第三方商家的服务收入，却从高速增长的态势逐渐放缓，从40.29%的同比增长率到2.99%。
▲数据源于京东财报，图为自象限自制
2023年第三方商家数量增长188%，但据财报显示全年服务收入却只比去年增长了17.8%。
除此之外引入3P的阵痛还在持续显现，2023年，京东平台及广告服务收入为236.26亿元，同比下降3.8%。对此，在财报后电话会中，京东首席执行官许冉解释道：“四季度平台及广告服务收入出现的短期小幅波动，这主要是因为公司在2023年大力发展平台生态，推出了一系列支持举措，包括为新商家提供免佣服务，以及在部分品类和营销场景中主动降佣，从而导致佣金收入增速在第四季度略有放缓”。
3P之外，京东也在不停的通过平台补贴来实现更低的价格。
从年初开始，京东便不断上线百亿补贴活动，面向商家免收坑位费。有商家曾向「自象限」透露到：“京东业务人员在沟通时均强调新频道的流量更高，只要给出低价，销量就一定能够增长。但只有部分商品才能获得京东官方的补贴，大部分都是商家让利。”
也就是说，百亿补贴背后是平台的全新流量分配策略，这本来无可厚非，但相较于如今的京东而言，能否“四两拨千斤”通过流量而不是真金白银就获得低价竞争力，这是一个问号。
在财务大师许冉的领导下，京东的成本得到了良性控制。财报数据显示，2023年履约开支同比增长2.5%，占总收入占比6%与2022年持平。营销开支同比增长6.3%，研发开支减少3%，一般行政开支较去年减少12.2%。
▲数据源于京东财报，图为自象限自制
在《徐雷卸任，京东保命》一文中，我们曾分析过许冉彼时接手京东：CFO的履历显而易见的好处是会省钱，很明显，擅长投资的许冉，不仅有效控制了成本，也在接任后快速收敛了非经营利润，由于利息收入增长及股权投资相关亏损减少，公司2023年Q4的非经营利润为17亿元，上年同期为-4亿元；去年全年，这项利润达到75亿元，而上年为-16亿元。 如果没有这项利润，在达达被爆业绩造假的负面影响下，2023Q4的业绩恐怕更加无法直视。
那么问题来了，究竟是放弃稳定求增长，还是保持稳定先生存，这是京东2024年必须回答的问题。
低价陷入“死结” 事实上，京东的低价策略，正在陷入一个“死结”：平台没有流量，无法吸引商家入驻和让利，就没办法实现低价；实现不了低价，就无法盘活用户和吸引新的用户。
这个“鸡生蛋还是蛋生鸡”的哲学问题，正在困扰着以消耗流量为主体的电商平台。
据晚点LatePost报道，京东此前多次在大促期间多次降低商品价格，部分品牌方一度要求停止合作。在刘强东看来，本质是因为今天京东在零售行业市场地位的下降，而美团、拼多多、抖音快速增长， “只要你手里有足够的用户和销量，上帝也一样能低头。”
最终，供应链低价推不下来的最终原因，归结到了流量的问题上。据第三方平台talkingdata的数据显示，从2023年3月到2023年8月，京东平台的用户活跃率正在缓慢下跌。
▲图源：talkingdata截图
从历史的经验来看，解决办法只有两个，其一是如拼多多一般真金白银的“砸”出用户心智，靠补贴吸引流量，再通过平台的玩法进行盘活；其二则是如抖音一般有一个天然的内容场，内容生产流量，电商消耗流量，自产自销，实现正循环。
因此我们看到，淘宝不断强调内容化，试图将自己变成“一体两面”的平台，而京东则更加注重吸引流量，无论是通过外部引流还是补贴吸引，试图通过先吸引流量，来促进商家低价。
一个很明显的信号是，2023的京东也比此前更加开放，不仅在站外与快手在3C品类方面进行合作，也与小红书对接数据，做消费者洞察、引入、成交，甚至再次豪掷千金，拿下2024春晚的合作，足见对新人群的渴求。
但这几次合作似乎都并没有对京东带来足够大的增益。
一位电商行业专家对「自象限」讲道：“京东早期与快手的合作，有一个很大的问题就是成交页面并没有跳转到京东商城，而是以类似商品卡的形式在快手直接完成了。这让用户迅速在快手养成了3C的购买的性质，反而弱化了京东。这也是为什么后来像追觅、小熊这样的电器品牌绕过了京东，直接入驻了快手。”
而春晚的合作，一直是历年互联网公司引流的杀手锏，表面上看，2024春晚互动超552亿次、发出30亿的互动红包，但京东需要的，不是一次瞬时的流量高峰，而是长期的活跃用户。
据参与了京东春晚红包的用户反馈到：“领京东红包特别麻烦，不仅要登录还要认领好友关系，让我把社交关系链搬到上面，在一系列复杂的操作之后，居然领到的是商品优惠券而不是能体现的红包，瞬间对京东好感度变得特别低。”
站在企业的角度上，我们不难理解京东想要通过一次春晚引流而带来更多交易、转化甚至是长尾流量，但复杂的玩法和不够“实在”的红包，也确实在一定程度上伤害了消费者的期待，同时也并没有因此而养成了低价心智。
不肯大力，能否出奇迹，京东需要找到一个流量生态正循环的转折点。
另一方面，无论是站外引流还是春晚大促，都已经是移动互联网时代“老掉牙”的玩法，20岁的京东在面对新的变革，需要的是当年刘强东带队打造京东物流时，破釜沉舟的决心和勇气，前怕狼后怕虎，终难抵挡新对手的势如破竹。
2024年，京东老矣，尚能饭否？
* 文中配图来源于网络
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/899e1a49694e62da24e16f687d221e32/" rel="bookmark">
			P8682 [蓝桥杯 2019 省 B] 等差数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include"bits/stdc++.h" using namespace std; /* 思路还是很简单的，即求出所有的公差d[i]=a[i]-a[i-1] ，然后找到 所有公差里相等的公差记为d[j]，然后求出d[j]的最大公约数即可 到这里可以发现时间复杂度相当之大，而且相当繁琐。 所以我们不是全求出d[i]之后再求d[j]的最大公约数，而是一个接一个的求解、更新即可 */ int gcd(int x,int y) { if(y==0) return x; return gcd(y,x%y); }//求最大公约数 int main() { int n; cin &gt;&gt; n; int a[100050]; for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i]; sort(a,a+n); int ans=a[1]-a[0]; if(a[n-1]==a[0])//判断是否为常数列 { cout &lt;&lt;n &lt;&lt;endl; return 0; } for(int i=2;i&lt;n;i++) { ans=gcd(ans,a[i]-a[i-1]);//求解、更新最大公约数 } cout &lt;&lt; (a[n-1]-a[0])/ans+1;//项数 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c9c7067907cbdff28d88f067420ad1/" rel="bookmark">
			OpenStack之Nova
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、Nova 使用OpenStack Compute来托管和管理云计算系统。 OpenStack Compute是基础架构即服务
（IaaS）系统的主要部分。 主要模块在Python中实现：
1因为认证，与OpenStack 身份认证keystone 交互。
2因为磁盘和服务器镜像， 与镜像服务Glance 交互。
3因为提供图形界面，与仪表盘Dashboard交互。
Nova是OpenStack云中的计算组织控制器。支持OpenStack云中实例（instances）生命周期的所有活动都由Nova处理。这样使得Nova成为一个负责管理计算资源、网络、认证、所需可扩展性的平台。但是，Nova自身并没有提供任何虚拟化能力，相反它使用libvirt API来与被支持的Hypervisors交互。Nova 通过一个与Amazon Web Services（AWS）EC2 API兼容的web services API来对外提供服务。
OpenStack Compute与OpenStack Identity（身份）进行交互以进行身份验证; 用于磁盘和服务器映像的OpenStack Image服务; 和用于用户和管理界面的OpenStack仪表板。 图像访问受到项目和用户的限制; 每个项目的配额有限（例如数量）。 OpenStack Compute可以在标准硬件上水平扩展，并下载图像以启动实例。
功能和特点：
实例生命周期管理
管理计算资源
网络和认证管理
REST风格的API
异步的一致性通信
Hypervisor透明：支持Xen,XenServer/XCP, KVM, UML, VMware vSphere and Hyper-V
OpenStack Compute由以下几个方面组成：
nova­api 服务
接受并响应最终用户的计算API调用。 该服务支持OpenStack Compute API，Amazon EC2 API 和特殊的Admin API，用于特权用户执行管理操作。 它执行一些策略并启动大多数业务流程活动，例如运行一个实例。
openstack云平台所有的服务相互之间进行通讯走各个服务的API接口。
访问API的方式：CLI命令行方式、web方式、第三方工具
nova­ api­ metadata 服务 接受来自实例的元数据请求，保存相关虚拟机的硬件数据，同时需要使用network。 当您使用nova­ network安装在多主机模式下运行时，通常会使用nova ­api­ metadata服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c9c7067907cbdff28d88f067420ad1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b819c74827da45c1e5888634e6c79f2/" rel="bookmark">
			[数据结构初阶】栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位读者老爷好，鼠鼠我好久没写博客了（太摆烂了），今天就基于C语言浅介绍一下数据结构里面的栈，希望对你有所帮助吧。
目录
1.栈的概念及结构
2.栈的实现
2.1定义栈
2.2.初始化栈 2.3.入栈
2.4.出栈
2.5.获取栈顶元素
2.6.获取栈中有效元素个数
2.7.检查栈是否为空，如果为空返回真，如果不为空返回假
2.8.销毁栈 3.栈小应用
3.1.Stack.h
3.2.Stack.c 3.3.test.c 4.小知识
5.ending
1.栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入、删除和访问元素操作（ps：我们之前介绍的顺序表和链表都可以在任意位置插入、删除和访问）。进行数据插入、删除和访问操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
这里有几个概念需要理解，将栈比喻成手枪弹夹十分合适：
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶，弹夹出入弹口就像栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
后进先出的原则：栈中的数据元素的插入、删除和访问均要遵循这个原则。栈中的数据元素就像子弹，先进入弹夹的子弹会后射出，后进入弹夹的子弹会先射出，栈中数据元素在栈中的操作就像弹夹的子弹一般。
举个列子解释栈中元素遵守的后进先出原则如图：
2.栈的实现 栈的实现一般可以使用数组或者链表实现，实现出来的栈只要满足数据结构对栈的定义即可。相对而言数组的结构实现更优一些，因为数组在尾上插删数据的代价比较小。所以下面我们实现一下以数组尾部为栈顶的数组栈。
而定长的静态栈的结构，实际中一般不实用，所以我们主要实现下面的支持动态增长的栈。
我们栈主要实现以下功能：
typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }Stack; //初始化栈 void StackInit(Stack* ps); // 入栈 void StackPush(Stack* ps, STDataType data); // 出栈 void StackPop(Stack* ps); // 获取栈顶元素 STDataType StackTop(Stack* ps); // 获取栈中有效元素个数 int StackSize(Stack* ps); // 检测栈是否为空，如果为空返回真，如果不为空返回假 bool StackEmpty(Stack* ps); // 销毁栈 void StackDestroy(Stack* ps); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b819c74827da45c1e5888634e6c79f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc6dfee8d71d04687ac91b752c68ac39/" rel="bookmark">
			【WEEK1】 【DAY2】 【DAY3】【DAY4】新建SpringMVC项目【中文版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 2024.2.27 Tuesday1. 新建SpringMVC项目1.1 创建空白Project1.2 pom中添加依赖1.3 建立一个module:名为 springmvc-01-servlet, 添加Web app的支持1.4 导入servlet 和 jsp 的 jar 依赖 2024.2.28 Wednesday1.5 新建并编写HelloServlet类，用于处理用户请求1.6 新建名称为jsp的directory包，位于WEB-INF文件夹下在这个包下新建test.jsp文件 1.7 新建Helloservlet.java文件Src-main-java中建包 1.8 在web.xml中注册Servlet在web文件夹下新建jsp文件1.9 下载并配置Tomcat，启动测试1.10 打开（链接因人而异） 2024.2.29 Thursday1.11 MVC框架要做哪些事情常见的服务器端MVC框架 2 什么是SpringMVC2.1.概述2.1.1.Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。2.1.2.查看官方文档：2.1.3.为什么要学习SpringMVC 2.2.中心控制器2.2.1.Spring的web框架围绕DispatcherServlet设计2.2.2.Spring MVC框架像许多其他MVC框架一样2.2.3.查看随便一个文件的dispatcherServlet步骤2.2.4.SpringMVC的原理 2.3.SpringMVC执行原理2.3.1.简要分析执行流程（是以上图1~12步骤为顺序解释） 2024.2.27 Tuesday 1. 新建SpringMVC项目 使用的开发工具为IntelliJ IDEA
1.1 创建空白Project 大体如下截图：
1.2 pom中添加依赖 （等待下载并检查）
&lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc6dfee8d71d04687ac91b752c68ac39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a31e69ac88ed841c933a99c301cefd9/" rel="bookmark">
			MySql、Oracle数据库批量删除多个表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 使用Navicat工具直接在界面中删除，只能单张表删除，不能多选。
解决方案： 我们可以通过SQL语句来批量删除多个表，其中test替换成你要查询的数据库名字，注意数据库名称和表名大小写。
一、MySql 数据库 1.生成删除某个数据库下所有的表SQL
-- 查询构建批量删除表语句（根据数据库名称） select concat('drop table ', TABLE_NAME, ';') from information_schema.TABLES where TABLE_SCHEMA = 'test'; 2.生成删除某个数据库下指定的表名SQL
-- 查询构建批量删除表语句（根据数据库中的表名称模糊查询） select concat('drop table ', TABLE_NAME, ';') from information_schema.TABLES where TABLE_SCHEMA = 'test' and TABLE_NAME like 'sys_%'; 复制查出来的删除sql语句，并批量执行。
drop table sys_dept; drop table sys_dict; drop table sys_log; drop table sys_log_2022; drop table sys_menu; drop table sys_notice; drop table sys_role; drop table sys_role_menu; drop table sys_user; drop table sys_user_dept; drop table sys_user_role; drop table sys_user_token; 一、Oracle 数据库 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a31e69ac88ed841c933a99c301cefd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea30b4a7e7cd732245d828411e6dffe/" rel="bookmark">
			（k8s中）docker netty OOM问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先查看docker的内存占用情况： docker top 容器名 -u 查看内存cpu占用率（容器名来自kubectl describe pod xxx或者docker ps）
可以看出内存一直增长，作为IO代理这是不正常的。
2、修改启动参数和配置文件 需要注意的是为了安全考虑，docker默认是不能使用一些调试手段的，需要修改启动参数和yaml
docker file中增加启动参数（yaml中应该也可以）：
ENTRYPOINT ["java", "-jar", "/usr/local/bin/access-1.0-SNAPSHOT.jar", "-XX:NativeMemoryTracking=detail"] yaml增加：
apiVersion: apps/v1 kind: Deployment ....... spec: ........ template: ........ spec: containers: - name: access ......... securityContext: capabilities: add: ["SYS_PTRACE"] 3、查看具体内存占用 各类内存增长情况：
#建立内存基线 jcmd 1 VM.native_memory baseline #与基线对比 jcmd 1 VM.native_memory summary.diff 其中1是pid，可以通过jps查看
查看当前内存具体申请源：
jcmd 1 VM.native_memory detail scale=MB 查看结果是Other的内存增长比较明显：
[0x00007f76b2143b77] Unsafe_AllocateMemory0+0x87 [0x00007f769577c4ba] (malloc=732MB type=Other #228) Unsafe_AllocateMemory0一般是ByteBuf申请的内存，jvm不管理，也就是不会gc，需要自己关注申请和释放
4、自己申请的ByteBuf 自己申请的ByteBuf要么往下传递（通过ctx write或者fire read）由后面的pipe节点释放，要么自己通过release释放。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea30b4a7e7cd732245d828411e6dffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c26953bd02d97c6cbdfbd12fb75c9f/" rel="bookmark">
			数据结构-＞链表分类与oj（题），带你提升代码好感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉
🍎个人主页：橘橙黄又青-CSDN博客
1.🍎链表的分类 前面我们学过顺序表，顺序表问题：
1. 中间/头部的插入删除，时间复杂度为O(N)2. 增容需要申请新空间，拷贝数据，释放旧空间。会有不小的消耗。3. 增容一般是呈2倍的增长，势必会有一定的空间浪费。例如当前容量为100，满了以后增容到 200，我们再继续插入了5个数据，后面没有数据插入了，那么就浪费了95个数据空间。 这些问题，链表给出了相应的答案。
概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表 中的指针链接次序实现的 。
比如说我们前面学习的单链表就是如此。
单链表是单向不循环不带头链表
实际中要实现的链表的结构非常多样，以下情况组合起来就有8种链表结构：
1. 单向、双向2. 带头、不带头3. 循环、非循环 又称2x2x2 图解：
1. 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结 构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。2. 带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都 是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带 来很多优势，实现反而简单了，后面我们代码实现了就知道了。 2.🍎链表相关基础oj 题目链接设计链表. - 力扣（LeetCode）两数相加. - 力扣（LeetCode）合并两个有序链表. - 力扣（LeetCode）两两交换链表中的节点. - 力扣（LeetCode）删除排序链表中的重复元素. - 力扣（LeetCode）删除排序链表中的重复元素II. - 力扣（LeetCode）相交链表. - 力扣（LeetCode）移除链表元素. - 力扣（LeetCode）回文链表. - 力扣（LeetCode）奇偶链表. - 力扣（LeetCode）链表的中间结点. - 力扣（LeetCode）链表最大孪生和. - 力扣（LeetCode）两两交换链表中的节点404: This page could not be found 合并两个链表中，可以安排一个哨兵（头）可以减少判断空的代码。
哨兵位的申请：
这些都是比较好的题目，
接下来我们分析几道题目
题目链接反转链表. - 力扣（LeetCode）反转链表II. - 力扣（LeetCode）链表中间节点问题. - 力扣（LeetCode）环形链表的约瑟夫问题环形链表的约瑟夫问题_牛客题霸_牛客网 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c26953bd02d97c6cbdfbd12fb75c9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337b0290450bccdd4c303c9a6f5c7847/" rel="bookmark">
			【java开发者工具】IDEA（java编程语言开发的集成环境）带你了解背后故事与基础操作指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉
🍎个人主页：橘橙黄又青-CSDN博客
1.🍎 IDEA介绍 IDEA 全称 IntelliJ IDEA，是java编程语言的集成开发环境。IntelliJ在业界被公认为最好的Java开发工具，尤其在智能代码助手、代码自动提示、重构、JavaEE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java,Kotlin等少数语言。
2.🍎 特色功能 DEA所提倡的是智能编码，是减少程序员的工作，IDEA的特色功能有以下22点 ：
🍎　智能的选取
在很多时候我们要选取某个方法，或某个循环或想一步一步从一个变量到整个类慢慢扩充着选取，IDEA就提供这种基于语法的选择，在默认设置中Ctrl+W，可以实现选取范围的不断扩充，这种方式在重构的时候尤其显得方便。
🍎　丰富的导航模式
IDEA提供了丰富的导航查看模式，例如Ctrl+E显示最近打开过的文件，Ctrl+N显示你希望显示的类名查找框（该框同样有智能补充功能，当你输入字母后IDEA将显示所有候选类名）。在最基本的project视图中，你还可以选择多种的视图方式。
🍎　历史记录功能
不用通过版本管理服务器，单纯的IDEA就可以查看任何工程中文件的历史记录，在版本恢复时你可以很容易的将其恢复。
🍎　JUnit的完美支持
🍎　对重构的优越支持
IDEA是所有IDE中最早支持重构的，其优秀的重构能力一直是其主要卖点之一。
🍎　编码辅助
Java规范中提倡的toString()、hashCode()、equals()以及所有的get/set方法，你可以不用进行任何的输入就可以实现代码的自动生成，从而把你从无聊的基本方法编码中解放出来。
🍎　灵活的排版功能
基本所有的IDE都有重排版功能，但仅有IDEA的是人性的，因为它支持排版模式的定制，你可以根据不同的项目要求采用不同的排版方式。
🍎　XML的完美支持
xml全提示支持：所有流行框架的xml文件都支持全提示，谁用谁知道。
🍎　动态语法检测
任何不符合java规范、自己预定义的规范、累赘都将在页面中加亮显示。
🍎　代码检查
对代码进行自动分析，检测不符合规范的，存在风险的代码，并加亮显示。
🍎　对JSP的完全支持
不需要任何的插件，完全支持JSP。
🍎　智能编辑
代码输入过程中，自动补充方法或类
🍎　列编辑模式
用过UtralEdit的肯定对其的列编辑模式赞赏不已，因为它减少了很多无聊的重复工作，而IDEA完全支持该模式，从而更加提高了编码效率。
🍎　预置模板
预置模板可以让你把经常用到的方法编辑进模板，使用时你只用输入简单的几个字母就可以完成全部代码的编写。例如使用比较高的public static void main(String[] args){}你可以在模板中预设pm为该方法，输入时你只要输入pm再按代码辅助键，IDEA将完成代码的自动输入。
🍎　完美的自动代码完成
智能检查类中的方法，当发现方法名只有一个时自动完成代码输入，从而减少剩下代码的编写工作。
🍎　版本控制完美支持
集成了市面上常见的所有版本控制工具插件，包括git、svn、github，让开发人员在编程的工程中直接在intellij idea里就能完成代码的提交、检出、解决冲突、查看版本控制服务器内容等等。
🍎　不使用代码的检查
自动检查代码中不使用的代码，并给出提示，从而使代码更高效。
🍎　智能代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337b0290450bccdd4c303c9a6f5c7847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23fa0235e61c17b6c5188e5fbbb95142/" rel="bookmark">
			【WEEK1】 【DAY2】 【DAY3】【DAY4】Creating a SpringMVC Project【English Version】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Contents 2024.2.27 Tuesday1. Creating a SpringMVC Project1.1 Create a Blank Project1.2 Add Dependencies in pom1.3 Establish a module: named springmvc-01-servlet, add support for Web app1.4 Import servlet and jsp jar dependencies 2024.2.28 Wednesday1.5 Create and write the HelloServlet class to handle user requests1.6 Create a directory named jsp, located under the WEB-INF folderCreate a file named test.jsp in this package 1.7 Create the Helloservlet.java fileCreate a package in Src-main-java 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23fa0235e61c17b6c5188e5fbbb95142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec399c67251f97d81e92d1e49c8c55c5/" rel="bookmark">
			Vue项目中使用Mock.js进行API模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue项目中使用Mock.js进行API模拟 🌟 前言 欢迎来到我的小天地，这里是我记录技术点滴、分享学习心得的地方。📚
🛠️ 技能清单 编程语言：Java、C、C++、Python、Go、前端技术：Jquery、Vue.js、React、uni-app、EchartsUI设计: Element-ui、Antd、Color-ui后端技术：Spring Boot、Mybatis-plus、Swagger移动开发：Android操作系统：Windows、Linux开发框架：RuoYi、微信小程序开发工具：VSCode、IDEA、Eclipse、WebStorm、HbuildX、Navicat、Xshell、Android Studio、Postman数据库技术：MySQL、Redis、SQL Server版本控制：Git 在开发Vue应用时，我们经常需要模拟API响应，以便在后端服务尚未准备好时进行前端开发。Mock.js是一个强大的工具，可以帮助我们轻松创建模拟数据。本教程将指导你如何在Vue项目中集成和使用Mock.js。
安装Mock.js 首先，你需要在你的Vue项目中安装Mock.js。
npm i mockjs 创建Mock数据 在你的项目中创建一个mock目录，并添加一个index.js文件。在这个文件中，我们将定义我们的模拟数据。
// src/mock/index.js import Mock from 'mockjs' // 创建模拟数据 const data = Mock.mock({ 'list|1-10': [{ 'id|+1': 1 }] }) // 模拟API响应 Mock.mock('/api/list/', 'get', () =&gt; { return data.list; }) 在Vue应用中导入Mock数据 在main.js文件中，导入并使用Mock数据。
// main.js import { createApp } from 'vue' import App from './App.vue' import '@/mock' // 导入Mock数据 createApp(App).mount('#app') 使用Mock数据 在Vue组件中，你可以像往常一样使用fetch或axios来请求模拟的API。
// page.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec399c67251f97d81e92d1e49c8c55c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e70e7e699d3c6de78f0f00cff6d015a/" rel="bookmark">
			java在cmd中乱码的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文深入探讨了在使用 Java 命令行（cmd）时可能出现的中文乱码问题，并提供了两种解决方案。首先，通过临时的方式，用户可以执行命令 chcp 936 选择字符集，然后再运行 Java 命令，确保在选择字符集过的 cmd 窗口中可以正常显示中文字符。其次，为了解决问题的根本，文章介绍了永久性的解决方案，通过新建环境变量 JAVA_TOOL_OPTIONS，在 cmd 中确保中文正常显示。这两种方法有效解决了 Java 在 cmd 中可能遇到的中文乱码问题，提供了灵活的解决途径供读者选择。
一、问题描述 如下图所示，我们在 cmd 里输入 java 命令，返回的中文字符乱码。
二、问题分析 在CMD（命令提示符）中执行Java命令时，返回的中文字符出现乱码。这可能是由于默认字符集不兼容导致的。 三、解决方案 1、解决方案一(临时) 通过执行 chcp 936 命令，我们可以临时选择合适的字符集。936 代表 GBK 字符集，执行这个命令后，CMD 窗口的字符集被更改，然后再运行 Java 命令，可以看到中文字符正常显示。这是一个实用的解决方案，但是只在当前 CMD 窗口有效。
具体步骤：
执行 chcp 936 命令，选择字符集为 936，即 GBK 编码。然后再运行 java 命令。 执行这个步骤后，可以看到返回的结果中中文字符显示正常。只要在选择字符集为 936 的 cmd 窗口中，就可以继续正常显示中文。
2、解决方案二(永久) 为了永久解决中文乱码问题，可以通过设置环境变量来配置 Java。
① 检查java基础环境变量 右键点击 "我的电脑"，选择 "属性"。
点击 "高级系统设置"。
我们先来检查基础的 Java 环境变量是否已经配置。
检查下列环境变量，如果没有需要补入：
系统变量 JAVA_HOME，变量值为：安装JDK的路径；系统变量 PATH，新建变量值为：安装JDK的路径\bin；系统变量 CLASSPATH，变量值为：.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e70e7e699d3c6de78f0f00cff6d015a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e425376f0d71bfd94c5e7ce5f2b1138/" rel="bookmark">
			Java代码审计安全篇-常见Java SQL注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 堕落了三个月，现在因为被找实习而困扰，着实自己能力不足，从今天开始 每天沉淀一点点 ，准备秋招 加油
注意： 本文章参考qax的网络安全java代码审计，记录自己的学习过程，还希望各位博主 师傅 大佬 勿喷，还希望大家指出错误
1.SQL语句参数直接动态拼接 常见的的执行语句为Statement执行SQL语句
例如下面这段代码：
&lt;% //驱动程序名 String driverName = "com.mysql.jdbc.Driver"; //数据库用户名 String userName = "root"; //密码 String userPasswd = "root"; //数据库名 String dbName = "javasqltest"; //表名 String ID = '1' //联结字符串 String url = "jdbc:mysql://localhost:3306/" + dbName + "?user=" + userName + "&amp;password=" + userPasswd; Class.forName("com.mysql.jdbc.Driver").newInstance(); Connection connection = DriverManager.getConnection(url); Statement statement = connection.createStatement(); String sql = "SELECT * FROM people where id = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e425376f0d71bfd94c5e7ce5f2b1138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c25e324fe40afba5c2d2b63f32dba1/" rel="bookmark">
			linux服务器查询系统版本，内存，存储等命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux服务器查询系统版本，内存，存储等命令 一、查看系统版本命令 1、使用uname命令 uname -a 2、使用cat命令 cat /etc/os-release 注意，以上命令不一定支持所有系统
二、查看系统内存命令 1、使用free命令，加上-h之后能显示单位，看上去更清晰 free -h 2、使用cat命令 cat /proc/meminfo 个人还是更喜欢使用free -h，看上去更清晰，按需使用就好
三、查看服务器存储 1、使用df命令 此命令可以看到文件系统使用了那些目录，目录大小等
df -h 2、使用lsblk命令 这个命令可以清晰的看到服务器有几块磁盘，磁盘的分配目录大小等情况
lsblk 当然，查看服务器存储的命令还有很多，比如lshw、fdisk等，这只是我自己使用到了的，所以做下记录，供大家参考使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e861349e8ebccd839d71371faccaec5/" rel="bookmark">
			【数据结构初阶】双向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位读者老爷好，很高兴你又来读本鼠鼠的博客。鼠鼠我呀基于C语言实现一下双向链表，有兴趣的读者老爷可以瞅瞅哈！
目录
1.定义双向链表节点
2.初始化哨兵位
3.双向链表销毁
4.双向链表打印
5.双向链表在pos的前面进行插入
6.双向链表删除pos位置的节点 7.双向链表尾插
8.双向链表尾删
9.双向链表头插 10.双向链表头删 11.双向链表查找
12.双向链表的小应用
12.1.list.h
12.2.list.c
12.3.test.c:
13.ending 好哈，我们上篇文章浅谈过链表的分类，其中讲到：
虽然有这么多的链表的结构，但是我们实际中最常用还是两种结构：
1. 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
2. 带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了。
那咱们上篇文章实现过了无头单向非循环链表 ，那这篇博客自然要实现带头双向循环链表了。
对于带头双向循环链表，好像听起来挺难的，但其实实现起来比无头单向非循环链表简单不是一星半点儿，咱们可以在接下来的代码中体会到，我们可以先来看看带头双向循环链表的逻辑结构如下图：
咱们可以看到有一个指针plist指向哨兵位（也就是头），所有节点均有三个数据域，分别存储所需存储的数据、前一个节点的地址和后一个节点的地址，我们通过地址即可找到想要的节点。这里讲的前后节点只是逻辑上的“前后”，实际上在内存中这些个节点通过保存的地址形成了循环，没有所谓的前后之分，那这个链表改重哪里开始呢？
其实就是从哨兵位开始的，让plist指向哨兵位，让哨兵位当“头”，也就在逻辑上形成了“前后”。
带头双向循环链表带哨兵位是有优势的，虽然哨兵位不存储有效数据，好似浪费了一个节点的空间，但是因为无论什么时候该链表都不可能为空，对于该链表的增删改等操作不用另外考虑空链表的情况 。带头双向循环链表的哨兵位是不能删除的。
以下带头双向循环链表简称双向链表。我们实现双向链表以下功能：
typedef int LTDataType; typedef struct ListNode { LTDataType data; struct ListNode* next; struct ListNode* prev; }ListNode; //初始化哨兵位 ListNode* LTInit(void); // 双向链表销毁 void ListDestory(ListNode* pHead); // 双向链表打印 void ListPrint(ListNode* pHead); // 双向链表在pos的前面进行插入 void ListInsert(ListNode* pos, LTDataType x); // 双向链表删除pos位置的节点 void ListErase(ListNode* pos); // 双向链表尾插 void ListPushBack(ListNode* pHead, LTDataType x); // 双向链表尾删 void ListPopBack(ListNode* pHead); // 双向链表头插 void ListPushFront(ListNode* pHead, LTDataType x); // 双向链表头删 void ListPopFront(ListNode* pHead); // 双向链表查找 ListNode* ListFind(ListNode* pHead, LTDataType x); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e861349e8ebccd839d71371faccaec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b5eebd02ebf7aaf9824c15fec8b70e/" rel="bookmark">
			【数据结构初阶】顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位读者老爷好，又见面了哈！鼠鼠我呀现在基于C语言浅浅介绍一下数据结构初阶中的顺序表，希望对你有所帮助！
目录
1.线性表 2.顺序表
2.1.概念即结构
2.2.动态顺序表接口的实现
2.2.1.定义顺序表
2.2.2.初始化
2.2.3.销毁 2.2.4.打印
2.2.5.尾插
2.2.6.头插 2.2.7.头删
2.2.8.尾删 2.2.9.顺序表查找
2.2.10.顺序表在下标pos位置插入数据x
2.2.11.顺序表删除下标pos位置的值
3.顺序表使用 3.1.test.c
3.2.SeqList.h
3.3.SeqList.c
4.小知识累积（与顺序表无关）
4.1.数组越界一定会报错吗？
4.2.数组的下标为什么不从1开始而要从0开始呢？ 5.ending
额额额，好哈！顺序表是线性表的一种哈！那我们看看下面是线性表！
1.线性表 线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...
线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。
咱们下面介绍的顺序表是一种在逻辑上和物理结构上是连续的。为什么说顺序表在物理结构上是连续的呢？因为顺序表在内存中是一块连续的空间，我们可以在下面体会。
2.顺序表 2.1.概念即结构 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存
储。在数组上完成数据的增删查改。
与数组不同的是，数组可以在不越界的情况下任意位置存储数据，而顺序表要求数据只能从头开始连续存储。
顺序表一般可以分为：
1.静态顺序表：使用定长数组存储数据
//顺序表的静态存储 #define N 7 #typedef int SLDataType typedef struct SeqList { SLDataType array[N];//定长数组 size_t size;//有效数据的个数 }SeqList; 2.动态顺序表：使用动态开辟的数组存储
//顺序表的动态存储 #typedef int SLDataType typedef struct SeqList { SLDataType*array;//指向动态开辟的数组 size_t size;//有效数据的个数 size_t capicity;//容量空间的大小 }SeqList; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2b5eebd02ebf7aaf9824c15fec8b70e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/508f341b9dc9f3d1b7b85997fe7a1ad8/" rel="bookmark">
			【数据结构初阶】算法的时间复杂度和空间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位读者老爷好！现在鼠鼠我呀来基于C语言浅谈一下数据结构初阶中的一个知识点：算法的时间复杂度和空间复杂度，希望对你有所帮助。
目录
1.什么是数据结构
2.什么是算法 3.时间复杂度
3.1时间复杂度的概念
3.2大O的渐近表示法
3.3常见时间复杂度举例分析
4.空间复杂度
4.1空间复杂度的概念
4.2常见的空间复杂度举例分析
5.复杂度的oj练习
6.ending
在浅谈时间复杂度和空间复杂度之前，咱们可以来了解一下一下几个概念：
1.什么是数据结构 数据结构(Data Structure)是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。
其实简单来说吧。数据结构就是在内存中管理数据。
拓展：
1.什么是数据库？ 简单来说：数据库就是在磁盘中管理数据。
2.内存和磁盘的异同
同：内存和磁盘都是电脑的两个核心存储介质，都是存储数据的两个硬件。
异：内存的速度快，需要带电存储；磁盘的速度（相对）慢，不带电存储。
2.什么是算法 算法(Algorithm):就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果。
咱们再简单来说。算法就是对数据做各种处理的方法。
那咱们如何判断一个算法的好坏呢？
算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度（时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。）。
3.时间复杂度 3.1时间复杂度的概念 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
那时间复杂度该如何计算呢？
咱们来抛砖引玉一下子哈，分析一下下面代码的时间复杂度：
void Func1(int N)//计算Fun1中++count总共执行多少次 { int count = 0; for (int i = 0; i &lt; N ; ++ i) { for (int j = 0; j &lt; N ; ++ j) { ++count; } } for (int k = 0; k &lt; 2 * N ; ++ k) { ++count; } int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/508f341b9dc9f3d1b7b85997fe7a1ad8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858a781f10bb6ea890a90ff445d0b9ad/" rel="bookmark">
			从零开发短视频电商 端到端测试Playwright实战CSDN搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景脚本录制配置窗口大小UserAgent设置全局默认超时时间保留登录身份信息加载登录身份信息 测试框架建议 背景 假设我是csdn的测试人员，我想测试如下流程：
1.用户进入站点https://www.csdn.net，
2.在搜索框输入"lakernote"
3.点击搜索按钮
4.切换为用户tab
5.断言列表中是否包含lakernote
相关源码在：https://gitee.com/lakernote/easy-auto-uitest
Playwright 内置了自动等待功能，它会在执行操作之前等待元素可操作。
Playwright 提供了assertThat重载来编写断言。
浏览器上下文 Playwright 为每个测试创建一个浏览器上下文。浏览器上下文相当于一个全新的浏览器配置文件。这提供了零开销的完整测试隔离。创建新的浏览器上下文只需几毫秒。
登录一次 保存上下文的身份验证状态并在所有测试中重用它。这绕过了每个测试中的重复登录操作，但提供了独立测试的完全隔离。
脚本录制 当您在浏览器中执行操作时，Playwright 的录制器能够为您生成测试代码。录制器将查看您的页面并找出最佳定位器，确定角色、文本和测试 ID 定位器的优先级。如果生成器找到与定位器匹配的多个元素，它将改进定位器，使其具有唯一标识目标元素的弹性。
运行下面代码以启动录制器。
import com.microsoft.playwright.*; public class Example { public static void main(String[] args) { try (Playwright playwright = Playwright.create()) { BrowserType chromium = playwright.chromium(); // Make sure to run headed. Browser browser = chromium.launch(new BrowserType.LaunchOptions().setHeadless(false)); // Setup context however you like. BrowserContext context = browser.newContext(/* pass any options */); context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/858a781f10bb6ea890a90ff445d0b9ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a065d9a08c616a0dae947b0a304f704/" rel="bookmark">
			清除注册表的U盘(USB盘)使用记录，或者电脑的U盘记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		清除注册表的U盘(USB盘)使用记录，或者电脑的U盘记录
1、可以考虑使用psexec.exe，在Windows图标按右键选择Windows PowerShell(管理员)(A)，然后输入PsExec.exe -i -d -s regedit.exe就可以删除(如果打开注册表，删除id需要右键修改权限为"完全控制"，但有时会失败)
psexec.exe 可以从 http://technet.microsoft.com/en-us/sysinternals/bb795533.aspx 下载PSTools.ZIP，然后解压缩后将psexec.exe复制到"c:\Windows\SYSTEM32\"下
2、删除注册表中以下目录的USBSTOR子项
（1）HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Enum\USB
（2）HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Enum\USBSTOR
（3）HKEY_LOCAL_MACHINE\SYSTEM\ControlSet003\Enum\USBSTOR
（4）HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\USBSTOR
附注，
如果执行PsExec.exe，出现错误信息：Error creating key file on &lt;COMPUTERNAME&gt;，请在Windows图标按右键选择"运行(R)"，在弹出的对话框中输入services.msc，然后找到Server(LanmanServer)，将其设置为"正在运行"，启动类型可以是"手动或自动"，重启电脑，即可正常运行PsExec.exe命令了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9c70e0beb2333fc9d28e5576000a04d/" rel="bookmark">
			Polars ，最强Pandas平替？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：数据studio
大家好，我是阿粥～
今天给大家分享关于Polars库的内容，前排提示，文末送两本好书～
Polars是一个用于操作结构化数据的高性能DataFrame库，可以说是平替pandas最有潜质的包。Polars其核心部分是用Rust编写的，但该库也提供了Python接口。它的主要特点包括：
快速: Polars是从零开始编写的，紧密与机器结合，没有外部依赖。
I/O: 对所有常见数据存储层提供一流支持：本地、云存储和数据库。
易于使用: 以原始意图编写查询。Polars 在内部会使用其查询优化器确定执行最有效的方式。
离线处理: Polars支持通过其流式API进行离线数据转换。这使您能够处理结果，而无需同时将所有数据存储在内存中。
并行处理: Polars通过在可用的CPU核心之间分配工作负载，充分利用计算机性能，而无需额外配置。
矢量化查询引擎: Polars使用 Apache Arrow，一种列式数据格式，以矢量化方式处理查询。它使用 SIMD 来优化CPU使用。
User guide: https://pola-rs.github.io/polars/user-guide/
API reference: https://pola-rs.github.io/polars/py-polars/html/reference/io.html
介绍
Polars 的目标是提供一个闪电般快速的 DataFrame 库，具有以下特点：
利用计算机上所有可用的核心。
通过优化查询来减少不必要的工作/内存分配。
处理比可用 RAM 更大得多的数据集。
具有一致且可预测的 API。
具有严格的模式（在运行查询之前应该知道数据类型）。
Polars 是用 Rust 编写的，这使得它具有 C/C++ 性能，并允许它完全控制查询引擎中的性能关键部分。因此，Polars 为此付出了很大的努力：
减少冗余的复制。
高效地遍历内存缓存。
在并行性中最小化争用。
以块处理数据。
重用内存分配。
基础 Series &amp; DataFrames Series 是一个一维数据结构。在一个 Series 中，所有元素都具有相同的数据类型（例如，整数、字符串）。下面的片段展示了如何创建一个简单的带有名称的 Series 对象。
import polars as pl import numpy as np s = pl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9c70e0beb2333fc9d28e5576000a04d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/25/">«</a>
	<span class="pagination__item pagination__item--current">26/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/27/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>