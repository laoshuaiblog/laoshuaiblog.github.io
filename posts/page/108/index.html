<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf23fff052b6f3e48e2331c29786a2a1/" rel="bookmark">
			python pandas获取groupby之后的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周，有个网友在后台提问，如何获取groupby之后的数据。后来，在网上还真找到了一种解决方法，虽然有点麻烦，但确实实现了。在这里小记录一下，供大家参考：
&gt;&gt;&gt; import pandas as pd # 原始数据 &gt;&gt;&gt; df = pd.read_excel(r'D:/myExcel/1.xlsx') &gt;&gt;&gt; df name math 0 bog 45 1 jiken 67 2 bob 23 3 jiken 34 # groupby之后的数据 &gt;&gt;&gt; dh = df.groupby(['name']) # 打印之后发现是个对象 &gt;&gt;&gt; dh &lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000002B675618F70&gt; # 通过勋魂调用发现内部保存了字典形式。key值是groupby列的值， # value是该值所代表的结果，以dateFrame格式保存 &gt;&gt;&gt; for key,value in dh: print(key) print(value) bob name math 2 bob 23 bog name math 0 bog 45 jiken name math 1 jiken 67 3 jiken 34 # 新建一个dataFrame，列名与df保持一致。通过 # 迭代进行行连接。得到结果 &gt;&gt;&gt; ds = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf23fff052b6f3e48e2331c29786a2a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aebd0d80228b29d9b5625341a0c3b2e2/" rel="bookmark">
			关于微信小程序js里赋值里还是会显示未定义的说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发微信小程序的过程中发现了一个小坑。
如果你要从数据库里或是其他什么来源读一个值出来，你要把他赋给一个变量，并且要求变量带的这个值在任何地方都有效，你需要按照以下的做法，方能避免出现undefined的天坑。
第一步，let 定义这个变量。
第二步，千万千万吧赋值写在onload函数里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c3961fef48aa4073014cfbb54c520f7/" rel="bookmark">
			如何给VMware中虚拟机设置固定IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在菜单栏选择编辑→ 虚拟网络编辑器 注：NAT模式配置：
上面的“使用本地DHCP服务……”这一项是没有钩选的，默认的设置是启动DHCP服务的，NAT会自动给虚拟机分配IP，但是我们需要将虚拟机的IP固定下来，所以要取消这个默认设置。
NAT是网络地址转换，是在宿主机和虚拟机之间增加一个地址转换服务，负责外部和虚拟机之间的通讯转接和IP转换。这里选择NAT模式，虚拟机通过NAT使用宿主机的IP来访问外网。我们的要求是虚拟机有固定的IP、可以访问外网，可以连接SecureCRT所以进行如上设置。
二、检查物理主机 网卡设置，右下“打开网络与Internet设置”→ 更改适配器选项 修改IP地址，网关、掩码与虚拟机里面设置的一样
三、进入虚拟机，设置固定IP地址。 输入如下命令：vi /etc/sysconfig/network-scripts/ifcfg-ens32（注意此处可能是ifcfg-ens32也可能是ifcfg-eth0）
注：修改网络设置必须是root用户或是sudo vi /etc/sysconfig/network-scripts/ifcfg-ens32
为了使地址生效，保存退出后需要重新启动网络配置，如下图输入：service network restart，使用ip addr命令查看修改后的网络属性
然后我们的SecureCRT就可以通过192.168.196.3连接VMware中的这台虚拟机了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c353ef82d280fca03ddad12b2de70a/" rel="bookmark">
			浮点数运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天学习了浮点数运算（加减乘除）。浮点数运算主要包括两部分：指数运算和尾数运算。在IEEE754标准下，指数运算就是阶码的运算，类似于无符号数运算。尾数运算是原码运算。之前一直很疑惑为什么前面的教材在介绍原码运算（加减乘除）所举的例子都是小数运算。现在猜想那部分内容可能只是为了浮点数运算做铺垫，这里才是主要的内容。（当然知识是不分重点的，但考试分）。下面就来详细介绍下浮点数运算的过程吧！另外本文使用的浮点数标准均为IEEE754结构，即单精度数由1位符号位，8位指数位，23位尾数位共计32位组成。
一、浮点数的加减运算： 浮点数的加减运算分为5个步骤：对阶、尾数相加、尾数规格化、尾数舍入处理、溢出判断处理。下面详细介绍：
1. 对阶： 所谓对阶，就是让两个操作数阶数相同，以便进行加减。实现的方式是对较小数的尾数进行右移操作。对阶的原则是向高阶看齐。计算公式为：
当结果大于0说明被加数（被减数）阶数高，则对加数（减数）进行移位对阶。小于0则反之改变被加数（被减数）。
2. 尾数加减： 将两个操作数的尾数相加减。值得注意的是：在IEEE754标准中，对于规格化数来说在小数点前有一位隐藏位1，在加减过程中需要把它还原到尾数中。尾数加减的实质是原码的加减，对于原码加减的规则如下图所示：
3. 尾数规格化： 加减完成的尾数形式未必满足IEEE754对于尾数的要求，即保留23位，小数点在第一个1之后。需要对尾数进行左规和右规，下面介绍一下左规和右规。
左规：将尾数向左移，用于清除第一个1前面出现的0。左规伴随着阶码减少，在左规过程中要检测阶码是否发生下溢，即阶码达到最小值（0000 0000）。
右规：将尾数向右移，用于两数相加后出现向高位进位的情况。因为两数相加最多进一位，所以右规最多一位。右规伴随着阶码的增加，在右规过程中要检测阶码是否发生上溢，即阶码达到最大值（1111 1111）。
4. 尾数的舍入处理： 在对阶和右规的时候，最右边的数字会被移出。为了保证最后计算的精度，把这些数字在过程中保存，等到最后进行舍入。也就是我上文提到的附加位。有两个问题值得注意：
1） 保留多少附加位合适？
2）最终对附加位怎么进行舍入？
在IEEE754中保留了保护位，舍入位，粘位三位作为附加位。同时对于IEEE754来说最后附加位的舍入，有如下规则：
5. 溢出判断： 在浮点数中是以阶码的溢出与否来作为评判标准的。单精度溢出分为上溢（指数大于等于127）和下溢（指数小于等于-126）。
插一句：“之前一直以为下溢的指数是-149，这个数字来源于-126再把所有的尾数向右移，当到达-149时刚刚好所有尾数全部为零，即表示零。这个误区在于没有正确的区分规格化数和非规格化数。对于规格化数而言，下溢就是-126，所以规格化数表示的最小值为1.00…乘2的-126次方，而0~0.111…乘2的-126次方就是非规格化数表示的范围。-149正是非规格化数表示的最小范围。这里贴一张图，更加便于理解。
下面直接粘贴一个书上的实例，对以上过程进一步加深了解：
二、浮点数乘除运算： 浮点数乘除和定点数乘除相同，在正式运算前会对操作数进行预处理。对于乘法如果有一个操作数为0则结果为0。对于浮点数除法，若被除数为0，则结果为0。除数为0分两种情况，第一种是被除数非零，第二种是被除数为0。下面着重介绍一下两种除数为0：
除数为0，被除数不为0：
结果为无穷大。在IEEE 754标准下就是阶码全为1，尾数全为0。C语言输出如下图：
除数为0，被除数为0：
结果是NAN（not a number)。在IEEE 754标准下就是阶码全为1，尾数非0。在C语言中输出如下图：
注：在Windows系统下，-1.#IND00即代表nan，Linux系统下会输出nan。
下面详细介绍无特殊情况浮点数的乘除运算：
浮点数乘除运算公式如下图：
1.浮点数的乘法： 点数的乘法运算主要分为四步：尾数相乘指数相加、尾数规格化、尾数舍入处理、溢出处理判断。
1）尾数相乘，指数相加： 尾数相乘即为原码相乘，这个具体的过程请参考另一篇文章：定点数运算（于文末给出网址）。值得注意的是，对于规格化浮点数要记得恢复隐藏位。指数相加可以直接运用移码的计算方法：
2）尾数规格化： 对于两个操作数的尾数一定都是大于1的（隐藏位导致），所以最终得到的结果，小数点前会有两位共三种情况（01，11，10）。若为01则不需规格化，11和10则需右规一位。注意对于IEEE754标准浮点数乘法不需要左规。
3）尾数舍入处理： 两个小数相乘，尾数自然更多，但位置是有限的，需要对尾数进行舍入，具体的舍入规则参照浮点数加减的舍入规则即可。
4）溢出处理判断： 乘法的溢出有两种可能：阶码相加减时，以及尾数右规时。右规与上文相同，下面介绍一下阶码溢出的判断标准：
注：Eb是最终的结果，EX和EY是操作数的指数值。
2.浮点数除法： 浮点数除法大致分为4步：尾数相除阶相减、尾数规格化、尾数舍入、溢出判断处理。由于除法大部分与乘法相似，所以此处只列出不同部分。
在尾数相除阶相减过程中，尾数除法也在上文引用那篇文章中有具体介绍。阶码相减的运算公式如下：
在尾数规格化步骤中：当除法运算完成后，若小数点前为0，则需进行左规以保证小数点前具有隐藏位1。
对于除法阶码溢出判断的规则如下：
注：Eb为最终结果指数，EXEY为操作数指数。
补充：在《程序是怎样跑起来的？》书中，对于阶码为什么使用0-127做了一个原因的解释：在计算机中，使用EXCESS系统的方法来同时存储正数和负数。这里面的0-127就是增加幻数之后的数字。幻数选择了127，可记为Excess_127。
本篇文章对于浮点数运算进行了介绍，因为作者水平有限，可能某些地方理解错误，请高手不吝赐教，批评指正，谢谢！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c8de2c9fb80f7ce7f3a624411718c3/" rel="bookmark">
			神经网络的计算及paddding为same和valid区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tensorflow下的程序，很多都是采用padding='SAME'，因此如何计算经过卷积操作以后输出层的尺寸，这个时候就要涉及到padding了。 卷积操作以后out=（input+2padding-kernel）/stride+1 *******************************************************************************************************************************
1、关于padding 参考链接：http://blog.sina.com.cn/s/blog_53dd83fd0102x356.html
定义： Padding在卷积(convolution)和池化(pooling)中都会被用到。在tensorflow比如tf.nn.conv2d，tf.nn.max_pool都有这参数
Valid: 用过滤器在输入的矩阵中按步长移动时候，会把最后的不足部分的列和行抛弃； Same: 先在输入矩阵上下各加个值为0的行，在左右各加个个值为0的列，也就是用0把原先的矩阵包裹一层，然后在移动的时候如果输入矩阵的列或者行长度不够，就用0来补齐 例子
看例子比较实际：
以一维向量做例子
输入(input)长度：13
过滤器(Filter)长度：6
步长(Stride)长度：5
"VALID" = 不会增加padding:
inputs: 1 2 3 4 5 6 7 8 9 10 11 (12 13)
|_____________| (抛弃不要)
|______________|
"SAME" = 会用0来做padding (如果步长是1的话，最终输出和输入一样大小):
pad| |Pad
inputs: 0| 1 2 3 4 5 6 7 8 9 10 11 12 13 |0 0
|_____________| |______________|
|_______________|
Notes:
"VALID" 会但只会抛弃最右边的列或者是最下面的行."SAME" 水平方向首先会在左右各加一个零，如果最后不够的话，会在右边再加零补齐，以满足最后一次完整的移动。对于垂直方向也是同理。 最终输出的行列数计算方法
SAME:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44c8de2c9fb80f7ce7f3a624411718c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/549929fe5b9bef0bd98a4ec4e3eef42c/" rel="bookmark">
			Can驱动芯片协议层及通信速率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.位定时 CAN总线上的所有节点都必须具有相同的标称比特率。CAN 协议采用不归零（ Non Return to Zero， NRZ）编码方式，在数据流中不对时钟信号进行编码。因此，接收时钟信号必须由接收节点恢复并与发送器的时钟同步。由于不同节点的振荡器频率和传输时间不同，接收器应具有某种能与数据传输边沿同步的锁相环（ Phase LockLoop， PLL）来同步时钟并保持这种同步。鉴于数据采用 NRZ 编码，有必要进行位填充以确保至少每 6 位时间发生一次边沿，使数字锁相环 （ Digital Phase LockLoop， DPLL）同步。MCP2515 通过 DPLL 实现位定时。 DPLL 被配置成同输入数据同步，并为发送数据提供标称定时。 DPLL 将每一 个 位 时 间 分 割 为 由 最 小 单 位 为 时 间 份 额 （ TimeQuanta， TQ）所组成的多个时间段。在位时间帧中执行的总线定时功能，例如与本地振荡器同步、网络传输延迟补偿和采样点定位等，都是由DPLL 的可编程位定时逻辑来规定的。 2. CAN 位时间 CAN 总线上的所有器件都必须使用相同的比特率。然而，并非所有器件都要求具有相同的主振荡器时钟频率。对于采用不同时钟频率的器件，应通过适当设置波特率预分频比以及每一时间段中的时间份额的数量来对比特率进行调整。CAN位时间由互不重叠的时间段组成。 每个时间段又由时间份额 （TQ）组成，在本数据手册的后面部分将对此进行解释。在 CAN 规范中，标称比特率 （NominalBit Rate， NBR）定义为在不需要再同步的情况下，理想发送器每秒发送的位数，它可用下面的公式来表示：
标称位时间： 标称位时间 （Nominal Bit Time， NBT）（ tbit）由互不重叠的段时间段组成（图-2） 。因此 NBT 为下列时间 段之和： 以上一个标称位时间，你可以理解为一个一定频率高电平或者一个低电平，它们里面分了如下几段，是为了能够精准的采样到总线上的数据，这个应该是硬件支持的，咱们不多做研究。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/549929fe5b9bef0bd98a4ec4e3eef42c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21463674fdfe69230b4250876d2b40a/" rel="bookmark">
			nginx启动报错：/usr/local/nginx/sbin/nginx: error while loading shared libraries: libcrypto.so.1.1:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CentOS7下配置Nginx，但是一致都在报错。报错信息为：
./nginx: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory
如下图所示：
首先检测原因所在，通过下面的命令行检测：
ldd $(which /usr/local/nginx/sbin/nginx)
执行结果 下图所示：
报错的原因是库文件少了：libcrypto.so.1.1文件，显示为Not found
接下来查看openssl version，并且输入出的结果如下图所示：
然后，我搜索了一下，
解决该问题的命令行如下，记住，执行命令的目录是在/lib64下：
然后，执行
ldd $(which /usr/local/nginx/sbin/nginx)
查看的结果如下图所示：
此时题目中给出的问题就解决了。
重新启动Nginx试试看。
[root@localhost sbin]# ./nginx
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
如果浏览器显示如下界面,表示CentOS下配置Nginx服务器已成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8a80b3cb80ba9d653b94ac6578de26/" rel="bookmark">
			MATLAB 绘制全国各省 市温度或者湿度地图(附全国省市区县四级地图shp格式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 效果图 2 代码 clc,clear load('shpdata.mat') % save('shpdata','SHP_DATA') colour_totall=512 shp_data = SHP_DATA.shp_data province_data=shaperead('maps/bou2_4p.shp', 'UseGeoCoords', true);% 省 %将省界多边形属性转为线条属性，否则会被覆盖 province_len = length(province_data) for i=1:province_len province_data(i).Geometry = 'Line' end num=length(shp_data) %本地图太老没有 香港 澳门 营口 襄阳四个城市 except_city = {'香港' '澳门' '营口' '襄阳' '台湾'} except_num=length(except_city) d=importdata('temperature.txt'); data=d.data; % 温度数据 city_arr=d.textdata; % 相对应的市名称 datanum = length(data) mycolormap=hot(colour_totall); %将颜色反序 mycolormap = inverted_color(mycolormap) % geo_name={shp_data.NAME}'; for j = 1:num geo_name{j} = shp_data(j).VARNAME_2 end max_temperature = max(data)+2; min_temperature = min(data)-2 n=datanum; % 市数量 symbol_spec=cell(1,n-except_num); % 预定义变量可以加快处理速度 symbol_index=1 for i=1:n tmp_pn=city_arr{i}; %过滤掉四个不在地图内的城市 if ~isempty(findstr(tmp_pn,except_city{1})) || ~isempty(findstr(tmp_pn,except_city{2})) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc8a80b3cb80ba9d653b94ac6578de26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af7dd9562d1202f9046ae602ad838e3/" rel="bookmark">
			HCL配置SSH远程登录实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH配置例子 实验拓扑
对 MAR36-20_1进行配置
配置命令如下： 路由器 MAR36-20_1
[H3C]int g0/0 [H3C-GigabitEthernet0/0]ip address 192.168.0.254 24 [H3C-GigabitEthernet0/0]qu [H3C]ssh server enable //开启SSH服务 [H3C]line vty 0 4 //进入线程模式，允许0/1/2/3/4线路 [H3C-line-vty0-4]authentication-mode scheme //设置认证模式，组合模式有用户名和密码的模式 [H3C-line-vty0-4]protocol inbound ssh //ssh协议 [H3C-line-vty0-4]qu [H3C]local-user sshclient //创建本地用户：sshclient [H3C-luser-manage-sshclient]password simple abc //本地用户密码：abc [H3C-luser-manage-sshclient]service-type ssh /服务类型ssh [H3C-luser-manage-sshclient]authorization-attribute user-role network-admin //角色权限 user-role是网络管理 命令配置完成后进行修改网卡IP地址
修改成功后用ping命令验证
ping通之后用CRT进行SSH连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9a186efbbdeb7146f5331726c7d619/" rel="bookmark">
			Kotlin关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.jianshu.com/p/77e42aebd7bb
let扩展函数的实际上是一个作用域函数，当你需要去定义一个变量在一个特定的作用域范围内， let函数的是一个不错的选择；let函数另一个作用就是可以避免写一些判断null的操作。 Kotlin： 1.inline（内联函数）关键字：也就是说inline关键字实际上增加了代码量，但是提升了性能， 而且增加的代码量是在编译期执行的，对程序可读性不会造成影响 2.object：静态类 3.Any：根类型，类似Java的Object，但是又区别 4.data：修饰类，数据类，类似Bean 5.Kotlin中有两种延迟初始化的方式。一种是lateinit var，一种是by lazy。 https://blog.csdn.net/liyi1009365545/article/details/84236433 lateinit var只能用来修饰类属性，不能用来修饰局部变量，并且只能用来修饰对象， 不能用来修饰基本类型(因为基本类型的属性在类加载后的准备阶段都会被初始化为默认值)。 lateinit var的作用也比较简单，就是让编译期在检查时不要因为属性变量未被初始化而报错。 Kotlin相信当开发者显式使用lateinit var 关键字的时候，他一定也会在后面某个合理的时机 将该属性对象初始化的(然而，谁知道呢，也许他用完才想起还没初始化)。 首先两者的应用场景是略有不同的。 然后，虽然两者都可以推迟属性初始化的时间，但是lateinit var只是让编译期忽略对属性 未初始化的检查，后续在哪里以及何时初始化还需要开发者自己决定。而by lazy真正做到了 声明的同时也指定了延迟初始化时的行为，在属性被第一次被使用的时候能自动初始化。 但这些功能是要为此付出一丢丢代价的。 6.let：let扩展函数的实际上是一个作用域函数，当你需要去定义一个变量在一个特定的作用域范围内， let函数的是一个不错的选择；let函数另一个作用就是可以避免写一些判断null的操作。 使用Navigation进行Fragment管理的时候
界面跳转： Navigation.findNavController(it).navigate(R.id.action_page3 === nav_host_fragment.findNavController().navigate(R.id.loginPolicyFragment)
返回处理：当前Fragment返回到上一个Fragment
btn.setOnClickListener { Navigation.findNavController(it).navigateUp() } ===
top_back.singleClickListener { nav_host_fragment.findNavController().navigateUp() }
然后需要在Activity中重新方法：
override fun onSupportNavigateUp() = nav_host_fragment.findNavController().navigateUp()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0184fef03907cf754f79e21c45359208/" rel="bookmark">
			python3报错: takes 1 positional argument but 2 were given 问题解决。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用python3的时候，刚开始使用，把所有的都写在了一个文件中，这不符合类的六大设计原则。就把原来的代码按照类进行了拆分。
关于类的六大设计原则：开放关闭原则，里氏替换原则，依赖倒转原则，接口隔离原则，迪米特原则。这里不作过多的解释，大家可以自行百度。
拆分完之后，使用main方法进行实例调用的时候，发现一直报错“ takes 1 positional argument but 2 were given ”。
代码合到一个文件又是好的，这逗我了这是！
看代码，确实又只定义了一个参数。
后来从网上找了个示例下来对比，发现调用类文件的def中，别人比我的代码中多了个参数self。
上网查了查，网上说，类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，但是在调用这个方法的时候你不为这个参数赋值，Python会提供这个值。这个特别的变量指对象本身，按照惯例它的名称是self。
简单来说就是，第一个参数是对象本身，这个是必须的。
在类方法加上第一个参数self。再启动调试。OK了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/967befe6ab602581e2657c87ed53d57a/" rel="bookmark">
			自学Linux 5—Linux 环境下的编译器之 GCC 编译器工具集详细知识点以及静态库与动态库的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Linux 下的 GCC 编译器工具集 在 Linux 环境下的编译器之 Vim 安装与基本操作使用 中介绍了如何使用 Linux 环境下的编译器编写程序，并编写了一个 hello.c 的程序。要使编写的程序能够运行，需要进行程序的编译。 Linux 环境下采用的编译器 GCC 来进行对程序的编译。
1. GCC 简介 GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写，包含 gcc、g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar、nm 等。
gcc -o(output) -o 是指定输出的文件叫什么 gcc -v / --v / --version 查看 gcc 版本号 gcc -I&lt;dir&gt;	指定头文件目录，注意 -I 和指定目录之间没有空格 例：gcc -I./dir/dir test.c dict.c -o app (test.c 中的头文件 &lt;dict.c&gt; 的在 ./dir/dir 目录下，可以理解为间接使 dict.c 成为了系统目录下的文件) gcc -c	只编译，生成 .o 文件，不进行链接 gcc -g	包含调试信息，生成的程序里面包含调试信息，可以用 Debug 工具进行调试。例：gcc test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/967befe6ab602581e2657c87ed53d57a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28cde0499ad669536d6b55d7b7804f3c/" rel="bookmark">
			MATLAB 求任意一个数的所有因子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB 求 任意一个数的所有因子
我们都知道matlab 有自带的求最大公约数和最小公倍数的函数，但是缺少求取任意一个数所有 因子 的函数，
我么有时候将一个数组进行分段截取的时候希望每段长度都是一样的，类似这样的情况都会用到这样的函数。
这里给出 matlab 代码:
例如求取832的所有因子
x=832; factors =[]; k=1; for i=2:round(length(x)/2) if (mod(x,i)==0) fators(k)=i; k=k+1; end end factors 数组里面就存储了数字 832 的所有因子。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db77e9661718a9edc227c44313c0f02/" rel="bookmark">
			CAN总线学习-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAN总线学习-1 最近开始学习CAN，希望每天能够做些笔记，有所积累。本文基于weixin_40528417博主的内容。
1 位定时
1.1 位速率
-位速率:又叫做比特率（bit rata）、信息传输率，表示的是单位时间内，总线上传输的信息量，即每秒能够传输的二进制位的数量，单位是bit per second。
1.2 位时间
1.2.1 位时间定义
-位时间：表示的是一个二进制位在总线上传输时所需要的时间。
位速率=1/位时间 首先先了解两个时钟的概念：晶振时钟周期和CAN时钟周期
晶振时钟周期：由振荡器的晶振频率决定的，是振荡器每震荡一次所消耗的时间，也是整个系统中最小的时间单位。
CAN时钟周期：CAN时钟是由系统时钟分频而来的一个时间值，实际上就是一个Tq。可以按照下面的公式计算
CAN时钟周期=2×晶振时钟周期×BRP(baudrate prescaler)
下面图片SS+PS+PBS1+PBS2 = tBit
1.2.2 位时间分布
如上面所述：一个CAN的最小的时间单位是Tq。
位时间主要分成4段：同步段，传播段，相位缓冲段1，相位缓冲段2，总共8-25个Tq。
1）同步段（Synchronization Segment）：
长度固定，1个时间量子Tq；
一个位的传输从同步段开始；
同步段用于同步总线上的各个节点，一个位的跳边沿在此时间段内。
2）传播段（Propagation Segment）：
传播段用于补偿报文在总线和节点上传输时所产生的时间延迟；
传播段时长 ≥ 2 × 报文在总线和节点上传输时产生的时间延迟 ；
传播段时长可编程（1~8个时间量子Tq）。
3）相位缓冲段1（Phase Buffer Segment1）：
用于补偿节点间的晶振误差；
允许通过重同步对该段加长；
在这个时间段的末端进行总线状态的采样；
长度可编程（1~8Tq）
4）相位缓冲段2（Phase Buffer Segment2）：
用于补偿节点间的晶振误差；
允许通过重同步对该段缩短；
长度可编程（1~8个时间量子Tq）
5） 采样点（Sample Point）
采样点一般位于相位缓冲段1之后，采样点是读取总线电平，并解释各位的值的一个时间点，采样点对CAN总线来说也非常重要，尤其在组网的时候，多个节点尽量保持同一个采样点，且最好在但不超过7/8位时间点上。
2. CAN的同步机制
在CAN通信中，有两种同步机制：硬同步与重同步
2.1 同步的规则
一个位时间内只允许一种同步方式，要么硬同步要么重同步；
任何一个从“隐性”到“显性”的下降沿 都可以用于同步；
硬同步发生在报文的SOF位（ SOF指帧起始：数据帧开始的段），所有接收节点调整各自当前位的同步段，使其位于发送的SOF位内；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1db77e9661718a9edc227c44313c0f02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec6d56e1fb9ac6b9848cf687b17066d/" rel="bookmark">
			ubuntu怎样打开命令行终端（5种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎样打开终端 方法1 首先在桌面任意空白处，按CTRL+ALT+T
这时就弹出终端窗口 （呵呵这招最好用）
方法2 指向左上角的Dash主页图标,并且双击打开
在弹出的Dash主页里的最下方，打开一个像个川字一样的图标
点开图标后，在第二行已安装里双击一下
之后一直往下面就可以看到终端了
方法3 第三种 把鼠标指向启动器里面的--主文件夹
在弹出的主文件夹页面里的右上方双击--搜索
在弹出的框框里输入gnoem-terminal 输入之后回车一下
然后在搜索结果下方把位置改成--文件系统
接着再点击重新装入
把搜索出来的结果一直往下拉就可以看到终端了
方法4 第四种 双击启动器栏的Dsah主页
然后在搜索框里打上--终端（此方法只适合一些打拼音的网友）。
因为ubuntu默认下五笔输入法，还没安装
方法5 第五种就是把终端发复制桌面，和 锁定在启动器栏里面
怀有希望!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fba6826b23a8978396e480d72982cd6/" rel="bookmark">
			adb命令查看设备内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用power shell 比cmd 更好用
输入命令:adb shell procrank 或者用adb shell top
看ram 大概905M 也就是1G内存
VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）
RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存）
PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）
USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）
VSS：VSS表示一个进程可访问的全部内存地址空间的大小。这个大小包括了进程已经申请但尚未使用的内存空间。在实际中很少用这种方式来表示进程占用内存的情况，用它来表示单个进程的内存使用情况是不准确的。
RSS：表示一个进程在RAM中实际使用的空间地址大小，包括了全部共享库占用的内存，这种表示进程占用内存的情况也是不准确的。
PSS：表示一个进程在RAM中实际使用的空间地址大小，它按比例包含了共享库占用的内存。假如有3个进程使用同一个共享库，那么每个进程的PSS就包括了1/3大小的共享库内存。这种方式表示进程的内存使用情况较准确，但当只有一个进程使用共享库时，其情况和RSS一模一样。
USS：表示一个进程本身占用的内存空间大小，不包含其它任何成分，这是表示进程内存大小的最好方式！
可以看到:VSS&gt;=RSS&gt;=PSS&gt;=USS
查看单个app的内存使用情况
adb shell dumpsys meminfo app的包名 ---------------如果这个app有多进程,统计起来会显示不全
推荐下面这个
dumpsys meminfo --package app的包名 可以看到app多进程的内存消耗,这个app包含2个进程 实际消耗应该是(50638+76563)/1024=124M
例如dumpsys meminfo --package com.test.app
更详细的说明请看:
Android内存分析命令 - Gityuan博客 | 袁辉辉的技术博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e400be061b35d33c85835c304d9fe733/" rel="bookmark">
			C#后台弹出窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;SCRIPT LANGUAGE="javascript"&gt; &lt;!-- window.open ('page.html', 'newwindow', 'height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no,location=n o, status=no') ; --&gt; &lt;/SCRIPT&gt; 参数解释：
js脚本结束
利用Response.Write将JavaScript写出
//关闭,父窗口弹出对话框,子窗口直接关闭
Response.Write("&lt;script language=javascript&gt;window.close();&lt;/script&gt;"); //关闭,父窗口和子窗口都不弹出对话框,直接关闭
Response.Write("&lt;script&gt;{top.opener =null;top.close();}&lt;/script&gt;"); //弹出窗口刷新当前页面width=200 height=200菜单。菜单栏,工具条,地址栏,状态栏全没有
Response.Write("&lt;script language=javascript&gt;window.open('rows.aspx','newwindow','width=200,height=200')&lt;/script&gt;"); //弹出窗口刷新当前页面
Response.Write("&lt;script language=javascript&gt;window.open('rows.aspx')&lt;/script&gt;"); Response.Write("&lt;script&gt;window.open('WebForm2.aspx','_blank');&lt;/script&gt;"); //弹出提示窗口跳到webform2.aspx页(在一个IE窗口中)
Response.Write(" &lt;script language=javascript&gt;alert('注册成功'); window.window.location.href='WebForm2.aspx';&lt;/script&gt; "); //关闭当前子窗口,刷新父窗口
Response.Write("&lt;script&gt;window.opener.location.href=window.opener.location.href;window.close();&lt;/script&gt;"); Response.Write("&lt;script&gt;window.opener.location.replace(window.opener.document.referrer);window.close();&lt;/script&gt;"); //子窗口刷新父窗口
Response.Write("&lt;script&gt;window.opener.location.href=window.opener.location.href;&lt;/script&gt;"); Response.Write("&lt;script&gt;window.opener.location.href='WebForm1.aspx';&lt;/script&gt;"); //弹出提示窗口.确定后弹出子窗口(WebForm2.aspx)
Response.Write("&lt;script language='javascript'&gt;alert('发表成功！');window.open('WebForm2.aspx')&lt;/script&gt;"); //弹出提示窗口,确定后,刷新父窗口
Response.Write("&lt;script&gt;alert('发表成功！');window.opener.location.href=window.opener.location.href;&lt;/script&gt;"); //弹出相同的一页
&lt;INPUT type="button" value="Button" onclick="javascript:window.open(window.location.href)"&gt; Response.Write("parent.mainFrameBottom.location.href='yourwebform.aspx?temp=" +str+"';"); 例:
window.open('detail.aspx?ID="+e.Item.Cells[1].Text+"','newwin','width=750,height=600,scrollbars=yes,top=50,left=50');"); Response.Write("&lt;Script&gt;window.open('WebForm2.aspx','','toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=no,resizable=yes,width=750,height=470,left=80,top=40');&lt;/script&gt;"); 例:
Response.Write("&lt;script&gt;alert('发表成功！');window.opener.location.href=window.opener.location.href;&lt;/script&gt;"); Response.Write("&lt;script&gt;"); Response.Write("{top.opener =null;top.close();}"); Response.Write("&lt;/script&gt;"); 例:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e400be061b35d33c85835c304d9fe733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff168b4f44e05d15700514754cc35e20/" rel="bookmark">
			以管理员权限打开命令提示符窗口的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法1：在命令提示符窗口中输入命令获得管理员权限。 使用runas命令，切换到Administrators用户组中的用户下 通过命令net localgroup administrators，可以查看Administrators用户组中有哪些用户，比如我这里有_han、Administrators两个 该用户组中的所有用户都有管理员权限，下面以_han用户为例说明 输入： runas /user:_han cmd，然后输入密码。可能遇到的 错误，以及 解决方法，如下： RUNAS 错误: 无法运行 - cmd 1058: 无法启动服务，原因可能是已被禁用或与其相关联的设备没有启动 原因是“Secondary Logo”服务没启动。所以，cmd中输入services.msc后将状态从禁用调为手动即可 方法2：通过“运行” Win+R，输入cmd，按下Ctrl+Shift+Enter 在弹出的询问框中选择“是” 方法3：通过“任务管理器” 打开任务管理器后，按下Alt+F+N 选中“以系统管理权限创建此任务”后，输入cmd，按下回车 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dcb608776367368fc7e772501e50d28/" rel="bookmark">
			Tensorflow2.0入门教程15：CNN网络添加BN层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BN(BatchNormalization)层的作用： 1，加速收敛；
2，控制过拟合，可以少用Dropout或者不用Dropout；
3，降低网络对初始化权重的不敏感；
4，允许使用比较大的学习率。
解决梯度消失与梯度爆炸的问题
1，网络中训练以batch_size为最小单位不断迭代，新的batch_size进入网络，就会产生新的γ与β，在BN层中，有总图片/batch_size组γ与β被保存。2，图像卷积的过程中，通常使用多个卷积核，得到多张特征图，对于多个卷积核需要保存多个γ与β。 基于CNN的花卉识别练习 需要安装的包
pip install opencv-python
import cv2 import os import tensorflow as tf import numpy as np 一、读取数据并进行数据处理 数据集路径—根据自己的路径进行改写
path=r'flower_photos/' 由于我们的数据集图片大小不一致，所以需要resize成统一大小 这里resize成100x100x3
w=100 h=100 c=3 读取数据集图片并添加标签,最后的形式是data 对应图片, label 是标签，roses 0,daisy 1,sunflowers 2,tulips 3,dandelion 4.
def read_img(path): imgs=[] labels=[] cate=[path+x for x in os.listdir(path) if os.path.isdir(path+x)] for idx,i in enumerate(cate): for j in os.listdir(i): im = cv2.imread(i+'/'+j) img = cv2.resize(im, (w, h))/255. imgs.append(img) labels.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dcb608776367368fc7e772501e50d28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7209923f4d3b6737470a963c572c129b/" rel="bookmark">
			SECP256K1签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;secp256k1.h&gt; #include &lt;string&gt; #include &lt;sstream&gt; #include &lt;iomanip&gt; #include &lt;assert.h&gt; #include &lt;openssl/sha.h&gt; //十六进制字符串转字符串, 如 "313233" -&gt; "123" std::string hex2string(const std::string &amp;strHex); //字符串转二进制字符串, 如 "123" -&gt; "313233" std::string string2hex(const std::uint8_t *data, int len); int main() { secp256k1_context *ctx = nullptr; secp256k1_pubkey pubkey; //随机一个256位的私钥 std::uint8_t private_key[] = "18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725"; int pk_size = std::extent&lt;decltype(private_key)&gt;::value; std::cout &lt;&lt; "private key : " &lt;&lt; private_key &lt;&lt; "|" &lt;&lt; pk_size &lt;&lt; std::endl; //创建一个上下文 assert(ctx == nullptr); ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY|SECP256K1_CONTEXT_SIGN); assert(ctx !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7209923f4d3b6737470a963c572c129b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/107/">«</a>
	<span class="pagination__item pagination__item--current">108/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/109/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>