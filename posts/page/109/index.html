<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4bf5849b17a61b51ee20b7a4698552e/" rel="bookmark">
			C语言之 用函数做一个计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码区 #include&lt;stdio.h&gt; float calculate(float a,float b,float d,char c) { switch(c) { case '+':d=a+b;break; case '-':d=a-b;break; case '*':d=a*b;break; case '/':d=a/b;break; default :putchar('\a'); //若运算符号出现错误，则机器以发出声音报错，注意，单撇号不要丢了 } return d; } int main() { float a,b,d,z; char c; printf("what dou you want to calculate\n"); scanf("%f %c %f",&amp;a,&amp;c,&amp;b); z=calculate(a,b,d,c); printf("%f%c%f=%f\n",a,c,b,z); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20fded2463e4cc45443ff0460996273c/" rel="bookmark">
			伪代码书写方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伪代码是描述算法过程的一种语言，它可以直接用中文或者英文等自然语言表示，也可以直接上代码，但常用经典的语法表示(讲的就是这种)。日常生中,别人能通过你的描述明白相应算法就行。
小规范 1、不需要声明变量，变量名可以一定程度反映变量类型。
2、伪代码里没有 “{” “}” ，同一代码块用缩进表示。
3、数组用 数组名 + [0…n-1] 表示，如BubbleSort( A[0…n-1])
4、注释用双斜杠表示： // 5、赋值用箭头表示： ←
6、等于用一个等号表示： =
一、算法名称 算法名+（变量，… ，变量）
1、没有返回值。
2、变量不说明数据类型。
二、if-else语句 if &lt;条件&gt; then
else
if i=0 then a[j]←0; a[k]←0;	//两行都是if语句的代码 else if i&gt;0 then	//else if语句没必要转行 return 0; else return 1; 三、for语句 for 变量←初值 to 终值 do
for i←0 to n-1 do a[i] ← 0; 或者 for i←n to 0 do a[i] ← 0; 四、while语句 while 条件 do
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20fded2463e4cc45443ff0460996273c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a0b96fa70482a4dc4463891accb6e88/" rel="bookmark">
			java8 中Collectors.toMap解决键重复问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例子：
Map&lt;Integer, List&lt;String&gt;&gt; manGroupIdsMap = manualEntries.stream().collect(Collectors.toMap(ManualEntry::getId, manualEntry -&gt; Arrays.stream(StringUtils.split(manualEntry.getGroupInsIds(), ",")) .filter(StringUtils::isNotEmpty).collect(toList()), (List&lt;String&gt; value1, List&lt;String&gt; value2) -&gt; value2)); 分析：
toMap接口：
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction) { return toMap(keyMapper, valueMapper, mergeFunction, HashMap::new); } 参数：
​ 第一个参数为要组成的Map的Key，例如上面例子中用ManualEntry的Id做key；
​ 第二个参数为map的value，例如例子中要生成的value为manualEntry.getGroupInsIds()分割后组成的List的合集
​ 第三个参数则为key重复时处理方法：例子中的处理方式是如果重复，使用value2，即覆盖，也可以做其他处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621e6b4d96c56c5fe7001a4af15f00fc/" rel="bookmark">
			webots与Matlab联合仿真中的错误记录(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 废话使用环境问题叙述问题分析测试继续废话贴上代码关于MATLAB R2019b检索不到的问题 废话 已经很久没有用过了，我的合伙人浑河学者最近要做自动驾驶仿真，我建议他使用webots来进行仿真，但是他想用matlab来写controller，这不，遇到问题了……
使用环境 win10系统webots R2020a rev1 （官方发行版）Matlab R2016a 问题叙述 要开始，请键入以下项之一: helpwin、helpdesk 或 demo。 有关产品信息，请访问 www.mathworks.com。 错误: 文件:D:\Program Files\Webots\lib\controller\matlab\launcher.m 行:29 列:50 输入字符不是 MATLAB 语句或表达式中的有效字符。 》
问题分析 先来看一下为什么会报launcher.m这个文件错误呢？在webots中，matlab调用的webotsAPI实际上是通过c API来实现的，这个调用操作实际上就是通过launcher.m来进行的，并且其中还自动配置了环境变量，省去了我们配环境的繁琐操作。在使用matlab写控制器之前，需要给matlab安装MinGW GCC，因为需要matlab与c的交互。对于安装过程这里不再赘述，但是此处有个坑需要强调一下：
MATLAB官网的安装包在安装的时候需要访问第三方MinGW网站来下载，但是实际上在安装的时候，matlab获取附加功能无法连接第三方网站（不知是否是我的matlab的问题），所以我们需要手动为matlab安装MinGW.
在目录D:\Program Files\Webots\lib\controller\matlab找到launcher.m，发现第29行语法使用双引号""，由于Matlab R2016不支持双引号字符串变量，当然会报错，Matlab R2019中不存在该问题。
手动安装MinGW，程序在附加功能管理里面找不到MinGW列表，所以我们直接屏蔽第28-32行代码即可。
等等，好像哪里不对劲！
这些脚本文件都是在lib\controller\matlab下，为啥launcher.m写的是'/lib/matlab'？此处必有猫腻！！！！
Ctrl+F全部把/lib/matlab替换成/lib/controller/matlab，完美！
注意第15行代码字符串需要改成../../..
save一下，你以为这就结束了？NO，还有一个文件需要修改：allincludes.h
同样的问题，路径对应错误：
继续Ctrl+F替换，保存！OK！！！
测试 相当完美！！！
继续废话 正当我准备去GitHub提交我修改的BUG时，发现已经有大佬在15day前修改过了，我哭了……
链接在这：https://github.com/cyberbotics/webots/pull/1378/files
所以我猜，下一个版本应该会修复这个BUG
贴上代码 launcher.m：
% Launcher script for MATLAB Webots controllers % useful env variables supplied by webots WEBOTS_HOME = getenv('WEBOTS_HOME'); WEBOTS_CONTROLLER_NAME = getenv('WEBOTS_CONTROLLER_NAME'); WEBOTS_VERSION = getenv('WEBOTS_VERSION'); if isempty(WEBOTS_CONTROLLER_NAME) disp('Entering test mode (normally launcher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/621e6b4d96c56c5fe7001a4af15f00fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad69b677b930a8c1e34a8be5f6887610/" rel="bookmark">
			Android Studio安装 含JDK、SDK配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AS安装难点： jdk、sdk环境变量配置；AS安装时要求填写的jdk、sdk文件路径容易出错
一、JDK配置
1、右击 “我的电脑” =&gt; “高级” =&gt; “环境变量”
2、在系统变量里新建系统变量JAVA_HOME
变量名：JAVA_HOME
变量值：C:\xxxx\xxxx\jdk1.8.0_11
注：变量值是jdk安装路径，根据自己的安装路径填写；JAVA_HOME变量指明了jdk的安装路径。
3、在系统变量里新建系统变量CLASSPATH
变量名：CLASSPATH
变量值：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar
注：路径前有一个 “.” ，表示当前路径；变量间用 “;” 隔开；CLASSPATH变量表示Java加载类的路径，该路径与jdk安装路径无关，固定为上面的变量值。
4、在系统变量里新建系统变量path，有Path或path变量就不新建，转而选择该变量=&gt;“编辑”=&gt;“新建”，分别新建图中的两个变量值。
注：也可以将两个变量值合起来写成：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin
路径前无“.”号，但变量间有“;”隔开，但有些电脑这样写有问题；path变量的存在可以让系统在任何路径下识别java和javac命令。
5、查看jdk安装是否成功
调出Windows命令窗口（菜单键+R），输入cmd，回车调查控制台窗口。
在控制台窗口分别输入java,javac,java -version命令，成功如下图，不成功就要查看环境变量配置是否出错。
6、设置完后，把能点的 “确定 ” 按钮都点完，一定要点确定，不点确定他不会应用该设置。 二、SDK配置
1、右击 “我的电脑” =&gt; “高级” =&gt; “环境变量”
2、在系统变量里新建系统变量ANDROID_SDK_HOME
变量名：ANDROID_SDK_HOME
变量值：D:\xxxx\xxxxx\android-sdk-windows
注：变量值为SDK安装路径，一定填精确，很多人会少填一级目录。
对的：D:\SDK\SDK\sdk_android 错的：D:\SDK\SDK (没精确到最近的一级目录) 3、点确定
三、AS安装
由于AS下载版本各不相同，安装界面会有较大区别，大家要根据自己显示的界面进行相应的变化，但主要的是jdk,sdk路径选择问题，基本过程其他教程已经很不错了，我在这想讲一下AS安装完成后常见的问题及解决办法。
1、打开AS显示jdk或sdk路径有问题的解决方法
打开AS后常有两种界面(小界面，大界面)，如图：
针对小界面sdk,jdk路径问题解决办法：
A、找到‘configure’选项，一般在右下角，点击；
B、在弹出界面里，找到‘project default’选项，点击；
C、在弹出界面，点击‘project structure’选项；
D、查看自己JDK，SDK路径是否有问题(AS自己默认的路径是不对的，要填自己安装的路径)
针对大界面的路径问题：（小界面和大界面都是找到project structure选项）
A、找到“File”选项
B、找到“Project Structure”选项
C、查看路径
四、AS安装成功检验（含虚拟机下载）
1、点击屏幕右上角的符号(AVD Manager)
2、点击右下角创建一个新的虚拟机
3、选择合适的手机类型，点击Next
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad69b677b930a8c1e34a8be5f6887610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0f5113df36ab5fe575bcbd56560c05/" rel="bookmark">
			Kotlin集合库的设计总结（部分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、集合的继承关系
Iterable为Kotlin集合库的顶层接口。
每一个集合分为两种，一种为带Mutable前缀的，另一种则是不带的。比如常见的列表分为MutableList和List，List实现了Collection接口，MutableList实现了MutableCollection和 List接口，MutableList表示可变的 List，而List表示只读List。其实Kotlin集合都是以 Java的集合库为基础来构建的，只是Kotlin通过扩展函数增强了它。
Kotlin中集合到继承关系如下图：
1.List
List表示一个有序的可重复的列表，其中元素的存储方式是线性存储的，以保证元素的有序性，另外，List中的元素是可以重复的。
fun main() { val listOf = listOf&lt;Int&gt;(1, 2, 3, 4, 4, 3, 3, 6) println(listOf) } 2.Set
Set表示一个不可重复的集合。Set常用的具体实现方式有两种，分别为HashSet和TreeSet。HashSet是用散列来存放数据的，不能保证元素的有序性。而TreeSet的底层结构是二叉树，它能保证元素的有序性。在不指定Set的具体实现时，一般说Set是无序的。Set中的元素不能重复。
fun main() { val set = setOf&lt;Int&gt;(1, 2, 3, 4, 4, 5) println(set)//Set会将重复的元素过滤掉 } [1, 2, 3, 4, 5] 3.Map
Kotlin中的Map与其他集合有点不同，它没有实现Iterable或者Collection。Map用来表示键值对元素集合。
val mapOf = mapOf(1 to 1, 2 to 2, 3 to 3) println(mapOf) {1=1, 2=2, 3=3} 注意了：Map 中的键值对，键是不能重复的。
二、可变集合与只读集合
1.1可变集合
可以改变的集合，可变集合都有一个前缀修饰——“Mutable”，比如MutableList。这里的改变是指集合中的元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe0f5113df36ab5fe575bcbd56560c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/929d565bf02a8244c22fbc968cda3703/" rel="bookmark">
			求因子和（函数专题）， 输入正整数n（2大于n小于1000），计算并输出n的所有正因子(包括1，不包括自身)之和。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
输入正整数n（2&lt;=n&lt;=1000），计算并输出n的所有正因子(包括1，不包括自身)之和。要求程序定义一个FacSum ()函数和一个main()函数，FacSum ()函数计算并返回n的所有正因子之和，其余功能在main()函数中实现。
int FacSum(int n)
{
//计算n的所有正因子(包括1，不包括自身)之和sum，本函数返回sum
}
输入
输入正整数n（2&lt;=n&lt;=1000）。
输出
输出n的所有正因子(不包括自身)之和。
样例输入
1000
样例输出
1340
代码一 # include&lt;stdio.h&gt; # include&lt;math.h&gt; int FacSum(int x) //求因数的和 { int sum=1,m=2; while(m&lt;=sqrt(x)) { if(x%m==0&amp;&amp;m!=x/m)sum=sum+m+x/m; if(m==x/m) sum=sum+m; m++; } return sum; } int main() { int x; scanf("%d",&amp;x); printf("%d",FacSum(x)); return 0; } 缺点：该代码求解正因数的范围较小，大于1000则容易出错，求解麻烦，但用于本题也可以。
代码二 # include&lt;stdio.h&gt; int FacSum(int x) //求因数的和 { int sum=1,m=2; while(m&lt;x) { if(x%m==0)sum+=sum; m++; } return sum; } int main() { int x; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/929d565bf02a8244c22fbc968cda3703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13a9a2d9e68a408152d907ceae02ec9/" rel="bookmark">
			vue给对象新增属性，页面不更新解决方法——四种方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：点击按钮，向一个对象新增name属性，希望页面也能显示出来新增的name 代码：
&lt;div id="app"&gt; {{obj}} &lt;div @click="add"&gt;新增name属性&lt;/div&gt; &lt;/div&gt;	&lt;script&gt; new Vue({ el:'#app', data(){ return { obj:{ id:1 } } }, methods:{ add(){ this.obj.name = 'xpf' console.log(this.obj) } }, }) &lt;/script&gt; 页面效果：
原因：
可以看到页面中并没有自动更新新增的name属性，但是，在控制台可以打印出来
当vue的data里边声明或者已经赋值过的对象或者数组（数组里边的值是对象）时，向对象中添加新的属性，如果更新此属性的值，是不会更新视图的。
方法一：使用Vue.set( target , key , value) target: 要更改的数据源（可以是一个对象或者数组）key 要更改的具体数据 （索引）value 重新赋的值 代码：
&lt;div id="app"&gt; {{obj}} &lt;div @click="add"&gt;新增name属性&lt;/div&gt; &lt;/div&gt;	&lt;script&gt; new Vue({ el:'#app', data(){ return { obj:{ id:1 } } }, methods:{ add(){ this.$set(this.obj,'name','xpf') console.log(this.obj) } }, }) &lt;/script&gt; 页面效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13a9a2d9e68a408152d907ceae02ec9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ac6d101399cedbddd7e2a08794d60a/" rel="bookmark">
			C语言指向函数的指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义形式：类型 （*指针变量名）（参数列表）;
例如：int (*p)(int i,int j);
在这里 int是函数的返回类型，*p是指向函数的指针，(int i,int j);是函数的参数
注意 ： int f(int i, int j);
int (p)(int i, int j);
前者是返回值是指针的函数；后者是一个指向函数的指针。
示例1 #include &lt;stdio.h&gt; #define GET_MAX 0 #define GET_MIN 1 int get_max(int i,int j) { return i&gt;j?i:j; } int get_min(int i,int j) { return i&gt;j?j:i; } int compare(int i,int j,int flag) { int ret; //这里定义了一个函数指针，就可以根据传入的flag，灵活地决定其是指向求大数或求小数的函数 //便于方便灵活地调用各类函数 int (*p)(int,int); if(flag == GET_MAX) { p = get_max; }else{ p = get_min; } ret = p(i,j);//或者ret = (*p)(i,j); return ret; } int main() { int i = 5,j = 10,ret; ret = compare(i,j,GET_MAX); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ac6d101399cedbddd7e2a08794d60a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c50cb3d5340ed78455ac4abdf02afa/" rel="bookmark">
			for循环中的switch的break和continue作用范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for循环中的switch的break和continue作用范围 不空泛的讲理论了，上代码。看下面这个代码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main () { char str[] = "SSSWLLIJKA"; char c; int k; for(k=2;(c=str[k]) != '\0';k++) { switch(c) { case 'I' :++k;break;//跳出switch，执行for循环内switch外的其他语句 case 'L' :continue; default:putchar(c);continue; } putchar('*'); } return 0; } 我们再看一下运行结果：
SW*KA
在这里我们可以看出这里的break的作用仅仅对switch有作用，并没有跳出for循环。而continue的作用域包含for循环内的其他语句。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/724991831b88a7e95801d6ee106d67f0/" rel="bookmark">
			UML之用例图(use case)箭头方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Association，无箭头，Actor连接UseCase即可；
2、DirectedAssocition，Actor连接UseCase，箭头由Actor指向UseCase（角色指向用例）；
3、Generalization，继承，我把它念成“继承于”，当然是箭头由子指向父啦； 4、Dependency，我念成“依赖于”，就知道箭头方向了；
5、Include，我念成“包含了”，箭头由包含者指向被包含者； 6、Extend，我念成“扩展于”或“扩展自”，箭头由扩展出来的“子”指向它的“父”； 总结：除了包含方向外，其它都是“小”的指向“大”的，“子”指向“父”，“一般”指向“抽象”。
UML中描述对象和类之间相互关系的方式包括：依赖（Dependency），关联（Association），聚合（Aggregation），组合（Composition），泛化（Generalization），实现（Realization）等。
依赖（Dependency）：元素A的变化会影响元素B，但反之不成立，那么B和A的关系是依赖关系，B依赖A；类属关系和实现关系在语义上讲也是依赖关系，但由于其有更特殊的用途，所以被单独描述。uml中用带箭头的虚线表示Dependency关系，箭头指向被依赖元素。泛化（Generalization）：通常所说的继承（特殊个体 is kind of 一般个体）关系，不必多解释了。uml中用带空心箭头的实线线表示Generalization关系，箭头指向一般个体。实现（Realize）：元素A定义一个约定，元素B实现这个约定，则B和A的关系是Realize，B realize A。这个关系最常用于接口。uml中用空心箭头和虚线表示Realize关系，箭头指向定义约定的元素。关联（Association）：元素间的结构化关系，是一种弱关系，被关联的元素间通常可以被独立的考虑。uml中用实线表示Association关系，箭头指向被依赖元素。聚合（Aggregation）：关联关系的一种特例，表示部分和整体（整体 has a 部分）的关系。uml中用带空心菱形头的实线表示Aggregation关系，菱形头指向整体。组合（Composition）：组合是聚合关系的变种，表示元素间更强的组合关系。如果是组合关系，如果整体被破坏则个体一定会被破坏，而聚合的个体则可能是被多个整体所共享的，不一定会随着某个整体的破坏而被破坏。uml中用带实心菱形头的实线表示Composition关系，菱形头指向整体。 1.1.1 依赖（Dependency）:虚线箭头表示 1、依赖关系也是类与类之间的联结
2、依赖总是单向的。（#add 注意，要避免双向依赖。一般来说，不应该存在双向依赖。）
3、依赖关系在 Java 或 C++ 语言中体现为局部变量、方法的参数或者对静态方法的调用。
（软件开发中，往往会设计一些公用类，供别的类调用，如果这些公用类出问题了，那调用这些公用类的类都会因此而出问题。 两个元素之间的一种关系，其中一个元素（提供者)的变化将影响另一个元素（客体)，或向它提供所需信息
显示一个类引用另一个类）
方法参数示例：
public class Person { void buy(Car car) { ... } } 表示方法：虚线加箭头
特点：当类与类之间有使用关系时就属于依赖关系，不同于关联关系，依赖不具有“拥有关系”，而是一种“相识关系”，只在某个特定地方（比如某个方法体内）才有关系。
依赖关系可以分为以下四类：
1） 使用依赖（Usage）表示客户使用提供者提供的服务以实现它的行为，包括：
使用&lt;&lt;use&gt;&gt;--声明使用一个类时需要用到已存在的另一个类。调用&lt;&lt;call&gt;&gt;--声明一个类调用其他类的操作的方法。参数&lt;&lt;parameter&gt;&gt;--声明一个操作和它的参数之间的关系。发送&lt;&lt;send&gt;&gt;--声明信号发送者和信号接收者之间的关系。实例化&lt;&lt;instantiate&gt;&gt;--声明用一个类的方法创建了另一个类的实例。 2） 抽象依赖（Abstraction）表示客户与提供者之间用不同的方法表现同一个概念，通常一个概念更抽象，一个概念更具体。包括：
跟踪&lt;&lt;trace&gt;&gt;--声明不同模型中的元素之间存在一些连接但不如映射精确。精化&lt;&lt;refine&gt;&gt;--声明具有两个不同语义层次上的元素之间的映射。派生&lt;&lt;derive&gt;&gt;--声明一个实例可以从另一个实例导出。 3） 授权依赖（Permission）表达提供者为客户提供某种权限以访问其内容的情形。包括：
访问&lt;&lt;access&gt;&gt;--允许一个包访问另一个包的内容。导入&lt;&lt;import&gt;&gt;--允许一个包访问另一个包的内容并为被访问包的组成部分增加别名。友元&lt;&lt;friend&gt;&gt;--允许一个元素访问另一个元素，不管被访问的元素是否具有可见性。 4） 绑定依赖（Binding）较高级的依赖类型，用于绑定模板以创建新的模型元素，包括：
绑定&lt;&lt;bind&gt;&gt;--为模板参数指定值，以生成一个新的模型元素。 1.1.2 关联（Association）：实线箭头表示 1、关联关系是类与类之间的联结，它使一个类知道另一个类的属性和方法。
2、关联可以是双向的，也可以是单向的（#add还有自身关联）。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。
3、在 Java 或 c++ 中，关联关系是通过使用成员变量来实现的。
public class 徒弟 { } public class 唐僧 { protected: list&lt;徒弟&gt; tdlist; } 表示方法：实线箭头
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/724991831b88a7e95801d6ee106d67f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e9faf3ed90f7c6a2537fff6d13786dc/" rel="bookmark">
			error: Your local changes to the following files would be overwritten by merge 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 团队其他成员修改了某文件并已提交入库，你在pull之前修改了本地该文件，等你修改完代码再pull时，这时会报错如下错误：
error: Your local changes to the following files would be overwritten by merge
二、解决方案 根据是否要保存本地修改，有以下两种解决方案
2.1 保留修改 执行以下三条命令
git stash #封存修改 git pull origin master git stash pop #把修改还原 注：
git stash：备份当前工作区内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前工作区内容保存到Git栈中git pull：拉取服务器上当前分支代码git stash pop：从Git栈中读取最近一次保存的内容，恢复工作区相关内容。同时，用户可能进行多次stash操作，需要保证后stash的最先被取到，所以用栈（先进后出）来管理；pop取栈顶的内容并恢复git stash list：显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。git stash clear：清空Git栈 2.2 废弃修改 核心思想就是版本回退，具体命令如下
git reset --hard git pull origin master 注：不建议使用第二种。除非你再三确定不需要本地的修改了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f884c34f9ba385d3b506ce2808b433/" rel="bookmark">
			nginx服务无法停止 任务管理器中自动启动nginx服务（Windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日本小白程序员 使用nginx 发现开启后 无法关闭 来分享解决方案
1. 命令 关闭 nginx.exe -s stop 或 nginx.exe -s quit , stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。
D:\java\nginx-1.16.1\nginx-1.16.1&gt;nginx.exe -s stop 或 D:\java\nginx-1.16.1\nginx-1.16.1&gt;nginx.exe -s quit 可能结果 会发现服务 还在 即使手动结束任务 会自动启动 访问127.0.0.1 依然可以显示 nginx页面
nginx服务没有启动 所以nginx服务停止报错 很神奇嘛！
2. 放大招 在cmd 输入命令 netstat -ano 找到nginx监听端口的pid 我的是第一个0.0.0.0:80 pid为3192
tasklist|findstr “PID” 找到nginx.exe 服务
确实有nginx服务在运行 通过cmd命令 taskkill /f /t /im nginx.exe 结束进程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66605ed428deb497155d80146a90fa83/" rel="bookmark">
			高数-不定积分--凑积分（第一类换元法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定理
步骤：
----------------------------------------------------习题-----------------------
1、
2、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f986c28791cae50f02b55af971132b/" rel="bookmark">
			【Android NDK 开发】Android Studio 使用 CMake 导入动态库 ( 构建脚本路径配置 | 指定动态库查找路径 | 链接动态库 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 I . CMake 引入动态库与静态库区别II . Android Studio 中 CMake 引入动态库流程III . 指定动态库查找路径IV . 链接函数库V . 完整代码示例1 . Module 级别的 build.gradle 完整配置代码2 . CMakeList.txt 完整配置代码3 . Java 层代码4 . C++ 层代码5 . 运行结果 VI . 博客资源 参考博客 : 【Android NDK 开发】Android Studio 使用 CMake 导入静态库 ( CMake 简介 | 构建脚本路径配置 | 引入静态库 | 指定静态库路径 | 链接动态库 )
I . CMake 引入动态库与静态库区别 1 . CMake 引入静态库 : 使用 add_library() 导入静态库 , set_target_properties() 设置静态库路径 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f986c28791cae50f02b55af971132b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c96ba3d91609119c4e197998a6439f3a/" rel="bookmark">
			算法 --- 阿克曼(Ackmann)函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.定义
阿克曼函数(Ackermann)是非原始递归函数的例子。它需要两个自然数作为输入值，输出一个自然数。它的输出值增长速度非常高，仅是对于(4,3)的输出已大得不能准确计算。
​Ackermann函数定义如下：
若m=0，返回n+1。
若m&gt;0且n=0，返回Ackermann(m-1,1)。
若m&gt;0且n&gt;0，返回Ackermann(m-1,Ackermann(m,n-1))。
2.Java源码
public class Test { public static void main(String[] args) throws Exception { Scanner scanner = new Scanner(System.in); int m = scanner.nextInt(); int n = scanner.nextInt(); if (m &gt;= 0 &amp;&amp; n &gt;= 0) { System.out.println(ackmann(m,n)); } } private static int ackmann (int m, int n) { if (m == 0) return n+1; if (m &gt; 0 &amp;&amp; n == 0) return ackmann(m-1,1); return ackmann(m-1,ackmann(m,n-1)); } } 输入： 2 3 结果： 9 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fdb28e4f0beb35303a10885f7464241/" rel="bookmark">
			Rabbitmq报错pika.exceptions.IncompatibleProtocolError: StreamLostError: (&#39;Transport indicated EOF&#39;,)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 rabbitmq 报错 pika.exceptions.IncompatibleProtocolError: StreamLostError: (‘Transport indicated EOF’,)解决办法 产生此报错的原因是我将port写成了15672 port = 15672 rabbitmq需要通过端口5672连接 - 而不是15672.更改端口，转发，一切正常 port = 5672 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37485d44c3b749db5f368b9edc6235c4/" rel="bookmark">
			【Android NDK 开发】NDK 交叉编译 ( Ubuntu 中交叉编译动态库 | Android Studio 中配置使用第三方动态库 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 I . 动态库 与 静态库II . 编译动态库III. Android Studio 使用第三方动态库IV . Android Studio 关键代码V . 博客资源 I . 动态库 与 静态库 1 . 函数库分类 : ① 动态库 , ② 静态库 ;
2 . 静态库 :
编译链接时 , 将整个库文件打包到可执行文件中 , 造成可执行文件较大 , 但运行时不需要库文件 ;
Android 与 Linux 静态库 后缀为 “.a” ;
3 . 动态库 :
编译链接时 , 不将库打包入可执行文件中 , 在程序运行时调用到该库时才链接加载该动态库 ;
Android 与 Linux 静态库 后缀为 “.so” ;
4 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37485d44c3b749db5f368b9edc6235c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9d15ad978572c06a3a1f0e73510af4/" rel="bookmark">
			LaTeX写UESTC毕业论文遇到的问题集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先推荐latex编写论文的两个实用工具: 在线公式编辑器：http://latex.codecogs.com/eqneditor/editor.php
Latex表格生成器：https://tablesgenerator.com/
1、问题一：插入子图的时候报Undefined control sequence错误 注意：插入图片使用figure环境，自动调整图片前后的间距，添加子图则使用\subfloat命令，而不是\subfigure。若子图过多需要跨页则在间断处插入\floatcontinue命令。这是一段插入子图的代码：
\begin{figure}[htb] \setlength{\abovecaptionskip}{0pt} \setlength{\belowcaptionskip}{0pt} \centering \subfloat[Foursquare]{ \includegraphics[width=6.6cm]{Foursquare.pdf}}\hspace{0.3cm} \label{F_D_o} \subfloat[Gowalla]{ \includegraphics[width=6.6cm]{Gowalla.pdf}}\hspace{0.3cm} \label{G_D_o} \subfloat[Yelp]{ \includegraphics[width=6.6cm]{Yelp.pdf}} \label{Y_D_o} \caption{维度$D$对三个数据集的性能影响} \label{E-D} \end{figure} 运行代码显示结果如左图所示，如果发现运行出来的结果中子图的小标题不在对应子图的正下方，则需要调整一下代码中的[width]参数，改变参数大小直至合适。
解决方案：
(1)可能情况一：出现以上错误的时候，考虑使用的tex版本太低，因为subfloat所在的subcaption包要求版本比较新。
官方下载网址：http://www.tug.org/texlive/
清华大学镜像： https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/
安装过程参考：https://blog.csdn.net/qq_28966711/article/details/104246494
UESTC毕业论文最新模板下载：https://x-magus.github.io/ThesisUESTC/
(2)可能情况二：检查thesis-uestc.cls文件中是否存在\RequirePackage[labelformat=simple]{subcaption}[2019/09/10]这个代码，将其改成\RequirePackage[labelformat=simple]{subfig}即可。
2、问题二：在Linux下编译UESTC毕业论文模板出现找不到字体的情况 解决方法1：terminal中用apt-get安装全部字体就可以了
解决方法2：将windows中的字体文件全部拷过去，具体保存路径自行百度。
3、问题三：在texstudio中编译tex文件不显示攻读硕士学位期间取得的成果 解决方案：成果的显示需要命令行进行手动编译。使用BibTeX录入参考文献需要先运行一次xelatex，运行一次bibtex，再运行两次xelatex。使用BibTeX录入攻读学位期间的研究成果的情况下还需要额外运行一次bibtex accomplish.aux。完整编译包含两个BibTeX文献列表。
首先将命令行工作目录切换到项目文件夹下，依次执行以下命令：
xelatex main.tex bibtex main.aux bibtex accomplish.aux xelatex main.tex xelatex main.tex 注意：自行修改.tex的文件名，编译多文件结构的文档将main.tex替换成main_multifile.tex。 4、Latex中图表浮动怎么处理（如何让图表放在想放的位置） 解决方法：在\begin{figure}后面加一个[htb]，表格类似\begin{table}[htb]。
注意：图表的位置必须在一段话结束或者开始的位置（英文论文似乎不太管图表具体出现的位置），否则会被答辩老师怼的很惨（亲测被怼）~
5、封面中的日期如何添加 如：封面中的论文提交日期以及答辩日期
解决方案：在latex中打开thesis-uestc.cls文件，找到对应位置直接添加就可以了。如下图：
6、提交到图书馆版本中的pdf版本如何去掉空白页 按照要求提交到图书馆系统里面的版本是不能有空白页的，而latex生成的pdf中考虑到奇偶页问题会自动补充空白页，这也便于后期打印纸质版本的论文。
解决方案：在提交到图书馆之前你需要将你的论文pdf中的空白页去掉，不是试图往latex里面加各种各样的命令行去解决空白页的问题，直接WPS office打开PDF文件，点击编辑——&gt;删除空白页就可以了。
7、独创性声明中个人与导师的电子签名如何放进去 解决方案：首先自己用word编辑好独创性声明然后装换成PDF版本文件（我将其命名为：cover.pdf）。
将cover.pdf文件放到与main.tex（main_multifile.tex）同一路径下。用latex打开main.tex（main_multifile.tex）之后找到用语句\bindpdfcover{cover.pdf}将其插入到\makecover后面即可，如下：
\documentclass[master]{thesis-uestc} \title{这是我的论文题目}{The Research on} \author{大漠}{Big mo} \advisor{张三\chinesespace 教授}{Dr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f9d15ad978572c06a3a1f0e73510af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aedec24a48db7feccd2e3f8351a08c51/" rel="bookmark">
			用LaTeX写毕业论文-UESTC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境：Texlive + TeXstudio
1、下载安装Texlive
使用官网的镜像下载，也可以利用国内的镜像下载。
官方下载网址: http://www.tug.org/texlive/
进入官网后，按以下操作进行：
官网下载速度特别慢，建议使用清华大学镜像文件 https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/
（2）安装Texlive
将texlive2019.iso 文件进行解压，然后双击打开其中的install-tl-advanced.bat文件。
安装完成之后，Win+R调出终端框命令行输入tex -version，出现TEX的版本则说明安装成功。
3、安装LaTex的编辑器TeXstudio。
直接去官网下载官网地址：https://www.texstudio.org/
官网下载的比较慢，建议自己找网盘资源。下载完.exe文件，然后进行傻瓜式安装。
（1）设置中文界面
依次点击：Options—&gt; Configure Texstudio —&gt; General—&gt; Language—&gt; zh_CN
（2）设置编译器与编码
4、下载UESTC毕业论文模板
下载地址：https://x-magus.github.io/ThesisUESTC/
5、将下载的模板解压导入Texstudio，按F5查看，F6编译，就是下图的两个绿色箭头。。。。。。
好了，开始愉快的写毕业论文吧！！！
大吉大利！毕业顺利！ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/108/">«</a>
	<span class="pagination__item pagination__item--current">109/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/110/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>