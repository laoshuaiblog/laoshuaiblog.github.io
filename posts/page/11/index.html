<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f98545a8d195bf6296b27f5d1417c29/" rel="bookmark">
			【力扣】409.最长回文串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。
在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。
示例 1:
输入：s = “abccccdd”
输出：7
解释：
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
示例 2:
输入：s = “a”
输出：1
示例 3：
输入：s = “aaaaaccc”
输出：7
提示:
1 &lt;= s.length &lt;= 2000s 只由小写 和/或 大写英文字母组成 解题方法 C 哈希数组 int longestPalindrome(char* s) { int alphabet[52] = {0}; int result = 0; int i = 0; int flag = 0; for (i = 0; i &lt; strlen(s); i++) { if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') { alphabet[s[i] - 'a']++; } if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') { alphabet[s[i] - 'A' + 26]++; } } for (i = 0; i &lt; 52; i++) { if (alphabet[i] % 2 == 0) { result += alphabet[i]; } if (alphabet[i] % 2 == 1) { result += alphabet[i] - 1; flag = 1; } } return result + flag; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1dde45bb8b7bfd055f3bc98257d258b/" rel="bookmark">
			数据结构-＞手把手教入门栈与列队（基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉
🍎个人主页：橘橙黄又青-CSDN博客
1.什么是栈 1.1栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除 操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out） 的原则。 压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 出栈：栈的删除操作叫做出栈。出数据也在栈顶。
这种结构类似于弹夹：遵守后进先出的原则
1.2栈的实现 栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上 插入数据的代价比较小。
2.栈的实现 这里我们讲解数组（顺序表）实现
2.1栈的初始化和销毁 这里顺序表一样，a是数组，free是释放一块连续的空间。
2.2栈的节点创建 这里注意的是创建后，记得top++；
2.3出栈和返回栈顶元素 2.4返回栈的数据个数和判断栈为空 2.5测试代码： 这里我们讲一个点，我们只创建一个栈Stack s，如果要创建两个栈，最好使用结构体包装起来，比如说：
这样就可以直接创建两个顺序表了。
3.什么是列队 3.1队列的概念及结构 列队列队其实可以理解为排队
队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先 进先出FIFO(First In First Out) 入队列：进行插入操作的一端称为队尾 出队列：进行删除操作的一 端称为队头。
4.列队的实现 队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构， 出队列在数组头上出数据，效率会比较低。
所以我们选择链表实现。
4.1列队初始化和销毁 4.2入队列 4.3出队列 出队列是链表的头删操作。
4.4找到列队头尾 4.5列队判断为空和数据个数 5.代码 5.1列队代码： Queue.h
#pragma once #include&lt;stdlib.h&gt; #include&lt;stdbool.h&gt; #include&lt;assert.h&gt; typedef int QDataType; typedef struct QueueNode { int val; struct QueueNode* next; }QNode; 入队列 //void QueuePush(QNode** pphead, QNode** pptail); 出队列 //void QueuePop(QNode** pphead, QNode** pptail); typedef struct Queue { QNode* phead; QNode* ptail; int size; }Queue; //初始化 void QueueInit(Queue* pq); //列队销毁 void QueueDestroy(Queue* pq); // 入队列 void QueuePush(Queue* pq, QDataType x); // 出队列 void QueuePop(Queue* pq); //列队前 QDataType QueueFront(Queue* pq); //列队尾 QDataType QueueBack(Queue* pq); //判断是否为空 bool QueueEmpty(Queue* pq); //数据个数 int QueueSize(Queue* pq); Queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1dde45bb8b7bfd055f3bc98257d258b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477cad924d8f5de0bd9c5163031d0a4a/" rel="bookmark">
			apache2.4设置完一个VirtualHost后，所有的域名和IP地址都变成访问这个VirtualHost的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apache2.4设置完一个VirtualHost（如www.example.com）后，所有的域名（如localhost）和IP地址都变成访问这个VirtualHost。
默认的DocumentRoot /var/www/html无效了。
解决办法：在/etc/httpd/conf.d/（或/etc/apache2/sites-enabled）下新建一个_first.conf（一定要好好起文件名，比如以下划线开头，使此文件为当前目录下的第一个文件），内容如下：
&lt;VirtualHost *:80&gt; DocumentRoot /var/www/html &lt;/VirtualHost&gt; &lt;VirtualHost *:443&gt; SSLEngine on SSLCertificateFile xxx.com.crt SSLCertificateKeyFile xxx.com.key SSLCertificateChainFile xxx.com.ca-bundle DocumentRoot /var/www/html &lt;/VirtualHost&gt; 然后重启apache服务器即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c775b29d04f9926183c7d6c60c3b776/" rel="bookmark">
			【协议-ICMP】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ping命令底层使用的是ICMP，ICMP报文封装在ip包里。它是一个对IP协议的补充协议，允许主机或路由器报告差错情况和异常状况。ICMP使用时必须增加IP报头。
通常ICMP隧道技术采用ICMP的ICMP_ECHO和ICMP_ECHOREPLY两种报文，把数据隐藏在ICMP数据包包头的选项域中，利用ping命令建立隐蔽通道。
下面是ping数据包的IP数据报格式：
icmp隧道通信特征
1.请求和回应部分数据不一致。正常的icmp数据包里，请求和回应部分数据是一致的。
2.同一时间内大量的icmp数据包。
3.ICMP隧道 数据包中DATA 往往大于 64 比特
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704026cfa018700e29ef0d0a537846e9/" rel="bookmark">
			Cisco Catalyst3850交换机RTU license使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 情况说明 客户处采购了4台3850-14T交换机，在配置的时候发现OSPF不支持，
查询原因为当前license不支持 (lanbase, 只能支持2层功能）
报错如下：
Access-3850-1(config)#router ospf 100 Protocol not in this image 2 如何处理？ 开启RTU license，加载ip service类型的license
开启RTU License后正常。如下图：
Access-3850-1(config)#router ospf 100 Access-3850-1(config-router)# 3 扫盲： 啥是RTU license What is RTU License ? A Right to Use license scheme is an honor-based model for licensing. Licenses are not tied to an unique device identifier (UDI), product ID, or serial number.
看到上面所说的了吗？ honor-based model ，说人话就是你应该购买license，但你可以直接使用。不买就用的就是臭不要脸。
我的理解，实际上就是cisco为了简化license安装和加载，以前的交换机或路由器上要加载license需要几步：
购买了license后，登录cisco.com官网输入license信封上的key，并输入交换机的SN进行绑定，—&gt;生成license文件—&gt;下载下来通过install license命令进行安装 现在不需要这么繁琐了，可以直接加载使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704026cfa018700e29ef0d0a537846e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c3e94628aafd92cc9a966c258621ce9/" rel="bookmark">
			【PHP &#43; 代码审计】数组函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍬 博主介绍 👨‍🎓 博主介绍：大家好，我是 hacker-routing ，很高兴认识大家~ ✨主攻领域：【渗透领域】【应急响应】 【Java、PHP】 【VulnHub靶场复现】【面试分析】 🎉点赞➕评论➕收藏 == 养成习惯（一键三连）😋 🎉欢迎关注💗一起学习👍一起讨论⭐️一起进步📝文末有彩蛋 🙏作者水平有限，欢迎各位大佬指点，相互学习进步！ 目录
数组的相关函数
编程思想
递推算法
递归算法
数组的相关函数 1）排序函数：对数组元素进行排序，都是按照ASCII码进行比较，可以进行英文比较
sort()：顺序排序（下标重排）
rsort()：逆序排序
asort()：顺序排序（下标保留）
arsort()：逆序排序
ksort()：顺序排序：按照键名（下标）
krsort()：逆序排序
shuffle()：随机打乱数组元素，数组下标会重排
2）指针函数
reset()：重置指针，将数组指针回到首位
end()：重置指针，将数组指针指导最后一个元素
next()：指针下移，取得下一个元素的值
prev()：指针上移，取得上一个元素的值
注意事项：next和prev会移动指针，有可能导致指针移动到最前或者最后（离开数组），导致数组不能使用，通过next和prev不能回到真确的指针位置。只能通过end或者reset进行指针重置
3）其他函数
count()：统计数组中元素的数量
array_push()：往数组中加入一个元素（数组后面）
array_pop()：从数组中取出一个元素（数组后面）
array_shift()：从数组中取出一个元素（数组前面）
array_unshift()：从数组中加入一个元素（数组前面）
PHP模拟数据结构：
栈：压栈，先进去后出来（FILO）
编程思想 编程思想：如何利用数学模式，来解决对应的需求问题；然后利用代码实现对应的数据模型（逻辑）。
算法：使用代码实现对应的数学模型，从而解决对应的业务问题。
递推算法 递推算法是一种简单的算法，即通过已知条件，利用特定关系得出中间推论，直至得到结果的算法。递推算法分为顺推和逆推两种。
顺推：通过最简单的条件（已知），然后逐步推演结果
逆推：通过结果找到规律，然后推到已知条件
斐波那契数列：1 1 2 3 5 8 13 …，通常需求：请求得指定位置N所对应的值是多少
找规律：
1、 第一个数是1
2、 第二个数也是1
3、 从第三位开始：属于前两个数的和
代码解决思路：
1、 如果数字位置为1和2，结果都是1
2、 从第三个开始，想办法得到前两个的结果，就可以得到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c3e94628aafd92cc9a966c258621ce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63875d367be9934ae07c30551b796e85/" rel="bookmark">
			Day18:LeedCode 513.找树左下角的值 112. 路径总和 106.从中序与后序遍历序列构造二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		513. 找树左下角的值
给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。
假设二叉树中至少有一个节点。
示例 1:
输入: root = [2,1,3] 输出: 1 思路:出该二叉树的 最底层 最左边 节点的值=找出深度最大的第一个结点(左结点先遍历)
方法一:递归法
如何找出深度最大的结点:回溯法,设置两个全局遍历maxlen,result记录最长深度,结果
图解:
递归三部曲:
1.确定返回值和参数的类型
用一个全局变量记录最长深度,result记录结果,递归函数无返回值,参数为int len(当前深度),和传入结点TreeNode cur;
2.确认终止条件:
我们采用左优先遍历 ,遇到叶节点则return,如果该叶节点是深度更大的结点,则更新result;
3.单层递归逻辑:
用回溯法计算每个结点的深度
代码参考:
class Solution { int maxlen=-1; int result=0; public int findBottomLeftValue(TreeNode root) { //本题结点个数至少为1个 travelsal(root,1); return result; } void travelsal(TreeNode cur,int len){ // if(root==null)return; if(cur.left==null&amp;&amp;cur.right==null){ if(len&gt;maxlen){//找到第一个深度更大的结点则更新result result=cur.val; maxlen=len; } return; } if(cur.left!=null){travelsal(cur.left,len+1);}//回溯,下一结点深度+1 //本节点深度不变 if(cur.right!=null){travelsal(cur.right,len+1);}//回溯,下一结点深度+1 } } 方法二:迭代法,层序遍历找到最后一排的第一个结点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63875d367be9934ae07c30551b796e85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/669a05b18da24116f8d6e2bb09d8e39e/" rel="bookmark">
			【C语言】预处理&amp;&amp;编译链接&amp;&amp;调试技巧详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主页：醋溜马桶圈-CSDN博客
专栏：C语言_醋溜马桶圈的博客-CSDN博客
gitee：mnxcc (mnxcc) - Gitee.com
目录
1.预处理
1.1 预定义符号
1.2 #define
1.2.1 #define 定义标识符
1.2.2 #define 定义宏
1.2.3 #define 替换规则
1.2.4 #和##
1.2.4.1 # 的作用
1.2.4.2 ## 的作用 1.2.5 带有副作用的宏参数
1.2.6 宏和函数的对比 对比
1.2.7 内联函数 1.2.8 命名约定 1.3 #undef
1.4 命令行定义 1.5 条件编译
1.5.1 常见的条件编译指令
1.6 头文件包含
1.6.1 头文件被包含的方式
1.6.2 嵌套文件的包含
2.程序环境 编译和链接
2.1 翻译环境和执行环境
2.2 编译和链接
2.3 翻译
2.3.1 翻译的几个阶段
2.3.1.1 预编译
2.3.1.2 编译
词法分析
符号汇总
2.3.1.3 汇编
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/669a05b18da24116f8d6e2bb09d8e39e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e7359e43545df53f4c81965cc719f7/" rel="bookmark">
			数据结构——二叉树-堆(堆的实现，堆排序，TopK问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.树的概念及结构
1.1 树的概念
1.2 树的相关概念
1.3 树的表示
2. 二叉树的概念及结构
2.1概念
2.2 特殊的二叉树
2.3 二叉树的性质
2.4 二叉树的存储结构
3. 堆
3.1 堆的概念及结构
3.2 堆的实现
3.1.2 数据结构的设计和文件准备
3.1.2堆的初始化和销毁
3.1.3 向下调整算法与向上调整算法
3.1.4 堆的插入和堆的删除
3.1.5 获取堆顶元素和堆的数据个数，堆的判空
3.3 建堆
4. 堆的应用
4.1 堆排序
4.1.2 思路
4.2.2 代码
4.1.3 时间复杂度的分析
4.2 TopK问题
4.2.1思路
4.2.2 代码实现
总结
前言 这篇文章介绍二叉树中的特殊的数据结构堆，堆的应用有堆排序和TopK问题。有详细的图文讲解，可以边看边敲，一起学起来吧！
1.树的概念及结构 1.1 树的概念 树是一种数据结构，它是由n(n≥0)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特定的节点被称为根节点或树根（root）。除根节点之外的其余数据元素被分为个互不相交的集合，其中每一个集合本身也是一棵树，被称作原树的子树（subtree）。树是递归定义的。 1.2 树的相关概念 我们以上面这颗树为例：
节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6
叶节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e7359e43545df53f4c81965cc719f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a8d3791cf10e3dcbf48a1ef858a404f/" rel="bookmark">
			AI大模型学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当前技术环境下，AI大模型学习不仅要求研究者具备深厚的数学基础和编程能力，还需要对特定领域的业务场景有深入的了解。通过不断优化模型结构和算法，AI大模型学习能够不断提升模型的准确性和效率，为人类生活和工作带来更多便利。
目录
AI大模型学习的理论基础
数学基础：
算法原理：
模型架构设计：
在大规模数据处理中的优势：
挑战：
AI大模型的训练与优化
AI大模型在特定领域的应用
AI大模型学习的伦理与社会影响
未来发展趋势与挑战
AI大模型学习的理论基础 数学基础： 线性代数：AI 大模型中大量使用向量和矩阵运算，如矩阵乘法、向量点积等，用于表示和操作数据。概率论与统计学：模型中的概率分布、随机变量和参数估计等都需要概率论和统计学的知识。微积分：优化算法中的梯度计算和反向传播等都涉及到微积分的概念。 算法原理： 反向传播：这是深度学习中常用的算法，用于更新模型的参数，通过计算损失函数的梯度来调整模型。随机梯度下降：一种常用的优化方法，通过不断迭代更新参数来最小化损失函数。激活函数：用于对神经元的输出进行非线性变换，增加模型的表达能力。 模型架构设计： 卷积神经网络（CNN）：擅长处理图像、视频等具有空间结构的数据，通过卷积操作提取特征。循环神经网络（RNN）：适用于处理序列数据，如自然语言处理中的文本。Transformer：一种全新的架构，在自然语言处理中取得了巨大成功，通过自注意力机制捕捉长距离依赖关系。 在大规模数据处理中的优势： 能够处理海量的数据，通过分布式训练等技术可以加速训练过程。可以自动学习数据中的模式和特征，不需要人工设计特征。模型的泛化能力强，可以应用于各种不同的任务和领域。 挑战： 模型的复杂度高，需要大量的计算资源和时间来训练。容易过拟合，需要进行适当的正则化和超参数调整。解释性较差，难以理解模型的决策过程。 AI大模型的训练与优化 训练和优化大规模机器学习模型确实是一个具有挑战性的任务，以下是一些有效的方法和技巧：
1. 计算资源分配：合理分配计算资源，例如使用 GPU 加速训练、分布式训练等技术，以提高训练效率。2. 参数调优：通过网格搜索、随机搜索或基于启发式的方法来调整模型的超参数，如学习率、正则化参数等。3. 正则化方法：应用正则化技术，如 L1、L2 正则化或dropout，以防止过拟合并提高模型的泛化能力。4. 模型压缩：采用压缩技术，如剪枝、量化等，减少模型的参数量和计算量，使其能够在资源有限的设备上运行。5. 数据增强：通过数据增强技术，如翻转、旋转、缩放等，增加训练数据的多样性，提高模型的鲁棒性。6. 梯度裁剪：限制梯度的范数，以避免梯度爆炸或消失问题。7. 早停法：根据验证集上的性能，在合适的时候停止训练，避免过拟合。8. 迁移学习：利用已有的预训练模型，在新的任务上进行微调，加快训练过程。9. 并行计算：使用多线程、多进程或分布式计算框架，加速模型的训练。10. 混合精度：在训练中使用低精度数据类型，如 FP16，减少内存消耗和计算时间。 AI大模型在特定领域的应用 在自然语言处理领域，AI 大模型如 GPT-3 被广泛应用于文本生成、机器翻译、问答系统等。这些模型通过学习大量的文本数据，能够理解自然语言的含义，并生成连贯、有逻辑的回答
在图像识别领域，深度学习模型如卷积神经网络在图像分类、目标检测、图像分割等任务中表现出色。它们可以识别和理解图像中的对象和场景，为各种应用提供支持。在语音识别领域，循环神经网络和 Transformer 架构常用于语音识别系统。这些模型能够将语音信号转换为文本，实现语音交互和自动化处理。
这些模型在解决实际问题方面取得了显著的进展。例如，自然语言处理模型可以帮助人们更轻松地与计算机进行交互，图像识别模型可以用于自动驾驶、安防监控等领域，语音识别模型则为智能语音助手提供了基础。
然而，这些模型仍然有潜在的改进空间。例如，提高模型的泛化能力、减少对大规模数据的依赖、提高模型的可解释性等。此外，模型的性能也受到计算资源、数据质量和算法优化等因素的影响
AI大模型学习的伦理与社会影响 AI 大模型学习确实带来了一些伦理和社会问题，我们需要认真对待：
1. 数据隐私：大量的数据收集和使用可能导致个人隐私的泄露，需要加强数据保护和隐私法规的制定。2. 算法偏见：模型可能受到训练数据中的偏见影响，导致不公平的决策和结果。需要关注算法的公正性和可解释性。3. 模型安全性：恶意攻击或滥用模型可能导致安全风险，如误导性信息的传播。需要加强模型的安全性和鲁棒性。4. 就业和社会结构变化：自动化和智能技术的发展可能对就业和社会结构产生影响，需要思考如何促进技能再培训和社会的可持续发展。 为了保障人类社会的福祉，我们可以采取以下措施：
1. 建立伦理准则：制定 AI 发展的伦理准则，引导技术的合理应用。2. 强化监管：加强对 AI 技术的监管，确保其符合法律和伦理标准。3. 公众教育：提高公众对 AI 技术的理解和认识，促进公众参与和讨论。4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a8d3791cf10e3dcbf48a1ef858a404f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a83a3a99bbe73dd8eafed4d005ec547/" rel="bookmark">
			网络分类简述与数据链路层协议（PPP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验拓扑 实验要求 1、R1和R2使用PPP链路直连，R2和R3把2条PPP链路捆绑为PPP MP直连按照图示配置IP地址
2、R2对R1的PPP进行单向chap验证
3、R2和R3的PPP进行双向chap验证
实验思路 给R1、R2的S3/0/0接口配置IP地址，已给出网段192.168.1.0/24R2作为主验证方，R1作为被验证方配置PPP协议。R2开启PPP协议，设置用户wangdaye，密码wdy12345，进入S3/0/0接口开启PPP协议，R1接口S3/0/0也配置上PPP协议R2、R3链路聚合，创建MP-Group组并配置IP地址，把接口加入MP-Group组R2作为主认证方，R3作为被认证方配置PPP协议R2作为被认证方，R3作为主认证方配置PPP协议 实验步骤 配置IP地址 [r1]int s3/0/0
[r1-Serial3/0/0]ip ad [r1-Serial3/0/0]ip address 192.168.1.1 24
[r1-Serial3/0/0]
[r2]int s3/0/0
[r2-Serial3/0/0]ip ad [r2-Serial3/0/0]ip address 192.168.1.2 24
[r2-Serial3/0/0]q
配置R2对R1的PPP R2：
[r2]aaa
[r2-aaa]l [r2-aaa]local-user wangday pas [r2-aaa]local-user wangday password ci
[r2-aaa]local-user wangday password cipher wdy12345
Info: Add a new user.
[r2-aaa]l [r2-aaa]local-user wangday s [r2-aaa]local-user wangday service-type p [r2-aaa]local-user wangday service-type ppp
[r2]int s3/0/0
[r2-Serial3/0/0]ppp a
[r2-Serial3/0/0]ppp authentication-mode
[r2-Serial3/0/0]ppp authentication-mode c [r2-Serial3/0/0]ppp authentication-mode chap
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a83a3a99bbe73dd8eafed4d005ec547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/155b22c88a5ca4d2771b137f94b394ce/" rel="bookmark">
			C&#43;&#43;stack,queue底层实现以及deque的详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、容器适配器二、stack的实现三、queue的实现四、deque的介绍总结 前言 在本篇文章中，我们将会学到stack,queue的底层实现，我们通过本篇的学习，我们会发现，栈和队列的实现和vector,list等容器的实现会有很大差异。我们实现栈和队列是通过一种叫容器适配器的东西实现的。我们还将会学到deque,这是一种将list和vector结合的一种容器。我们来详细看一看吧！！！🌟🌟🌟
一、容器适配器 在介绍容器适配器之前，我们来想一下stack应该如何实现呢？？
我们很清楚，栈是一种后进先出的结构，只能在一端进行数据的插入删除。
在c语言我们学习过，stack既可以用顺序表来实现，又可以用链表实现。
那么我们在C++中依然可以采用相同的方式来实现链式栈和顺序栈。
但是，我们发现在实现stack的接口中，很多都与顺序表的实现结构相似。
那麽我们把vector的一些接口进行封装，修改修改不就是我们stack的结构吗？？
在C++官方库中，确实就是采用这种方法进行实现的。我们把这个叫做容器适配器
stack是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出
队列作为容器适配器实现，容器适配器即将特定容器类封装作为其底层容器类，queue提供一组特定的成员函数来访问其元素。元素从队尾入队列，从队头出队列。
容器适配器是C++标准库中的一种数据结构，它可以将不同类型的容器（如vector、list、deque等）转换为另一种类型的容器。本质上，容器适配器是一种机制，能使某种容器的行为看起来像另外一种容器。这种转换提供了一种简单的方式来重新组织和访问数据，同时隐藏了底层容器的实现细节。容器适配器通常用于解决特定的问题或满足特定的需求。
二、stack的实现 我们现在已经知道实现stack采用容器适配器来实现，我们想实现一个链式栈，就采用list进行适配，我们想实现一个顺序栈，就采用vector进行适配。
vector适配缺点：容易造成空间浪费
list适配缺点：内存命中率较低
有没有一种两者兼有的结构呢？？
我们来看一下stack库里的是如何实现的！！！
我们发现在进行适配时，默认采用了deque这个容器。
这其实是一个双端队列。尾插尾删效率很高，对于空间的浪费也没有那麽大，内存命中率也可以。我们先用这个实现一下，在后面我们再来详细看一下
template&lt;class T,class con=deque&lt;T&gt;&gt; class stack { public: void push(const T&amp;val) { _con.push_back(val); } void pop() { _con.pop_back(); } size_t size() { return _con.size(); } T&amp; top() { return _con.back(); } bool empty() { return _con.empty(); } private: con _con; }; 三、queue的实现 对于queue的实现我们想一下是否可以用vector和list实现
queue是先进先出，尾插头删，对于vector我们在库里面并没有头删的操作。
我们也可以用自己模拟实现的vector实现一个头删，但是我们知道对于头删，效率太低了
⭐️⭐️注意一下：适配器并不是一定要适配库里的，也可以适配自己模拟实现的，只要可以实现对应的需求就可以
对于list我们就可以了，但是list也有对应的缺陷，我们看一下库里的实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/155b22c88a5ca4d2771b137f94b394ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd30d64ed5511ef72864068be958bae/" rel="bookmark">
			AJAX介绍&amp;使用&amp;案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、AJAX概念二、AJAX快速入门1、编写AjaxServlet，并使用response输出字符（后台代码）2、创建XMLHttpRequest对象：用于和服务器交换数据 &amp; 3、向服务器发送请求 &amp; 4、获取服务器响应数据 三、案例-验证用户是否存在1、SelectUserServlet2、register.html 四、Axios异步框架1、Axios快速入门（1）、get（2）、post 2、Axios请求方式别名（阅读性不好） 五、JSONJSON概念1、JSON基础语法2、JSON数据和Java对象转换（1）、导入坐标（2）、转换 3、案例（1）、查询所有1、Web层2、brand.html （2）、新增品牌1、Web层2、addBrand.html 一、AJAX概念 异步和同步
二、AJAX快速入门 1、编写AjaxServlet，并使用response输出字符（后台代码） package com.itheima.web.servlet; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; @WebServlet("/ajaxServlet") public class AjaxServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 响应数据 response.getWriter().write("hello ajax~"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 2、创建XMLHttpRequest对象：用于和服务器交换数据 &amp; 3、向服务器发送请求 &amp; 4、获取服务器响应数据 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdd30d64ed5511ef72864068be958bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76a5c7f4143731a5acbd5011bd75729e/" rel="bookmark">
			案例实践 | 基于长安链的煤质检测智慧实验室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例名称-煤质检测智慧实验室
■ 建设单位
国能数智科技开发（北京）有限公司
■ 用户群体
煤炭生产单位、电力单位、化工单位等产业链上下游单位
■ 应用成效
化验效率提升50%，出验时间缩短40%，提高化验数据市场公信力
案例背景
煤炭作为重要的能源资源广泛应用于工业、发电、加热和燃料等领域，在全球发电燃料占比持续保持第一。2021年，全球煤炭产量超过80亿吨，国际贸易量达到13.33亿吨并持续增长。国家能源集团是拥有煤炭、电力、运输、化工等8个板块的综合产业集团，是全球规模最大的煤炭生产公司、火力发电公司、风力发电公司和煤制油煤化工公司。
煤炭质量不仅影响发电效率和碳排放量，还对煤炭交易的价格产生影响，因此煤炭质量数据是指导煤炭产销、火力发电的关键数据。煤质检测过程中，存在测试数据真实性难以保证、人工检测误差率大、检测数据难以实现跨系统共享的问题，基于长安链构建账户可信、设备可信、过程可信和数据可信的信任体系将有助于提升全球贸易与上下游交易中的公平性和信任度。
针对此类问题国家能源集团联合煤炭生产单位、转运单位、火电单位、化工单位等产业链上下游及外部海关、CNAS、ZSA共同基于以长安链为底层的国能链建设煤质检测智慧实验室，打通集团煤炭采、制、化、存、管全过程数据通道，实现上下游企业数据共享和数据溯源，形成统一的煤炭采制标准，并以可视化方式呈现煤炭贸易的全链路状态跟踪，为煤质检测提供自动化、数字化服务，实现数据在产业链上下游安全共享和可信溯源，促进煤炭供应链一体化协同，支撑煤炭交易数字化转型。
业务流程
基于长安链的煤质检测智慧实验室涉及采制化计划管理、调度管理、采制化全过程管理等多个业务模块，各业务之间数据基于区块链进行打通，实现数据透明、全流程溯源，业务协同性强。
图表 基于区块链的煤质检测智慧实验室流程图
1）采样管理：由计划员制定煤炭进港计划、装卸计划，同步将计划上传至区块链平台。计划管理员按区块链上的计划后生成采制化任务，并上传至区块链平台。采制化调度员按区块链上的采制化任务给集中监控系统，中控室上传作业信息至区块链平台存证。
2）制样管理：中控室作业员按区块链上的制样任务要求，通过集中监控系统执行制样作业，启动制样设备完成制样，并返回作业信息到区块链平台存证。
3）留存样管理：中控室作业员通过集中监控系统执行存样作业，启动设备自动存样，并返回入库作业信息到区块链平台存证。
4）化验业务管理：中控室作业员启动设备自动化验，并返回化验作业和化验数据信息到区块链平台。化验数据管理员进行数据审核，审核通过后，系统按规则自动生成化验报告，报告审核通过后，上传区块链平台存证。
5）抽检业务管理：采制化调度员创建抽检任务，启动抽检出库、制样、存样和化验作业，并返回化验作业和化验数据信息上传区块链平台进行存证。
基于区块链的煤质检测智慧实验室，实现煤炭采制化过程现场无人化，贯通煤炭采制化全过程，确保数据源无人干预，保证数据上链前真实可信，依托区块链分布式账本，实现贸易双方、货运代理、海关、铁路局、银行等参与方数据信息实时共享、公开透明。
价值与成效
以长安链为底层平台搭建煤炭采制化联盟网络，建设煤质检测智慧实验室，实现煤炭采制化全过程协同贯通。具体价值与成效如下。
平台应用效果：单个样品完成制样时间约70min，连续出样间隔约30min，8小时可完成30批样品，而传统人工制样，5名化验员每8小时平均完成15批样品，采用全过程机器人制样后，效率提升50%。无人值守化验室自动化验煤质分析核心检验项目，较之前人工化验效率提升了50%，出验时间缩短40%，分析结果准确度达100%。
全流程智能管理：实现煤炭采、制、化、存、管全过程自动化、智能化管理，改变传统煤炭采制化业务模式，由无人采制化作业替代传统人工作业，基于区块链自动审核替代人工三级审核，提高数据准确性，提高煤炭质量管控水平，促进企业降本增效。
提高化验数据市场公信力：基于区块链实现票据电子化、数据可信共享和溯源，构建数据可信体系，创新化验数据信任共享机制，由机构信任转向机制信任，提高煤炭化验数据的市场公信力。
提升煤炭产运销储用业务协同能力：煤质检测智慧实验室在煤炭生产、运输、销售、电力、化工等企业推广应用，创新煤炭供应链化187验业务模式，由各煤炭单位独立化验模式转向供应链网络共享化验模式，促进煤炭供应链产运销储用业务协同能力。
发布行业标准：发布《无人值守可信煤炭化验室通用技术要求》、《国家能源集团公司集团煤炭采制化业务标准》以及《国家能源集团区块链使能平台应用规范》等，申请专利10项，软件著作权2项。煤质检测智慧实验室国际标准已通过ISO/TC 336 PMI(预提案)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ac38a191533b876c0f06d9c2036cf4/" rel="bookmark">
			vivado 分析和查看实施结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析和查看实施结果
监控实施运行
通过监视实施运行，您可以：
•阅读汇编信息。
•查看消息窗口中的警告和错误。
•查看项目摘要。
•打开“设计运行”窗口。
在“日志”窗口中监视“合成”或“实现”运行的状态。
查看运行状态显示
正在进行的运行状态可以通过两种方式显示，用于合成和实现运行。这些状态显示显示运行正在进行中。他们允许你如果需要，取消跑步。
•您可以在项目状态栏的右上角找到运行状态指示器AMD Vivado™IDE，如下图所示。运行状态指示器显示滚动条以指示运行正在进行中。您可以单击“取消”结束跑步。
•您还可以在“设计运行”窗口中找到运行状态指示器，如底部所示下图的左侧。它显示一个圆形箭头（图中用红色标注）来指示运行正在进行中。可以从中选择管路并使用“重置管路”命令弹出菜单取消跑步。
取消或重置跑步
如果您通过单击“取消”或“重置运行”来取消正在进行的运行，Vivado IDE提示您删除在取消运行期间创建的所有运行文件，如下所示图形
选择“删除生成的文件”以从本地项目目录中清除运行数据。
建议：删除由于取消运行而创建的任何数据，以避免与未来发生冲突跑。
在日志窗口中查看日志
启动运行后，会在Vivado IDE中打开“日志”窗口。它显示了标准输出信息。它还显示了关于每个单独实施过程的进展的细节，诸如place_ design和route_。如下图所示的Log（日志）窗口可以帮助您了解不同之处消息的产生有助于调试运行的实现。
暂停输出
单击“暂停输出”按钮以暂停输出到“日志”窗口。暂停允许您在实现继续运行的同时读取日志。
显示项目状态
Vivado IDE使用多种方法来显示项目状态以及下一步要执行的步骤。项目状态仅报告主要设计任务的结果。项目状态显示在项目摘要和状态栏中。它允许您打开项目时或运行时立即查看项目的状态设计流命令，包括：
•RTL阐述
•合成
•实施
•比特流生成
在项目状态栏中查看项目状态
项目状态显示在Vivado右上角的项目状态栏中石斑鱼类。
随着运行通过Synthesis、Implement和Write Bitstream命令的进行项目状态栏更改为显示成功或失败的尝试。故障显示在中红色文本。
查看过期状态
如果源文件或设计约束发生更改，并且合成或实现先前完成的项目可能会标记为过期，如下所示图形项目状态栏显示“过期”状态。单击更多信息以显示的哪些方面设计已经过时了。可能需要重新运行实现，或者综合和实施
强制运行最新
单击强制最新以强制执行或综合运行最新。如果更改了设计或约束，但仍要分析的结果，请使用“强制更新”当前运行。
提示：“设计运行”窗口的弹出菜单中也提供“强制更新”命令当选择了过期的跑步时。
实施后的进展
在实施完成后，对于项目模式和非项目模式接下来的设计方向取决于实现的结果。
•设计是否完全就位和布线，或者是否存在需要解决的问题？
•是否满足了时间限制和设计要求，或者是否进行了额外的更改是否需要完成设计？
•您准备好为AMD部件生成比特流了吗？
实施后的建议步骤
实施后的建议步骤是：
1.审查实施消息。
2.审查实施报告，以验证设计的关键方面：
•满足时间限制（report_Timing_summary）。
•利用率如预期（report_uUtilization）。
•功率如预期（report_Power）。
3.写入比特流文件。
写入比特流文件包括最终DRC，以确保设计不会违反任何硬件规则。
4.如果未满足任何设计要求：
•在项目模式中，打开已实施的设计进行进一步分析。
•在非项目模式下，打开实施后设计检查点。
有关已实现设计分析的更多信息，请参阅交互式设计一节Vivado Design Suite用户指南中IDE中的分析：设计分析和闭合技术（UG906）。
以非项目模式前进
在非项目模式下，Vivado Design Suite为设计会话生成消息，以及将消息写入Vivado日志文件（Vivado.log）。检查此日志文件和报告根据设计数据生成，以查看对当前项目状态的准确评估。
以项目模式前进
在项目模式下，Vivado Design Suite在消息中显示日志文件中的消息窗它还自动化了大量报告的创建和交付，供您审阅。在项目模式下，在Vivado IDE中完成实现运行后，系统会提示您下一步，如下图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66ac38a191533b876c0f06d9c2036cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e4b3f158edb0a6dcfa9fd92393d454/" rel="bookmark">
			新手必学的Markdown教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown 简介与教程 强烈推荐你学会Markdown！因为它真的很有用，能够让你更方便的记笔记，帮助你整理你的思路和想法。
聚沙成塔，复杂的工程也是一步一步完成的，因此记录这件事不能被忽视。就像你在做实验、写文章、分析数据、学习或工作中，可能偶尔需要回溯之前的操作，有时候记性不好容易忘，如果做好关键记录，那么以后回看时会大大提高效率。
什么是Markdown？ Markdown 是一种轻量级的标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档。
由于其简洁性和易用性，Markdown 成为了编写博客、文档及笔记的首选语言之一。本篇博客旨在介绍 Markdown 的基础知识，并通过详细的教程和示例，帮助你快速上手。
Markdown 的优势是什么？ 易于学习和使用： Markdown 的语法非常简单，几乎没有学习曲线，你可以在几分钟内开始编写文档。 这个就像一种语言，有固定的语法格式和通用框架，所以不用畏惧，你肯定能快速掌握，主要是熟能生巧，多记多思考。
纯文本格式： 由于是纯文本，Markdown 文件可以用任何文本编辑器打开，无需特定的软件。不管你是什么电脑、平板、手机，不管你什么Linux、windows、mac都能兼容，甚至直接用txt记事本也能打开，不像word那么复杂。
高度可读： Markdown 文档即使不转换成 HTML，也依然是可读的，这是因为它的标记语法非常接近自然语言。除了几个特殊符号外没有其他影响，就算不进行渲染也能够正常打开阅读。
灵活转换： Markdown 文档可以轻松转换成 HTML、PDF 和其他格式，非常适合网页和印刷。现在有语雀、腾讯文档、飞书、知乎、CSDN、公众号等平台都支持markdown格式，还可以通过typora进行灵活转换。
基础语法 标题 Markdown 使用#符号来表示标题，支持六级标题，数量越多表示级别越低：
# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
段落和换行 在 Markdown 中，段落之间通过空白行分隔。如果你需要在段落内添加换行，可以在行尾添加两个或以上的空格然后回车。
强调 可以使用 * 或 _ 来强调文本：
*斜体* 或 _斜体_
**粗体** 或 __粗体__
***加粗斜体*** 或 ___加粗斜体___
列表 使用 *、+ 或 - 作为列表标记：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07e4b3f158edb0a6dcfa9fd92393d454/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c796a4877c7917ea8beea0ec7224c843/" rel="bookmark">
			OFDM调制解调的优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、频谱效率高
各子载波可以部分重叠，理论上可以接近Nyquist极限。 实现小区内各用户之间的正交性，避免用户间干扰，取得很高的小区容量。 相对单载波系统（WCDMA），多载波技术是更直接实现正交传输的方法
2、带宽扩展性强
OFDM系统的信号带宽取决于使用的子载波数量，几百kHz—几百MHz都较容易实现，FFT尺寸带来的系统复杂度增加相对并不明显。 非常有利于实现未来宽带移动通信所需的更大带宽，也更便于使用2G系统退出市场后留下的小片频谱。 单载波CDMA只能依赖提高码片速率或多载波CDMA的方式支持更大带宽，都可能造成接收机复杂度大幅上升。 OFDM系统对大带宽的有效支持成为其相对单载波技术的决定性优势。
3、抗多径衰落
保护间隔可抑制符号间串扰，但是破坏了子载波间的正交性，带来子载波间干扰（ICI），所以引入循环前缀（CP）。
CP使一个符号周期内因多径产生的波形为完整的正弦波，因此不同子载波对应的时域信号及其多径积分总为0 ，消除载波间干扰(ICI)。
4、频域调度和自适应
集中式、分布式子载波分配方式
集中式子载波分配方式：时域调度、频域调度
分布式子载波分配方式：终端高速移动或低信干噪比，无法有效频域调度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b35e007e7a75d844062eeb4767246bc4/" rel="bookmark">
			C语言-----qsort()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面向大家介绍了冒泡排序，冒泡排序的核心思想是让数组中相邻的元素进行比较，这是一种常见的算法。但是冒泡排序有一个缺陷，就是冒泡排序只能对整型类型的数组进行操作。所以当我们要对其他类型进行排序时。例如：字符串类型的数组、结构体类型的数组。则冒泡排序此时就不起作用了，那我们要如何操作呢？
C语言为例帮我们解决这个问题，就创建了一个排任意数据类型的函数------qsort()函数。
1.qsort()函数 qsort()函数是C语言中的一个库函数，其包含在 &lt;stdlib.h&gt; 这个头文件中。它是C语言中的一个高级函数，可以帮助我们对任意类型的数组进行排序。
qsot()函数采用了自动快速排序的方式，当条件符合时，就会自动对所需要进行排序的数据进行排序。
那如何使用qsort()函数呢？
首先，我们要知道qsort()函数中有4个参数，形式如下
void qsort(void* base,size_t num,size_t size,int(*compare)(const void*p1,const void*p2)) 我来为大家解释下这些参数的意义
1. void* base 是一个void* 类型的指针，其指向的是需要进行排序的数组中的首个元素。
2. size_t num 是指向数组的元素个数，也就是数组的大小。
3. size_t size 是指向数组中的元素的大小。
4. int(*compare)(const void*,const void*) 是一个指向两个需要比较元素的数组。
这个比较函数是有返回值,如下表
返回值 *p1-*p2 1 *p1-*p2&gt;0 -1 *p1-*p2&lt;0 0 *p1*p2==0 注意： 这里的*p1 ,*p2做差的位置不是固定的，我们要根据我们的需求来决定是*p1-*p2还是
*p2 - *p1。
2.qsort()的实际使用 2.1 qsort()实现对整型数组的排序 int main() { int arr[5] = { 23,45,67,24,78 }; int sz = sizeof(arr) / sizeof(arr[0]); qsort(arr, sz, sizeof(arr[0]), com); for (int i = 0; i &lt; sz; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b35e007e7a75d844062eeb4767246bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf4a3d6db5edfb94c55cb553593e327/" rel="bookmark">
			LeetCode_32_困难_最长有效括号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 题目2. 思路及代码实现详解（Java）2.1 动态规划2.2 不需要额外空间的算法 1. 题目 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。
示例 1：
输入： s = s = s= "(()"
输出： 2 2 2
解释：最长有效括号子串是 "()"
示例 2：
输入： s = s = s= ")()())"
输出： 4 4 4
解释：最长有效括号子串是 "()()"
示例 3：
输入： s = s = s= ""
输出： 0 0 0
提示：
0 &lt; = s . l e n g t h &lt; = 3 × 1 0 4 0 &lt;= s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf4a3d6db5edfb94c55cb553593e327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ef6eb1edb939be7490aa30341d49531/" rel="bookmark">
			RabbitMq高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息队列高级 服务异步通信-高级篇1.消息可靠性1.1.生产者消息确认1.2.消息持久化1.3.消费者消息确认1.4.消费失败重试机制1.5.总结 2.死信交换机2.1.初识死信交换机2.2.TTL2.3.延迟队列 3.惰性队列3.1.消息堆积问题3.2.惰性队列 4.MQ集群4.1.集群分类4.2.普通集群4.3.镜像集群4.4.仲裁队列 服务异步通信-高级篇 消息队列在使用过程中，面临着很多实际问题需要思考：
1.消息可靠性 消息从发送，到消费者接收，会经理多个过程：
其中的每一步都可能导致消息丢失，常见的丢失原因包括：
发送时丢失： 生产者发送的消息未送达exchange消息到达exchange后未到达queue MQ宕机，queue将消息丢失consumer接收到消息后未消费就宕机 针对这些问题，RabbitMQ分别给出了解决方案：
生产者确认机制mq持久化消费者确认机制失败重试机制 下面我们就通过案例来演示每一个步骤。
创建项目，项目结构如下：
1.1.生产者消息确认 RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。
返回结果有两种方式：
publisher-confirm，发送者确认 消息成功投递到交换机，返回ack消息未投递到交换机，返回nack publisher-return，发送者回执 消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。 注意：
1.修改配置
首先，修改publisher服务中的application.yml文件，添加下面的内容：
spring: rabbitmq: publisher-confirm-type: correlated publisher-returns: true template: mandatory: true 说明：
publish-confirm-type：开启publisher-confirm，这里支持两种类型： simple：同步等待confirm结果，直到超时correlated：异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback publish-returns：开启publish-return功能，同样是基于callback机制，不过是定义ReturnCallbacktemplate.mandatory：定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息 2.定义ReturnConfirm 回调
每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目加载时配置：
修改publisher服务，添加一个：
package cn.cloud.mq.config; @Slf4j @Configuration public class CommonConfig implements ApplicationContextAware { @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { // 获取RabbitTemplate RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class); // 设置ReturnCallback rabbitTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ef6eb1edb939be7490aa30341d49531/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/10/">«</a>
	<span class="pagination__item pagination__item--current">11/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/12/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>