<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845fd94f7016a20460dce8c827e92b88/" rel="bookmark">
			【Vue】脚手架搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建vue脚手架 一、安装Node.js 1、Node.js简介
简单的说 Node.js 就是运行在服务端的 JavaScript。
Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。
Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。
2、下载Node.js
打开官网下载链接:https://nodejs.org/en/download/
下载完成后就可以开始安装了，只需无脑下一步就行，不过记得修改自己安装的路径
至此Node.js已经安装完成，可以先进行下简单的测试安装是否成功了，后面还要进行环境配置
在键盘按下【win+R】键，输入cmd，然后回车，打开cmd窗口
node -v 能够显示版本号就说明已经安装成功了
安装完后的目录如下图所示:
环境配置
我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹【D:\Develop\nodejs】下创建两个文件夹【node_global】及【node_cache】如下图
创建完两个空文件夹之后，打开cmd命令窗口，输入
npm config set prefix"D:\Develop\nodejs\node_global" npm config set cache "D:\Develop\nodejs\node_cache" 接下来设置环境变量，关闭cmd窗口，“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”
进入环境变量对话框，在【系统变量】下新建【NODE_PATH】
【D:\Develop\nodejs】 此处为自己的安装的路径
然后编辑path，新建，为%NODE_PATH%
此时Node就已经安装成功了！！！
二、配置淘宝镜像 打开 “命令提示符” 窗口，输入：
npm config set registry https://registry.npm.taobao.org 完成配置
三、安装脚手架 打开 “命令提示符” 窗口，输入：
npm install -g @vue/cli 注意：如果安装过程一直不动，可以敲下回车
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/845fd94f7016a20460dce8c827e92b88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b865416493ce1638fffb8a2a9d5d54/" rel="bookmark">
			【Vue】生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue的生命周期详解 一、vue的生命周期是什么
借用官网的一句话就是：每一个vue实例从创建到销毁的过程，就是这个vue实例的生命周期。在这个过程中，他经历了从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程。那么这些过程中，具体vue做了些啥，我们今天来了解一下。
二、Vue生命周期图详解(尚硅谷)
beforeCreate( 创建前 ) 第一个生命周期函数
这个时候，在实例被完成创建出来，el和data都还没有初始化，不能访问data、method，一般这个阶段不进行操作。
beforeCreate() { console.log('----beforeCreate----') console.log(this.msg) //undefined console.log(this.$el) //undefined }, created( 创建后 ) 第二个生命周期函数
这个时候，vue实例中的data、method已经被初始化，属性也可以被绑定，但是此时还是虚拟dom，真实dom还没有生成，$el 还不可用，这个时候可以调用data和method的数据及方法，created钩子函数是最早可以调用data和method的，故一般再次对数据进行初始化
created() { console.log('----created----') console.log(this.msg)	//msg console.log(this.$el)	//undefined }, beforeMount( 挂载前) 第三个生命周期函数
此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面上，此时的页面还是旧的，此时el存在则会显示el。在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取。
当vue实例中，el为挂载目标，未对el进行定义，则this.el显示undefined，因为el只有渲染完成后才会存在。这里讲的el是真实的el。在真实的el之前存在前。
Mounted( 挂载后) 第四个生命周期函数
此时内存中得得模板已经渲染成了真实的DOM，用户已经可以看到渲染完成的页面，这是实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动
mounted() { console.log('----mounted----') console.log(this.msg)	//msg console.log(this.$el)	//&lt;div id="app"&gt;&lt;span model="msg"&gt;&lt;/span&gt;&lt;/div&gt; }, beforeUpdate（更新前） 第五个生命周期函数
更新之前前，此时页面的数据还没有发生改变，但是数据已经发生了改变，也就是说页面尚未和数据保存同步
beforeUpdate() { console.log(document.getElementById('h3').innerText) // ok console.log('data 中的 msg 数据是：' + this.msg) //No }, updated（更新后） 此时页面的数据已经发生了改变，页面是新的，数据也是新的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56b865416493ce1638fffb8a2a9d5d54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aee68e4d82f4d5f372021d359da323f6/" rel="bookmark">
			Integer的int compare(int x, int y)方法为什么不直接用x-y?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在查看Integer源码时发现有下面这个方法，为什么要废这么大劲写这么长
public static int compare(int x, int y) {
return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);
}
比较两个数下意识会做减法，其实这样是不对的，因为每种数据类型都有范围，向上溢出（超过最大值）会从最小值开始计数；向下溢出（小于最小值）会从最大值往回计数。得不到我们需要的结果。
Integer.MAX_VALUE-(-1)结果为-2147483648。
Integer.MIN_VALUE-1结果为2147483647
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3801f2bbadf138e9d3e1b84cd3b20cd0/" rel="bookmark">
			golang并发编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go的并发编程 go 在语言层面支持并发，go 标准库提供的所有系统调用操作（包括所有同步IO操作），都会分配 CPU 给其他 goroutine ，这使得轻量级线程的切换管理不依赖于系统的线程和进程，也不需要依赖于 CPU 的核心数量。
有人把 go 比作21世纪的C语言，第一是因为 go 具有 C语言的简洁和性能，第二就是 go 的并发编程了，go 在语言层面就支持并发，操作更简单，性能更好，同时，go 还自带自动垃圾回收机制，方便内存管理。
go 语言为并发编程而内置的上层 API 基于顺序通信进程模型 CSP(communicating sequential processes)。这就意味着显式锁都是可以避免的，因为go 通过相对安全的通道发送和接受数据以实现同步（channel），这大大地简化了并发程序的编写，“不要通过共享内存来通信，而应该通过通信来共享内存”，这是风靡 go 社区的流行语。
go 语言中的并发程序主要使用两种手段来实现，goroutine 和 channel。
并发介绍 进程、线程和协程 进程
进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。
进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成。
数据集则是程序在执行过程中所需要使用的资源;进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 进程的局限是创建、撤销和切换的开销比较大。
线程
线程是进程的一个执行实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
线程由线程ID、 程序计数器、寄存器集合和堆栈共同组成，一个进程可以包含一个或多个线程
协程
协程是一种轻量级的线程，也被称为用户级线程或微线程，可以轻松创建上百万个而不会导致系统资源衰竭，它是一种可以暂停和恢复执行的函数，能够在特定的位置暂停执行，然后在需要时恢复执行，一个线程上可以跑多个协程。
与线程相比，协程不依赖于操作系统的线程调度机制，而是由程序员自行控制协程的切换和调度。在协程中，可以通过挂起和恢复操作来实现协程之间的切换，而无需进行上下文切换和线程间的通信。
协程的优势在于其轻量级和高效性。由于协程的切换操作由程序员手动控制，因此可以减少上下文切换的开销，并且在切换时不需要保存和恢复整个线程的上下文，而只需要保存和恢复协程的状态。
协程可以用于处理需要高并发和高效性能的任务，特别是在IO密集型的场景下，如网络通信、数据库访问等。协程的代码结构也更加清晰和简洁，可以提高代码的可读性和可维护性。
Go语言对于并发的实现是靠协程，Goroutine
并发和并行 并发：多线程的程序在一核 CPU 上运行
并行：多线程的程序在多核 CPU 上运行
并发：
并行：
并发主要由切换时间片来实现"同时"运行，并行则是直接利用多核实现多线程的运行，go可以设置使用核数，以发挥多核计算机的能力。
并行一定比并发快吗？
不一定，在实际并行运行的组件，我们需要考虑到多个线程之间的通信问题，这种跨 CPU 的通信问题的性能开销比较高，所以并行并不一定快。
goruntine go 使用 goruntine 来实现并发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3801f2bbadf138e9d3e1b84cd3b20cd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23745d7b71045c5cf84f482c3b01e4a5/" rel="bookmark">
			学习卡尔曼滤波的一些粗浅认识以及如何在雷达系统中进行应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章先根据以下两处学习资料对卡尔曼滤波卡尔曼增益的由来做一个简要推导，其次简单分析了以下在雷达系统中应用卡尔曼滤波进行跟踪需要哪些变量。
感谢大佬们的付出，学习资料主要参考以下两个部分： B站视频: link
CSDN博客：link
1、卡尔曼增益的简单推导 首先借用B站up的PPT里的卡尔曼滤波五个公式：
对于预测部分， x ^ t − 1 {\hat x_{t - 1}} x^t−1​表示 ( t − 1 ) (t-1) (t−1)时刻的状态估计， F F F表示状态转移矩阵， x ^ t − \hat x_t^- x^t−​的 − ^- −号表示该值还不是最佳的状态估计值，待会儿还要根据观测值对该值进行修正。 B B B是控制矩阵，表示控制量 u u u如何作用于当前状态。举链接视频里的例子，假如小车的状态有位置和速度两个变量，用 x t = [ p t , v t ] T {x_t} = {\left[ {{p_t},{v_t}} \right]^T} xt​=[pt​,vt​]T表示，那么做匀加速运动的小车的状态方程可以表示成：
而预测部分的第二个公式表示的是协方差矩阵的更新。上述引用的博客对此作的解释是：基于高斯分布来建立状态变量，对于 ( t − 1 ) (t-1) (t−1)时刻，均值为 x ^ t − 1 {\hat x_{t - 1}} x^t−1​，方差为 P t − 1 {P_{t - 1}} Pt−1​，其中均值被称为最佳估计，这也很好理解，因为均值代表了小车的位置和速度。而 F F F的作用是将上一时刻估计的每个点移动到了新的位置，那么此时刻的均值和方差就分别为 F x ^ t − 1 F{\hat x_{t - 1}} Fx^t−1​， F P t − 1 F T F{P_{t - 1}}F^T FPt−1​FT。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23745d7b71045c5cf84f482c3b01e4a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbc825696897b017233fd6785716e48/" rel="bookmark">
			存储简单了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储目前常用的有磁盘（磁性存储器）和固态硬盘（半导体存储器）
磁盘由盘片，磁头和移动磁头的机械装置组成。磁盘从空间结构上分为扇区和磁道，每个扇区存储大小一致。
固态硬盘由多个闪存芯片组成，每个闪存芯片由块组成，块有多个页组成。
RAM（Random Access Memory）随机存取存储器，是与CPU直接交换数据的内部存储器。
RAM由存储矩阵、地址译码器、读/写控制器、输入/输出、片选控制等几部分组成。
（1）存储矩阵。如图所示，RAM的核心部分是一个寄存器矩阵，用来存储信息，称为存储矩阵。
（2）地址译码器。地址译码器的作用是将寄存器地址所对应的二进制数译成有效的行选信号和列选信号，从而选中该存储单元。
（3）读/写控制器。访问RAM时，对被选中的寄存器进行读操作还是进行写操作，是通过读写信号来进行控制的。读操作时，被选中单元的数据经数据线、输入/输出线传送给CPU（中央处理单元）；写操作时，CPU将数据经输入/输岀线、数据线存入被选中单元。
（4）输入/输出。RAM通过输入/输岀端与计算机的CPU交换数据，读出时它是输岀端，写入时它是输入端，一线两用。由读/写控制线控制。输入/输出端数据线的条数，与一个地址中所对应的寄存器位数相同，也有的RAM芯片的输入/输出端是分开的。通常RAM的输出端都具有集电极开路或三态输出结构。 [6]
（5）片选控制。由于受RAM的集成度限制。一台计算机的存储器系统往往由许多RAM组合而成。CPU访问存储器时，一次只能访问RAM中的某一片（或几片），即存储器中只有一片（或几片）RAM中的一个地址接受CPU访问，与其交换信息，而其他片RAM与CPU不发生联系，片选就是用来实现这种控制的。通常一片RAM有一根或几根片选线，当某一片的片选线接入有效电平时，该片被选中，地址译码器的输出信号控制该片某个地址的寄存器与CPU接通；当片选线接入无效电平时，则该片与CPU之间处于断开状态。
根据存储单元的工作原理不同， RAM分为静态RAM和动态RAM。
静态存储单元是在静态触发器的基础上附加门控管而构成的。因此，它是靠触发器的自保功能存储数据的。SRAM存放的信息在不停电的情况下能长时间保留，状态稳定，不需外加刷新电路，从而简化了外部电路设计。但由于SRAM的基本存储电路中所含晶体管较多，故集成度较低，且功耗较大。
优点：速度快、使用简单、不需刷新、静态功耗极低；常用作Cache。
缺点：元件数多、集成度低、运行功耗大。
DRAM利用电容存储电荷的原理保存信息，电路简单，集成度高。由于任何电容都存在漏电，因此，当电容存储有电荷时，过一段时间由于电容放电会导致电荷流失，使保存信息丢失。解决的办法是每隔一定时间（一般为2ms）须对DRAM进行读出和再写入，使原处于逻辑电平“l”的电容上所泄放的电荷又得到补充，原处于电平“0”的电容仍保持“0”，这个过程叫DRAM的刷新。
优点： 集成度远高于SRAM、功耗低，价格也低。
缺点：因需刷新而使外围电路复杂；刷新也使存取速度较SRAM慢，所以在计算机中，DRAM常用于作主存储器。
尽管如此，由于DRAM存储单元的结构简单，所用元件少，集成度高，功耗低，所以已成为大容量RAM的主流产品。
存储器的种类很多，按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存），辅助存储器又称外存储器（简称外存）。
外存通常是磁性介质或光盘，像硬盘，软盘，磁带，CD等，能长期保存信息，并且不依赖于电来保存信息，但是由机械部件带动，速度与CPU相比就显得慢的多。内存指的就是主板上的存储部件，是CPU直接与之沟通，并用其存储数据的部件，存放当前正在使用（即执行中）的数据和程序，它的物理实质就是一组或多组具备数据输入输出和数据存储功能的集成电路，内存只用于暂时存放程序和数据，一旦关闭电源或发生断电，其中的程序和数据就会丢失
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7e65bdbd8532d9698e7976ab3757a3/" rel="bookmark">
			LeetCode刷题 --- 前缀和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前缀和（Prefix Sum）
定义：前缀和是一种重要的预处理，能大大降低查询的时间复杂度。结合Hash缓存，能够进一步优化提升算法执行效率
prefixSum [0] = 0 【备注：此处不要定义prefix[0]=nums[0]，这种定义违背前缀和的意义】
prefixSum [1] = prefixSum[0] + nums[0] = 0 + num[0]
…
prefixSum [i] = prefixSum [i-1] + nums [i]。
由此推导出两个变换公式： （1）nums[某一项] = 两个相邻 前缀和 之差：
nums[x] = prefixSum[x] - prefixSum[x - 1]
（2）从left到right的元素和等于prefixSum[right+1] –prefixSum[left];
例题：
560. 和为 K 的子数组
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。
代码
public static int subarraySum(int[] nums, int k) { // 计算前缀和 int[] sum = new int[nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e7e65bdbd8532d9698e7976ab3757a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d06b7db46a913070722471ef17504a/" rel="bookmark">
			YOLO 划分数据集（训练集、验证集、测试集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言训练集、验证集（8:2）训练集、验证集、测试集（7:2:1） 前言 本博客是在我的另一篇博客 VOC 格式与 YOLO 格式的相互转换 的基础上进行的，有需要可以参考
以下代码亲测可以直接复制运行（以下所有的路径修改成自己对应的路径） {\color{Red} \mathbf{以下代码亲测可以直接复制运行 （以下所有的路径修改成自己对应的路径）}} 以下代码亲测可以直接复制运行（以下所有的路径修改成自己对应的路径）
训练集、验证集（8:2） split82.py 内容如下：
import os import shutil import random from tqdm import tqdm """ 标注文件是yolo格式（txt文件） 训练集：验证集 （8：2） """ def split_img(img_path, label_path, split_list): try: # 创建数据集文件夹 Data = './VOCdevkit/VOC2007/ImageSets' # 这里我的文件夹./VOCdevkit/VOC2007/ImageSets提前创建好了，所以注释了下一行，否则会抛异常 # os.mkdir(Data) train_img_dir = Data + '/images/train' val_img_dir = Data + '/images/val' # test_img_dir = Data + '/images/test' train_label_dir = Data + '/labels/train' val_label_dir = Data + '/labels/val' # test_label_dir = Data + '/labels/test' # 创建文件夹 os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97d06b7db46a913070722471ef17504a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e4227e52f69b85c925fb92538d2322/" rel="bookmark">
			BatchNorm, LayerNorm, InstanceNorm和GroupNorm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 介绍 Batch Norm: 对NHW计算归一化参数(均值和方差)，总共得到C组归一化参数, 相当于对每个channel进行归一化。BN主要缺点是对batchsize的大小比较敏感，由于每次计算均值和方差是在一个batch上，所以如果batchsize太小，则计算的均值、方差不足以代表整个数据分布Layer Norm: 对CHW计算归一化参数，得到N(batch)组归一化参数，对于Batch为1，相当于对整个Feature map 做归一化。主要对RNN及Transformer作用明显，不适应输入变化很大的数据，大Batch较差Instance Norm: 对HW计算归一化参数，总共输出N*C组归一化参数，相当于对每个channel和每个Batch都需要进行归一化。优点：适用图像风格迁移, 缺点：不适应通道之间的相关性较强数据。**GroupNorm：**将channel方向分group，然后每个group内做归一化，算(C//G)HW的均值；这样与batchsize无关，不受其约束 1.1 BatchNorm torch.nn.BatchNorm1d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) torch.nn.BatchNorm3d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) 参数：
num_features： 来自期望输入的特征数，该期望输入的大小为’batch_size x num_features [x width]’eps： 为保证数值稳定性（分母不能趋近或取0）,给分母加上的值。默认为1e-5。momentum： 动态均值和动态方差所使用的动量。默认为0.1。affine： 布尔值，当设为true，给该层添加可学习的仿射变换参数。track_running_stats：布尔值，当设为true，记录训练过程中的均值和方差； 实现公式：
1.2 GroupNorm torch.nn.GroupNorm(num_groups, num_channels, eps=1e-05, affine=True) 参数：
num_groups：需要划分为的groupsnum_features： 来自期望输入的特征数，该期望输入的大小为’batch_size x num_features [x width]’eps： 为保证数值稳定性（分母不能趋近或取0）,给分母加上的值。默认为1e-5。momentum： 动态均值和动态方差所使用的动量。默认为0.1。affine： 布尔值，当设为true，给该层添加可学习的仿射变换参数。 实现公式：
1.3 InstanceNorm torch.nn.InstanceNorm1d(num_features, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False) torch.nn.InstanceNorm2d(num_features, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False) torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e4227e52f69b85c925fb92538d2322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d454b3d36dec295a60b6a83b0ce8c821/" rel="bookmark">
			数据结构初阶（链表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、链表的基础概念二、无头单向非循环链表2.1 链表的底层代码2.2 单链表例题 三、无头双向非循环链表（LinkedList）（1）什么是LInkedList（2）LinkedList 构造方法（3）LinkedList 方法（4）LinkedLIst的使用 四 顺序存储和链式存储的区别 一、链表的基础概念 1.链表出现原理
为什么当插入和删除时，顺序表就要移动大量元素，因为相邻两元素的存储位置也具有邻居关系。它们编号是1，2，3 ,…, ，它们在内存中的位置也是挨着的，中间没有空隙， 当然就无法快速介入，而删除后，当中就会留出空隙，自然需要弥补
所以，链表是用于解决 ArrayList 中，插入、删除时间复杂度较大，且可能会浪费空间的问题
2.什么是链表
逻辑上是连续的，物理上(内存上)是不连续的，由一个个节点组成
对于线性表来说，总得有个头有个尾，链表也不例外。我们把链表中的第一个节点的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了，之后的每一个结点，其实就是上一个的后继指针指向的位置最后一个， 当然就意味着直接后继不存在了，所以我们规定，线性链表的最后一个结点指针为"空" 3.链表的分类
单向 / 双向
带头的 / 不带头的
循环 / 非循环
重点掌握
无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如
哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多
无头双向非循环链表：在Java的集合框架库中LinkedList底层实现就是无头双向循环链表
二、无头单向非循环链表 2.1 链表的底层代码 public class MyStringList { private ListNode head; class ListNode{ private int val; private ListNode next; public ListNode(int val) { this.val = val; } } public void creatList(){ ListNode node1 = new ListNode(12); ListNode node2 = new ListNode(24); ListNode node3 = new ListNode(36); ListNode node4 = new ListNode(48); node1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d454b3d36dec295a60b6a83b0ce8c821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc3355f9afb8402da0619fc6cde44424/" rel="bookmark">
			uni-app - App打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：使用的编辑器是Hbuilder X 进行的打包，左下角需要先登录账号，没有账号就注册一个账号，然后登录进去（开发者中心官网和Hbuilder X都登录一下），然后点击官网的个人中心中的账户信息，进行手机号码验证。
第一种：使用公共测试证书 1、选择需要打包的项目
2、点击发行
3、点击原生App-云打包
4、选择使用公共测试证书
5、Android包名可以自定义
6、点击右下角的 打包（P）
7、弹出打包校验---点击继续打包
8、等待打包完成就可以了，之后点击【打开所在目录】
9、对apk文件右键复制，粘贴至QQ，这样后缀名不会被更改
10、最后手机下载就可以了
第二种：使用自有证书 1、选择需要打包的项目
2、点击发行
3、点击原生App-云打包
4、选择使用自有证书
5、如果没有证书，点击右侧如何生成证书，根据文档安装JRE环境
可从Oracle官方下载jre安装包：https://www.oracle.com/java/technologies/downloads/#java8
6、下载好之后直接安装即可，注意：要记住安装的地址，等下配置环境变量时需要使用
7、配置环境变量：找到自己电脑中的高级系统设置
我的是在：此电脑----&gt;右键选择属性----&gt;高级系统设置
8、选择环境变量----&gt;系统变量中的path（双击）进入-----&gt;右侧新建----&gt;将刚刚安装地址复制到此
9、任意创建一个文件夹----&gt;在地址栏中输入cmd
10、生成签名证书（使用keytool -genkey命令生成证书）
keytool -genkey -alias testalias -keyalg RSA -keysize 2048 -validity 36500 -keystore test.keystore testalias是证书别名，可修改为自己想设置的字符，建议使用英文字母和数字test.keystore是证书文件名称，可修改为自己想设置的文件名称，也可以指定完整文件路径36500是证书的有效期，表示100年有效期，单位天，建议时间设置长一点，避免证书过期 回车后会提示：这是英文版也可能是中文版
Enter keystore password: //输入证书文件密码，输入完成回车 Re-enter new password: //再次输入证书文件密码，输入完成回车 What is your first and last name? [Unknown]: //输入名字和姓氏，输入完成回车 What is the name of your organizational unit? [Unknown]: //输入组织单位名称，输入完成回车 What is the name of your organization?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc3355f9afb8402da0619fc6cde44424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2fca1faa57b9cee5721901d85506568/" rel="bookmark">
			PostgreSQL入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速学会创建和管理数据库 当谈到数据库管理系统时，PostgreSQL是一个功能强大且广泛使用的开源关系型数据库。在本次讲解中，我将为您介绍如何创建和管理数据库，并提供一些有关PostgreSQL的基本概念和最佳实践的指导。
创建数据库 在开始之前，请确保您已经成功安装了PostgreSQL，并可以通过命令行或图形界面工具访问它。
要创建一个新的数据库，请按照以下步骤进行操作：
打开命令行终端或使用图形界面工具登录到PostgreSQL服务器。
输入以下命令以创建一个新数据库：
CREATE DATABASE database_name; 在这里，database_name是您想要创建的数据库的名称。您可以根据自己的需求选择一个合适的名称。
创建数据库后，您可以使用以下命令切换到新创建的数据库：
\c database_name; 这将使您当前的会话与指定的数据库关联起来，以便您可以执行与该数据库相关的操作。
管理数据库 一旦您创建了数据库，您可能需要进行一些管理操作，例如添加表、插入数据、执行查询等。以下是一些重要的概念和任务，涉及到PostgreSQL数据库的管理：
表和模式
表（Table）：表是数据库中的基本数据存储单位。您可以使用CREATE TABLE语句创建表，并定义表中的列和约束。 例如，以下命令用于创建一个名为users的表：
CREATE TABLE users ( id SERIAL PRIMARY KEY, name VARCHAR(100), email VARCHAR(100) ); 模式（Schema）：模式是数据库对象的逻辑容器，它们可帮助组织和管理数据库中的对象。每个模式可以包含表、视图、索引等。
例如，以下命令用于创建一个名为public的模式：
CREATE SCHEMA public; 数据操作
插入数据：要将数据插入到表中，您可以使用INSERT INTO语句。以下是一个示例： INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com'); 查询数据：要从表中检索数据，可以使用SELECT语句。以下是一个简单的查询示例：
SELECT * FROM users; 这将返回users表中的所有行。
数据库备份和恢复
为了确保数据的安全性，定期备份数据库是至关重要的。PostgreSQL提供了几种备份和恢复数据库的方法，其中一种常用的方法是使用pg_dump和pg_restore工具。 备份数据库：要备份整个数据库，可以使用以下命令：
pg_dump -U username -d database_name -f backup.sql 这将生成一个名为backup.sql的文件，其中包含整个数据库的结构和数据。
恢复数据库：要恢复数据库，可以使用以下命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2fca1faa57b9cee5721901d85506568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec32b3e95876685ade8b562cfb803603/" rel="bookmark">
			基于JAVA&#43;SpringBoot&#43;Mybatis&#43;MYSQL的养老院管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍：
账号管理：管理员账号，用户账号健康管理：健康档案，病例档案，药品管理生活管理：每月餐饮，外出报备入住管理：入住登记，寝室分配安全管理：事故记录，访客记录收费标准：入住费用，护理费用 页面效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f0bfe0da979e6b401702dbe9da2cf4c/" rel="bookmark">
			基于JAVA&#43;SpringMVC&#43;Mybatis&#43;MYSQL的同城搬家管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目功能：
用户端：
登录注册搬家需求留言反馈个人中心我的收藏预约搬家我的订单我的留言退出系统 管理员端：
系统登录个人中心用户管理搬家公司管理城市信息管理搬家需求管理订单信息管理留言板管理我的收藏管理退出系统 搬家公司：
系统登录个人中心城市信息管理搬家需求管理订单信息管理退出系统 页面效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e08306b36b9409406771deae6486d2/" rel="bookmark">
			面试：浏览器的本地存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器的本地存储主要分为Cookie、WebStorage和IndexDB, 其中WebStorage又可以分为localStorage和sessionStorage。
共同点: 都是保存在浏览器端、且同源的
不同点：
cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。
存储大小限制也不同，
cookie数据不能超过4K，sessionStorage和localStorage可以达到5M
sessionStorage：仅在当前浏览器窗口关闭之前有效；
localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；
cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
作用域不同
sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；
localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在
cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f469e69d32b540158c86b4d92faa24/" rel="bookmark">
			centos7上安装redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、直接单机版安装 1、Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖
yum install -y gcc tcl 2、官网上下载依赖包来安装，官网地址
直接官网上下载，上传到服务器上，下载地址
直接使用wget的方式下载
wget https://shuiping.oss-cn-shenzhen.aliyuncs.com/redis-6.2.6.tar.gz 3、把文件放在/usr/local/src目录下
4、解压文件
tar -xzf redis-6.2.6.tar.gz 5、进入解压后的文件夹下，编译安装
make &amp;&amp; make install 6、默认的安装路径是在 /usr/local/bin目录下
redis-cli：是redis提供的命令行客户端redis-server：是redis的服务端启动脚本redis-sentinel：是redis的哨兵启动脚本 7、直接启动
./redis-server 8、进入redis-cli中查看版本号
[root@iZwz9et2qekjwu8mwmxgxhZ bin]# ./redis-cli 127.0.0.1:6379&gt; info server # Server redis_version:6.2.6 redis_git_sha1:00000000 redis_git_dirty:0 redis_build_id:a90324d212372b79 redis_mode:standalone os:Linux 3.10.0-957.21.3.el7.x86_64 x86_64 arch_bits:64 multiplexing_api:epoll atomicvar_api:atomic-builtin gcc_version:4.8.5 process_id:27941 process_supervised:no run_id:156053feefd85fba87a4e027dc72fa8fbae4df95 tcp_port:6379 server_time_usec:1689563133774537 uptime_in_seconds:20 uptime_in_days:0 hz:10 configured_hz:10 lru_clock:11841533 executable:/usr/local/bin/./redis-server config_file: io_threads_active:0 127.0.0.1:6379&gt; 9、使用配置文件启动，并且再后台启动，配置文件的路径/usr/local/src/redis-6.2.6下的redis.conf文件
10、先拷贝一份
cp redis.conf redis.conf.bck 11、然后修改redis.conf文件中的一些配置
# 允许访问的地址，默认是127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80f469e69d32b540158c86b4d92faa24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1868dfa767be59240a52db1741093103/" rel="bookmark">
			亲测有效！！解决MySQL8误删root账号无法登录的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲测有效！！解决MySQL8误删root账号无法登录的问题 前言1. 进入cmd ,停止MySQL服务 net stop mysql2. 输入： mysqld --console --skip-grant-tables --shared-memory3.另外开一个cmd，使用mysql直接无密登录 mysql -u root –p（在enter password时直接回车即可）4.修改密码5.试验用密码登录，发现登录成功 前言 本人在做项目的过程中，不小心误删了本地MySQL的root账号，心急如焚，但是好在数据库的data都有备份，那想办法能找回账号成功登录就好了。下面是我亲测有效的一种办法，希望可以帮助到大家！！
本解决方法参考自：简书一文
如果遇到其他问题也可以在评论区互相交流，感谢小伙伴的大力支持！如果切实解决了你的问题的话，点个赞支持一下吧，希望可以高效解决大家问题。
1. 进入cmd ,停止MySQL服务 net stop mysql 方法1：可以打开服务（win+R），输入services.msc，进去之后找到MySQL服务，停止。
方法2：找到本地MySQL的bin目录下，以管理员身份运行cmd，输入以下命令：
Microsoft Windows [版本 10.0.14393] (c) 2016 Microsoft Corporation。保留所有权利。 C:\Users\Administrator&gt;net stop mysql MySQL 服务正在停止. MySQL 服务已成功停止。 C:\Users\Administrator&gt; 2. 输入： mysqld --console --skip-grant-tables --shared-memory C:\Users\Administrator&gt;mysqld --console --skip-grant-tables --shared-memory 2022-09-08T05:24:08.165351Z 0 [System] [MY-010116] [Server] D:\mysql\bin\mysqld.exe (mysqld 8.0.22) starting as process 6852 2022-09-08T05:24:08.167088Z 0 [Warning] [MY-013242] [Server] --character-set-server: 'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1868dfa767be59240a52db1741093103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ebb10508a02f537eb33cad0df421c05/" rel="bookmark">
			Android自定义圆环进度条/刻度仪表盘(单环单点带进度动画)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图: 1.自定义SleepDashBoardView /** * 睡眠刻度仪表盘 */ public class SleepDashBoardView extends View { private static final float START_ANGLE = 135f; private static final float MAX_ANGLE = 270f; private float progress = 0; private float centerX; private float centerY; private float width; private float height; private int lineWidth = dp2px(8); // 绘制圆环的线宽 private int pointWidth = dp2px(2); // 绘制圆点线宽 private int rectangleWidth = dp2px(1); // 绘制矩形的线宽 private SweepGradient sweepGradient; private Paint paint = new Paint(Paint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ebb10508a02f537eb33cad0df421c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c3a600e8f129ee9534bd190ca1c47b/" rel="bookmark">
			element ui固定在下方‘合计行‘实现，并且可点击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图
代码
// 首先在el-table增加element ui的自带属性（:summary-method="getSummaries" show-summary） &lt;el-table :data="tablep_115.data" id="tablep_115" border :style="conheight" height="200" @selection-change="tablep_115_Change" default-expand-all :summary-method="getSummaries" show-summary &gt; // 事件 getSummaries(param) { let $this = this console.log('合计',param) const { columns, data } = param; const sums = []; columns.forEach((column, index) =&gt; { if (index === 0) { sums[index] = '合计'; return; } else if(index == 1 ){ $(".el-table__footer").find("td").eq(1).click(()=&gt;{ // 此处定义行里面的点击事件 }) } const values = data.map(item =&gt; Number(item[column.property])); if (!values.every(value =&gt; isNaN(value))) { sums[index] = values.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70c3a600e8f129ee9534bd190ca1c47b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01abd5cafc73d75a41768f8efe25c737/" rel="bookmark">
			Git 常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git 常见问题 Git 常见问题分支没有跟踪信息通常错误信息提示如下：解决方案 Git 常见问题 分支没有跟踪信息 如果在执行 git pull 时出现这个错误信息,通常是因为当前分支没有设置跟踪信息,Git不知道应该去哪个远程分支拉取代码。
通常错误信息提示如下： There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt; If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; dev 解决方案 这个可以通过以下几步来解决:
查看当前分支: git branch 这会显示出当前所在的分支,例如 dev
2. 设置跟踪信息:
git branch --set-upstream-to=origin/dev dev 这个命令是设置 dev 分支跟踪 origin 远程的 dev 分支。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01abd5cafc73d75a41768f8efe25c737/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/44/">«</a>
	<span class="pagination__item pagination__item--current">45/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/46/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>