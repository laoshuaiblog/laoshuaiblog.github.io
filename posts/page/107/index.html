<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85f232b7e4779206416637c967ff3f96/" rel="bookmark">
			pymssql查询表数据返回 ASCII 码值b&#39;\x01\x00\x00\x00&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在查询SqlServer中表数据时返回结果出现b'\x01\x00\x00\x00'，列类型为sql_variant、经过搜索一番，查询该类型列数据需要转换为字符串才可以，如：
CONVERT(VARCHAR(40,列名)) 另外对于日期格式可能也会出现该问题，解决方法也是如此。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc80d29b9fce3790d72a562b2ab17e15/" rel="bookmark">
			python pandas df.loc[]的典型用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pandas中的df.loc[]主要是根据DataFrame的行标和列标进行数据的筛选的，如下图红框部分所示：
其接受两个参数：行标和列标，当列标省略时，默认获取整行数据。两个参数都可以以字符，切片以及列表的形式传入。
&gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; df = pd.read_excel(r'D:/myExcel/1.xlsx', index_col='id') &gt;&gt;&gt; df name score grade id a bog 45 A c jiken 67 B d bob 23 A b jiken 34 B f lucy 98 A e tidy 75 B # 指定行标'a'以及'f'行，第二个参数省略，则获取整行 &gt;&gt;&gt; df.loc[['a', 'f']] name score grade id a bog 45 A f lucy 98 A # 以切片形式传入，会按照df中的顺序获取 # 此处需要注意，并不是只获取'a', 'b'行 # 在df中'a', 'b'两行中还包含'c', 'd'行 # 会一并获取 &gt;&gt;&gt; df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc80d29b9fce3790d72a562b2ab17e15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b783d1cc3602bfffc9e608b475e1450/" rel="bookmark">
			Oracle Caused by: java.sql.SQLException: sql injection violation, syntax error: syntax error, expect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/qq_36326332/article/details/102938147
https://blog.csdn.net/fly_captain/article/details/82144789
一、mybatis的sql信息 select model.WIRE_MODEL from IDS_WIRE_MODEL model left join IDS_SIGNAL_TYPE type on model.SIGNAL_TYPE_ID = type.id where type.SIGNAL_TYPE = #{signalType,jdbcType=VARCHAR} 二、报错信息 Exception in thread "AWT-EventQueue-0" org.springframework.jdbc.UncategorizedSQLException: ### Error querying database. Cause: java.sql.SQLException: sql injection violation, syntax error: syntax error, expect DIMENSION, actual LEFT, pos 252, line 6, column 37, token LEFT : -- select m.WIRE_MODEL -- from IDS_WIRE_MODEL m -- left join IDS_SIGNAL_TYPE t on m.SIGNAL_TYPE_ID = t.id -- where t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b783d1cc3602bfffc9e608b475e1450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac9665e92a86d19bdb40578dc6bf9b0/" rel="bookmark">
			平滑滤波算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己项目中经常需要对一维时间序列进行滤波处理（保留原始信号，消除噪声信号），这里做些总结，一方面总结知识，另外帮助他人
1.常用滤波技术
1.1.均值滤波（待续）
1.2.中值滤波（待续）
1.3.高斯滤波法（待续）
1.4.指数平滑（待续）
2.复杂滤波方法
2.1.STL分解(待续)
STL全称 基于损失的季节性趋势分解过程，此算法思想 一些随时间变化的信号由三种信号组合而成，他们分别是 趋势（trend）、季节（seasonal）和残差（residue）,因此，此技术将时间序列信号分解为上面的三个部分。
（待续）
2.2.光滑样条（待续）
2.3.最小二乘拟合残差法（待续）
SG平滑滤波（多项式平滑算法）
2.4.样条拟合残差法（待续）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df461d18086fa5bcd029dcccc593a7d3/" rel="bookmark">
			Java消息机制ActiveMQ入门实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载ActiveMQ 去官方网站下载：http://activemq.apache.org/
这里使用 ActiveMQ 5.1.0 Release版
2.运行ActiveMQ 解压缩apache-activemq-5.10.0-bin.tar.gz，然后双击apache-activemq-5.10.0\bin\activemq.jar运行ActiveMQ程序。
启动
java -jar activemq.jar start 启动ActiveMQ以后，登陆：http://localhost:8161/admin/，创建一个Queue，命名为FirstQueue。
登录需要账号密码：默认的账号和密码 admin/admin
创建一个Queue，命名为FirstQueue
3.创建Eclipse项目并运行 创建java project：ActiveMQ-5.10，新建lib文件夹
打开apache-activemq-5.10.0\lib目录
拷贝
activemq-broker-5.10.0.jar
activemq-client-5.10.0.jar
geronimo-j2ee-management_1.1_spec-1.0.1.jar
geronimo-jms_1.1_spec-1.1.1.jar
slf4j-api-1.7.5.jar
这5个jar文件到lib文件夹中,并Build Path-&gt;Add to Build Path
4.编写代码 Sender.java
package com.dowhere.activemq; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.DeliveryMode; import javax.jms.Destination; import javax.jms.MessageProducer; import javax.jms.Session; import javax.jms.TextMessage; import org.apache.activemq.ActiveMQConnection; import org.apache.activemq.ActiveMQConnectionFactory; public class Sender { private static final int SEND_NUMBER = 5; public static void main(String[] args) { // ConnectionFactory ：连接工厂，JMS 用它创建连接 ConnectionFactory connectionFactory; // Connection ：JMS 客户端到JMS // Provider 的连接 Connection connection = null; // Session： 一个发送或接收消息的线程 Session session; // Destination ：消息的目的地;消息发送给谁.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df461d18086fa5bcd029dcccc593a7d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5deac0355b57086d78b89a14d316cf/" rel="bookmark">
			水仙花数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
输入整数n，求小于n的水仙花数（n&lt;1000）。所谓“水仙花数”是指一个三位正整数ABC，其各位数字的立方和等于该数本身，即
例如，370是一个水仙花数，因为
输入要求
输入一个正整数n(n&lt;1000)
输出要求
输出小于n的所有水仙花数。如果该范围内部不存在水仙花数，则输出No Answer。
输入样例
400
输出样例
153
370
371
#include &lt;stdio.h&gt; int main() { int i,j,k,n=100,x,y=0; scanf("%d",&amp;x); for(;n&lt;x;n++) { i=n/100; j=(n-i*100)/10; k=n-i*100-j*10; if(n==i*i*i+j*j*j+k*k*k) printf("%d\n",n),y=y+1; } if(y==0) printf("No Answer\n"); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b47814ca2192e8ec05dc938526bf985/" rel="bookmark">
			MATLAB基础题（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.已知数组A=[1，2，34，-100；5，9，-20，10；21，-20，34，68]，现需要把数组中大于0的数求平方根、素小于0的数求绝对值。
代码：
A=[1,2,34,-100;5,9,-20,10;1,-20,34,68];
B=A&gt;0;
C=A.*B;
E=sqrt©;
D=A&lt;0;
F=A.*D;
I=abs(F);
W=E+I;
num2str(W)
截图：
2 编写一个函数，求Sn=a+aa+aaa+…+aa…a的值，其中a是一个数字，由键盘输入，表达式中位数最多项a的个数，也由键盘输入。例如：输入a=3,n=4.
代码：函数文件
function Sn=no(a,n)
Sn=0;
for i=1:n
x=a^i;
Sn=Sn+x;
end
end
实现文件
a=input(‘请输入a的值’);
n=input(‘请输入n的值’);
Sn=no(a,n)
截图：
3若一个数等于它的各个真因子之和，这个数就被称为完数。比如6=3+2+1。用MATLAB编写程序实现任意范围內的完数查询。
代码：
m= input(‘请输入m的值:’)%%最小值
n= input(‘请输入n的值:’)%%最大值
for a = m:n
k = 0;
for i = 1:a/2
if rem(a,i) ==0
k = k + i;
end
end
if k == a
a
end
end
截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf808df5c96ad984f2a308415a5894e6/" rel="bookmark">
			SpringCloud：Eureka微服务跨分区调用region、zone、gateway
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PS：未经测试，后补
目的 系统为分区架构，减少中心化服务，避免单点风险。
region1和region2为完全独立分区，分区数据无交集，互不依赖。
region1中的处理由于特殊原因用到region2中的服务，需要提供技术支持。
思路 新架构不影响独立region内部架构region直接互不影响通过gateway处理转发逻辑并进行转发，如果是同一个region直接路由到内部微服务，如果是另一个region则通过调用其他region的网关路由到其微服务。 架构设计 原始架构 需求架构 设计架构 技术实现 eureka server配置 gateway的独立region注册中心 spring: application: name: eureka-server eureka: client: region: region0 #独立区域 availability-zones: region0: zone-0 #内部集群 region1: zone-1 region2: zone-2 service-url: zone-0: http://localhost:9001/eureka,http://localhost:9002/eureka zone-1: http://localhost:9001/eureka zone-2: http://localhost:9002/eureka provider1的独立region注册中心 spring: application: name: eureka-server eureka: client: region: region1 #独立区域 availability-zones: region0: zone-0 #内部集群 region1: zone-1 region2: zone-2 service-url: zone-0: http://localhost:9001/eureka,http://localhost:9002/eureka zone-1: http://localhost:9001/eureka zone-2: http://localhost:9002/eureka provider2的独立region注册中心 spring: application: name: eureka-server eureka: client: region: region2 #独立区域 availability-zones: region0: zone-0 #内部集群 region1: zone-1 region2: zone-2 service-url: zone-0: http://localhost:9001/eureka,http://localhost:9002/eureka zone-1: http://localhost:9001/eureka zone-2: http://localhost:9002/eureka eureka client配置 gateway注册 spring: application: name: gateway eureka: instance: metadata-map: zone: zone-0 #归属zone，优先调用zone-0 client: region: region0 availability-zones: region0: zone-1 region1: zone-1 region2: zone-2 service-url: zone-0: http://localhost:9001/eureka,http://10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf808df5c96ad984f2a308415a5894e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e8a8ad78ff01ffbf895cef1ca635264/" rel="bookmark">
			三极管之多谐振荡LED流水灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 多谐振荡器 多谐振荡器：利用深度正反馈，通过阻容耦合使两个电子器件交替导通与截止，从而自激产生方波输出的振荡器。常用作方波发生器。多谐振荡器是一种能产生矩形波的自激振荡器，也称矩形波发生器。在接通电源后，不需要外加脉冲就能自动产生矩形脉冲！
多谐振荡器是一种能产生矩形波的自激振荡器，也称矩形波发生器。“多谐”指矩形波中除了基波成分外，还含有丰富的高次谐波成分。多谐振荡器没有稳态，只有两个暂稳态。在工作时，电路的状态在这两个暂稳态之间自动地交替变换，由此产生矩形波脉冲信号，常用作脉冲信号源及时序电路中的时钟信号。
1.1 简单的振荡电路 双三极管振荡电路
改电路可以在Q1和Q2的集电极产生一个接近方波的波形，其中Q1和Q2的集电极输出波形互为反相。
1.2原理分析 通上电的瞬间，Q1和Q2会争相导通，但是由于Q1和Q2的元件的差异，即使一样的型号也会存在差异，Q1和Q2会有一个先导通，另一个不导通。
状态一：
Q1导通，Q1的集电极电压为接近0V，C1由流经R2及Q1_CE的电流放电，由于电容C1提供反电压，Q2的基级电压为负使得Q2截止，C2经由R4及Q1_BE充电，输出电压为高（但因C2经由R4充电的缘故，较电源电压稍低）。此状态一直持续到C1放电完成。由于R2提供基极偏置使得Q2导通：此电路进入状态二。
状态二：
Q2导通，Q2的集电极电压（即是输出电压）由高电位变为接近0V，由于电容C2提供反电压，使Q1瞬间截止，Q1截止，使得Q1集电极电压上升到高电位，C1经由R1及Q2_BE充电，C2流经R3以及Q2_CE的电流放电，由于电容C2提供反电压，使得Q1截止。
此状态一直持续到直到C2放电完毕，由于R3对Q1基极提供偏置电压，Q1导通：此电路进入状态一。
由上可知，Q1的导通时间为C1放电再充电到电压可以导通Q2为止，Q2也一样。
Q1的导通时间估计为：T = 0.7*C1*R2;
Q2的导通时间估计为：T = 0.7*C2*R3；
若将R1和R4换为两个LED即可得到交替闪烁的灯光。
2 常见的振荡器流水灯 2.1 2.2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c598da7d690d9f09a66cad8a87c67706/" rel="bookmark">
			深入理解Batch Normalization原理与作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.为什么需要Normalization 深度学习网络模型训练困难的原因是，cnn包含很多隐含层，每层参数都会随着训练而改变优化，所以隐层的输入分布总会变化，每个隐层都会面临covariate shift的问题。
internal covariate shift（ICS）使得每层输入不再是独立同分布。这就造成，上一层数据需要适应新的输入分布，数据输入激活函数时，会落入饱和区，使得学习效率过低，甚至梯度消失。
2.Normalization的基本思想 由于cnn层数多，ICS会使激活输入分布偏移，落入饱和区，导致反向传播时出现梯度消失，这是训练收敛越来越慢的本质原因。而BN就是通过归一化手段，将每层输入强行拉回均值0方差为1的标准正态分布，这样使得激活输入值分布在非线性函数梯度敏感区域，从而避免梯度消失问题，大大加快训练速度。
如上图，sigmoid函数，BN使输入值分布在-1~1之间，在此区间梯度值大，有效避免梯度消失并提高收敛速度。
但是，归一化后，激活输入值均被分布于-1~1之间，这会导致非线性程度降低，夸张一点说，其实输入域的分布把原来的非线性函数转变成了线性函数。这意味着网络的表达能力下降了。因此BN为了保证非线性，对变换后的满足均值为0方差为1的x又进行了scale shift操作，即y=scale*x+shift。这两个参数通过训练获得，其实又将输入分布在标准正态分布的基础上进行了平移。其实就是为了在线性与非线性间找到平衡，让泛化能力与收敛能力最大程度的体现。
3、BN中均值、方差通过哪些维度计算得到？ 神经网络中传递的张量数据，其维度通常记为[N, H, W, C]，其中N是batch_size，H、W是行、列，C是通道数。那么上式中BN的输入集合就是下图中蓝色的部分。
均值的计算，就是在一个批次内，将每个通道中的数字单独加起来，再除以 N×W×H。举个例子：该批次内有10张图片，每张图片有三个通道RBG，每张图片的高、宽是H、W，那么均值就是计算10张图片R通道的像素数值总和除以 10×W×H，再计算B通道全部像素值总和除以10×W×H，最后计算G通道的像素值总和除以10×W×H。方差的计算类似。可训练参数 γ , β \gamma,\beta γ,β 的维度等于张量的通道数，在上述例子中，RBG三个通道分别需要一个 γ \gamma γ 和一个 β \beta β ，所以 γ , β \gamma,\beta γ,β 的维度等于3。
4.训练BatchNorm 每层BN参数是根据特征图的channel数来确定的。
5.BatchNorm推理（Inference） 推理时，均值、方差是基于所有批次的期望计算所得，公式如下：
有了均值和方差，每个隐层神经元也已经有对应训练好的Scaling参数和Shift参数，就可以在推导的时候对每个神经元的激活数据计算NB进行变换了，在推理过程中进行BN采取如下方式：
beta、gamma在训练状态下，是可训练参数，在推理状态下，直接加载训练好的数值。moving_mean、moving_var在训练、推理中都是不可训练参数，只根据滑动平均计算公式更新数值，不会随着网络的训练BP而改变数值；在推理时，直接加载储存计算好的滑动平均之后的数值，作为推理时的均值和方差。
滑动平均，储存固定个数Batch的均值和方差，不断迭代更新推理时需要的E(x),Var(x)。
6.BatchNorm的作用 1.加快收敛速度，有效避免梯度消失。
2.提升模型泛化能力，BN的缩放因子可以有效的识别对网络贡献不大的神经元，经过激活函数后可以自动削弱或消除一些神经元。另外，由于归一化，很少发生数据分布不同导致的参数变动过大问题。
最后还想谈一谈Instance normalization BN适用于判别模型中，比如图片分类模型。因为BN注重对每个batch进行归一化，从而保证数据分布的一致性，而判别模型的结果正是取决于数据整体分布。但是BN对batchsize的大小比较敏感，由于每次计算均值和方差是在一个batch上，所以如果batchsize太小，则计算的均值、方差不足以代表整个数据分布；
IN适用于生成模型中，比如图片风格迁移，GAN等。因为图片生成的结果主要依赖于某个图像实例，所以对整个batch归一化不适合图像风格化中，在风格迁移中使用Instance Normalization不仅可以加速模型收敛，并且可以保持每个图像实例之间的独立。
上图中，从C方向看过去是指一个个通道，从N看过去是一张张图片。每6个竖着排列的小正方体组成的长方体代表一张图片的一个feature map。蓝色的方块是一起进行Normalization的部分。由此就可以很清楚的看出，Batch Normalization是指6张图片中的每一张图片的同一个通道一起进行Normalization操作。而Instance Normalization是指单张图片的单个通道单独进行Noramlization操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430cf58a2fbb7df0465307f68067a3e5/" rel="bookmark">
			硬件I2C实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1配置GPIO和I2C模式 1，使能GPIOB，I2C1
RCC-&gt;APB2ENR|=1&lt;&lt;3;//使能GPIOB
RCC-&gt;APB1ENR|=1&lt;&lt;21;//使能I2C1
GPIOB-&gt;CRL&amp;=~((u32)0x0F&lt;&lt;4*6); GPIOB-&gt;CRL|=((u32)0x0F&lt;&lt;4*6);//配置PB6为复用开漏输出 GPIOB-&gt;CRL&amp;=~((u32)0x0F&lt;&lt;4*7); GPIOB-&gt;CRL|=((u32)0x0F&lt;&lt;4*7);//配置PB7为复用开漏输出 I2C_InitStructure.I2C_Ack=I2C_Ack_Enable; I2C_InitStructure.I2C_AcknowledgedAddress=I2C_AcknowledgedAddress_7bit; I2C_InitStructure.I2C_ClockSpeed=400000; I2C_InitStructure.I2C_DutyCycle=I2C_DutyCycle_2; I2C_InitStructure.I2C_Mode=I2C_Mode_I2C; I2C_InitStructure.I2C_OwnAddress1=0x3EF; I2C_Init(I2C1,&amp;I2C_InitStructure);//配置i2c1模式 I2C_Cmd(I2C1,ENABLE);//使能I2C 2.写单页（不超过8个字节）
while(I2C_GetFlagStatus(I2C1,I2C_FLAG_BUSY))//判断总线是否忙碌 { if((I2C_Timeout--)==0)return I2C_TIMEOUT_UserCallPack(1); } I2C_GenerateSTART(I2C1,ENABLE);//发送起始信号 I2C_Timeout=I2CT_FLAG_Timeout; while(!(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)))//检查事件EV5（事件主机模式选择） { if((I2C_Timeout--)==0)return I2C_TIMEOUT_UserCallPack(2); } I2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Transmitter);//发送地址，模式发送 I2C_Timeout=I2CT_FLAG_Timeout; while(!(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)))//（检测事件EV6，主机发送模式已选择） { if((I2C_Timeout--)==0)return I2C_TIMEOUT_UserCallPack(3); } I2C_SendData(I2C1,WriteAddr);//发送写入地址 I2C_Timeout=I2CT_FLAG_Timeout; while(!(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)))//（检测事件EV8，主机数据已发送） { if((I2C_Timeout--)==0)return I2C_TIMEOUT_UserCallPack(4); } for(i=0;i&lt;NumToWrite;i++) { I2C_SendData(I2C1,pBuffer[i]); //发送数据 I2C_Timeout=I2CT_FLAG_Timeout; while(!(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)))//（检测事件EV8，主机数据已发送） { if((I2C_Timeout--)==0)return I2C_TIMEOUT_UserCallPack(5); } } I2C_GenerateSTOP(I2C1,ENABLE);//发送结束信号 3接受数据
u32 EEPROM_Byte_Read(u8 ReadAddr,u8 *pBuffer,u8 NumToRead)
{
u8 i;
I2C_Timeout=I2CT_LONG_Timeout;
while(I2C_GetFlagStatus(I2C1,I2C_FLAG_BUSY))//检查总线忙碌状态 { if((I2C_Timeout--)==0)return I2C_TIMEOUT_UserCallPack(6); } I2C_GenerateSTART(I2C1,ENABLE);//发送起始信号 I2C_Timeout=I2CT_FLAG_Timeout; while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/430cf58a2fbb7df0465307f68067a3e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e25cf5aee3ee2b6c0b9499770c1e9ac1/" rel="bookmark">
			请问如何在Origin点线图误差棒上添加显著性标记,如下图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/017ed5d694574090ee93d4e56781f64c/" rel="bookmark">
			在pom.xml的build中配置resources,防止资源导出失败的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3260e1ec8ba9dee5f2b4b8c78c57658b/" rel="bookmark">
			异步复位同步释放 打两拍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同步复位问题：复位信号持续时间太短，在clk下没采集到就没了。
异步复位问题：释放时可能会出现亚稳态（见最后两张图）。
文章目录 1. 异步复位2. 同步复位3. 异步复位同步释放 今天好好理一理异步复位，同步复位，以及亚稳态中的异步复位同步释放。
1. 异步复位 一般让复位信号低电平有效
复位信号不受时钟的控制，只要复位信号有效，那么电路就会复位。对应的写法为：
always @ （posedge clk or negedge rst_n） begin if (!rst_n) xxxx; else if (xx) begin xxxx; xxxx; end end 注意，在此always块中，敏感量为两个，一个是clk的上升沿（posedge clk），一个是复位信号rst_n的下降沿（negedge rst_n），当复位信号下降沿出现时，不论clk在什么状态，都执行always块，即复位！
2. 同步复位 同步复位，即如果复位信号有效，则只能在时钟上升沿让电路复位。对应写法为：
always @ (posedge clk) begin if (!rst_n) xxxx; end 注意，在此always块中，敏感量只有一个，即clk的上升沿，此含义是，只有在clk的上升沿才能执行always块，否则不执行。于是如果复位信号有效，也只能等到clk上升沿才能执行always块，才能使电路复位！
3. 异步复位同步释放 什么同步释放不同步释放之类的，说得那么高大上的，搞得云里雾里的，其实也下面一行字就能解释清楚：
为了避免亚稳态，让拉高的复位信号打两拍，达到与时钟clk同步的目的
以上就是同步释放，可见只是拉高的信号打两拍，拉低的信号，也就是复位信号有效的时候，该复位就复位，该干嘛干嘛，我们不用去管它。
以下是解释：
假设复位信号低电平有效rst_n，当复位信号无效时，也就是复位信号拉高时，即为复位信号的释放。
由于异步复位信号与时钟无必然联系，两者都是独立的，所以复位信号的拉高将有一定的概率导致电路出现亚稳态。
对于亚稳态的处理，通常是利用同步器进行同步，使其输出能够受到时钟clk的控制。也就是说，同步器的输出最终与时钟clk同步。另外，同步器的另一个口语化表达为：“打两拍”，通过两个D触发器，最终得到与时钟同步的信号。
至于为什么需要两个D触发器而不是一个，请移步论文《异步复位设计中的亚稳态问题及其解决方案》，提取码ejjr
至于为什么需要两个D触发器而不是更多，是因为两个就已经够用了。
那么将异步的复位信号打两拍，不就能够解决亚稳态的问题了吗？换句话说，复位信号有效的时候，我们不去管任何东西，系统复位让它复位就好了；之后在复位信号拉高的时候可能导致亚稳态的出现，那直接将拉高的信号打两拍，不就完事了吗？就是这么简单。
经典的异步复位同步释放代码如下
module asyn_reset( clk	, rst_n	, rst_s2 ); input clk	; input rst_n	; output reg rst_s2; reg rst_s1; always @ (posedge clk or negedge rst_n) begin if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3260e1ec8ba9dee5f2b4b8c78c57658b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc3561fb9989b2744aef6f709190c4cb/" rel="bookmark">
			python连接sftp进行文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python连接sftp进行文件操作 1、sftp部署 1）添加用户
[root@docker ~]#groupadd ftpuser [root@docker ~]#useradd -g ftpuser -s /sbin/nologin -M ftpuser [root@docker ~]#passwd ftpuser [root@docker ~]#cd /home &amp;&amp; mkdir ftpuser [root@docker home]#chown root:ftpuser ftpuser [root@docker home]#chmod 755 ftpuser [root@docker home]#mkdir sftpdata &amp;&amp; chown ftpuser:ftpuser ./sftpdata 2）修改配置文件
[root@docker ~]#vim /etc/ssh/sshd_config #修改Subsystem sftp /usr/libexec/openssh/sftp-server为以下 Subsystem sftp	internal-sftp #增加以下 Match User sftp X11Forwarding no AllowTcpForwarding no ForceCommand internal-sftp [root@docker ~]#service sshd reload 2、python连接sftp import paramiko transport = paramiko.Transport(("101.202.2.25", 22)) # 获取Transport实例 transport.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc3561fb9989b2744aef6f709190c4cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3327cf1d32993e6751413d3bf907993a/" rel="bookmark">
			Collectors.toMap报错 ：Duplicate key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种写法:使用Collectors.toMap的方法，如果key重复会直接报错
第二种写法: 使用mergeFunction参数，可以取重复的key中的第一个或最后一个
方案1:#使用Collectors.toMap的方法，如果key重复会直接报错 List&lt;TpLifecircleConsumeDO&gt; list = new ArrayList&lt;&gt;(); TpLifecircleConsumeDO tpLifecircleConsumeDO = new TpLifecircleConsumeDO(); TpLifecircleConsumeDO tpLifecircleConsumeDO2 = new TpLifecircleConsumeDO(); tpLifecircleConsumeDO.setOrderSn("123"); tpLifecircleConsumeDO.setOrderSumprice(new BigDecimal("2.1")); list.add(tpLifecircleConsumeDO); tpLifecircleConsumeDO2.setOrderSn("123"); tpLifecircleConsumeDO2.setOrderSumprice(new BigDecimal("2.1")); list.add(tpLifecircleConsumeDO2); 方案1:#使用Collectors.toMap的方法，如果key重复会直接报错 Map&lt;String, TpLifecircleConsumeDO&gt; consumeDOMap = list.stream().distinct().collect(Collectors.toMap(TpLifecircleConsumeDO::getOrderSn, consumeDo -&gt; consumeDo)); System.out.println(consumeDOMap); Exception in thread "main" java.lang.IllegalStateException: Duplicate key TpLifecircleConsumeDO[id=&lt;null&gt;,ext1=&lt;null&gt;,ext2=&lt;null&gt;,ext3=&lt;null&gt;,ext4=&lt;null&gt;,token=&lt;null&gt;,openid=&lt;null&gt;,remark=&lt;null&gt;,orderSn=123,bankType=&lt;null&gt;,discount=&lt;null&gt;,payToken=&lt;null&gt;,callBackUrl=&lt;null&gt;,merchantOrderSn=&lt;null&gt;,uid=&lt;null&gt;,mode=&lt;null&gt;,type=&lt;null&gt;,mchid=&lt;null&gt;,redId=&lt;null&gt;,userId=&lt;null&gt;,agentId=&lt;null&gt;,channel=&lt;null&gt;,payTime=&lt;null&gt;,payType=&lt;null&gt;,storeId=&lt;null&gt;,markread=&lt;null&gt;,printNum=&lt;null&gt;,redPreId=&lt;null&gt;,cashierId=&lt;null&gt;,payStatus=&lt;null&gt;,createTime=&lt;null&gt;,discountId=&lt;null&gt;,refundStatus=&lt;null&gt;,rechargeactId=&lt;null&gt;,preferentialId=&lt;null&gt;,repairOrderStatus=&lt;null&gt;,updateTimeAuto=&lt;null&gt;,fee=&lt;null&gt;,refund=&lt;null&gt;,cashFee=&lt;null&gt;,rateFee=&lt;null&gt;,redMoney=&lt;null&gt;,couponFee=&lt;null&gt;,orderPrice=&lt;null&gt;,commissionFee=&lt;null&gt;,discountMoney=&lt;null&gt;,orderSumprice=2.1,autowipingzero=&lt;null&gt;,additionalPrice=&lt;null&gt;,commissionRateFee=&lt;null&gt;,rechargeactAmount=&lt;null&gt;,preferentialAmount=&lt;null&gt;] at java.util.stream.Collectors.lambda$throwingMerger$0(Collectors.java:133) at java.util.HashMap.merge(HashMap.java:1254) at java.util.stream.Collectors.lambda$toMap$58(Collectors.java:1320) at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169) at java.util.stream.DistinctOps$1$2.accept(DistinctOps.java:175) at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) at com.fshows.lifecircle.datacore.service.facade.impl.MonthlyTableFacadeImpl.main(MonthlyTableFacadeImpl.java:554) 方案2: 使用mergeFunction参数，可以取重复的key中的第一个或最后一个 Map&lt;String, TpLifecircleConsumeDO&gt; consumeDOMap = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3327cf1d32993e6751413d3bf907993a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1500adf5f525f656be2af521626985be/" rel="bookmark">
			【Unity】在Inspector上显示自定义的位掩码枚举（Flags）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Unity】在Inspector上显示自定义的位掩码枚举（Flags） 前面啰嗦了踩坑过程，想看源码直接拉到最后。。。
以 IMGUI 实现，版本原因，没有查看 UIElements 。
Unity编辑器默认并不支持将 Flags 枚举以位掩码形式显示在Inspector上，像Layers这些控件，并不通用。
想让所有带有 Flags 特性的枚举都能支持多选，就要自定义编辑器扩展。然后，坑就来了！
坑1：EditorGUI.MaskField() EditorGUI.MaskField() ，这个方法一看名字，就感觉是我需要的，然后我写出了这玩意：
// ... property.intValue = EditorGUI.MaskField(position, label, property.intValue, property.enumDisplayNames); // ... Inspector成功地以位掩码形式显示出了 Flags 枚举，但是，用着用着感觉不对啊！它错位了！
问题在于，这个方法返回的不是所选的枚举的总值，而是所选的枚举项的索引，也就是说，他表示你选了哪几个枚举项。
这个方法的文档里，对返回值的说明是“The value modified by the user”，我觉得他应该改成“The indexes selected by the user”。
所以，如果要用这种方法正确地实现需求，要手动去获得 当前所选枚举值、每个枚举项的值、每个枚举项的名称，然后通过 位运算 手动去计算 当前选择了哪些枚举项 ，再调用 MaskField() 方法绘制控件。然后再拿到代表 当前所选枚举项索引 的返回值，通过 位运算 手动去计算 所选的索引对应的最终枚举值。
我这样做了下，确实是能正确显示了，但是不支持组合掩码（AB=A|B这种，见示例），不支持1&lt;&lt;31（见示例）。嫌烦没有去处理这个问题，所以查了下有没有其他方式实现，然后遇到了坑2。
坑2：EditorGUI.EnumFlagsField() EnumFlagsField() 方法是这样用的：
Enum currentEnum = (Enum)fieldInfo.GetValue(property.serializedObject.targetObject); Enum newEnum = EditorGUI.EnumFlagsField(position, label, currentEnum); property.intValue = Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1500adf5f525f656be2af521626985be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3412784026c38cf532c7b3e5fb24f0/" rel="bookmark">
			【TS】566- 一文读懂 TS 中 Object, object, {} 类型之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建了一个 “重学TypeScript” 的微信群，想加群的小伙伴，加我微信 "semlinker"，备注重学TS。
本文是 ”重学TS系列“ 第 27 篇文章，感谢您的阅读！
TypeScript 2.2 引入了被称为 object 类型的新类型，它用于表示非原始类型。在 JavaScript 中以下类型被视为原始类型：string、boolean、number、bigint、symbol、null 和 undefined。
所有其他类型均被视为非基本类型。新的 object 类型表示如下：
// All primitive types type Primitive = string | boolean | number | bigint | symbol | null | undefined; // All non-primitive types type NonPrimitive = object; 让我们看看 object 类型，如何让我们编写更精确的类型声明。
一、使用 object 类型进行类型声明 随着 TypeScript 2.2 的发布，标准库的类型声明已经更新，以使用新的对象类型。例如，Object.create() 和Object.setPrototypeOf() 方法，现在需要为它们的原型参数指定 object | null 类型：
// node_modules/typescript/lib/lib.es5.d.ts interface ObjectConstructor { create(o: object | null): any; setPrototypeOf(o: any, proto: object | null): any; // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da3412784026c38cf532c7b3e5fb24f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/197b62ae384683e985d68d47420cc55d/" rel="bookmark">
			docker 安装keepalived
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 安装keepalived 1、拉取keepalived镜像 能够拉取镜像的前提是已经安装了docker,如未安装请参考docker安装手册
搜素镜像 先搜索所有keepalived镜像，根据实际环境拉取所需要的镜像
docker search keepalived 部分结果如下：
NAME DESCRIPTION STARS OFFICIAL AUTOMATED alterway/keepalived Keepalived manage virtual ip between servers. 24 [OK] osixia/keepalived Keepalived with quick start configuration vi… 12 arcts/keepalived Alpine based container for keepalived 7 [OK] solnetcloud/keepalived Routing software designed to provide facilit… 3 [OK] gloppenhosting/keepalived keepalived for virtual ip between kamailio s… 2 [OK] goldenroute/keepalived-haproxy Keepalived and HAProxy 1 [OK] indigodatacloud/keepalived Docker image for Keepalived 0 [OK] osixia/keepalived-confd Keepalived that get unicast peers from any k… 0 weikinhuang/keepalived-kube keepalived: Loadbalancing &amp; High-Availabilit… 0 clearent/keepalived Dockerized keepalived to ease HA in deployme… 0 aramase/keepalived Docker image for running keepalived 0 interlegis/keepalived Docker container for keepalived 0 [OK] randomcoww/keepalived Keepalived 0 [OK] mesosphere/keepalived 0 mesosphere/keepalived-snmp Dockerized keepalived with snmp support 0 azenk/keepalived Apline based Keepalived 0 [OK] angelnu/keepalived Keepalived for multiple architectures 0 [OK] alogoc/keepalived 0 osism/keepalived 0 bara/keepalived keepalived based on alpine linux with netsta… 0 [OK] jckasper/keepalived 0 djannot/keepalived 0 nexinto/keepalived 0 brainloop/keepalived 0 拉取镜像 docker pull arcts/keepalived 2、启动容器 因为keepalived需要创建vip，其对网络权限要求较高，我们在启动容器的时候需要增加权限，启动方式如下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/197b62ae384683e985d68d47420cc55d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e132c3a491e49957c9d11a919beb418/" rel="bookmark">
			边沿检测电路的Verilog实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 边沿检测电路的Verilog实现 边沿检测， 就是检测输入信号， 或者 FPGA 内部逻辑信号的跳变， 即上升沿或者下降沿的检测。
Verilog 代码：
module work(	input clk,	input rst,	input signal,	output negedge_signal,	output posedge_signal );	reg dff1,dff2,dff3;	reg ne_signal,po_signal;	always @(posedge clk)	begin	if(!rst)	begin	dff1 &lt;= 0;	dff2 &lt;= 0;	dff3 &lt;= 0;	ne_signal &lt;= 0;	po_signal &lt;= 0;	end	else begin	dff1 &lt;= signal;	dff2 &lt;= dff1;	dff3 &lt;= dff2;	end	end	assign posedge_signal = dff2 &amp; (~dff3);	assign negedge_signal = (~dff2) &amp; dff3; endmodule 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/106/">«</a>
	<span class="pagination__item pagination__item--current">107/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/108/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>