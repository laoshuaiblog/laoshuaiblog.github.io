<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86faf8bcf15af67f8419eaa062fcbf12/" rel="bookmark">
			JS删除树形结构中childKey数组为空的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 删除树形结构中childKey数组为空的数据 tree是目标树形数据，childKey是字段名 export function removeEmptyChildKey(tree, childKey) { tree.forEach(item =&gt; { if (item[childKey] &amp;&amp; item[childKey].length === 0) { delete item[childKey]; } else if (item[childKey] &amp;&amp; item[childKey].length &gt; 0) { item[childKey] = removeEmptyChildKey(item[childKey]); } }) return tree; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0648337ca029c3974a8fcbf6e74c4337/" rel="bookmark">
			服务器数据恢复—raid5热备盘上线同步数据失败的如何恢复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器数据恢复环境&amp;故障&amp;分析：
一台存储上有一组由多块硬盘组建的raid5阵列，该raid5阵列中的一块硬盘掉线，热备盘自动上线同步数据的过程中，raid阵列中又有一块硬盘掉线，热备盘的数据同步被中断，raid5阵列失效，卷挂载不上，存储瘫痪。
这类raid故障比较常见，服务器raid中的硬盘大多数情况下都是一个批次的同品牌同型号的硬盘，一旦有硬盘出现故障掉线，那么其他硬盘也随时有出故障掉线的可能。
服务器数据恢复过程：
1、将故障存储中所有磁盘编号后取出，以只读方式进行扇区级全盘镜像，镜像完成后按照编号将所有磁盘还原到原存储中，后续的数据分析和数据恢复都基于镜像文件进行，避免对原始磁盘数据造成二次破坏。
2、基于镜像文件分析所有磁盘底层数据，通过分析获取到存储中raid5阵列相关信息：raid结构、raid块大小、raid校验信息、盘序等。北亚企安数据恢复工程师根据获取到的raid阵列信息虚拟重构raid5磁盘阵列，在重构raid5阵列中提取lun的数据。
3、提取出数据后交由用户方验证数据，经过仔细验证，用户方表示需要恢复的数据已经完全恢复出来，认可数据恢复结果。
4、用户方准备了一台新的存储设备，在数据恢复工程师的协助下，将恢复出来的lun一对一拷贝到新创建的lun中，再次进行验证后确认数据无误。本次数据恢复工作完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35154181ef0b18d068d60b3b7345c1d/" rel="bookmark">
			【leetcode&#43;深度/广度优先搜索】841. 钥匙和房间 (DFS,BFS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode-cn：leetcode面试75道精华：https://leetcode.cn/studyplan/leetcode-75/
841.钥匙和房间：https://leetcode.cn/problems/keys-and-rooms/description/
一、题目：841. 钥匙和房间 有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0号房间外的其余所有房间都被锁住。 你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。
当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。
给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回
示例
示例 1： 输入：rooms = [[1],[2],[3],[]] 输出：true 解释： 我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。 然后我们去 2 号房间，拿到钥匙 3。 最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。
示例 2： 输入：rooms = [[1,3],[3,0,1],[2],[0]] 输出：false 解释：我们不能进入 2 号房间。
提示：
n == rooms.length
2 &lt;= n &lt;= 1000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f35154181ef0b18d068d60b3b7345c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d354576011a5da30e683263bcca9fe4/" rel="bookmark">
			LVS&#43;Keepalived 高可用群集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.背景
企业应用中，单点服务器承担应用存在单点故障的危险
单点故障一旦发生，企业服务将发生中断，造成极大的危害
为解决单点故障，而引入keepalived
keepalived工具介绍 专为LVS和HA设计的一款健康检查工具
支持故障自动切换(Failover)
支持节点健康状态检查(Health Checking)
判断LVS负载调度器、节点服务器的可用性，当master主机出现故障及时切换到backup 节点保证业务正常，当master故障主机恢复后将其重新加入群集并且业务重新切换回master节点。
官方网站: http://www.keepalived.org/ Keepalived实现原理剖析 Keepalived采用VRRP热备份协议实现Linux服务器的多机热备功能
VRRP(虚拟路由冗余协议) 是针对路由器的一种备份解决方案
由多台路由器组成一个热备组，通过共用的虚拟IP地址对外提供服务
每个热备组内同时只有一台主路由器提供服务，其他路由器处于冗余状态
若当前在线的路由器失效，则其他路由器会根据设置的优先级自动接替虚拟IP地址，继续提供服务
VRRP 相关术语 虚拟路由器：Virtual Router 虚拟路由器标识：VRID(0-255)，唯一标识虚拟路由器 VIP：Virtual IP VMAC：Virutal MAC (00-00-5e-00-01-VRID) 物理路由器： master：主设备 backup：备用设备 priority：优先级 虚拟路由器的主备 是由priority：优先级决定的 VRRP工作过程 选举Master，比较优先级，高的为Master，若优先级相同无Master时，比较接口IP地址，大的为Master，Master设备发送ARP报文，承担报文转发工作；
状态维持，Master设备周期发送通告报文，公布配置信息和工作状态；
Backup设备根据收到的通告报文判断Master设备是否工作正常，如果Master设备主动放弃Master地位时，会发送优先级为0的通告报文，Backup设备收到后会快速切换成Master设备或者定时器超时后Backup设备认为Master设备无法正常工作，会切换状态为Master。
当Master设备出现故障后怎么办？
Master设备故障后，组内的备份设备一段时间（Master_Down_Interval定时器取值为：3×Advertisement_Interval＋Skew_Time，单位为秒）内没有接收到来自Master设备的报文，则将自己转为Master设备。一个VRRP组里有多台备份设备时，短时间内可能产生多个Master设备，设备将会对收到的VRRP报文中的优先级与本地优先级做比较，从而选取优先级高的设备成为Master。 Master设备故障后恢复的时候会怎么样？
Master设备恢复后，若其优先级为255则立即为Master设备，若优先级小于255，先切换为Backup设备，当Backup优先级高于Master设备时，如果此时工作模式为抢占模式，则Backup设备切换为Master设备，如果工作模式为非抢占模式，Backup设备不会切换为Master。（当设备切换为Master地位时都会发送免费ARP报文，承担报文转发功能） Keepalived案例讲解 Keepalived可实现多机热备,每个热备组可有多台服务器双机热备的故障切换是由虚拟P地址的漂移来实现,适用于各种应用服务器Keepalived配置目录位于/etc/keepalived/ Keeplived及其工作原理 Keepalived是一个基于VRRP协议来实现的LVS服务高可用方案，可以解决静态路由出现的单点故障问题。
在一个LVS服务集群中通常有主服务器（MASTER）和备份服务器（BACKUP）两种角色的服务器，但是对外表现为一个虚拟IP。主服务器会发送VRRP通告信息给备份服务器，当备份服务器收不到VRRP消息的时候，即主服务器异常的时候，备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性
Keepalived体系主要模块及其作用 keepalived体系架构中主要有三个模块，分别是core、check和vrrp。
core模块：为keepalived的核心，负责主进程的启动、维护及全局配置文件的加载和解析。vrrp模块：是来实现VRRP协议的。check模块：负责健康检查，常见的方式有端口检查及URL检查。 keepalive服务 keepalive服务可以使用yum安装、以及编译安装
本地yum源自带的版本比较旧
编译安装可以从官网下载较新的安装包进行安装
安装keepalive 使用yum安装：yum install keepalived.x86_64 -y
默认的主配置文件有157行
cat /etc/keepalived/keepalived.conf |wc -l
配置文件详解 全局配置
global_defs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d354576011a5da30e683263bcca9fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467479daf5d501601cc4cba2df6d4027/" rel="bookmark">
			产品经理能否带中国AI突破重围？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Photo by Ryan Loughlin on Unsplash 大模型开启新的AI时代之后，寻求机会的人们反而感受到一种更为强烈的撕裂感。
一方面，技术的革新让人感觉机会无处不在；另一方面，在庞大而混沌的创业机会面前，又感觉到无所适从。
技术创业成本和风险太高、应用创业门槛和壁垒不强。许多创业者、投资人就在夹缝中，一边看着OpenAI蒙眼狂奔，一边拿着项目寸步难行。
AI时代，创业者和投资人应该如何寻找时代机会？阶段性成功的创业者和投资人们又有什么心得和故事？
2024年，「自象限」推出系列专题“逐浪”，深度对话多位科技创业与一线投资人，期待从他们的故事和思考中，看见时代的涟漪。
©自象限原创
访谈丨罗辑
编辑丨程心
大模型时代，产品经理还有价值吗？
2023年初，ChatGPT上线短短两个月，活跃用户突破一亿，成为用户规模破亿速度最快的应用。
当时我们曾提出过一个粗暴的观点，说产品经理已死。
原因有二，其一是因为大模型从实验室里走出来就已经相对成熟，自然语言的交互不需要太多界面。其二是，技术还在飞快迭代，新的应用很快会被新的技术颠覆掉。
后来事情的发展一定程度上如我们所料，OpenAI陆续发布的GPTs和Sora让无数基于大模型的应用胎死腹中，我们当时说《OpenAI正在杀死创业者》（点击查看）。
但另一方面，随着时间的推移我们也越来越意识到，大模型技术固然炫酷，却很难在生活和工作中发挥实际价值。即技术和生产力之间，仍然存在巨大的差距。
显然世界仍然需要产品经理，需要他们来让技术与应用场景结合，将技术转化为生产力。
只是这件事情并不容易，新的产品从技术路径到产品思维都与之前大有不同，如何在AI时代打造一款好的产品，不仅成为产品经理的问题，也成为无数企业和投资人孜孜以求的事情。
因此，「自象限」邀请到AI创业公司「波形智能」的CPO万磊，一起聊一聊他在AI产品方面的经验和思考。
▲「波形智能」CPO万磊 受访者提供
万磊，连续创业者，前腾讯高级产品经理，参与过现象级软件「全民K歌」的产品打造，同时也是多个AI爆款产品的创始人。
万磊的思维特别活跃，从元宇宙到Web 3，再到AI大模型，他一直活跃在创业一线。在与「自象限」接近2个小时的交流中，他提到的产品创意以及亲手打造的产品就多达数十个项，多次的创业经历和深厚的产品实践成为其如今打造AI产品的支撑。
其在「波形智能」一手打造的「蛙蛙写作1.0」在上线1个月后月活达到30万，用户付费率达到7%。2024年1月，「波形智能」完成由蓝驰创投领投，西湖科创投、藕舫天使跟投的千万元级Pre-A轮融资，并发布垂类大模型Weaver。
2024，技术与产品融合 自象限：2024年，你认为大模型会有怎样的发展趋势？什么样的公司在这一年会更具优势？
万磊：回顾去年的发展，上半年先进入大众视野的是基于ChatGPT的AIGC应用，多是基于智能问答衍生出的各类小软件，这批项目基本都是产品经理主导的，但因为GPT迭代太快，AI训练的难度大幅度降低，这批项目的技术竞争力越来越没壁垒，竞品铺天盖地的出来，没跑出来什么好的软件。我的前几个项目就是这么“被迫”死掉的。
然后就是技术主导的“百模大战”和大量的Agent创业公司。这一波技术主导的项目比纯AIGC应用融资会顺利很多，当然后期大部分的大模型公司也死了，尤其是GPTs出来以后，大量粗浅的Agent创业公司也找不到方向，几百个大模型出来以后，大部分像空中楼阁一样找不到落地的应用场景，慢慢消失了。
到今年，大模型的理解能力和各种多模态技术的成熟度越来越高，还有越来越多的垂域大模型出现，各类AI应用去比多年多了很多。我认为今年这种趋势会更加明显，有自己产品落地形态的大模型公司才会活得比较好。对于用户来说以前看似摸不着头脑的大模型概念，今年会逐渐落地成AI应用不知不觉的走进大家的生活中
自象限：那在大模型时代做产品，与之前会有什么不同？
万磊：最大的不同自然是技术。之前我们纯做应用，不太需要太顾虑技术的实现瓶颈。无论是游戏还是社交软件，技术能做到什么程度我们心里还是比较清楚的，所以在功能设计上，只要是对用户有帮助的强需求，基本都能实现，强调从用户触发，寻找真实痛点，基本上很难遇到技术无法实现的诉求。更多时间都是在周旋研发的优先级问题。
自象限：所以技术稳定的时候，是产品主导一切；现在技术还在发展，技术主导产品就会更多，那这会成为当前产品经理的挑战吗？
万磊：也不能说谁主导谁的逻辑，更多的是配合方式。做AI产品经理会很不一样，当你做一个功能之前首先要和技术算法充分讨论，这个模型训练出这样内容能不能实现， 算力成本有多大，目前的文生图、对嘴型、声音克隆接口能做到什么程度，分别生成的时间需要多久。
AI技术的迭代速度太快了，可能今天做不了的东西，明天就会有一个技术突破点帮你解决了，产品要随时去获取新技术的迭代变化。用户有时候对AI有盲目的幻想，预期和实际实现往往都有差距。所以对于产品经理来说，要从从技术实现来反推自己的产品功能应该怎么设计，对AI技术本身要非常了解。这对传统的产品经理来说，会有一些不同需要适应。
自象限：那你觉得，现在做大模型产品，产品经理最大挑战会是什么？
万磊：一个是对前沿技术的理解和持续学习的能力，要求会更高，甚至是必要条件。比如像OpenAI每次的技术发布会，产品也需要全程看完并消化。其次在一些传统的垂直领域思考AI落地方案，挑战会大很多。因为没有什么可以copy的案例，如何把各种各样的AI技术赋能到某个垂类行业，你自己可能就是最早一批去思考这个分支要怎么结合AI往前走的人。以往我们做社交也好，游戏也好，可以有很多竞品分析的环节，从多种已有的模式选一个最合适的，现在没有这种流程了，你可能就是第一个产品。
自象限：现在很多人都在探讨AI原生应用，觉得所有产品都应该被AI重构一遍，你如何思考这个问题？
万磊：我觉得“AI原生”快被炒成一个噱头了，好像不是AI原生就会低人一等一样。
我记得有个大厂搞了个应用商店，号称有100个原生应用。但实际上你去看，它很多都是老应用加了一个AI功能，然后就说是AI原生，那肯定是不合理的。但现在市场就爱用这个东西标榜自己，觉得蹭上就会很厉害。其实不是，我觉得这有点走极端。
不是说原生应用就牛，我甚至觉得都不需要区分这个概念。现在的路径，一定是在传统的需求里去结合AI，然后提供更好的服务和效率。就像蒸汽时代不会一下把马车颠覆了一样，我们原来的那些应用，它的需求本身是真实存在的，不可能因为AI出现就不存在了。
所以很难说一个什么AI应用就把这些都颠覆掉，AI只能在原来非常好的，稳定的需求上面去做一些结合，比如提高服务质量，提高工作效率，提高信息获取速度等等。
自象限：我理解AI就是老房子翻新，一块砖一块砖去替换掉原来的建材，直到它成为一座全新的房子，而不是现在就推到重建。
万磊：对，它有点像每个人可能需要花七年的时间把自己的细胞更新一遍，我感觉AI技术和现有产品结合也会是这个过程。
自象限：2024年，AI应用会呈现什么样的发展趋势？
万磊：去年真正留下来的产品其实不多，且大部分都是基于单一技术的应用，比如换脸，或者一对一的声纹复刻，因为去年的技术形态也比较单一。今年随着多模态技术的成熟，综合性的应用可能会更多。
自象限：这种应用最有可能出现在哪些场景？
万磊：最出圈的有可能还是出现在偏社交的领域，比如虚拟陪伴。因为AI大模型最神奇的一点，就是它可以像人一样跟你交流，甚至跟你进行情感沟通。
我之前做的相亲软件，头几句话都是AI生成的，大模型可能会让未来更夸张一些，什么文生图、文生视频、声纹复刻都可以塞到同一个产品里面去，会有一些新的东西出来。基本上各行各业的传统软件都会有AI介入。
如何做好一款AI产品 自象限：如何才能做出一款好的AI产品？
万磊：我觉得首先得判断什么是真需求，什么是伪需求。
前两年区块链NFT火的时候，我做了一个算是国内比较早的数字藏品的社交平台，期望国内的数藏玩家可以在这个平台上分享自己的藏品、购买经验、或者进行转卖销售等等。
NFT刚火的时候，我觉得这是一个强需求。但后来才发现，国内玩数藏的人很少需要跨平台交流，也不需要分享和交换数藏。他们把数字藏品当金融产品去炒，一群人只盯着一个数藏品牌。盘子炒热以后就撤退去主攻另外一个新盘，这样持续往复，他们用得最多的就是QQ群或者QQ频道。QQ已经满足了交流分享的能力了，不需要再新造一个跨平台的数藏社交工具。
自象限：产品设计上会有什么考虑，现在大多数AI产品都是以对话方式进行的，这是最直接的交互方式，产品在这方面有什么思考空间吗？
万磊：以写作软件为例，目前常见交互方主要是对话框输入框，或者从Notion那边学过来的交互方式，把对话框放进文档里，输出的内容直接呈现在编辑区域，然后做一些快捷按钮。
这种交互面向宽泛的内容创作没有问题，但如果面向专业写作者就会存在问题。因为AI生成的内容并不一定有效，生成的内容取决于指令的内容，这里变量非常大。内容直接侵入到编辑区域，如果作者不满意，还要不停的删除重新提问生成。
所以我在蛙蛙写作的小说工具上就放弃了常见的这种交互方案，根据具体的需求写作场景进行设计。
比如我给文章单独开了一个侧边栏，AI生成的内容不会直接出现在文章里，而是先出现在侧边栏，用户可以对这些内容进行选择，修改，确定了之后再放到正文区域。
我们也会做一些按钮，因为很多人不知道怎么把自己的想法告诉AI，我们会和用户做深入的沟通交流，把一些高频的设定词做成按钮，可以进行快捷交互。
比如我们设计的“划词修改”的功能，现在很多AI产品要是对内容不满意，就需要全部重头再来，但用户很多时候可能只想要调整其中某一句话。划词功能就可以选中这一句，然后让AI进行定向修改，比如增加感情描写，扩写剧情等等。
自象限：所以写作类产品的整体逻辑还是定位在工具属性，采用的副驾驶逻辑。
万磊：对，我觉得目前AI写作的核心逻辑还是做好辅助，而不是直接代替你输出成品。
现在是产品经理的好时代吗？ 自象限：你觉得现在是产品经理最好的时代吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/467479daf5d501601cc4cba2df6d4027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89cf4bc94a53f8b4e44753fb213ff44c/" rel="bookmark">
			【Java】祖宗Object类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Object类1.1 Object类是什么1.2 获取对象信息toString方法1.3 对象比较equals方法1.4 hashcode方法 结语 前言 在之前我们对Java的抽象类与接口进行深入的了解，今天我们来进一步学习Java中的“祖宗类”——Object类。本篇文章将详细介绍Java语言中的Object类及其包含的toString()方法、equals()方法和hashcode()方法。让我们开始吧！！
一、Object类 1.1 Object类是什么 Object是Java默认提供的一个类。Java中除了Object类，所有的类都是存在继承关系的。 默认会继承Object类。 即所有类的对象都可以使用Object的引用进行接收。 （会有一种Object类是所有类的祖先/始祖的感觉XD）
举个栗子🌰：用Object类接收其他类的对象
class Student{} class Teacher{} public class test { public static void func(Object obj){//参数为Object类 System.out.println(obj); } public static void main(String[] args) { Student stu = new Student(); Teacher tea = new Teacher(); func(stu); func(tea); } } 运行结果： Student@1b6d3586 Teacher@4554617c 所以在开发之中，Object类是参数的最高统一类型，同时该类还具有一些已经定义好的方法：
1.我们通过IDEA来实现查找
2.双击shift
3.点击后左侧或快捷键shift+7来查看类中方法
接下来主要来了解以下三个方法：toString()方法、equals()方法和hashcode()方法
1.2 获取对象信息toString方法 根据查找我们可以看到定义的toString()方法：
Object类中的toString方法返回值是一个字符串：类名+“@”+该对象的哈希码的无符号十六进制表示组成
但我们一般使用时返回的都是直观简洁的以文本信息表示的字符串，建议子类使用时都重写此方法。
1.3 对象比较equals方法 查找equals方法具体代码如下：
可以发现返回值中有==判断,那么我们需要先对该符号在Java中的使用有所了解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89cf4bc94a53f8b4e44753fb213ff44c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0079038f04703a86df170c8944bd1b83/" rel="bookmark">
			Lvs--部署DR集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Lvs有三种负载均衡的模式： VS/NAT（nat模式）
VS/DR (路由模式）
VS/TUN （隧道模式）
（1）NAT模式（VS-NAT）
原理：首先负载均衡器接收到客户端请求包时，根据调度算法决定将请求发送给哪个后端的真实 服务器（RS)
然后负载均衡器就把客户端的请求数据包的目标IP地址及端口改成后端真实服务器的IP地址 （RIP）。真实服务器响应完请求后，查看默认路由，把响应后的数据发送给负载均衡器，
负载均衡器在接收到到响应包后，把包的源地址改成虚拟地址（VIP），然后发送回给客户端。
优点：集群中的服务器可以使用任何支持TCP/IP的操作系统，只要负载均衡器有一个合法的IP地址。
缺点：扩展性有限，当服务器节点增长过多时，由于所有的请求和应答都需要经过负载均衡器，因此负载均衡器将成为整个系统的瓶颈。
（2）直接路由模式（VS-DR）
简称 DR 模式
原理:首先负载均衡器接收到客户的请求数据包时，根据调度算法决定请求发送给哪个后端的真实 服务器（RS)。
然后负载均衡器就把客户端发送的请求数据包的目标MAC地址改成后端真实服务器的MAC地 址（R-MAC）。
真实服务器响应完请求后，查看默认路由，把响应后的数据包直接发送给客户端，不需要经 过负载均衡器。
优点：负载均衡器只负责将请求包分发给后端服务器，而RS将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不在是系统的瓶颈，也能处理很巨大的请求量。
缺点：需要负载均衡器与真实服务器RS都有一块网卡连接到同一物理网段上，必须在同一个局域网环境。
DR模式的特点：
Director和各RS都配置有VIP
确保前端路由器将目标IP为VIP的请求报文发往Director
在前端网关做静态绑定VIP和Director的MAC地址
在RS上使用arptables工具
arptables -A IN -d $VIP -j DROP arptables -A OUT -s $VIP -j mangle --mangle-ip-s $RIP 在RS上修改内核参数以限制arp通告及应答级别
/proc/sys/net/ipv4/conf/all/arp_ignore /proc/sys/net/ipv4/conf/all/arp_announce RS的RIP可以使用私网地址，也可以是公网地址；RIP与DIP在同一IP网络；RIP的网关不能指向DIP，以确保响应报文不会经由Director
RS和Director要在同一个物理网络
请求报文要经由Director，但响应报文不经由Director，而由RS直接发往Client
不支持端口映射（端口不能修改）
无需开启 ip_forward
RS可使用大多数OS系统
（3）IP隧道模式（VS-TUN）
原理：首先负载均衡器接收到客户的请求数据包时，根据调度算法决定将请求发送给哪个后端的真实服务器（RS）。
然负后载均衡器就把客户端发送的请求报文封装一层IP隧道(T-IP)转发到真实服务器（RS）。
真实服务器响应完请求后，查看默认路由，把响应后的数据包直接发送给客户端，不需要经过负载均衡器。
优点：负载均衡器在只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，也能处理很巨大的请求量。
缺点：隧道模式的RS节点需要合法IP。这种方式需要所有的服务器支持"IP Tunneling"
二.LVS工作模式总结和比较 NATTUNDR优点端口转换WAN性能最好缺点性能瓶颈服务器支持隧道模式不支持跨网段真实服务器要求anyTunnelingNon-arp device支持网络private（私网）LAN/WAN（私网/公网）LAN（私网）真实服务器数量low (10~20)High (100)High (100)真实服务器网关lvs内网地址Own router（网工定义）Own router（网工定义） 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0079038f04703a86df170c8944bd1b83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e3eb131031a71292def818d3c12b9b1/" rel="bookmark">
			kotlin使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：现在工作越来越不好找，搞不好突然就会离开开发。为了在离开时候，如果想要写kotlin还能想起来怎么写，所以写了一篇教程给自己。
变量表达式方法类扩展属性及函数Function正则表达式kotlin常用的apikotlin协程和flowktx 先来一个kotlin中文站，可以用来看看kotlin新版本出了什么新特性。还可以看看b站的benny老师，他在国内的kotlin推广做了很多事。
main方法
在创建一个kotlin文件之后，不需要声明类名就可以编写main方法，只需
fun main() { } 在可以在main里面编写代码，编写完成后再点击运行即可。
变量 val a = 1 var b = "" // 下面这句代码会编译错误 // var b = 1 val a: Float = 1f kotlin会自动推断变量的类型，一个变量在声明后，编译器就已经确定了该变量的类型，后续是无法更改变量的类型的。可以在变量名臣后面使用":变量类型"来指定变量类型，就像上面的Float一样。
使用val声明的变量不可以被重新赋值，使用var声明的变量可以被重新赋值。
java的byte、short、int、long、char、boolean、float、double在kotlin里面，是以大写字母开头体现的，并且在kotlin里面，没有Integer、Character类型。
在kotlin里面，一个String如果想要转换成Int，可以使用toInt方法，toInt本质也是调用Integer.parseInt方法。顺便一提，在kotlin里面，也可以调用parseInt方法，不过需要这样调用，java.lang.Integer.parseInt。
提到toInt，就顺便提一个kotlin在声明Int时特有的问题。如果Int的最高位是1时，Int不会将这个值视为负数，而是当做Long。此时，就需要使用toInt转换成Int。
val white:Int = 0xffffffff.toInt() long类型和java一的点不同，在java里面，long类型可以使用大小写L作为结尾，但小写l总会和数字1看错，所以kotlin不允许用小写l，只能用大写L。
除了基本数据有一点不同之外，大部分类型都和java一样，因为kotlin可以直接使用java的api，但有一些还是有点不同。
Object：对应kotlin的Any。void/Void：对应kotlin的Unit。List：List也有一点不同。java的List有add方法，而kotlin的List是没有的add和remove这样的方法的。如果想要使用add或remove方法，只能声明一个MutableList。我认为kotlin这样设计的原因，是为了让开发者可以提供一个只读的List。当开发者不希望返回的List被操作时，就返回List，而如果不在乎是否被操作，就返回MutableList。 0x、0b：kotlin同样支持在声明数字时，用0x表示16进制，用0b表示二进制，还能用_隔开数字而不影响数值。
数组：提到List，就顺便将数组说一下。在kotlin里面，如果想要使用数组，可以使用IntArray或Array。八大基本数据类型都有自己的Array，其他类型需要使用Array。Array在new时，还是比较麻烦的，以IntArray为例：
IntArray(1){ it -&gt; 2 } 这里的1就是Array的长度，2就是要返回的值，这里的意思就是返回一个长度为1，第0个元素为2的数组。
it就是index，这里的it-&gt;可以去掉，{}默认的名称就是it，可以修改为其他名称，比如index，这个下面会具体说明，现在只要知道能这样用即可，其他类型的数组使用的方式也是一样。如果要问，IntArray和Array有什么区别，我记得看过相关博客，说是IntArray的性能更好，所以如果使用基本类型的数组，就使用相应的Array，其他情况再用Array。
从上面的使用方式也可以看到，数组使用的方式特别麻烦，如果length很长，那就是需要判断所有index，这显然是不合理的，所以kotlin也提供了arrayOf这样的api。有intArrayOf和arrayOf等方式。
intArrayOf(1, 2, 3) arrayOf(1, 2, 3) 从上面可以看到初始化一个对象没有使用new关键字，在kotlin里面，没有new关键字，所以想要创建对象时不需要使用new。再补充一下，如果一行只写一句代码，不需要写";“，只有一行写多句代码和在声明枚举类时，才需要用”;"。
val a = 1;val b = 1 enum class Word{ A, B; fun test(){ } } 如果没有在B后面补一个"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e3eb131031a71292def818d3c12b9b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb54f78b8776fa4dc250cfb792c41ec/" rel="bookmark">
			【WEEK1】学习目标及总结【SpringMVC】【中文版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习目标： 三周完成SpringMVC入门——第一周
学习内容： 参考视频教程【狂神说Java】SpringMVC最新教程IDEA版通俗易懂掌握 MVC基本概念新建MVC项目掌握SpringMVC的原理、特点及作用使用配置文件完成MVC程序 学习时间及产出： 第一周 MON~FRI
2024.2.26【WEEK1 DAY1】 MVC相关历史和概念【中文版】【WEEK1 DAY1】 MVC related history and concepts【ENGLISH version】 2024.2.27, 28,29【WEEK1】 【DAY2】 【DAY3】【DAY4】新建SpringMVC项目【中文版】【WEEK1】 【DAY2】 【DAY3】【DAY4】Creating a SpringMVC Project【English Version】 2024.3.1【WEEK1】 【DAY5】第一个MVC程序之配置文件【中文版】【WEEK1】 【DAY5】First MVC Program: Configuration File【English Version】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac3cf0bb4028dbb93d9a2e1f56448a4/" rel="bookmark">
			dbpystream：证券股票数据服务API开源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/songroom2016/dbpystream/tree/main
上面是我开源dbpystream的地址，谨供非商业且内部使用（开放10个测试账户），欢迎交流！
一、关于dbpystream
dbpystream API 主要为已经购买了数据供应商API服务的企业内部提供向自己员工内部的数据服务的API接口，这种服务是一种API的镜像服务。
1、dbpystream API的目的
对于不少企业来说，购买了很多不同类的数据，比如wind,同花顺，joinquant,财汇，聚源等等。很多是以账号的形式提供服务，也有部分是以落地数据库的形式。但这些形式，更多的只是提供给企业内部的局部人员使用，在数据共享和数据探索，以及服务上，还是处于一个相对窄的面上。对企业来讲，这些数据并没有得到全面的使用，也没有把数据信息资产化，并且流动起来，让业务产生更大的价值。
基于上面的痛点 ，dbpystream的目的是根据自身的业务需要，把企业内部的数据进行服务化，让企业内的员工能方便得到数据服务，而不再让数据服务只是一小部分人的特权，让数据可以在更广泛的层面得到充分的利用，并发挥数据驱动业务的价值。
从更长远的角度，数据的广泛利用，有利于在公司、行业层面发挥价值，同时也让大家更加重视数据的内在价值，也有利提升行业的生态环境。
2、dbpystream API 的特点
（1）、函数基本一致。在接口规范上，尽量保持和原生的API接口相近，尽量让大家上手比较快,个别上函数签名和返回值上可能会有微调；
（2）、基于内部使用。 API的服务范围是基于内部的需要开发的实用接口部分，其要比原生API范围的小；
（3）、数据上“源汁源味"。数据上不对源数据做相应的清洗和加工。
3、dbpystream API 与其它数据源API不同
（1）、定位不同。dbpystream是对内服务。
和供应商提供的API服务不同，dbpystream是对内的，更相对于是一个局域网。数据源API是对外赋能，dbpystream是对内赋能，而不是对外商业化。
（2）、上下游关系。dbpystream依赖于供应商的API服务。
供应商的API的服务质量是dbpystream的天花板，没有优秀的供应商服务（源头），就不可能有好的内部服务。
（3）、共生关系。dbpystream只做整合部分，不能替代供应商API，是对供应商API服务包装，为了让服务更好的落地，而供应商API做的是一套完整的生产和质量管理流程。
4、dbpystream API展望
目前，data api 市场和服务还是较初级的阶段，感谢市场上为数不多的数据提供商，可以让大家有了接触api服务的可能。在此基础上，dbpystream api才有了二次的可能，在此特别致谢，joinquant, tushare、同花顺等数据服务厂商，也感谢为市场提供免费数据的sina财经等网站。
目前，dbpystream主要的数据服务商有：jqdatasdk, 未来计划支持更多。
dbpystream只对企业内部提供数据服务,也期待能与数据供应商一起为整个数据生态而努力！
二、dbpystream sdk使用方法
1、安装方法
pip install dbpystream 2、python sdk 实例说明
以下jqdatasdk为例，本库提供了jqdatasdk类似的支持，主要函数签名及参数基本上与jqdatasdk一致
其中，比如，你希望通过get_price获取历史1 min bar行情，首先，你需要在首次登陆时需要使用到auth函数。
auth:
def auth(username=None,password=None) -&gt; None 说明： 可以选择手动同时填入两个参数，也可以使用从环境变量中进行设置。默认是从环境变量中;如果从环境变量设置相关变量，建议以"dbpystream_username"，"dbpystream_password"来命名。 当前面username和password参数必须显示指定和输入。这两个参数，需要由内部分发。
在完成登陆后，你就可以直接调用get_price函数了。
get_price:
def get_price(security,start_date,end_date,frequency,fq='pre',fields=None) -&gt; pd.DataFrame: 关于get_price的用法：
其中主要参数： 1、security 一支股票代码或者一个股票代码的list。股票代码或期货合约要包含交易后缀，比如.XSHE,XSHG等等。 2、start_date 与 count 二选一，不可同时使用.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac3cf0bb4028dbb93d9a2e1f56448a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/507c69972282c4380fd80176d7369104/" rel="bookmark">
			Linux安全攻防大揭秘：攻击类型与防护策略详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在上一篇文章中，谈到Linux系统中常见的一些安全威胁，以及这些安全威胁如何应对，而在这篇文章中，将会换一个角度，从一个攻击者的角度出发，来分享一下，攻击者们是如何利用这些安全威胁漏洞发起哪些攻击的，以及在面对这些攻击时又有哪些有效的措施可以采取。我想，无论你是想提升自身技能的技术人员，还是对网络安全保护感兴趣的读者，本文都将为你提供宝贵的见解和实用的应对策略。这里会通过分析各种攻击手法和漏洞利用方式，帮助你建立起坚固的防御体系，保障个人和组织的信息安全。
针对Linux系统有哪些常见的攻击类型 从攻击者的角度来看，针对Linux系统的攻击类型，比较常见的如下：
密码破解：攻击者试图通过暴力破解或使用已知的密码进行登录来获取系统访问权限。拒绝服务攻击（DoS）：攻击者通过发送大量请求或占用系统资源来使系统无法正常工作，从而导致服务不可用。远程执行漏洞攻击：攻击者利用系统中的漏洞，通过发送恶意代码或命令来远程执行恶意操作。缓冲区溢出攻击：攻击者通过向应用程序输入超出其预期大小的数据，来覆盖相邻内存区域的内容，从而执行恶意代码。提权攻击：攻击者试图获取比他们当前权限更高的访问权限，以便执行敏感操作或控制整个系统。嗅探攻击：攻击者截获网络上的数据包，以获取敏感信息，如用户名、密码等。木马攻击：攻击者在系统中安装后门程序，以获取对系统的远程访问权限。社会工程学攻击：攻击者通过欺骗、诱骗或操纵用户来获取敏感信息，如密码、账号等。物理入侵攻击：攻击者通过物理访问服务器或设备，直接获取系统权限。网络钓鱼攻击：攻击者通过伪装合法网站或电子邮件来欺骗用户，以获取他们的敏感信息。 当然，这些只是一些常见的攻击类型，肯定还有其他类型的攻击。为了保护Linux系统，仅仅了解这些是远远不够的，还需要更多的专业知识，这里只是抛砖引玉，希望能给你一些启发和思考。
密码破解 密码破解是一种常见的攻击方式，黑客们会使用各种技术手段来获取用户账户或系统的密码，而针对Linux的密码破解的方式通常有：字典攻击、暴力攻击、彩虹表攻击等等：
字典攻击：密码破解者使用一个包含常见密码、词典单词和组合的字典文件进行尝试。暴力攻击：密码破解者尝试所有可能的密码组合，从简单的数字串到复杂的字符组合，直到找到正确的密码。彩虹表攻击：密码破解者事先生成一张包含密码散列值和对应明文密码的表格，然后通过比对散列值来破解密码。社交工程：密码破解者可能试图获取您的个人信息或通过欺骗手段获取密码，例如通过钓鱼邮件、电话欺诈等方式。操作系统漏洞利用：密码破解者可能利用操作系统或应用程序的漏洞来绕过密码验证，直接访问系统。 为了应对这些不怀好意的攻击，保护您的Linux系统，建议你在日常的工作生活中，尽可能采取以下措施：
使用强密码：选择一个长且包含大小写字母、数字和特殊字符的密码，并定期更改密码。多因素身份验证：启用多因素身份验证，如使用手机验证应用程序或硬件密钥来增加登录安全性。防火墙和入侵检测系统：配置并更新防火墙，并使用入侵检测系统来监控恶意活动。定期更新系统：及时应用操作系统和应用程序的安全补丁，以修复已知漏洞和强化安全性。限制登录尝试：设置登录失败的尝试次数限制，并启用账户锁定功能。加密存储：对重要数据进行加密存储，以防止未经授权访问。 如果这些有效的措施在工作中已经实施过了，还是需要记住，这些措施只是加强系统安全性的一部分。维护好密码的安全性并及时更新系统是保护系统免受密码破解的关键。
拒绝服务攻击（DoS） 拒绝服务攻击（DoS，Denial of Service）是一种非常恶意的行为，它旨在使目标系统无法提供正常的服务。其原理也很简单，主要是通过发送大量请求或占用过多资源来耗尽目标系统的计算能力、网络带宽或存储空间，从而导致服务不可用。
原理很简单，但防御起来却挺麻烦，主要原因在于为了应对这些“恶意流量”，往往需要付出额外性能成本才行，有的时候这些成本还很高昂。但有幸的并非没有办法：
流量过滤和限制：使用防火墙、入侵检测系统（IDS）和入侵防御系统（IPS）等工具来监测和过滤恶意流量，以阻止DoS攻击的入侵。负载均衡和故障转移：通过使用负载均衡器将流量分散到多个服务器上，以平衡负载并减轻单个服务器的压力。同时，设置故障转移机制，可以在一个服务器受到攻击时迅速切换到备份服务器上。增加带宽和网络容量：增加网络带宽和系统资源，以更好地处理突发的高流量负载。这可以通过与云服务提供商合作或使用分布式CDN（内容分发网络）来实现。安全策略和访问控制：制定和执行严格的安全策略和访问控制措施，包括强密码策略、用户认证和授权机制，以防止未经授权的访问和滥用系统资源。流量分析和异常检测：通过使用流量分析工具来监测网络流量，并使用异常检测技术来识别和拦截异常流量和行为。这可以帮助及早发现DoS攻击，并采取相应的防御措施。云服务和内容分发网络（CDN）：将系统迁移到云环境中，可以借助云服务提供商的资源和安全性来缓解DoS攻击。同时，使用CDN可以将流量分发到全球各地的缓存节点，减轻源服务器的负担。DDos保护服务：考虑使用DDoS保护服务，这些服务专门针对DoS和DDoS攻击提供专业级的防护策略，能够迅速识别和应对恶意流量。 远程执行漏洞攻击 远程执行漏洞攻击是指攻击者通过利用目标系统上的安全漏洞，以远程方式执行恶意代码或命令。这种攻击通常会导致攻击者能够在目标系统上执行任意的指令和操作，包括获取敏感信息、篡改数据、控制系统等。
远程执行漏洞攻击的原理是利用目标系统上存在的软件漏洞，通过发送特制的数据包或恶意代码来触发漏洞，进而执行攻击者预先准备好的恶意操作。这些漏洞可能涉及操作系统、网络协议、应用程序或库等方面。
攻击者利用远程执行漏洞攻击时，通常会采取以下步骤：
识别目标系统：攻击者首先会扫描目标系统，寻找存在漏洞的软件或服务。发现漏洞：一旦找到潜在的漏洞，攻击者会详细研究漏洞的性质和利用方式。利用漏洞：攻击者会构造特定的数据包或注入恶意代码，以利用漏洞执行恶意操作。获取权限：一旦成功执行了恶意操作，攻击者可能会获取系统的高权限，以便进一步控制和操作目标系统。 为了防御远程执行漏洞攻击，可以从以下方面采取措施：
及时更新软件：保持操作系统、应用程序和库等软件的最新版本，以修复已知漏洞并强化安全性。限制外部访问：通过使用防火墙或访问控制列表（ACL）等工具，限制对系统的外部访问，并只允许必要的服务对外提供。安全配置：确保系统和应用程序的安全配置，包括关闭不必要的服务、禁用不安全的功能和默认密码等。输入验证和过滤：对外部输入数据进行严格的验证和过滤，以防止恶意代码注入和攻击者构造特定的数据包。漏洞扫描和漏洞管理：定期进行漏洞扫描，及时发现系统中可能存在的漏洞，并采取相应的补救措施。安全意识培训：提高用户和管理员的安全意识，教育他们警惕社会工程学攻击和点击可疑链接或附件的风险。 缓冲区溢出攻击 缓冲区溢出攻击是一种常见的计算机安全漏洞利用方式，黑客利用程序设计上的漏洞，通过向程序输入超出其预期处理能力的数据，导致程序的缓冲区溢出，从而实现恶意代码注入或改变程序执行流程的攻击手法。
具体来说，当程序接收输入数据时，如果没有对输入数据的长度进行有效的检查和限制，恶意攻击者就可以输入比程序预期处理的更多数据，超出了程序分配给缓冲区的内存空间。这样一来，攻击者就能够覆盖程序的其他重要数据、修改程序的运行时行为或者注入恶意代码，从而获取系统权限、执行恶意操作或者使程序崩溃。
为了防范缓冲区溢出攻击，软件开发者和系统管理员在开发和管理相关程序软件时，应特别注意加强下面几个方面：
输入验证：对程序接收的输入数据进行有效的长度和格式验证，避免超出缓冲区大小的输入。使用安全函数：使用编程语言提供的安全函数，如strcpy_s()、strncpy()等，避免使用容易发生溢出的函数。内存隔离：使用内存隔离技术，如地址空间布局随机化（ASLR）、数据执行保护（DEP），减少攻击者对内存的利用空间。 提权攻击 提权攻击（Privilege Escalation Attack）是指攻击者通过利用系统或应用程序中的漏洞，获取比其当前权限更高的权限级别的一种攻击方式。攻击者通过提权攻击可以获得对系统、网络或应用程序的完全控制，从而执行未经授权的操作。
提权攻击可以分为以下几种类型：
本地提权：攻击者已经获得了部分系统权限，通过利用操作系统或应用程序的漏洞，提升自己的权限级别。远程提权：攻击者从远程位置尝试利用目标系统或应用程序的漏洞，以获取更高的权限。水平提权：攻击者通过在某个已被入侵的系统上获得的低权限账户，尝试在其他系统上提升权限。 为了防范提权攻击，这里推荐一些常见的防护方法：
及时更新和修补漏洞：定期更新操作系统、应用程序和软件，确保已修复已知漏洞，以防止攻击者利用这些漏洞进行提权攻击。最小权限原则：将用户和服务账户设置为最低权限，限制其对系统的访问和操作范围，减少攻击者成功提权的机会。强化访问控制：使用强密码策略、多因素身份验证，以及严格的访问控制机制，限制未经授权的访问和操作。日志监控和分析：实时监控系统日志，及时发现异常活动和提权迹象，以便采取相应的应对措施。安全意识培训：加强员工和用户的安全意识培训，提高其对提权攻击的认识和防范能力。 嗅探攻击 嗅探攻击（Sniffing Attack）是一种网络安全攻击方式，攻击者通过监听网络上的数据包来获取敏感信息的行为。嗅探攻击通常发生在不安全的网络环境中，例如公共Wi-Fi网络或未加密的局域网。
攻击者使用嗅探工具来捕获经过网络的数据包，通过分析这些数据包的内容，可以获取包含用户名、密码、信用卡信息等敏感数据的明文。嗅探攻击主要利用了网络上的数据传输过程中的漏洞和弱点，例如未加密的通信、弱密码、不安全的协议等。
为了防范嗅探攻击，这里推荐一些常见的防护方法：
使用加密通信：通过使用加密协议（如HTTPS、SSH等）来保护数据的传输过程，使攻击者无法直接获取明文数据。安全的无线网络：避免使用未加密的公共Wi-Fi网络，尽量连接至受信任的、加密的Wi-Fi网络，或者使用虚拟私人网络（VPN）来加密通信。强密码和身份验证：使用强密码，并启用多因素身份验证，以增加攻击者获取敏感信息的难度。网络流量监控和检测：实施网络流量监控和入侵检测系统（IDS/IPS），及时发现异常活动和嗅探工具的使用。加密文件共享和数据存储：对共享文件和敏感数据进行加密，以防止未经授权的访问。 木马攻击 木马攻击（Trojan Horse Attack）是一种常见的网络安全攻击方式，得名于古希腊传说中的“特洛伊木马”。在计算机领域中，木马指的是一种看似正常但实际上包含恶意功能的程序。木马程序通常会隐藏在其他程序或文件中，并骗取用户执行，一旦被执行，木马程序就会开始执行其恶意目的。
木马攻击的危害包括但不限于以下几点：
数据窃取：木马可以用于窃取用户的个人信息、账号密码、信用卡信息等敏感数据。系统破坏：木马可以损坏系统文件、篡改系统设置，甚至导致系统崩溃。后门开启：木马可以为攻击者留下后门，使其能够远程控制受感染的系统。拒绝服务攻击：木马可以利用受感染系统的资源发起拒绝服务攻击，影响其他系统的正常运行。 下面一些常见的防护方法：
安装安全软件：定期更新杀毒软件、防火墙等安全软件，及时检测和清除潜在的木马程序。谨慎下载和执行：避免下载和执行来历不明的软件、文件，尤其是通过邮件、社交网络等途径传播的文件。更新系统和应用程序：及时安装系统和应用程序的安全补丁，修复已知漏洞，减少木马程序利用的机会。强化安全意识：加强员工和用户的安全意识培训，警惕钓鱼邮件、虚假链接等木马传播手段。多层防御措施：建立多层防御体系，包括网络防火墙、入侵检测系统、安全审计等，提高木马攻击的检测和防范能力。 社会工程学攻击 社会工程学攻击（Social Engineering Attack）是一种利用心理学和社会工程学原理来欺骗人员，使其泄露敏感信息或执行特定操作的攻击方式。攻击者通常通过伪装成信任的实体或利用社会工程技巧来获取目标的机密信息或执行特定的操作，而不是依靠技术手段入侵系统。
社会工程学攻击可以采取多种形式，包括但不限于以下几种：
钓鱼邮件：攻击者发送伪装成合法机构或个人的电子邮件，诱使受害者点击恶意链接、下载恶意附件或输入个人信息。假冒身份：攻击者冒充他人身份，通过电话、短信或面对面接触等方式请求受害者提供敏感信息或执行操作。社交工程：攻击者通过社交网络、聊天应用等渠道获取目标的信息，以便进行有针对性的攻击。垃圾邮件/电话诈骗：攻击者发送垃圾邮件或打电话给受害者，声称需要验证信息或解决问题，从而获取敏感信息。 下面是一些常见的防护方法：
提高安全意识：加强员工和用户的安全意识培训，警惕社会工程学攻击的各种形式和手段。谨慎对待信息请求：避免轻信陌生人的信息请求，谨慎对待来历不明的邮件、电话等。多重验证：采用多因素身份验证方式，增加访问系统或数据的门槛。定期审查权限：定期审查系统和应用程序的权限设置，限制员工和用户的访问权限，减少攻击面。报告可疑行为：建立报告机制，鼓励员工和用户及时报告可疑的信息请求或行为。 物理入侵攻击 物理入侵攻击（Physical Intrusion Attack）是指攻击者通过直接进入受攻击目标的物理空间，获取机密信息、破坏设备或执行其他恶意操作的一种攻击方式。与传统的网络攻击不同，物理入侵攻击侧重于攻击目标的物理安全，而不是网络或系统安全。
物理入侵攻击可以采取多种形式，包括但不限于以下几种：
窃听：攻击者潜入目标地点，安装窃听设备或针孔摄像头等，以获取敏感信息。偷盗：攻击者潜入目标地点，偷窃设备、文件或其他有价值的物品。破坏：攻击者在目标地点破坏设备、损毁文件或物品，导致系统故障或数据丢失。冒充：攻击者冒充合法人员进入目标地点，获取未经授权的访问权限。社交工程：攻击者通过面对面的社交互动，欺骗人员提供敏感信息或执行特定操作。 下面是一些常见的防护方法：
控制访问权限：建立有效的门禁系统，限制只有授权人员才能进入物理空间。监控设备：安装监控摄像头和入侵检测系统，及时发现和记录可疑活动。安保培训：对员工进行安全意识和物理安全培训，教育他们识别和报告可疑行为。加固设备：采取物理防护措施，如加密存储设备、安全锁、防火墙等，减少攻击者物理入侵的机会。定期检查：定期对物理空间进行检查，确保设备完好无损、门禁系统正常运行。 网络钓鱼攻击 网络钓鱼攻击（Phishing Attack）是一种通过伪装成合法实体或机构，以欺骗用户提供敏感信息（如用户名、密码、银行账号等）或执行特定操作的攻击方式。攻击者通常会发送电子邮件、短信、社交媒体消息或创建伪造的网站来诱使受害者相信信息的真实性，并骗取其个人信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/507c69972282c4380fd80176d7369104/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de146e80165974669f6a1b6e49f2782/" rel="bookmark">
			R语言绘制散点密度图ggdentity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用R语言绘制二维密度图 下图是一张常见的二维核密度散点图，能够清晰直观的反映出数据之间的分布趋势，颜色越红的位置数据越集中分布。今天分享的笔记是在R语言中绘制该图的两种常见方法，提供过程代码。 论文中常见的这种展示两组数据之间分布趋势的图，其实也是一种散点图，只是用不同颜色来映射了点的密度大小，通常是渐变色来展示数据的变化规律。 方法一：ggpointdensity 这个包结合了散点图和密度图的特点，是 ggplot2 的一个扩展，使用户能够创建点密度图，其中点的颜色和大小可以表示数据点在特定区域的局部密度，从而直观地揭示出数据的集中趋势。
安装与使用方法 install.packages("ggpointdensity")
library(ggpointdensity)
library(viridis) # 使用viridis提供的翠绿色标度：scale_fill_viridis()
安装完成后开始绘图，首先生成测试数据
df &lt;- data.frame("x" = rnorm(10000), "y" = rnorm(10000))
&gt; head(df)
x y
1 0.2505781 0.05379511
2 -0.2779240 0.75343075
3 -1.7247357 0.24985048
4 -2.0067049 -0.44410484
5 -1.2918083 -0.05027016
6 0.3658382 -0.46777918
如果你有实际数据，也可以按照这种方式进行整理，比如在excel中整理好，分成两列，分别代表横轴和纵轴，然后导入R语言中进行绘图。
ggplot(df)+
geom_pointdensity(aes(x=x,y=y))
绘图的核心函数geom_pointdensity生成散点密度图，如果直接运行，结果图如下：
看起来配色不太好看，换成青翠渐变色：
ggplot(df)+
geom_pointdensity(aes(x=x,y=y))+
scale_color_viridis() +
theme_bw()
添加scale_color_viridis函数修改配色： 方法二：ggdensity 这个包也是属于ggplot2扩展包，用于绘制密度图，效果和刚才差不多，优点是提供geom_hdr函数，功能比较多。
安装与使用方法 install.packages("ggdensity")
if (!requireNamespace("remotes")) install.packages("remotes")
remotes::install_github("jamesotto852/ggdensity")
还是使用刚刚创建的假数据来展示：
p &lt;- ggplot(df, aes(x, y)) + coord_equal()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de146e80165974669f6a1b6e49f2782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81f1c6e06d64ca46de5c0a932d082d1/" rel="bookmark">
			【虚拟换衣&#43;论文&#43;代码】2403.OOTDiffusion：高分辨率(1024x768)可控的虚拟试穿（已开源，暂不能训练）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目地址：https://github.com/levihsu/OOTDiffusion
试用地址：https://ootd.ibot.cn/
论文：2403.OOTDiffusion: 基于衣服融合的可控虚拟试穿潜在扩散
arxiv: Outfitting Fusion based Latent Diffusion for Controllable Virtual Try-on | readpaper
在comfyui中使用: https://github.com/StartHua/ComfyUI_OOTDiffusion_CXH
b站说明：https://www.bilibili.com/video/BV1nj421Q7yg
一、简介 基于图片虚拟试穿（image-based virtual try-on ，VTON）
基于扩散模型全套试穿：Outfitting over Try-on Diffusion (OOTDiffusion)
利用预训练的潜在扩散模型的力量(pretrained latent diffusion models)，用于现实和可控的(realistic and controllable)虚拟试穿。在没有明确的衣物形变适应过程(warping process)的情况下，
提出了一个outfitting UNet来学习服装细节特征，在扩散模型去噪过程中，通过我们提出的服装融合outfitting fusion将其与目标人体融合。
1.1 原文展示结果 生成分辨率 1024x768
第一行数据，是在`VITON-HD，半身数据集上训练的，支持上半身衣服（upper-body garment）
第二行，在Dress Code 数据集训练, 支持上半身服装(upper-body)、下身服装(upper-body)和裙子（dresses）
1.2 实测结果 生成衣服保存特征还是会有问题
二、如何训练？ 2.1 数据集 1024x768分辨率
VitonHD数据集
13,679对正面半身模型和相应的上半身服装组成，其中2032对作为测试集。
Dress Code数据集
15,363/8,951/2,947 个全身模型的图像对和相应的上半身服装/下身服装/服装组成，其中每个服装类别的 1,800 对作为测试集。
训练参数 实验中，我们通过继承Stable Diffusion v1.5 的 预训练权重来初始化 OOTDiffusion 模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81f1c6e06d64ca46de5c0a932d082d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b3c3ceff686d9564cadefcb03b85240/" rel="bookmark">
			【机器学习算法】: MeanShift算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之所以把这个算法单独拿出来讲解，是因为这个算法比较有用，很多算法搭配这个算法，实现起来效果会更好，但是这个算法放到哪个章节都显得很突兀，因为这个算法其实是一个机器学习中的聚类算法，所以应该把这个算法和其他几种聚类算法比如kmeans、DBSCAN、层次聚类算法Birch等放在一起写，但是由于精力有限，先单独成一章把这个算法说清楚吧，而且这个算法的亮点就是用在图像处理领域。其他几种聚类算法以后有机会再写机器学习算法时再写吧。
meanshift算法可以实现对图像在色彩层面进行平滑滤波，它可以中和色彩分布相近的颜色，平滑色彩细节，侵蚀掉面积较小的颜色区域。实现效果如下：
我们可以看到meanshift可以很好的平滑掉图像上彩色细节，图像上的颜色都变成一片一片的了，所以用这个算法我们做一些图像特效还是蛮不错的。但是如果只是用于图像特效，那价值太小了。这个算法的价值在于：它搭配canny算法可以得到效果更加好的边缘检测效果；搭配分水岭算法可以得到更好的图像分割效果；搭配轮廓检测函数cv2.findContours()可以得到更好的轮廓效果；搭配直方图可以得到更好的匹配效果，可以用于视频中的运动跟踪了。
小结：meanshift算法的基本功能是实现图像的色彩滤波、但这个算法搭配其他算法可以更好的实现图像分割、前后景提取、视频跟踪等功能。
meanshift算法并不是像我们第7章图像平滑那章里面讲的，都是用各种滤波核去和图像进行卷积运算而实现图像平滑目的的。meanshift算法本质上一种机器学习算法，是机器学习中的聚类算法的思路和原理，是一种无监督的分类算法。就是把图像的所有像素点看成一个个没有标签的样本数据，然后用聚类方法探索这些样本数据的内部规律，把所有样本分成若干个类别，实现聚类。如果我们对机器学习算法中的聚类算法比较熟悉，那就很容易理解meanshift算法。
一、MeanShift算法原理 机器学习中的meanshift算法原理非常简单，如下图所示：
上面这些数据不需要标签，是无监督机器学习，就是自动聚类，不需要人为干预，也不需要事先规定打算把数据分为几类(kmeans就需要事先确定分几类，也就是k这个超参数需要提前指定)，我们只要在初始化时随机选取一个样本点，以这个样本点为圆心，设定一个半径，被这个圆套住的样本点，计算这些样本点的均值(也称为质心)，然后将圆心移动到这个均值点上，再画圆，再计算被圈住的样本点的均值，再移动圆心到新的均值点上，再画圆，再算均值，再移动圆心。。。如此反复迭代，直到质心不变，或者改变很小，小于你设定的阈值，我们就认为达到收敛状态，就停止迭代，此时被最后一个圆圈套住的样本点我们就认为是一类的，我们把这些样本标记为簇1。
然后我们再重复上面的步骤，再随机选取一个样本点，重复上面的步骤，直到收敛，就又被圈出一类，我们给这些样本标记为簇2。
如此反复。。。直到所有的样本点都被标记上标签，就停止。
然后我们再计算各个簇的质心之间的距离，如果两个簇的质心之间的距离很近，小于你设定的阈值，就合并两个簇为一簇。这样就实现了分类。看下面的动态图演示：
每个黑点都代表每轮迭代时随机选取的样本点，但它们经过迭代后最终都重叠到每一类的中心位置。
二、meanshift算法的公式推导 Mean Shift这个概念最早是由Fukunaga等人于1975年在一篇关于概率密度梯度函数的估计（The Estimation of the Gradient of a Density Function, with Applications in Pattern Recognition）中提出来的，其最初含义正如其名，自动找到最高密度处。但是在以后的很长一段时间内Mean Shift并没有引起人们的注意，直到20年以后，也就是1995年，另外一篇关于Mean Shift的重要文献（Mean shift，mode seeking, and clustering ）发表。在这篇文献中，Yizong Cheng对Mean Shift算法进行了两个方面的改进：一是，Yizong Cheng定义了一族核函数，使得随着样本与被偏移点的距离不同，其偏移量对均值偏移向量的贡献也不同；二是，Yizong Cheng还设定了一个权重系数，使得不同的样本点重要性不一样，这大大扩大了Mean Shift的适用范围。
import numpy as np import random DISTANCE_THRESHOLD = 1e-4 CLUSTER_THRESHOLD = 1e-1 def distance(a,b): return np.linalg.norm(np.array(a)-np.array(b)) def Gaussian_kernal(distance,sigma): return (1/(sigma*np.sqrt(2*np.pi)))*np.exp(-0.5*distance/(sigma**2)) class MeanShift(object): def __init__(self,kernal = Gaussian_kernal): self.kernal = kernal def shift_points(self,center_point,whole_points,Gaussian_sigma): ##计算center_point点移动后的坐标 shifting_px = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b3c3ceff686d9564cadefcb03b85240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2f4be310c15eb53708863a585fbd69/" rel="bookmark">
			R语言快速读取数据vroom
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言快速读取大文件 想象一下，一辆赛车在巴音布鲁克赛道上，嗖的一声飞驰而过，这种场景是不是很酷！R语言中，如果用vroom读取一个GB级别的大文件，也能体会到这种速度感。
今天分享的一个R小技巧是读取大文件的最佳方式，尤其是GB以上的文件，比如常见的csv、tsv、txt等类型的文件。还可以批量读取、远程读取、自动解压缩，用起来体验非常不错。
如何使用？ install.packages("vroom")
library(vroom)
# install.packages("pak")
pak::pak("tidyverse/vroom")
首先安装一下，这个包是属于tidyverse生态圈，由Rstudio公司官方维护，主要是用C++进行优化。
官方宣称的速度可以达到1.23 GB/s
读取一个1.55G的文件，使用传统方式一分半，用vroom几秒钟就完成
vroom有自动识别文件格式功能，所以不管是csv，还是tsv文件都只需要同一个读取指令vroom(”xxx.csv”)就可以。
读取CSV文件 vroom::vroom("mtcars.tsv",
col_types = list(cyl = "i", gear = "f",hp = "i", disp = "_",
drat = "_", vs = "l", am = "l", carb = "i")
)
#&gt; # A tibble: 32 × 10
#&gt; model mpg cyl hp wt qsec vs am gear carb
#&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;fct&gt; &lt;int&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac2f4be310c15eb53708863a585fbd69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544cbddb69a0ff5e80f13eba5c53b068/" rel="bookmark">
			数据结构-＞双向链表带你体验开火车（哨兵）与拼接火车（应用）厢的乐趣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉
🍎个人主页：橘橙黄又青-CSDN博客
目的：学习双向带头链表的增，删，查，销毁。
1.🍎 双向链表的结构 注意：这⾥的“带头”跟前⾯我们说的“头节点”是两个概念，实际前⾯的在单链表阶段称呼不严 谨，但是为了同学们更好的理解就直接称为单链表的头节点。 带头链表⾥的头节点，实际为“哨兵位”，哨兵位节点不存储任何有效元素，只是站在这⾥“放哨 的”
哨兵位”存在的意义： 遍历循环链表避免死循环。
结构图解：
代码：
2. 🍎双向链表的实现 双向链表的定义结构：
链表空间申请节点，和初始化： 2.1🍎🍎哨兵位的申请 2.2🍎🍎带头双向链表打印 我们来分析分析：
代码：
这里补充一下：为什么是传值？因为临时拷贝一份打印就行，不用打印链表。
2.3🍎🍎双向链表的头插 2.4🍎🍎双向链表的尾插 尾插一个val尾x的元素
2.5🍎🍎双向链表的头删 2.6🍎🍎双向链表的尾删 2.7🍎🍎双线链表的查找 2.8🍎🍎双向链表在指定位置插入 2.9🍎🍎双向链表删除指定位置节点 2.10🍎🍎 双向链表销毁 3.🍎项目代码 Test.c
#include"List.h" void ListTest01() { //LTNode* plist = NULL; //LTInit(&amp;plist); LTNode* plist = LTInit(); //尾插 //LTPushBack(plist, 1); //LTPushBack(plist, 2); //LTPushBack(plist, 3); //LTPushBack(plist, 4); //LTPrint(plist); //头插 LTPushFront(plist, 1); LTPushFront(plist, 2); LTPushFront(plist, 3); LTPushFront(plist, 4); LTPrint(plist); //4-&gt;3-&gt;2-&gt;1-&gt; // //LTPopBack(plist); //LTPrint(plist); //LTPopBack(plist); //LTPrint(plist); //LTPopBack(plist); //LTPrint(plist); //LTPopBack(plist); //LTPrint(plist); //LTPopBack(plist); //LTPrint(plist); // //头删 //LTPopFront(plist); //LTPrint(plist); //LTPopFront(plist); //LTPrint(plist); //LTPopFront(plist); //LTPrint(plist); //LTPopFront(plist); //LTPrint(plist); //LTPopFront(plist); //LTPrint(plist); LTNode* findRet = LTFind(plist, 3); /*if (findRet == NULL) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/544cbddb69a0ff5e80f13eba5c53b068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750db0e8a8a619a06ae14f5c1dba8e12/" rel="bookmark">
			MySQL优化大总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL层优化应遵循的五条原则 1.1、减少数据访问： 设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO；
1.2、返回更少的数据： 只返回需要的字段和数据分页处理 减少磁盘IO及网络IO；
1.3、减少交互次数： 批量DML操作，函数存储等减少数据连接次数；
DML（Data Manipulation Language）语句： 即数据操纵语句，用来查询、添加、更新、删除等
1.4、减少服务器CPU开销： 尽量减少数据库排序操作以及全表查询，减少CPU内存占用；
1.5、利用更多资源： 使用表分区，可以增加并行操作，更大限度利用CPU资源。
二、SELECT语句-语法/执行顺序 2.1 语法顺序 SELECT
DISTINCT &lt;select_list&gt;
FROM &lt;left_table&gt;
&lt;join_type&gt; JOIN &lt;right_table&gt;
ON &lt;join_condition&gt;
WHERE &lt;where_condition&gt;
GROUP BY &lt;group_by_list&gt;
HAVING &lt;having_condition&gt;
ORDER BY &lt;order_by_condition&gt;
LIMIT &lt;limit_number&gt;
2.2 执行顺序 SELECT执行顺序 顺序关键字描述1FROM&lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。2ON&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选3JOIN&lt;join, left join, right join...&gt;&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中4WHERE&lt;where条件&gt; # 对上述虚表进行筛选5GROUP BY&lt;分组条件&gt; # 分组6&lt;SUM()等聚合函数&gt;# 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的7HAVING&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选8SELECT&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外9DISTINCT# 数据除重10ORDER BY&lt;排序条件&gt; # 排序11LIMIT&lt;行数限制&gt; 三、基础 SQL优化 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/750db0e8a8a619a06ae14f5c1dba8e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a4dc9299bbdf0606a360aa925a94d2/" rel="bookmark">
			机器时代的无情：无论领子颜色，取代无可避免
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		被淘汰的不仅是工作，更是我们的技能 全球变暖对人类是否有益，取决于你居住的地方。对生活在寒冷地区的人来说，全球变暖可能是好事。全球变暖其实就是地球生命的冷热循环，本身并非灾难。但最大的问题在于温度变化过快，动植物无法及时适应。如果这种气候变化持续几个世纪，可能会导致许多动植物遭殃。科技变化对劳动力市场的影响也是如此。只要变化不那么快，市场就能自我调整；但如果变化太快，市场就会变得混乱。目前，人工智能的飞速发展正在使劳动力市场变得混乱：一方面，自动化正在取代工人，导致工作机会减少；另一方面，科技发展改变了商业模式和工作方式，一些旧的工作和技能将被淘汰。就像银行装了 ATM 机，就裁了好多柜员，招了些网络工程师。工人学新技能要时间，有人会跟不上，要么被裁要么重新培训，所以企业只招能适应新时代的工人。
假设发展了200年的科技，是在 20 年内高速发展的。小明和父母都在农场工作，农业变革改变了整个行业，崭新的耕种机、打谷机和收割机出现了。在华尔街金融家的支持下，企业开始收购各地的农场。几年之内，小明家的农场就会被夺走，而他只有高中文凭，他掌握的给马修蹄、犁直沟、给干草压捆的技能，突然没用了。但是他还得吃饭。最后，他只能背井离乡去大城市寻找一份工作谋生，每天 10 个小时操作一台新机器，才能换来一日三餐。可不久之后，失业在家，只能被迫打零工的父母生病了，为了支付昂贵的医疗费用，小明回家抵押了房子，可最终还是没能救回他们……这就是科技高速发展下，大众所面临的生存困境。
对于少数保住工作的人来说，他们住在小区住宅中，虽然只能勉强度日，但已经让人羡慕不已。然而，另一个天翻地覆的变化即将到来：人造劳动者将取代大部分技术工人，合成智能将大面积代替需要由受过教育的人来完成的工作。很多新科技在初期应用时，会替代工人完成工作，但更厉害的科技会直接淘汰现有工作的种类。例如，亚马逊通过使用人工智能来改善存储模式，减少了对仓库管理员的培训和知识要求，让他们更容易被替代。自动化和流程再造会导致人们大面积的失业。有人认为需要人际交往或说服能力的工作不可能被自动化取代，其实并不是这样的。
失业现象背后：经常失业的人与没有人想雇用的人 自动化不仅让一些工作被替代，还让一些技能变得无用。它造成了两种失业：一种是周期性失业，指的是人们会随着经济周期的循环，在就业和失业之间来回摇摆。经济萧条时，失业率更高，穷人变得更多了。经济复苏了，失业的人减少，待业时间也会变短。这就像房地产：市场萧条时，待售的房子就多，卖得也慢；市场回暖了，多余的库存很快就被出售了。另一种是结构性失业，有些人失业后就很难再找到工作了。他们整天投简历，却没人雇佣，因为他们的技能跟当前市场需求不匹配。整个劳动力市场的岗位变化速度远超人们学习新技能的速度。所以他们要么去接受再培训，要么就只能被淘汰。以房地产为例，这种等待出售的二手旧房屋，并不是现在购房者所青睐的户型或样式。过去，影响理想房屋条件的因素变化很慢，所以建筑商和改造商有足够的时间去适应。但是，自动化使得发明和应用的速度变得非常快，他们都无法适从。
这些变化很难预测和衡量。一般来说，研究劳动市场的专家需要数据支持和同行评审才能做出预测和发出警报。但表格数据反映的是过去，无法预测未来那些打破常规、难以衡量的趋势和风险，这才是关键问题。因为有用的技能一直在变，所以对劳动力市场来说，失业统计或者变化率反映不了真实情况。因此，传统数学工具无法分析劳动场所的消失和工作的变化。作为管理者或个人，最重要的是预测那些还没有变成数字的趋势。
在市场和科技的双重推动下，公司的运转效率将会变得越来越高。举个例子，假如要完成 100 万的销售额，沃尔玛可能需要雇佣 5 个人，而亚马逊只需要雇佣 1 个人就可以了。这表明，随着实体店向线上零售的转型，很多人可能会面临失业的困境。在物流领域，自动驾驶技术和人工智能、人造劳动者已经开始结合应用了。力拓集团的卡车车队在两年的试用期内，连续运输了 4200 万吨货物，行驶里程超过 45 万公里。这些卡车由珀斯操作中心控制，靠 GPS 系统自动导航行驶。这项技术普及后，可能会导致很多长途卡车司机失业。
自动充电、自主列队的无人驾驶卡车，集装箱商业运输新模式
各行各业的机器人替代现象：就业岗位的侵占与转型 未来司机可能会失业，但售货员不会，不过这也不代表售货员就可以高枕无忧了。因为售货员的工作内容已经变了，很多售货员可能会因为无法适应而被淘汰。让沃尔玛卖鞋的老太太去管亚马逊的网店商品，或者让只有高中文凭的卡车司机通过远程计算机操纵汽车，都是非常困难的。如今，能感知和运行的机器人大量进入劳动力市场，抢了很多人的饭碗。不管是体力劳动，还是脑力劳动，都将被自动化取代。
农业机械工人 城市化让农村种地的人越来越少，听说中国农民还不到 2 亿。转基因技术普及后，种子被垄断了，除草剂和化肥的价格也一年比一年高，农产品的售价却被控制在一定范围内，涨不了价，农民种地挣不到多少钱，要是遇上天灾或者市场波动，说不定还得赔钱甚至破产。所以，劳动力和产量的不足导致中国每年要进口 1 亿多吨粮食。
不过随着科技发展，中国的粮食问题会得到解决。现在已经用于生产的农业机器人可以给庄稼施肥、浇水、打农药，还能全天 24 小时不停地干农活。另外，人工智能也能帮农民种地，它可以通过物联网、大数据分析等技术，给农民提供种地的建议和指导，还能帮农民了解市场行情，让交易更公平。但是一些农民可能会因此失业，因为操作和维护农业机器人需要专业知识，没受过培训的农民可能干不了。
你一定要看的5个神奇的农业机器人！
机器仓管员 中国现在已经有机器仓管员了，一些大型物流企业和电商平台都在用。机器仓管员主要靠自动化和机器人技术，实现仓库里货物的自动存取、搬运和管理。AI 技术可以通过优化算法和自动化技术，提高物流仓储的效率和准确性，降低人力成本和错误率。同时，AI 还可以通过智能监控和预警系统，提高物流仓储的安全性，减少事故发生的可能性。这些技术的应用，不仅提高了仓库的效率，还降低了人力成本和错误率。随着物流仓储行业越来越自动化和智能化，一些低技能的工作岗位会被自动化设备和机器人代替，导致一些人失业。
你一定要看的5个神奇的仓库机器人！
自动驾驶汽车 现在汽车成了大家出门的主要交通工具，车多了，问题也跟着来了，什么交通事故、车位紧张、养车贵、车辆闲置时间长，全来了。为了解决这些问题，就有了自动驾驶技术。自动驾驶的车，用智能导航和规划路线，避开堵车，提高出行效率；靠传感器和算法，避免碰撞，减少事故。它还能让闲置的车赚钱……但这也会让很多司机失业，汽车企业人力成本大幅降低，乘客支付的费用也降低不少。
武汉无人驾驶的出租车，不愧是科技赛博之城
陪伴机器人 随着单身和独居人口增加，男女对立加剧，超单身社会形成了。为了解决单身人士、社恐、留守儿童、残障人士和老年人的孤独感和无人照顾的问题，陪伴机器人市场发展壮大，很多企业推出了各种陪伴机器人。这些机器人能做各种事，比如聊天、播放音乐、提醒日程、叠衣服、洗盘子、做美食、冲咖啡，甚至弹钢琴。现在，它还能谈恋爱、滚床单。
新泽西的 TrueCompanion 公司开发了全尺寸交互式性爱娃娃，有男有女。公司的创始人道格拉斯·海因斯在 2010 年的采访中说：“人工智能是整个项目的根基。机器人可以跟你聊天，跟你示爱。她会说话、会听，还能感受到你的抚摸。” 在现实中，卖淫是犯法的，但卖成人用品就合法。所以，这种特殊的陪伴机器人有很大市场潜力。但随着陪伴机器人不断进化，人们可能会减少人际互动，影响传统的家庭价值观，改变婚姻观念。
震撼发布！全新人工智能爱情机器人即将火爆上市！
AI律师 过去，许多人法律意识淡薄，不知用法律维权，或因高额律师费而放弃。现在，在线法律服务更方便、便宜。NLP 和机器学习技术能帮助律师分析文件、案例并提供建议。区块链技术可保证记录安全、透明和不可篡改。AI 辅助决策工具也能帮助律师做决定。AI 法律的兴起和普及会降低大众法律咨询成本，但也会让很多律师失业。
人工智能，可以取代律师吗？
AI医生 医疗领域一直存在费用高、资源分配不均、看病难、效率低等问题。有些无良医生还会滥用职权，乱开检查单、乱做手术、乱开药，甚至收红包，这不仅增加了患者的就医成本，还破坏了医患关系。科技发展让在线医疗服务更方便，AI 还能提供远程医疗、疾病预测、预防措施和健康管理建议；手术机器人可以做微创手术，降低风险，缩短恢复期。AI 和机器学习可以帮医生分析数据和案例，区块链给医疗记录提供安全保障，决策工具也能帮医生做出更明智的治疗决策。AI 医生的兴起和普及将提高患者治病的效率，降低看病的成本，但也会给医护人员带来失业风险。
AI医生MedGPT问世，让稀缺医疗资源触手可得！
AI教师 长期以来，教育存在很多问题，比如资源不均衡、质量不齐、成本高、负担重等，还有一些教师违规收费、有偿补课、指定购书、收礼……这些不仅增加了学生和家长的学业和经济负担，还背离了教育的初衷——开启心智、培养创新能力。随着 AI 教学的普及，人工智能会替代一些重复、机械的教学工作。在线教育平台提供很多优质资源，学生能随时随地学习。人工智能和机器学习可以帮老师分析学生情况，提供个性化教学方案。老师的工作从传统的备课、讲课变成学习教练，引导学生学习和思考。此外，在老师或助理的帮助下，学生在线完成作业。在这场变革中，一些不能适应的老师会失业。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a4dc9299bbdf0606a360aa925a94d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c8ffcd78f445506f2abb29fb19d724/" rel="bookmark">
			Linux 命令操作手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Boot项目前后台二、进程三、防火墙四、查看系统版本五、权限赋予六、远程同步文件七、目录八、文件和数量九、解/压缩十 、大文件分割方案十一、查看文件中关键词出现的次数十二、添加/删除/修改/查看用户和用户组十三、寻找文件十四、清空文件内容十五、磁盘占用+删除包含某字符的行十六、后台启动脚本十七、常用命令十八、Shell脚本专栏十九、linux crontab定时任务常用梳理二十、vim专栏二十一、linux shell脚本关闭指定端口号的进程二十二、Linux 便笺技巧专栏 一、Boot项目前后台 说明执行命令直接(前台)运行jarjava -jar jar的项目名称(后台)运行jar项目,并记录日志nohup java -jar jar的项目名称 &gt;msg.log 2&gt;&amp;1 &amp;指定端口(后台)启动jar并记录日志nohup java -jar jar的项目名称 --server.port=8082 &gt;msg.log 2&gt;&amp;1 &amp;指定端口(后台)启动jar不记录日志，项目内部有专门的日志框架记录日志logback、log4j2nohup java -jar jar的项目名称 --server.port=8082 &gt;/dev/null &amp;默认指定端口(后台)启动jar，会生成nohup.out文件记录日志nohup java -jar demo-0.0.1-SNAPSHOT.jar --server.port=8083 2&gt;&amp;1 &amp;查看监控日志tail -f 日志文件名退出当前命令窗口ctrl + c① 前台启动和后台启动的区别？说明执行命令:–:–前台启动关闭命令窗口时，服务停止后台启动无命令窗口，服务进程后台运行正常Linux命令大全(手册)https://www.linuxcool.com 二、进程 说明执行命令查看java/其他软件进程 专业术词叫过滤`ps -ef杀死进程kill -9 进程号 linux shell脚本关闭指定端口号的进程
https://gblfy.blog.csdn.net/article/details/111825808
三、防火墙 ① Centos7 常用命令
说明命令查看防火墙的状态systemctl status firewalldreboot 永久关闭防火墙systemctl disable firewalld启动防火墙systemctl start firewalld开机启动防火墙systemctl enable firewalld关闭防火墙(临时,重启失效)systemctl stop firewalld重启防火墙firewall-cmd --reload② Centos7 查看开放端口命令及开放端口号说明命令:–:–查看已开放的端口firewall-cmd --list-ports查询端口号8080 是否开启firewall-cmd --query-port=8080/tcp开放端口（开放后需要要重启防火墙才生效）firewall-cmd --zone=public --add-port=8080/tcp --permanent重新启动防火墙firewall-cmd --reload关闭端口（关闭后需要要重启防火墙才生效）firewall-cmd --zone=public --remove-port=8080/tcp --permanent③ Centos 6 常用命令说明命令:–:–查看防火墙的状态service iptables status关闭防火墙service iptables stop启动防火墙service iptables start重新启动防火墙service iptables restart vim /etc/sysconfig/iptables ④ Centos6 端口操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87c8ffcd78f445506f2abb29fb19d724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbff5bd740b7ba1c0498dbf5ee33eb6/" rel="bookmark">
			java 数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JDBC java database connectivity， JDBC是一套面向对象的应用程序的接口，是一个可以执行SQL语句的Java API,， 用于链接应用程序与数据库之间的桥梁。JDBC不直接访问数据库，依赖于数据库厂商提供的数据库驱动程序。
1.JDBC-ODBC 2.JDBC驱动程序的类型 二、数据库常用接口 1.connection接口 2.statement接口 3.preparestatement接口 4.DriverManager接口 5.ResultSet接口 三、数据库操作 连接、查询、模糊查询like 1.连接，顺序获取查询结果、模糊查询like package nyClient; import java.lang.*; import java.sql.*; public class mySql { Connection connection; //Connection con;//不能在这里定义 //Statement sqlStatement;// static Connection con;//不能在这里定义 static Statement sqlStatement;// static ResultSet resset; public Connection getConnection() { try { Class.forName("com.mysql.jdbc.Driver");//通过此函数加载jdbc驱动程序 System.out.print("数据库驱动加载成功" + "\r\n"); } catch (ClassNotFoundException e) { // TODO: handle exception e.printStackTrace(); } try { connection = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/dbs", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cbff5bd740b7ba1c0498dbf5ee33eb6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/23/">«</a>
	<span class="pagination__item pagination__item--current">24/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/25/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>