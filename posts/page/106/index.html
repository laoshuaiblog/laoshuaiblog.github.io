<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811da6e85f3f37503eda11d891ba1271/" rel="bookmark">
			J2EE知识梳理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言J2EE章节详细链接思维导图总结 前言 学习完前面的相信大家对J2EE都轻车熟路了吧，今天就来做个总结方便日后查看调度
J2EE章节详细链接 环境搭配+认识集合https://blog.csdn.net/licmi/article/details/105230111set集合https://blog.csdn.net/licmi/article/details/105331434集合框架小结https://blog.csdn.net/licmi/article/details/105374080DTD约束https://blog.csdn.net/licmi/article/details/105421725xpath解析https://blog.csdn.net/licmi/article/details/106266124xml建模https://blog.csdn.net/licmi/article/details/106305815反射https://blog.csdn.net/licmi/article/details/106323374jsp自定义标签https://blog.csdn.net/licmi/article/details/106360922通用分页（一）https://blog.csdn.net/licmi/article/details/106441305通用分页（二）https://blog.csdn.net/licmi/article/details/106461125认识mvchttps://blog.csdn.net/licmi/article/details/106498785自定义mvc框架应用https://blog.csdn.net/licmi/article/details/106653548 思维导图 方便查看，所以我把知识点分开做的。首先是环境搭建+集合框架
然后就是xml
XML是一种通用的数据交换格式,它的平台无关性、语言无关性、系统无关性、给数据集成与交互带来了极大的方便。XML在不同的语言环境中解析方式都是一样的,只不过实现的语法不同而已
1.什么是自定义标签
自定义标签是用户定义的JSP语言元素。当包含自定义标签的JSP页面转换为servlet时，这个标签就转换为一个名为tag handler的对象上的操作。之后当JSP页面的servlet执行时，Web容器就调用这些操作。
2.标签的特点组成
&lt;开始标签 属性=“属性值”&gt;标签体&lt;/结束标签&gt;
还有一种标签就是空标签，空标签没有标签体没有结束标签。列如：
&lt; br/&gt;&lt; hr/&gt;
&lt;开始标签/&gt;
1、什么是反射？
概念：反射是java语言中的一种机制，通过这种机制可以动态的实例化对象、读写属性、调用方法
2、为什么要学反射
用tomcat来举例，tomcat开发人员是不清楚未来程序员是否会编码出什么类也就不会去实例化未知的类，反射的好处：能够将未知的类进行实例化，
3、反射的三大作用
实例化对象 c.newInstance()
Constructor.getConstructor/Constructor.getDeclaredConstructor
注：一定要提供无参构造器
动态调用方 Method m; m.invoke
读写属性
Field set/get
1、什么是xml建模？
我们都知道.xml文件有两个作用，一是传输，二是存储数据。xml建模主要针对它的第二的功能开发的，在我们解析.xml文件我们可以发现，要写大量的代码最后得到一个数据。
2、建模是否更快捷更高效率呢？
简单的来说，就是写一些方法将xml解析变得高效，和简单，这就是xml建模。也是我们为什么要xml建模的原因(减少代码量，并且可以针对不同的需求)。
核心思想
官方来说通用分页核心思路
将上一次查询请求再发一次，只不过页码变了
为什么使用通用分页
在我们写某个项目的时候，分页是必不可少的，并且需要用到的地方还不少，所以我们学通用分页可以减少不必要的代码量让整个界面数据显示更加简洁
什么是mvc
MVC全名：Model View Controller，其中Model（模型层）、View（视图层）、Controller（控制层）
它是一种软件设计典范，用于业务逻辑处理、数据、界面显示分离
mvc的流程是什么
MVC的核心思想是将代码按照不同的作用进行划分，具体划分原则是
Model：处理大部分的业务逻辑和数据操作
View：负责渲染数据，以html的方式呈现给用户
Controller：处理用户交互，负责从视图读取数据，控制用户输入，并向模型发送数据
一个典型的MVC流程就是
controller 截获用户发出的请求
controller调用model完成数据的读取和存储
controller把数据传给view
view渲染最终结果并呈现给用户
总结 今天就到这里了如果有什么不对的地方欢迎大家在评论区留言交流改进！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4469a3b73c13cb9fa817cb00827b84/" rel="bookmark">
			华为手机使用百度地图SDK-无法定位/不显示图标的解决方案之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无法定位 很可能是由于相关权限未被许可，尤其是Android 10的系统，参见：
文档1
（关注文档1的权限申请部分即可）
文档2
定位图标不显示 我的情况是，由于用习惯了xml文件——但是xml文件用于这里定位的图标会报空，产生异常：BDMapSDKException: marker's icon can not be null
图标要使用png格式的文件，不能用xml矢量图。至少在我这儿不行，报错了。
最后我要说一句，baidu地图，WDNMD
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3878633b457ea949958d1da70367e9be/" rel="bookmark">
			Spring Cloud Gateway：使用ReadBodyPredicateFactory读取request的body，可能无法匹配404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 获取request中的body内容
常规用法 SCG自带ReadBodyPredicateFactory断言，可以将body中的内容读取到exchange对象中，使用exchange.getAttribute("cachedRequestBodyObject")获取
但是当body为空时，无法匹配该路由，导致返回404错误。
SCG route配置如下 - id: r_fapi #测试 uri: lb://LIZZ-GATEWAY predicates: - Path=/fapi/** - name: ReadBodyPredicateFactory #读取body断言 args: inClass: "#{T(String)}" #body数据类型 predicate: "#{@testRequestBody}" #自定义断言处理器 自定义断言处理器 /** * @description: ReadBodyPredicateFactory 判断器 * @author: lizz * @date: 2020/6/6 17:03 */ @Component public class TestRequestBody implements Predicate { /** * 根据内容判断是否匹配该路由 * @param o body的内容 * @return ture-匹配成功，false-匹配失败 */ @Override public boolean test(Object o) { //可以对body内容进行判断处理 //这里不做处理直接返回成功 return true; } } 在filter中的exchange读取body /** * @description: 输出请求记录 * @author: lizz * @date: 2020/2/28 1:09 下午 */ @Component public class LogFilter implements GlobalFilter, Ordered { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3878633b457ea949958d1da70367e9be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5204800324bec1b3acd498044835c111/" rel="bookmark">
			LINUX入门知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LINUX入门知识 计算机与操作系统简介计算机组成及其功能操作系统的功能完整的操作系统操作系统的接口有两类API接口和ABI接口CPU架构介绍学LINUX前必备知识冯诺依谩体系 LINUX及IT领域架构体系LINUX的由来LINUX的发行版本开源闭源协议安装LINUXLINUX系统组成程序管理用户界面终端terminal远程连接命令行接口目录结构 LINUX哲学思想基础命令使用命令的语法通用格式命令的使用帮助几个基础命令常用命令 LINUX系统结构图LINUX文件系统LINUX系统上的文件类型基本命令bash的基础特性目录管理类命令文件查看类命令文件管理工具LINUX系统变量基础 计算机与操作系统简介 计算机组成及其功能 ENIARC：埃尼阿克，世界上第一台通用计算机，诞生于1946年美国宾夕法尼亚大学；冯诺依曼体系－计算机五大基础部件：运算器、控制器、存储器、输入设备、输出设备； CPU：运算器、控制器、内部存储器（寄存器、缓存）；
存储器：分主存储器（内存）和辅助存储器（外存）；内存RAM（Random Access
Memory），仅仅用于存放当前正在运行的程序和数据，断电后数据消失。外存，通常指磁盘、光盘等，能长期保存数据信息；
输入设备：下指令，提供数据等（鼠标、键盘等）；
输出设备：输出数据加工后的结果（显示器等）；
最小存储单元Cell：1 Bytes=8 bits
程序：
指令 + 数据
算法 + 数据结构
CPU寻址能力：
32位CPU只能使用最多4G的内存，计算方法：
232 = 210 * 210 * 210 * 22
= 1024 * 1024 * 1024 * 4 = 4294967296(Bytes)
= 1024 * 1024 * 4 = 4194304(KB)
= 1024 * 4 = 4096(MB)
= 4(GB)
过程式编程语言：
顺序执行：依次；
循环执行：将整个循环体执行n次；
选择执行：仅执行其中的一个分支；
操作系统的功能 驱动程序
进程管理
安全
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5204800324bec1b3acd498044835c111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b6628e82ea649f8657f26748995f14/" rel="bookmark">
			在build中配置resources,来防止我们资源导出失败的问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e14e61337cbf0eb464131ebf405ff33/" rel="bookmark">
			在x86电脑上交叉编译mips linux内核并升级替换原mips内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主机环境使用的是uos系统
第一步 下载安装gcc交叉编译器
刚开始走了很多弯路。搞了GNU gcc源码安装，还有这个网页【Linux】Linux下搭建MIPS交叉编译环境安装乱七八糟的软件包。都太过麻烦了。
最后是自己查找了一下安装源，已经提供了gcc mips交叉编译器，
sudo apt-cache search gcc | grep mips 这里我根据mips测试机的gcc版本，选择的gcc-8-mips64el-linux-gnuabi64。
查看gcc版本可通过如下命令查看：
uos@uos-PC:~$ which gcc /usr/bin/gcc uos@uos-PC:~$ uos@uos-PC:~$ uos@uos-PC:~$ uos@uos-PC:~$ ls -l /usr/bin/gcc lrwxrwxrwx 1 root root 5 5月 26 09:36 /usr/bin/gcc -&gt; gcc-8 uos@uos-PC:~$ uos@uos-PC:~$ uos@uos-PC:~$ ls -l /usr/bin/gcc-8 lrwxrwxrwx 1 root root 29 5月 26 09:36 /usr/bin/gcc-8 -&gt; mips64el-linux-gnuabi64-gcc-8 uos@uos-PC:~$ uos@uos-PC:~$ uos@uos-PC:~$ ls -l /usr/bin/mips64el-linux-gnuabi64-gcc mips64el-linux-gnuabi64-gcc mips64el-linux-gnuabi64-gcc-nm mips64el-linux-gnuabi64-gcc-8 mips64el-linux-gnuabi64-gcc-nm-8 mips64el-linux-gnuabi64-gcc-ar mips64el-linux-gnuabi64-gcc-ranlib mips64el-linux-gnuabi64-gcc-ar-8 mips64el-linux-gnuabi64-gcc-ranlib-8 uos@uos-PC:~$ ls -l /usr/bin/mips64el-linux-gnuabi64-gcc-8 -rwxr-xr-x 1 root root 1216744 5月 26 09:36 /usr/bin/mips64el-linux-gnuabi64-gcc-8 uos@uos-PC:~$ uos@uos-PC:~$ uos@uos-PC:~$ gcc -v Using built-in specs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e14e61337cbf0eb464131ebf405ff33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06088b514d22af30d5ed17adf92067ae/" rel="bookmark">
			Android JNI手册——Java/Kotlin与Native层的相互调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android JNI中数据和方法的传递与调用 题记1.基础数据类型的传递1.1 新建一个jni接口1.2 生成头文件1.3 jni中Android的Log1.4 实现函数 2.基础数组类型的传递3.String/String数组类型的传递4.类与方法调用4.1 上层传入类1. 新建一个类2. 获取类的签名3. 实现 4.2 在C层new类1.上层接口：2.cpp实现： 题记 说到jni相关的内容，满打满算至少搞了俩年了，基本上都是与算法或者说底层驱动做交互，这篇文章的细节其实也放在文件夹里面一年之久了，最近心有不安，还是拿出来晾晒下，还望有缘人指正交流。文章有以下俩点前置条件：
我前面博客已写过Jni的动态加载，本篇代码仍已动态加载作为范本。传送门：动态注册流程按照习惯，上层我还是会用Kotlin代码做示范。上层的Jni接口文件我采用了kotlin的单例模式，当然也可以用java，其实都是大同小异，无伤大雅。我前面的博客有对比过差异，完整的代码也有。传送门：Kotlin与Java单例模式的比较 1.基础数据类型的传递 java基础数据类型的传递基本大同小异，这里简单用int做示范。这里流程讲的仔细点，后面的类型就会简略的叙述。
1.1 新建一个jni接口 input：int
return：int
// 1. 基础数据类型 external fun putBasic(int: Int): Int 1.2 生成头文件 我们可以用javah命令生成头文件，得到jni函数和方法签名，顺便做下动态加载。
我们得到如下函数：
/* * Class: com_heima_jnitest_JniUtils * Method: putBasic * Signature: (I)I */ jint JNICALL Java_com_heima_jnitest_JniUtils_putBasic (JNIEnv *, jobject, jint); 1.3 jni中Android的Log 我感觉有必要补充一下，在jni函数中打印Android 的log需要引入android/log.h，我这里为了省事，直接自己写了个头文件，以后工程肯定会用得到。
#define TAG "HM" #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__); #define LOGI(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06088b514d22af30d5ed17adf92067ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c67a7ffceffab541ef31b4d61080c8b/" rel="bookmark">
			C语言写个简单的串口调试助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习单片机或者嵌入式编程常常要用到超级终端–串口调试助手，但有时需要我们自己做一个终端，用来当上位机。最近课设要求我们自己写个终端来处理串口信息，于是乎，接触了一些windows的串口API，做出了一个简单的串口调试助手，很简陋~
Windows把串口当作文件处理，这点很重要！
使用串口的基本流程：
1、得到串口的句柄，句柄可以看作一个指针或者是一个实例
2、配置串口，比如收发超时时间、波特率，奇偶校验
3、读写串口
一、得到串口句柄 使用CreateFile 函数，有8个参数。
不懂这些函数的使用点这个链接，可以节省你的时间
上面这个链接非常非常重要，是一个大佬的博客
//打开串口 CreateFile函数 hCom = CreateFile("COM3",GENERIC_READ |GENERIC_WRITE, 0,NULL,OPEN_EXISTING,0,NULL); if (hCom !=INVALID_HANDLE_VALUE) { printf("串口打开成功!\n"); }else { printf("串口打开失败!\n"); } 二、配置串口 1、设置读写超时等待时间
使用SetCommTimeouts 函数，2个参数。
COMMTIMEOUTS timeouts;	//windows.h头文件设置的一种变量类型 //读超时 timeouts.ReadIntervalTimeout = 1000;	//读操作时两个字符间的间隔超时 timeouts.ReadTotalTimeoutMultiplier = 500;	//读操作在读取每个字符时的超时 timeouts.ReadTotalTimeoutConstant = 5000;	//读操作的固定超时 //写超时 timeouts.WriteTotalTimeoutMultiplier = 0;	//写操作在写每个字符时的超时 timeouts.WriteTotalTimeoutConstant = 2000;	//写操作的固定超时 SetCommTimeouts(hCom,&amp;timeouts); 2、设置输入输出缓存区大小
使用SetupComm函数，2个参数。
//设置输入输出缓冲区大小 SetupComm(hCom,500,500); 3、设置串口波特率、数据位、奇偶校验等属性
使用GetCommState、SetCommState 函数，都是2个参数。
DCB dcb; //库里的一种数据结构类型 if (GetCommState(hCom, &amp;dcb) == 0) { return -1; } dcb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c67a7ffceffab541ef31b4d61080c8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d139b1e7e8b0ee1fc370cfd73f67506/" rel="bookmark">
			前端JS处理后台传递的Boolean类型的获取方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到的问题: 页面需要获取后端传递的boolean类型的数据, 如果不进行处理,显示true/false
function showPageList(datas) { $("#pageList div div").addClass("blockquote-reverse"); $("#pageList div div").attr("style", "border: 0px none;"); $("#bodyList").empty(); var tableHtml = "";//拼接展示列表 for (var key in datas) { var data = datas[key]; tableHtml += '&lt;tr&gt;' + '&lt;td&gt;' + data.Name + '&lt;/td&gt;' + '&lt;td&gt;' + data.EmpID + '&lt;/td&gt;' + '&lt;td&gt;' + data.jobName + '&lt;/td&gt;' + '&lt;td&gt;' + data.EnterpriseName + '&lt;/td&gt;' + '&lt;td id="'+data.FirstPut+'"&gt;' + (data.FirstPut == true?"是":"否") + '&lt;/td&gt;' + '&lt;td&gt;&lt;button type="but ton"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d139b1e7e8b0ee1fc370cfd73f67506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85092314e2d4c0f62591c858db3d8e3/" rel="bookmark">
			技术名词：脑裂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 脑裂（brain-split）：
脑裂是指在主备切换时，由于切换不彻底或其他原因，导致客户端和Slave误以为出现两个active master，最终使得整个集群处于混乱状态。解决脑裂问题，通常采用隔离(Fencing)机制，包括三个方面：
共享存储fencing：确保只有一个Master往共享存储中写数据。 客户端fencing：确保只有一个Master可以响应客户端的请求。 Slave fencing：确保只有一个Master可以向Slave下发命令。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c0bccc1673491de60aee8bbbef7af6d/" rel="bookmark">
			linux kernel中的virt_to_phys代码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设VA_BITS = 48 (虚拟地址有效位), 那么kernel space的虚拟地址是：0xffff_0000_0000_0000 - 0xffff_ffff_ffff_ffff, userspace的虚拟地址是 0x0000_0000_0000_0000 - 0x0000_ffff_ffff_ffff
然后我们再看一张kernel space memory layout图 ，这张图说明了：
0xffff_8000_0000_0000 - 0xffff_8008_0000_0000 是个memory使用的，就是有映射SDRM的，也是线性一射
而0xffff_8000_0000_0000向下的kernel space virtual addr是给 kernel image使用的
在kernel中PAGE_OFFSET = 0x8000_0000_0000
#define PAGE_OFFSET	(UL(0xffffffffffffffff) - \ (UL(1) &lt;&lt; (VA_BITS - 1)) + 1) 当virt_to_phys调用时候，先判断bit47(最高有效位)，如果为1，则表示是（memory）DRAM的地址。那么直接使用X[46:0]和PHYS_OFFSET相加即可
#define __virt_to_phys(x) ({	\ phys_addr_t __x = (phys_addr_t)(x);	\ __x &amp; BIT(VA_BITS - 1) ? (__x &amp; ~PAGE_OFFSET) + PHYS_OFFSET :	\ (__x - kimage_voffset); }) PHYS_OFFSET是DRAM的真实物理地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c0bccc1673491de60aee8bbbef7af6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8e981817456baccce5e0127c041479/" rel="bookmark">
			Spring JDBC Template使用小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spring JDBC Template表结构主要方法查询queryForObject 返回单个基本类型、字符串queryForObject 返回单个实体类queryForMap 返回单个Map结果集为空或多条时的解决方案queryForList 返回基本类型、字符串的Listquery 返回对象的List批量查询 IN 插入、更新、删除插入插入并返回自增的主键使用PreparedStatement，且插入的基本类型的字段为null报错批量插入更新、删除 Spring JDBC Template 表结构 CREATE TABLE `user` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `age` int NOT NULL, `sex` tinyint DEFAULT NULL, `email` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 主要方法 查询 queryqueryForListqueryForObjectqueryForMapqueryForRowSet queryForObject 返回单个基本类型、字符串 queryForObject()方法可直接返回对象，但只能是基本类型及其包装类，以及 String，不能返回自定义对象，比如 jdbcTemplate.queryForObject(sql, User.class, id)。结果集必须为一条，否则报错
public String getName(Integer id) { String sql = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c8e981817456baccce5e0127c041479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258c678bd8322f6c583208dbcf483680/" rel="bookmark">
			VMware克隆虚拟机镜像、导入镜像，图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.克隆虚拟机镜像 1.右击当前虚拟机–》选择管理–》选择克隆
2.选择克隆自虚拟机当前状态
3.选择完整克隆
4.选择保存路径，稍等片刻即可完成克隆
2.虚拟机导入镜像 1.进入主页选择打开虚拟机
2.选择刚才克隆的虚拟机镜像。
3.在主页中就可以看到刚才复制的镜像了，复制的镜像与原来的镜像是完全一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35440898e5576fa395224f51d874bc4/" rel="bookmark">
			python seaborn.heatmap参数介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		seaborn.heatmap(data, vmin=None, vmax=None, cmap=None, center=None, robust=False, annot=None, fmt=’.2g’, annotkws=None, linewidths=0, linecolor=‘white’, cbar=True, cbarkws=None, cbar_ax=None, square=False, ax=None, xticklabels=True, yticklabels=True, mask=None, **kwargs)
vmin,vmax：用于指定图例中最小值与最大值的显示值 cmap：指定一个colormap对象，用于热力图的填充色 center：指定颜色中心值，通过该参数可以调整热力图的颜色深浅 annot：指定一个bool类型的值或与data参数形状一样的数组，如果为True，就在热力图的每个单元上显示数值 fmt：指定单元格中数据的显示格式 annot_kws：有关单元格中数值标签的其他属性描述，如颜色、大小等 linewidths ：指定每个单元格的边框宽度 linecolor：指定每个单元格的边框颜色 cbar：bool类型参数，是否用颜色条作为图例，默认为True square：bool类型参数，是否使热力图的每个单元格为正方形，默认为False cbar_kws：有关颜色条的其他属性描述 xticklabels,yticklabels：指定热力图x轴和y轴的刻度标签，如果为True，则分别以数据框的变量名和行名称作为刻度标签 mask：用于突出显示某些数据 ax：用于指定子图的位置 data：矩阵数据集，可以使numpy的数组（array），如果是pandas的dataframe，则df的index/column信息会分别对应到heatmap的columns和rows
vmax,vmin, 图例中最大值和最小值的显示值，没有该参数时默认不显示
linewidths,热力图矩阵之间的间隔大小
cmap：matplotlib的colormap名称或颜色对象；如果没有提供，默认为cubehelix map (数据集为连续数据集时) 或 RdBu_r (数据集为离散数据集时)
cmap参考的有：
cmap颜色设置
center:将数据设置为图例中的均值数据，即图例中心的数据值；通过设置center值，可以调整生成的图像颜色的整体深浅；设置center数据时，如果有数据溢出，则手动设置的vmax、vmin会自动改变
xticklabels: 如果是True，则绘制dataframe的列名。如果是False，则不绘制列名。如果是列表，则绘制列表中的内容作为xticklabels。 如果是整数n，则绘制列名，但每个n绘制一个label。 默认为True。
yticklabels: 如果是True，则绘制dataframe的行名。如果是False，则不绘制行名。如果是列表，则绘制列表中的内容作为yticklabels。 如果是整数n，则绘制列名，但每个n绘制一个label。 默认为True。默认为True。
annotate的缩写，annot默认为False，当annot为True时，在heatmap中每个方格写入数据（PS：也会显示数字）
annot_kws，当annot为True时，可设置各个参数，包括大小，颜色，加粗，斜体字等
sns.heatmap(x, annot=True, ax=ax1) sns.heatmap(x, annot=True, ax=ax2, annot_kws={'size':9,'weight':'bold', 'color':'blue'}) fmt，格式设置，决定annot注释的数字格式，小数点后几位等
sns.heatmap(x, annot=True, ax=ax1) sns.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f35440898e5576fa395224f51d874bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8372ee14dcdc0398460ad79fc38b3fa7/" rel="bookmark">
			MakeItTalk:  让图像开口说话！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“机器学习与生成对抗网络”，关注"星标"
获取有趣、好玩的前沿干货！
文自 【机器之心】 参与 魔王
未经授权，不得二次转载
不仅让真人图像开口说话，油画、素描、漫画等都能动起来！
给出一张面部图像和一段音频，能做什么？AI 有办法，比如让图像中的人开口说话！
此前，机器之心报道过三星人工智能研究中心和伦敦帝国理工学院提出的新型端到端系统，仅凭一张人脸照片和一段音频，就可以生成新的讲话或唱歌视频。
最近我们发现了一项类似的研究，马萨诸塞大学阿默斯特分校、Adobe 研究院等机构提出了一种叫做 MakeItTalk 的新方法，不仅能让真人头像说话，还可以让卡通、油画、素描、日漫中的人像说话。
论文链接：https://arxiv.org/pdf/2004.12992v1.pdf
不信就来看看效果吧！
我们首先看一看真人图像的动态化效果。
看起来不错，那么卡通画呢？
给我一个插座，我能让他成精！
还有油画。
如果我想让图像中的人物摇头晃脑高谈阔论，或者保持沉静端庄呢？
答案是也可以实现。
动图 get 不到声画同步效果？请戳下面这个视频：
那么，这是如何做到的呢？
之前的方法往往学习音频和原始像素之间的直接映射进而创建人物的说话动态，而这项研究提出的方法将输入音频信号中的内容和说话人身份信息分离开来：音频内容用来稳健地控制嘴唇及周围区域的运动；说话人信息则决定面部表情的细节和人物的头部动态。
该方法的另一个重要组件是预测能够反映说话人动态的面部特征点。基于该中间表征，该方法能够为真人头部图像合成说话状态视频。此方法还可用于艺术作品、素描、2D 卡通人物、日漫、随手涂鸦等图像。
研究者对该方法进行了定量和定性评估，结果表明与之前的 SOTA 方法相比，该方法能够生成具备更高质量的说话状态头部动画。
图 8：与 SOTA 方法的对比。
研究贡献
该研究的主要贡献如下：
提出一种基于深度学习的新架构，能够仅基于语音信号预测面部特征点，捕捉嘴唇、下巴、眉毛、鼻子和头部的姿势；
基于分离开的语音内容和说话人表征生成包含面部表情和头部动态的动画；
针对矢量风格卡通图像和真实人物面部图像各提出一种图像合成方法。这些方法可以处理训练过程中未出现的新人脸图像和卡通人物图像；
提出一组定量度量指标，并对头部动画方法的评估进行了用户调研。
MakeItTalk 架构
图 2：MakeItTalk 方法概览。
如上图所示，给出一段音频和一张面部图像，MakeItTalk 架构可以生成说话人的头部状态动画，且声画同步。
在训练阶段，研究者使用现成可用的人脸特征点检测器对输入图像进行预处理，提取面部特征点。然后使用输入音频和提取到的特征点直接训练使语音内容动态化的基线模型。为了达到高保真动态效果，研究者尝试将输入音频信号的语音内容和说话人嵌入分离开来，进而实现面部特征点的预测。
具体而言，该研究使用声音转换神经网络将语音内容和说话人身份信息分离开。
语音内容与说话人无关，仅捕捉嘴唇及周围区域的运动（参见图 2「Speech Content Animation」）。说话人的身份信息则决定了动作的细节和说话人的其余头部动态（参加图 2「Speaker-Aware Animation」）。
例如，不管谁说单词「Ha!」嘴唇都会张开，这与说话人无关，仅取决于说话内容。而嘴唇的形状和张开的幅度，以及鼻子、眼睛和头部的动态则取决于说话人的身份。
基于语音内容和说话人身份信息，MakeItTalk 模型为给定音频输出预测特征点序列。
图 3：针对不同说话人身份的特征点预测。左：给定人脸图像的静态特征点；右上：对说话时头部动作较轻的人的预测特征点序列；右下：对说话时头部动作较大的人的预测特征点序列。
为了生成光栅图像，研究者开发了两种特征点-图像合成（landmark-to-image synthesis）算法。
对于非真人图像，如油画或矢量图（图 9），该研究使用基于德劳内三角剖分（Delaunay triangulation）的简单换脸方法。
图 4：通过面部特征点和德劳内三角剖分进行卡通图像换脸。左：给出的卡通图像和面部特征点；中：德劳内三角剖分；右：由预测特征点引导进行换脸后的图像。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8372ee14dcdc0398460ad79fc38b3fa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8933ec1e949243064d94bbec1a931650/" rel="bookmark">
			高等数学复习笔记（五）-一元函数积分的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节为高等数学复习笔记的第五部分，一元函数积分的计算，主要包括： 四大积分基本法即凑微分法、换元法（第一类和第二类）、分部积分法以及有理函数积分法。
1. 凑微分法 1.1 基本导数公式（反过来用） ( x a ) ′ = a x a − 1 (x^a)'=ax^{a-1} (xa)′=axa−1， ( a x ) ′ = a x l n a (a^x)'=a^xlna (ax)′=axlna， ( e x ) ′ = e x (e^x)'=e^x (ex)′=ex ( l o g a x ) ′ = 1 x l n a （ a &gt; = , a ≠ 1 ） (log_ax)'=\frac{1}{xlna}（a&gt;=,a\neq 1） (loga​x)′=xlna1​（a&gt;=,a​=1）， ( l n x ) ′ = 1 x (lnx)'=\frac1x (lnx)′=x1​ ( s i n x ) ′ = c o s x (sinx)'=cosx (sinx)′=cosx， ( c o s x ) ′ = − s i n x (cosx)'=-sinx (cosx)′=−sinx ( a r c s i n x ) ′ = 1 1 − x 2 (arcsinx)'=\frac{1}{\sqrt{1-x^2}} (arcsinx)′=1−x2 ​1​， ( a r c c o s x ) ′ = − 1 1 − x 2 (arccosx)'=-\frac{1}{\sqrt{1-x^2}} (arccosx)′=−1−x2 ​1​ ( t a n x ) ′ = s e c 2 x = 1 c o s 2 x (tanx)'=sec^2x=\frac{1}{cos^2x} (tanx)′=sec2x=cos2x1​， ( c o t x ) ′ = − c s c 2 x = − 1 s i n 2 x (cotx)'=-csc^2x=-\frac{1}{sin^2x} (cotx)′=−csc2x=−sin2x1​ ( a r c t a n x ) ′ = 1 1 + x 2 (arctanx)'=\frac{1}{1+x^2} (arctanx)′=1+x21​， ( a r c c o t x ) ′ = − 1 1 + x 2 (arccotx)'=-\frac{1}{1+x^2} (arccotx)′=−1+x21​ ( s e c x ) ′ = s e c x t a n x (secx)'=secxtanx (secx)′=secxtanx， ( c s c x ) ′ = − c s c x c o t x (cscx)'=-cscxcotx (cscx)′=−cscxcotx [ l n ( x + x 2 + 1 ) ] = 1 x 2 + 1 [ln(x+\sqrt{x^2+1})]=\frac1{\sqrt{x^2+1}} [ln(x+x2+1 ​)]=x2+1 ​1​， [ l n ( x + x 2 − 1 ) ] = 1 x 2 − 1 [ln(x+\sqrt{x^2-1})]=\frac1{\sqrt{x^2-1}} [ln(x+x2−1 ​)]=x2−1 ​1​ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8933ec1e949243064d94bbec1a931650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db8a6bd7c950a63f444694c2e28d4d3/" rel="bookmark">
			空调机状态机verilog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章为汇总文章Verilog学习代码总结的状态机——空调机部分。
该状态机为moore型时序电路。
采用三段式设计方式。
题目要求 设计一个空调机的控制机。温度传感器控制两个输入端temp_high和temp_low, 如果室内温度较高，则temp_high为’1’， 同时temp_low为’0’; 如果室内温度较低，则temp_high为’0’， 同时temp_ low为’1’; 如果室内温度正常，则temp_high为’0’， 同时temp_low为’0’。 根据输入端temp_high和temp_ _low的值来判断当前的状态是: 1.too_hot (太热) ; 2. too_cold (太冷) ; 3.just_right (正好)，然后决定输出端heat和cool的值是’1’还是’0’,从而控制是制冷还是制热。
要求:
1.画出有限状态机,标明状态转换条件;
2.写出程序代码，标注说明和解释;
3.写出验证程序，对设计进行全面的验证。
状态转移图 源代码 module air(clk,rst,temp_high,temp_low,heat,cool); input clk,rst,temp_high,temp_low; output heat,cool; reg heat,cool; reg [1:0] cur_state,next_state; //定义三个状态 parameter TOO_HIGH = 2'b10, JUST_RIGHT = 2'b00, TOO_LOW = 2'b01; //时序 设置当前状态为预设的下一状态或初始 always @(posedge clk or posedge rst) begin if(rst)begin //重设置零 cur_state &lt;= JUST_RIGHT; next_state &lt;= JUST_RIGHT; end else begin cur_state &lt;= next_state; end end //根据当前状态决定输出 always @(cur_state) begin case (cur_state) TOO_HIGH: begin {heat,cool} = 2'b01; end JUST_RIGHT: begin {heat,cool} = 2'b00; end TOO_LOW: begin {heat,cool} = 2'b10; end default: begin {heat,cool} = 2'b00; end endcase end //根据输入决定下一预设状态 always @(cur_state or temp_high or temp_low) begin case (cur_state) TOO_HIGH: begin next_state = (temp_high == 1)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db8a6bd7c950a63f444694c2e28d4d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3395ce0a0039a9535d03df8193d308f9/" rel="bookmark">
			K_means算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据来源： 链接：https://pan.baidu.com/s/1GT2HGMRtYJsVm7iWMi4qRw
提取码：up6x
主程序： import numpy as np import matplotlib.pyplot as plt from scipy.io import loadmat mat = loadmat("./data/ex7data2.mat") X = mat['X'] def plot_data(X): plt.figure(figsize=(8, 5)) plt.scatter(X[:, 0], X[:, 1], label='point') plt.xlabel("X1") plt.ylabel("X2") plt.legend() plt.title("X") plt.grid(True) plot_data(X) plt.show() m, n = X.shape k =3 # 设置聚类中心个数 max_iters = 10 # 设置迭代次数 def init_centroids(X, k): # 随机初始化聚类中心 rand_idx = np.random.permutation(X) # 随机排列 centroids = rand_idx[:k, :] # 选前K个 return centroids def find_closest_centroids(X, centroids): # 簇分配 idx = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3395ce0a0039a9535d03df8193d308f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc28eae6e54fd567722617290f7470ce/" rel="bookmark">
			Verilog学习代码总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01、8位加法器 功能代码
module adder_8 ( cout,sum,a,b,cin ); input [7:0] a,b; input cin; output cout; output [7:0] sum; assign {cout,sum} = a + b + cin; endmodule 测试代码
`timescale 1ns/1ns module adder_8_test; reg [7:0]a, b; reg cin; wire [7:0] sum; wire cout; parameter INTERVAL; adder_8 a1(.cout(cout), .sum(sum), .a(a), .b(b), .cin(cin)); initial begin #INTERVAL {a,b,cin} = 17'b0000_0000_0000_0000_0; #INTERVAL {a,b,cin} = 17'b1101_1011_0010_0011_0; #INTERVAL {a,b,cin} = 17'b1111_0000_0000_1111_1; #INTERVAL {a,b,cin} = 17'b1001_0100_1001_0011_1; end endmodule 02、8位计数器 功能代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc28eae6e54fd567722617290f7470ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75db7bfebc959f135a6ed5069f8663aa/" rel="bookmark">
			短小精悍算例：Python如何提取数组Numpy array中指定元素的位置索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数组a的表达式如下：
import numpy as np a = np.array([1, 2, 3, 2, 2, 3, 0, 8, 3]) print(a) 输出结果：[1 2 3 2 2 3 0 8 3] 现在要找出a中元素3的位置索引。
r1 = np.where(a==3) print(type(r1)) print(r1) 输出结果： &lt;class 'tuple'&gt; (array([2, 5, 8], dtype=int64),) 可见得到的是一个tuple。如果要想得到array，采用如下表示：
r1 = np.where(a==3) print(type(r1[0])) print(r1[0]) 输出结果： &lt;class 'numpy.ndarray'&gt; [2 5 8] 还可以使用argwhere()函数进行操作：
r2 = np.argwhere(a==3) print(type(r2)) print(r2) print(r2.shape) 输出结果： &lt;class 'numpy.ndarray'&gt; [[2] [5] [8]] (3, 1) 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/105/">«</a>
	<span class="pagination__item pagination__item--current">106/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/107/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>