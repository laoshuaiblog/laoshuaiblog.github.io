<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0acc9b7bf06dbcbb6359d9e8a3e15ae/" rel="bookmark">
			关于ES6新增的script标签type为module和importmap的使用和坑点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于ES6新增的script标签type为module和importmap的使用和坑点 今天在做web3D的时候，为了简单的验证一些案例，我直接在html上书写，但是three.js的导入都是模块化的，为了解决这个问题，ES++6已经给出解决方法，那就是在script标签中，使用type为module的声明，就可以实现导入，下面展示下简单的使用：
&lt;script type="module" src="./02.js"&gt;&lt;/script&gt; //这里声明为module后，我连接到另外一个文件 02.js的内容如下：
import * as THREE from './build/three.module.js' //创建一个三维场景 const scene=new THREE.Scene() const geometry = new THREE.BoxGeometry( 50, 50, 50 ); 到这里，对于module的使用是没有问题的。
那么没问题就是有问题，后续我还需要导入另外一个模块，这个时候就非常魔怔了，我的导入是这样子的：
import * as THREE from './build/three.module.js' import { OrbitControls } from './three.js-r148/examples/jsm/controls/OrbitControls.js'; 我觉得这样子是没问题的，因为我已经声明导入了，但是关键就是浏览器一直报错，长这样子：
01.html:1 Uncaught TypeError: Failed to resolve module specifier “three”. Relative references must start with either “/”, “./”, or “…/”.
01.html:1 Uncaught TypeError: Failed to resolve module specifier "three". Relative references must start with either "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0acc9b7bf06dbcbb6359d9e8a3e15ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cafdbf1289af3aac5b186d6677dc9e6/" rel="bookmark">
			vue 导入、导出模块的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 vue 导入、导出模块的几种方式一、ESModel 规范1. export 导出 和 import {}、import * as 导入2. export default 导出 和 import 导入 CommonJS 规范1. exports. 导出 和 require 导入2. module.exports = {} 导出 和 require 导入 vue 导入、导出模块的几种方式 webpack 支持 ESModel 规范和 CommonJS 规范
一、ESModel 规范 ESModel 模块导入方式：import
ESModel 模块导出方式：export、export default
1. export 导出 和 import {}、import * as 导入 导出：
export const name = 'alias' export const age = () =&gt; { return 18 } 导入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cafdbf1289af3aac5b186d6677dc9e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8045ed9c4b87cd58b52f07ed7300ea8f/" rel="bookmark">
			@element-plus/icons-vue 图标 icon 不显示的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 &lt;i class = "el-icon-shopping-cart-2"&gt;&lt;/i&gt; 此方法在vue3中已经无效，不会报错，但也不能显示出图标。
解决方法 在官网中找到需要的图标，直接点击复制。
具体方法代码如下：
&lt;template&gt; &lt;el-icon&gt;&lt;ShoppingCart /&gt;&lt;/el-icon&gt; &lt;/template&gt; &lt;script&gt; import { ShoppingCart } from '@element-plus/icons-vue' export default { setup () { components: { ShoppingCart }, const state = reactive({ count: 0 }) return { ...toRefs(state) } } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f3154bb8ba006ac238d757ea29ad84/" rel="bookmark">
			HTML学习笔记（第三天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 HTML 表单`&lt;form&gt;` 元素`&lt;input&gt;` 元素文本输入单选按钮输入提交按钮Action 属性Method 属性何时使用 GET？何时使用 POST？Name 属性用 `&lt;fieldset&gt;` 组合表单数据HTML Form 属性 HTML 表单属性Action 属性Target 属性Autocomplete 属性Novalidate 属性 HTML 表单元素`&lt;select&gt;` 元素（下拉列表）`&lt;textarea&gt;` 元素`&lt;button&gt;` 元素HTML5 `&lt;datalist&gt;` 元素 HTML 输入类型&lt;input&gt; 元素的输入类型输入限制 HTML Input 属性value 属性readonly 属性disabled 属性size 属性maxlength 属性pattern 属性placeholder 属性required 属性 HTML 表单 &lt;form&gt; 元素 HTML 表单用于收集用户输入。
&lt;form&gt; 元素定义 HTML 表单：
实例
&lt;form&gt; . form elements . &lt;/form&gt; HTML 表单包含表单元素。
表单元素指的是不同类型的 input 元素、复选框、单选按钮、提交按钮等等。
&lt;input&gt; 元素 &lt;input&gt; 元素是最重要的表单元素。
&lt;input&gt; 元素有很多形态，根据不同的 type 属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f3154bb8ba006ac238d757ea29ad84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25974de41f138859634c93579fcc8a9b/" rel="bookmark">
			Verilog编译预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介二、宏定义`define三、文件包含`include四、时间尺度`timescale五、条件编译`ifdef参考 一、简介 编译预处理是Verilog HDL编译系统的一个组成部分。
Verilog HDL编译系统通常先对这些特殊的命令进行预处理，然后将预处理的结果和源程序一起在进行通常的编译处理。
为了和一般的语句相区别，这些预处理命令以符号 ` 开头
这些预处理命令的有效作用范围为定义命令之后到本文件结束或到其它命令定义替代该命令之处。
宏定义与parameter的区别
二、宏定义`define 一般形式
// 宏定义 `define 宏名 宏内容 // 使用宏 `宏名 宏名的有效范围为定义命令之后到原文件结束。
宏定义是用宏名代替一个字符串，也就是作简单的置换，不作语法检查，预处理时照样代入，不管含义是否正确。只有在编译已被宏展开后的源程序时才报错。
在进行宏定义时，可以引用已经定义的宏名，进行层层替换。
三、文件包含`include 文件包含处理是一个源文件可以将另一个源文件的全部内容包含进来，即将另外的文件包含到本文件之中。
Verilog语言提供了include命令用来实现文件包含的操作。
`include "文件名" 预处理时，会将file2.v中的全部内容复制插入到include “file1.v” 命令出现的地方。
在后面的编译中，会将包含以后的file1.v作为一个源文件单位进行编译。
文件包含可以将一些常用的宏定义命令或者任务task组成一个文件，然后用include命令将这些宏定义包含到源文件中。
此外一个源文件可能经常要用到另外几个源文件中的模块，可以使用include命令将所需模块源文件包含进来。
文件包含的说明：
一个include命令只能指定一个被包含的文件，如果要包含n个文件，需要用n个includeinclude命令可以出现在Verilog源程序的任何地方，被包含文件名可以是相对路径，也可以是绝对路径。如果文件1包含文件2，而文件2要用到文件3的内容，则可以在文件1中用两个include命令分别包含文件2和文件3，并且文件3应出现在文件2之前。（此时文件2中可以不用包含文件3)在一个被包含文件中又可以包含另一个文件，即文件包含是可以嵌套的。 四、时间尺度`timescale timescale命令用来说明跟在该命令后的模块的时间单位和时间精度。
使用timescale命令可以在同一个设计里包含采用不同时间单位的模块。
timescale命令格式：
`timescale 时间单位/时间精度 时间单位参数用来定义模块中仿真时间和延迟时间的基准单位，时间精度参数用来声明该模块的仿真时间的精确程度，即决定模块中的延迟时间可以带几位小数。
如果在同一个程序中，存在多个timescale命令，则用最小的时间精度值来决定仿真的时间单位。
时间精度至少要和时间单位一样精确，时间精度不能大于时间单位值。
用于说明时间单位和时间精度值的数字必须是整数，其有效数字为1、10、100，单位为: s、ms、us、ns、ps、fs。
可以使用系统任务$printtimescale来输出显示一个模块的时间单位和时间精度。
可以使用系统函数$time和realtime及%t格式声明来输出显示EDA工具记录的时间信息。
五、条件编译`ifdef 一般情况下，Verilog源程序的每一行都参与编译，但是有时希望对其中的一部分内容只有在满足条件才进行编译，就需要使用条件编译。
条件编译形式
/// `ifdef 宏名 // xxx `else // xxx `endif /// `ifdef 宏名 // xxx `endif /// `ifdef 宏名 // xxx `elsif 宏名 // xxx `else // xxx `endif 被忽略的不进行编译的部分也要符合Verilog程序的语法规则。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25974de41f138859634c93579fcc8a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fba46cbe8cea643c629cbeaa69aeb13/" rel="bookmark">
			Java线程池以及Future和CompletableFuture的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程池 是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。
为什么使用线程池?
频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。
对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。
系统无法合理管理内部的资源分布，会降低系统的稳定性。
使用线程池的好处？
重用存在的线程，减少对象创建、消亡的开销。
有效的控制最大并发数，提高系统资源使用率。
统一的分配、调优和监控、可定时执行、定期执行。
线程池所在包java.util.concurrent
顶级接口Executor,真正的线程池接口是ExecutorService
Executors类提供创建线程池的方法
线程池工作流程 Java内置的线程池 自定义线程池 拒绝任务策略
1、AbortPolicy
当任务添加到线程池中被拒绝时，它将抛出RejectedExecutionException异常。(该策路下，直接丢弃任务，并抛出RejectedExecutionException异常)
2、DiscardPolicy
当任务添加到线程池中被拒绝时，默认情况下它将丢弃被拒绝的任务。(即该策略下，直接丢弃任务，什么都不做)
3.DiscardoldestPolicy
当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。(该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列)
4、CallerRunsPolicy
不进入线程池执行，在这种方式(CallerRunsPolicy)中，任务将由调用者线程去执行。(用于被拒绝任务的处理程序，它直接在execute方法的调用线程中运行被拒绝的任务：如果执行程序已关闭，则会丢弃该任务。)
Future和CompletableFuture的用法 在Java多线程编程中，Future是一个接口，用于表示一个异步计算的结果。当启动callable线程时，就可以声明一个Future，用于接收返回结果。它提供了一系列的方法，用于管理和获取任务的执行结果。Future接口定义在java.util.concurrent包中。
使用Future可以将任务提交给线程池执行，并在需要时获取任务的执行结果。它的主要作用是允许主线程在提交异步任务后，继续执行其他操作，而不需要等待任务执行完成。
下面是Future接口的一些常用方法：
boolean cancel(boolean mayInterruptIfRunning): 取消任务的执行。如果任务正在执行，并且mayInterruptIfRunning参数设置为true，则会尝试中断任务的执行。boolean isCancelled(): 判断任务是否已被取消。boolean isDone(): 判断任务是否已经完成。V get() throws InterruptedException, ExecutionException: 获取任务的执行结果。如果任务还未执行完毕，get()方法会阻塞直到任务执行完成。如果任务执行过程中发生异常，get()方法会抛出ExecutionException，可以通过getCause()方法获取具体的异常信息。V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException: 在指定的时间内获取任务的执行结果，如果任务在指定时间内未执行完毕，会抛出TimeoutException异常。
通过Future接口，我们可以方便地提交任务并获取任务执行结果。这对于需要处理耗时操作的应用程序非常有用，可以提高系统的并发性和响应性。 栗子：四个刚需（线程）去买房摇号，future获取摇号结果。摇号结果未出，就一直阻塞。
public class FutureTest { /** * 买房摇号 */ public static class Yaohao implements Callable&lt;Integer&gt; { /** * 返回摇号结果 * @return 0：中签 1：没中 * @throws Exception */ @Override public Integer call() throws Exception { Random random = new Random(); //模拟摇号，10天内出结果 TimeUnit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fba46cbe8cea643c629cbeaa69aeb13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c07c44cdae55949ff86ecd1cc46174/" rel="bookmark">
			VMware虚拟机配置固定IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware虚拟机配置固定IP 1、共享当前网络给VMnet82、VMWare配置VMnet8网址等信息3、进入虚拟机修改网卡信息4、遇到的问题：更换wifi网络后，发现再开启虚拟机连不上网了。 1、共享当前网络给VMnet8 打开“控制面板”–》“网络和 Internet”–》“网络和共享中心”，点击“更改适配器设置”。
右击当前使用的网络，点击“属性”
选择“共享”，选择“Vmware Network Adapter VMnet8”
右击“VMware Network Adapter for VMnet8”，点击“属性”。
选择IPv4，点击“属性”
查看VMnet8网络连接的IPv4的IP地址。
VMWare点击“虚拟网络编辑器”
2、VMWare配置VMnet8网址等信息 选择“VMnet8”，点击“更改设置”，调整子网IP地址。
调整NAT设置
调整DHCP设置
确认虚拟机是否使用NAT模式
3、进入虚拟机修改网卡信息 vim /etc/sysconfig/network-scripts/ifcfg-ens33 #添加以下内容 BOOTPROTO=static #协议类型 dhcp bootp none IPADDR=192.168.137.101 #设定的固定IP地址 NETMASK=255.255.255.0 #网络子网地址 GATEWAY=192.168.137.2 #网关地址 ONBOOT=yes #启动时是否激活 yes | no DNS1=8.8.8.8 #DNS地址 #修改文件完成后，重启网络 service network restart ping www.baidu.com #验证网络是否生效 ifconfig #验证ip地址是否生效 #如果没有ifconfig命令，可以执行下面这条命令安装 yum -y install net-tools.x86_64 4、遇到的问题：更换wifi网络后，发现再开启虚拟机连不上网了。 打开“控制面板\网络和 Internet\网络连接”的“更改适配器设置”，发现VMnet1和VMnet8的网络适配器没有了。
解决方案：
点击“还原默认设置”
此时，网络适配器可看到“VMnet1”和“VMnet8”
可通过右击–》属性，查看适配器完整名称，并查看IPv4地址。
右击当前使用的网络，点击“属性”，再次共享网络给VMnet8。
选择“共享”，选择“VMnet8”对应的网络连接，这里对应“以太网5”.
按照本文中“2、VMWare配置VMnet8网址等信息”的步骤再次配置IP地址、网关等信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23c07c44cdae55949ff86ecd1cc46174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63de1ac7536e4835b613a410bf8eb27a/" rel="bookmark">
			如何在golang中解析JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Go语言（也称为Golang）中，我们可以使用令人惊奇的encoding/json包来解析JSON数据，该包提供了编码和解码JSON数据的函数。以下是如何在Go中逐步解析JSON的指南：
步骤 1 创建一个代表您想要解析的JSON结构的结构体。结构体中的每个字段应该有一个相应的JSON字段标签，以将其映射到JSON键。
type Person struct { Name string `json:"name"` Age int `json:"age"` City string `json:"city"` Email string `json:"email"` } 步骤 2 使用encoding/json包的json.Unmarshal()函数将JSON数据解析到您提供的Go结构体中。
err := json.Unmarshal(jsonData, &amp;person) Go中解析JSON的完整示例 package main import ( "encoding/json" "fmt" ) // 结构体表示JSON数据 type Person struct { Name string `json:"name"` Age int `json:"age"` City string `json:"city"` Email string `json:"email"` } // 主函数 func main() { // JSON数据作为字节切片 jsonData := []byte(`{ "name": "Jimmy", "age": 28, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63de1ac7536e4835b613a410bf8eb27a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9e6d0cc1f7422c83fe8b094af748833/" rel="bookmark">
			LeetCode-101-对称二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
给你一个二叉树的根节点 root ， 检查它是否轴对称。
题目链接：LeetCode-101-对称二叉树
解题思路：判断2个二叉树是否可以相互翻转，考察同时处理2个二叉树的遍历情况。
代码实现：
class Solution { // 后序遍历：需要收集左右孩子的信息，左右孩子的结果可以返回给根节点 public boolean isSymmetric(TreeNode root) { if (root.left == null &amp;&amp; root.right == null) { return true; } return dfs(root.left, root.right); } // 递归三部曲： // 1. 确定返回值类型：boolean // 2. 确定终止条件： // 左右都为空，true // 左右都不为空，但是值相等，true // 左右都不为空，但是值不相等，false // 左右一个空，一个不空，false // 3. 确定单层递归的逻辑 private boolean dfs(TreeNode L, TreeNode R) { if (L == null &amp;&amp; R == null) { return true; } if (L == null || R == null || L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9e6d0cc1f7422c83fe8b094af748833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd091faffd870de9f44c14402c69e2c/" rel="bookmark">
			【前端】如何将后端返回的数据遍历展示在前端页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端小白单纯记录前端处理后端返回的结果展示在前端页面，直接拷贝了一个包含假数据的页面然后对后端数据进行展示。
实现效果：
原始页面代码：
&lt;el-col class="mb40" :span="24" :sm="12" :md="12" :lg="8" :xl="8"&gt; &lt;div class="item-center"&gt; &lt;div class="gitee-traffic traffic-box"&gt; &lt;div class="traffic-img"&gt; &lt;img src="./images/add_person.png" alt="" /&gt; &lt;/div&gt; &lt;span class="item-value"&gt;2222&lt;/span&gt; &lt;span class="traffic-name sle"&gt;Gitee 访问量&lt;/span&gt; &lt;/div&gt; &lt;div class="gitHub-traffic traffic-box"&gt; &lt;div class="traffic-img"&gt; &lt;img src="./images/add_team.png" alt="" /&gt; &lt;/div&gt; &lt;span class="item-value"&gt;2222&lt;/span&gt; &lt;span class="traffic-name sle"&gt;GitHub 访问量&lt;/span&gt; &lt;/div&gt; &lt;div class="today-traffic traffic-box"&gt; &lt;div class="traffic-img"&gt; &lt;img src="./images/today.png" alt="" /&gt; &lt;/div&gt; &lt;span class="item-value"&gt;4567&lt;/span&gt; &lt;span class="traffic-name sle"&gt;今日访问量&lt;/span&gt; &lt;/div&gt; &lt;div class="yesterday-traffic traffic-box"&gt; &lt;div class="traffic-img"&gt; &lt;img src="./images/book_sum.png" alt="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dd091faffd870de9f44c14402c69e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f616758ba0046f866a052b7d9e7924/" rel="bookmark">
			Oracle PL/SQL 类型(Type)：索引表、嵌套表、变长数组、pipelined 管道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Oracle 新建员工表和部门表.sql。
集合类型 1、Oracle 集合是相同类型元素的组合，在集合中，使用唯一的下标来标识其中的每个元素，与 Java 的 List 很像。
2、常用集合方式：
类型语法下标元素个数初始值.extend能否存在DB中索引表 TYPE type_name IS TABLE OF element_type
INDEX BY index_type;
table_name type_name := type_name();
整数或字符
可以为负数无限制不用不用只能用在PLSQL中嵌套表 TYPE type_name IS TABLE OF element_type;
table_name type_name := type_name();
只能为整数无限制用同名构造函数赋值用可以使用create type 创建, 存在数据库中变长数组 TYPE type_name IS VARRAY(n) OF element_type;
varray_name type_name := type_name();
有限制 索引表：不需要初始化或者extend，且无个数限制，迄今为止最高效的集合类型，优先选择。唯一不足的一点是它只能用于PL/SQL而不能直接用于数据库。
嵌套表：如果需要使用10g，11g中的那些集合操作，则可以选择Nested table（嵌套表）;
变长数组：需要限制集合元素个数时可以使用。
3、集合常用方法：集合方法是集合对象的内置函数，可以使用"."标记来调用。
方法描述 exists(n)
索引处的元素是否存在, 返回TRUE|FALSEcount当前集合中的元素总个数 limit集合元素索引的最大值 (索引表和嵌套表是不限个数的，所以返回null，变长数组返回定义时的最大索引 )first / last返回集合第一个/最后一个元素的下标prior / next当前元素的前一个 / 后一个元素extend 增加元素,扩展集合的容量,不能用于索引表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77f616758ba0046f866a052b7d9e7924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebb85fd0e64d5480b4bb677222d629ff/" rel="bookmark">
			ES6之Array.from和Array.of
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Array.from 用于将两类对象转为真正的数组：
1、类似数组的对象（array-like object）
2、可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）
let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; // ES5 的写法 var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c'] // ES6 的写法 let arr2 = Array.from(arrayLike); 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from()都可以将它们转为真正的数组。
// NodeList 对象 let ps = document.querySelectorAll('p'); Array.from(ps).filter(p =&gt; { return p.textContent.length &gt; 100; }); // arguments 对象 function foo() { var args = Array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebb85fd0e64d5480b4bb677222d629ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553ef33e438b3a9b08f1066c68e5101e/" rel="bookmark">
			idea maven-compiler-plugin报红
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方案：
在&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;下面加上版本&lt;version&gt;3.8.0&lt;/version&gt;
&lt;build&gt; &lt;finalName&gt;test-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt;	&lt;!-- 加上版本号 --&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.test.ApplicationMain&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 重新reload更新下maven，正常情况下，会自动下载依赖，然后这里的爆红就消失了。
如果还是报错，将爆红的插件放入dependencies标签中，然后再通过 reload 就可以解决这个报红问题。
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 今天上午正常运行的代码，什么都没动下午突然爆红。在添加版本信息后刷新恢复正常，但是当我再次去掉版本这一属性后还是能正常的没有爆红。猜测可能下载jar包的时候失败了，把版本删除后，按住ctrl点击名称进去，发现跳转的是刚才填的版本号，很神奇。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b66dedc1e0f4021d5c196498dd05942/" rel="bookmark">
			用python生成二维码，想生成啥内容都可以啦（亲测好用的代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二维码又称二维条码，常见的二维码为QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，而生成一个二维码也非常简单，在Python中我们可以通过MyQR模块了生成二维码，而生成一个二维码我们只需要2行代码，我们先安装MyQR模块，这里选用国内的源下载：
pip install qrcode 安装完成后我们就可以开始写代码了：
import qrcode import os i = 1 while True: text = input('输入文字或URL：') # 设置URL必须添加http:// img =qrcode.make(text) img.save('二维码-{1}.png'.format(text)) #保存图片至本地目录，可以设定路径 img.show() path = os.getcwd() + '\\' print('二维码已保存在此目录下：',path) i +=1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e47548354a1029b716e55f8c80f4530/" rel="bookmark">
			Sublime Text3配置：在可交互环境下运行python快捷键（亲测可用！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在已经安装了包管理器的前提下（如果没有安装可以看这里的”安装包管理器”部分），按ctrl+shift+p快捷键呼出一个输入框，输入Install Package，回车，在新出现的输入框里输入SublimeREPL，在下面的选择列表中选中回车就会开始安装，一般几秒钟就能装完。
在刚刚的python文件的界面里点击上方菜单栏的tools-&gt;sublimeREPL-&gt;python-&gt;python run current file，这时候就像IDLE一样，会弹出一个新的窗口，而且是可交互的，可以输入
吐槽一下：这里面的编程语言，为什么没按照音序排列，害得我找python半天。
设置快捷键
但是每次都要去选择tools-&gt;sublimeREPL-&gt;python-&gt;python run current file这么一长串肯定是很让人头疼的，就想着能不能设置快捷键来运行。因为以前使用IDLE写python，所以就打算配成F5运行。
我们知道，Sublime Text是通过json文件进行设置的。我们打开preferences-&gt;Key Binding-Default就能看到原来的快捷键的设置，是json格式的。
打开preferences-&gt;Key Binding-User，按照上面的格式重写需要设置的快捷键的的相关属性，就能覆盖默认设置。
但是设置的格式不容易看懂，可以参考非官方文档
发现可以把”command”设为”run_macro_file” ，”args”设为录制的宏的文件名，就可以快捷地调用这个宏。但是这个尝试失败了，可能是因为
Note that the macro buffer will remember only the latest recorded macro. Also, macros only record commands sent to the buffer: window-level commands, such creating a new file, will be ignored.
宏不能创建新窗口之类的。
后来折腾了好久，在网上找到相关的内容，研究出了解决方案
打开C:\Users\xxx(your name)\AppData\Roaming\Sublime Text 3\Packages\SublimeREPL\config\Python，根据自己的情况调整具体路径。AppData可能是隐藏文件夹，要先设置隐藏文件夹可见才找得到。打开Main.sublime-menu，看到里面也是json格式的。观察一下就发现这对应的刚好就是tools-&gt;sublimeREPL-&gt;python-&gt;下的几个选项。caption对应的就是显示的名字。
打开刚刚提到的preferences-&gt;Key Binding-User，写入以下内容：
[ { “keys”: [“f5”], “caption”: “SublimeREPL:Python”, “command”: “run_existing_window_command”, “args”: { “id”: “repl_python_run”, “file”: “config/Python/Main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e47548354a1029b716e55f8c80f4530/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177e33570885ebe868474a9cdbe8a5d5/" rel="bookmark">
			Clickhouse: A股分时线bar数据python实验-批量导入[上]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批量导入有两种方式，一种是本地的csv文件集合，一个个读进来，这个比较象生产环境下；另一种是模拟环境的，只需要用随机数生成相应的模拟数据。
from operator import truediv import sys #from xmlrpc.client import Boolean dir_path = "/home/click/pyclick/minute" sys.path.append("/home/click/pyclick") sys.path.append("/usr/local/lib/python3.8/site-packages") from clickhouse_driver import Client import pandas as pd import os import datetime import time import math import random def get_all_files_by_root_sub_dirs(directory, file_type): data = list() if os.path.isdir(directory): # 是目录 dir_list = os.walk(directory) # os.listdir(directory) for (root, sub, files) in dir_list: for file in files: path = os.path.join(root, file) # root +'\\'+file if path.endswith(file_type): data.append(path) else: # 不是目录，直接输出 if directory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177e33570885ebe868474a9cdbe8a5d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d78271d5a06333537f54ed7ef964db7/" rel="bookmark">
			oracle数据库新增和查询索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle数据库新增和查询索引 1、通过sql语句查询某张表的索引
SELECT * FROM ALL_INDEXES WHERE TABLE_NAME='XXXXXXXX'; 在上面的命令中，单引号括起来的部分是需要填入表的名称。
2、通过sql语句创建索引
CREATE INDEX index_name ON table_name (column_name); 在上面的命令中，index_name是要创建的索引的名称，table_name是要创建索引的表的名称，column_name是要创建索引的列的名称。
3、通过SQL语句修改索引名称
ALTER INDEX INDEX_NAME_OLD RENAME TO INDEX_NAME_NEW; 在上面的命令中，INDEX_NAME_OLD 是要修改的索引的老名称，INDEX_NAME_NEW是索引修改之后新的名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a8adbfa5ba1ad8a6174775ddde540bf/" rel="bookmark">
			Vue-cli全局配置整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue-cli配置简单明了，内部还自带了webpack，默认已经有development test production三种模块，支持自定义环境变量来区分打包产物，所以将vue-cli常用配置整理出来，以备不时只需. //baseUrl:'./',//cli3.3开始已启用 请使用publicPath //发布路径 会覆盖vue-cli中的 BASE_URL publicPath: process.env.VUE_APP_MODE === 'prod' ? '/prod-h5/' : process.env.VUE_APP_MODE === 'other'?'/other-h5/':'./', outputDir:'dist',//默认打包路径 assetsDir:'static',//生成的静态资源目录, indexPath:'index.html',//生成Index.html的路径 filenameHashing:true,//默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存, // 只有vue-cli生成index.html才生效，使用其他非自动生成的将此值设置false //在 multi-page 模式下构建应用。每个“page”应该有一个对应的 JavaScript 入口文件。其值应该是一个对象，对象的 key 是入口的名字，value 是： //一个指定了 entry, template, filename, title 和 chunks 的对象 (除了 entry 之外都是可选的)； //或一个指定其 entry 的字符串 pages:{// index: { // page 的入口 entry: 'src/index/main.js', // 模板来源 template: 'public/index.html', // 在 dist/index.html 的输出 filename: 'index.html', // 当使用 title 选项时， // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a8adbfa5ba1ad8a6174775ddde540bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bac2892de9f87a2ad5b796642d58728/" rel="bookmark">
			Spring事务传播机制、实现方式、失效场景及原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贴一篇源码分析的好文章：https://blog.csdn.net/qq_30905661/article/details/114400417
本质： 一个事务对应一个数据库连接。
通过 this 来调用某个带有 @Transactional 注解的方法时，这个注解是失效的
Spring的事务是如何实现的？ spring事务底层是通过数据库事务和AOP实现的首先对于使用@Transactional的注解的bean，spring会创建一个代理对象作为bean当调用代理对象的方法时，spring会判断该方法上是否加了@Transactional注解如果加了，就会利用事务管理器创建一个数据库连接，并修改数据库连接的 autocommit 为 false，禁止自动提交然后执行该方法，若方法没有抛异常则会提交事务，反之亦然spring事物的隔离级别就是对应数据库的隔离级别spring事务的传播机制是spring自己实现的，是spring事务中最复杂的spring事物的传播机制是基于数据库连接来做的，一个连接一个事务，传播事务实际上是开了一个新的数据库连接，在此基础上执行sql Spring事物的传播机制？ spring事务默认是注解是 REQUIRED，支持事务的传播，使用同一个数据库连接。
REQUIRED：spring默认的事务传播机制，A存在事务，则B加入A的事务；A没有事务则会新建一个数据库事务；
SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务；如果当前不存在事务，就以非事务执行
MANDATORY：（强制性使用第一个事务）A存在事务，则B加入A的事务；A没有事务，则抛异常
REQUIRES_NEW：创建一个新事务，B在这个新事务中执行；A如果有事务将会被挂起，等待B事务方法执行结束（commit or rollback），当B事务执行结束后，A事务被唤醒继续执行，若B抛出了异常给A 或 A 方法执行出了异常，那么在 A 事务中执行的 sql 将会被回滚，B 事务中的sql 由B的事务管理器控制，A、B中的sql不在同一数据库连接中执行，即内层事务B已经 commit 或 rollback， 外层事务干扰不了。
NOT_SUPPORTED：（不支持事务），若A存在事务，则挂起A的事务，以非事务方式运行
NEVER：（不支持事务），若A存在事务抛异常
NESTED：A存在事务，则在嵌套事务中执行；不存在则和 REQUIRED 一样开启一个新事务
那些情况会导致Spring事务的失效？失效的原因是？ 数据库不支持事务
类没有被spring管理（ioc），没有加注解。
未启用Spring事务管理功能（@EnableTransactionManagement）
数据源没有配置事务管理器
@Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ return new DataSourceTransactionManager(dataSource); } 没有加@Configuration注解：springboot基本没有这个问题；Spring可能会出现这个问题，原因是由于mybatis或JdbcTemplate会从ThreadLocal中获取数据库连接，但是ThreadLocal底层引用的是ThreadLocalMap，Map的key是一个DataSource对象，value是数据库连接。如果没有加@Configuration注解的话，会导致Map中的DataSource对象和mybatis、jdbcTenplate中的DataSource对象不相等，所有就拿不到数据库连接，以至于自己去创建连接了。
异常被吃掉：默认情况下Spring会捕获 error 和 RunTimeException ，spring捕获不到异常也就不会回滚了，例如 try-catch
方法是private的：spring事务基于CGLIB来进行AOP，CGLIB是基于父子类来实现，子类是代理类，子类无法重写父类的private方法，也就没有办法增加spring事务逻辑。
方法是 final 修饰的，和private原因一致，子类不能重写增强。
调用A方法和B方法不是同一个线程，不同的线程拿到的数据库连接不一样。TransactionSynchronizationManager.bindResource 会将线程与数据库连接绑定。
rollbackFor = RuntimeException.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bac2892de9f87a2ad5b796642d58728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9c3971133f740a0259e10d5f27a00f/" rel="bookmark">
			基于ssm框架的高校选课系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家点赞、收藏、关注、评论啦 ，由于篇幅有限，只展示了部分核心代码。
文章目录 前言一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 前言 本论文旨在探讨高校选课系统的设计与实现。随着高校教育的普及和学生数量的增加，如何有效地管理选课系统成为了一个重要的问题。本论文首先会对目前高校选课系统的现状进行调研，分析其中存在的问题和不足。接着，本论文将设计一个基于Web的高校选课系统，并通过详细的需求分析和系统架构设计来解决现有系统中存在的问题。系统的开发将采用目前流行的Web技术和数据库技术，并考虑系统的灵活性、安全性和易用性。最后，本论文将对开发出的系统进行测试和评估，分析系统的性能和用户体验，并提出可行的优化方案。通过本论文的研究，可以为高校选课系统的改进和优化提供一定的参考和借鉴。
论文采用 Java作为软件的技术，在系统的设计方面，运用了B/S的架构，在后台上，利用Mysql数据库，它是一个十分出色的高校选课系统。
关键词：选课管理；Java；Mysql；B/S
一、项目介绍 随着互联网技术的不断发展，高校选课系统的建设和应用已成为当前高校教育改革的重要方向。选课系统作为高校教务管理的重要组成部分，对于提高教学质量、提高学生的学习效率、优化教学资源配置具有重要的意义。
然而，当前高校选课系统的建设和应用还存在一些问题，例如课程资源匮乏、选课信息不透明、选课难度大等。因此，对于高校选课系统的探讨和研究具有重要的现实意义和实践价值。
本文旨在探讨高校选课系统的建设和应用现状以及存在的问题，并提出一些解决方案和建议，以期为高校选课系统的改进和优化提供一定的参考和借鉴。
二、开发环境 开发语言：Java
框架：ssm
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 根据现实需要，此系统我们设计出一下功能，主要有以下功能模板。
学生功能：首页、个人中心、课程信息管理、选课信息管理、公告信息管理。
教师功能：首页、个人中心、课程信息管理、选课信息管理、公告信息管理。
管理员功能：首页、个人中心、学生管理、教师管理、课程类型管理、课程信息管理、选课信息管理、公告信息管理。
在系统的功能设计方面，高校选课系统的设计目标是便于学生选课，因此抽取了满足管理员、学生基本业务需求的基本用例，如图3-1、3-2所示。
图3-1 管理员用例图
图3-2 学生用例图
本系统设计时，确定详细功能，这些功能主要通过需求阶段的调研分析得来的，具体功能模块如下图，如图4-1所示。
图4-1 系统结构图
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.example.utils.MapWrapperUtils; import com.example.utils.jwt.JwtUtil; import com.example.vo.CaiwuVo; import org.springframework.beans.BeanUtils; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a9c3971133f740a0259e10d5f27a00f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/39/">«</a>
	<span class="pagination__item pagination__item--current">40/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/41/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>