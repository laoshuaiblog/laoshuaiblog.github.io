<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39020517a317fd2ac3884c28099a086c/" rel="bookmark">
			gstreamer_搭建rtsp服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ubuntu下搭建rtsp server 注意： 可以直接使用最下面的脚本，一键搭建。
1. 下载源码并编译 # download src git clone git://anongit.freedesktop.org/gstreamer/gst-rtsp-server cd gst-rtsp-server # see all branches # remotes/origin/1.8 8799fb5 tests: try to avoid using the same ports in different tests git branch -av # create new branch git checkout -B test git reset --hard 8799fb5 # compile ./autogen.sh &amp;&amp; make -j12 2. 测试 ./examples/test-launch "( videotestsrc ! x264enc ! rtph264pay name=pay0 pt=96 )" 3. 做成简单脚本，方便搭建。 # # by aizizai 20220207 # #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39020517a317fd2ac3884c28099a086c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/609b6ad94c27f95dd8a83e07741f15d4/" rel="bookmark">
			LINUX暂停、挂起进程，开启进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LINUX暂停、挂起进程，开启进程 先使用如下命令查看你需要暂停的进程：
ps -a 确定想要关闭的进程后，使用如下命令暂停、挂起进程：
kill -stop 进程号 如果你想开启上面挂起的进行，并放在后台运行：
kill -cont 进程号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e271ae8a5d891bff6ce1687fb9f602d1/" rel="bookmark">
			SinoDB在物联网领域的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		星瑞格SinoDB国产数据库通过时序处理引擎，快速处理按时间轴生成的时序数据，提供计算速度快，处理数据量大，满足及时性要求等优势。
SinoDB架构图
1、需求背景
为了确保仓库物料储存的要求，有效防范储存过程中可能发生的安全风险，确保质量安全，创造适宜于物料储存的环境，当库内温湿度适宜商品储存时，就要设法防止库外气候对库内的不利影响；当监控到库内温湿度不适宜物料储存时，需及时采取有效措施调节库内的温湿度。
因此，建立实时的温湿度监控系统，保存完整的历史温度数据有利于对仓库物料储存进行管理。
2、系统建设目标
实时采集仓库温湿度数据，监控仓库温湿度数据；
预警及预警处理：当数值超过设定阀值进行实时报警并钉钉通知；
数据分析：将读取的温湿度数据实时保存在数据库中，通过历史数据制定客制化报表进行数据分析。
3、解决方案
该方案具备联接物联网设备（传感器、看板、报警装置、空调、加湿机、门禁、摄像头、电力等）、三维室内定位，数据存储于工业时序数据库(SinoDB)，同时开放接口给第三方系统，开发工业APP应用。可根据采集监测数据，联动其他系统和组件，从而为工厂提供综合自动化、数字化及可视化的生产安全管理方案。
4、实施效果
SinoDB数据库具有时间序列处理引擎、空间地理数据处理能力，良好支持物联网应用。
温度、湿度的配置，如下图：
数据采集后的报表，如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a131570fd7b990e09bb5332339c29d45/" rel="bookmark">
			CAS流程简析 客户端处理未携带Ticket访问请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关阅读 CAS基础组件 简介CAS流程简析 服务端处理未携带Service登录请求CAS流程简析 客户端处理携带Ticket访问请求CAS基础组件 客户端过滤器 简介 用户访问客户端的请求，会先经过客户端配置的过滤器链，常用的过滤器如下：
CAS Single Sign Out Filter——SingleSignOutFilter 实现单点登出，放在首个位置； CAS Validation Filter——Cas30ProxyReceivingTicketValidationFilter 负责对Ticket的校验需要指定服务端地址：casServerUrlPrefix需要指定客户端地址：serverName CAS Authentication Filter——AuthenticationFilter 负责用户的鉴权需要指定服务端登录地址：casServerLoginUrl需要指定客户端地址：serverName CAS HttpServletRequest Wrapper Filter——HttpServletRequestWrapperFilter 负责包装HttpServletRequest，从而可通过HttpServletRequest的getRemoteUser()方法获取登录用户的登录名
用户的访问请求会依次经过以上配置的过滤器的拦截和处理； SingleSignOutFilter 首先经过SingleSignOutFilter处理，该过滤器实现单点登出功能；
本次是用户访问请求，不是登出请求，该过滤器会直接放行，核心代码如下：
private static final SingleSignOutHandler HANDLER = new SingleSignOutHandler(); public void init(final FilterConfig filterConfig) throws ServletException { super.init(filterConfig); if (!isIgnoreInitConfiguration()) { // 设置属性 setArtifactParameterName(getString(ConfigurationKeys.ARTIFACT_PARAMETER_NAME)); setLogoutParameterName(getString(ConfigurationKeys.LOGOUT_PARAMETER_NAME)); setFrontLogoutParameterName(getString(ConfigurationKeys.FRONT_LOGOUT_PARAMETER_NAME)); setRelayStateParameterName(getString(ConfigurationKeys.RELAY_STATE_PARAMETER_NAME)); setCasServerUrlPrefix(getString(ConfigurationKeys.CAS_SERVER_URL_PREFIX)); HANDLER.setArtifactParameterOverPost(getBoolean(ConfigurationKeys.ARTIFACT_PARAMETER_OVER_POST)); HANDLER.setEagerlyCreateSessions(getBoolean(ConfigurationKeys.EAGERLY_CREATE_SESSIONS)); } // handler初始化 HANDLER.init(); // 设置handler初始化完成标识 handlerInitialized.set(true); } public void doFilter(final ServletRequest servletRequest, final ServletResponse servletResponse, final FilterChain filterChain) throws IOException, ServletException { final HttpServletRequest request = (HttpServletRequest) servletRequest; final HttpServletResponse response = (HttpServletResponse) servletResponse; /** * &lt;p&gt;Workaround for now for the fact that Spring Security will fail since it doesn't call {@link #init(javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a131570fd7b990e09bb5332339c29d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252b678fac133f6b27bd47938b64d2e7/" rel="bookmark">
			Nginx命令stop或者quit停止服务器无效失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照Nginx官方文档，正常关闭Nginx服务器的命令是：
nginx -s stop nginx -s quit 但在Windows环境下，上述两条命令无法正常关闭Nginx服务器，解决方案：
taskkill /f /t /im nginx.exe 通过杀掉Nginx进程的方法结束、关闭Nginx服务器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7173477dfe53e38c589f3c87ec937ce/" rel="bookmark">
			CAS流程简析 服务端校验Ticket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关阅读 CAS基础组件 简介CAS流程简析 服务端处理未携带Service登录请求CAS流程简析 服务端处理携带Service登录请求CAS基础组件 客户端过滤器 简介 用户访问客户端的请求若携带Ticket信息，经过客户端配置的过滤器Cas30ProxyReceivingTicketValidationFilter时，该过滤器会将请求中携带的Ticket信息发送到服务端进行校验，若校验通过，才返回鉴权结果；
简析 Cas30ProxyReceivingTicketValidationFilter发送到服务端的请求路径为：/p3/serviceValidate，对应服务端的处理器为V3ServiceValidateController，核心代码如下：
@Component("v3ServiceValidateController") @Controller public class V3ServiceValidateController extends AbstractServiceValidateController { /** * Handle model and view. * * @param request the request * @param response the response * @return the model and view * @throws Exception the exception */ @RequestMapping(path="/p3/serviceValidate", method = RequestMethod.GET) protected ModelAndView handle(final HttpServletRequest request, final HttpServletResponse response) throws Exception { return super.handleRequestInternal(request, response); } @Override @Autowired public void setValidationSpecificationClass(@Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7173477dfe53e38c589f3c87ec937ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091cd750de4546bb225f9bef56228aa7/" rel="bookmark">
			前端 - 用div仿输入框，解决鼠标点击位置错乱的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于项目需要在输入框的中插入各种自定义标签，特别的，需要将自定义标签插入指定的位置，可能是已有的字符串中间，而现有的组件无法记录失去焦点前的鼠标位置，所以采用div仿造一个div来实现需求，该方案可于移动端和pc端
直接上代码
import React, { useEffect, useState, useRef } from "react"; import styles from "./index.scss"; function DiscussInput({ tagName, value, wrapStyle = {} }, ref) { const [caretOffset, setCaretOffset] = useState(0); const [focusNode, setFocusNode] = useState(null); const inputElement = useRef(null); // in order to form.resetFields() useEffect(() =&gt; { if (!value) { inputElement.current.innerHTML = ""; } }, [value]); useEffect(() =&gt; { if (tagName) { inputElement.current.focus(); setCaretPosition(); insertContent(tagName); } }, [tagName]); function setCaretPosition() { if (document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/091cd750de4546bb225f9bef56228aa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59653229c5d83133ab5b7c69b8011600/" rel="bookmark">
			PHP-运算符（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是运算符？？？
赋值运算符
算术运算符
比较运算符
什么是运算符？？？ 运算符：operator，是一种数据进行运算的符号，PHP中有十种运算符之多.
赋值运算符 赋值运算符 : 符号“ = ”，表示将右边的结果保存到内存的某个位置，然后将位置的内存地址赋值给左边的变量或常量；（结果可以是变量、常量、数据、运算出来的结果）
//数值运算 $a=2; $b=3; $c=$a+$b; echo $c; //常量 define('a',5); const b=a; echo '&lt;br/&gt;',b; //变量 $b='adada'; $a=$b; echo $a,$b; 算术运算符 运算符号：
+ ：执行数据累加；
- ：数据相减；
* ：键盘上没有乘法符号，使用 * 代替，两个数值相乘；
/ ：正斜杠代替除号，表示两个数相除；
% ：取余运算，两个数（整数）相除，保留余数；
注：在进行除法运算或者取余运算的时候，对应的被除数（第二个数）不能为0 ， 否则就会报错；
//算术运算 //数值相加 $a=$b=1; echo $a+$b; //数值相减 $c=5; $d=5; echo $c-$d; //数值相乘 $e=2; $f=2; echo $e*$f; //数值相除 $aa=10; $bb=2; echo $aa/$bb; //数值取余 $cc=10; $dd=3; echo $cc%$dd; 比较运算符 &gt;:左边大于右边，返回True；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59653229c5d83133ab5b7c69b8011600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb9e5513a9656f30c6bc47ac3295936/" rel="bookmark">
			如何批量打印dwf文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有大量的dwf、dwfx文件需要打印，如何快速批量打印dwf文件？
最简单的方法莫过于选中dwf文件，单击鼠标右键，打印即可。
上述方法虽然简单，但很多时不能满足要求：
文件的打印顺序有可能是混乱的，并不是所见的那样；当要计算页数时需要打开每个文件才能查看页数，总页数需要手动统计；无法指定只打印某些页等等。 所有这些需求可以通过使用一款绿色软件【Office批量打印精灵】来满足！
Office批量打印精灵（以下简称“打印精灵”）是一款Word、Excel、Powerpoint、PDF、图片、DWF等文档的批量打印软件。
可到【依云软件官网】（yiyunsoftware.com）下载。
打印精灵无需安装，下载后打开即可使用，注意打印 dwf、dwfx 文件需安装“Autodesk DWF Viewer”或“Design Review”。
拖放要打印的文件到打印精灵列表，单击“开始打印”即可打印并统计页数。
注意打印精灵同时支持多种类型的文件批量打印，若只想打印某个文件夹下一种类型的文件，可单击“过滤选项”，只勾选指定类型的文件即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8205e88b9bf7add00dda15c747cd503c/" rel="bookmark">
			如何批量打印PDF文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有大量的PDF文件需要打印，如何快速批量打印PDF文件？
最简单的方法莫过于选中PDF文件，单击鼠标右键，打印即可。
上述方法虽然简单，但很多时不能满足要求：
文件的打印顺序有可能是混乱的，并不是所见的那样；当要计算页数时需要打开每个文件才能查看页数，总页数需要手动统计；无法指定只打印某些页等等。 所有这些需求可以通过使用一款绿色软件【Office批量打印精灵】来满足！
Office批量打印精灵（以下简称“打印精灵”）是一款Word、Excel、Powerpoint、PDF、图片、DWF等文档的批量打印软件。
可到【依云软件官网】（yiyunsoftware.com）下载。
打印精灵无需安装，下载后打开即可使用，注意使用打印精灵共享版打印PDF文件时需要安装“Adobe Reader”。
拖放要打印的文件到打印精灵列表，单击“开始打印”即可打印并统计页数。
注意打印精灵同时支持多种类型的文件批量打印，若只想打印某个文件夹下一种类型的文件，可单击“过滤选项”，只勾选指定类型的文件即可。
除支持双面打印、打印份数等设置外还支持：
支持批量打印带密码的PDF文件；支持打印部分页、奇偶页；支持选择纸张大小、纸张来源。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b270919f4397e95a80612719a48267/" rel="bookmark">
			“好奇号“登陆火星与无穷小放飞互联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ ​10年前，2012年8月，袁萌发表文章：《"好奇号"火星车登陆火星进行探测》引起国内广大读者的密切关注。
​ ​随至，2012年11月28日，袁萌主持无穷小放飞互联网行动，使得无穷小微积分进入我国网络空间，促使我国数学教育的现代化，开启我国数学现代化改革的新篇章。
袁萌
2022年01月22日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9fb28d66d557f2a4a0adabd86ee7c13/" rel="bookmark">
			如何批量打印Word文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有大量的Word文件需要打印，如何快速批量打印Word文件？
最简单的方法莫过于选中Word文件，单击鼠标右键，打印即可。
上述方法虽然简单，但很多时不能满足要求：
文件的打印顺序有可能是混乱的，并不是所见的那样；当要计算页数时需要打开每个文件才能查看页数，总页数需要手动统计；无法指定只打印某些页等等。 所有这些需求可以通过使用一款绿色软件【Office批量打印精灵】来满足！
Office批量打印精灵（以下简称“打印精灵”）是一款Word、Excel、Powerpoint、PDF、图片、DWF等文档的批量打印软件。
可到【依云软件官网】（yiyunsoftware.com）下载。
打印精灵无需安装，下载后打开即可使用，注意打印 Word 文件需安装“Microsoft Office”或“WPS 专业版”。
拖放要打印的文件到打印精灵列表，单击“开始打印”即可打印并统计页数。
注意打印精灵同时支持多种类型的文件批量打印，若只想打印某个文件夹下一种类型的文件，可单击“过滤选项”，只勾选指定类型的文件即可。
除支持双面打印、打印份数等设置外还支持：
支持打印部分页、奇偶页；支持选择纸张大小、纸张方向、页边距；支持在每版上打印多页。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a987dd35edf00a90243b50e43423afd/" rel="bookmark">
			（超详细）Scala环境搭建（scala-2.12.15、IDEA2021.1.3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scala环境搭建（scala-2.12.15、IDEA2021.1.3） JunLeon——go big or go home
目录
Scala环境搭建（scala-2.12.15、IDEA2021.1.3）
一、Scala概述
1、什么是Scala？
2、Scala发展史
3、Scala与Java的关系
二、Scala环境搭建
1、环境准备
2、Scala安装与配置环境变量
3、验证Scala
三、编写第一个Scala程序
1、使用IDEA创建maven工程
2、安装Scala插件
3、创建scala文件
4、运行结果
前言：
学习Scala最好先掌握Java基础及高级部分知识，文章正文中会提到Scala与Java的联系，简单来讲Scala好比是Java的加强版，因为Scala是一门以Java虚拟机（JVM）为运行环境并将面向对象和函数式编程的最佳特性结合在一起的静态类型编程语言（静态语言需要提前编译的如：Java、c、c++等，动态语言如：js）。
一、Scala概述 1、什么是Scala？ Scala是一门以Java虚拟机（JVM）为运行环境并将面向对象和函数式编程的最佳特性结合在一起的 静态类型编程语言（静态语言需要提前编译的如：Java、c、c++等，动态语言如：js）。
Scala是一门多范式的编程语言，Scala支持面向对象和函数式编程。（多范式，就是多种编程方 法的意思。有面向过程、面向对象、泛型、函数式四种程序设计方法。）
Scala源代码（.scala）会被编译成Java字节码（.class），然后运行于JVM之上，并可以调用现有 的Java类库，实现两种语言的无缝对接。
Scala单作为一门语言来看，非常的简洁高效。
Scala在设计时，马丁·奥德斯基是参考了Java的设计思想，可以说Scala是源于Java，同时马丁·奥 德斯基也加入了自己的思想，将函数式编程语言的特点融合到JAVA中, 因此，对于学习过Java的同学， 只要在学习Scala的过程中，搞清楚Scala和Java相同点和不同点，就可以快速的掌握Scala这门语言。
2、Scala发展史 2001年 洛桑联邦理工学院的马丁·奥德斯基（Martin Odersky）开始基于Funnel的工作设计Scala。
Funnel 是把函数式编程思想和佩特里网相结合的一种编程语言。奥德斯基之前工作于Generic Java 和 javac。
马丁·奥德斯基是编译器及编程的狂热爱好者，长时间的编程之后，希望发明一种语言，能够让写程序这样的基础工作变得高效，简单。所以当接触到JAVA语言后，对JAVA这门便携式，运行在网络，且存在垃圾回收的语言产生了极大的兴趣，所以决定将函数式编程语言的特点融合到JAVA中，由此发明了两种语言（Pizza &amp; Scala）。
2003年底/ 2004 年初 Java 平台的Scala发布。
2004年6月 .NET平台的Scala发布。
2006年3月 Scala v2.0发布。
2009 年4 月 Twitter 宣布他们已经把大部分后端程序从Ruby 迁移到Scala，其余部分也打算要迁移。此外，Wattzon 已经公开宣称，其整个平台都已经是基于Scala 基础设施编写的。
2014 年 马丁·奥德斯基宣布Scala 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a987dd35edf00a90243b50e43423afd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f5ab957f94bb4011572a5b2875af7e/" rel="bookmark">
			PHP-数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
什么是数据类型？
PHP的八种数据类型
类型转换
数据类型的判断
什么是数据类型？ 数据类型：data type ，在PHP中指的是存储的数据本身的类型，而不是变量的类型，php是一种弱类型语言，变量本身没有数据类型
PHP的八种数据类型 在PHP中将数据类型分为三大类八小类；
基本数据类型：
整形：int/intger，系统分配4个字节存储，表示整数类型；
浮点型：float/double，系统分配4个字节存储，表示整数类型（有前提）
字符串型：string，系统根据实长度分配，表示字符串，表示字符串的符号是单引号或双引号；
布尔类型：bool/boolean，表示布尔类型的只有两个值：True和False；
复合类型类型
对象类型：object，可以存放对象（面对对象）；
数组类型：array，可以一次性存储多个数据；
特殊数据类型：
资源类型：resource，存放资源数据（通常存放都是php外部数据，如：数据库、文件 等...）；
空类型：NULL , 只有一个值就是NULL（不能运算）；
类型转换 类型转换：在很多的条件下，需要指定的数据类型，需要外部数据（当前php取得的数据），转换成目标的数据类型；
在PHP中有两种类型转换方式：
自动转换 ：系统根据需求自己判断，自己转换（用的较多，缺点：效率低）；强制(手动)转换：认为根据需要的目标类型转换； 强制转换的规则：在变量之前添加一个（），在里面写上对应的类型（NULL不能直接转换，需要使用函数unset{}）；
&lt;?php $a='1.12.111abc'; $b='abcd12.41.15'; //强制转换 echo '&lt;br&gt;',(int)$a,'&lt;br/&gt;',(int)$b; //强制转换空类型的使用方式 unset($a); echo $a; 在转换过程中常用的类型有：布尔类型（用于判断）、转数值类型（算术运算）；
其它类型转换成布尔类型只有两种结果：True或False，在PHP中很少类型会转化成False；
其它类型转数值说明：
布尔值 True=1，False=0；字符串转数值有自己的规则；以字母开头的字符串，永远为0；以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点）； 数据类型的判断 数据类型判断是使用一组类型判断函数，来判断变量的数据类型
is_+类型名字+{变量名}；（相同的数据类型结果返回True，否则返回False）
$a='112.1.1'; $b=21; var_dump(is_int($a)); var_dump(is_int($b)); 布尔类型不能使用echo来查看，需要使用var_drum();
$a=TRUE; $b=FALSE; var_dump($a,$b); PHP中还有一组函数可以获取以及设定数据（变量）的类型；
Gerrype（变量名）：获取类型，得到的是该类型对应的字符串Settype(变量名，类型)：设定数据类型 //判断类型 $a='112.1.1'; $b=21; echo gettype($a); echo gettype($b); //设置类型 var_dump(settype($a,'int')); //转换成功会返回True 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0070b7484b66b63d45eb968625f2f3b/" rel="bookmark">
			PHP-系统常量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
什么是系统常量？
常用的系统常量
什么是系统常量？ 系统常量就是系统帮助用户定义的常量，用户可以直接使用；
常用的系统常量 PHP_VERSION : PHP版本号；PHP_INT_MAX : 整形能表示的最大值；PHP_INT_SIZE : 整形的字节数大小； 在PHP中还有一些特殊常量，它们由双下划线开头+常量名+双下划线结束，这种常量称之为系统魔术常量，系统魔术常量的值通常会根据系统的环境变化而改变，但是用户改变不了
__DIR__ : 当前执行脚本的绝对路径；（不带当前脚本的文件名）__FILE__ : 当前执行脚本的绝对路径；（带当前脚本的文件名）__LINE__:当前所属的行数；__NAMESPACE__ : 当前所属的命名空间;__CLASS__ : 当前所属的类；__METHOD__ : 当前所属的方法； echo PHP_VERSION; //输出当前PHP的版本号 echo '&lt;br/&gt;'; echo PHP_INT_MAX; //输出正整形的最大值 echo '&lt;br/&gt;'; echo PHP_INT_MIN; //输出负整形的最大值 echo '&lt;br/&gt;'; echo PHP_INT_SIZE; //输出整形的字节数大小 echo '&lt;br/&gt;'; echo __DIR__; //输出当前文件所在服务器的绝对路径（不带当前文件名） echo '&lt;br/&gt;'; echo __FILE__; //输出当前文件所在服务器的绝对路径（带当前文件名） echo '&lt;br/&gt;'; echo __LINE__; //输出当前所在的行数； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124ff6f75a9d7a45b3c90c96122e69d5/" rel="bookmark">
			JVM知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面
本文是最近学习JVM的知识点总结，主要包含以下内容：
JVM 内存结构对象的内存布局、访问方式类文件结构和加载过程垃圾收集策略与算法 JVM概述
JVM 是 Java Virtual Machine 的缩写，即Java虚拟机，是一种抽象计算机，它有一个指令集，在运行时操作各种内存区域。虚拟机有很多种，不同厂商提供了不同实现，只要遵循虚拟机规范即可，目前我们所说的虚拟机一般指的是Hot Spot。JVM对Java语言一无所知，只知道一种特定的二进制格式，即类文件格式，我们写好的程序最终交给JVM执行的时候会被编译成二进制格式，JVM只认识二进制格式，所以任何语言只要编译后的格式符合要求，都可以在JVM上运行。
JVM 内存结构 Java 虚拟机的内存空间分为 5 个部分：
程序计数器Java 虚拟机栈本地方法栈堆方法区 程序计数器 程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制；在多线程情况下，程序计数器记录的是当前线程执行的位置，当线程切换回来时，就知道上次线程执行到哪了。
线程私有，每条线程都有自己的程序计数器。生命周期：随着线程的创建而创建，随着线程的结束而销毁。是唯一一个不会出现 OutOfMemoryError 的内存区域。 Java 虚拟机栈 虚拟机栈是线程独有的空间，每个线程都有一个与线程同时创建的私有的虚拟机栈。虚拟机栈中存储栈帧，每个被线程调用的方法都会产生一个栈帧。调用一个方法就是执行一个栈帧的过程，一个方法调用完成，对应的栈帧就会出栈。
栈帧用于存放该方法运行过程中的一些信息，如：
局部变量表操作数栈动态链接方法出口信息… 局部变量表
定义为一个数字数组，主要用于存储方法参数、定义在方法体内部的局部变量，数据类型包括各类基本数据类型，对象引用，以及 return address 类型。
局部变量表容量大小是在编译期确定下来的。最基本的存储单元是 slot（变量槽）。
操作数栈
每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）
操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
动态链接
每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令
在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。
虚拟机栈可能有以下两种异常：
如果线程执行所需栈深度大于Java虚拟机栈深度，就会抛出StackOverFlowError，其实方法调用的过程就是入栈和出栈的过程，如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，就容易发生异常（递归调用）如果Java虚拟机栈可以动态扩展，但是扩展大小的时候无法申请到足够的内存，则会抛出OutOfMemoryError。 public static void main(String[] args) { test(); } public static void test() { test(); } //抛出异常：Exception in thread"main"java.lang.StackoverflowError //程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。 本地方法栈 本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124ff6f75a9d7a45b3c90c96122e69d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c192759cc93430c83fd29fee6b3582b/" rel="bookmark">
			PHP-常量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
常量
常量的概念
常量的定义方式
常量的命名规则
两个定义常量函数的区别
使用常量的方式
常量和变量的使用说明 常量 常量跟变量一样都是用来保存数据的
常量的概念 常量：const/constant 是一种不可改变的量(数据) 常量一旦定义，通常数据不可改变
常量的定义方式 常量的定义方式有两种分别是：
使用函数define('常量名',常量值)；定义 define('pi',3.1415926); 使用关键字 const 常量名 = 常量值 ；定义 const pi = 3.14; 常量的命名规则 常量不需要使用 ' $ ' 符号命名，否则系统会认为是变量常量命名可由数字、字母、' _ '等特殊字符组成，但不能由数字开头常量命名通常使用大写字母为主，以表示变量和常量的区别常量的命名规则比变量的松散可以使用一些特殊字符来命名，但必须使用函数define定义 //使用特殊字符定义常量名 define('-w-','sb'); 注意：定义常量的时候通常不区分大小写但是也可以区分！
两个定义常量函数的区别 函数define()和函数const的区别是访问权限的区别
使用常量的方式 常量和变量的使用方式一样，区别在于常量值是不可改变的，在定义的时候必须同时赋值
注意：常量名中包含特殊符号的，在使用常量的时候需要使用函数constant('常量名')进行输出
//使用函数const定义常量 const a = '这是函数const定义的常量'; echo a; //输出“这是函数const定义的常量” //使用函数define()定义常量 //无特殊字符 define('abc','这是函数define()定义的常量'); echo abc; //使用特殊字符 define('-w-','这常量名里面包含着特殊字符'); echo constant('-w-'); //输出这常量名里面包含着特殊字符 常量和变量的使用说明 数据会发生变化的情况下，必须使用变量；数据不一定会发生变化的时候可以使用变量或者常量（变量居多）数据不允许修改的情况下，一定要使用常量； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/822cb42c86480870ef4da5c908878973/" rel="bookmark">
			putty使用密钥登陆OpenSSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows管理Linux服务器时，常使用putty登陆ssh进行远程管理。默认登陆验证方式为密码认证，该方式虽然简单，但每次登陆都要输入一长串的密码，相当麻烦。而且，如果万一把root允许登陆打开，还有可能被强力破解，导致严重的后果。
所以，通常建议用密钥登陆验证代替密码方式，即简单，又可靠。
一、为什么建议使用密钥登陆
通常现在的Linux发行版都使用OpenSSH代替telnet、rsh等明文传输的终端服务。
以红旗 DC Server 5.0为例：
引用
# rpm -qa|grep -E -w 'openssh'
openssh-clients-4.0p1-1.2AX
openssh-server-4.0p1-1.2AX
openssh-4.0p1-1.2AX
而OpenSSH默认是同时支持密码和密钥两种认证方式的。转一个说明：
为什么要使用公钥认证
通常，通过ssh登录远程服务器时，使用密码认证，分别输入用户名和密码，两者满足一定规则就可以登录。但是密码认证有以下的缺点：
引用
a）用户无法设置空密码（即使系统允许空密码，也会十分危险） b）密码容易被人偷窥或猜到 c）服务器上的一个帐户若要给多人使用，则必须让所有使用者都知道密码，导致密码容易泄露，而且修改密码时必须通知所有人
而使用公钥认证则可以解决上述问题。
引用
a）公钥认证允许使用空密码，省去每次登录都需要输入密码的麻烦 b）多个使用者可以通过各自的密钥登录到系统上的同一个用户
c）即使修改了对应用户的密码，也不会影响登陆
d）若同时禁用密码认证，则只要保证私钥的安全，不会受到暴力破解的威胁
二、使用putty生成密钥和登陆
根据公钥认证的原理（见后面说明），认证双方任何一方都可制作该钥匙对，并且只要认证方有被认证方的公钥信息，即可匹配成功。
这里，我们先以Windows上的putty登陆Linux服务器为例说明。所以，该密钥对由putty制作。
继续前，请确保您已经把整个putty包都下载完：
官方网站：点击
最新版本：0.60，我截图的版本是0.55的。
本地下载：
下载文件
点击这里下载文件
其中包括：PuTTY、Puttygen、PSCP、Plink、Pagent 等工具。
1、使用puttygen制作密钥
启动puttygen工具，为兼容OpenSSH密钥，选择“SSH2 RSA”：
单击 Generate 按钮，并使用鼠标在“key”框内移动，以获得足够的随机数据供生成密钥使用：
※期间，你会看到进度条上面有个提示“Please generate some radomness by moving the mouse over the blank area.”，意思就是让你用鼠标在空白区域随机移动。随着鼠标在空白区域的移动，进度条会一直走下去。停止移动鼠标，进度条也就停止了。所以，那我们要移动鼠标，直到进度条走满为止。
完成后的窗口如下：
其中：
引用
Key comment：是注释，不会影响密钥的有效性，但可作为自己用于区别其他密钥的参考；
Key passphrase 和 Confirm passphrase ：用于保护私钥，如果不输入该信息，那么任何人只要拿到该私钥，即可无密码登陆系统，非常危险；通常情况下，我是建议大家输入的，但这里为了方便说明，暂时留空，请看后面使用的说明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/822cb42c86480870ef4da5c908878973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f79d10937f74533a35ee40417c9aea0c/" rel="bookmark">
			数学研究对象是集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ ​数学研究对象是什么？这是一个根本性问题，必须说清楚。
​ ​记得，1957年的秋天，袁萌到南京大学图书馆借阅德国数学家Hausdorff的代表作“集合论”。
​ ​在这本书中，Hausdorff把序偶定义为集合：（a，b）={a，{a，b}}
​ ​这个定义概念清楚，让我至今记忆犹新。
​ ​1976年，德国数学家J. Keisler在其代表作“Elementary Calculus”中，把函数定义为由序偶的集合。
​ ​请见本文附件。
​ ​据此，数学研究对象是集合，以及集合的集合，除此之外一切其他的“东西”都不是数学的研究对象。
袁萌 （孙朗宸 代笔）
2022年1月15日
附件：
无穷小与函数的序偶定义
​ ​进入中文互联网搜索“无穷小与函数”关键字，你会发现，这两个基本数学概念被媒体糟蹋得不成样子，严重干扰了大学新生上网学习的兴趣。这种状况必须得到改变。
​ ​看问题要有历史观点，不能抓住一个“时间点”胡乱发挥。上世纪中叶，数理逻辑模型论利用“超乘积”技术给莱布尼兹所创建的微积分学（Calculus）一个历史性的辩护，使其重新获得新生。这是数学的一大进步。
​ ​简而言之，模型论所创立的这种新型的数系，即“超实数系”*R（Hyperreals）。在这种“超实数系”*R是一个抽象集合（Set），其中的元素都是“平等的”，也就是说，都是本质相同的超实数。超实数系*R远比传统实数系结构丰富、复杂。但是，十分巧合的是，在*R中有个相对很小的子集合R与传统实数系“保序同构”。在*R中，存在一种大于零而小于R中的一切”正数“的超实数。由于R与传统实数“保序同构”，由此，人们称这类超实数为“无穷小”(Infinitesimal)，符合我们的直观感觉，这是顺理成章的事情。在传统实数系中，谈论无穷小是无稽之谈，胡说八道。
​ ​函数是什么？如果函数是一种对应关系、映射关系，那么，什么是“对应”？，什么是“映射”？又是一笔糊涂账，说不清，道不明。1939年，法国布尔巴基学派将函数定义为“序偶集合”（Setof orderedpairs)，正好顺应了引入超实数*R的历史发展潮流，把传统函数定义中的“对应”、”映射“含糊说辞统统避开了。
​ ​在J.Keisler的《基础微积分》第一章第1.1节中，明确无误地将函数定义为”序偶集合“，干净利落，概念清晰，特别有利于大学新生的掌握、理解。为此，我阅们要引发一个学习现代无穷小微积分的群众热潮，抛开旧传统，迎接新潮流。现在，坚定主张现代无穷小的人虽然是极少数，但是，只要我们把数学真理”原汁原味地“上传到互联网上，理解的人们就会自然地跟上来了。所以，负责人工转录的文员薛lily以及负责语义校对的张xiaofeng女士，她们两人的工作都很有意义。只要我们做到了这一点（上传成功），数学真理的传播是不可阻挡的。（全文完）
袁萌 2013年6月29日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/529ea28555c6cd4104458a4ca63563c5/" rel="bookmark">
			EFCore中怎么表示Mysql中的三种模糊查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 EFCore中对应Mysql中的三种模糊查询：
Like’%xxx%’：DbContext.TableInfo.Where(p =&gt; stringList.Contains(p.id))Like’xxx%’：DbContext.TableInfo.Where(p =&gt; p.Name.StartsWith("XXX"))Like’%xxx’：DbContext.TableInfo.Where(p =&gt; p.Name.EndsWith("XXX")) 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/78/">«</a>
	<span class="pagination__item pagination__item--current">79/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/80/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>