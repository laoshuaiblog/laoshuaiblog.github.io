<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998c8f8196c01c0f43bff5962014940e/" rel="bookmark">
			Tomcat及项目部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Tomcat是什么？ Tomcat 是基于 Java 实现的⼀个开源免费, 也是被⼴泛使⽤的 HTTP 服务器。
二、下载安装 官⽅⽹站：https://tomcat.apache.org/
选择其中的 zip 压缩包, 下载后解压缩即可.
解压缩的⽬录最好不要带 "中⽂" 或者 特殊符号
三、目录结构 把zip文件解压之后可以看到以下文件
apache-tomcat-8.5
bin \存放各种启动、停⽌脚本的。*.sh 是以后在 linux 上⽤的，*.b
at 是在 windows 上⽤的
startup.bat 启动服务，双击即可使⽤
conf \ 相关的配置⽂件，⽬前我们不⽤关⼼
lib \ 运⾏ tomcat 需要的类库，我们不关⼼
logs \ 运⾏时的⽇志⽂件，我们有时需要查看⽇志，来发现定位⼀些问题
temp \ 临时⽂件夹，不关⼼
webapps \ 存放我们要运⾏的 web application 的⽂件夹，对于我们最常
⽤的⼀个⽂件夹
work \ Tomcat 内部进⾏预编译的⽂件夹，我们不关⼼
下⾯都是⼀些⽂档，有兴趣的同学可以⾃⾏阅读
BUIDING.txt
CONTRIBUTING.md
LICENSE
NOTICE
README.md
RELEASE-NOTES
RUNNING.txt
四、启动服务器 1.在 bin ⽬录中, 双击 startup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/998c8f8196c01c0f43bff5962014940e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811faa0c3c06d369ebffcaca66a5d8e7/" rel="bookmark">
			Java高级编程——Java8的其它新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java高级编程——Java8的其它新特性 目录
Java高级编程——Java8的其它新特性
0.Java 8新特性简介
0.1.并行流与串行流 一、Lambda表达式
1.为什么使用 Lambda 表达式
2.两个例子
3.语法
4.类型推断
上代码
二、函数式(Functional)接口
1.什么是函数式(Functional)接口
2.如何理解函数式接口
3.函数式接口举例
4.自定义函数式接口
5. 作为参数传递 Lambda 表达式
6.Java 内置四大核心函数式接口
上代码
总结
三、方法引用与构造器引用
1.方法引用(Method References)
2.方法引用举例
上代码
3.构造器引用
4.数组引用
上代码
四、强大的Stream API
1.Stream API说明
2.为什么要使用Stream API
3.什么是 Stream
4.Stream 的操作三个步骤
创建 Stream方式（一）
1.通过集合
2.通过数组
3.通过Stream的of()
4.创建无限流
Stream 的中间操作（二）
1.选与切片
2.映射
3.排序
Stream 的终止操作（三）
1-匹配与查找
2-归约
3-收集
上代码
五、Optional类
1.概述
上代码
学习的思维方式：
1. "大处着眼，小处着手"
2. 逆向思维、反证法 List&lt;String&gt; list2; List&lt;Object&gt; list1 = list2;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811faa0c3c06d369ebffcaca66a5d8e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eacbe7507ccc6c36f126f32a0e5c89c/" rel="bookmark">
			这一刻，我感觉一定要给.....（补充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一刻，我感觉一定要给。。。。_空白MAX的博客-CSDN博客
太好玩儿了，根据空白大佬的图，并在此基础上做了一些补充，hhhhh~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55d4a5694422bc389b0c33d6b9a1d69/" rel="bookmark">
			Java高级编程——Java反射机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java高级编程——Java反射机制 目录
Java高级编程——Java反射机制
一、Java反射机制概述
1.Java Reflection
2.补充：动态语言 vs 静态语言
3.Java反射机制研究及应用
4.反射相关的主要API
二、理解Class类并获取Class实例
1.Class 类
2. Class类的常用方法
3.反射的应用举例
4.获取Class类的实例 (四种方法)
5.哪些类型可以有Class对象？
上代码
三、类的加载与ClassLoader的理解
1.了解：类的加载过程
2.了解：什么时候会发生类初始化？
3.了解：ClassLoader
上代码
四、创建运行时类的对象
1.有了Class对象，能做什么？
上代码
五、获取运行时类的完整结构
1.通过反射获取运行时类的完整结构
2.小 结
上代码
六、调用运行时类的指定结构
1.调用指定方法
2.调用指定属性
3.关于setAccessible方法的使用
上代码
七、反射的应用：动态代理
1.代理设计模式的原理
2.Java动态代理相关API
3.动态代理步骤
4.动态代理与AOP（Aspect Orient Programming)
代码演示
静态代理
动态代理
一、Java反射机制概述 1.Java Reflection 2.补充：动态语言 vs 静态语言 框架 =反射 + 注解 + 设计模式
3.Java反射机制研究及应用 4.反射相关的主要API 二、理解Class类并获取Class实例 1.Class 类 2. Class类的常用方法 3.反射的应用举例 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d55d4a5694422bc389b0c33d6b9a1d69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56a1306e2396cba357faa659667f3ba/" rel="bookmark">
			（carbon flow（1/n））计算物理母线与三绕组变压器对应关系的计算步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算过程：
步骤一：将1、2、3侧母线节点写成一列1+2+3侧母线节点；
步骤二：利用vlookup函数分别计算“1+2+3侧母线节点”对应的在1侧、2侧和3侧的寻找结果，没有找到赋值为“”；
步骤三：判断语句，将3个vlookup的结果归集在一起，形成“1+2+3侧汇集”。
步骤四：将“1+2+3侧母线节点”进行数据透视，形成不重复的总母线节点
步骤五：利用vlookup函数将物理母线与变电站对应。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1140955146486142206e21c9bc4d4093/" rel="bookmark">
			如何超过大多数人——陈皓（左耳朵耗子）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：酷 壳 – CoolShell
当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的“武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径……然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力……然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍”用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个“人生导师”可以写得好。毕竟，我的生命过到了十六进制2B的年纪，踏入这个社会已超过20年，舍我其谁呢？！
P.S. 这篇文章借鉴于《如何写出无法维护的代码》一文的风格……嘿嘿
目录
相关技巧和最佳实践
相关原理和思维模型
认知
知识
技能
领导力
相关技巧和最佳实践 要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。
在信息获取上，你要不断地向大众鼓吹下面的这些事：
让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。
让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。
把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。
让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场……
利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。
然后，在知识学习和技能训练上，让他们不得要领并产生幻觉
让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……
培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……
不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”……
让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃……
玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……
让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……
告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……
让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……
让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就
等同于学好了……
最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。
让他们尽可能地用拼命和加班，尽可能的996，并告诉他们这就是通往成功的唯一路径。这样一来，他们必然会被永远困在低端成为最低的劳动力。
让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，就是不要告诉他还有另外一种活法，不要扩大他的认识……
宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……
告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……
多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……
多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……
让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……
让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……
告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春……
当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）
告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……
每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……
最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。
相关原理和思维模型
对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。
一般来说，超过别人一般来说就是两个维度：
1. 在认知、知识和技能上。
这是一个人赖以立足社会的能力（参看《程序员的荒谬之言还是至理名言？》和《21天教你学会C++》）
2. 在领导力上。
所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《技术人员发展之路》）
首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。
认知
要在认知上超过别人，就要在下面几个方面上做足功夫：
1）信息渠道。
试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&amp;R的不用，硬要用错误百出谭浩强的书，能有什么好呢？）
2）信息质量。
信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1140955146486142206e21c9bc4d4093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4736f81c5e487f1b38ef337db9d9006/" rel="bookmark">
			java/kotlin正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言字符捕获组和非捕获组Pattern和Matcher断言(Assertion)标记 前言 在学习java时，学过正则，但学完就放一边，偶尔需要用到一些简单的规则来匹配字符串。但大部分情况下，我都没有使用正则表达式的意识，对字符串的处理还是喜欢编写一大段代码来解决。 直到在工作中提交的一个PR，同事看到我的PR之后，就修改了我的代码，并跟我说用正则表达式的好处。 虽然PR的代码被修改了让我有点不爽，但看到人家提交的代码，还是让我自愧不如，也因为这件事，让我开始对正则表达式有了兴趣。 受这件事的影响，遇到字符串的问题时，我都会优先考虑使用正则表达式来解决。 再提一下上面PR的代码，那是一段在数字中间塞空格的代码，源自我的一篇介绍"安卓无障碍的开发"的文章。具体需求为：
val str = "abc1234def" 有这样一个字符串，希望处理之后，结果是：
abc1 2 3 4def
此时，如果不用正则表达式，直接编写代码处理，就需要判断某个字符是否为数字，它的下一个字符是否也为数字，然后再用StringBuilder拼接起来，还是比较麻烦的。而如果使用正则表达式，就非常简单：
val str = "abc1234def" val regex = "(\\d)(?=\\d)".toRegex() println(str.replace(regex,"$1 ")) // result: abc1 2 3 4def 可以看到，只需一个简单的正则表达式，就可以完成这个需求。这里涉及到捕获组和正向前瞻断言的知识，下面会介绍。
字符 先介绍正则表达式的基本用法，然后再介绍比较复杂的用法。 转义 在提特殊字符和预定义字符之前，先说转义问题。 在正则表达式里面，有不少预定义字符，比如：\w、\s、\d。如果想在java里面使用它们，就必须写成"\\d"，否则编译就会报错。第一个斜杆用于将第二个斜杆转义成一个普通字符。 特殊字符和预定义字符 字符作用例子^匹配一行的开头。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与"\n"或"\r"之后的位置匹配。如果在[]里面使用，表示匹配除了[]以外的字符。用[^a-j]otlin匹配kotlin为true，如果去掉^为false$匹配一行的结尾。如果设置了RegExp对象的Multiline属性，$ 还会与"\n"或"\r"之前的位置匹配\w+\d+$，匹配以数字结尾|或a|b，匹配a或b[]在[]里面的任意字符。可以使用“-”表示范围a-zA-z：前者表示26个字母中的任意字符。0-9：表示0到9 10个数字中的任意字符。abc：表示abc三个字符中的任意字符{}用于匹配次数，下面会列出相关用法none()用于捕获分组或限制操作符的作用范围(ab)+，匹配 ababab，ab出现了多次，所以(?:pattern)用于非捕获组none.匹配任意单个字符，除了换行符。如果想要匹配"."字符，需要使用转义kotli.，可以匹配kotlin、kotlim等\w匹配单字符，包括0-9、26个英文字母和下划线_kotli\w，匹配kotlin、kotlim等\d匹配单个数字，等同于[0-9]kotlin\d，匹配kotlin1、kotlin2等\s匹配任意换行符\w\s\w，匹配a b\b匹配字符边界hello\b，匹配hello后面是否为边界。hello\b.*，匹配hello,world hello后面是否为边界。边界可以是没有字符，也可以是,.等字符\uxxxx匹配16进制所表示的0xxxx字符\u4E00，匹配中文"一"{n}n为非负整数，正好匹配n次\w{2}，表示有2个字符{n,}n为非负整数，至少匹配n次\w{2,}，表示至少有2个字符{n,m}n和m都为非负整数，匹配n到m次，n&lt;=m\w{2,3}，表示有2到3个字符?等同{0,1}，表示零次或一次\w?，判断字符是否出现0到1次*等同{0,}，表示零次或多次\w*，该字符是否存在都无所谓。如，\d\w*，必须出现数字，但是否存在其他字符都行+等同{1,}，表至少出现一次\d+\w*，如1months，出现了1，至于后面的months有没有，都行 大概就是这些，可能会有遗漏。
然后还有需要补充的：\d、\w、\s、\b这几个，如果将小写字母改为大写字母，就表示相反的意思。如\D表示数字以外的字符，^也有同样的作用，如[^\d]
上面提了这么多字符，来一些例子巩固一下
匹配手机号码
val str = "13111111111" // 两种方式都可以[]里面的内容表示数字3到9，\\d{9}表示数字必须出现9次 // val regex = "1[3456789]\\d{9}".toRegex() val regex = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4736f81c5e487f1b38ef337db9d9006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c9ab08d03b4fe904289e1a51c0a597/" rel="bookmark">
			Android技术框架篇(三)：MVVM框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、MVVM架构的基本概念
二、MVVM架构的核心思想
三、MVVM架构的实现方式
四、MVVM架构的优缺点
五、MVVM架构的应用场景
一、MVVM架构的基本概念 以下是MVVM架构的基本概念的简要总结：
概念描述Model数据和业务逻辑的层，负责管理数据的获取、存储和处理。View用户界面层，负责展示数据和与用户的交互。ViewModel连接Model和View的桥梁，负责处理用户输入、管理数据变化和提供界面更新。数据绑定实现Model和View之间的自动数据同步，使得数据的变化能够自动反映在界面上。命令将用户操作封装成对象，使得操作可以在ViewModel中进行处理和管理。双向绑定允许数据的双向同步更新，即当Model中的数据改变时，View自动更新；当用户在View中修改数据时，Model也会相应更新。解耦将数据和界面逻辑解耦，使得每个组件可以独立开发、测试和维护。 MVVM架构的基本概念包括三个关键组件：Model、View和ViewModel。Model负责数据和业务逻辑的管理，View负责用户界面的展示和交互，ViewModel作为连接Model和View的桥梁，负责处理用户输入、管理数据变化和提供界面更新。数据绑定是MVVM的核心机制，它实现了Model和View之间的自动数据同步，使得数据的变化能够自动反映在界面上。
此外，MVVM还引入了命令的概念，将用户操作封装成对象，使得操作可以在ViewModel中进行处理和管理。双向绑定则允许数据的双向同步更新，即当Model中的数据改变时，View自动更新；当用户在View中修改数据时，Model也会相应更新。通过解耦数据和界面逻辑，MVVM架构实现了组件的独立开发、测试和维护。
二、MVVM架构的核心思想 下表是MVVM架构的核心思想：
核心思想描述分离关注点（Separation of Concerns）将视图逻辑、业务逻辑和数据操作分离开来，使每个部分专注于自己的职责。数据驱动视图（Data-Driven Views）视图的展示内容通过数据驱动，视图模型负责处理数据的准备和转换，以满足视图的需求。单向数据流（Unidirectional Data Flow）数据从模型层流向视图模型层，再流向视图层，确保数据的一致性和可追溯性。双向数据绑定（Two-Way Data Binding）视图和视图模型之间建立双向数据绑定，使数据的变化能够自动同步，提供更好的用户交互和响应性。可测试性（Testability）将业务逻辑从视图层解耦，使业务逻辑和数据操作更易于测试。通过单元测试和自动化测试确保系统的可靠性和稳定性。可扩展性（Scalability）通过组件的解耦和模块化，使系统易于扩展和维护。新功能的添加或修改不会影响整个系统的其他部分，提高开发的灵活性和效率。 以上核心思想体现了MVVM架构的设计原则和优势，通过这种架构方式，我们可以实现高内聚、低耦合、易于测试和可扩展的应用程序开发。
三、MVVM架构的实现方式 下表是MVVM的架构实现方式：
实现方式描述模型（Model）负责数据的获取、存储和处理，包括数据库操作、网络请求等。视图（View）用户界面的展示层，负责用户交互和数据的展示。可以是Activity、Fragment、XML布局等。视图模型（ViewModel）连接模型和视图之间的桥梁，负责准备和管理视图所需的数据，并将模型层的数据转换为视图所需的格式。数据绑定（Data Binding）实现视图和视图模型之间的双向数据绑定，使数据的变化能够自动同步更新视图。命令（Command）将用户交互行为封装成可执行的命令对象，用于处理用户操作。通过命令对象，可以将用户操作与视图模型的方法绑定在一起。依赖注入（Dependency Injection）使用依赖注入框架（如Dagger、Koin等）管理对象的创建和依赖关系，提高代码的可测试性和可维护性。组件通信（Component Communication）使用事件、观察者模式或消息总线等方式实现组件间的通信，使各个组件之间解耦。单元测试（Unit Testing）对模型和视图模型层进行单元测试，验证其功能和逻辑的正确性，提高代码的质量和稳定性。数据持久化（Data Persistence）使用合适的数据持久化方案（如SQLite、Shared Preferences、文件存储等）进行数据的保存和读取，确保数据的持久性和可靠性。MVVM框架（MVVM Framework）使用现有的MVVM框架（如Android Jetpack的ViewModel、LiveData等）加速开发过程，提供MVVM架构所需的核心组件和功能。 以上是MVVM架构的实现方式，开发人员可以根据具体的需求和项目特点选择适合的实践方式来构建优秀的Android应用程序。
四、MVVM架构的优缺点 以下是MVVM架构的优缺点：
优点缺点分离关注点（Separation of Concerns）学习曲线较陡峭可测试性（Testability）增加了复杂性和额外的开发成本可维护性（Maintainability）适用于大型项目和复杂业务逻辑可扩展性（Scalability）需要合适的框架和工具支持代码重用（Code Reusability）数据绑定可能引发性能问题支持并行开发（Support for Parallel Development）视图和视图模型之间的通信可能引发同步问题提高开发效率（Improved Development Efficiency）对小型项目和简单业务逻辑而言，引入MVVM可能过于繁琐和冗余可以更好地分工协作（Better Team Collaboration）需要合适的架构设计和规范 以上是MVVM架构的优缺点，开发团队在选择架构时应综合考虑项目的规模、复杂性、开发需求和团队成员的技术水平，以及项目的长期维护和可扩展性要求，从而做出适合的决策。
五、MVVM架构的应用场景 以下是MVVM架构的应用场景：
应用场景描述复杂的用户界面当应用程序具有复杂的用户界面和大量的交互时，MVVM可以提供更好的分层和组织代码的方式。需要频繁变更的用户界面如果应用程序的用户界面需要频繁变更，MVVM的数据绑定机制可以简化界面更新的过程，提高开发效率。需要同时支持多个平台或设备的应用程序MVVM的解耦性和可测试性使其非常适合开发需要在多个平台或设备上运行的应用程序，如移动应用和桌面应用。需要重用代码和逻辑的应用程序MVVM的分离关注点和数据绑定机制使得代码和逻辑的重用更加容易，从而减少了代码的重复编写。需要高可维护性和可扩展性的应用程序MVVM的分层结构和清晰的职责分离使得应用程序更易于维护和扩展，有利于团队合作和长期项目的发展。 以上是MVVM架构的应用场景，开发团队在选择架构时应考虑项目的特点、需求和目标，结合团队的技术能力和开发周期，来决定是否采用MVVM架构。
在撰写本文时，我尽力提供准确和有用的信息，但难免存在不足之处。如有任何不准确或改进的地方，请各位不吝指正，以便不断改进和提升。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe16a6497ed00a0e41cde955ae4641e/" rel="bookmark">
			关于dataframe中的警告A value is trying to be set on a copy of a slice from a DataFrame问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pandas处理dataframe时新增一列数据时发现这里给出警告，但不影响程序的正常运行。
这个警告意思是pandas在使用de[‘列名’]赋值时会返回一个试图而不是原始的dataframe,这种情况下对视图进行修改可能无法生效。
针对这个问题，网上普遍有两种解决方案：
①使用loc方法进行赋值：
de.loc[:,'时间']=de['订单创建时间'] ②使用copy()方法复制dateframe再进行操作：
de_new=de.copy() de_new['时间']=de['订单创建时间'] 按照上述两种方法操作后发现方法①执行后还是给出警告，方法②则是不会发出警告，因此利用copy()方法是有效的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b100a1ed3385d2838b016567efb54238/" rel="bookmark">
			uin-app项目实现pdf文件预览以及下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于项目需要，需要对于pdf格式的文件进行预览由用户进行选择性下载，查阅相关文档后方知针对于这种 pdf.js有奇效
一、下载 官网地址https://mozilla.github.io/pdf.js/getting_started/#download
文档下载解压成功后，按照这种格式放入uin-app项目中：
注意：
需要注意的是，解压后的文件需要放在静态资源文件夹中，pdf.js的相关文件是需要按照静态资源来做加载的，放在别的地方加载不出来的，
同时build文件我是修改了文件名称，以及源码中的相关名称的，在上传远程的时候这个文件总是被忽略掉，如果没有类似问题，可以不做修改
二、应用 新建单独页面做为点击链接后的，pdf文件渲染页面通过web-view结合pdf.js对于pdf文件做出预览 &lt;template&gt; &lt;view class="pdf-module" style="width: 100%; height: 100%"&gt; &lt;web-view :src="allUrl"&gt;&lt;/web-view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { allUrl: "", pdfUrl: "", viewerUrl: "/static/hybrid/html/web/viewer.html", }; }, onLoad(option) { let itemObj = JSON.parse(decodeURIComponent(option.itemObj)); this.allUrl = `${this.viewerUrl}?file=${itemObj.url}`; }, }; &lt;/script&gt; 注意：
这里的地址要和你文件中的路径保持一致，否则页面空白pdf.js第三方插件库是能够渲染链接以及文件流的，因此无需多虑！ 有问题可以留言讨论！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f8bac20153069baf86939e00c15a97c/" rel="bookmark">
			Vscode链接SSH服务器问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 vscode远程连接服务器时ssh: Connection refused，过程试图写入的管道不存在
reason：可能是服务器ssh service没有打开
solution：sudo service ssh start；（设置开机自启动：sudo service ssh start）
若启动后任然出问题，可以尝试retry重新链接
2 WSASendCB - ERROR: broken assumption, io:000001EB0A8E5D20, sent:33, remaining:0
reason：windows系统自带openssh环境变量不适合使用vscode连接导致
solution：
右击 此电脑-属性-高级系统设置-高级-环境变量-系统变量-Path-编辑
把路径为: %SYSTEMROOT%\System32\OpenSSH\更改为xxxxx\Git\usr\bin
3 ssh config文件的配置
Host alias
HostName 172.17.252.97
User 远程服务器的名字
ServerAliveInterval 50
ServerAliveCountMax 4
4 vscode的settings.json配置
{
"workbench.colorTheme": "Visual Studio Dark - C++",
"remote.SSH.configFile":"C:\\Users\\xxxxx\\.ssh\\config",（3中ssh config文件的存放路径）
"remote.SSH.path": "D:\\Program Files\\Git\\usr\\bin\\ssh.exe", （Git中ssh.exe的路径）
"remote.SSH.showLoginTerminal": true,
"remote.SSH.remotePlatform": {
"alias": "linux"
},
"bracket-pair-colorizer-2.depreciation-notice": false,
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b1d1407acdc2a985e5a365ade3436e/" rel="bookmark">
			Java 学习资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 框架系列 SpringBoot 学习资源 Spring Boot 教程汇总（http://www.springboot.wiki/） SpringCloud 学习资源 Spring Cloud 微服务教程汇总（http://www.springcloud.wiki/#home） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469816918ea638fa1454238c42aa4104/" rel="bookmark">
			【洛谷】P8665 [蓝桥杯 2018 省 A] 航班时间 的题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【洛谷】P8665 [蓝桥杯 2018 省 A] 航班时间 的题解 题目传送门 思路 思路的话很简单，把起止时间用秒表示，计算差值就行。
但是需要注意：
计算的结果是取两次时间差值的平均值。
不要漏掉 getchar 读掉的后缀的 + n +n +n 天。
代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;cctype&gt; #include &lt;climits&gt; #include &lt;algorithm&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;ctime&gt; #include &lt;string&gt; #include &lt;cstring&gt; #define lowbit(x) x &amp; (-x) #define endl "\n" using namespace std; typedef long long ll; typedef unsigned long long ull; namespace fastIO { inline int read() { register int x = 0, f = 1; register char c = getchar(); while (c &lt; '0' || c &gt; '9') { if(c == '-') f = -1; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f; } inline void write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) write(x / 10); putchar(x % 10 + '0'); return; } } using namespace fastIO; int t; ll calc() { int t1, h1, m1, t2, h2, m2; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/469816918ea638fa1454238c42aa4104/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6428dc770753efeadf07dc3331935988/" rel="bookmark">
			计算机组成原理Cache例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，计算Cache的命中率，效率，平均访问时间
已知cache命中98次，访问主存2次。主存周期是cache的4倍，主存存取周期为200ns，求cache的命中率，效率，平均访问时间。
2.有一个cache的容量为2K字，每块为16字，按字编址。
①该cache可容纳多少个块？
② 如果主存的容量是256K字，则有多少个块
③主存的地址有多少位?cache的地址有多少位
④在直接地址映像方式下，主存中的第i块映像到cache中哪一个块？
⑤进行地址映像时，存储器地址分成哪几段？各段分别有多少位？
3，某计算机cache用4路组相联地址映像，已知cache容量为16KB，主存容量为2MB，每个字块有8个字，每个字有32位。请回答：
主存地址多少位(按字节编址)，各字段如何划分(各需多少位)？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3cb09979cd1b49f69605ebf09339987/" rel="bookmark">
			前端响应式布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端响应式布局原理与方案（详细版）
文章目录 1、媒体查询不同尺寸设置不同css样式**移动优先 OR PC优先** 2、百分比布局3、rem布局4.视口单位5.图片响应式1.使用max-width（图片自适应）:2.使用srcset3.使用background-image 响应式布局：在不同屏幕尺寸下， 同一页面有不同的布局。
传统的开发模式：PC端搞一套布局，移动端搞一套布局。
使用了响应式布局，只需要开发一套即可，缺点是CSS比较重
响应式设计和自适应设计的区别：响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，展现不同的布局和内容
自适应需要开发多套界面，通过检测视口分辨率，判断当前访问的设备是PC端、平板、手机，从而请求服务层返回不同的页面
1、媒体查询 不同尺寸设置不同css样式 关键点如何选择不同的尺寸区间，即如何确定媒体查询的分割点。
如果我们选择600px,900px,1200px,1800px作为分割点，可以适配到常见的14个机型
当然这只是其中的一种分割方案，我们还可以这样划分：480px,800px,1400px,1400px
而作为曾经典型的响应式布局框架，Bootstrap是怎么进行断点的呢？
上面的分割方案不一定满足项目中的实际需求，我们可以先用跨度大的分割点进行分割，如果出现不适配的情况可以再根据实际情况增加新的分割点。
移动优先 OR PC优先 移动用的多，pc不多
不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是min-width，PC端优先使用的max-width。
移动优先:
&lt;style&gt; /* iphone6 7 8 */ body { background-color: yellow; } /* iphone 5 [, 320]是红色*/ @media screen and (max-width: 320px) { body { background-color: red; } } /* iphoneX [375, 414-1px] 为啥没有显示#0FF000; */ @media screen and (min-width: 375px) and (-webkit-device-pixel-ratio: 3) { body { background-color: #0FF000; } } /* iphone6 7 8 plus [414, 768-1]是Blue */ @media screen and (min-width: 414px) { body { background-color: blue; } } /* ipad [768px]*/ @media screen and (min-width: 768px) { body { background-color: green; } } /* ipad pro [1024px, 1100-1]*/ @media screen and (min-width: 1024px) { body { background-color: #f0f; } } /* pc [1100px,] */ @media screen and (min-width: 1100px) { body { background-color: black; } } &lt;/style&gt; PC优先：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3cb09979cd1b49f69605ebf09339987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4399601e55a8f9bec05a32b5d51d2f6/" rel="bookmark">
			如何解决在 k3s 环境中每次运行 kubectl 都需要 sudo 的问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装好了 k3s 以后每次运行 kubectl 系统可能会提示以下信息：
Unable to read /etc/rancher/k3s/k3s.yaml, please start server with -write-kubeconfig-mode to modify kube config permissions. error: error loading config file “/etc/rancher/k3s/k3s.yaml”: open /etc/rancher/k3s/k3s.yaml: permission denied 原因是 k3s 的配置文件放在了 /etc/rancher/k3s/k3s.yaml。这个位置需要 root 用户才能访问。我们可以把这个文件复制到当前用的 .kubeconfig 文件下。使用以下命令：
mkdir -p $HOME/.kube sudo cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config sudo chown $USER:$USER $HOME/.kube/config 然后运行下面的命令让 k3s 使用刚才设置的配置文件：
export KUBECONFIG=~/.kube/config 为了避免每次登录都需要运行以上命令。我们可以把上面的 export 命令加到 .bashrc 里。
结论 我们可以通过把 k3s 的配置文件设置到当前用户的目录下来避免每次运行 kubectl 命令都需要 sudo 的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/821fdbc832060334e35438c8c0f2407c/" rel="bookmark">
			B树和B&#43;树的区别（mysql数据结构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简述 写在前面1、B树2、B+树 深入浅出 B树 B树深入B-树的查找 B+ 树 B+树概述 B-树和B+树的区别拓展：MySQL为什么使用B-Tree（B+Tree）&amp;&amp; 存储知识 存储数据最小单元主存存取原理磁盘存取原理 总结 简述 写在前面 大家在面试的时候，肯定都会被问到MySql的知识，以下是面试场景：
B树 和B+树是 MySQL索引使用的数据结构，对于索引优化和原理理解都非常重要，下面我的写文章就是要把B树，B+树的神秘面纱揭开，让大家在面试的时候碰到这个知识点一往无前，不再成为你的知识盲点！
1、B树 这里的 B 是 Balance（平衡）的缩写。它是一种多路的平衡搜索树。它跟普通的平衡二叉树的不同是，B树的每个节点可以存储多个数据，而且每个节点不止有两个子节点，最多可以有上千个子节点。B树中每个节点都存放着索引和数据，数据遍布整个树结构，搜索可能在非叶子节点结束，最好的情况是O(1)。一般一棵 B 树的高度在 3 层左右，3 层就可满足 百万级别的数据量 B树 每个节点都存储了一定的范围区间，区间更多的情况下，搜索也就更快。
比如普通的二叉树对于 1~ 100 的索引值，首先分为 1~ 50 和51~ 100 两部分。
而 B树可以分为四个区间 1~ 25, 26~ 50, 51~ 75, 76~ 100 。甚至可以划分为更多区间，这样一次就能排除四分之三的数据
2、B+树 B+树是B树的一种变种，它与 B树 的 区别 是：
叶子节点保存了完整的索引和数据，而非叶子节点只保存索引值，因此它的查询时间固定为 log(n).叶子节点中有指向下一个叶子节点的指针，叶子节点类似于一个单链表正因为叶子节点保存了完整的数据以及有指针作为连接，B+树可以增加了区间访问性，提高了范围查询，而B树的范围查询相对较差B+树更适合外部存储。因为它的非叶子节点不存储数据，只保存索引。 B+树的示意图如下：
到此为止相信你已经对B树和B+树有一定认识，下面结合数据库深入了解
深入浅出 B树 B-树有如下特点:
所有键值分布在整颗树中（索引值和具体data都在每个节点里）；任何一个关键字出现且只出现在一个结点中；搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；在关键字全集内做一次查找,性能逼近二分查找； B树深入 B树由来
定义：B-树是一类树，包括B-树、B+树、B*树等，是一棵自平衡的搜索树，它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/821fdbc832060334e35438c8c0f2407c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4af9a621ab31b4ca0afa9476660c879/" rel="bookmark">
			Python3学习之数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 数字数据类型用于存储数值。数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。以下实例在变量赋值时 Number 对象将被创建：
var1 = 1 var2 = 10 可以使用del语句删除一些数字对象的引用。del语句的语法是：
del var1[,var2[,var3[....,varN]]] 可以通过使用del语句删除单个或多个对象的引用，例如：
del var del var_a, var_b Python 支持三种不同的数值类型：
整型(int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 可以使用十六进制和八进制来代表整数：
&gt;&gt;&gt; number = 0xA0F # 十六进制 &gt;&gt;&gt; number 2575 &gt;&gt;&gt; number=0o37 # 八进制 &gt;&gt;&gt; number 31 intfloatcomplex100.03.14j10015.2045.j-786-21.99.322e-36j08032.3e+18.876j-0490-90.-.6545+0J-0x260-32.54e1003e+26J0x6970.2E-124.53e-7j Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4af9a621ab31b4ca0afa9476660c879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2539adcc642254d756e6db648cb4bb91/" rel="bookmark">
			干爆源码系列之Step by step lldb/gdb调试多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Step by step lldb/gdb调试多线程 0.叙谈1.断点分析2.多线程切换 2.1 并发队列 2.1.1 两次入队 2.2 线程调度 2.2.1 执行build端子MetaPipeline 2.2.1.1 Thread6调度第一个PipelineInitializeTask 2.2.1.2 Thread7调度第二个PipelineInitializeTask 2.2.1.3 Thread8调度build端PipelineEvent 2.2.2 执行下一个Metapipeline
书接上回，我们分析了InitializeInternal的ScheduleEvents函数，了解了如何从MetaPipeline构建各种Event事件，上一节中还提到在最终会进行调度，对无依赖节点发起Schedule()，那么本节就继续这一内容，详细从多线程角度看看这些Event对应的Task如何被调度的呢？
本节将会从lldb/gdb角度Step by step断点调试分析多线程如何玩转task执行。
0.叙谈 下面展示了一段无依赖的事件调度，初始化阶段会循环所有events，找到无依赖的event，并发起Schedule()，这里的event是PipelineInitializeEvent，两个MetaPipline各自一个，按照顺序入并发队列，接下来详细聊聊如何调试以及具体怎么调度多任务的呢？
for (auto &amp;event : events) { if (!event-&gt;HasDependencies()) { event-&gt;Schedule(); } } 1.断点分析 下面是本次调试的断点list，每个都break一下便可以快速学习了。
Enqueue函数
Task入队的函数。
b task_scheduler.cpp:47
ExecuteForever函数
线程从队列中获取Task的函数。
b task_scheduler.cpp:135
打上这两个断点后，就可以调试多线程了。
Event::CompleteDependency函数
处理事件依赖关系，能够定位当前线程处理了哪些event。
Event::Finish函数
能够知道当前事件的依赖有哪些，下一步处理哪一个，这个跟上面的函数一起用。
2.多线程切换 2.1 并发队列 初始化时，当调用Schedule()后，会把PipelineInitializeTask放入并发队列中，见下图的queue(蓝色部分)。
2.1.1 两次入队 1）入队第一个PipelineInitializeTask
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2539adcc642254d756e6db648cb4bb91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412148c4fd2d90d3e8e394920882ced8/" rel="bookmark">
			案例|某城商行Zabbix 监控架构分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编者荐语：
作者所在的某城商行顺利完成应用系统监控迁移到 Zabbix平台，将从架构部署、监控维度、自动化方案、运营管理层面，分享Zabbix 系统发展壮大的经验。本文作者也在"Zabbix技术交流群“，欢迎加入交流。
AcidGo：某城商行基础架构运维工程师
2018年开始使用并在公司内部普及Zabbix监控系统，在内部生产环境使用Zabbix监控了多款存储设备、数千台操作系统主机、各个数据库产品等多维度的监控覆盖，开发了多个自定义监控脚本、应用监控框架和前端页面展示。
Zabbix 平台概述
平台介绍
Zabbix 是一个基于 Web 界面提供分布式系统监视及网络监视功能的企业级开源解决方案。它能监视各种网络参数，保证服务器系统的安全运营，并提供灵活的通知机制以让系统管理员快速定位、解决存在的各种问题，借助Zabbix 可很轻松地减轻运维人员繁重的服务器管理任务，保证业务系统持续运行。其后端使用数据库存储监控配置和历史数据，可以非常方便地对接数据分析、报表定制等渠道，在前端开放了丰富的 RESTful API 供第三方平台调用，整体架构在当下的 DevOps 的趋势下显得非常亮眼。
选型过程
我们于 2017 年开始接触 Zabbix，之前运维内主要使用的监控系统是 Nagios，但 Nagios 的页面展示、监控配置、自动化等各项功能对基础架构的运维人员来说不是特别友好，而风头正劲的 Zabbix 正好引起了我们的注意。基础架构的运维工作中，需要面对各种各样的监控场景，例如 PC 服务器的故障灯巡检、存储设备的阵列健康判断、小型机 LPAR 的资源监控、操作系统的多路径检查，等等。而 Zabbix 内置提供了 SNMP、IMPI、SSH、Agent 等多种监控途径，在系统架构的各层场景下都能很好的适配，其中 Agent 还支持自定义工具，总体的表现非常灵活。在网页前端管理上，Zabbix 可以满足各个粒度的监控管理，从整个集群到单独一个监控项都能够进行细分管控，自定义 dashboard 和历史数据可视化功能也极大地方便运维人员对监控数据的审查。综合以上的考虑因素，行内选择了 Zabbix 作为一个新的监控平台试点，从基础资源的监控出发，首先将大部分存储、主机和操作系统接管到 Zabbix。
使用现状
2017 年底在基础架构范围内试行的 Zabbix 系统，从 3.2 版本开始逐步演进到现在的 4.4 版本，其中经历了各项监控系统的里程碑事件。目前的 Zabbix 系统也由原先的小范围试用，逐步扩展到涵盖硬件、应用、平台、业务等更大范围的场景，架构上也从单数据中心进化为三中心的分布式部署。除了逐渐替代旧的监控系统，越来越多的第三方系统也开始对接起了 Zabbix，例如自动化运维平台、持续发布平台、运维可视化平台等，通过 API 或者数据库抽数的方式，使用海量的运维监控数据实现智能运维的工作模式。
在编写此文前不久，我们也顺利完成应用系统监控迁移到 Zabbix 平台，作为一名全程参与 Zabbix 系统推广实施和自动化开发的运维人员，非常荣幸能够见证我们运维力量的茁壮成长，在此，本人也将从架构部署、监控维度、自动化方案、运营管理层面，分享我们 Zabbix 系统发展壮大的经验。
硬件监控
数据中心的运维管理中，系统架构的纵向深度是非常陡长的，包括最基础的硬件设备也需要运维人员费尽心思地去巡检排查，但随着数据中心的设备数量呈爆发式增长，人工巡检已不能满足当下监控实时性、可靠性的要求。对于这种低层级的监控，Zabbix 的多维度特性就非常好的解决了这个问题，其内置的 SNMP/IPMI 协议能够轻松对接相关硬件设备的带外监控。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/412148c4fd2d90d3e8e394920882ced8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/46/">«</a>
	<span class="pagination__item pagination__item--current">47/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/48/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>