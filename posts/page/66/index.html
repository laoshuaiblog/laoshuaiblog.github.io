<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b7eb3cf2a1456dba22c777e0bbb805a/" rel="bookmark">
			删除win10电脑U盘使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.查看U盘使用记录 通过注册表信息，可以看到U盘插拔的历史记录，步骤如下： 1、【运行对话框】
在Windows10电脑桌面，右键点击其左下角的开始按钮，然后在弹出菜单中选择“运行”菜单项。或者在键盘上同时按下WIN+R，打开运行窗口。
2、【Regedit】
在打开的运行对话框内输入命令Regedit，然后点击确定按钮。
3、【注册表】
这时就可以看到打开的注册表编辑器窗口，继续下一步。
4、【注册表项】
把注册表编辑器定位到HKEY_LOCAL_MACHINE\SYSTEM\ControlSet00X，其中X可以是任意数字，例如ControlSet001，ControlSe002等等注册表项。
5、【历史记录】
然后再依次展开注册表项ControlSet001\Enum\USBSTOR，在下面就可以看到所有连接过的USB设备。
6、【详细信息】
点击其中任一个设备，可以在右侧的窗口中看到该设备的详细信息。 2.删除记录的方法 手工删除：和查看的方法类似，分三步，缺一不可，顺序也不能反！
第一步
设置环境变量，变量名为“devmgr_show_nonpresent_devices”，值为“1”。
第二步
打开设备管理器，勾上“查看”菜单中的“显示隐藏设备”。如果之前已经打开设备管理器，则要关了，重新打开。
第三步
清除“磁盘驱动器”、“存储卷”、“通用串行总线控制器”3个栏目下所有的灰色的图标，注意是所有！右键点击灰色图标，然后选择“卸载”。
3.成功 ：结果 USBSTOR 没有了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef50580ebe41d049279cd9e59a70d477/" rel="bookmark">
			2022企业级常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引 目的：为了提高查询的效率。
1、什么时候考虑添加索引？ 条件1：数据量庞大（到底有多么大算庞大，这个需要测试，因为每一个硬件环境不同）
条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。
条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）
2、索引的类型 主键索引，数据库表的主键字段会自动创建索引。唯一索引，当某个列添加了Unique约束，也会自动创建唯一索引，要求值必须是唯一的。普通索引，给普通字段添加索引就是普通索引。组合索引，多个字段合起来创建一个索引，遵循最左前缀原则。 3、创建索引sql create index 要创建的索引名 on 要创建索引的表名(要创建索引的字段);
4、怎么查看一条sql语句中使用了索引？ EXPLAIN select * from dept where loc = ‘北京’;
看rows执行条数
5、索引失效的情况以及对应解决方案 失效的第1种情况：
select * from emp where ename like ‘%T’;
ename上即使添加了索引，也不会走索引，为什么？
原因是因为模糊匹配当中以“%”开头了，mysql找不到。
解决方案：尽量避免模糊查询的时候以“%”开始。这是一种优化的手段/策略。
失效的第2种情况：
使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有索引，才会走索引，如果or其中一边有一个字段没有索引，那么另一个字段上的索引也会失效。
解决方案：
不建议使用or，所以这就是为什么不建议使用or的原因。
或使用union联合查询。
举例：
dept表，loc字段有索引，deptname字段没有索引
select * from dept where loc = ‘福建’ or deptname = ‘信息部’;
查询位于福建的或者信息部的部门信息
以上sql语句，由于deptname没有索引，会导致loc的索引失效，可以使用union联合查询：
select * from dept where loc = ‘福建’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef50580ebe41d049279cd9e59a70d477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/435ece17a27c150ba6954ef550c00873/" rel="bookmark">
			如何在Linux系统挂载U盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：使用的U盘要FAT32模式，在Windows端插上U盘，右键点击属性，确认U盘文件系统为FAT32模式。如果自己的U盘格式化选项没有FAT32，可以下载DiskGenius进行格式化。
1、插入U盘列出当前设备块信息：lsblk，需要挂载的U盘设备是sdb1
2、把它挂载到当前的任意目录下，新建目录：mkdir my_usb
3、输入挂载指令，sudo mount /dev/sdb1 my_usb/
非root用户需要加sudo并输入密码 此时查看设备块信息，可以看到sdb1已经挂载到/home/fw/my_usb路径下，取消挂载指令
sudo umount my_usb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb96fbf27d0becf09bd19a61e079a66/" rel="bookmark">
			无法重命名，文件不可信，后台被自动关闭，“Notebook Untitled.ipynb is not trusted jupyter”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jupyter Noteebook 在安装完成之后通过cmd终端输入 jupyter notebook 以启动 jupyter，可以正常浏览器跳转，但是发现无法创建新文件，无法重命名，提示文件不可信，终端里 jupyter后台自动退出，如下图：
可在终端输入以下命令
pip install pyzmq==19.0.2 看到 Successfully 这样就安装成功了，虽然有报红，但是不用管，这时，重新启动 jupyter 即可正常运行了
那为什么会出现这种情况呢，据说是系统用户名为中文导致的。但是千万不要想当然的去更改系统用户名，否则会导致系统奔溃，想改成英文，只能等下次需要换系统重新命名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a6e7797b77a85cfd9d5f064d83cc366/" rel="bookmark">
			在线程中弹出自定义对话框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线程中弹出自定义对话框 | 火苗999℃的博客
弹出对话框的代码 ：
主要是弹出对话框的时候可以在后台做某些动作：
与直接弹出对话框前开启线程，在线程中做某些动作效果相同。
MsgBoxThread mbt; mbt.MesgBoxPopup(10, "请按手指！"); // do something // do something mbt.WaitFor(); // 等待线程退出 使用到的MsgThread和对话框类
#include "StdAfx.h" #include "MsgBoxThread.h" #include "YF_GCM.h" #include "DlgMesgBox.h" unsigned int __stdcall ThreadBox(LPVOID); MsgBoxThread::MsgBoxThread(void) { } MsgBoxThread::~MsgBoxThread(void) { } int MsgBoxThread::MesgBoxPopup(int time, const CString&amp; szText) { m_Mesg.text = szText; m_Mesg.time = time; m_handle[0] = (HANDLE)_beginthreadex(NULL, 0, ThreadBox, (LPVOID)&amp;m_Mesg, 0, NULL); return 0; } unsigned int __stdcall ThreadBox(LPVOID lp) { _mesg *pTmpMesg = (_mesg *)lp; CDlgMesgBox box; box.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a6e7797b77a85cfd9d5f064d83cc366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46482eccfc6a17eb54f5bd1ad07ee9a2/" rel="bookmark">
			LVS&#43;Keepalived负载均衡高可用群集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Keepalived高可用详解
1.应用场景
2.介绍和原理简介
3.主要模块和作用
二、LVS+keepalived配置实例（抢占模式）
1.配置NFS共享存储器
2.配置节点web服务（两台的配置相同）
3.配置主备LVS+keepalived负载调度器
三、非抢占模式
四、脑裂现象的解释和解决办法
1.解释
2.解决方法
一、Keepalived高可用详解 1.应用场景 在企业应用中，单台服务器承担应用存在单点故障的危险。单点故障一旦发生，企业服务将发生中断，造成极大的危害。所以需要群集实现高可用性，保证服务稳定。
2.介绍和原理简介 Keepalived是一个基于VRRP协议来实现的LVS服务高可用方案，可以解决静态路由出现的单点故障问题。
可参考 VRRP详解与配置实例_Evens7xxX的博客-CSDN博客
支持故障自动切换（Failover）和 节点健康状态检查（Health Checking）—— 判断LVS负载调度器、节点服务器的可用性，当master主机出现故障及时切换到backup节点保证业务正常，当master故障主机恢复后将其重新加入群集并且业务。
在一个LVS服务集群中通常有主服务器(NASIER）和备份服务器（EcCXOp)两种角色的服务器，但是对外表现为一个虚拟re，主服务器会发送vRt通告信息给备份服务器，当备份服务器收不到wa&amp;消息的时候，即主服务器异常的时候，备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。W AEF AWF EAFAF FAEDAWAWEDF 4TWAWDFA
3.主要模块和作用 core模块：为keepalived的核心，负责主进程的启动、维护及全局配置文件的加载和解析
vrrp模块：是来实现VRRP协议的，用于主备调度器的检查和切换。
check模块：负责健康检查节点服务器，常见的方式有端口检查及URL检查。
二、LVS+keepalived配置实例（抢占模式） LVS-NAT 参考 LVS-DR负载群集的优势和部署实例_Evens7xxX的博客-CSDN博客​​​​​​
LVS-DR 参考 LVS-DR负载群集的优势和部署实例_Evens7xxX的博客-CSDN博客
以下实验使用LVS-DR+keepalived的抢占模式实现高可用负载群集
Web 服务器1：192.168.116.10（VIP 192.168.116.100）
Web 服务器2：192.168.116.20（VIP 192.168.116.100）
NFS 共享存储器：192.168.116.30
LVS+keepalived 主负载调度器：192.168.116.40（VIP 192.168.116.100）
LVS+keepalived 备负载调度器：192.168.116.30（VIP 192.168.116.100）
网关/路由器：192.168.116.2
客户端：192.168.116.50
1.配置NFS共享存储器 systemctl stop firewalld.service setenforce 0 yum -y install nfs-utils rpcbind mkdir /opt/nfs/server1 /opt/nfs/server2 chmod -R 777 /opt/nfs vim /etc/exports /opt/nfs 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46482eccfc6a17eb54f5bd1ad07ee9a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9378ce2a4563ecdb4fdf122ae6d52af7/" rel="bookmark">
			为什么小数java会不精确呢？？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么会不精确？？？ 因为0.1 和 0.2 在转换为二进制时就发生了一次精度丢失，而对于计算后的二进制又有一次精度丢失 。因此，得到的结果是不准确的。
在 64 位的二进制中，符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。
实际上，不是运算本身会出错，而是计算机根本就不能精确的表示很多数，比如0.1这个数。
计算机是用一种二进制格式存储小数的，这个二进制格式不能精确表示0.1，它只能表示一个非常接近0.1但又不等于0.1的一个数。
并且你会发现有时候的计算结果是准确的。
其实，这只是Java语言给我们造成的假象，计算结果其实也是不精确的，但是由于结果和0.2足够接近，在输出的时候，Java选择了输出0.2这个看上去非常精简的数字，而不是一个中间有很多0的小数。
在误差足够小的时候，结果看上去是精确的，但不精确才是常态。
怎么处理计算不精确？？？
减小精度。大部分情况下，我们不需要那么高的精度，可以四舍五入，或者在输出的时候只保留固定个数的小数位。
进行转换。如果真的需要比较高的精度，可以将小数转化为整数进行运算，运算结束后再转化为小数。
使用十进制的数据类型。但运算更准确，效率比较低。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b520996385af83eb94d1889dd071d37/" rel="bookmark">
			verilog | 十、时钟信号与复位信号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.常规时钟
1) initial:
parameter clk_period = 10;
reg clk;
initial begin
clk = 1'b0;
forever
#(clk_period / 2) clk = ~clk;
end
2) always:
parameter clk_period = 10;
reg clk;
initial
clk = 0;
always #(clk_period / 2) clk = ~clk;
2.占空比可调时钟
//占空比：High_time / (High_time + Low_time)
parameter High_time = 5, Low_time = 10;
reg clk;
always
begin
clk = 1;
# High_time;
clk = 0;
# Low_time;
end
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b520996385af83eb94d1889dd071d37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097a3e851244dafb77ac2b929c621cb4/" rel="bookmark">
			Tracing Knowledge State with Individual Cognition and Acquisition Estimation 阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reference Ting Long, Yunfei Liu, Jian Shen, Weinan Zhang, Yong Yu. 2021. Tracing Knowledge State with Individual Cognition and Acquisition Estimation. In Proceedings of the 44th International ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR ’21), July 11–15, 2021, Virtual Event, Canada. ACM, New York, NY, USA, 10 pages. https://doi.org/10.1145/ 3404835.3462827 原文链接：https://dl.acm.org/doi/10.1145/3404835.3462827
在线学习网站面临的一个关键问题：动态评估学生的学习状态，找出学生难以回答的问题，并将其推入学生的待回答列表。Knowledge Tracing有利于在线教育中的相关任务，如安排个人学习路径，推荐学习材料。
深度学习拥有强大的学习能力，因此很多人致力于设计知识追踪的深度模型，比如基于拥有auto-regressive结构的深度学习模型RNN的KT模型。该模型中学生的知识状态(概念的掌握水平)由循环单元的隐藏状态表示，框架由read和write两个阶段组成，框架结构如下图所示：
在read阶段，将recurrent cell的隐含状态和问题表征加载到多层感知器中，预测学生正确回答问题的概率。write阶段通过在收到一个问题的反馈后更新相应的recurrent cell来模拟学生知识状态的动态变化。
1. motivation 上述KT模型存在缺陷：
（1）认为学生认知水平一致（cognition level一致）
（2）认为学生在相同的学习条件下可以获得相同的知识增量（acquisition sensitivity一致）
缺乏对cognition level和acquisition sensitivity的显式建模限制了模型的表现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/097a3e851244dafb77ac2b929c621cb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51971f11a82bb1bec94308d5cf644ad/" rel="bookmark">
			【Batch Normalization 在CNN中的实现细节】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. BN在MLP中的实现步骤2. BN在CNN中的实现细节2.1 训练过程2.2 前向推断过程 整天说Batch Norm，CNN的论文里离不开Batch Norm。BN可以使每层输入数据分布相对稳定，加速模型训练时的收敛速度。但BN操作在CNN中具体是如何实现的呢？
1. BN在MLP中的实现步骤 首先快速回顾下BN在MLP中是怎样的，步骤如下图：
图片来源：BN原论文
一句话概括就是对于每个特征，求一个batch求均值和方差。然后该特征减去均值除以标准差，再进行一个可以学习参数的线性缩放（即乘以γ加上β）即可。本质上是对输入进行线性缩放，使得每层的输入数值分布相对稳定。
在MLP中更具体的实现可以参考BN原论文，也可以看这篇讲解——Batch Normalization原理与实战，写得非常清楚。
2. BN在CNN中的实现细节 其实本质上还是对于每层进行线性缩放，使得每层的数据分布相对稳定。但由于MLP中的一层是一个1D的向量，而CNN的每一层是一个3D的tensor，所以具体实现细节还是有差异的。
整体过程还是和上面的步骤一致：
2.1 训练过程 只是我们不在对每个特征，求一个batch的均值和方差；而是对每个feature map，求一个batch的均值和方差。
也可以这么表述：MLP是对在特征维度（即每个神经元）求均值和方差，而CNN是在通道（channel）维度（即每个feature map）求均值和方差。
表述得更清楚一些：
上图中红框圈出的是CNN的一层，形状是（C, H, W），其中，C是通道个数（即feature map的数量），H和W是feature map的长和宽。我们可以这么理解：CNN的一层是一个3D的矩阵，是由C层2D的feature map组成的。
若一个batch有N张图片，则红框圈出的一层的形状为（N, C, H, W），即共有NxCxHxW个数值。
在训练时，BN做的就是在该batch中，对该层每一个feature map的所有数据（即第二个维度C，共有C个feature map），求均值和方差。即对NxHxW个数据求均值μ和方差σ。【一个feature map有HxW个数据，一个batch中有N张图片】即对第i个feature map，有与之对应的μ_i和σ_i。
因为一层有C个feature map，所以就共有C个μ_i和σ_i。i∈[1, C]
其余过程就和MLP一样了：第i个feature map每个元素减去对应的均值μ_i除以标准差，然后再进行一个可以学习参数的线性缩放（即乘以γ加上β）即可。
2.2 前向推断过程 和MLP一样，在训练过程中，每个batch都会求出C个均值和方差（因为每个feature map都会有一个均值和方差）。
而在前向推断过程，则对于所有的batch的每个feature map的均值和方差做平均，论文中是求出所有均值的期望和方差的无偏估计，如下：
得到前向推断时每一层feature map的均值μ_i_test和方差σ_i_test。然后第i个feature map每个元素减去对应的均值μ_i_test除以标准差，然后再进行一个的线性缩放（即乘以γ加上β）即可。其中γ和β是训练过程已经训练好的。
总而言之：MLP是对在特征维度（即每个神经元）对一个batch求均值和方差，而CNN是在通道（channel）维度（即每个feature map）对一个batch求均值和方差。
END：）
总觉得文字还是无法完全把我的想法表述清楚，最好的学习方法还是去看原论文，然后自己多琢磨。
参考：
1.【原论文】 Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d51971f11a82bb1bec94308d5cf644ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7ea6c01143fa176c829320560311082/" rel="bookmark">
			Js 简化代码的基础上解决后台返回字符串类型的Boolean值导致判断错误的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常情况 我们js判断Boolean值可以直接这样写
let mint = false; if(mint){ console.log("条件为 true"); }else{ console.log("条件为 false"); } 没有任何问题
但有时 后端直接给我们返回了个字符串 这种情况还是不少的 因为有些后端不想处理 就直接这样省事
但却会影响我们的判断结果
let mint = "false"; if(mint){ console.log("条件为 true"); }else{ console.log("条件为 false"); } 因为 mint 是个字符串 那么字符串判断的就是非空了 那他不为空啊 所以条件就成立了 换成Boolean就是true了
这时 有人就会想 改成
if(mint == "true") 呗
那要是后端有时候有返回的是Boolean类型的呢？
又有人想说
if(mint == "true"||mint == true) 我只能说 你这样是可以解决问题 但太丑了 写的 说实话 很多余
我们直接用js中的 eval方法就好了
let mint = "false"; if(eval(mint)){ console.log("条件为 true"); }else{ console.log("条件为 false"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7ea6c01143fa176c829320560311082/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae74713e56a614725fcceb27e84b2d5/" rel="bookmark">
			Node.js 应用部署到 SAP 云平台上访问时出现 502 Bad Gateway 错误分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：
Ghttps://erry-demo-server.ctapps.eu10.hana.ondemand.com
502 Bad Gateway: Registered endpoint failed to handle the request.
Elements Console Sources Network.
Performance Memory Application Security AuditsDefault levels
Adblock Plus
”
1top
2 messages.No user messageso2 errorsANo warnings
o FilterxExpression
ot available
17:13:48.811 Failed to load resource: the server responded with a status of 502 (Bad Gateway.17:13:54.589 Failed to load resource: the server responded with a status of 502 (Bad Gateway.
ONo infoENo verbos
检查Manifest.yml：里面指向的httpsServer.js:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ae74713e56a614725fcceb27e84b2d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbb5c0f010d26f1cead1f55c27543897/" rel="bookmark">
			大众点评Cat实时应用监控平台服务端部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于cat服务端部署的相关文档地址如下：
https://github.com/dianping/cat/wiki/readme_server
话不多说，接下来就按照官方文档流程走一遍，我这里是使用的Windows系统进行部署。
第一步确认环境：
我这边使用的是如下环境：
jdk: 1.8
mysql: 5.7 切记不要用8.x的mysql
tomcat: 7.0.35
环境也可以不一样，具体参考上面的文档
第二步编写相关配置文件：
因为我们是Windows上部署，所以可以直接跳过官方文档的第一步：
tomcat conf下的server.xml是否修改不影响，最好是不动任何配置（修改了好像还是乱码）
这一步很重要
因为是在Windows上部署，所以你要确定你的tomcat打算放在哪个盘进行运行，比如你的tomcat解压放在D盘的某个路径下，那么你创建的data/appdatas/cat和data/applogs/cat目录就必须是在D盘下，并且全路径就只能是 d:/data/appdatas/cat d:/data/applogs/cat，千万不要想着把这些个文件夹创建在别的地方。
当然还要一种方式只需要创建一个d:/data/appdatas/cat文件夹的方式，先把这个文件夹路径创建好，然后给自己电脑的环境变量添加一个变量为CAT_HOME的，值就是这个文件夹路径：
这样的话，日志和appdatas最后都会在这个文件夹里保存，还有，如果你的d盘里已经有了一个data文件夹（可能是因为运行其他软件导致有的），直接在这个文件夹里创建appdatas/cat路径即可：
随后在appdatas/cat文件夹里创建两个xml配置文件：
client.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;config mode="client"&gt; &lt;servers&gt; &lt;server ip="127.0.0.1" port="2280" http-port="8080"/&gt; &lt;/servers&gt; &lt;/config&gt; 我这里只在本地机器部署了，所以ip是127.0.0.1,其他像port和http-port不要修改，并且tomcat运行的端口号也不要修改，让tomcat默认以8080启动即可
datasources.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;data-sources&gt; &lt;data-source id="cat"&gt; &lt;maximum-pool-size&gt;3&lt;/maximum-pool-size&gt; &lt;connection-timeout&gt;1s&lt;/connection-timeout&gt; &lt;idle-timeout&gt;10m&lt;/idle-timeout&gt; &lt;statement-cache-size&gt;1000&lt;/statement-cache-size&gt; &lt;properties&gt; &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt; &lt;url&gt;&lt;![CDATA[jdbc:mysql://127.0.0.1:3306/cat]]&gt;&lt;/url&gt; &lt;!-- 请替换为真实数据库URL及Port --&gt; &lt;user&gt;root&lt;/user&gt; &lt;!-- 请替换为真实数据库用户名 --&gt; &lt;password&gt;root&lt;/password&gt; &lt;!-- 请替换为真实数据库密码 --&gt; &lt;connectionProperties&gt;&lt;![CDATA[useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;socketTimeout=120000]]&gt;&lt;/connectionProperties&gt; &lt;/properties&gt; &lt;/data-source&gt; &lt;/data-sources&gt; 填写好你自己的数据库地址以及root用户的密码，因为使用的是5.7版本的数据库，所以像driver无需加cj，connectionProperties中也不需要加serverTimezone参数。
配置数据库时，记得把相应的表也给创建好，数据库名称要和文件里的一致，表的SQL在cat的github文档里也有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbb5c0f010d26f1cead1f55c27543897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc20a490b582010429685648926ee16/" rel="bookmark">
			lvgl v8 linux下使用xmake交叉编译移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移植准备 针对linux移植lvgl官方已经提供了移植工程，只需要根据自己板子修改frambuffer的设备节点和input event设备节点。
1、下载移植工程源码
下载地址：
https://github.com/lvgl/lv_port_linux_frame_buffer 由于速度问题只使用以下方式下载：
git clone https://github.com/lvgl/lv_port_linux_frame_buffer] 下载下来发现lv_drivers和lvgl 目录是空的，对于这个问题直接去lvgl github仓库那里
下载release的压缩包：
lvgl-8.3.1.tar.gz lv_drivers-8.3.0.tar.gz 解压并重命名为lvgl、lv_driver：
# 解压 tar xvf lvgl-8.3.1.tar.gz tar xvf lv_drivers-8.3.0.tar.gz # 重命名 mv lvgl-8.3.1 lvgl mv lv_drivers-8.3.0 lv_drivers 移植修改 修改驱动配置头文件lv_drv_conf.h
322 #if USE_FBDEV 323 # define FBDEV_PATH "/dev/fb0" 324 #endif 根据板子实际情况选择fb设备节点
449 #if USE_EVDEV || USE_BSD_EVDEV 450 # define EVDEV_NAME "/dev/input/event1" 根据实际情况选择 input event
交叉编译 lvgl官方的移植工程已经写好makefile，只需要make就可以编译成功。
但是这里不使用写好的makefile，使用makefile后续添加自己应用的目录和文件太麻烦，
这里我使用xmake进行工程构建工作。
xmake是类似cmake的构建工具。
cmake也用过，cmake似乎每个有源码的目录都需要一个CMakeList.txt ？像lvgl移植工程源码目录层级太多，添加CMakeLists.txt要吐血。
xmake可以只有一个xmake.lua在根目录。
xmake github : https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc20a490b582010429685648926ee16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f95096f8121675485dc531d41c9da7a/" rel="bookmark">
			Android模糊查询的Spinner，模糊查询下拉选择框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做了个需求，后台返回了一个列表数据地址，实现下拉选择框，之前直接用了系统Spinner结果需要添加模糊查询功能找了很久的资料发现各个方案都不太一样本来想要自己写一个的结果发现了一个大佬写的跟需求差不多拿来改了一些。
添加链接描述
大佬的gitee原文地址需要的可以去看看写的很好也很清晰
public class AppCompatEditSpinner { /** * 使用SimpleAdapter加载数据 * &lt;p&gt; * 需要在 * {@link AppCompatEditSpinner#setMatchIgnoreCase(boolean)}、 * {@link AppCompatEditSpinner#setMatchTextColor(String)}、 * {@link AppCompatEditSpinner#setSpinnerItemTextColor(int)}、 * {@link AppCompatEditSpinner#setSpinnerItemTextSize(int)}、 * {@link AppCompatEditSpinner#setSpinnerBackground(int)} * 属性设置之后调用。 */ public void setItemData(List&lt;String&gt; data); /** * 使用继承{@link BaseEditSpinnerAdapter}的适配器加载数据 * &lt;p&gt; * 需要在 * {@link AppCompatEditSpinner#setMatchIgnoreCase(boolean)}、 * {@link AppCompatEditSpinner#setMatchTextColor(String)}、 * {@link AppCompatEditSpinner#setSpinnerItemTextColor(int)}、 * {@link AppCompatEditSpinner#setSpinnerItemTextSize(int)}、 * {@link AppCompatEditSpinner#setSpinnerBackground(int)} * 属性设置之后调用 */ public void setAdapter(BaseEditSpinnerAdapter adapter); /** * 设置文本 */ public void setText(@StringRes int text); /** * 设置文本 */ public void setText(String text); /** * 设置Hint文本 */ public void setHint(@StringRes int hint); /** * 设置Hint文本 */ public void setHint(String hint); /** * 设置Hint的文本颜色 */ public void setHintTextColor(@ColorInt int color); /** * 设置背景 */ public void setEditBackgroundResource(@DrawableRes int resource); /** * 设置输入文字字体大小，单位：sp */ public void setEditTextSize(int size); /** * 设置输入文字颜色 */ public void setEditTextColor(@ColorInt int color); /** * 设置输入限制最大行数 */ public void setEditMaxLines(int maxLines); /** * 设置输入限制最大字符长度 */ public void setEditMaxLength(int maxLength); /** * 设置输入限制类型 * &lt;p&gt; * 例如：{@link InputType#TYPE_CLASS_TEXT} */ public void setEditInputType(int inputType); /** * 设置输入限制字符 */ public void setEditDigits(@StringRes int digits); /** * 设置输入限制字符 */ public void setEditDigits(String digits); /** * 设置是否隐藏右侧下拉选图标 */ public void setRightImageGone(boolean rightImageGone); /** * 右侧图片展开下拉选时是否显示全部数据，默认：点击时显示和当前输入匹配的数据 */ public void setRightImageDropShowAllItem(boolean rightImageDropShowAllItem); /** * 匹配字符的颜色，忽略字母大小写时，此属性无效 * * &lt;p&gt; * 必须在{@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)} 调用之前进行设置 * &lt;p&gt; * {@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)} 调用后不可再次修改 * * @param matchTextColor RGB形式，需要包含#号，例如：“#000000” */ public void setMatchTextColor(String matchTextColor); /** * 匹配字符时是否忽略字母大小写，默认不忽略。 * * &lt;p&gt; * 必须在{@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)}调用之前进行设置 * &lt;p&gt; * {@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)} 调用后不可再次修改 */ public void setMatchIgnoreCase(boolean matchIgnoreCase); /** * 待选项的颜色，默认黑色 * * &lt;p&gt; * 必须在{@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)}调用之前进行设置 * &lt;p&gt; * {@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)} 调用后不可再次修改 */ public void setSpinnerItemTextColor(@ColorInt int spinnerItemTextColor); /** * 待选项的字体大小，单位sp。 * * &lt;p&gt; * 必须在{@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)}调用之前进行设置 * &lt;p&gt; * {@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)} 调用后不可再次修改 */ public void setSpinnerItemTextSize(int spinnerItemTextSize); /** * 待选项的背景 * * &lt;p&gt; * 必须在{@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)}调用之前进行设置 * &lt;p&gt; * {@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)} 调用后不可再次修改 */ public void setSpinnerBackground(Drawable spinnerBackground); /** * 待选项的背景 * * &lt;p&gt; * 必须在{@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)}调用之前进行设置 * &lt;p&gt; * {@link AppCompatEditSpinner#setItemData(List)} * 或者{@link AppCompatEditSpinner#setAdapter(BaseEditSpinnerAdapter)} 调用后不可再次修改 */ @SuppressLint("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f95096f8121675485dc531d41c9da7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e7773b0baa2999800f8ed307e44214/" rel="bookmark">
			Dev C&#43;&#43; 5.11版 「时代 の 眼泪」安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Dev C++ 是一款轻量化的 C / C++ 桌面 IDE ，由于不需要额外配置 GCC 、即开即用的特点，因此常常用于 C / C++ 语言基础的学习。
目前官方最新版为 Dev-C++ 5.11。
下载 国内 —— 计蒜客下载（速度快）
国外 —— SourceForge 下载（官方托管，速度慢）
跳过教程图片，点击直接无脑下载
计蒜客SourceForge 计蒜客 SourceForge 安装 没有说明就一路向下，看图即可：
测试 第一次启动 打开后选好中文一直 next 就行：
新建源代码 由于奇怪的因素，只能用英文进行演示啦~
对应位置是一样的
写代码 「 经 典 」 保存代码 编译运行 运行结果 「成功啦！」 传送门 嗯~ 其实很简单不是吗？但是截图好累，好心的陌生人能给个赞嘛 (｡･∀･)ﾉﾞ
一套教程搞下来，笔者肯定有些地方会有遗漏或错误，欢迎大家留言补充哦~
【⭐Dev 系列⭐】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf7041e348f3c28b140042ee192a4c2/" rel="bookmark">
			clickhouse数据导入遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 采用mybatis写入数据，速度很慢的问题； 采用mybatis拼接sql的方式，可以写入数据，但是效率很低。每秒数据大概200-300条数据记录。
2. 采用jdbc写入数据，可以使用两种数据源 // 新版本的包 import com.clickhouse.jdbc.ClickHouseDataSource; // 这个包可以 import ru.yandex.clickhouse.ClickHouseDataSource 3. 时间格式设置问题 组织批量写库时的日期时间格式问题。
java.sql.Date sqlPayTime = new java.sql.Date(bill.getPayTime().getTime()); prepareStatement.setObject(39, new Timestamp(sqlPayTime.getTime())); 需要使用sql的Timestamp，不能使用java.util.Date，也不能使用java.sql.Date。
4. 主键和排序键 在创建表时指定主键，会根据主键创建索引； 主键可以是多个列，不会影响查询性能，而且主键相同的数据可以重复； 一般不指定主键（primary key），而是指定排序键（order by），此时会把排序键作为主键； 排序键和主键可以不同，但此时主键必须时排序键的前缀。 5. 引擎参数问题 CREATE TABLE default.bill ( `bill_id` Int64, `bill_date` DateTime ） ENGINE = ReplacingMergeTree PARTITION BY toYYYYMM(bill_date) ORDER BY bill_date SETTINGS index_granularity = 8192; 这个引擎设置是有问题的。
当排序key相同的数据，在做数据合并的时候，会进行去重处理。如果bill_date相同，就会进行数据合并。
CREATE TABLE default.bill ( `bill_id` Int64, `bill_date` DateTime, `plat_billno` String ） ENGINE = ReplacingMergeTree(bill_date) PARTITION BY toYYYYMM(bill_date) ORDER BY (plat_billno, bill_date) PRIMARY KEY (plat_billno) SETTINGS index_granularity = 8192; 这个引擎设置才是正确的，因为账单编号本身是唯一的，所以不会造成数据被覆盖的情况。 ReplacingMergeTree引擎
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccf7041e348f3c28b140042ee192a4c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcf2980541cb5d9bfca2a17c3be9661/" rel="bookmark">
			判断一个数是否为素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 判断一个数是否为素数的两种思想方法 第一种代码思想： 思想如果一个数除了1和本身外不能被其他数整数，那么这个数为素数。
下面展示一下代码和输出结果。
// #include&lt;stdio.h&gt; int main(void) { int a,b; printf("请输入一个数："); scanf("%d",&amp;a); if(a&lt;=1) printf("%d不是素数",a); else if(a==2) printf("%d是素数",a); else { for(b=2;b&lt;a;b++) { if(a%b==0) { printf("%d不是素数",a); return 0; } } printf("%d是素数",a); } return 0; } 请输入一个数:3 3是素数 第二种代码思想： 判断一个数是否为素数，其根本就是看该数能不能被1和本身以外的数整除，值得注意的是，能够被该数整除的数存在于该数平方根的之前或之后，若平方根之前有，则之后也有，否则，无；如此，只需要循环判断该数平方根之前及该数的平方根能否被该数整除即可。
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int a; printf("请输入一个整数："); scanf("%d",&amp;a); if(a&lt;=1) printf("不是素数"); else if(a==2) printf("是素数"); else{ double b=sqrt(a); for(int i=2;i&lt;=b;i++) { if(a%i==0) { printf("不是素数"); return 0; } } printf("是素数"); } return 0; } 请输入一个整数:3 是素数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb5a3e8413395e79171b4fd0084ce38/" rel="bookmark">
			基于FCNN的特征提取网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景
对于深度学习相关的轴承故障分析，以前的研究要么使用原始的一维时间序列直接作为网络模型的输入，要么使用通过一维信号转换获得的二维波形信号作为网络模型的输入。基于原始数据的深度学习需要消耗大量的计算资源，此外大量的无用数据会大大降低模型的训练精度，因此本文希望将数据驱动的故障诊断转化为特征驱动的故障诊断，基于关键信息进行诊断大大加快了计算效率。
现有的卷积以一维和二维为主，一维时间序列信号进行分析口与较好的提取波形的时间序列特征，但是无法识别其内部的空间领域；二维波形信号的分析可以保留信号的空间领域特征，但是容易丢失时域特征。
二、模型
2.1融合卷积神经网络（FCNN）
融合卷积神经网络（FCNN）相比于单一的一维卷积和二维卷积的优势在于保证时序特征提取的同时可以基于图像处理手段找到“故障图”中的关键信息，并将二者进行融合挖掘深层次的故障特征信息驱动后续的故障识别算法。
基于FCNN的自编码器，编码部分包括以为信息编码和二维信息编码，在特征识别的最后将一维特征和二维特征数据进行拼接，并且通过全连接的方式进行特征融合。个网络层之间使用RELU函数进行激活，可增加模型的曲线拟合能力，但是该模型没有使用池化层，因为池化层会降低诊断的准确性。
FCNN特征提取结构表：
为实现自编码的训练过程，选择使用SmoothL1Loss损失函数。SmoothL1Loss同时具有L1Loss的优点和L2Loss的优点，当预测值和groundtruth差别较小的时候，其实是使用L2Loss，损失函数相较于L1Loss比较圆滑；而当差别大的时候没事L1Loss比较稳定，不容易梯度爆炸。其公式如下：
为实现梯度下降，系统使用Adam优化传统的随机梯度下降，可以解决系数梯度和噪声问题。
此编码层可将4096个数据点降维到一个二维平面上并以此作为故障信号特征点。
2.2故障诊断模型的改进过程
SVM算法具有良好的分类特性，其关键在于核函数的选择，每种核函数都i有对应的使用场景，基于特征参数在平面上的分布特点口与选择使用高斯核函数进行分类。高斯和函数是一种局部性较强的核函数，可以将一个样本映射到一个更高维的空间内，其公式为：
但是存在超参数选择困难问题，主要的超参数包括C和gamma，其中C是惩罚系数，C越高导致模型过拟合，不合适的C使得模型的泛化能力较差。二gamma时高斯核函数的超参数，gamma的选择决定了数据库映射后在高维空间的分部，gamma越大，支持向量越少，gamma越小支持向量越大，而支持向量的数据和训练预测的精度和速度有关。
文中使用了麻雀搜索算法对SVM的模型进行优化。麻雀搜索算法对种群进行初始化时采用的是随机生成的方式，而这种麻雀种群生成策略会导致分布不均匀然后影响后期的迭代。对此模型基于混沌序列进行初始种群的分布优化。因Tent混沌映射具有更好的均匀性，在初始化种群时选择Tent映射，其表达式如下，在迭代过程中的值会更新。
在种群初始化的过程中引入Tent映射后所产生的混沌麻雀序列如下所示：
为增大麻雀搜索算法迭代过程中的寻优范围，本文将引入飞行策略Levy。Levy飞行策略是一种游走算法，每一步的步长从一个heavy tail分布函数中采样，生成服从莱维分布的随机步长的方法如下所示：
论文参考：基于深度学习的滚动轴承故障诊断方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/067b2404f0ad58556add6fb7c85dc825/" rel="bookmark">
			数据结构初阶——栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
栈
1. 栈的概念及结构
2. 栈的实现
3. 栈的初始化与销毁
4. 入栈
5. 出栈
6. 获取栈顶元素
7. 获取栈中有效元素个数
测试栈
队列
1. 队列的概念及结构
2. 队列的实现
3. 队列的初始化与销毁
4. 入队
5. 出队
6. 获取队列头部和尾部元素
7. 获取队列中有效元素个数
测试队列
结语
栈 1. 栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和 删除操作的一端称为栈顶，另一端称为栈底。 栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。 压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 出栈：栈的删除操作叫做出栈。出数 据也在栈顶。 2. 栈的实现 栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。 还需要一个capacity变量来记录栈中容量，不够了要扩容。 3. 栈的初始化与销毁 4. 入栈 由于栈的性质，只有入栈时插入数据，那就不用单独写一个扩容的函数了，top记录的是栈中的数据个数，也记录下一个入栈的位置下标，和顺序表差别不大，也比不过多介绍了。
5. 出栈 这里就需要判断一下，第一点就是传入的指针不能为NULL，第二点就是栈中至少还有数据，不能为空。那就需要写一个函数判断栈中是不是空。
6. 获取栈顶元素 栈顶的下标就是top-1，获取栈顶元素就是找到数组中下标为top-1的数据，返回就可以了，当然还是要判断栈中是不是空的。
7. 获取栈中有效元素个数 直接返回top就可以了 。
测试栈 那这里为什么不写一个打印函数呢，是由于栈的性质，只能对栈顶的元素操作，所以接下来就测试一下这个栈。
这里也只是拿数组来实现栈的结构，也可以用链表来实现，使用什么数据结构要看场景，这些都可以自己决定。
队列 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/067b2404f0ad58556add6fb7c85dc825/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/65/">«</a>
	<span class="pagination__item pagination__item--current">66/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/67/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>