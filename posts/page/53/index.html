<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28bda702437bfd467bcaaa9e21365496/" rel="bookmark">
			vue3 setup语法糖的三种书写方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3 setup语法糖 关于vue3 setup语法糖的三种书写方法一、简介二、代码三、说明NO.1 setup写在script标签内。NO.2 setup写在js中。NO.3 setup写在js中，使用reactive打包页面内数据，再使用toRefs解构。 四、PS：关于vue3生命周期介绍 关于vue3 setup语法糖的三种书写方法 一、简介 Vue3 的一大特性函数 ---- setup
1、setup函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之间的函数 也就说在 setup函数中是无法 使用 data 和 methods 中的数据和方法的
2、setup函数是 Composition API（组合API）的入口
3、在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用
二、代码 &lt;template&gt; &lt;div&gt; &lt;div&gt;{{ readersNumber }}&lt;/div&gt; &lt;el-button type="primary" @click="onClick"&gt;自定义点击事件&lt;/el-button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; /* 方式一：(script 右边写上 setup)*/ // import {onBeforeMount, ref} from "vue"; // const readersNumber = ref('绿色回收') // const onClick = () =&gt; { // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28bda702437bfd467bcaaa9e21365496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180dedbe0f3072a51a261c171c371a58/" rel="bookmark">
			python json数据写入excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍💻个人简介： 深度学习图像领域工作者
🎉总结链接： 链接中主要是个人工作的总结，每个链接都是一些常用demo，代码直接复制运行即可。包括：
📌1.工作中常用深度学习脚本
📌2.torch、numpy等常用函数详解
📌3.opencv 图片、视频等操作
📌4.个人工作中的项目总结（纯干活）
链接： https://blog.csdn.net/qq_28949847/article/details/128552785
🎉视频讲解： 以上记录，通过B站等平台进行了视频讲解使用，可搜索 ‘Python图像识别’ 进行观看
B站：Python图像识别
抖音：Python图像识别
西瓜视频：Python图像识别
示例demo：
# -*- coding: utf-8 -*- import xlwt import json def json_excel(data): # 创建excel工作表 workbook = xlwt.Workbook(encoding='utf-8') worksheet = workbook.add_sheet('skiing') # 写表头 for index, val in enumerate(data[0].keys()): worksheet.write(0, index, label=val) # 写数据 for row, list_item in enumerate(data): row += 1 col = 0 for key, value in list_item.items(): worksheet.write(row, col, value) col += 1 # 保存 workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/180dedbe0f3072a51a261c171c371a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0b2b626eb477b1ab02651d6531cbac/" rel="bookmark">
			uniApp h5项目/小程序项目通过命令行打包 一个项目二端适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、打包环境1. 环境版本2. 搭建环境 二、创建项目2.1. HBuilder X创建项目2.2. cli创建项目2.3. H5项目移植2.4. 项目运行2.5. 打包个性化配置2.6. 项目打包 三、项目开发3.1. 开发模式运行项目3.2. 验证实时编译 四、异常汇总4.1. node-sass报错 一、打包环境 1. 环境版本 软件版本nodejsv14.17.5vue/cli4.5.15vue2.x 2. 搭建环境 安装nodejs
win： https://nodejs.org/download/release/v14.17.5/node-v14.17.5-x64.msi linux： https://nodejs.org/download/release/v14.17.5/node-v14.17.5-linux-x64.tar.xz linux安装流程：
wget https://nodejs.org/download/release/v14.17.5/node-v14.17.5-linux-x64.tar.xz tar -xvf node-v14.17.5-linux-x64.tar.xz mv node-v14.17.5-linux-x64 nodejs ln -s /app/nodejs/bin/node /usr/local/bin/ ln -s /app/nodejs/bin/npm /usr/local/bin/ node -v https://nodejs.org/download/release/v14.17.5/
卸载默认vue/cli
npm uninstall -g @vue/cli 安装vue/cli
npm install -g @vue/cli@4.5.15 二、创建项目 2.1. HBuilder X创建项目 my-project-x
修改展示文字为 gblfy.com
2.2. cli创建项目 通过cli新建一个项目
vue create -p dcloudio/uni-preset-vue my-project-cli 选择默认版本（直接敲回车键）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa0b2b626eb477b1ab02651d6531cbac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a68dfd7957e73e16bc46ab9d9c30fa/" rel="bookmark">
			Linux内核：进程管理——进程挂起管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 以前对于这个概念始终比较模糊，遂在解决后记录博客，希望帮助到有同样问题的朋友。
挂起状态是什么？ 我们一般认为进程有五个状态，即新建态，就绪态，阻塞态，运行态，终止态 。
而在这些状态之外还存在着一个状态，我们称之为挂起状态，它既可以是我们客户主动使得进程挂起，也可以是操作系统因为某些原因使得进程挂起。总而言之引入挂起状态的原因有以下几种：
用户的请求：可能是在程序运行期间发现了可疑的问题，需要暂停进程。父进程的请求：考察，协调，或修改子进程。操作系统的需要：对运行中资源的使用情况进行检查和记账。负载调节的需要：有一些实时的任务非常重要，需要得到充足的内存空间，这个时候我们需要把非实时的任务进行挂起，优先使得实时任务执行。定时任务：一个进程可能会周期性的执行某个任务，那么在一次执行完毕后挂起而不是阻塞，这样可以节省内存。安全：系统有时可能会出现故障或者某些功能受到破坏，这是就需要将系统中正在进行的进程进行挂起，当系统故障消除以后，对进程的状态进行恢复。 既然我们知道了挂起状态引入的原因，那么我们再来看看带有挂起状态的进程状态转移过程：
相比于一般的五个状态的进程状态转移图，我们引入了两种挂起状态的类型，即就绪挂起状态和阻塞挂起状态。它们的区别就是就绪挂起状态其实还是在内存中的，而后者是在外存中的 。接下来我们说一说新加入的几个状态转化的步骤：
运行状态-&gt;就绪挂起状态：这里发生在客户在程序正在运行是直接挂起程序。注意这里的箭头是单向的，所以在就绪挂起状态结束以后实际上是执行激活步骤，进入就绪状态，等待处理机调度。阻塞状态-&gt;阻塞挂起状态：当内存空间比较紧缺的时候，如果有存在在内存中的，而且是处于阻塞状态的进程，那么就让他更需要内存的程序占用内存，自己进入阻塞挂起状态，PCB等数据存入外存。因为现在这个进程也不能进入就绪状态，这个程序在内存中是没有什么作用的。阻塞挂起状态-&gt;就绪挂起状态：当阻塞状态等待的IO事件或其他事件到来的时候状态发生改变。就绪挂起状态-&gt;就绪状态：如果内存中没有就绪态进程，操作系统需要调入一个进程继续执行。此外，当处于就绪/挂起状态的进程比处于就绪态的任何进程的优先级都要高时，也可以进行这种转换。这种情况的产生是由于操作系统设计者规定，调入高优先级的进程比减少交换量更重要。就绪状态-&gt;就绪挂起状态：通常，操作系统更倾向于挂起阻塞态进程而不是就绪态进程，因为就绪态进程可以立即执行，而阻塞态进程占用了内存空间但不能执行。但如果释放内存以得到足够空间的唯一方法是挂起一个就绪态进程，那么这种转换也是必需的。并且，如果操作系统确信高优先级的阻塞态进程很快就会就绪，那么它可能选择挂起一个低优先级的就绪态进程，而不是一个高优先级的阻塞态进程。 挂起状态和阻塞状态有什么区别? 这里大多来自其他博主的文章，有以下几个方面的区别：
是否释放CPU：阻塞（pend）就是任务释放CPU，其他任务可以运行，一般在等待某种资源或信号量的时候出现。挂起（suspend）不释放CPU，如果任务优先级高就永远轮不到其他任务运行。一般挂起用于程序调试中的条件中断，当出现某个条件的情况下挂起，然后进行单步调试。是否主动：显然阻塞是一种被动行为，其发生在磁盘，网络IO，wait，lock等要等待某种事件的发生的操作之后。因为拿不到IO资源，所以阻塞时会放弃 CPU的占用。而挂起是主动的，因为挂起后还要受到CPU的监督（等待着激活），所以挂起不释放CPU，比如sleep函数，站着CPU不使用。与调度器是否相关：任务调度是操作系统来实现的，任务调度时，直接忽略挂起状态的任务，但是会顾及处于pend下的任务，当pend下的任务等待的资源就绪后，就可以转为ready了。ready只需要等待CPU时间，当然，任务调度也占用开销，但是不大，可以忽略。可以这样理解，只要是挂起状态，操作系统就不在管理这个任务了。 上面我们提到了sleep 函数和wait 函数，我们把它们单独拎出来看看：
sleep（）和wait（）函数的区别：
两者比较的共同之处是：两个方法都是使程序等待多少毫秒 。最主要区别是：sleep（）方法没有释放锁。而wait（）方法释放了锁，使得其他线程可以使用同步控制块或者方法 。sleep（）指线程被调用时，占着CPU不工作，形象的说明为“占着CPU”睡觉 。 sleep(2000)表示：占用CPU，程序休眠2秒。
wait(2000)表示：不占用CPU，程序等待2秒。
如何主动挂起程序 ctrl+z：挂起，程序放到后台，程序没有结束。
jobs：查看被挂起的程序工作号
恢复进程执行时，有两种选择：fg命令将挂起的作业放回到前台执行；用bg命令将挂起的作业放到后台执行
格式：fg 工作号；bg 工作号
总结 挂起状态一般不被放在进程的常用状态之一，常见的，”五大“状态里就没有挂起状态，但其实际上还是非常重要的，值得我们每一个人好好学习。
内核资料直通车：Linux内核源码技术学习路线+视频教程代码资料
学习直通车：Linux内核源码/内存调优/文件系统/进程管理/设备驱动/网络协议栈
原文作者：极致Linux内核
原文地址：Linux内核：进程管理——进程挂起管理 - 知乎（版权归原文作者所有，侵权留言联系删除）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60ad3ab8f5fc171b2b1f70156f679a88/" rel="bookmark">
			使用RecyclerView开发TabView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github链接
demo代码
效果图
这个功能是使用RecyclerView开发的，需要解决下面这些问题
单个item滚动的问题：左边的view需要固定、手指松开之后，惯性的处理滑动布局子View事件分发冲突的解决多个item联合滚动滚动header解决itemView与RecyclerView滑动冲突的问题横向滚动时，显示和隐藏滚动条 带着上面想到的问题，逐一写demo，最后再把编写的代码糅合在一起，完成tab view。
第1个问题还是比较复杂的，也是核心问题，所以必须最先解决。
由于我以前写过左滑显示删除按钮的功能，所以滑动部分马上就想到在LinearLayout的基础上开发。而固定的功能反而是最简单的，直接在外部套一个LinearLayout，然后写一个View在最左边就行。
简单提了一下思路，接下来是功能的开发。
单个滑动布局
先实现滑动的功能，这个是最简单的，先看一下图片。
代码：
这里10个TextView的代码我就不提供了，没什么好说的，直接提供GestureLayout的代码。
class GestureLayout @JvmOverloads constructor(context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : LinearLayout(context, attrs, defStyleAttr), View.OnTouchListener { private var scrollState = SCROLL_STATE_IDLE private var lastTouchX = 0 // 当前滑动的距离 private var scrollOffset = 0f // 最大可滑动的距离 private var maxScrollOffset = 0f // 大于这个值才可以滑动 private var touchSlop = 16 init { orientation = HORIZONTAL setOnTouchListener(this) } override fun onAttachedToWindow() { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60ad3ab8f5fc171b2b1f70156f679a88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/743092d0a0ef66755f093849ab5e1f98/" rel="bookmark">
			如何将GIS地图和可视化结合使用实现更好的数据呈现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GIS（地理信息系统）和可视化（visualization）是两个紧密相关的领域。GIS是一种用于管理、分析和展示地理空间数据的技术，而可视化则是一种用图形、图表、动画等形式展示数据的方式。GIS地图则是指基于地理信息系统技术，将各种地理数据在一个地图上进行展示的地图。
GIS地图和可视化是紧密相关的概念，因为GIS系统通常需要将地理数据以直观的方式呈现给用户。这就需要使用各种可视化技术，将抽象的地理信息转换为易于理解和使用的图形和图像。GIS和可视化可以结合起来，使得地理空间数据可以以更加直观、形象、生动的方式呈现出来。例如，在一个GIS应用中，可以利用可视化技术展示地图、气泡图、线条图、柱状图等等，以便更好地理解和分析数据。
GIS地图在数据可视化中具有广泛的应用，以山海鲸可视化软件中的GIS地图为例，如：
①通过将地理信息与其他数据结合，可以更加直观地展示数据分布、空间关系和趋势变化。
②通过在GIS地图上叠加人口分布数据，可以更加清晰地了解不同地区的人口密度和人口流动情况。
③GIS地图可以帮助企业更好地分析不同地区的资源分布情况，帮助决策者制定合理的资源分配方案。
④通过GIS地图，可以更加直观地展示城市的规划和交通情况，帮助政府决策者和城市规划师更好地进行规划和管理。
⑤将环境监测数据与GIS地图结合，可以更好地了解环境状况和资源保护情况，帮助决策者采取更加科学有效的环境保护措施。
GIS地图有以下优点：
①空间分析能力：GIS地图可以将不同的数据集集成到地图中进行空间分析，例如测量距离、面积和体积，计算空间关系等，能够帮助用户更好地理解和分析地理空间数据。
②数据可视化：GIS地图可以将各种地理空间数据以不同的形式进行可视化呈现，包括点、线、面、图表等，可以更清晰地展示数据分布、趋势和关系。
③数据共享：GIS地图可以将数据共享给用户，帮助他们更好地理解地理空间数据，并且可以提供可视化的数据呈现，使得数据更加直观和易于理解。
④空间决策支持：GIS地图可以为用户提供空间决策支持，帮助用户更好地理解和分析地理空间数据，制定更合理的决策。
⑤实时性：GIS地图可以将数据实时更新到地图中，保持数据的及时性和准确性，帮助用户更好地了解和应对地理空间变化。
总之，GIS地图在数据可视化中的应用非常广泛，可以帮助我们更好地理解数据，做出更加准确的决策。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0715d75923c319696e13e0cfbceb140a/" rel="bookmark">
			【Linux系统管理进程，运行，挂起，杀死进程和crontab计划任务表的使用以及实验的心得体会】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验 （1）显示本用户的进程，重定向到file1
top命令如果不加限制，默认是查看所有用户的进程情况top -u [用户名] 可以查看该用户名的所有进程 （2）显示本用户所有进程，重定向到file2
top命令如果不加限制，默认是查看所有用户的进程情况
top -u [用户名] 可以查看该用户名的所有进程
比如：我想查看我的python运行了哪些进程程序
在命令行敲入此命令：ps -ef |grep python
这样就可以查看到了当前python正在运行的程序，同理要查看其它的进程也是一样的 ps -ef |grep 进程名
结束进程的话直接 kill -9 进程id就可以了
（3）在后台运行nano命令
nano命令可以打开指定文件进行编辑，默认情况下它会自动断行，即在一行中输入过长的内容时自动拆分成几行，但用这种方式来处理某些文件可能会带来问题，比如Linux系统的配置文件，自动断行就会使本来只能写在一行上的内容折断成多行了，有可能造成系统不灵了。因此，如果你想避免这种情况出现，就加上-w选项吧。
按Ctrl+X
如果你修改了文件，下面会询问你是否需要保存修改。输入Y确认保存，输入N不保存，按Ctrl+C取消返回。如果输入了Y，下一步会让你输入想要保存的文件名。如果不需要修改文件名直接回车就行；若想要保存成别的名字（也就是另存为）则输入新名称然后确 定。这个时候也可用Ctrl+C来取消返回
（4）查看进程nano
LINUX暂停、挂起进程，开启进程：
先使用如下命令查看你需要暂停的进程：
ps -a
确定想要关闭的进程后，使用如下命令暂停、挂起进程：
kill -stop 进程号
如果你想开启上面挂起的进行，并放在后台运行：
kill -cont 进程号
（5）杀死进程nano
（6）再次查看进程nano,看看是否被杀死
LINUX暂停、挂起进程，开启进程：
先使用如下命令查看你需要暂停的进程：
ps -a
确定想要关闭的进程后，使用如下命令暂停、挂起进程：
kill -stop 进程号
如果你想开启上面挂起的进行，并放在后台运行：
kill -cont 进程号
ps -l
列出与本次登录有关的进程信息；
ps -aux
查询内存中进程信息；
ps -aux | grep ***
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0715d75923c319696e13e0cfbceb140a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29927bd5d2afe0cb17d2ff74656a200e/" rel="bookmark">
			Navicat Premium v16.2 大有不同 | 一个工具将轻松搞定Mysql&#43;Redis等混合部署的管理开发需求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Navicat v16.2 大有不同 | 计划于 2023 年上半年发布 | 新增 Redis 功能
Navicat v16.2 连接界面 | 先睹为快
近期，我们发布了一项有关于《除 Redis 外，贵司还部署了哪些数据库？》的调查，从投票结果中我们发现：仅有5%的用户选择了企业单一Redis数据库部署的环境；而 95% 的用户选择了多种数据库的混合部署场景。混合部署与企业越发复杂的数据生产环境密不可分，它可以有效地节约和优化企业内部资源，从而避免系统资源的浪费，最终帮助企业实现增效降本。
在混合部署的条件下，从 Navicat 目前所支持的数据库产品来看，排名依次为：32% MySQL、14% PostgreSQL、12% MongoDB、10% Oracle、10% SQL Server，其他几款数据库（MariaDB、SQLite 和 OceanBase）投票数相对较少。
其实，早在 2002 年我们首发 Navicat for MySQL 产品，用于管理开发 MySQL。产品距今已经历了 20 余年的更新与迭代。产品力也受到广大用户的认可。目前，Navicat 不仅支持绝大多数主流的关系型数据库( MySQL、MariaDB、Oracle、SQLserver、PostgreSQL、SQLite、OceanBase )，还支持 NoSQL 数据库（MongoDB、Redis-计划2023年上半年发布）。Navicat 最畅销产品之一- Navicat Premium 可支持单一应用程序同时连接以上多种关系型和非关系型数据库，极大地满足企业多数据库混合部署的管理开发需求。同时，它还支持与阿里云、腾讯云、华为云、Amazon 等云数据库兼容。
随着市面上数据库产品的不断增多，企业多数据库混合部署的情况将越发普及。Redis 作为目前最火爆的内存数据库之一，可通过在内存中读写数据很大程度上提高了读写速度，可以说 Redis 是实现网站高并发不可或缺的一部分。在不久的某一天，Navicat 数据库管理开发工具可以帮助提升 Redis 应用开发人员、DBA 的项目管理开发时间，满足更多混合部署场景的管理开发需求，有效地帮助企业实现降本增效。如果你还没体验过 Navicat Premium, 欢迎点击 这里 下载免费的14天全功能试用版。
往期回顾 Navicat 荣获 Microsoft 金牌合作伙伴Navicat 16 正式支持 OceanBase 全线数据库产品免费试用 Navicat 16Navicat 的 20年发展史SQL 语句中 WHERE 1=1 的作用SQL 中计算总行数的百分比互动有礼活动进行中 | 奖品为价值 819 元 Navicat Premium假冒网站引发多重安全风险 | 官方严正声明：切勿在非官方渠道购买或下载 Navicat 软件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f970900ecbc5f8d4c1752e952f374667/" rel="bookmark">
			兔子生兔子问题（java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问第n个月的兔子对数为多少?
分析：第一个月是1对
第二个月是1对
第三个月是1+1=2对
第四个月是2+1=3对
第五个月是3+2=5对
第六个月是5+3=8对
第七个月是8+5=13对
典型的斐波那契数列
方法一：循环实现
public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int f1 = 1,f2 = 1,f3=0; for (int i = 3; i &lt;= n ; i++) { f3 = f1 + f2; f1 = f2; f2 = f3; } System.out.println(f3) ; } } 运行结果:
-------------------------------下面补充几种斐波那契数列的解法------------------------------------------------
方法二：数组实现（使用了动态规划的思想）
class Solution { public int fib(int n) { if (n &lt;= 1) return n; int[] dp = new int[n + 1]; dp[0] = 0; dp[1] = 1; for (int index = 2; index &lt;= n; index++){ dp[index] = dp[index - 1] + dp[index - 2]; } return dp[n]; } } 方法三：递归实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f970900ecbc5f8d4c1752e952f374667/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a383a868952f5c20d2837c77211f7ea2/" rel="bookmark">
			CANoe仿真报文无法持续外发的解决办法（OSEKNMO1库引起）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CANoe仿真报文无法持续外发的解决办法（OSEKNMO1库引起） 背景
在仿真节点报文的过程中，按照平时仿真的办法来根据DBC节点仿真外发报文，按道理说，当我们启动工程就能够正常持续发送默认报文，信号值为DBC的初始化默认值，但在最近我仿真的过程中发现仿真过程中，发送一段时间后就停止发送了，这不是我想要的结果，于是就开始找问题原因了，于是就有了解决办法这一说法了。
问题描述
创建好工程之后，配置好所有的仿真节点，当点击start的时候，刚开始正常外发报文，过一段时间就停止发送报文，重复几次，都是这样的现象。
原因
经过排查，发现是因为一个OSEKNMO1库影响的，具体为什么，我也不从得知。
解决办法
修改DBC相关属性操作要点 查看Network Node的属性，右键节点，选择Configuration，选择Components，看看自己的节点有哪些dll，如下图所示：
打开DBC文件按照以下方式进入修改界面
删除Nm开头的这些属性，至少要删除下图所标注出来的这些（包括最后一栏删除OSEKNMO1.dll）
修改完成后，再次重新导入DBC文件，重新配置节点信息即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d039bc79f3ac70837cf93cf827c50562/" rel="bookmark">
			clickhouse批量插入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按照如下模板进行插入：
INSERT INTO 数据库.数据表 (列1,列2,列3) VALUES (列1的新数据, 列2的新数据, 列3的新数据), (列1的新数据, 列2的新数据, 列3的新数据), (列1的新数据, 列2的新数据, 列3的新数据), 完整示例 首先新建一个数据库test：
CREATE DATABASE test 再新建一个just_check的数据表
CREATE TABLE test.`just_check` ( `code` String, `name` String, `dt` Date, ) ENGINE = MergeTree() ORDER BY (dt) PRIMARY KEY (dt) SETTINGS index_granularity=8192; 尝试插入一个数据：
INSERT INTO test.just_check (code,name,dt) VALUES ('a1','a2', toDateTime('2023-01-01')) 时间格式可以参考：https://clickhouse.com/docs/zh/sql-reference/functions/date-time-functions
木有问题，尝试插入多个数据：
INSERT INTO test.just_check (code,name,dt) VALUES ('b1','b2', toDateTime('2023-01-02')), ('c1','c2', toDateTime('2023-01-03')), ('d1','d2', toDateTime('2023-01-04')) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680ec92b284f91c4bb91f54f71427293/" rel="bookmark">
			发送Ajax请求时，页面没有发生响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常记录，给一个按钮添加单击事件发送Ajax请求时，页面却没有即时的刷新，打开开发者工具查看，网络面板(Network Panel)在点击按钮后很快地显示Ajax请求，但是又很快消失了，这很可能是因为您的Ajax请求在发送后立即被取消了。
在某些情况下，例如当您使用button标签作为Ajax请求的触发器时，当您单击按钮时，浏览器可能会执行默认的提交操作，并立即跳转到另一个页面，从而导致您的Ajax请求被取消。这种情况可以通过在单击事件处理程序中调用preventDefault()方法来防止发生。例如，以下代码演示了如何使用jQuery在单击按钮时发送Ajax请求并防止默认操作：
$('button').click(function(event) { event.preventDefault(); // 防止默认操作 $.ajax({ url: '/your-url', type: 'POST', dataType: 'json', data: yourData, success: function(result) { // 处理返回结果 }, error: function(xhr, textStatus, errorThrown) { // 处理错误 } }); }); 请注意，这只是一个示例，并且实际实现可能会因您的具体要求而有所不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58bd533b27e54a8e6a29fc4fe868c850/" rel="bookmark">
			redis缓存的三大问题以及解决方法！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏前言
本专栏开启，目的在于帮助大家更好的掌握学习Redis，同时也是为了记录我自己学习Redis的过程，将会从基础的数据类型开始记录，直到一些更多的应用，如缓存击穿还有分布式锁以及Redis持久化等。希望大家有问题也可以一起沟通，欢迎一起学习，对于专栏内容有错还望您可以及时指点，非常感谢大家 。
1.缓存的三大问题
话说学习缓存，缓存雪崩、击穿、穿透肯定是绕不开的一个话题，不仅在开发中我们需要注意这个问题，在面试中更是面试官有关Redis必问的面试题，可以说我们对这三个场景我们必须了解其中的差异，以及各自的解决方案。
2.缓存雪崩
2.1 什么是缓存雪崩？
缓存雪崩指的是在同一时间，大量的Key同时失效，导致大量的请求直接绕开了我们的Redis直接打到数据库，数据库一下顶不住直接挂彩了，这就是缓存雪崩的场景。
那有的人肯定好奇，咦？怎么会那么巧大量的Key同时失效，考虑一个秒杀场景，比如双十一的时候，我们在晚上十一点集中上架一批商品，此时缓存过期时间设置为一小时，那么一到十二点这批商品的缓存就全部过期了，如果此时成千上万的用户想购买这些商品发送大量请求，就会导致数据库的压力上升从而可能压垮数据库。
同一时间大量 Key 失效，就会导致Redis直接如同隐身了一样，那对于双十一这种数以千万级别甚至上亿量级的请求来到数据库，那后果就是灾难性的。一旦你一个库被打倒，那么其他的库可能也会收到影响，导致瞬间都挂掉了。你一重启用户又把你干崩，等你真正修好的时候，可能用户早就睡着了，还在心里吐槽一句什么垃圾产品。
当然，如果Redis宕机了，那么显然也会触发缓存雪崩的情况。
2.如何解决缓存雪崩？
讨论完了案发场景，那我们该如何解决缓存雪崩了。
过期时间添加随机值。
那就对症下药嘛，既然你是大量的key同时过期导致的，那我就尽量让你不一起过期，所以我们在批量添加缓存的时候，可以给过期时间添加一个随机值，使得Key过期的时间尽量分散，这样保证缓存不会大面积的同时失效。
进行集群部署
集群部署的情况下，我们就无须担心某一台Redis宕机导致触发缓存雪崩，也可以将热点数据均匀分布在不同Redis库中，来避免全部失效的问题。
热点数据永不过期
我们也可以让热点数据永不过期，只进行更新的操作，这也可以避免缓存雪崩。但可能会带来数据不一致的问题。
3.缓存穿透
3.1 什么是缓存穿透？
缓存穿透指的是对于一些缓存和数据库中都不存在的数据，而用户却不断对该数据进行请求，如果你的数据库甚至没有建立索引，那么数据库还会进行全表扫描，压力更大。每次数据库都需要去进行查，然后查不到，然后又继续查，然后又查不到，然后又…最终数据库卒，这就是缓存穿透。
此时显然用户是一个攻击者，比如我们数据库id都是从1开始自增的，它可以故意访问一个负数的id，然后不断请求，如果是我们个人搭建的一些小网站，对这种行为没有预防，只需要用 postman 就可以干崩你的网站。
3.2 如何解决缓存穿透?
我们考虑如何去解决缓存穿透问题。
参数校验
在场景中我们已经提及，对于一些非法的参数我们一定要进行校验，不合法的参数直接进行返回，比如一些负数的id，还有用户的鉴权校验。参数校验的思想我们一定要根深蒂固，在任何地方都不应该相信前端传来的参数，我们都应当手动判断其是否合法。
缓存空值
对于一些不存在的对象，我们也可以将其作为key缓存，value设置null，这样用户再次访问时就不会走数据库查询了。当然需要注意的是我们这个key的过期时间我们需要设置短一些。
@Component
public class CacheNullValue {
private static final int CACHE_EXPIRATION = 60; // 缓存过期时间，单位为秒
@Autowired
private StringRedisTemplate stringRedisTemplate;
//@NotBlank对参数进行校验
public String getData(@NotBlank String key) {
String data = stringRedisTemplate.opsForValue().get(key);
if (data == null) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58bd533b27e54a8e6a29fc4fe868c850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a36cf51ac06c8601fe265c69acd3a7/" rel="bookmark">
			如何把开发的javaweb程序让用户在网上访问使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要将Java Web应用部署到云服务器上，才能让用户通过互联网访问该应用。
以下是详细的步骤：
购买云服务器：在阿里云、腾讯云、AWS等云服务提供商中选择自己需要的云服务器，根据服务器需求选择配置，购买云服务器。
配置环境：登录云服务器，安装配置Java环境，例如将Java JDK下载到服务器中，并配置系统环境变量。
部署Web应用：将Web应用打成war包，上传到服务器，解压war包，将解压后的文件放到Tomcat服务器的webapps目录下，启动Tomcat服务器。
配置域名和端口：在云服务器上的Tomcat中，配置自己的域名和端口，例如设置为http://www.example.com:8080。
配置安全组和防火墙：为云服务器配置安全组和防火墙，保障服务器的网络安全。
访问应用：检查Tomcat服务是否启动成功，然后通过域名和端口号访问应用，例如http://www.example.com:8080/。
以上是将Java Web应用部署到云服务器上的详细步骤，需要注意的是，在部署过程中可能会出现各种问题，请仔细检查其中的每一步骤，以保证Web应用能够正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac850909fe5a72f10f0d3cc988557c4/" rel="bookmark">
			SpringBoot集成WebSocket进行前后端通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： SpringBoot集成WebSocket进行前后端通信
实现步骤： 1.引入Maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 2.配置WebSocket 创建配置类启用WebSocket支持,用@Configuration和@Bean纳入spring
package com.test.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.server.standard.ServerEndpointExporter; @Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 3.核心业务代码 因为WebSocket是类似客户端服务端的形式(采用ws协议)，那么这里的WebSocketServer其实就相当于一个ws协议的Controller
package com.test.service; import java.io.IOException; import java.util.concurrent.CopyOnWriteArraySet; import javax.websocket.OnClose; import javax.websocket.OnError; import javax.websocket.OnMessage; import javax.websocket.OnOpen; import javax.websocket.Session; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import org.springframework.stereotype.Component; import org.springframework.stereotype.Service; import lombok.extern.slf4j.Slf4j; /** * @ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端, * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端 */ @Component @Slf4j @Service @ServerEndpoint("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dac850909fe5a72f10f0d3cc988557c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e349248105df3672e2136f446b47d015/" rel="bookmark">
			Webots调用MATLAB引擎进行数据处理和绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Webots是一个很强大的机器人仿真软件，可以仿真各类机器人，美中不足的是利用Ｗebots仿真的过程中无法绘制机器人的运动轨迹等类似的需要展示的数据，怎么办 ？ 这里介绍一种 利用webots 调用matlab 引擎进行数据处理和绘图的方法。
目录 配置 webots 文件在webots里面编写调用 matalb的程序仿真结果 正文 配置 webots 文件
请参考第一个链接在webots里面编写调用 matalb的程序、
step1: 必须添加此文件：
#include “engine.h”
step2: 定义一个中间矩阵：
然后在主函数里面打开matlab 引擎，定义一个链接C语言和matlab 语言的矩阵 mxArray。
step3: 数据传递和绘图：
GPS_P 是一个指针变量，已经在C语言程序中定义过了，这里拿过来导入到matlab中进行作图。实现了C语言到matlab的单向数据传递以及图形绘制。 5. 仿真结果
相关参考和链接： 1.添加链接描述
2.添加链接描述
3.添加链接描述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f0ab6c253fc5d68272f1f3653aa086/" rel="bookmark">
			解决HttpURLConnection GET封装请求体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		广义上get没有请求体，但在实际开发中可能会遇到get请求封装请求体的需求。这里我们要解决的是使用 HttpURLConnection 封装get请求body时，源码中get请求封装请求体会转为post请求。
源码如下：
//HttpURLConnection private synchronized OutputStream getOutputStream0() throws IOException { try { if (!this.doOutput) { throw new ProtocolException("cannot write to a URLConnection if doOutput=false - call setDoOutput(true)"); } else { if (this.method.equals("GET")) { this.method = "POST"; //注意这里 } if ("TRACE".equals(this.method) &amp;&amp; "http".equals(this.url.getProtocol())) { throw new ProtocolException("HTTP method TRACE doesn't support output"); } else if (this.inputStream != null) { throw new ProtocolException("Cannot write output after reading input."); } else { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80f0ab6c253fc5d68272f1f3653aa086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd5edda0289effddcf25eb82793419f0/" rel="bookmark">
			java自定义实现阻塞队列和线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不多BB，直接上代码。
阻塞队列：
public class BlockingQueue&lt;T&gt;{ // 1.任务队列, 双向队列 private Deque&lt;T&gt; queue = new ArrayDeque&lt;&gt;(); // 2.锁 private ReentrantLock lock = new ReentrantLock(); // 3.生产者条件变量 private Condition fullWaitSet = lock.newCondition(); // 4.消费者条件变量 private Condition emptyWaitSet = lock.newCondition(); // 5.容量 private int capacity; public BlockingQueue(int capacity) { this.capacity = capacity; } // 超时阻塞获取任务 public T pull(long timeout, TimeUnit unit){ lock.lock(); try{ // 将超时时间统一转换为纳秒 long nanos = unit.toNanos(timeout); // 取任务的时候，如果为空则需要等待 while(queue.isEmpty()){ // 超时的情况直接返回null if(nanos &lt;= 0){ return null; } // 返回的是剩余的时间 nanos = emptyWaitSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd5edda0289effddcf25eb82793419f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f3faf46b8e769a7c66803475a2c9797/" rel="bookmark">
			小米电视无法访问 SAMBA 4.15.13 共享文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小米电视无法访问 SAMBA 4.15.13 共享文件 小米电视无法访问 SAMBA 4.15.13 共享文件故障表现分析研究成功 小米电视无法访问 SAMBA 4.15.13 共享文件 作者：高玉涵
时间：2023-4-8 21:00
环境：Linux version 5.19.0-35-generic (buildd@lcy02-amd64-020) (x86_64-linux-gnu-gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #36~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Feb 17 15:17:25 UTC 2
故障表现 家里自建的 NAS 采用的是 Ubuntu 系统，之前一直正常使用。因，许久没有更新，今天 upgrade 后 Samba 自动升级版本至 Version 4.15.13 再次连接一直失败（图 1-1）。
分析研究 通过查找资料得知 Linux Samba 服务默认使用协议 &gt; SMB2.0，小米电视（我的）只能使用版本较低的 SMB 1.0 协议。查看 smb.conf 配置文档找到配置项 server min protocol （图 1-2）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f3faf46b8e769a7c66803475a2c9797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c408fb5441c5d298ddb79084bce320/" rel="bookmark">
			Java 内存区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM介绍：
1） JVM学习总结，全面介绍运行时数据区域、各类垃圾收集器的原理使用、内存分配回收策略
2） JVM学习总结，虚拟机性能监控、故障处理工具：jps、jstat、jinfo、jmap、Visual VM、jstack等
文章目录 前言一、Java运行时数据区1. 程序计数器（Program Counter Register）2. 虚拟机栈（VM Stack）3. 本地方法栈（Native Method Stacks）4. 堆（Heap）5. 方法区（Method Area）6. 运行时常量池（Runtime Constant Pool） 二、虚拟机中的对象1. 对象的创建（普通Java对象）2. 对象的内存布局3. 对象的访问定位 前言 内容参考自《深入理解Java虚拟机 JVM高级特性与最佳实践》第三版第一章，供自己学习做笔记使用。
一、Java运行时数据区 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域有各自的用途，根据《Java虚拟机规范的规定》，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：
1. 程序计数器（Program Counter Register） 程序计数器是一块较小的内存空间，他可以看作是当前线程所执行字节码的行号指示器。在Java虚拟机的概念模型中，字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
2. 虚拟机栈（VM Stack） 虚拟机栈的生命周期与线程相同，虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应一个栈帧在虚拟机中从入栈到出栈的过程。
局部变量表中存放了编译期可知的各种Java虚拟机基本数据类型（byte、short、char、int、long、float、double、boolean）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他榆次对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。
局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间是不会改变局部变量表的大小的。在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，则会抛出StackOverflowError异常；如果Java虚拟机支持动态扩展，当栈无法扩展时无法申请到足够的内存空间时则会OutOfMemoryError异常。
3. 本地方法栈（Native Method Stacks） 本地方法栈与虚拟机栈的作用基本上是一致的，区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。对应本地方法栈的实现，《Java虚拟机规范》中并未强制规定，由虚拟机自己根据需求实现，有的Java虚拟机例如Hot-Spot虚拟机就直接将本地方法栈和虚拟机栈合二为一。与虚拟机栈相同的是，本地方法栈也会出现两类异常状况。
4. 堆（Heap） 对于Java应用程序来说，Java堆（Heap）是虚拟机所管理的内存中最大的一块区域，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存存在的唯一目的就是存放对象实例，几乎所有的对象实例都在堆上分配空间、存放。
5. 方法区（Method Area） 方法区与Java堆一样，是各个线程共享的内存区域，它用于存放已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
6. 运行时常量池（Runtime Constant Pool） 运行时常量池（Runtime Constant Pool）是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Tabel），用于存放编译器内生成的各种字面量与符号引用，这部分内容将在内加载后存放到方法区的运行时常量池中。
二、虚拟机中的对象 1. 对象的创建（普通Java对象） 2. 对象的内存布局 在HotSpot 虚拟机中，对象在堆内存中的存储布局可以分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c408fb5441c5d298ddb79084bce320/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/52/">«</a>
	<span class="pagination__item pagination__item--current">53/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/54/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>