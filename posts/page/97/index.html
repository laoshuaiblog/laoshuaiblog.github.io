<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/039ceeb25d95191dff412da680094fac/" rel="bookmark">
			fanuc换刀宏程序详解_FANUC宏程序入门到精通，新手必看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数控加工领域，随着CAM软件的普及，对手工编程的要求有所降低。但这个现象在数控车床的加工中并不明显，对于有些异形零件的加工，CAM软件是不能胜任的。特别是异形螺杆的加工，用CAM软件几乎无法入手，而普通的G代码也很难做到，这时我们要用
用户宏程序概念
在一般的程序编制中程序字为常量，一个程序只能描述一个几何形状，当工件形状没有发生改变但是尺寸发生改变时，也只能重新编程，灵活性和适应性差。另外，在编制如椭圆等没有插补指令的公式曲线加工程序时，需要逐点算出曲线上的点，然后用直线或圆弧段逼近，如果零件表面粗糙度要求很高则需要计算很多点，程序庞大且不利于修改。利用数控系统提供的宏程序功能，当所要加工的零件形状不变，只是尺寸发生了一定变化的情况时，只需要在程序中给要发生变化的尺寸加上几个变量和必要的计算公式，当加工的是椭圆等非圆曲线时，只需要在程序中利用数学关系来表达曲线，然后实际加工时，尺寸一旦发生变化，只要改变这几个变量的赋值参数就可以了。这种具有变量，并利用对变量的赋值和表达式来进行对程序编辑的程序叫宏程序。数控系统提供的宏程序称为系统宏程序，用户不能修改，只能使用，如循环指令G70、G81等。用户自行编制的宏程序称为用户宏程序，可以修改、存储等。平常说的宏程序就是指用户宏程序。
宏程序的基本特征
(1) 使用变量
(2) 可对变量赋值
(3) 变量间可进行演算
(4) 程序运行可以跳转
宏程序与子程序之间有相同之处，也有不同之处。相同之处，宏程序和子程序一样，都是存入存储器中，然后用一个总指令代表它们，使用时只需给出这个总指令就能执行该功能，宏程序和子程序的调用完全一样。不同之处是宏程序在调用指令中可对变量进行赋值。
宏程序的优点
(1) 长远性
(2) 共享性
(3) 多功能性
(4) 简练性与智能性
编制宏程序的基本要求
(1) 数学基础知识
(2) 计算机编程基础知识
(3) 一定的英语基础
(4) 耐心与毅力
FANUC用户宏程序的分类
FANUC用户宏程序功能分A、B两类，在功能上差异并不大，但在编程和分析判读方面，B类宏程序要比A类宏程序清晰容易得多。A类宏程序使用的是G65 Hm指令，指令格式长而含义表达模糊，B类宏程序使用的是高级语言编程，表达式简单明了而且含义清晰。
例如，要表达#101=#102+#103:
A类宏程序为：G64 H02 P#101 Q#102 R#103 ; (“G65 H02”代表加法运算 )
B类宏程序为： #101=#102+#103 ；
在用户宏程序发展初期，A类宏程序用于车床数控系统较多，B类宏程序用于铣床和加工中心数控系统较多，而现在绝大多数FANUC车床系统中都应用了B类宏程序，使宏程序的编制得到了简化。
宏程序可以较大地简化编程，扩展应用范围。宏程序适合图形类似只是尺寸不同的系列零件的编程；适合刀具轨迹相同只是位置参数不同的系列零件的编程；也适合抛物线、椭圆、双曲线等没有插补指令的曲线编程。为了让大家更清晰的学习宏程序，我们开发了一套宏程序入门课程，建议大家去聚匠云平台学习《FANUC宏程序入门到精通》这门课，会很容易上手，轻松get宏程序编程技巧~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c26c8e493b844d41d5eb3374aa9e9e8/" rel="bookmark">
			1恢复 群晖raid_关于RAID1阵列数据丢失的恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．RAID控制器出现物理故障
RAID控制器如果出现物理故障，将不能被计算机识别，也就无法完成对RAID-1中各个物理成员盘的控制，在这种情况下，通过RAID控制器虚拟出来的逻辑盘自然就不存在了。
2．RAID信息出错
对于硬RAID-1来说，RAID控制器将物理盘配置为RAID-1后，会记录有关该RAID-1的相关信息，包括组成该RAID-1的物理盘数目、物理盘的容量大小、哪块物理盘为工作磁盘、哪块物理盘为镜像磁盘、RAID-1在每块物理盘中的起始地址等，所有这些信息被称为RAID信息，也称为RAID元数据，它们会被保存到RAID控制器中，有时候也会保存到RAID-1的成员盘中。
磁盘阵列raid1知识及数据恢复讲解
对于软RAID-1来说，同样具有上面提到的RAID信息，这些信息一般都存放在RAID-1的成员盘中。
RAID信息出错就是指该RAID-1的配置信息出现错误，导致RAID程序不能正确地组织管理RAID-1中的成员盘，从而导致RAID-1逻辑盘丢失或不能访问。
3．RAID-1成员盘出现物理故障
RAID-1可以允许其中一块成员盘离线，如果RAID-1中的某一块成员盘出现物理故障，比如电路损坏、磁头损坏、固件损坏、出现坏扇区等，该成员盘就不能正常使用，但剩下的一块成员盘中的数据完好无损，RAID-1还不会崩溃。
如果系统管理员没有及时替换出现故障的成员盘，当另一块成员盘再出现故障离线后，RAID-1将彻底崩溃。
4．人为误操作
如果误将RAID-1中的两块成员盘都拔出，或不小心删除了RAID-1的配置信息等，都会造成RAID-1崩溃。
RAID-1数据恢复思路
RAID-1是所有RAID中最简单的一种，以图中的RAID-1结构为例，从图中可以看出，RAID-1中两块硬盘互为镜像，所有数据都是完全一样的，如果是RAID控制器故障或RAID信息出错导致RAID-1的数据无法访问，只要将两块物理盘中的一块从服务器上拆下来，作为单独的硬盘接在一台计算机上，就很容易将数据恢复出来。
经过上述资料收集。总结了简单恢复思路，恢复必须具备以下条件。
1.置换的硬盘应该是同型号同系列同容量的硬盘
2.硬盘是全新硬盘或者是未分区未格式化的硬盘
3.硬盘需要插回原RAID通道。
4.有些软阵列需要进入WINDOWS系统才会自动进行同步RAID1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e699dc8dc0d6811d9ce0f7d202c7376/" rel="bookmark">
			git 如何返回上一步操作_转！！git如何撤销上一次commit(或已push)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原博文地址 ： https://www.cnblogs.com/lyy-2016/p/6509707.html
git如何撤销上一次commit操作
1.第一种情况：还没有push，只是在本地commit
git reset --soft|--mixed|--hard git push develop develop --force (本地分支和远程分支都是 develop)
这里的就是每次commit的SHA-1，可以在log里查看到
--mixed 会保留源码,只是将git commit和index 信息回退到了某个版本.
--soft 保留源码,只回退到commit信息到某个版本.不涉及index的回退,如果还需要提交,直接commit即可.
--hard 源码也会回退到某个版本,commit和index 都会回退到某个版本.(注意,这种方式是改变本地代码仓库源码)
当然有人在push代码以后,也使用 reset --hard 回退代码到某个版本之前,但是这样会有一个问题,你线上的代码没有变,线上commit,index都没有变,当你把本地代码修改完提交的时候你会发现全是冲突.....这时换下一种
2.commit push 代码已经更新到远程仓库
对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令
git revert revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新。
注意：git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit，看似达到的效果是一样的,其实完全不同。
第一:上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会.
第二:如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里.
第三:reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d8e0080fb2acac3c09be872bd341a00/" rel="bookmark">
			uniapp之uni.navigateBack返回携带参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码
let pages = getCurrentPages(); //获取所有页面栈实例列表 let nowPage = pages[pages.length - 1]; //当前页页面实例 let prevPage = pages[pages.length - 2]; //上一页页面实例 prevPage.$vm.tagIndex = this.index; //修改上一页data里面的tagIndex 参数值 uni.navigateBack({ //uni.navigateTo跳转的返回，默认1为返回上一级 delta: 1 }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202e733c881411e83265dd97616b0aa0/" rel="bookmark">
			java多线程基础高级篇（详解下）面试必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java多线程基础高级篇（详解下）面试必备 1、容器1.1、容器类关系图1.2、HashMap实现分析1.2.1、JDK1.8之前并发问题1.2.2、JDK1.8并发问题 1.3、HashMap并发问题解决方案 2、同步容器2.1、同步容器介绍2.2、HashTable 3、并发容器3.1、并发容器简介3.2、ConcurrentHashMap数据结构3.2.1、Java7基于分段的数据结构3.2.2、Java8基于CAS的数据结构 3.3、ConcurrentHashMap同步原理3.3.1、Java7同步实现分析3.3.2、Java8同步实现分析 4、线程池4.1、为什么使用线程池4.2、ThreadPoolExecutor的全参构造函数参数介绍4.3、四种常用线程池4.3.1、newCachedThreadPool4.3.2、newFixedThreadPool4.3.3、newSingleThreadExecutor4.3.4、newScheduleThreadPool 1、容器 1.1、容器类关系图 Collection 接口的接口 对象的集合
├ List 子接口 按进入先后有序保存 可重复
│├ LinkedList 接口实现类 链表 插入删除 没有同步 线程不安全
│├ ArrayList 接口实现类 数组 随机访问 没有同步 线程不安全
│└ Vector 接口实现类 数组 同步 线程安全
│ └ Stack
└ Set 子接口 不可重复
├ HashSet
│ └ LinkedHashSet
└ TreeSet
Map 接口 键值对的集合
├ Hashtable 接口实现类 同步 线程安全
├ HashMap 接口实现类 没有同步 线程不安全
│├ LinkedHashMap
│└ WeakHashMap
└ TreeMap
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/202e733c881411e83265dd97616b0aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f5540cb10e73ac54c32395a8e731d8/" rel="bookmark">
			java多线程基础高级篇（详解上）面试必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java多线程高级篇（详解） 1、Java内存模型1.1.Java程序执行流程回顾1.2、Java内存模型 2、多线程特性3、多线程控制类3.1、ThreadLocal3.2、原子类3.2.1、非原子性操作问题演示3.2.2、原子类解决非原子性操作问题3.2.3、原子类CAS原理分析3.2.4、CAS的ABA问题及解决 3.3、Lock类3.3.1.Lock接口关系图3.3.2、可重入锁3.3.3、读写锁 3.4、Volatile关键字3.4.1、应用场景 1、Java内存模型 Java内存模型是每个java程序员必须掌握理解的，这是Java的核心基础，对我们编写代码特别是并发编程时有很大帮助。由于Java程序是交由JVM执行的，所以我们在谈Java内存区域划分的时候事实上是指JVM内存区域划分。
1.1.Java程序执行流程回顾 如图所示
首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，
然后由JVM中的类加载器加载各个类的字节码文件，
加载完毕之后，交由JVM执行引擎执行。
Java内存模型指的就是Runtime Data Area（运行时数据区），即程序执行期间用到的数据和相关信息保存区。
1.2、Java内存模型 根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。结构如下图：
PC程序计数器：
每个线程对应有一个程序计数器。各线程的程序计数器是线程私有的，互不影响，是线程安全的。程序计数器记录线程正在执行的内存地址，以便被中断线程恢复执行时再次按照中断时的指令地址继续执行 Java栈JavaStack（虚拟机栈JVM Stack）：
每个线程会对应一个Java栈；每个Java栈由若干栈帧组成；每个方法对应一个栈帧；栈帧在方法运行时，创建并入栈；方法执行完，该栈帧弹出栈帧中的元素作为该方法返回值，该栈帧被清除；栈顶的栈帧叫活动栈，表示当前执行的方法，才可以被CPU执行；线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；栈扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常； 方法区MethodArea
方法区是Java堆的永久区（PermanetGeneration）方法区存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，方法区是被Java线程共享的方法区要使用的内存超过其允许的大小时，会抛出OutOfMemoryError: PremGen space的错误信息。 常量池ConstantPool:
常量池是方法区的一部分。常量池中存储两类数据：字面量和引用量。
字面量：字符串、final变量等。
引用量：类/接口、方法和字段的名称和描述符，常量池在编译期间就被确定，并保存在已编译的.class文件中 本地方法栈Native Method Stack:
本地方法栈和Java栈所发挥的作用非常相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行Native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。 Java内存模型工作示意图
首先类加载器将Java代码加载到方法区然后执行引擎从方法区找到main方法为方法创建栈帧放入方法栈，同时创建该栈帧的程序计数器执行引擎请求CPU执行该方法CPU将方法栈数据加载到工作内存（寄存器和高速缓存），执行该方法CPU执行完之后将执行结果从工作内存同步到主内存 线程计算的时候，原始的数据来自内存，在计算过程中，有些数据可能被频繁读取，这些数据被存储在寄存器和高速缓存中，当线程计算完后，这些缓存的数据在适当的时候应该写回内存。
当个多个线程同时读写某个内存数据时，就会产生多线程并发问题，要解决这些问题就涉及到多线程编程三个特性：原子性，有序性，可见性。
2、多线程特性 多线程编程要保证满足三个特性：原子性、可见性、有序性。
原子性
原子性，即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
可见性
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。显然，对于单线程来说，可见性问题是不存在的。
有序性
有序性即程序执行的顺序按照代码的先后顺序执行
3、多线程控制类 为了保证多线程的三个特性，Java引入了很多线程控制机制，下面介绍其中常用的几种：
ThreadLocal原子类Lock类Volatile关键字 3.1、ThreadLocal 作用
ThreadLocal提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。
当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal，比如数据库连接Connection，每个请求处理线程都需要，但又不相互影响，就是用ThreadLocal实现。
示例
两个线程分别转账
package com.liuchunming.ThreadLocal; import java.lang.annotation.Target; /** * @author liuchunming * @site www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47f5540cb10e73ac54c32395a8e731d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eeae14079e06ad32803778e95eed54e/" rel="bookmark">
			【进阶】三种&#34; 堆栈溢出检测 &#34;方法，请拿去吹牛！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、聊一聊
分享一首非常洒脱自在的歌曲！
本文主要是跟大家分享三种堆栈溢出检测的方法，也算是接着之前分享的堆栈溢出分析的续篇。
2、正文部分
在阅读本文前建议大伙阅读往期文章 : ☞ 【进阶】" 堆栈溢出 "，也就这么回事！
1
堆栈溢出检测 堆栈溢出并不可怕，因为有部分堆栈溢出并不会造成什么影响，比如说局部数组导致堆栈溢出，却又没有篡改溢出部分内存，又或者篡改了相关数据却不会立马让程序奔溃，问题就悄无声息的隐藏着。
所以堆栈溢出有时候是非常让人抓狂的，经常会导致一些奇奇怪怪的问题，对于一般的程序员感觉把任务的堆栈加大了似乎问题就不再复现了，从而暗自欣喜，其实仅仅是bug移动了一个位置罢了，然而拿到客户现场没跑个几天就宕机了。
2
堆栈溢出与数组越界 大家用更加抽象的思维去看待这个问题，堆栈溢出和数据越界或许就区别不大了，其本质上都是超出了数据原本的定义范围，造成程序中重要数据被篡改而引发的问题。
前一篇文章跟大家介绍了堆栈用来干什么、一些什么情况会造成堆栈溢出、以及为了避免堆栈溢出我们如何确定合适的堆栈大小。然而这些还远远不够，仍然有非常多种情况堆栈的实际使用大小是未知的，比如使用可变参数函数，递归算法的处理等等，所以为了能够让所编写的嵌入式软件更加的强大和健壮，那么程序里面有相应机制进行堆栈的溢出检测就变得非常有必要了！
数据越界我们可以通过assert断言来提前检测其数组下标是否超出范围，而对于堆栈的分配和使用却没有这样一个清晰可控的过程，特别是在C环境下进行编码，一般都由C编译器帮我们处理好了，程序员无法直接触及到该过程。
既然正面比较难捕获该异常，那就只能通过间接手段检测，无论做什么事情，必然会留下线索，堆栈溢出也一样。
3
堆栈溢出检测三大法宝
1
软件预设检测法 堆栈说到底就是用来重复使用的内存，并且其规律是固定的，要么向下或者向上增长，使用完以后也不会对其进行清除等等处理，那么这里就为我们分析堆栈的使用情况带来了一丝线索。
软件预设检测法就是在堆栈的末端规定一段内存区域，然后在程序运行前先采用特殊的数值对该部分内存区域进行填充，系统软件定时或者定期的比对这一部分规定的内存区域与所设置的特殊值是否一致，一旦检测不一致大概率说明堆栈已经使用到了末尾（这里为什么说大概率呢?因为你程序中起飞的指针也有可能篡改这一部分数据！），所以也就说明你之前分配的堆栈空间不够。
该方法也是目前前后台程序或者是多线程程序经常使用的软件检测堆栈溢出的办法，特别是目前的RTOS基本上都是采用此办法。
该方法的缺点也非常明显，首先检测需要耗费CPU不少开销，有时候由于较严重的堆栈溢出直接会导致程序卡死而来不及检测，甚至大数组局部变量直接跳过预设值区域，导致堆栈检测失效等问题。
所以对于软件上检测堆栈溢出的不可靠性，各路大佬又想出了非常多改进版本的检测方案，这里暂时不展开，后续再跟大家介绍！
2
堆栈限制寄存器 前面我们说了数组越界可直接检测下标，而堆栈分配前软件上不好实时检测，然而有一部分芯片硬件上为该检测量身定做了一套策略。
原理很简单，通过设置堆栈限制寄存器，每次使用堆栈都会拿实际的堆栈指针与堆栈限制寄存器进行比对，看是否超过了所限制的范围，一旦超过了便会触发相应的异常中断，最终交给用户做最后的处理，用户甚至可以根据当前的寄存器情况追溯到对应的溢出位置从而修护问题。
对于单任务的前后台程序运行或许直接设置堆栈限制寄存器的值可以实时的检测堆栈的使用情况，然而对于多任务系统，每个任务都有其自身的内存堆栈，所以需要在任务切换过程中动态的更新保存堆栈限制寄存器的值，从而实现对每个任务的堆栈监控。
所以拥有了这样的硬件神器或许根本就不需要程序员太过担心堆栈溢出问题导致的后果，不幸的是目前支持堆栈限制功能的CPU太少了，对于MCU而言这样的功能更加是稀缺。
那么bug菌下面便介绍另外一种硬件实施办法！
3
MPU替代法
相对堆栈限制寄存器或许MPU就比较廉价了，目前比较高性能的MCU都会自带MPU功能，然而bug菌可以说80%的嵌入式程序员几乎都不怎么用MPU功能，或者说根本不会用该功能。
什么是MPU呢？英文名字Memory Protection Unit，内存保护单元，当然MPU的缩写还可以表示微处理器的意思，这里就暂时不讨论。
对于内存保护单元简单一点说就是可以通过设置MPU控制器来指定哪些内存在什么情况下可以访问，哪些内存在什么情况下不可以访问。
那再来看看我们堆栈溢出，不正好就是CPU访问了不该访问的地方吗?所以MPU该上阵了。
如上图我们把堆栈的末端一部分内存设置为MPU单元保护区，一旦堆栈分配的内存访问到这部分区域便会触发MPU访问异常中断，从而通知用户进行溢出后的处理工作。
很明显这种MPU方案与第一种软件检测方案几乎是类似的，只是前一种去主动检查该区域是否被修改，而另外一种是通过MPU被动触发异常。但是后者硬件MPU检测是实时的更加降低了漏检的风险。
他们两个都没有第二种方案完美，比如对于大数组的漏检测风险，堆栈区域的浪费等等，整体来说只能说" 够用 ",软件上可以更好的降低漏检风险，毕竟你的堆栈溢出也不会那么凑巧！
3、结束语
好了，本文到此结束！全是bug菌一个字一个字敲的，原创不易！
最近大家应该有发现bug菌更新有点慢，其实手上已经积累了20多个文章主题待写，可是一直迟迟没有动手，原因就不多解释了吧！
我是bug菌，一个走路都带风的男子！
推荐专辑 点击蓝色字体即可跳转
☞ MCU进阶专辑 ☞ 嵌入式C语言进阶专辑 ☞ “bug说”专辑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b6d9b4a41ff73f5daf546a274da497/" rel="bookmark">
			STM32的PWM和DAC练习（播放音乐）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、用STM32F103输出一路PWM波形二、DAC练习步骤实作（截图） 一、用STM32F103输出一路PWM波形 此处使用的是野火自带的示例代码：
《32-TIM—通用定时器》—&gt;《2-TIM—通用定时器-4路PWM输出》
之后进行下图设置：
之后就能仿真了
二、DAC练习 将一段数字音频歌曲数据转换为模拟音频波形输出（循环）
步骤 1、截取自己想要一段音乐最好使用WAV格式，如果不是WAV格式需要使用软件将格式更改为WAV格式；
2、用UltraEdit和Notepad++编辑这个wav文件，选择文件需要的一部分；
3、打开野火实例代码：《38-DAC—输出正弦波》
4、将自己需要的部分粘贴进uint16_t Sine12bit 这个函数
5、编译并烧录程序
实作（截图） 1、
2、
打开后，我们只需要中间这一部分；
这一部分我们需要将他改为16进制（加入0x和**,**）；
这里我使用的软件是Notepad++,alt+c可以直接列块编辑；
3、
**4、**将第二步的数据粘贴到进代码；
野火的示例代码可以在野火的官网下载；
5、
编译通过，之后烧录即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f8364e91f5e402324b0083c3fd5b79/" rel="bookmark">
			java多线程基础（二）线程死锁及线程通讯！！面试必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习多线程基础（二）线程死锁及线程通讯 1、线程死锁1.1、什么是死锁1.2、死锁产生的必要条件互斥条件不可剥夺条件请求与保持条件循环等待条件 1.3、死锁示例代码1.4、死锁处理死锁预防 1.5、死锁避免有序资源分配法银行家算法顺序加锁限时加锁死锁检测死锁恢复 2、线程通讯2.1、为什么要线程通信2.2、线程通讯方式休眠唤醒方式 2.3、CountDownLatch方式2.4、CyclicBarrier方式2.5、Semaphore方式 小结sleep和wait区别wait和notify区别 1、线程死锁 1.1、什么是死锁 多线程以及多进程改善了系统资源的利用率并提高了系统的处理能力。然而，并发执行也带来了新的问题–死锁。
所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。
1.2、死锁产生的必要条件 以下这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
互斥条件 进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
不可剥夺条件 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。
请求与保持条件 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
循环等待条件 存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图所示。
1.3、死锁示例代码 DeadLock.java
package com.liuchunming.multithread; public class DeadLock implements Runnable { private static Object obj1 = new Object();//定义成静态变量，使线程可以共享实例 private static Object obj2 = new Object();//定义成静态变量，使线程可以共享实例 public int flag; public DeadLock(int flag){ this.flag=flag; } public void run() { if(flag == 1){ //线程1执行代码 synchronized (obj1){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4f8364e91f5e402324b0083c3fd5b79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f272e807fc88f5ce692f25ce5d8d68c3/" rel="bookmark">
			redis stream持久化_Redis源码学习(36)Redis数据持久化RDB策略（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知Redis是一款内存数据库，所有的数据都被存储在内存之中，然而如果数据仅仅被存储在内存中的话，那么一旦服务器进程出现停机，那么所有的数据都将丢失，因此Redis需要支持数据的持久化，将内存之中的数据存储在磁盘之中。当Redis进程启动时，会从磁盘之中将数据恢复到内存之中。
RDB概述 RDB持久化是Redis支持的一种持久化策略，Redis会将服务器的状态信息以及所有数据库中的数据序列化到磁盘的文件之中，相当于保存了服务器数据的一个快照。在Redis启动时，会从文件中反序列化恢复数据到内存之中。
Redis可以通过主动或者被动的方式来创建RDB文件：
主动方式，通过客户端数据的命令SAVE以及BGSAVE，来启动RDB持久化。
如果客户端执行SAVE，那么Redis会同步地生成RDB文件，此时Redis的主线程会被阻塞起来，直到RDB文件生成完成，Redis都不会响应客户端的命令请求。
如果客户端执行BGSAVE，那么Redis会异步地生成RDB文件，此时Redis会主动创建一个子进程用于生成RDB文件，而Redis此时依然可以处理客户端的其他命令请求。
被动方式，Redis检测一段时间内修改次数累积到一定的阈值时，会启动异步生成RDB文件的逻辑。
对于RDB文件的自动备份，这里需要专门介绍一下，Redis会通过下面这个结构体来描述这个自动备份的阈值：
struct saveparam {time_t seconds;int changes;
}; 这表示，如果Redis在saveparam.seconds秒数内累积了saveparam.changes次变化的化，便会启动备份。Redis可以保有多个这样的阈值，存储在服务器全局数据之中：
struct redisServer {
...struct saveparam *saveparams;int saveparamslen;
}; 同时Redis也存储了自上次备份以来被修改的数据数量以及上次备份的时间，同样保存在服务器全局数据之中：
struct redisServer {
...long long dirty;time_t lastsave;
}; Redis会在服务器的心跳serverCron中，对累积的变化数据进行检测，多个阈值只要有一个满足，那么便会触发生成RDB文件的逻辑。需要注意的时，这种情况下，Redis是采用异步的方式来生成RDB文件的。
Redis在生成RDB文件时，则是使用前面我们介绍的rio对象，通过操作FILE类型的rio对象，我们可以实现内存数据到文件的序列化过程以及文件数据到内存的反序列化过程。
RDB基础数据的读写 为了实现序列化，出了需要将内存中的数据转化为一段连续数据之外，还需要附加上一个类型标记，通过这个类型标记，我们可以知道被序列化的连续数据将被反序列化为何种类型的数据。另外还需要在序列化数据之中附加上长度信息，通过这个信息，我们可以在反序列化时，确定一段完整的数据应该截止于何处。
Redis在src/rdb.h头文件之中，通过define定义了RDB序列化数据的类型：
RDB_TYPE_STRING，这个类型表示序列化的是字符串对象类型
RDB_TYPE_LIST，这个类型已经不再使用
RDB_TYPE_SET，这个类型表示序列化的是使用OBJ_ENCODING_HT编码方式的集合对象
RDB_TYPE_ZSET，这个类型已经不再使用
RDB_TYPE_HASH，这个类型表示序列化的是使用OBJ_ENCODING_HT编码方式的散列对象
RDB_TYPE_ZSET_2，这个类型表示序列化的是使用OBJ_ENCODING_SKIPLIST编码方式的有序集合对象
RDB_TYPE_MODULE，这个类型已经不再使用
RDB_TYPE_MODULE_2，这个类型表示序列化的是Module对象数据
上述这几个类型都是用于标记对象数据类型的序列化，并且上述类型的数据都是对应底层使用哈希表或者跳跃表这类离散数据的序列化。通过前面的介绍我们知道在一些特殊的情况下，Redis会使用连续分配的内存段来事项对象数据类型，下面这几个类型的定义便是对应于这种情况：
RDB_TYPE_HASH_ZIPMAP，这个类型已经不在使用
RDB_TYPE_LIST_ZIPLIST，这个类型已经不在使用
RDB_TYPE_SET_INTSET，这个类型表示序列化的是使用OBJ_ENCODING_INTSET编码方式的集合对象
RDB_TYPE_ZSET_ZIPLIST，这个类型表示序列化的是使用OBJ_ENCODING_ZIPLIST编码方式的有序集合对象
RDB_TYPE_HASH_ZIPLIST，这个类型表示序列化的是使用OBJ_ENCODING_ZIPLIST编码方式的散列对象
RDB_TYPE_LIST_QUICKLIST，这个类型表示序列化的是使用OBJ_ENCODING_QUICKLIST编码方式的列表对象
RDB_TYPE_STREAM_LISTPACKS，这个类型表示序列化的是Streamdui对象数据
上述的这些对应数据对象类型的序列化类型，可以通过下面的两个函数进行读写：
int rdbSaveObjectType(rio *rdb, robj *o);int rdbLoadObjectType(rio *rdb); 除了标记数据对象的序列化类型，Redis还定义了几个辅助数据序列化的类型：
RDB_OPCODE_MODULE_AUX，这个类型表示后序列化的是Module辅助数据。
RDB_OPCODE_IDLE，这个类型表示后面序列化的是一个key的LRU空闲时间。
RDB_OPCODE_FREQ，这个类型表示后面序列化的是一个key的LFU频率数据。
RDB_OPCODE_AUX，这个类型表示后面序列化的是一个RDB的辅助数据。
RDB_OPCODE_RESIZEDB，这个类型表示后面序列化的是数据库键空间的长度以及过期哈希表的长度。
RDB_OPCODE_EXPIRETIME_MS，这个类型表示后面序列化的是一个key的毫秒级有效期时间戳。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f272e807fc88f5ce692f25ce5d8d68c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a8d40861b2b858e66704b1f7eb982f4/" rel="bookmark">
			cad中填充的剖面线不能被修剪_cad图纸解析，总结的666
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好课推荐：
1、CAD2014：点击查看 2、室内&amp;全屋：点击查看 3、CAD2019：点击查看 4、CAD2018： 点击查看 5、Bim教程：点击查看 6、室内手绘：点击查看 7、CAD三维： 点击查看 8、全屋定制：点击查看 9、 ps cc2019 ：点击查看 10、 MAC版CAD :点击查看 11、 3dmax教程 ：点击查看 12、 UG教程 ：点击查看 13：SU教程：点击查看 14.solidworks教程：点击查看
更多视频教程：点我查看
经常分享室内或建筑等图纸总结推文，每次推文都有很多人问，能不能来套机械的，以下希望对大家有点帮助。 1.纸幅面按尺寸大小可分为5种，图纸幅面代号分别为A0、A1、A2、A3、A4。图框右下角必须要有一标题栏，标题栏中的文字方向为与看图方向一致。
2.图线的种类有粗实线、细实线、波浪线、双折线、虚线、细点划线、粗点划线、双点划线等八类。 3.图样中，机件的可见轮廓线用粗实线画出，不可见轮廓线用虚线画出，尺寸线和尺寸界线用细实线画出来，对称中心线和轴线用细点划线画出。 虚线、细实线和细点划线的图线宽度约为粗实线的1/3。 4.比例是指图中图形尺寸与实物尺寸之比。 5.比例1∶ 2是指实物尺寸是图形尺寸的2倍，属于缩小比例。 6.比例2∶ 1是指图形尺寸是实物尺寸的2倍，属于放大比例。 7.在画图时应尽量采用原值比例的比例，需要时也可采用放大或缩小的比例，其中1： 2为缩小比例，2： 1为放大比例无论采用那种比例图样上标注的应是机件的实际尺寸。 8.图样中书写的汉字、数字和字母，必须做到字体工整，笔画清楚，间隔均匀，排列整齐，汉字应用长仿宋体书写。 9.标注尺寸的三要素是尺寸界限、尺寸线、尺寸数字。 10.尺寸标注中的符号： R表示圆半径，ф表示圆直径，Sф表示球直径。 11.图样上的尺寸是零件的实际尺寸，尺寸以毫米为单位时，不需标注代号或名称。 12.标准水平尺寸时，尺寸数字的字头方向应向上； 标注垂直尺寸时，尺寸数字的字头方向应朝左。 角度的尺寸数字一律按水平位置书写。 当任何图线穿过尺寸数字时都必须断开。 13.斜度是指斜线对水平线的倾斜程度，用符号∠表示，标注时符号的倾斜方向应与所标斜度的倾斜方向一致。 所标锥度方向一致。 14.符号“∠1∶ 10”表示斜度1∶ 10，符号“1： 5”表示锥度1∶ 5。 15.平面图形中的线段可分为已知线段、中间线段、连接线段三种。 它们的作图顺序应是先画出已知线段，然后画中间线段，最后画连接线段。 16.已知定形尺寸和定位尺寸的线段叫已知线段； 有定形尺寸，但定位尺寸不全的线段叫中间线段； 只有定形尺寸没有定位尺寸的线段叫连接线段。 17.主视图所在的投影面称为正投影面，简称正面，用字母V表示。 俯视图所在的投影面称为水平投影面，简称水平面，用字母H表示。 左视图所在的投影面称为侧投影面，简称侧面，用字母W表示。 18.三视图的投影规律是，主视图与俯视图等长； 主视图与左视图等高； 俯视图与左视图等宽。 19.零件有长、宽、高三个方向的尺寸，主视图上能反映零件的长和高，俯视图上只能反映零件的长和宽，左视图上只能反映零件的高和宽。 20.零件有上、下、左、右、前、后六个方位，在主视图上只能反映零件的上，下，左，右方位，俯视图上只能反映零件的前，后，左，右方位，左视图上只能反映零件的上，下，前，后方位。 21.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a8d40861b2b858e66704b1f7eb982f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e165fe775e65171b9101dd56c2e14830/" rel="bookmark">
			a3图纸标题栏尺寸标准_CAD福利教程，甲级设计院全部专业的CAD制图标准，早晚用得到！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是爱踢汪。今天又给大家送上一波福利。为进一步规范xx公司的CAD制图标准，解决计算机资源共享问题，从而进一步提高设计效率，特制定《xxCAD制图标准》。
1、适用范围
使用上海xx设计(集团)有限公司、XX建筑设计研究院有限公司、XX建筑设计研究院有限公司等设计资质，并以CAD方式制图的初步设计、施工图设计阶段的设计图纸。
2、引用标准
下列标准所包含的条文，通过在本标准中引用而构成为本标准的条文。
《房屋建筑CAD制图统一规则》GB/T18112-2000
《CAD工程制图规则》GB/T18229-2000
《房屋建筑制图统一标准》GB/T50001-2001
《建筑制图标准》GB/T50104-2001
《建筑结构制图标准》GB/T50105-2001
《给水排水制图标准》GB/T50106-2001
《采暖通风与空气调节制图标准》GBJ/T50114-2001
3、基本要求
3.1图框
3.1.1图幅与格式
3.1.2标题栏
现代设计集团及各子分公司设计资质的设计图框应制作成标准图块。标准图框中的标题栏应具备更改区、签字区、设计单位及项目名称和代号区等，并作为统一标识不得随意修改,当需要修改使用时必须由集团或各子分公司技术管理部门批准。
3.1.3文件名
各专业CAD图纸文件名一般应采用中文书写，且与自然图纸张数相对应，并用以下规定格式：“图别图号—图名”例如：结施2-基础平面图，结施1XX-基础平面图等；
当从事合作设计，文件名需要使用英文书写时应设“专业码—图名主组码(—图名次组码)—序号”引导。例如：建筑专业一层平面图A—F—1，其专业码为建筑“A”，主组码为平面图“F”，序号为1；各专业英文图名列表见附录一。为直观起见，允许在专业码后直接采用英文全称及图纸序号，例如：A—Floor1。
3.2比列
3.3字体
3.3.1字高
1、图面字高应严格采用2.5、3.5、5、7、10、14、20mm等七类字高，高宽比设定为0.7；
2、汉字字高应不小于3.5mm，英文字符与数字高度应不小于2.5mm；
3、一般情况下A0、A1号图纸的图签中图名采用10mm字高，A2、A3号图纸的图签中图名采用7mm字高；
4、图纸中图面表达部分的图名宜采用7mm及以上字高，设计说明部分采用5mm字高，图中文字标注或引注采用3.5mm字高，尺寸标注采用2.5mm字高。
3.3.2字间距及行距
字间距宜使用标准字间距，行距宜采用1.5倍行距。
3.3.3字体
标准图签内及说明的字体应由集团或各子分公司统一选定，如华东院为统一选用HZS(长仿宋体)，使用字体类型STYLE定为ECADI(hzs.shx，hztxt.shx)。并符合字体间距要求，图签中图名等标题可选用其他字体；上海院一般字体为数字选用单线体SA-RS，汉字选用单线体SA-HZ；标题字体数字选用SA-RC，汉字选用SA-SHZ。另外，考虑到特殊符号的调用，允许使用WORD编写各专业统一说明，字体选用仿宋_GB2312。
3.4图线
3.4.1基本线形
3.4.2线形构造
各项线形构造均有严格规定，常用LTSCALE取值如下表所示：
3.4.3线宽
线宽分粗(b)、中(0.5b)、细(0.25b)三级，绘图时应根据绘图比例大小成组选用，严禁从不同组内选用各级线宽；各专业应严格采用本专业的标准线宽组进行绘图。各组线宽如下表所示：
3.4.4颜色管理
各图层颜色必须随层设置(Bylayer)，层颜色宜使用各专业模板(.dwt)设定色。
3.5剖面符号
常用剖面式样所表达材料内容如下表所示：
其他剖面式样见附录三。
注：
1、以上普通砖、金属材料、多孔材料、自然土壤以及夯实土壤的图例中斜线一律为45度。
2、混凝土、钢筋混凝土、金属图例中，在图形较小时可以涂黑。3、钢筋混凝土图例使用混凝土及普通砖图例通过Hatch命令叠加。
3.6投影法
管道透视图按45度正面斜轴测法绘制。管道透视图的布置方向应与平面图一致。
图面表达形式如下图所示：
图层管理
不同类别内容应分层设置。标准图框中已设定图框层及填表内容层，填表内容层用于填写图签中的内容，请勿在该二层内绘图或写说明文字。绘图与设计说明应根据各专业要求另设图层。
图层名原则上用中文命名，设置原则：专业名—图层类别，常用图层名见附录二(中文)。
中外合作设计需要时，图层名可用英文命名，设置原则为：专业码—英文简称，常用图层名见附录二(英文)。
专业码分类如下：
4、基本画法
4.1尺寸标注
同一工程图中只应采用一种形式，宜采用短斜线形式，如图示1。
尺寸数字、尺寸线、标注文字与尺寸线间距和尺寸界限设置要求：1、尺寸界线应用细实线绘制，通常一端应离开被标注图样轮廓线2mm，另一端超出尺寸线2~3mm。图样轮廓线也可用作尺寸界线。尺寸起止符号一般用中粗斜短线绘制，其倾斜方向应与尺寸界线成顺时针45º角，长度为2mm。
2、圆弧及圆的直径、半径尺寸标注用箭头表示法表示，如图示2。
3、文字一般应标注于尺寸线上方，当间距过小无法标注清晰时，也可标注在尺寸线的下方或外侧，并应与尺寸线间距尽量保持一致。当尺寸标注在图样轮廓内时，不应与图线、文字及符号等相交，如图示3。
3、图样轮廓线以外的尺寸界线距图样最外轮廓之间的距离通常为10mm，平行排列的尺寸线间距为7~10mm，各条平行排列的尺寸线间距应保持一致。
在电子模板文件(.dwt)中，提供了1:1、1:50、1:100和1:500四种常用比例的尺寸标注样式。若要使用其他比例的尺寸标注样式，请进入“DimensionStyles”对话框，点击“Geometry”按扭，在弹出的对话框中找到“OverallScale”项，将其值改为所需要的值(例：所需比例为1:200，则将‘OverallScale’值改为200)。然后，点击“OK”按扭回到“DimensionStyles”对话框，再依次点击“Save”和“OK”按扭即可。
4.2标高标注
标高符号以直角等腰三角形表示，其竖向图面高度为3mm。标高应注在标高三角侧向横线的上(下)方。如图示4。当标注总平面图室外地坪标高符号时，应将三角涂黑表示。
4.3定位轴线标记
定位轴线标记有下列方式：
一般定位轴线标记，见图5中的a)、b)；
通用详图的定位轴线标记，见图5中的c)；
附加轴线的定位轴线标记，见图5中的d)、e)；
分区轴线的定位轴线标记，见图5中的f)；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e165fe775e65171b9101dd56c2e14830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f26155b27a05723172d57d5e6b406a2/" rel="bookmark">
			html首页源码_从Vue生产代码index.html看prefetch和preload
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生产代码index.html示例 以下是一张执行了npm run build之后的index.html的源码。可以看到，除了最后一个rel是preload，其余的都是prefetch。可以看出Vue cli使用preload和prefetch来改善性能。
preload 通常在页面中我们需要加载脚本和样式，preload可以对当前页面所需要的脚本、样式等资源进行预加载，而无需等到解析到script和link标签时才进行加载。这一机制使得资源可以更早的得到并可用，且不易阻塞页面的初步渲染，进而提升性能。
prefetch prefetch和preload一样都是对资源进行预加载，但是prefetch加载的资源一般不是用于当前页面，而是其他页面用到的资源。prefetch不会像preload一样，在页面渲染的时候加载资源，而是等浏览器空闲下来的时候再去下载。当真正打开对应页面时，直接从缓存中取，既不影响当前页面的渲染，又提高了其他页面加载和渲染的速度。
网络请求对比 对于如下源码：
&lt;link href="app.js" rel="preload" as="script&gt; 首页加载时的一个真实网络请求为：
可以看出传输了5.8M，资源加载了5.8M。
对于如下源码：
&lt;link href="app.js" rel="preload" as="script&gt; 首页加载时的一个真实网络请求为：
可以看出传输了5.8M，资源加载了0。
当真正用到这个资源的网页打开时，资源才会从缓存里面加载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa45beec59177a0b3b1478391626f55/" rel="bookmark">
			idea的查看git提交记录history，但是不显示每次提交对应的细节文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/u010886217/article/details/110207121
一、问题描述
最近使用idea遇见非常头痛问题。
虽然使用idea的VCS功能进行代码管理非常方便，但是，最近使用时竟然产生了一个很头痛的问题：就是点击项目右键-》git-》Show History，查看git提交记录。之前都是显示对应的提交细节文件，但是最近没有
之前使用idea都是显示提交批次的具体代码
但是，这次idea只是显示提交记录细节，而不显示提交批次对应代码，这样，就无法知道每次提交对应的分别时那些文件，如下图
二、问题解决
也是查找了很多，但是很多无效方法。后来终于发现这个看似复杂的问题，其实，关键就在右侧上方比较粗的一条线。把这个线往下拉就可以看到亲爱的对应代码了！
如果你也热衷技术欢迎加群一起进步：230274309 。 一起分享，一起进步！少划水，多晒干货！！欢迎大家！！！(进群潜水者勿加) 点击链接加入群聊【编程之美】：https://jq.qq.com/?_wv=1027&amp;k=h75BfFCg
+++++++++++++++++++++++
或者扫码
+++++++++++++++++++++++
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7eb7f71de55ea720ff91b668a1227bc/" rel="bookmark">
			移动宽带套餐介绍_中国移动宽带套餐有哪些，谢谢！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
中国移动宽带套餐分别有以下几个：
1、一年20兆宽带网络资费600送150话费32313133353236313431303231363533e58685e5aeb931333365666265，二年资费900送300话费。
2、一年50兆宽带网络资费980送240话费，二年资费1500送50话费。
3、一年100兆宽带网络资费1380送380话费，二年资费1800送600话费。
扩展资料：
有线通宽带
移动依托铁通发展自己的有线宽带的同时，发展移动有线通，是移动在2008年电信业重组之后与广电合作推出的一种有线宽带上网业务。移动为了和电信联通进行有线宽带服务的竞争，推出了这个业务。移动有线通是针对家庭用户或企业提供的基于双向有线网络的宽带接入服务。
当然移动有线通是针对有线上网提出的，移动很早就开办了无线上网业务如：手机上网、3G上网、WLAN(WIFI)，有线通的推出也使人们多了一种上网运营商的选择。
移动有线通还没有很好的网络覆盖，对于大多数想尝试移动有线通的用户必须先咨询移动公司才能办理这个业务。因为并不是每个地方都能办理的，有些地方也由铁通代办。
WLAN
WLAN 信号覆盖范围内，以无线方式接入互联网。
数字校园：是指移动为各学校及教育主管部门提供与其日常生活、办公和学校管理紧密耦合的信息化平台，以满足师生随时随地通信沟通、学习、互联网畅游等办公、学习和生活的需要。
cmcc即China Mobile Communication Corporation的简称，是中国移动随e行WLAN业务，电脑、智能手机、平板电脑搜索到的无线网络信号标示，一般在电脑右下角显示，cmcc-edu大部分适用于中国移动校园网业务。
无线音乐
中国移动无线音乐俱乐部(以下简称无线音乐俱乐部)是为广大中国移动用户提供的一站式音乐体验新平台，包括音乐下载、音乐共享、音乐传播、音乐交流等服务。无限优质丰富的音乐产品与服务将让俱乐部会员更加畅快地享受到移动音乐的淋漓尽致！音乐产品优惠、明星见面会、演唱会门票...各项会员特权，让你自由畅享音乐国度。
手机报
手机报是中国移动与国内主流媒体单位合作的一项自有增值业务，它以彩信通信方式为主,以WAP方式辅助浏览，向客户提供资讯服务(含新闻、体育、娱乐、文化、生活等内容)，客户可以定时收到报刊彩信或随时通过WAP方式直接阅读，获取渠道及时、便捷，内容权威。
参考资料：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0499669fd275d9732be26b555270c0/" rel="bookmark">
			sklearn聚类模型评估代码_sklearn中模型评估和预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、模型验证方法如下：
通过交叉验证得分：model_sleection.cross_val_score(estimator,X)
对每个输入数据点产生交叉验证估计：model_selection.cross_val_predict(estimator,X)
计算并绘制模型的学习率曲线：model_selection.learning_curve(estimator,X,y)
计算并绘制模型的验证曲线：model_selection.validation(estimator,...)
通过排序评估交叉验证的得分在重要性：model_selection.permutation_test_score(...)
①通过交叉验证得分：model_sleection.cross_val_score(estimator,X)
import numpy as np
from sklearn.model_selection import cross_val_score
from sklearn import datasets,svm
digits=datasets.load_digits()
X=digits.data
y=digits.target
svc=svm.SVC(kernel='linear')
C_s=np.logspace(-10,0,10)
print("参数列表长度",len(C_s))
scores=list()
scores_std=list()
n_folds=3
for C in C_s:
svc.C=C
this_scores=cross_val_score(svc,X,y,cv=n_folds,n_jobs=1)
#print(this_scores)
scores.append(np.mean(this_scores))
scores_std.append(np.std(this_scores))
#绘制交叉验证的曲线
import matplotlib.pyplot as plt
plt.figure(1,figsize=(4,3))
plt.clf()
plt.semilogx(C_s,scores)
plt.semilogx(C_s,np.array(scores)+np.array(scores_std),'b--')
plt.semilogx(C_s,np.array(scores)-np.array(scores_std),'b--')
locs,labels=plt.yticks()
plt.yticks(locs,list(map(lambda x:"%g" %x,locs)))
plt.ylabel("CV score")
plt.xlabel("Parameter C")
plt.ylim(0,1.1)
plt.show()
结果图
②对每个输入数据点产生交叉验证估计：model_selection.cross_val_predict(estimator,X)
from sklearn import datasets,linear_model
from sklearn.model_selection import cross_val_predict
disbetes=datasets.load_diabetes()
X=disbetes.data[:150]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd0499669fd275d9732be26b555270c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3acaeafb23fa4e2a4b51ddabbb74383/" rel="bookmark">
			编译原理-正则文法与正则表达式的相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则文法与正则表达式的相互转化 前言一、正则文法1.定义2.例子 二、正则表达式1.定义2.例子 三、转换规则1.正则文法转换为正则表达式2.正则表达式转换为正则文法 四、转换例子1.正则文法转换为正则表达式2.正则表达式转换为正则文法 总结 前言 在词法分析过程中，如果将每类单词都看作一种语言，则大多数单词词法可以用正则文法来描述。 除了正则文法外，正则表达式也可以相应的用来描述单词，正则文法和正则表达式的能力相同，且可以互相转化。正则表达式比正则文法更直观，有时首选正则表达式来表示正则语言。
一、正则文法 1.定义 正则文法在这篇文章（编译原理-文法的定义与分类）中有所讲解，在此处再稍微讲述一遍：
正则文法G = (V，T，P，S)中，对∀α —&gt; β∈P，α β均具有形式A —&gt; w或A —&gt; wB(A —&gt; w或A —&gt; Bw)，其中A，B∈V，w∈T+。正则文法描述T上的正则语言。 2.例子 例子：词法分析中标识符的文法：
二、正则表达式 1.定义 定义：设∑是一个字母表，则∑上的正则表达式及其所表示的正则语言可递归地定义如下：
⑴ Ø是∑上的一个正则表达式，它表示空集；
⑵ ε是∑上的一个正则表达式，它表示语言{ε}；
⑶ 对于∀a(a∈∑)，a是∑上的一个正则表达式，它表示的正则语言是{a}；
⑷ 假设r和s都是∑上的正则表达式，它们表示的语言分别为L®和L(s)，则：
( r )也是∑上的正则表达式，它表示的语言为L( r )；(r|s)也是∑上的正则表达式，它表示的语言为L( r )∪L(s)；（并操作）(r•s)也是∑上的正则表达式，它表示的语言为L( r )L(s)；（连接操作）(r*)也是∑上的正则表达式，它表示的语言为(L( r ))*；（克林闭包操作） ⑸ 使用上述规则构造的表达式是∑上的正则表达式。
2.例子 例子：词法分析中标识符的正则表达式表达：
三、转换规则 1.正则文法转换为正则表达式 具体转换步骤为：
根据正则文法G构造正则表达式联立方程组。
假设正则文法G是右线性的，其每个产生式的右部只含有一个终结符，则有如下方程式构造规则：
解联立方程组，求等价的正则表达式r。
用代入消元法逐个消去方程组中除开始符号S外的其他变量，最后即可得到关于开始符号S的解。
代入消元规则如下：
求得结果。
如果最后得到的关于S的方程式为如下形式，
S=α1|α2|…|αh
则将方程式右边所有其中仍然含有语法变量的αi(1≤i≤n)删除，得到的结果就是与G等价的正则表达式。
如果任意的αi(1≤i≤n)均含有语法变量，则Ø就是与G等价的正则表达式。
2.正则表达式转换为正则文法 给定正则表达式r，按如下方法构造正则定义式，并逐步将其转换成正则文法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3acaeafb23fa4e2a4b51ddabbb74383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c951f8ae62d0282f82d5ba1405465b6/" rel="bookmark">
			cada0图纸框_求标准CAD图纸(A0、A1、A2、A3、A4)图框(外框、内框)、标题栏及明细栏大小样式字体是多大?...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置绘图边界
一个菜单命令“格式|”图形界限
命令行：LIMITS
正式图纸，图纸格式有具体的规定和要求。 GB-1986年，国家规定的绘图格式的大小。表1-1中所示的特定的要求，如在图1-1中示出了：
表1-1绘图格式大小(单位：mm)
尺寸代码
振幅表面生成编号
A0 A1 A2 A3 A4
？？？B 841 594 420 297 210
？·L 1189 841 594 420 297
？？C 10 5
？？？25
提示：
1)图纸从A0，根据图格式的大小的一半的格式尺寸图纸上。如A0 = 2A1
2)A0-A3图纸景观图纸，剩余的垂直图纸。
注：
答：相同规格的工程图纸一般不超过两个，尽量采用相同规格的图纸的风格
B：AUTOCAD使用公制默认图纸幅面A3，即420×297毫米
？
绘图空间，从图1-1中可以看出，由图边界，附图的帧线缝合图边界是否必须由粗实线表示。图纸的格式绘图本身的大小是规范。图框是用来定义在图纸上绘图范围的边界线。可分为2种水平格式和垂直格式的格式的附图。作为该图的垂直边缘的短边被称为水平附图。
在正常情况下，附图是按照上面的描述，但也有特殊情况下。此时，附图可以适当延长。
注：不能延长图纸的短边，长边不再需要，但根据国标规定的，不能随意扩大。指定为表1-2中所示：
表1-2图纸的长边扩展尺寸(mm)
格式代码尺寸长边长边扩展尺寸
A0 1189 1338 1487 1635 1784 1932 2081 2230 2387
A1 841 1051 1261 1472 1682 1892 2102
A2 594 743 892 1041 1189 1338 1487 1635 1784 1932 2081
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c951f8ae62d0282f82d5ba1405465b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697c775ef0ea6539efef4bc4ea46718b/" rel="bookmark">
			卓越性能代码_开启win10的卓越性能模式，轻松几步就设置好了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开启win10的卓越性能模式，轻松几步就设置好了
在windows10中更新了一项不错的功能，一般人估计发现不了，那就是性能模式，一般我们常规使用的是windows自带的一些电源选项模式，比如省电模式，性能模式等等。
其实啊，win10 的这一次更新当中还隐藏了一个模式，那就是卓越性能模式，开启卓越性能模式以后，CPU的利用率可以从原来的百分之十提升到百分之五十以上。
如何查看到我们的电脑当前使用的是什么样的电源管理选项呢？
其实很简单在屏幕的左下角点击开始——设置——系统——电源设置——其他电源设置。就能够看到的了。
电源管理一般默认的情况下，windows默认开启的是平衡模式。
现在就来说一说如何开启电脑上面的卓越性能模式吧。
首先我们在开始按钮的隔壁(也就那个圆圈)里面直接搜索windows powershell，然后右键单击windows powershell，在弹出的菜单中选择用管理员的权限打开。
然后在里面粘贴"powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61"这一段代码，点击回车键，这时候windows powershell 就会提示你开启了卓越性能模式了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c665c454acedad33dd7739f8a139775a/" rel="bookmark">
			哈工大讯飞联合实验室发布法律领域ELECTRA预训练模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自：哈工大讯飞联合实验室
哈工大讯飞联合实验室发布的中文ELECTRA系列预训练模型再迎新成员。我们基于大规模法律文本训练出中文法律领域ELECTRA系列模型，并且在法律领域自然语言处理任务中获得了显著性能提升。欢迎各位读者下载试用相关模型。
项目地址：http://electra.hfl-rc.com
中文法律领域ELECTRA 我们在20G版（原版）中文ELECTRA的基础上加入了高质量2000万裁判文书数据进行了二次预训练，在不丢失大规模通用数据上学习到的语义信息，同时使模型对法律文本更加适配。本次发布以下三个模型：
legal-ELECTRA-large, Chinese: 24-layer, 1024-hidden, 16-heads, 324M parameters
legal-ELECTRA-base, Chinese: 12-layer, 768-hidden, 12-heads, 102M parameters
legal-ELECTRA-small, Chinese: 12-layer, 256-hidden, 4-heads, 12M parameters
快速加载 哈工大讯飞联合实验室发布的所有中文预训练语言模型均可通过huggingface transformers库进行快速加载访问，请登录我们的共享页面获取更多信息。
https://huggingface.co/HFL
模型键值如下：
hfl/chinese-legal-electra-large-discriminator
hfl/chinese-legal-electra-large-generator
hfl/chinese-legal-electra-base-discriminator
hfl/chinese-legal-electra-base-generator
hfl/chinese-legal-electra-small-discriminator
hfl/chinese-legal-electra-small-generator
效果评测 我们在罪名预测以及要素抽取任务上进行了基线测试。其中罪名预测任务使用的是CAIL 2018数据，要素抽取任务为in-house实际应用。可以看到本次发布的法律领域ELECTRA模型均相比通用ELECTRA模型获得了显著性能提升。
表1 罪名预测任务
表2 要素抽取任务
其他相关资源 TextBrewer知识蒸馏工具
http://textbrewer.hfl-rc.com
中文BERT、RoBERTa、RBT系列模型
http://bert.hfl-rc.com
中文XLNet系列模型
http://xlnet.hfl-rc.com
中文MacBERT模型
http://macbert.hfl-rc.com
编辑：HFL编辑部
说个正事哈
由于微信平台算法改版，公号内容将不再以时间排序展示，如果大家想第一时间看到我们的推送，强烈建议星标我们和给我们多点点【在看】。星标具体步骤为：
（1）点击页面最上方“深度学习自然语言处理”，进入公众号主页。
（2）点击右上角的小点点，在弹出页面点击“设为星标”，就可以啦。
感谢支持，比心。
投稿或交流学习，备注：昵称-学校（公司）-方向，进入DL&amp;NLP交流群。
方向有很多：机器学习、深度学习，python，情感分析、意见挖掘、句法分析、机器翻译、人机对话、知识图谱、语音识别等。
记得备注呦
推荐两个专辑给大家：
专辑 | 李宏毅人类语言处理2020笔记
专辑 | NLP论文解读
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c665c454acedad33dd7739f8a139775a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/96/">«</a>
	<span class="pagination__item pagination__item--current">97/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/98/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>