<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d53f784c6e6317cad69ecf0ae978cf1/" rel="bookmark">
			PHP初级教程------------------（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文件包含
文件包含的作用
文件包含四种形式
文件加载原理
Include和require区别
文件加载路径
文件嵌套包含
函数
函数的基本概念
函数定义语法
函数命名规范
参数详解
形参
实参
默认值
引用传递
函数体
函数返回值
​作用域
静态变量
可变函数
匿名函数
闭包
伪类型
文件包含 文件包含：在一个PHP脚本中，去将另外一个文件（PHP）包含进来，去合作完成一件事情。
文件包含的作用 文件包含的意义：
1、 要么使用被包含文件中的内容，实现代码的共享（重用）：向上包含（索要）
向上包含：在当前脚本要用某个代码之前包含别的文件
2、 要么自己有东西可以给别的文件使用，实现代码的共享（重用）：向下包含（给予）
向下包含：在自己有某个东西的时候，需要别的脚本来显示（自己代码写完之后包含其他文件）
最大的作用：分工协作，每个脚本做的事情不一样，因此可以使用协作方式，让多个脚本共同完成一件事情。
文件包含四种形式 在PHP中文件的包含有四种形式（两种大形式）
Include：包含文件
Include_once：系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）
Require：与include相同
Require_once：以include_once相同
包含基本语法
Include ‘文件名字’;
Include(‘文件名字’); //文件名字：路径问题
以上方式：是先包含文件，后使用文件中的内容（向上包含）
向下包含：先准备内容，然后包含另外的文件，在另外的文件中，使用当前的内容
&lt;?php //被包含文件 //定义数据 $a = 1; define('PI',3.14); &lt;?php //包含文件：使用数据 //包含文件 include '20include1.php';	//包含当前文件include2.php所在文件夹下的include1.php echo $a,PI; //再次加载 //include 'include1.php'; //include_once //include_once 'include1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d53f784c6e6317cad69ecf0ae978cf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58055323ee302ea1c8a01acc0448ce26/" rel="bookmark">
			IDEA自带的数据库连接工具连接(GBase 8s)南大通用安全数据库管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GBase 8s工具（GBase Data Studio）用起来怪怪的，而且打开某张表查看数据，或者操作数据，等待时间很久，总觉得不方便。于是就想试试用IDEA自带的数据库工具链接GBase 8s试试
1、打开DataBase工具，新增驱动 2、IDEA 默认驱动没有GBase 8s，所以要先自定义一个GBase 8s的驱动，配置如下 详细添加步骤：
3、创建数据库连接 URL:jdbc:gbasedbt-sqli://主机:端口/数据库:GBASEDBTSERVER=实例名;SQLMODE=GBase;DB_LOCALE=zh_CN.57372;
url可以直接复制在GBase Data Studio中连接配置的JDBC URL
4、双击右侧连接即可显示数据库表等信息，双击表名可以快速查表 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458a94ac47f520fa53db5dce776ee79d/" rel="bookmark">
			百元买百鸡问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、假设公鸡2元一只，母鸡1.5元一只，小鸡0.5元一只，现用100元买一百只鸡。 解决方案一：枚举法
把每一种情况都罗列出来，找出符合条件的情况。
int x,y,z; int times = 0; int index = 1; for (x = 0;x &lt;= 100;x++){ for (y = 0; y &lt;= 100;y++){ for (z = 0;z &lt;= 100;z++){ times++; if (x + y + z == 100 &amp;&amp; 2*x +1.5*y + 0.5*z == 100){ System.out.println("方案"+index+"： 公鸡："+x+"只 母鸡："+y+"只 小鸡："+z+"只"); index++; } } } } System.out.println("总共循环了"+times+"次"); 1.优化1.0版 利用x+y+z=100解出z=100-x-y，减少一层循环。
int x,y,z; int times = 0; int index = 1; for (x = 0;x &lt;= 100;x++){ for (y = 0; y &lt;= 100;y++){ z = 100 - x - y; times++; if (x + y + z == 100 &amp;&amp; 2*x +1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/458a94ac47f520fa53db5dce776ee79d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0dafcb423566135545cf055e3a0e73/" rel="bookmark">
			Postgresql实战：使用pg_basebackup或pg_start_backup方式搭建Postgresql主从流复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档https://www.postgresql.org/docs/current/high-availability.html
主从原理或逻辑理解：
将一个基于文件日志传送slave服务器转变成流复制slave服务器的步骤是把该slave服务器recovery.conf文件中的primary_conninfo设置指向master服务器。这样slave服务器可以连接到master服务器上的伪数据库replication。当slave服务器被启动并且primary_conninfo被正确设置，slave服务器将在重放完归档中所有可用的WAL文件之后连接到master服务器。如果连接被成功建立，你将在slave服务器中看到一个walreceiver进程，并且在master服务器中有一个相应的walsender进程。
流复制允许一台后备服务器比使用基于文件的日志传送(日志传送是异步的，即 WAL 记录是在事务提交后才被传送。)更能保持为最新的状态。后备服务器连接到主服务器，主服务器则在 WAL 记录产生时即将它们以流式传送给后备服务器而不必等到 WAL 文件被填充。 默认情况下流复制是异步的，在这种情况下主服务器上提交一个事务与该变化在后备服务器上变得可见之间存在短暂的延迟。不过这种延迟比基于文件的日志传送方式中要小得多，在后备服务器的能力足以跟得上负载的前提下延迟通常低于一秒。如果你使用的流复制没有基于文件的连续归档，该服务器可能在后备机收到 WAL 段之 前回收这些旧的 WAL 段。如果发生这种情况，后备机将需要重新从一个新的基础备 份初始化。通过设置wal_keep_segments为一个足够高的值来确保旧 的 WAL 段不会被太早重用或者为后备机配置一个复制槽，可以避免发生这种情况。如果设置了一个后备机可以访问的 WAL 归档，就不需要这些解决方案，因为该归档可以 为后备机保留足够的段，后备机总是可以使用该归档来追赶主控机。 一旦流复制已经被配置，配置同步复制就只需要一个额外的配置步骤：synchronous_standby_names必须被设置为一个非空值。synchronous_commit也必须被设置为on，但由于这是默认值，通常不需要改变。这样的配置将导致每一次提交都等待确认消息，以保证后备服务器已经将提交记录写入到持久化存储中。将synchronous_commit设置为remote_write将导致每次提交都等待后备服务器已经接收提交记录并将它写出到其自身所在的操作系统的确认，但并非等待数据都被刷出到后备服务器上的磁盘。这种设置提供了比on要弱一点的持久性保障：在一次操作系统崩溃事件中后备服务器可能丢失数据，尽管它不是一次PostgreSQL崩溃。不过，在实际中它是一种有用的设置，因为它可以减少事务的响应时间。只有当主服务器和后备服务器都崩溃并且主服务器的数据库同时被损坏的情况下，数据丢失才会发生。
主节点：172.22.136.146
从节点：172.22.136.147
pg_basebackup的过程中，主库可读可写
pg_start_backup+copy+pg_stop_backup，copy的过程，主库可读可写
pg_basebackup的方式
1、master节点172.22.136.146创建用于同步的账号repdev3，修改postgresql.conf文件和pg_hba.conf文件
create user repdev3 SUPERUSER LOGIN password '123456'; pg_hba.conf文件新增如下
host replication repdev3 172.22.136.147 md5 postgresql.conf修改如下
wal_level=replica max_wal_senders = 2 wal_keep_segments = 256 2、重启master节点
3、在slave节点172.22.136.147执行psql看是否可以连接master节点
psql -h172.22.136.146 -p 5432 -U repdev3 -d postgres -W 4、在slave节点172.22.136.147，删除$PGDATA目录下所有文件，否则pg_basebackup过程会报错pg_basebackup: directory “/XX” exists but is not empty
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a0dafcb423566135545cf055e3a0e73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ae1d7ec4606d7dec749ce591fe012f/" rel="bookmark">
			【Android Gradle 插件】Android Studio 工程 Gradle 构建流程 ② ( settings.gradle 构建脚本分析 | 根目录下 build.gradle 分析 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、settings.gradle 构建脚本分析1、Maven 远程仓库配置2、目录配置3、完整代码示例 二、根目录下 build.gradle 构建脚本分析 一、settings.gradle 构建脚本分析 1、Maven 远程仓库配置 pluginManagement 脚本块 ,
用于 配置 Gradle 插件的 Maven 仓库 ,配置的是 构建过程 中 , 使用的仓库 ; dependencyResolutionManagement 脚本块 ,
用于 配置 依赖 的 Maven 仓库 ,配置的是 工程 或 模块 下的依赖使用的仓库 ; 在 dependencyResolutionManagement 脚本块 中 定义的 repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) 代码的含义是 解析依赖时 , 只能使用本脚本块中的 Maven 仓库 , 不能使用 Module 子项目中的依赖 ;
repositoriesMode 模式有两种 :
RepositoriesMode.PREFER_PROJECT : 解析依赖库时 , 优先使用本地仓库 , 本地仓库没有该依赖 , 则使用远程仓库 ;RepositoriesMode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40ae1d7ec4606d7dec749ce591fe012f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ccb99efdc654505004fd612e7632c98/" rel="bookmark">
			Running cells with Python 3.7 requires ipykernel installed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pip uninstall ipykernel
pip install ipykernel 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f626b5bba5e24091add6892bbf42758f/" rel="bookmark">
			FirewallD is not running[Linux防火墙操作]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：防火墙开放端口
firewall-cmd --add-port=6379/tcp --permanent （作用域是public，开放tcp协议的6379端口，一直有效）
firewall-cmd --reload （更新防火墙）
提示错误FirewallD is not running
执行查看防火墙状态命令： systemctl status firewalld
（dead）防火墙未开启。
二：开启防火墙
systemctl start firewalld （开启防火墙）
systemctl status firewalld （查看防火墙状态）
三：再次执行开放端口命令
firewall-cmd --add-port=6379/tcp --permanent （作用域是public，开放tcp协议的6379端口，一直有效）
firewall-cmd --reload（更新防火墙）
提示成功
四：补充关闭防火墙
systemctl stop firewalld（关闭防火墙）
systemctl status firewalld（查看防火墙状态）
firewall-cmd --zone=public --list-ports(查看所有开放端口)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af12b1638198fd7b409672672e5e740/" rel="bookmark">
			二维数组与稀疏数组之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA实现二维数组与稀疏数组之间的转换 一、什么是稀疏数组？ 稀疏数组(Sparse array) ，所谓稀疏数组就是数组中大部分的内容值都未被使用（或都为零），在数组中仅有少部分的空间使用。因此造成内存空间的浪费，为了节省内存空间，并且不影响数组中原有的内容值，我们可以采用一种压缩的方式来表示稀疏数组的内容。
二、稀疏数组应用场景 **基本使用场景介绍：**当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。
**举例：**假设你需要用程序记录如下一张11*11的棋盘，其中用数字1代表白子，数字2代表黑子。我们可以很明显想到用二维数组去存储棋盘数据。
使用二维数组存储如上数据的缺点：
int[][] chessArr1 = new int[11][11]; 使用二维数组我们需要创建一个占用11*11*4字节的内存空间去存储，而就这张棋盘数据来看，实际对我们有用的数据只有4*4个字节内存空间，很明显，这极大的浪费了内存空间。于是我们就引出了使用稀疏数组的存储方式去存储如上棋盘数据。
稀疏数据的记录方式：
稀疏数组第一行记录数组一共有几行几列以及共有多少个需要记录的数据把有值位置的行、列对应的值都记录起来，只记录有下子的位置，从而节约内存空间。 从上述结果看来，使用稀疏数组记录棋盘数据，仅仅只需要5*3*4个字节的内存空间。
三、实现思路 ①二维数组转稀疏数组的思路及方法实现 思路：
遍历整个二维数组，获取有效值的个数，记录为sum
通过sum确定稀疏数组的长度，并创建稀疏数组
int[][] sparsArr = new int[sum + 1][3]; 获取二维数组的行列数和有效值数，赋值给稀疏数组的第一行
然后再次遍历整个稀疏数组，获取有效值的位置和值，赋值给稀疏数组。
代码实现：
/** * 实现将二维数组转换为稀疏数组 * * @param towDimen 传入的二维数组 * @return 返回的稀疏数组 */ public int[][] towDimenToSparse(int[][] towDimen) { int sum = 0; // 用于记录有效值的个数 // 遍历整个二维数组，获取有效值的个数 for (int[] row : towDimen) { for (int data : row) { if (data !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9af12b1638198fd7b409672672e5e740/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083228f28900d9f74c0237649d7c86dd/" rel="bookmark">
			PHP初级教程------------------（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
运算符
赋值运算符
算术运算符
比较运算符
逻辑运算符
连接运算符
错误抑制符
三目运算符
自操作运算符
​编辑
计算机码
位运算符
运算符优先级
流程控制
控制分类
顺序结构
分支结构
If分支
​ Switch分支
循环结构
For循环
while循环
do-while循环
循环控制
​ 流程控制替代语法
运算符 运算符：operator，是一种将数据进行运算的特殊符号，在PHP中一共有十种运算符之多。
赋值运算符 赋值运算：符号是“=”，表示将右边的结果（可以是变量、数据、常量和其它运算出来的结果），保存到内存的某个位置，然后将位置的内存地址赋值给左侧的变量（常量）。
算术运算符 算术运算：基本算术操作
+：执行数据累加
-：数据相减
*：键盘上没有乘法符号，使用*代替，两个数相乘
/：正斜杠代替，表示两个数相除
%：取余（模）运算，两个数（整数）相除，保留余数
在进行除法运算或者取余运算的时候，对应的除数（第二个数）不能为0
比较运算符 比较运算：比较两个数据的大小，或者两个内容是否相同，返回的结果都是布尔类型：满足返回true，不满足返回false
&gt;：左边大于右边，返回结果true
&gt;=：左边大于等于右边
&lt;：左边小于右边
&lt;=：左边小于或者等于右边
==：左边的与右边的相同（大小相同）
!=：左边的与右边的不同（大小不同）
===：全等于，左边与右边相同：大小以及数据的类型都要相同
!==：不全等于，只有大小或者类型不同
逻辑运算符 逻辑运算：针对不同的结果进行匹配。满足条件返回true，不满足返回false
&amp;&amp;：逻辑与，左边的条件与右边的条件同时成立（两边结果都为true）
||：逻辑或，左边的条件或者右边的条件只要有一个满足即可
！：逻辑非，对已有条件进行取反，本身为true，取反结果就是false
逻辑与和逻辑或又称之为短路运算：如果第一个表达式结果已经满足条件了，那么就不会运行逻辑运算符后面的表达式：在书写代码的时候，尽量将出现概率最高的（能够直接判断出结果）的表达式放到第一位
连接运算符 连接运算：是PHP中将多个字符串拼接的一种符号
. ：将两个字符串连接到一起
.= ： 复合运算，将左边的内容与右边的内容连接起来，然后重新赋值给左边变量
A .= b 就变成了 A = A .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/083228f28900d9f74c0237649d7c86dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e8e29e19601d9d7f80eaf83fe842286/" rel="bookmark">
			一种基于mysql实现分布式锁的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 分布式锁，即分布式系统中的锁。在单体应用中我们通过锁解决的是控制共享资源访问的问题，而分布式锁，就是解决了分布式系统中控制共享资源访问的问题。与单体应用不同的是，分布式系统中竞争共享资源的最小粒度从线程升级成了进程。
目前比较常见的实现分布式锁的方式主要有三种：基于数据库实现、基于Zookeeper实现、基于redis实现。本文主要介绍了一种基于mysql数据库实现分布式锁的方式，从最简单的实现方式开始，一步步构造一个拥有基本分布式锁条件的程序。
版本1 mysql有两种实现分布式锁的思路，乐观锁和悲观锁，本文利用悲观锁方式实现。
select * from tableName where key = " " for update 在InnoDB下如果key为索引，则会为该行加上排他锁，若其它线程想获得排他锁则会阻塞。
伪代码：
where(true){ select ... for update if(记录存在) //业务逻辑 return； else inset ... } commit; 如上的版本会产生两个问题：
insert时通过唯一键重复报错，处理错误形式不和由于间隙锁原因，并发插入会引发死锁 版本2 为了解决上一版本的问题，本文引入中央锁的概念，也同时加入了数据库锁表和状态位。
创建数据库锁表，插入中央锁记录-- 锁表，单库单表 CREATE TABLE IF NOT EXISTS credit_card_user_tag_db.t_tag_lock ( -- 记录index Findex INT NOT NULL AUTO_INCREMENT COMMENT '自增索引id', -- 锁信息（key、计数器、过期时间、记录描述） Flock_name VARCHAR(128) DEFAULT '' NOT NULL COMMENT '锁名key值', Fcount INT NOT NULL DEFAULT 0 COMMENT '计数器', Fdeadline DATETIME NOT NULL DEFAULT '1970-01-01 00:00:00' COMMENT '锁过期时间', Fdesc VARCHAR(255) DEFAULT '' NOT NULL COMMENT '值/描述', -- 记录状态及相关事件 Fcreate_time DATETIME NOT NULL DEFAULT '1970-01-01 00:00:00' COMMENT '创建时间', Fmodify_time DATETIME NOT NULL DEFAULT '1970-01-01 00:00:00' COMMENT '修改时间', Fstatus TINYINT NOT NULL DEFAULT 1 COMMENT '记录状态，0：无效，1：有效', -- 主键（PS：总索引数不能超过5） PRIMARY KEY (Findex), -- 唯一约束 UNIQUE KEY uniq_Flock_name(Flock_name), -- 普通索引 KEY idx_Fmodify_time(Fmodify_time) )ENGINE=INNODB DEFAULT CHARSET=UTF8; 伪代码： select from tableName where key = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e8e29e19601d9d7f80eaf83fe842286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c99d1e99725a00c3b6bf4d26d180088/" rel="bookmark">
			百鸡百钱【枚举算法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
百鸡百钱是中国古代数学家张丘建在《算经》一书中提出的数学问题：
鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？
含义：公鸡每只单价为5，母鸡每只单价为3，小鸡三只总价为1；如果买100只鸡的价钱恰好为100，那么其中的公鸡、母鸡、小鸡数量分别是多少？
经过计算，有四种情况可以满足百鸡百钱（鸡的数量可以为0）
公鸡母鸡小鸡02575418788118112484 现在将问题推广到一般情况：输入鸡的总数n和总价m（1≤m,n≤200），计算公鸡、母鸡、小鸡的数量各是多少？
输入
鸡的总数n和总价m（1≤m,n≤200）
输出
公鸡、母鸡、小鸡的数量，之间有一个空格（测试数据确保至少有一组解）
如果有多组解满足条件，要求每一组解占一行，并按照公鸡，母鸡，小鸡数量的升序输出
样例输入 Copy
100 100 样例输出 Copy
0 25 75 4 18 78 8 11 81 12 4 84 #include&lt;stdio.h&gt; int main() { int x,y,z,a,b,i; scanf("%d %d",&amp;a,&amp;b); for(x = 0;x &lt;= a;x++) for(y = 0;y &lt;= a;y++){ z = a - x - y; if(5*x + 3*y + z/3.0 == b) { printf("%d %d %d\n",x,y,z); } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d84878a8255863295260c159c93dc5f7/" rel="bookmark">
			防火墙功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口类型 物理接口
物理接口是指设备的硬件接口，其参数包括∶接口名称、接口状态、接口当前工作模式、接口自协商模式等;可以根据MAC地址表进行数据帧转发及三层路由转发功能。
子接口
子接口的名称是它来源的接口名字的扩展，例如ge0.2。DBAPPOS支持以下类型子接口∶以太网子接口、聚合子接口。
网桥接口
网桥接口是指设备的物理接口工作在网桥模式，负责二层（数据链路层)报文的转发﹔其中一个网口收到的报文会经FDB表转发或被复制给其他网口并发送出去。以使得网口之间的报文能够互相转发。
聚合接口
聚合接口是物理接口的集合，一个聚合可以包含1到16个物理接口。这些物理接口平均分担该聚合接口IP地址的流量负载。因此聚合接口可以提高单个IP地址可用带宽。如果聚合接口中的一个物理接口出现故障，不能工作，其他接口可以继续处理流量，只是可使用的带宽变小了。
隧道接口
lunnel接口主要用于报文的封装和解封装，常见的封装协议为GRE、JPSec和lPv6lP。隧道接口充当VPN通道的入口。流量通过隧道接口进出VPN通道。隧道接口只能是三层接口。
无线接口
无线接口作为设备的外置接口，支持通过USB口插入4G网卡的方式接入。
安全策略基础 策略是网络安全设备的基本功能。默认情况下，安全网关会拒绝设备上所有接口之间的信息传输。而策略则通过策略规则决定从一个接口到另一个接口的哪些流量该被允许，哪些流量该被拒绝。
策略规则的基本元素
策略规则允许或者拒绝从一个(多个）接口到另一个(多个）接口/从一个地址段到另一个地址
段的流量。流量的类型、流量的源安全域/源地址与目的安全域/目的地址以及行为构成策略规则的基本元素。
lF_IN/SIP ——流量的源接口或源安全域/源地址。lFOUT /DIP ——流量的目的接口或目的安全域/目的地址。SERVICE–流量的服务对象。USER ——流量的用户对象。APPLICATION——流量的应用对象。SCHEDULE ——流量的时间对象。Action ——安全设备在遇到指定类型流量时所做的行为，包括允许（Permit )、拒绝（Deny )。ID ——-安全策略的唯一标识。 安全策略的匹配原则
策略匹配顺序:
一从列表由上至下(不是按照ID号大小匹配）根据流量的过滤条件进行匹配，系统会对流量按 照找到的第一条与过滤条件相匹配的策略规则进行处理。
系统缺省的策略是拒绝所有流量。
调整策略规则位置-WebUI配置
通过WebUI调整策略规则位置，在IPv4安全策略规则编辑页面选择&lt;优先级&gt;:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b05259e8ca6ce3f915fd49a03bfc95/" rel="bookmark">
			Modbus规约格式分析与总结（数据帧示例超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modbus概述 Modbus通信协议由Modicon公司(现已经为施耐德公司并购，成为其旗下的子品牌)于1979年发明的，是全球最早用于工业现场的总线规约。由于其免费公开发行，使用该协议的厂家无需缴纳任何费用，Modbus通信协议采用的是主从通信模式(即Master/Slave通信模式)，其在分散控制方面应用极其广泛，从而使得Modbus协议在全球得到了广泛的应用。
Modbus通信协议具有多个变种，其具有支持串口(主要是RS-485总线)，以太网多个版本，其中最著名的是Modbus RTU,Modbus ASCII和Modbus TCP三种。其中Modbus RTU与Modbus ASCII均为支持RS-485总线的通信协议，其中Modbus RTU由于其采用二进制表现形式以及紧凑数据结构，通信效率较高，应用比较广泛。而Modbus ASCII由于采用ASCII码传输，并且利用特殊字符作为其字节的开始与结束标识，其传输效率要远远低于Modbus RTU协议，一般只有在通信数据量较小的情况下才考虑使用Modbus ASCII通信协议，在工业现场一般都是采用Modbus RTU协议，一般而言，大家说的基于串口通信的Modbus通信协议都是指Modbus RTU通信协议。
上面是百度百科对于modbus的解释，我理解的modbus，是一种工业上最为简洁的协议，能够很好的将实时数据从一个设备传输到它的采集器。当然它的优势也就只有简洁了，轮询的方式发送请求帧来请求数据，数据量稍微一大会造成实时数据很大的延时，因为一帧最多请求128个寄存器，还要考虑主站处理请求帧的延时，以及硬件线路延时等等，延时会更大。现在电力行业在数据采集上有更好的协议替代它，如104跟61850等都已经具备了主站变位主动上报的功能，这样就大大提高了数据采集的实时性。104跟61850后续再细说，本次重点关注modbus
Modbus协议名称解释 功能码：功能码在modbus协议用于表示信息帧的功能，常用的功能码有03，04，06，16等，其中03功能码的作用是读保持寄存器内容，04功能码的作用是读输入寄存器内容，06功能码的内容是写单个保持寄存器，16功能码的内容则是写多个保持寄存器。
输入寄存器和保持寄存器：04功能码的作用就是读输入寄存器，而03功能码的作用则是读保持寄存器，很多人在看到这两个功能码的时候总是希望找到这两个功能码的区别，保持寄存器和输入寄存器到底是什么区别，modbus协议最开始是用来解决PLC的通信协议问题的，主要用于输入输出数字量信号以及模拟量信号，所谓的输入寄存器就是从模拟量信号输入引申出来的，即输入寄存器只能从模拟量信号输入端改变寄存器，而主机则不能通过下发指令改变输入寄存器的数据，而保持寄存器则是用于输出模拟量信号的，主机是可以改变寄存器数据，也就是说对于主机而言，输入寄存器是只读的，而保持寄存器是可以读写的，当主机用06，16功能码的指令去预置输入寄存器的时候，设备会返回一个代码为0x81的错误代码，即企图写只读寄存器。
Modbus中的数据地址格式：在Modbus协议中，经常会出现类似于3xxxx,4xxxx寄存器，这个表示的是寄存器支持的数据类型。Modbus数据地址格式是从0开始，比如以下一个寄存器40009，即表示保持寄存器，寄存器地址为00 08，类似的数据地址格式经常在组态软件以及PLC系统中用到。
Modbus RTU/ASCII/TCP：Modbus协议最开始是用于可编程逻辑控制器(PLC)之间的通讯，由于其具有的开放性，大量的用于现场智能仪表。Modbus协议有多个变种，其中最著名的是Modbus RTU/Modbus ASCII和Modbus TCP通信协议。其中RTU/ASCII协议是基于串行口通信，而TCP协议则是基于以太网通信。
Modbus错误代码表：modbus有功能码，校验码，异常功能码和错误代码，其中异常功能码和错误代码非常容易混淆，一般来说异常功能码指的是某个功能码执行的时候出现的相应异常功能码，一般都是在功能码的基础上加上0x80，比如03功能码出现的异常码是0x83异常功能码，16功能码对应出现的异常功能码则是0x90,而错误代码则是表示出现错误的具体情况，比如寄存器地址不存在，不管是读还是写，如果该寄存器地址不存在的话，错误代码为02。
其中物理离散量输入和输入寄存器只能有I/O系统提供的数据类型，即只能是由I/O系统改变离散量输入和输入寄存器的数值，而上位机程序不能改变的数据类型，在数据读写上表现为只读，而内部比特或者物理线圈和内部寄存器或物理输出寄存器(保持寄存器)则是上位机应用程序可以改变的数据类型，在数据读写上表现为可读可写。
下发指令：01 10 01 8E 00 01 02 00 00 69 BE（向寄存器0x018E写入一个数值为0的数据)
正确回应指令：01 10 01 8E 00 01 60 1E(向寄存器地址0x018E写操作一个寄存器）
错误回应指令：01 90 01 8D C0（写操作非法功能，可能是向输入寄存器写数据）
注：异常功能码为在原来功能码的基础上机上80H，异常回复报文的主要内容就是错误码，不同错误码代表含义不同
Modbus RTU/TCP协议 Modbus TCP协议则是在RTU协议上加一个MBAP报文头，由于TCP是基于可靠连接的服务，RTU协议中的CRC校验码就不再需要，所以在Modbus TCP协议中是没有CRC校验码。
RTU数据格式： 主机请求消息
[03][03][00][00][00][0A][C4][2F]
Slave id(BIT0)
Function(BIT1)
addr(BIT2、BIT3)
nb(BIT4、BIT5) 请求的数据大小
CRC(BIT6、BIT7)
从机回复消息
03 03 14 00 01 00 02 00 03 00 04 00 05 00 06 00 07 00 08 00 09 00 0A 16 6F
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6b05259e8ca6ce3f915fd49a03bfc95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee486bd693f4132e6a74d3026416bbc5/" rel="bookmark">
			css单行文本溢出显示省略号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用CSS中的text-overflow属性来实现单行文本溢出显示省略号。
具体实现步骤如下：
首先，将需要显示省略号的元素的宽度设置为固定值或最大宽度。 .ellipsis { width: 200px; /* 或者 */ max-width: 200px; } 接着，使用white-space属性将元素的文本内容强制放在一行中，防止换行。 .ellipsis { white-space: nowrap; } 然后，使用overflow属性将超出元素宽度的文本内容进行隐藏。 .ellipsis { overflow: hidden; } 最后，使用text-overflow属性将超出元素宽度的文本内容显示为省略号。 .ellipsis { text-overflow: ellipsis; } 完整的代码如下所示：
.ellipsis { width: 200px; max-width: 200px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } 这样就可以让单行文本溢出时显示省略号了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39218a7b1a00bdc7686eda8fb0e71820/" rel="bookmark">
			逻辑回归（Logistic Regression）测试实例：糖尿病预测项目（不调库，手工推）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据来源 1.数据来源：kaggle
2.数据样式
通过模型训练后，对测试集的前5列（Pregnancies、Glucose、BloodPressure、SkinThickness、Insulin、BMI、DiabetesPedigreeFunction、Age）数据进行预测，判断最后一列（Outcome）的数值，1表示患病，0表示未患病
二.使用方法 逻辑回归（Logistic Regression）
方法说明:
逻辑回归函数：
其中：
损失函数：
梯度下降法：
其中：为自定义的学习比率
三.代码实现 从数据读取开始，不调取三方库，纯手工推。
导入基础库
from random import seed,randrange from csv import reader from math import exp 读取csv文件，将字符串内容转换为浮点型
def csv_loader(file): dataset=[] with open(file,'r') as f: csv_list=reader(f) for row in csv_list: if not row: continue dataset.append(row) return dataset def str_to_float_converter(dataset): dataset=dataset[1:] for i in range(len(dataset[0])): for row in dataset: row[i]=float(row[i].strip('')) 数据标准化（Min-Max标准化）
因为数据之间的量纲不一样，需要进行无量纲处理。
def min_max(dataset): min_max_list=[] for i in range(len(dataset[0])): col_value=[row[i] for row in dataset] min_value=min(col_value) max_value=max(col_value) min_max_list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39218a7b1a00bdc7686eda8fb0e71820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892fc8650c1131bc8aa50b8588945a61/" rel="bookmark">
			docker部署ftp，java连接踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载镜像
docker pull fauria/vsftpd 启动容器
docker run -d --network=host -v /app/deploy/ftp:/home/vsftpd -e FTP_USER=ftp -e FTP_PASS=123456 --name vsftpd --restart=always fauria/vsftpd 注意此处不需要端口映射，之前我只映射了，20，21，22等端口发现，可以连接上ftp但是无法打开目录上传下载文件
使用java连接ftp
&lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;3.6&lt;/version&gt; &lt;/dependency&gt; private static final Logger logger = LoggerFactory.getLogger(FtpServiceImpl.class); // ip地址 @Value("${ftp.client.host}") private String host; // 端口号 @Value("${ftp.client.port}") private Integer port; // 用户名 @Value("${ftp.client.username}") private String username; // 密码 @Value("${ftp.client.password}") private String password; // session链接超时时间 @Value("${ftp.client.sessionConnectTimeout:15000}") private Integer sessionConnectTimeout; // channel链接超时时间 @Value("${ftp.client.channelConnectedTimeout:15000}") private Integer channelConnectedTimeout; /** * 检查SFTP目录或文件是否存在 * * @param remotePath * @return */ @Override public boolean checkFileExist(String remotePath) { FTPClient ftpClient = loginFtp(); try { ftpClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/892fc8650c1131bc8aa50b8588945a61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00b66e1dffc3cf170bf12c11cdc61011/" rel="bookmark">
			黑群手残升级出级不能启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESXI新建PE系统，挂载硬盘，进入PE后打开 diskgenius分区工具。
删除.syno下面的patch文件夹
删除etc和ext.defaults目录下的VERSION文件
​
有多少个这种分区就每个分区里面都要删除上述文件
（多盘RAID的情况下，每个硬盘都会有这个分区的，内容差不多）。
esxi系统中删除DSM622引导，重新上传引导文件。
启动系统，选择第三个引导项（带ESXI的选项），其他项会导致群晖找不到直通的硬盘。
恢复DS3617_6.23-25426（不能破解abb套件）工具包，见百度盘ds3617_6.23恢复包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48157cd72e9cf73206290c73ba83d6c3/" rel="bookmark">
			ssh_exchange_identification: Connection closed by remote host
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 最近虚拟机经常性的无法连接，小部分时候能尝试登上，大部分时候直接就返回ssh_exchange_identification: Connection closed by remote host。
问题解决流程 使用sudo netstat -tnpa | grep 'ESTABLISHED.*sshd'查看主机上ssh的连接情况，发现有很多未知的连接，而且主要是四台机器发起。推测因为这些连接数过多，导致无法新建其他的ssh连接。
直接将这几个IP封掉了sudo iptables -I INPUT -s 需要封掉的IP地址 -j DROP，后续连接就正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bbde30ab1ba825c95f209167287a12a/" rel="bookmark">
			Collectors.toMap 根据字段去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Collectors.toMap
map.merge
list.stream() // Collectors.toMap去重 // 将list转为map .collect(Collectors.toMap( // id为key Entity -&gt; entity.getId(), // 实体对象为value // Function.identity() 返回和输入相同的 等同于 t-&gt;t Function.identity(), // 先从map中get(第一个参数key), // 如果get的value为null,put(key,value), // 如果get的value不为空则根据(o,n)-&gt;o选择 新/旧 的value, 再put(k,v) (oldValue, newValue) -&gt; oldValue)) // 收集map的value集合 .values().stream().collect(Collectors.toList()); 可以理解为
Map&lt;Long, Entity&gt; map = new HashMap&lt;&gt;(); for (Entity entity : list) { map.putIfAbsent(entity.getId(), entity); } entityList = map.values().stream().collect(Collectors.toList()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb1831d421ae805833693183aa9739a/" rel="bookmark">
			「Redis」07 持久化操作（RDB、AOF）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记整理自【尚硅谷】Redis 6 入门到精通 超详细 教程
Redis——持久化操作（RDB、AOF） 1. RDB（Redis DataBase） 概述 RDB是什么
在指定的时间间隔内将内存中的数据集快照写入磁盘， 即 Snapshot 快照，恢复时是将快照文件直接读到内存里。 备份是如何执行的
Redis 会单独创建一个子进程（fork）来进行持久化会先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件替换上次持久化好的文件（内容覆盖到 dump.rdb）。整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。 Fork 作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程
在 Linux 程序中，fork() 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，Linux 中引入了 “写时复制技术”
一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程
RDB持久化流程
redis.conf dump 文件名字
在 redis.conf 中配置文件名称，默认为 dump.rdb。
dump 保存位置
rdb 文件的保存路径可以修改。默认为 Redis 启动时命令行所在的目录下。
stop-writes-on-bgsave-error
当 redis 无法写入磁盘，直接关闭 redis 的写操作。推荐 yes。
rdbcompression 压缩文件
对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis 会采用 LZF 算法 进行压缩。
如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能。推荐 yes。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cb1831d421ae805833693183aa9739a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/54/">«</a>
	<span class="pagination__item pagination__item--current">55/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/56/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>