<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="老帅的博客">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="老帅的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55247f1d177fe5878ba7c5e40e917215/" rel="bookmark">
			打字通小游戏制作教程：用HTML5和JavaScript提升打字速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟 前言
欢迎来到我的技术小宇宙！🌌 这里不仅是我记录技术点滴的后花园，也是我分享学习心得和项目经验的乐园。📚 无论你是技术小白还是资深大牛，这里总有一些内容能触动你的好奇心。🔍
🤖 洛可可白：个人主页
🔥 个人专栏：✅前端技术 ✅后端技术
🏠 个人博客：洛可可白博客
🐱 代码获取：bestwishes0203
📷 封面壁纸：洛可可白wallpaper
文章目录 打字通小游戏制作教程：用HTML5和JavaScript提升打字速度体验地址准备工作创建HTML结构添加CSS样式编写JavaScript逻辑测试游戏全部代码🎉 结语🎉 往期精彩回顾 打字通小游戏制作教程：用HTML5和JavaScript提升打字速度 在这篇文章中，我们将一起学习如何使用HTML5和JavaScript来制作一个简单的打字通小游戏。这个小游戏可以帮助用户练习打字速度和准确性。通过这个教程，你将了解如何创建游戏界面、处理用户输入、实现倒计时以及计算得分。即使你是编程新手，也能跟随步骤完成这个项目。
体验地址 洛可可白⚡️打字通
准备工作 首先，确保你的计算机上安装了文本编辑器，如Notepad++、Sublime Text或Visual Studio Code。这些工具将帮助你编写和编辑代码。
创建HTML结构 打开你的文本编辑器，创建一个新的HTML文件，并输入以下代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;洛可可白打字通&lt;/title&gt; &lt;style&gt; /* 在这里添加CSS样式 */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="bigBox"&gt; &lt;div class="container"&gt;你准备好了吗？&lt;/div&gt; &lt;textarea placeholder="开始输入..." style="resize: none" cols="30" rows="10"&gt;&lt;/textarea&gt; &lt;div class="operate"&gt; &lt;button&gt;开始&lt;/button&gt; &lt;div id="timer"&gt;60&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 在这里添加JavaScript代码 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这是我们游戏的基本结构。&lt;head&gt;部分包含了页面的元数据和样式定义，&lt;body&gt;部分则是游戏的主要内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55247f1d177fe5878ba7c5e40e917215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc7c19558b05e9b8f6bd06c6ff5e23d/" rel="bookmark">
			ORACLE 11G R2 PSU 补丁升级过程-SinoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. psu 概述
Oracle PSU的全名是Patch Set Update，是Oracle对于发行的官方补丁包，包含了bug的修复。Oracle选取被用户下载数量多，且被验证过具有较低风险的补丁放入到每个季度的PSU中。在每个PSU中不但包含Bug的修复而且还包含了最新的CPU。PSU通常随CPU一起发布。
在新部署环境建议打上最新的补丁包
2. 升级环境描述
本次升级基本环境如下：
数据库版本
系统版本
升级psu版本
patch文件名
oracle 11.2.0.4
redhat 7.4
11.2.0.4.190416 p29255947
2016年1月份推出对PSU、SPU、Bundle Patch新的命名规则。 新的命名规则为（以11.2.0.4为例）：11.2.0.4.YYMMDD ，YYMMDD为主要patch （PSU、SPU、Bundle）发布的具体日期年份后两位、两位的月份以及两位的日期。如：11.2.0.4.190416表示这11.2.0.4的PSU 是在19年4月16日推出的patch。
3. 升级详细步骤
此升级oracle psu详细步骤如下：
[root@zfbadb1]mkdir /patch
[root@zfbadb1]mv p6880880_112000_Linux-x86-64.zip p29255947_112040_Linux-x86-64.zip /patch/
[root@zfbadb1]cd /u01/app/11.2/grid/
[root@zfbadb1]mv OPatch OPatch_bak
[root@zfbadb1]unzip /patch/p6880880_112000_Linux-x86-64.zip -d ./
[root@zfbadb1]chmod -R 777 OPatch
[root@zfbadb1]chown -R grid:oinstall OPatch
ll OPatch*
OPatch:
total 176
drwxr-x--- 6 grid oinstall 4096 Jun 13 17:54 auto
drwxr-x--- 2 grid oinstall 4096 Jun 13 17:54 config
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dc7c19558b05e9b8f6bd06c6ff5e23d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730472aba34539dc5a332376cf882ba4/" rel="bookmark">
			华为云平台部署虚拟机-SinoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常运维中经常需要在华为云平台上部署虚拟机，涉及操作系统类型比较多，为了提高虚拟机部署效率，我们通常会把镜像文件做成虚拟机模版，下面是虚拟机模版创建及部署的过程，希望能给大家带来一些借鉴。
一、注册镜像文件 登录华为云SERVICEOM平台，点击“服务列表”--&gt;“镜像资源”
点击“注册镜像”
填写镜像的相关信息
注册成功之后，可以在管理镜像里找到镜像文件的名称。
二、创建虚拟机 等待完成。
点击“服务列表”--&gt;“计算资源”
查看创建好的虚拟机
通过VNC的方式登录虚拟机
登录虚拟机后，开始安装操作系统
登录系统，安装UVP VMTools工具。
1、在已安装的Linux虚拟机中，使用root帐户分别执行如下命令，将镜像文件虚拟机。 mkdir -p /mnt/image-tools
mount /dev/sr1 /mnt/image-tools
mkdir -p /opt/image-tools
cp -r /mnt/image-tools/linux /opt/image-tools
cd /opt/image-tools/linux
chmod +x *.sh
umount /mnt/image-tools
2、在Service OM界面卸载ISO文件。 在弹出的ISO挂载框中，单击“卸载ISO”，卸载ISO文件。
3、挂载并安装UVP VMTools 在已登录的Service OM界面，单击已创建的镜像虚拟机名称，进入概要界面。单击界面右上角“更多 &gt; 挂载UVP VMTools”，使用root帐户在Linux虚拟机中执行如下命令，安装UVP VMTools。
cd /opt/image-tools/linux
./install-vmtools.sh
当出现以下回显时，表示UVP VMTools已安装成功。
The UVP VMTools is installed successfully.
Reboot the system for the installation to take effect.
Successfully installed vmtools.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/730472aba34539dc5a332376cf882ba4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73444175794bf99b379f660052a3d858/" rel="bookmark">
			“微盟事件”星瑞格（Sino-DB）产品解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 背景
1.1、事件始末
微盟是成立于2013年的智能商业服务商，2019年1月港股上市。集团有两大业务：SaaS产品和精准营销。商户使用其SaaS产品在社交媒体平台上开设个性化店面并管理主要数字商务营运，包括产品展示、订单获取及支付流程、客户关系管理及社交媒体运营。微盟集团财报运营数据显示，截至2019年6月30日，其SaaS付费用户数为7万户。
2月24日，有商户反应，微盟的SaaS业务服务突然宕机，商铺后台的所有数据被清零。
次日，微盟集团发布公告，称已启动紧急响应机制，并与腾讯云技术团队一起研究制定生产环境和数据修复方案。此次数据库遭破坏是人为，公司SaaS业务数据遭研发中心运维部核心运维人员贺某“因个人精神、生活等原因对微盟线上生产环境进行了恶意的破坏”。公司已于2月24日向上海宝山区公安局报案，通过登录账号及IP地址追踪，定位并找到了犯罪嫌疑人，其迅速承认了犯罪事实，并被刑事拘留。
2月27日下午，微盟创始人孙涛勇对该事件回应称，事后通过警方了解，该员工一直深陷网络贷，还曾有过轻生。春节期间只能一个人在房间独处30多天，再加上本身经济上的困扰，就做出了这样的举动，事后他也说跟公司无任何仇恨。
1.2、影响
在3月3日发布的公告中，微盟公布了具体的赔付方案，拟定了现金赔付计划和流量赔付计划供商家选择，共计1.5亿元赔付拨备金，其中公司承担1亿元，管理层承担5000万元。
值得注意的是，“未来微盟可能面临多方困难，”国泰君安证券则在同一天发布的研报中表示，“复修时间不可控，营运成本上升，客户/商家将考虑换到其它平台，将面临更多或巨额赔赏，流失潜在客户给竞争对手等。”
1.3、启示
回顾“微盟删库”事件，有几点值得我们警醒：
（1）首先，微盟在内部人员管理上存在漏洞。
如果企业能有效进行建立数据重要程度分级权限管理制度，就不会出现一个运维人员，能够直接操作并删除公司的核心数据。其实除了这种“越权使用、权限滥用”现象，还有其他各种内部员工的不规范操作普遍存在：表现为：企业存在多位运维人员，或者外包第三方，权限管理混乱，对维护人员的操作监控失效；离职员工的后门；以上原因都致使安全事件发生时，无法追溯并定位真实的操作者。
其实类似“微盟删库事件”这样，由于内部员工即合法授权者的非法或可疑访问活动而导致企业重要数据泄露的情况早已屡见不鲜，。
比如Verizon Communications(威尔逊电信)数据泄露事件：2017年6月份，美电信巨头Verizon的600万用户数据被泄露，但直到7月Verizon才证实这一消息，并在一份声明中称数据泄漏是由该公司供应商的一名员工造成。因操作失误导致外部可进入云存储区域访问信息，而这些数据是在没有保护的亚马逊S3存储服务器上泄漏的，这使得任何链接到云的人都可以使用这些数据。
数据泄露影响与危害，一方面给受害企业带来直接和间接的经济损失（违法巨额的罚款（如GDPR）、事后处理成本和名誉损失恢复成本）；另一方面发生大规模事件中绝大部分包括个人信息以及敏感数据，这给涉及的用户个人信息与隐私安全带来潜在的危害。
（2）其次，微盟的容灾备份恢复机制落后。
一家提供信息服务的公司，在数据被删除了，竟然需要用几天来恢复？据信，微盟公司是建立的混合云平台，也就是本地私有云平台和腾讯云混合运作，这次出问题的是本地私有云平台。一般数据备份，在本地全备份一次，随着业务运营，更多时候是在用差异备份和增量备份运作，被这个程序员删除数据前。这些差异备份或者增量备份数据量应该不会大到需要几天来恢复。
进一步的说，涉及到金融服务层面的公司，数据也不会只限于备份机制来解决数据安全问题。CDP系统是肯定应该有的，如果因为经济原因，做不到异地双活形式CDP，本地双活起码也要有，但是数据需要几天恢复，可以想象这家公司数据保护机制建设的落后。
由于疫情，在线下零售停摆的局面下，不少商家将运营活动全面转向线上，小程序商城的重要性不言而喻。而微盟系统宕机直接导致线上生产环境的破坏，一些商家的小程序商城被迫暂停使用，商家无法正常运营，其损失不仅仅用金钱可以衡量。
因此，如何应对人为误操作、软件错误、病毒入侵等“软”性灾害以及硬件故障、自然灾害等“硬”性灾害，在发生意外时，及时快速准确的恢复生产环境，对企业至关重要。需要企业加大重视，建立可靠的容灾备份机制。
二、解决方案
星瑞格为企业如何完善数据安全管理机制、加强灾备体系的建设，提供如下解决方案：
（1）星瑞格数据库安全审计系统dbAudit作为判断用户行为合法性的重要工具，成为保护企业核心数据安全的重要一环。旨在以用户为核心，建立一套严谨的责任追溯机制。通过主动审计，系统将进行海量数据的挖掘和迅速定位，对用户行为建立智能模型，自动判断是否符合法规政策和企业规范。实现主动告警、防攻击、防漏洞等功能，保护客户重要核心数据。
（2）星瑞格数据库管理系统SinoDB可满足各行业客户7*24业务不中断运行的高可用需求。可以根据客户的需求提供灵活的高可用性解决方案，保障客户的系统在发生故障或灾难时不受影响，无论是人为故障还是自然灾害。
（3）星瑞格数据实时复制软件SinoRepl可以做为一个低成本、低风险的数据库实时容灾解决方案, 如果因预算或其他因素无法使用HDR，RSS做为灾备数据库，可以采用SinoRepl将数据库实时复制到备库当作灾备应用。
2.1、dbAudit“数据防泄漏、责任可追溯”方案介绍
dbAudit能够稽核所有造访数据库的存取轨迹，追踪终端使用者的真实身份。并记录操作行为，厘清责任。
2.1.1、监控人员操作
①识别运维人员、外包商、特权用户等账户，管理数据库帐号使用权限。
②捕捉到真实的数据库用户、将前端真实用户与WEB操作进行关联。
③每日自动生成运维人员操作行为记录报表，监控操作行为,保留操作日志记录，可以溯源追查，厘清责任。
2.1.2、关注敏感数据
①敏感数据查找分类在大数据时代，数据利用与挖掘是主旋律。如何在数据安全合规和隐私保护前提下打破数据孤岛促进数据流动。“囚笼式管控”传统方式转变到“数据安全治理”思维，可利用敏感数据查找功能摸清企业敏感数据分布与流动态势，对重要数据进行重点关注。
② 跟踪敏感数据访问行为，及时发现敏感数据泄漏。
③ 生成敏感数据高频与大量访问报表。
2.1.3、 违规行为自动预警
①灵活定制告警策略：对于恶意的SQL注入行为、非法的业务登录、高危的SQL操作和过量的数据下载等各种违规行为，系统可以基于灵活的策略配置，设置风险规则，提供风险告警。
②多种告警方式：dbAudit的告警发送可以用email，短信发送，亦可通过Syslog或SNMP方式发送给安全管理中心接收软件与安管平台整合。
③事后处理：系统除了事中告警并记录违规行为，用户还可在事后进行事件管理，判断告警事件是否得到有效解决和重视。
2.1.4、主动防攻击和防漏洞
为了更好地保障个人信息安全避免相关数据泄露事件发生，对重要的数据资产服务器进行重点防护与安全配置检查，定期进行漏洞扫描与评估等措施。
2.2、SinoDB“高可用”方案介绍
SinoDB为我司具有完全自主知识产权的安全可靠数据库产品，支持国密算法，提供多层次数据加密，具备高可用性、金融级场景一致性和水平扩展能力，具有成熟的服务体系，提供99.99%的高水准服务等级(SLA)，能确保客户业务的连续性。 SinoDB提供了3种基于集群的高可用性解决方案，HDR(High availability Data Replication，高可用性数据复制)、RSS(Remote Standalone Secondary, 远程独立辅节点) 和SDS(Shared Disk Secondary, 共享磁盘辅节点)。
在集群中，主服务器和备服务器之间通过传输逻辑日志（或逻辑日志号）进行同步。用户无法控制数据复制的粒度；而是始终复制整个数据库服务器的数据。
集群中的服务器必须使用相同的 SinoDB 版本，运行在相同的操作系统、硬件和磁盘架构上。下表为 3 种高可用性方案的特征：
2.3、SinoRepl数据库实时容灾解决方案
SinoRepl前身为Oracle OGG for Informix，采用表级复制的方式，是事务日志+异步复制 (准实时)软件，可以实现在异构平台与异构数据库上复制数据。帮助企业实现以下目标：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73444175794bf99b379f660052a3d858/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da621cfe76ec6f910d32085b8893a146/" rel="bookmark">
			【WEEK2】 【DAY2】RestFul和Controller之Controller控制器【中文版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.3.5 Tuesday
目录 4.RestFul和Controller4.1.Controller控制器4.1.1.说明4.1.2.实现Controller接口1. 添加web支持（详见1.5）2. 添加lib依赖3. 新建web.xml4. 需要新建springmvc-controller.xml5. 实现controller接口6. 新建ControllerTest1.java7. 新建test.jsp文件（常规写法）8. 配置Tomcat运行9. 说明 4.1.3.使用注解@Controller1. 增加一个ControllerTest2类，使用注解实现2. 修改springmvc-controller.xml文件（仅修改一行：开启扫描）3. 运行4. 实现视图复用 4.1.4.RequestMapping1. 新建ControllerTest3.java2. 结果 4.RestFul和Controller 4.1.Controller控制器 4.1.1.说明 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。控制器负责解析用户的请求并将其转换为一个模型。在Spring MVC中一个控制器类可以包含多个方法。在Spring MVC中，对于Controller的配置方式有很多种。 4.1.2.实现Controller接口 新建模块springmvc-04-controller（详细操作见W1D21.5 新建并编写HelloServlet类，用于处理用户请求）
1. 添加web支持（详见1.5） 2. 添加lib依赖 （详见W1D53.1.8.配置tomcat，启动测试）
3. 新建web.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!--1.配置DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 配置文件的位置，是在resource文件夹下的文件名 --&gt; &lt;param-value&gt;classpath:springmvc-controller.xml&lt;/param-value&gt; &lt;!-- 这里仍然需要配置springmvc-controller.xml文件 --&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da621cfe76ec6f910d32085b8893a146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a385b5cb756ce5b4963769645d8f836/" rel="bookmark">
			2024 AI 辅助研发的新纪年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能技术的持续发展与突破，2024年AI辅助研发正成为科技界和工业界瞩目的焦点。从医药研发到汽车设计，从软件开发到材料科学，AI正逐渐渗透到研发的各个环节，变革着传统的研发模式。在这一背景下，AI辅助研发不仅提升了研发效率，降低了成本，更在某种程度上解决了复杂问题，推动了科技进步。2024年，随着AI技术的进一步成熟，AI辅助研发的趋势将更加明显，其潜力也将得到更广泛的挖掘和应用。
目录
AI辅助研发的技术进展
深度学习：
强化学习：
生成模型:
多模态技术：
可解释性人工智能：
行业应用案例
医药行业：
汽车行业：
电子行业：
面临的挑战与机遇
技术挑战：
模型可解释性：
伦理问题：
数据隐私和保护：
数据安全：
数据泄露和滥用：
未来趋势预测
AI与研发流程的深度融合：
智能研发平台的崛起：
小模型的广泛应用：
多模态AI模型的发展：
研发数字化：
辅助决策的知识管理：
AI应用的DevOps设施：
线上故障定位和问题解决：
AI辅助UI设计的涌现：
代码翻译与系统间翻译：
与法规的影响
人才培养与教育
AI辅助研发的技术进展 2024年，AI辅助研发领域可能会有以下技术突破和创新：
深度学习： 深度学习是机器学习的一个分支，是一种以人工神经网络为架构，对资料进行表征学习的算法。深度学习的好处是用非监督式或半监督式的特征学习和分层特征提取高效算法来替代手工获取特征。
目前，深度学习已被广泛应用于计算机视觉、语音识别、自然语言处理等领域，并取得了显著的成果。例如，在图像识别方面，深度学习可以实现对人脸、物体等的准确识别；在语音识别方面，深度学习可以实现对语音的准确识别和转换；在自然语言处理方面，深度学习可以实现对文本的分类、情感分析等。
随着技术的不断发展和数据的不断增加，深度学习的应用前景将会更加广阔。同时，深度学习也面临着一些挑战，如计算资源的需求、模型的可解释性等问题，需要不断地进行研究和改进。
强化学习： 强化学习是一种机器学习算法，主要用于解决决策问题。强化学习的核心思想是通过与环境进行交互，学习如何做出最优决策以获得最大的奖励。
强化学习在实际应用中有很多例子，以下是一些常见的例子：
游戏 AI：强化学习可以用于训练游戏 AI，使其能够在游戏中做出最优决策，例如在棋类游戏、电子游戏等中。机器人控制：强化学习可以用于机器人的控制，使机器人能够学会如何执行任务，例如抓取物体、避开障碍物等。推荐系统：强化学习可以用于推荐系统，通过学习用户的行为和反馈，为用户提供个性化的推荐。金融交易：强化学习可以用于金融交易，例如股票交易、期货交易等，通过学习市场数据和规律，做出最优的交易决策。 强化学习是一个非常活跃的研究领域，随着技术的不断发展和应用场景的不断拓展，强化学习将会在更多的领域得到应用。
生成模型: 生成模型是机器学习中的一种重要模型，它可以根据给定的输入数据生成输出数据。生成模型由数据学习输入和输出联合概率分布 P(x,y)，然后求出后验概率分布 P(y|x) 作为预测的模型。
目前，生成模型已经在多个领域得到了广泛的应用，例如自然语言处理、计算机视觉、音频处理等。随着技术的不断发展和数据的不断增加，生成模型的应用前景将会更加广阔。
生成模型的工作原理是通过对大量的数据进行学习，从而掌握数据的分布规律和特征。生成模型使用这些学到的知识来生成新的数据。
具体来说，生成模型通常使用一种称为“生成式对抗网络”（Generative Adversarial Network，GAN）的技术。GAN 由两个神经网络组成：生成器和判别器。生成器负责生成新的数据，而判别器则负责判断生成的数据是否真实。在训练过程中，生成器和判别器会不断地进行对抗，生成器试图生成尽可能真实的数据，而判别器则试图区分真实数据和生成数据。通过这种对抗过程，生成器不断地改进自己的生成能力，最终能够生成非常真实的数据。
除了 GAN 之外，还有其他一些生成模型的技术，如变分自编码器（Variational Autoencoder，VAE）和流模型（Flow Model）等。这些技术的工作原理也都类似，都是通过学习数据的分布规律来生成新的数据。
总之，生成模型的工作原理是通过学习数据的分布规律和特征，使用这些知识来生成新的数据。这些模型在图像生成、音频生成、自然语言处理等领域都有广泛的应用。
多模态技术： 多模态技术是一种将多种不同模态的信息（如图像、音频、文本等）进行融合和处理的技术。通过多模态技术，可以实现对多种模态信息的综合理解和利用，从而提高系统的性能和智能化水平。
多模态技术的应用非常广泛，例如：
语音识别：结合音频和文本信息，可以提高语音识别系统的准确率。图像识别：结合图像和文本信息，可以提高图像识别系统的准确率。情感分析：结合文本和音频信息，可以提高情感分析系统的准确率。人机交互：结合多种模态信息，可以实现更加自然和智能的人机交互。 多模态技术的发展需要解决多种技术难题，例如模态融合、信息提取、模型训练等。随着技术的不断发展和应用场景的不断拓展，多模态技术将会在更多的领域得到应用。
如果你对多模态技术感兴趣，可以了解相关的技术和应用，探索更多的创新应用场景。
可解释性人工智能： 随着人工智能系统在医疗、金融和司法等关键领域的应用越来越广泛，对其决策过程的解释和透明度要求也越来越高。因此，2024年可能会见证可解释性人工智能技术的突破，使得人工智能系统的决策过程更具可理解性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a385b5cb756ce5b4963769645d8f836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a6856ae7d47d4f915d4d1d2fe50c7b/" rel="bookmark">
			【WEEK2】 【DAY1】第一个MVC程序之使用注解【中文版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.3.4 Monday
接上文 【WEEK1】 【DAY5】第一个MVC程序之配置文件【中文版】
目录 3.2.使用注解（在实际使用中用不到3.1）3.2.1.新建一个module，名为springmvc-03-hello-annotation，添加web支持3.2.2.由于Maven可能存在资源过滤的问题，我们将配置完善（web-pom.xml）3.2.3.在pom.xml文件引入相关的依赖3.2.4.配置web.xml3.2.5.添加SpringMVC配置文件3.2.6.新建视图层3.2.7.新建HelloController3.2.8.配置Tomcat运行3.2.9.小结 3.2.使用注解（在实际使用中用不到3.1） 3.2.1.新建一个module，名为springmvc-03-hello-annotation，添加web支持 3.2.2.由于Maven可能存在资源过滤的问题，我们将配置完善（web-pom.xml） &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;SpringMVC_try1&lt;/artifactId&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springmvc-03-hello-annotation&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/project&gt; 3.2.3.在pom.xml文件引入相关的依赖 主要有Spring框架核心库、Spring MVC、servlet , JSTL等。
（在父依赖中已经引入了：仅需检查右侧Maven栏中的Dependencies） 3.2.4.配置web.xml 添加web支持（详见W1D21.3 建立一个module:名为 springmvc-01-servlet, 添加Web app的支持）添加lib依赖（详见W1D53.1.8.配置tomcat，启动测试）修改web-WEB-INF-web.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a6856ae7d47d4f915d4d1d2fe50c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cffdf1a98077b597a59b69857a3a69a2/" rel="bookmark">
			【零基础C语言】指针解析3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		17.字符指针变量 在指针类型中我们通常使用char*
代码展示
int main() { char ch = 'w'; char* p = &amp;ch; *p = 's'; printf("%c", ch); return 0; } int main() { char ch[] = "hello ouquyang!"; char* pch = &amp;ch; printf("%s", pch); return 0; } 上述代码中，并不是将字符串放入指针中，而是将字符或字符串首字符的
地址存放在指针中，在使用时顺藤摸瓜就可以打印出后面内容了
如剑指offer上的一题
int main() { char str1[] = "hello bit."; char str2[] = "hello bit."; const char* str3 = "hello bit."; const char* str4 = "hello bit."; if (str1 == str2) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cffdf1a98077b597a59b69857a3a69a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a18e33f7d6e4eac4a764680e7e143b/" rel="bookmark">
			【数据结构初阶】单链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位读者老爷好，鼠鼠我又来了哈。鼠鼠我呀现在来基于C语言实现一下单链表，希望对你有所帮助！
目录
1.链表的概念及结构
2.链表的分类
3.无头单向非循环链表的实现
3.1.单链表打印 3.2.单链表尾插
3.3.单链表头插
3.4.单链表尾删
3.5.单链表头删
3.6.单链表查找
3.7.单链表在pos位置之和插入值
3.8.单链表删除pos位置之后的值 3.9.在pos的前面插入值
3.10.删除pos位置的值
3.11.销毁单链表
4.单链表的小应用
4.1.slist.h
4.2.slist.c
4.3.test.c
5.ending 鼠鼠我上次浅谈了顺序表。但是吧，Any coin has two sides。
顺序表有一些缺陷：
1.尾部插入效率还不错。头部或者中间插入删除，需要挪动数据，效率低下。
2.顺序表满了以后只能扩容。扩容是有一定消耗的，扩容一般是存在一定的空间浪费：一次扩得越多，可能浪费越多；一次扩得少，可能需要频繁扩容。
当然，顺序表也有它的优势：
得益于它的物理空间连续，顺序表支持随机的下标访问。 So，我们有链表（也是线性表）可以避免顺序表的缺陷，那我们先来看看链表哈！
1.链表的概念及结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表
中的指针链接次序实现的 。
不带头非循环单向链表的逻辑结构如下图：
链表是由节点（或者结点）构成的。这些个节点一般是动态内存申请得来的，所以每个节点的地址没有关联，是随机的，可能动态申请的时候申请到了连续的空间，更多可能是申请到不连续的空间，也就是说链表的物理结构不一定连续，。既然每个节点的地址是随机的，那我们如何管理链表呢？ 其实也很简单，拿不带头非循环单向链表来说，如上逻辑结构可知，只要节点有俩个数据域即可，一个数据域存放所需存入的值（即有效数据），另一个数据域存放下一个节点的地址（最后一个节点保存空指针）。这样我们就可以通过第一个节点找到第二个节点、第二个节点找到第三个节点……这样就可以管理链表了。
了解了链表的特点，那我们对于数据的增删改等操作，更改节点内存储的地址即可，不必挪动数据。而且节点是一个个动态申请得到的，想要多少就申请多少，自然就避免了扩容有浪费的情况。这样子就很好避免的顺序表的缺陷！
画图方便理解：
2.链表的分类 实际中链表的结构非常多样，以下情况组合起来就有8种链表结构：
1.单向或者双向
2.带头（哨兵位）或者不带头
3.循环或者非循环
虽然有这么多的链表的结构，但是我们实际中最常用还是两种结构：
1. 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
2. 带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了。
咱们这篇博客实现的是无头单向非循环链表。 3.无头单向非循环链表的实现 具体我们实现这些无头单向非循环链表（以下简称单链表）的增删查改等等功能：
typedef int SLTDateType; //有效数据类型，方便后续维护代码 //定义单链表节点 typedef struct SListNode { SLTDateType data; //有效数据 struct SListNode* next; //下一个节点的地址 }SListNode; // 单链表打印 void SListPrint (SListNode * plist); // 单链表尾插 void SListPushBack(SListNode** pplist, SLTDateType x); // 单链表的头插 void SListPushFront(SListNode** pplist, SLTDateType x); // 单链表的尾删 void SListPopBack(SListNode** pplist); // 单链表头删 void SListPopFront(SListNode** pplist); // 单链表查找 SListNode* SListFind(SListNode* plist, SLTDateType x); // 单链表在pos位置之后插入值 void SListInsertAfter(SListNode* pos, SLTDateType x); // 单链表删除pos位置之后的值 void SListEraseAfter(SListNode* pos); // 在pos的前面插入值 void SLTInsert(SListNode** pphead, SListNode* pos, SLTDateType x); // 删除pos位置的值 void SLTErase(SListNode** pphead, SListNode* pos); //销毁单链表 void SLTDestroy(SListNode** pphead); 好了好了，一个个来实现吧！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71a18e33f7d6e4eac4a764680e7e143b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b073df0b858268266643bbcd3f2057b4/" rel="bookmark">
			ES6语法（七）Promise
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Promise ECMAscript 6 原生提供了 Promise 对象。Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。
1.1. 说明 1.1.1. 单个异步程序 //检测机构 //resolve : 表示成功的状态 //reject : 表示失败的状态 new Promise((resolve,reject) =&gt; { if(处理异步程序){ resolve([参数]); }else{ reject([参数]); } }) .then(([参数]) =&gt; { ... }) .catch(([参数]) =&gt; { ... }) 1.1.2. 多个异步程序 //解决多个异步程序 new Promise((resolve,reject) =&gt; { if(处理异步程序){ resolve([参数]); }else{ reject([参数]); } }) .then(([参数]) =&gt; { return new Promise((resolve,reject) =&gt; { if(处理异步程序){ resolve([参数]); }else{ reject([参数]); } }) }) .then(([参数]) =&gt; { return new Promise((resolve,reject) =&gt; { if(处理异步程序){ resolve([参数]); }else{ reject([参数]); } }) }) …… .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b073df0b858268266643bbcd3f2057b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d6c2c86d2d3b635f01fd406d246cbb/" rel="bookmark">
			P8723 [蓝桥杯 2020 省 AB3] 乘法表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		呈上篇，更高进制的乘法口诀表。主要思想在于进制的转换，用函数，数组来辅助本题思路更为清晰
#include"bits/stdc++.h" using namespace std; const int N=1000; int a[N],p;//牵扯到更高进制的转换，这里直接用一个数组储存余数，然后输出更为简洁 void s(int n) { int ans=0; while(n)//短除法 { a[++ans]=n%p; n=n/p; } for(int i=ans;i&gt;=1;i--)//短除法转换进制时，需要倒过来输出 { if(a[i]&lt;10) cout &lt;&lt; a[i]; else cout &lt;&lt; (char)(a[i]+'A'-10); /*余数大于9，说明为高进制转换，依题意转换成字母*/ } } int main() { cin &gt;&gt; p; for(int i=1;i&lt;p;i++) { for(int j=1;j&lt;=i;j++) { if(i&lt;10) cout &lt;&lt; i; else cout &lt;&lt;(char)('A'+i-10);//同上 cout &lt;&lt; "*"; if(j&lt;10) cout &lt;&lt; j; else cout &lt;&lt;(char)('A'+j-10); cout &lt;&lt;"="; s(i*j); cout &lt;&lt;" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d6c2c86d2d3b635f01fd406d246cbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4840ee15aa9896ebde118d11ebfe419/" rel="bookmark">
			九进制以内的乘法口诀表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本代码只适用于九进制以内，更高进制在下篇
#include"bits/stdc++.h" using namespace std; int p,m,n,c,sum; int main() { cin &gt;&gt; p; for(int i=1;i&lt;=9;i++) { for(int j=1;j&lt;=i;j++) { c=0; sum=0; n=i*j; while(p)//设置一个无限循环 { m=n%p; sum=m*pow(10,c)+sum;//进制转换，再开辟一个函数会更直观 if(n&lt;p) break; n=n/p;//短除法 c++; } if(j&lt;i) printf("%d*%d=%d ",i,j,sum);//注意形式 else printf("%d*%d=%d\n",i,j,sum); } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f259609b6d1765ae8540d8c54e2ec015/" rel="bookmark">
			jdk1.8安装步骤及环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jdk1.8安装步骤及环境配置 1.1：安装步骤 在Oracle官网下载jdk1.8，下载链接 ，如果之前没有注册过还需要注册。下载好之后会得到如下的图标， 双击下载好的exe文件，选择更改安装路径：D:\Java\jdk1.8（会先弹出来一个对话框让安装jdk，后面还会弹出一个对话框选择的是jre的安装路径，选择自己合适的路径即可：D:\Java\jre-1.8）等待安装完成即可，下一步就是配置环境。 1.2：环境配置 依次打开计算机--系统属性--高级系统设置--环境变量，主要关注3个，JAVA_HOME, path和CLASSPATH。其中，path是已经存在的，JAVA_HOME和CLASSPATH需要自己新建。**设置JAVA_HOME属性：**新建变量名是JAVA_HOME，变量值是刚才jdk的安装路径，比如我的就是：D:\Java\jdk1.8，再点击 确定 即可。 设置CLASSPATH属性：新建变量名是CLASSPATH，变量值为：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar 设置path属性：找到path。点击编辑--新建，然后新建下面两个环境。这里提醒一下，如果遇到后面验证不成功的情况，可能是这两个路径的位置太靠后了，所以建议新建好之后把这两个路径往上移，放到最前面。 1.3：验证是否安装成功 按win+R组合键，输入cmd后回车，然后依次输入java，javac，java -version，看出现的界面是否和下面一样，一样说明已经安装完成，大功告成！如果没出来，看看前面哪个环节出错了，再检查一下。 …(img-rVTHLZBW-1709956400832)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2432b9fa4b4dbaf2367d45b061859109/" rel="bookmark">
			[数据结构初阶]队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鼠鼠我呀，今天写一个基于C语言关于队列的博客，如果有兴趣的读者老爷可以抽空看看，很希望的到各位老爷观点和点评捏！
在此今日，也祝各位小姐姐女生节快乐啊，愿笑容依旧灿烂如初阳，勇气与童真永不退色！
目录
1.队列的概念及结构
2.对列的实现 2.1.queue.h
2.2.queue.c
2.3.test.c
2.4.定义队列
2.5.初始化队列
2.6.队尾入队列
2.7.对头出队列
2.8.获取队列队头元素
2.9.获取队列队尾元素
2.10.获取队列中有效元素的个数
2.11.检测队列是否为空，如果为空返回非零结果，非空返回0
2.12.销毁队列 3.分析运行结果
4.ending
1.队列的概念及结构 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列中的数据元素具有先进先出 FIFO(First In First Out) 的特点。
队尾：进行插入操作的一端称为队尾。
对头：进行删除操作的一端称为队头 。
咱们画一个队列的想象图就很好理解上面几个概念：
其实很好理解，队列里面的数据元素就像排队一样，先进入队列的数据元素当然先出队列了。
2.对列的实现 队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低。
而队列用链表实现的方案也是多种多样，只要满足队列的定义即可。鼠鼠我今天写一个方案（本方案基于无头单向非循环链表）各位佬们可以看看啊，俺先把三个文件和运行结果呈现如下：
2.1.queue.h #pragma once #include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdbool.h&gt; typedef int QDatatype; typedef struct QNode { QDatatype _data; struct QNode* _next; }QNode; typedef struct Queue { int k; QNode* head; QNode* tail; }Queue; //初始化队列 void QueueInit(Queue* q); //队尾入数据 void QueuePush(Queue* q, QDatatype data); //对头出数据 void QueuePop(Queue* q); //获取队列对头元素 QDatatype QueueFront(Queue* q); //获取队列队尾元素 QDatatype QueueBack(Queue* q); //获取队列中有效元素个数 int QueueSize(Queue* q); //检测队列是否为空，如果为空返回非零结果，非空返回0 bool QueueEmpty(Queue* q); //销毁队列 void QueueDestory(Queue* q); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2432b9fa4b4dbaf2367d45b061859109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73680b64f98a795b65573a26d2e11e40/" rel="bookmark">
			在Vue中处理接口返回的二进制图片数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟 前言
欢迎来到我的技术小宇宙！🌌 这里不仅是我记录技术点滴的后花园，也是我分享学习心得和项目经验的乐园。📚 无论你是技术小白还是资深大牛，这里总有一些内容能触动你的好奇心。🔍
🤖 洛可可白：个人主页
🔥 个人专栏：✅前端技术 ✅后端技术
🏠 个人博客：洛可可白博客
🐱 代码获取：bestwishes0203
📷 封面壁纸：洛可可白wallpaper
文章目录 在Vue中处理接口返回的二进制图片数据摘要1. 问题分析1.1 环境检查1.2 问题描述 2. 接口对接2.1 添加接口返回头2.2 请求数据示例2.3 使用`bufferUrl`和`btoa`函数 3. 全部代码结语 在Vue中处理接口返回的二进制图片数据 摘要 在现代Web开发中，前端应用经常需要从后端接口获取图片数据。有时，这些图片数据以二进制格式返回，而不是常见的Base64编码。本文将指导你如何在Vue应用中处理这类二进制图片数据，并将其正确地显示在页面上。
1. 问题分析 1.1 环境检查 确保你的Vue项目能够正常发起网络请求，并且后端接口的跨域设置是正确的。如果需要，可以参考这篇文章洛可可白⚡️axios网络请求配置。
1.2 问题描述 当后端接口返回的响应类型为application/octet-stream或image/png等二进制格式时，我们需要特殊处理这些数据。
2. 接口对接 2.1 添加接口返回头 在axios请求中，我们需要指定responseType为arraybuffer，以便接收二进制数据。
// 使用axios获取二进制数据 request.get("/commonEntity/generateImageCode", { responseType: "arraybuffer", }).then((res) =&gt; { console.log(res.data); // 二进制数据 }); 2.2 请求数据示例 接口返回的二进制数据通常是一个ArrayBuffer对象。
2.3 使用bufferUrl和btoa函数 为了将二进制数据转换为Base64编码，我们可以使用btoa函数。然后，我们可以将Base64编码的字符串作为图片的src属性。
import request from "@/request"; import { onMounted, ref } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73680b64f98a795b65573a26d2e11e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565885ee0eb7144a372e359aee58dd79/" rel="bookmark">
			EasyExcel.read()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // MultipartFile file; InputStream inputStream = file.getInputStream(); // sheet页 int sheetIdx = 0; // 单个句柄的数据量 int batchCount = 50; EasyExcel.read(inputStream, ExcelVo.class, new PageReadListener&lt;ExcelVo&gt;(list -&gt; { for (ExcelVo vo : list) { System.out.println(vo); } // }, batchCount)).sheet(sheetIdx).doReadSync(); } )).sheet().doReadSync(); @Data public class ExcelVo { @ExcelProperty("id") private Long id; @ExcelProperty("编码") private String Code; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd392621b852b006bcd6c21a0ae6180/" rel="bookmark">
			MyEclipse保留配置数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 对于做开发的来说，能够熟练使用一个工具，就非常不错了。 最近一直都在使用MyEclipse做开发。由于最近做的比较杂，而且做的Demo程序比较多。 而小编在做Demo程序的时候，喜欢重新开一个工作空间。
在使用MyEclipse的时候，首先是会配置一些数据。 一般都是在Windows-Preference中进行换环境配置和一些常用的设置。如：字体样式、服务器配置、jdk等等。
配置比较简单，而且还是无脑性质的配置。
接下来，看如何节省配置
在旧的工作空间中使用的配置： 现在，重新打开一个新的工作空间中打开，配置为空： 之前使用的配置数据全部被重置了。
对于新创建的工作空间，MyEclipse的配置数据 并不会像Vs一样保留。
所以，对于习惯.net开发的人们来说，有一丢丢的不适应。当然，如果是进行Java开发的，肯定不会没事创建工作空间玩儿。
为了节省时间，进行繁琐的配置。所以我们可以保留下我们的配置数据。
我们的配置数据在哪呢？既然配置数据会随着创建工作空间而重置，那么我们对MyEclipse进行的配置数据，肯定是保存到工作空间了。
亲们，可以去自己的工作空间中看一下。 如果你将该文件，覆盖到新创建的工作空间中去，你会发现，这种做法是行不通的…… 因为这个文件夹中保存了 本工作控件的 配置信息 和项目信息。
解决方案： 我们只需要将工作空间的配置数据，覆盖我们新的工作空间即可。 目录：\.metadata\.plugins\org.eclipse.core.runtime
把org.eclipse.core.runtime文件夹覆盖新的工作空间
进行覆盖之后，在重新打开新的工作空间：
覆盖之后的效果图： 省去了很多重复配置的时间。
原文：MyEclipse保留配置数据_myeclipse工作空间保留配置-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6212e3d6f237f692126d5f2dab8c123c/" rel="bookmark">
			【WEEK1】 【DAY5】First MVC Program: Configuration File【English Version】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.3.1 Friday
Table of Contents 3. First MVC Program3.1 Configuration files3.1.1. Create a new module3.1.2. Modify web.xml, add content3.1.3. Write the SpringMVC configuration file3.1.4. Add handler mappings, handler adapters, and view resolvers3.1.5. Write specific business operations3.1.6. JSP page to jump to, display the data stored in ModelAndView, and the normal page3.1.7. Register your own class with the Spring IOC container, register bean3.1.8. Configure Tomcat, Start Testing3.1.9. Common Issues: Encountering a 404 Error, Troubleshooting Steps 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6212e3d6f237f692126d5f2dab8c123c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a08647980b63027f0a645f45c93ad8b/" rel="bookmark">
			初阶数据结构-双向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双向链表 双向链表的概念哨兵位 链表的分类双向链表的基本功能双向链表的创建双向链表节点的创建双向链表的初始化双向链表的打印双向链表判断是否为空双向链表的尾插双向链表的头插双向链表的头删双向链表的尾删双向链表的查找双向链表的pos位置插入双向链表的pos位置删除双向链表的销毁 双向链表的测试主函数 双向链表的概念 链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。
哨兵位 为什么要有哨兵位呢？
1.对于一个已经创建和初始化的链表来讲，可以没有数据，即头节点，尾节点等，但是不能没有哨兵位，因为哨兵位并不是帮我们存储数据的，只是来定位链表的。即使是一个空链表，它也会有哨兵位，所以我们可以用哨兵位是否为空来检测程序运行情况。
2.对于链表来讲，一个很重要的地方就是头的位置，而哨兵位则可以起到定位头的作用，它的下一个节点就是头节点。
3.在双向循环链表中，如果我们要遍历，那么很难去说明结束条件，而我们可以用哨兵位来作为结束条件，当当前节点为哨兵位时，遍历结束。
链表的分类 1. 单向或者双向2. 带头或者不带头3. 循环或者非循环
双向链表的基本功能 //初始化 LTNode* LTInit( ); //打印 void LTPrint(LTNode* phead); //判断是否为空 bool LTEmpty(LTNode* phead); //尾插 void LTPushBack(LTNode* phead, LTDataType x); //头插 void LTPushFront(LTNode* phead, LTDataType x); //头删 void LTPopFront(LTNode* phead); //尾删 void LTPopBack(LTNode* phead); //查找 LTNode* LTFind(LTNode* phead, LTDataType x); //在pos之前插入 void LTInsert(LTNode* pos, LTDataType x); //删除pos位置的值 void LTErase(LTNode* pos); //销毁 void LTDestroy(LTNode* phead); 双向链表的创建 typedef int LTDataType; typedef struct ListNode { struct ListNode* next; struct ListNode* prev; LTDataType data; }LTNode; 双向链表节点的创建 LTNode* BuyLTNode(LTDataType x) { LTNode* newnode = (LTNode*)malloc(sizeof(LTNode)); if (newnode == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a08647980b63027f0a645f45c93ad8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5a29d3743862ca64eb77bd410ea0f3/" rel="bookmark">
			【WEEK1】 【DAY5】第一个MVC程序之配置文件【中文版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.3.1 Friday
目录 3. 第一个MVC程序3.1配置文件3.1.1.新建module3.1.2.修改web.xml，添加内容3.1.3.编写SpringMVC 的 配置文件3.1.4.添加处理映射器、处理适配器、视图解析器3.1.5.写具体业务操作3.1.6.要跳转的jsp页面，显示ModelandView存放的数据，以及正常页面3.1.7.将自己写的类交给SpringIOC容器，注册bean3.1.8.配置tomcat，启动测试3.1.9.可能遇到的问题：访问出现404，排查步骤 3. 第一个MVC程序 3.1配置文件 3.1.1.新建module 新建springmvc-02-hello模块，并添加web支持
3.1.2.修改web.xml，添加内容 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;!--要写一个配置文件--&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!-- the above should be ignored at this time --&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--所有请求将会经过--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 3.1.3.编写SpringMVC 的 配置文件 名称：springmvc-servlet.xml : [servletname]-servlet.xml
说明，这里的名称要求是按照官方来的
3.1.4.添加处理映射器、处理适配器、视图解析器 完整代码位于3.1.7
&lt;!--配置三个类：可以直接复用--&gt; &lt;!-- 处理映射器 --&gt; &lt;bean class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad5a29d3743862ca64eb77bd410ea0f3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/24/">«</a>
	<span class="pagination__item pagination__item--current">25/134</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/26/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>