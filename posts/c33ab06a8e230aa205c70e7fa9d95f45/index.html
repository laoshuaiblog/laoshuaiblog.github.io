<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Codeforces Round 935 (Div. 3) （A~G） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/c33ab06a8e230aa205c70e7fa9d95f45/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Codeforces Round 935 (Div. 3) （A~G）">
  <meta property="og:description" content="1945A - Setting up Camp 题意：三种人安排住宿,a只能跟自己住,b只能三个人住,c能1~3个人，问最终最少房间数
思路：a单独安排,b放一起,不足三个人的用c补,然后c按照3人一房间尽可能分配
void solve() { int a , b , c; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c; int ans = a &#43; b / 3; b %= 3; int res = b &#43; c; if(res == 0){ cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return; } if(b){ if(res &amp;lt; 3){ cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; } else{ cout &amp;lt;&amp;lt; ans &#43; (res - 1) / 3 &#43; 1 &amp;lt;&amp;lt; endl; } } else{ cout &amp;lt;&amp;lt; ans &#43; (res - 1) / 3 &#43; 1 &amp;lt;&amp;lt; endl; } } 1945B - Fireworks 题意：装置A每a分钟放一次烟花,装置B每b分钟放一次烟花,烟花能存在m分钟,求空中同时存在最多多少烟花.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-20T17:44:31+08:00">
    <meta property="article:modified_time" content="2024-03-20T17:44:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Codeforces Round 935 (Div. 3) （A~G）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a href="https://codeforces.com/problemset/problem/1945/A" rel="nofollow" title="1945A - Setting up Camp ">1945A - Setting up Camp </a></h2> 
<p>        题意：三种人安排住宿,a只能跟自己住,b只能三个人住,c能1~3个人，问最终最少房间数</p> 
<p>        思路：a单独安排,b放一起,不足三个人的用c补,然后c按照3人一房间尽可能分配</p> 
<p>        </p> 
<pre><code class="language-cpp">void solve() 
{
	int a , b , c;
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
	int ans = a + b / 3;
	b %= 3;
	int res = b + c;
	if(res == 0){
		cout &lt;&lt; ans &lt;&lt; endl;
		return;
	}
	if(b){
		if(res &lt; 3){
			cout &lt;&lt; -1 &lt;&lt; endl;
		}
		else{
			cout &lt;&lt; ans + (res - 1) / 3 + 1 &lt;&lt; endl;
		}
	}
	else{
		cout &lt;&lt; ans + (res - 1) / 3 + 1 &lt;&lt; endl;
	}
}      </code></pre> 
<h2><a href="https://codeforces.com/problemset/problem/1945/B" rel="nofollow" title="1945B - Fireworks ">1945B - Fireworks </a></h2> 
<p>        题意：装置A每a分钟放一次烟花,装置B每b分钟放一次烟花,烟花能存在m分钟,求空中同时存在最多多少烟花.</p> 
<p>        思路：两只烟花必然能同时放,然后再看接下来m分钟能放多少只烟花,这样必然最优</p> 
<pre><code class="language-cpp">void solve() 
{
	LL a , b , m;
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; m;
	//同一时间发射
	LL en = m;
	cout &lt;&lt; (en / a) + (en / b) + 2&lt;&lt; endl;
}  </code></pre> 
<h2><a href="https://codeforces.com/problemset/problem/1945/C" rel="nofollow" title="1945C - Left and Right Houses ">1945C - Left and Right Houses </a></h2> 
<p>        题意：给定01串,要求从中间某个位置分开,其中左侧0的数量大于等于1的数量,右侧1的数量大于等于0的数量,求满足条件的最靠近中心的位置。</p> 
<p>        思路：直接模拟</p> 
<pre><code class="language-cpp">void solve() 
{
	double n;
	cin &gt;&gt; n;
	string s;
	cin &gt;&gt; s;
	s = " " + s;
	int left = 0, right = 0;
	for(int i = 1 ; i &lt;= (int)n ; i ++){
		right += (s[i] == '1');
	}	
	vector&lt;double&gt;ans;
	int left_cnt = 0 , right_cnt = n;
	for(int i = 0 ; i &lt;= n ; i ++){
		if(i &gt; 0){
			if(s[i] == '0'){
				left++;
			}
			if(s[i] == '1'){
				right--;
			}
			left_cnt++;
			right_cnt--;
		}
		//在i的右边
		if((left_cnt + 1) / 2 &lt;= left &amp;&amp; (right_cnt + 1) / 2 &lt;= right){
			ans.pb(i);
		}
		
	}
	int out = 0;
	int maxx = 1e8;
	for(int i = 0 ; i &lt; ans.size() ; i ++){
		double diff = abs(n / 2 - ans[i]);
		if(diff &lt; maxx){
			out = ans[i];
			maxx = diff;
		}
	}
	cout &lt;&lt; out &lt;&lt; endl;
}  </code></pre> 
<h2> <a href="https://codeforces.com/problemset/problem/1945/D" rel="nofollow" title="1945D - Seraphim the Owl ">1945D - Seraphim the Owl </a></h2> 
<p>        题意：<img alt="" height="184" src="https://images2.imgbox.com/2c/82/OjRoTJ9J_o.png" width="867"></p> 
<p>        思路：最终位置必须为a数组,一旦最终位置确定了,那么其中间的选a数组还是b数组都行，因此除了最终位置需要花费a数组的硬币,其余都是a或b的最小值。</p> 
<pre><code class="language-cpp">void solve() 
{
	cin &gt;&gt; n &gt;&gt; m;
	LL a[n + 5] , b[n + 5];
	for(int i = 1 ; i &lt;= n ; i ++)
		cin &gt;&gt; a[i];
	for(int i = 1 ; i &lt;= n ; i ++)
		cin &gt;&gt; b[i];
	//如果b[i] &lt; a[i] , 那么就等着前面 , 否则就选上
	LL ans = llinf;
	LL pre = 0;
	for(int i = m + 1 ; i &lt;= n ; i ++){
		pre += min(a[i] , b[i]);
	}	
	for(int i = m ; i &gt;= 1 ; i --){
		ans = min(ans , a[i] + pre);
		pre += min(a[i] , b[i]);
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}      </code></pre> 
<p></p> 
<h2> <a href="https://codeforces.com/problemset/problem/1945/E" rel="nofollow" title="1945E - Binary Search ">1945E - Binary Search </a></h2> 
<p>        题意：<img alt="" height="352" src="https://images2.imgbox.com/ea/51/fhXwBuyq_o.png" width="867"></p> 
<p>        思路：可以想到,对于一个给定的排列,其算法中所有需要跟x进行比较的数的位置都是能确定的，如果x所在位置不在需要比较的位置里面,那么只需要将x放到最终的l上面就能满足题意了，因此我们可以枚举第一步,将x放在不需要比较的位置上，然后再将x放入最终的l即可。</p> 
<pre><code class="language-cpp">void solve() 
{
	int n , x;
	cin &gt;&gt; n &gt;&gt; x;
	int pos = 0;
	for(int i = 1 ; i &lt;= n ; i ++){
		cin &gt;&gt; a[i];
		if(a[i] == x)
			pos = i;
	}
	for(int i = 1 ; i &lt;= n ; i ++){
		swap(a[i] , a[pos]);
		int l = 1 , r = n + 1;
		vector&lt;int&gt;path;
		while(r - l &gt; 1){
			int mid = (l + r) / 2;
			if(a[mid] &lt;= x){
				l = mid;
			}
			else
				r = mid;
			path.pb(mid);
		}
		int f = 1;
		for(auto it : path){
			if(it == i){
				f = 0;
				break;
			}
		}
		if(f){
			cout &lt;&lt; 2 &lt;&lt; endl;
			cout &lt;&lt; i &lt;&lt; " " &lt;&lt; pos &lt;&lt; endl;
			cout &lt;&lt; i &lt;&lt; " " &lt;&lt; l &lt;&lt; endl;
			return;
		}
		swap(a[i] , a[pos]);
	}
}   </code></pre> 
<h2><a href="https://codeforces.com/problemset/problem/1945/F" rel="nofollow" title="1945F - Kirill and Mushrooms ">1945F - Kirill and Mushrooms </a></h2> 
<p>        题意：现有n个蘑菇,每个蘑菇有一个对应的魔力值,还给定了一个排列,现在需要用蘑菇来制作药水,规定药水的魔力值为所用蘑菇中最小的魔力值 * 所用蘑菇数。同时若用了k个蘑菇,那么排列的前k - 1个数所对应的蘑菇魔力值将变为0.同时魔力值为0的蘑菇不能被用作制作药水。</p> 
<p>        思路：枚举拿蘑菇的数量。贪心的思想,每次都拿当前魔力值最高的蘑菇,同时因为多了一个蘑菇,因此会有一个蘑菇的魔力值变成0，若这个0魔力值的蘑菇在所选中蘑菇里面，就重新再拿一个蘑菇，如此不断往复。</p> 
<pre><code class="language-cpp">void solve() 
{
	cin &gt;&gt; n;
	pair&lt;int,int&gt;a[n + 5];
	for(int i = 1 ; i &lt;= n ; i ++){
		cin &gt;&gt; a[i].x;
		a[i].y = i;
	}
	int p[n + 5];
	p[0] = 0;
	for(int i = 1 ; i &lt;= n ; i ++)
		cin &gt;&gt; p[i];
	auto cmp = [&amp;](pair&lt;int ,int&gt; a , pair&lt;int,int&gt; b){
		return a.x &gt; b.x;
	};
	a[n + 1].x = 0;
	sort(a + 1 , a + n + 1 , cmp);
/*	for(int i = 1 ; i &lt;= n ; i ++){
		cout &lt;&lt; a[i].x &lt;&lt;" " &lt;&lt; a[i].y &lt;&lt; endl;
	}*/
	map&lt;int,int&gt;mp;//是否在篮子里
	map&lt;int,int&gt;vis;//这么多不能在篮子里
	LL ans = -1;
	LL out = 0;
	int id = 0;
	int minn = llinf;
	for(int cnt = 1 ; id &lt;= n &amp;&amp; cnt &lt;= n ; cnt ++ , id++){
		if(id &gt; n)
			break;
		//ban
		vis[p[cnt - 1]] = 1;
		//out
		if(mp.count(p[cnt - 1])){//有了
			while(id &lt;= n &amp;&amp; vis.count(a[id].y)){
				id++;
			}
			minn = a[id].x;
			mp[a[id].y] = 1;
			id++;
		}
		//pick
		while(id &lt;= n &amp;&amp; vis.count(a[id].y)){
			id++;
		}
		minn = a[id].x;
		mp[a[id].y] = 1;
		if(minn * cnt &gt; ans){
			ans = minn * cnt;
			out = cnt;
		}
	}
	cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; out &lt;&lt;endl;
}  </code></pre> 
<h2><a href="https://codeforces.com/problemset/problem/1945/G" rel="nofollow" title="1945G - Cook and Porridge ">1945G - Cook and Porridge </a></h2> 
<p>        题意：<img alt="" height="424" src="https://images2.imgbox.com/38/42/4zmupD7R_o.png" width="862"></p> 
<p>        思路：看代码</p> 
<pre><code class="language-cpp">// Problem: G. Cook and Porridge
// Contest: Codeforces - Codeforces Round 935 (Div. 3)
// URL: https://codeforces.com/contest/1945/problem/G
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// 

#include &lt;bits/stdc++.h&gt;
using namespace std;
#define LL long long
#define pb push_back
#define x first
#define y second 
#define endl '\n'
const LL maxn = 4e05+7;
const LL N = 5e05+10;
const LL mod = 1e09+7;
const int inf = 0x3f3f3f3f;
const LL llinf = 5e18;
typedef pair&lt;int,int&gt;pl;
priority_queue&lt;LL , vector&lt;LL&gt;, greater&lt;LL&gt; &gt;mi;//小根堆
priority_queue&lt;LL&gt; ma;//大根堆
LL gcd(LL a, LL b){
	return b &gt; 0 ? gcd(b , a % b) : a;
}

LL lcm(LL a , LL b){
	return a / gcd(a , b) * b;
}
int n , m;
vector&lt;int&gt;a(N , 0);
void init(int n){
	for(int i = 0 ; i &lt;= n ; i ++){
		a[i] = 0;
	}
}
struct BIT{//Binary indexed Tree(树状数组)
	int n;
	vector&lt;int&gt; tr;
	BIT(int n) : n(n) , tr(n + 1 , 0){
	}
	int lowbit(int x){
		return x &amp; -x;
	}
	void modify(int x , int modify_number){
		for(int i = x ; i &lt;= n ; i += lowbit(i)){
			tr[i] += modify_number;
		}
	}
	void modify(int l , int r , int modify_number){
		modify(l , modify_number);
		modify(r + 1 , -modify_number);
	}
	int query(int x){
		int res = 0;
		for(int i = x ; i ;  i -= lowbit(i))
			res += tr[i];
		return res;
	}
	int query(int x , int y){
		return query(y) - query(x);
	}
};
struct Eat{//吃饭队列
	int ti;//归队时间
	int ss;//吃饭时间
	int id;//编号
	friend bool operator &lt; (struct Eat a , struct Eat b){
		if(a.ti != b.ti){
			return a.ti &gt; b.ti;
		}
		else{
			return a.ss &gt; b.ss;
		}
	}
};
struct Rank{//就绪队列 优先级高的在前面,统一优先级到达时间晚的在后面
	int kk;//优先级
	int time;//到达时间
	int id;//编号
	int num;
	friend bool operator &lt; (struct Rank a , struct Rank b){
		if(a.kk != b.kk){
			return a.kk &lt; b.kk;
		}
		else if(a.time != b.time){
			return a.time &gt; b.time;
		}
		else{
			return a.num &gt; b.num;
		}
	}
};
void solve() 
{
	cin &gt;&gt; n &gt;&gt; m;
	pair&lt;int,int&gt;stu[n + 5];
	for(int i = 1 ; i &lt;= n ; i ++){
		cin &gt;&gt; stu[i].x &gt;&gt; stu[i].y;
	}
	int num = 0;
	//怎么判断第i个人能否喝到粥？ -&gt; 前面没有人
	//怎么计算第i个人第一次喝到粥的时刻？ -&gt; 模拟时间
	//若第i个人会被插队的条件是,他之后没有比那个人优先级高的人了,之后加的也必然不会被卡
	vector&lt;int&gt;back(n + 5 , 0);//第i个人之后的最大优先,第i个人喝完之后,会在大于等于back[j]的后面,若没有,则放到第一个
	back[n + 1] = 0;
	for(int i = n ; i &gt;= 1 ; i --){
		back[i] = max(back[i + 1] , stu[i].x);
	}
	priority_queue&lt;Eat&gt;e;//吃饭队列,时间到了归队
	priority_queue&lt;Rank&gt;r;//等待队列
	int id = 1;
	int ans = -1;
	for(int i = 1 ; i &lt;= m ; i ++){
		if(r.empty() || back[id] &gt;= r.top().kk){
			e.push({i + stu[id].y , stu[id].y , id});
			id++;
			if(id == n + 1){
				ans = i;
				break;
			}
		}
		else{
			int idx = r.top().id;
			r.pop();
			e.push({i + stu[idx].y , stu[idx].y , idx});
		}
		while(!e.empty() &amp;&amp; e.top().ti == i){
			int idx = e.top().id;
			e.pop();
			r.push({stu[idx].x , i , idx , ++num});
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}            
int main() 
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cout.precision(10);
    int t=1;
	cin&gt;&gt;t;
    while(t--)
    {
    	solve();
    }
    return 0;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea34e24a404f837813db60db8e9bce95/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nrm切换源和私有库下载方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4f5f7508574af7206b9cef4d81e289dd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">进程管理与计划任务管理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>