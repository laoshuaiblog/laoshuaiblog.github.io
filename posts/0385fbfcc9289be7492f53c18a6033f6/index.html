<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java取模场景下设置数组等长度尽量用2的n次方数字 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/0385fbfcc9289be7492f53c18a6033f6/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="java取模场景下设置数组等长度尽量用2的n次方数字">
  <meta property="og:description" content="记录一下除数为2的N次方取模可以用与运算替代，效率更高
转载：除数为2的N次方取模可以用与运算替代，效率更高_taoshengyang的专栏-CSDN博客
取模运算在包括JAVA在内的大多数语言中的效率都十分低下，而当除数为2的N次方时，取模运算将退化为最简单的位运算，其效率明显提升（按照Bruce Eckel给出的数据，大约可以提升5～8倍） 。看看JDK中是如何实现的：
Java代码：
static int indexFor(int h, int length) { return h &amp;amp; (length-1); } 当key空间长度为2的N次方时，计算hashCode为h的元素的索引可以用简单的与操作来代替笨拙的取模操作！假设某个对象的hashCode为35（二进制为100011），而hashMap采用默认的initialCapacity（16），那么indexFor计算所得结果将会是100011 &amp;amp; 1111 = 11，即十进制的3，是不是恰好是35 Mod 16。
上面的方法有一个问题，就是它的计算结果仅有对象hashCode的低位决定，而高位被统统屏蔽了；以上面为例，19（10011）、35（100011）、67（1000011）等就具有相同的结果。针对这个问题， Joshua Bloch采用了“防御性编程”的解决方法，在使用各对象的hashCode之前对其进行二次Hash，参看JDK中的源码：
Java代码：
static int hash(Object x) { int h = x.hashCode(); h &#43;= ~(h &amp;lt;&amp;lt; 9); h ^= (h &amp;gt;&amp;gt;&amp;gt; 14); h &#43;= (h &amp;lt;&amp;lt; 4); h ^= (h &amp;gt;&amp;gt;&amp;gt; 10); return h; } 采用这种旋转Hash函数的主要目的是让原有hashCode的高位信息也能被充分利用，且兼顾计算效率以及数据统计的特性，其具体的原理已超出了本文的领域。
加快Hash效率的另一个有效途径是编写良好的自定义对象的HashCode，String的实现采用了如下的计算方法：
Java代码：
for (int i = 0; i &amp;lt; len; i&#43;&#43;) { h = 31*h &#43; val[off&#43;&#43;]; } hash = h; 这种方法HashCode的计算方法可能最早出现在Brian W.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-12-29T16:11:16+08:00">
    <meta property="article:modified_time" content="2021-12-29T16:11:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java取模场景下设置数组等长度尽量用2的n次方数字</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>记录一下除数为2的N次方取模可以用与运算替代，效率更高</p> 
<p>转载：<a href="https://blog.csdn.net/taoshengyang/article/details/7235319" title="除数为2的N次方取模可以用与运算替代，效率更高_taoshengyang的专栏-CSDN博客">除数为2的N次方取模可以用与运算替代，效率更高_taoshengyang的专栏-CSDN博客</a></p> 
<p>取模运算在包括JAVA在内的大多数语言中的效率都十分低下，而当除数为2的N次方时，取模运算将退化为最简单的位运算，其效率明显提升（按照Bruce Eckel给出的数据，大约可以提升5～8倍） 。看看JDK中是如何实现的：</p> 
<p>Java代码：<br>  </p> 
<pre><code>static int indexFor(int h, int length) {   
    return h &amp; (length-1);   
}  </code></pre> 
<p><br> 当key空间长度为2的N次方时，计算hashCode为h的元素的索引可以用简单的与操作来代替笨拙的取模操作！假设某个对象的hashCode为35（二进制为100011），而hashMap采用默认的initialCapacity（16），那么indexFor计算所得结果将会是100011 &amp; 1111 = 11，即十进制的3，是不是恰好是35 Mod 16。</p> 
<p>上面的方法有一个问题，就是它的计算结果仅有对象hashCode的低位决定，而高位被统统屏蔽了；以上面为例，19（10011）、35（100011）、67（1000011）等就具有相同的结果。针对这个问题， Joshua Bloch采用了“防御性编程”的解决方法，在使用各对象的hashCode之前对其进行二次Hash，参看JDK中的源码：</p> 
<p>Java代码：<br>  </p> 
<pre><code>static int hash(Object x) {   
        int h = x.hashCode();   
        h += ~(h &lt;&lt; 9);   
        h ^=  (h &gt;&gt;&gt; 14);   
        h +=  (h &lt;&lt; 4);   
        h ^=  (h &gt;&gt;&gt; 10);   
        return h;   
    }
</code></pre> 
<p><br> 采用这种旋转Hash函数的主要目的是让原有hashCode的高位信息也能被充分利用，且兼顾计算效率以及数据统计的特性，其具体的原理已超出了本文的领域。</p> 
<p>加快Hash效率的另一个有效途径是编写良好的自定义对象的HashCode，String的实现采用了如下的计算方法：</p> 
<p>Java代码：<br>  </p> 
<pre><code>for (int i = 0; i &lt; len; i++) {   
h = 31*h + val[off++];   
}   
hash = h;  </code></pre> 
<p><br> 这种方法HashCode的计算方法可能最早出现在Brian W. Kernighan和Dennis M. Ritchie的《The C Programming Language》中，被认为是性价比最高的算法（又被称为times33算法，因为C中乘数常量为33，JAVA中改为31），实际上，包括List在内的大多数的对象都是用这种方法计算Hash值。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d6894364a84860a7a87cfd73e276f127/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。举例：153就是一个水仙花数。 153 = 1*1*1 &#43; 5*5*5 &#43; 3*3*3 = 1 &#43; 125 &#43; 27 =</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c22b6a53ae534fbbaf1acfc4cb7adf33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于JAVA&#43;Swing&#43;MYSQL的学生选课系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>