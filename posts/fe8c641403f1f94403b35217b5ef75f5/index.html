<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>解释Java的垃圾回收机制，Java中如何创建多线程？ - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/fe8c641403f1f94403b35217b5ef75f5/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="解释Java的垃圾回收机制，Java中如何创建多线程？">
  <meta property="og:description" content="Java的垃圾回收（Garbage Collection, GC）机制是一种自动的内存管理技术，它是Java虚拟机（JVM）的核心特性之一。其主要目标是识别并回收那些在Java程序运行过程中已经不再使用的对象所占用的内存空间，从而避免了程序员手动去管理和释放内存，这降低了出现内存泄露等问题的风险，并简化了编程模型。
在Java中，当一个对象被创建后，它会被分配到堆内存上。如果这个对象随后不再有任何引用指向它（即没有可达路径能够访问到这个对象），那么根据GC的定义，这个对象就成为了“无用”或者“不可达”的对象，可以被当做垃圾进行回收。
Java垃圾回收的工作流程通常包括以下几个步骤：
对象可达性分析：通过根节点集合（通常是栈上的局部变量、方法区的类静态变量以及全局JNI引用等）作为起点，遍历整个引用树来判断对象是否可达。如果一个对象在GC Roots不可达，则被认为是可回收的。
标记（Marking）：一旦确定某个对象是不可达的，垃圾回收器会将其标记为待回收的状态。
清理（Sweeping）/整理（Compacting）：标记阶段结束后，垃圾回收器会清除所有标记为可回收的对象，释放它们占用的内存空间。在一些GC算法中，如CMS或G1，还会进一步进行内存空间的整理，避免内存碎片的产生，以优化后续对象分配的效率。
内存压缩（如果有必要）：在一些现代的垃圾回收器（如G1，ZGC，Shenandoah）中，为了减少内存碎片，会在清理后进行内存区域的压缩，即将存活对象移到一块连续的空间上，然后释放其余空闲区域。
Java提供了多种不同的垃圾回收算法实现，比如分代收集（Young Generation 和 Tenured/Old Generation）、并发标记清除（Concurrent Mark Sweep, CMS）、暂停预拷贝（Parallel Copy Collector）、低暂停时间的G1和ZGC等，这些算法在不同的场景下有着不同的优势和适用性。
总之，Java垃圾回收机制确保了内存的有效利用和系统的稳定性，使得开发人员无需关心内存的具体管理工作，从而更加专注于业务逻辑的实现。
在Java中，有多种方式可以创建多线程：
继承Thread类：创建一个新的类，该类继承自Thread类，并重写它的run()方法。然后创建该类的实例并调用start()方法来启动新线程。
示例代码：
class MyThread extends Thread { public void run() { // 线程的任务代码 } } public class Main { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); } } 实现Runnable接口：创建一个实现Runnable接口的新类，并实现其run()方法。然后将这个Runnable对象作为参数传递给Thread类的构造函数来创建新的线程。
示例代码：
class MyRunnable implements Runnable { public void run() { // 线程的任务代码 } } public class Main { public static void main(String[] args) { Thread thread = new Thread(new MyRunnable()); thread.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-15T10:15:00+08:00">
    <meta property="article:modified_time" content="2024-01-15T10:15:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">解释Java的垃圾回收机制，Java中如何创建多线程？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Java的垃圾回收（Garbage Collection, GC）机制是一种自动的内存管理技术，它是Java虚拟机（JVM）的核心特性之一。其主要目标是识别并回收那些在Java程序运行过程中已经不再使用的对象所占用的内存空间，从而避免了程序员手动去管理和释放内存，这降低了出现内存泄露等问题的风险，并简化了编程模型。</p> 
<p>在Java中，当一个对象被创建后，它会被分配到堆内存上。如果这个对象随后不再有任何引用指向它（即没有可达路径能够访问到这个对象），那么根据GC的定义，这个对象就成为了“无用”或者“不可达”的对象，可以被当做垃圾进行回收。</p> 
<p>Java垃圾回收的工作流程通常包括以下几个步骤：</p> 
<ol><li> <p><strong>对象可达性分析</strong>：通过根节点集合（通常是栈上的局部变量、方法区的类静态变量以及全局JNI引用等）作为起点，遍历整个引用树来判断对象是否可达。如果一个对象在GC Roots不可达，则被认为是可回收的。</p> </li><li> <p><strong>标记（Marking）</strong>：一旦确定某个对象是不可达的，垃圾回收器会将其标记为待回收的状态。</p> </li><li> <p><strong>清理（Sweeping）/整理（Compacting）</strong>：标记阶段结束后，垃圾回收器会清除所有标记为可回收的对象，释放它们占用的内存空间。在一些GC算法中，如CMS或G1，还会进一步进行内存空间的整理，避免内存碎片的产生，以优化后续对象分配的效率。</p> </li><li> <p><strong>内存压缩（如果有必要）</strong>：在一些现代的垃圾回收器（如G1，ZGC，Shenandoah）中，为了减少内存碎片，会在清理后进行内存区域的压缩，即将存活对象移到一块连续的空间上，然后释放其余空闲区域。</p> </li></ol> 
<p>Java提供了多种不同的垃圾回收算法实现，比如分代收集（Young Generation 和 Tenured/Old Generation）、并发标记清除（Concurrent Mark Sweep, CMS）、暂停预拷贝（Parallel Copy Collector）、低暂停时间的G1和ZGC等，这些算法在不同的场景下有着不同的优势和适用性。</p> 
<p>总之，Java垃圾回收机制确保了内存的有效利用和系统的稳定性，使得开发人员无需关心内存的具体管理工作，从而更加专注于业务逻辑的实现。</p> 
<p>在Java中，有多种方式可以创建多线程：</p> 
<ol><li> <p>继承Thread类：创建一个新的类，该类继承自Thread类，并重写它的run()方法。然后创建该类的实例并调用start()方法来启动新线程。</p> <p>示例代码：</p> <pre><code class="prism language-java">
<span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 线程的任务代码</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>



<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token class-name">MyThread</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> </li><li> <p>实现Runnable接口：创建一个实现Runnable接口的新类，并实现其run()方法。然后将这个Runnable对象作为参数传递给Thread类的构造函数来创建新的线程。</p> <p>示例代码：</p> <pre><code class="prism language-java">
<span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 线程的任务代码</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>



<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> </li><li> <p>使用Executor框架：Java 5及更高版本引入了Executor框架，可以通过它更灵活地管理和控制线程。可以使用Executors类创建ExecutorService，然后通过submit()或execute()方法执行Runnable或Callable任务。</p> <p>示例代码：</p> <pre><code class="prism language-java">
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span>



<span class="token keyword">class</span> <span class="token class-name">MyTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Override</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 线程的任务代码</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>



<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建并启动线程</span>

        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 关闭ExecutorService</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> </li></ol> 
<p>以上三种方式都可以实现多线程编程，但通常推荐使用实现Runnable接口和Executor框架的方式，因为它们更加灵活且易于管理。</p> 
<p>线程和进程是操作系统中用于管理和调度执行单元的两种基本概念。</p> 
<p>进程：一个进程是一个程序在操作系统中的一个实例，它拥有独立的资源（如内存空间、文件描述符等）和自己的虚拟地址空间。每个进程都有一个唯一的进程标识符（PID）。进程是资源分配的基本单位，它可以包含一个或多个线程。</p> 
<p>线程：线程是进程中执行路径的一个实例，也称为轻量级进程。同一进程内的多个线程共享相同的内存空间和系统资源，包括代码段、数据段、堆和打开的文件等。线程间通信更为高效，因为它们可以直接访问共享的数据。线程是调度和执行的基本单位。</p> 
<p>区别总结如下：</p> 
<ol><li> <p>资源分配：进程是资源分配的基本单位，而线程共享其所在进程的资源。</p> </li><li> <p>内存空间：每个进程都有自己独立的内存空间，而同一进程内的线程共享同一块内存空间。</p> </li><li> <p>创建销毁开销：创建和销毁进程相比创建和销毁线程要昂贵得多，因为进程涉及更多的系统资源分配与回收；而线程的创建和销毁则相对较快。</p> </li><li> <p>通信方式：进程间通信需要借助于一些特殊机制（如管道、消息队列、共享内存等），而线程间可以直接访问共享内存，通信更便捷高效。</p> </li><li> <p>独立性：进程间的运行相互独立，不会直接影响彼此（除非通过特定的通信手段交互）；而在同一个进程中的线程之间存在一定程度上的依赖关系，一个线程的异常可能会影响到整个进程。</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/765ae27a848f8d2b6d7a3a3f75f49438/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring全局异常处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/18ef500dba444137a9dc8d9772875c82/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux环境—在线安装nginx</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>