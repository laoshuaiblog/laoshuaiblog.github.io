<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一些JAVA面试知识点 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/0b577d1a5f98d637c4feb65b89a37c2c/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="一些JAVA面试知识点">
  <meta property="og:description" content="1. 九种基本数据类型的大小，以及他们的封装类。 基本类型 大小(字节) 默认值 封装类 byte 1 (byte)0 Byte short 2 (short)0 Short int 4 0 Integer long 8 0L Long float 4 0.0f Float double 8 0.0d Double boolean - false Boolean char 2 \u0000(null) Character void - - Void 基本类型所占的存储空间是不变的：这种不变性也是java具有可移植性的原因之一。 基本类型是放在栈中，直接存储值。 所有数值类型都有正负号，没有无符号的数值类型。 注意： 1.int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。 2.基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值 3.数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。 2. Switch能否用string做参数？ 在 Java 7之前，switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。在 Java 7中，String支持被加上了。 3. equals与==的区别。 1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。 2.复合数据类型(类)，当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。 对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 3.String比较特殊：new的作为复合数据类型，直接双引号的作为基本类型。 4. Object有哪些公用方法？ 1)．clone方法 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。 主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。 2)．getClass方法 final方法，获得运行时类型。 3)．toString方法 该方法用得比较多，一般子类都有覆盖。 4)．finalize方法 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。 5)．equals方法 该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。 6)．hashCode方法 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 一般必须满足obj1.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-09-19T23:23:48+08:00">
    <meta property="article:modified_time" content="2016-09-19T23:23:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一些JAVA面试知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    1. 
<span style="white-space:pre"> </span>九种基本数据类型的大小，以及他们的封装类。 
<br> 基本类型 
<span style="white-space:pre"> </span>大小(字节) 
<span style="white-space:pre"> </span> 默认值 
<span style="white-space:pre"> </span>封装类 
<br> byte 
<span style="white-space:pre"> </span>      1 
<span style="white-space:pre"> </span>    (byte)0 
<span style="white-space:pre"> </span>Byte 
<br> short 
<span style="white-space:pre"> </span>      2 
<span style="white-space:pre"> </span>    (short)0 
<span style="white-space:pre"> </span>Short 
<br> int 
<span style="white-space:pre"> </span>      4 
<span style="white-space:pre"> </span>       0 
<span style="white-space:pre"> </span>Integer 
<br> long 
<span style="white-space:pre"> </span>      8 
<span style="white-space:pre"> </span>       0L 
<span style="white-space:pre"> </span>Long 
<br> float        4 
<span style="white-space:pre"> </span>      0.0f 
<span style="white-space:pre"> </span>Float 
<br> double 
<span style="white-space:pre"> </span>  8 
<span style="white-space:pre"> </span>       0.0d 
<span style="white-space:pre"> </span>Double 
<br> boolean 
<span style="white-space:pre"> </span>  - 
<span style="white-space:pre"> </span>           false 
<span style="white-space:pre"> </span>Boolean 
<br> char 
<span style="white-space:pre"> </span>      2 
<span style="white-space:pre"> </span>  \u0000(null) 
<span style="white-space:pre"> </span>Character 
<br> void 
<span style="white-space:pre"> </span>      - 
<span style="white-space:pre"> </span>            - 
<span style="white-space:pre"> </span>Void 
<br> 
<br> 
<br> 基本类型所占的存储空间是不变的：这种不变性也是java具有可移植性的原因之一。 
<br> 基本类型是放在栈中，直接存储值。 
<br> 所有数值类型都有正负号，没有无符号的数值类型。 
<br> 注意： 
<br> 1.int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。 
<br> 2.基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值 
<br> 3.数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。 
<br> 
<br> 
<br> 2. Switch能否用string做参数？ 
<br>    在 Java 7之前，switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。在 Java 7中，String支持被加上了。 
<br> 
<br> 
<br> 3. equals与==的区别。 
<br>     1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。  
<br> 2.复合数据类型(类)，当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。   对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 
<br> 3.String比较特殊：new的作为复合数据类型，直接双引号的作为基本类型。 
<br> 
<br> 
<br> 4. Object有哪些公用方法？ 
<br>     1)．clone方法 
<br> 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。 
<br> 主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。 
<br> 
<br> 
<br> 2)．getClass方法 
<br> final方法，获得运行时类型。 
<br> 
<br> 
<br> 3)．toString方法 
<br> 该方法用得比较多，一般子类都有覆盖。 
<br> 
<br> 
<br> 4)．finalize方法 
<br> 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。 
<br> 
<br> 
<br> 5)．equals方法 
<br> 该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。 
<br> 
<br> 
<br> 6)．hashCode方法 
<br> 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 
<br> 一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。 
<br> 如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。 
<br> 
<br> 
<br> 7)．wait方法 
<br> wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 
<br> 调用该方法后当前线程进入睡眠状态，直到以下事件发生。 
<br> （1）其他线程调用了该对象的notify方法。 
<br> （2）其他线程调用了该对象的notifyAll方法。 
<br> （3）其他线程调用了interrupt中断该线程。 
<br> （4）时间间隔到了。 
<br> 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。 
<br> 
<br> 
<br> 8)．notify方法 
<br> 该方法唤醒在该对象上等待的某个线程。 
<br> 
<br> 
<br> 9)．notifyAll方法 
<br> 该方法唤醒在该对象上等待的所有线程。 
<br> 
<br> 
<br> 5. Java的四种引用，强弱软虚，用到的场景。 
<br>     1、强引用 
<br> 强引用不会被GC回收，并且在java.lang.ref里也没有实际的对应类型，平时工作接触的最多的就是强引用。 
<br> 　 Object obj = new Object();这里的obj引用便是一个强引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 
<br> 2、软引用 
<br> 如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只 要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 
<br> 这里有几点需要说明： 
<br> 1、System.gc()告诉JVM这是一个执行GC的好时机，但具体执不执行由JVM决定（事实上这段代码一般都会执行GC) 
<br> 2、Thread.sleep(200); 这是因为从对象被回收到JVM将引用加入refQueue队列，需要一定的时间。而且poll并不是一个阻塞方法，如果没有数据会返回null，所以我们选择等待一段时间。 
<br> 3、弱引用 
<br> 如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回 收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。这里需要注意下： 
<br> 1、remove这是一个阻塞方法，类似于J.U.C并发包下的阻塞队列，如果没有队列没有数据，那么当前线程一直等待。  
<br> 2、如果队列有数据，那么remove和pool都会将第一个元素出队。 
<br> 4、幽灵引用(虚引用)  
<br> 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。由于Object.finalize()方法的不安全性、低效性，常常使用虚引用完成对象回收前的资源释放工作。参考我的另一篇博客：解释为什么finalize是不安全的，不建议使用  
<br> 这里特别需要注意：当JVM将虚引用插入到引用队列的时候，虚引用执行的对象内存还是存在的。但是PhantomReference并没有暴露API返回对象。所以如果我想做清理工作，需要继承PhantomReference类，以便访问它指向的对象。如NIO直接内存的自动回收，就使用到了sun.misc.Cleaner。
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b83821299bd53ab5518b37d227d5d4c5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; replace() 函数用法详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17ccff1d2e50b96be16728b4d5bd878f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">J2EE基础知识点总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>