<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>流水线问题--计算机体系结构 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/69f04a3c9daa2faa6439687784ba3a6a/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="流水线问题--计算机体系结构">
  <meta property="og:description" content="参考书：《计算机体系结构量化研究方法》 作者：John L. Hennessy
一、 基本概念 先理解几个基本概念：
流水线：是一种将多条指令重叠执行的实现技术。一条指令的执行需要多个操作，流水线技术充分利用了这些操作之间的并行性。
流水级：不同步骤并行完成不同指令的不同部分。这些步骤中的每一步都称为流水级或流水段
吞吐量：由指令退出流水线的频率决定。
处理器周期：一条指令在流水线中下移一步所需要的时间。一个处理器周期通常为1个时钟周期。（又是为2个，但要少见的多）
流水线的作用：缩短每条指令的平均执行时间。降低了每条指令时钟周期数（CPI）
1.1 RISC精简指令集基础知识 以MIPS指令集为例，其提供了32个寄存器，通常由以下三类指令：
1）ALU指令：取两个寄存器或者一个寄存器与一个符号扩展立即数进行运算并存储到第三个寄存器中
2）载入和存储指令：这些指令获取一个寄存器源（基址寄存器）和一个立即数字段（16位，偏移量），作为操作数计算有效地址用作存储器地址。
3）分支与跳转：条件转移。通常由两种方式指定分支条件：其一，采用一组条件位（条件码）；其二通过两个寄存器之间、寄存器与0之间的对比来设定。MIPS采用后者。
1.2 RISC指令集的简单实现 RISC子集中的每条指令都可以在最多5个时钟周期内实现，如下
1）指令提取周期（IF）
将程序计数器PC发送存储器，从存储器提取当前指令。向程序计数器加4（因为每条指令的长度为4个字节），将程序计数器更新到下一个连续计数器。
此周期操作：a.读取PC，b.更新PC
2）指令译码/寄存器提取周期（ID）
此周期操作：a.将指令译码，b.读取相应寄存器，c.判断是否为分支
这几点在下面都会有详细解释
3）执行/有效地址周期（EX）
此周期操作（其中之一）：a.计算有效地址（基址寄存器&#43;偏移量）b.在寄存器与寄存器之间进行运算,c.在寄存器与立即数之间进行运算
4）存储器访问（MEM）
操作（执行其中之一）：a.将寄存器写入存储器（写入）b.将存储器的内容读取到寄存器中（载入）
5）写回周期（WB）
将程序结果（来自ALU运算或载入指令）写入寄存器堆
1.3 RISC经典五级流水线 下面这种情况没有采用流水线结构，是简单的顺序执行，在执行完一个指令的五个周期后，才能执行下一条指令，如图所示：
这种方法存在着一个问题，比如参与运算的ALU单元平均在五个周期种只被使用了一次，硬件资源造成的很大程度上的浪费。于是我们采用了流水线结构，如下图所示：
流水线结构在每个时钟周期都会启动一条指令，其性能会达到非流水化处理器的5倍（理想情况下）。比如ALU单元，在每一个时钟周期都被用到了，相比于非流水化大大提高了硬件的利用率。IF ID EX MEM WB值得是指令集的5个时钟周期。
可能很难相信流水线是这么地简单，实际上，它的确不是这么简单。
下图是流水化形式的RISC数据路径的简化版本。如图：
流水线可以看作一系列随时间移动的数据路径。上图给出了数据路径不同部分之间的重叠，时钟周期数5（CC5）表示稳定状态，此状态下，一个时钟周期内，运行着五条指令的不同部分。寄存器左侧虚线表示写入，右侧虚线表示读取。IM表示指令存储器，DM表示数据存储器，CC表示时钟周期。
我们也可以看出来，主要功能单元（如ALU）是在不同周期使用的，因此多条指令的重叠执行不会引发多少冲突（实际上，不可避免会存在些许冲突即冒险问题，在后面会提到及其解决方案）。以下三点可以看出：
1）采用分离的指令存储器及数据存储器，并采用分离缓存的方式避免二者的访问冲突。不过相应开销是：存储器系统必须提供5倍的带宽。
2）在两个阶段都使用了寄存器堆（MIPS中由32个寄存器）：一是在ID中进行读取，一是在WB中进行写入。每次时钟周期会执行两次读取和一次写入。我们在时钟的前半周期写寄存器，后半周期读寄存器
3）为了每个时钟周期都会启动一条新指令，必须在IF阶段增加一加法器，一边为下一条指令做准备。此外，我们会在ID期间计算潜在的分支目标。
你会发现流水线最重要的就是：
1. 确保流水线中的指令不会试图在相同时间使用硬件资源。
2. 不同流水级中的指令不会互相干扰
因此在连续流水级中引入了流水线寄存器，如图所示
在流水化处理器中，如果要将中间结果从一级传送到另外一级，而源寄存器与目标地址可能并非直接相邻，这时候就是流水线寄存器发挥作用的时候了。例如：要在存储指令中存储的寄存器值是在ID期间进行读取的，但要等到MEM才会真正用到；他在MEM级中通过两个流水线寄存器传送到数据寄存器。于此类似，ALU指令的结果是在EX期间计算的，但要等到WB才会实际存储；
所以有必要对每个寄存器进行命名，称为：IF/ID,ID/EX,EX/MEM,MEM/WB。
流水化作用：提高了CPU指令吞吐量（单位时间内完成的指令数）。但不会缩短单条指令的执行时间。实际上它还会产生额外的开销
流水线开销：流水线寄存器延迟和时钟偏差。
二、 流水化冒险 上面介绍的流水线，我们假定指令之间都没有相互依赖关系。可实际上，流水线中的指令可能是存在依赖关系的。
若产生了依赖关系，再按照之前无停顿的顺序执行，就会产生冒险问题。有以下三种冒险：
1）结构冒险：比如两个指令都要访问存储器端口，可存储器只有一个写端口，这咋办？这时候就产生了资源冲突即结构冒险。
2）数据冒险：实际上，指令是存在一些先后顺序的，如果一些指令取决于先前的指令的结果，就可能导致数据冒险。
3）控制冒险：比如C语言中的if else语句，分支指令及其他改变程序计数器的指令实现流水化时可能会导致控制冒险。
这三种冒险总结如下表所示：
2.1 结构冒险 出现原因：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-08-22T17:57:05+08:00">
    <meta property="article:modified_time" content="2020-08-22T17:57:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">流水线问题--计算机体系结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考书：《计算机体系结构量化研究方法》 作者：John L. Hennessy</p> 
<h2><a id="__4"></a>一、 基本概念</h2> 
<p>先理解几个基本概念：</p> 
<p><strong>流水线</strong>：是一种将多条指令重叠执行的实现技术。一条指令的执行需要多个操作，流水线技术充分利用了这些操作之间的并行性。</p> 
<p><strong>流水级</strong>：不同步骤并行完成不同指令的不同部分。这些步骤中的每一步都称为流水级或流水段</p> 
<p><strong>吞吐量</strong>：由指令退出流水线的频率决定。</p> 
<p><strong>处理器周期</strong>：一条指令在流水线中下移一步所需要的时间。一个处理器周期通常为1个时钟周期。（又是为2个，但要少见的多）</p> 
<p>流水线的<strong>作用</strong>：缩短每条指令的平均执行时间。降低了每条指令时钟周期数（CPI）</p> 
<h3><a id="11_RISC_18"></a>1.1 RISC精简指令集基础知识</h3> 
<p>以MIPS指令集为例，其提供了32个寄存器，通常由以下三类指令：</p> 
<p><strong>1）ALU指令</strong>：取两个寄存器或者一个寄存器与一个符号扩展立即数进行运算并存储到第三个寄存器中</p> 
<p><strong>2）载入和存储指令</strong>：这些指令获取一个寄存器源（基址寄存器）和一个立即数字段（16位，偏移量），作为操作数计算有效地址用作存储器地址。</p> 
<p><strong>3）分支与跳转</strong>：条件转移。通常由两种方式指定分支条件：其一，采用一组条件位（条件码）；其二通过两个寄存器之间、寄存器与0之间的对比来设定。MIPS采用后者。</p> 
<h3><a id="12_RISC_28"></a>1.2 RISC指令集的简单实现</h3> 
<p>RISC子集中的每条指令都可以在最多5个时钟周期内实现，如下</p> 
<p><strong>1）指令提取周期（IF）</strong></p> 
<p>将程序计数器PC发送存储器，从存储器提取当前指令。向程序计数器加4（因为每条指令的长度为4个字节），将程序计数器更新到下一个连续计数器。</p> 
<p>此周期操作：a.读取PC，b.更新PC</p> 
<p><strong>2）指令译码/寄存器提取周期（ID）</strong></p> 
<p>此周期操作：a.将指令译码，b.读取相应寄存器，c.判断是否为分支</p> 
<p>这几点在下面都会有详细解释</p> 
<p><strong>3）执行/有效地址周期（EX）</strong></p> 
<p>此周期操作（其中之一）：a.计算有效地址（基址寄存器+偏移量）b.在寄存器与寄存器之间进行运算,c.在寄存器与立即数之间进行运算</p> 
<p><strong>4）存储器访问（MEM）</strong></p> 
<p>操作（执行其中之一）：a.将寄存器写入存储器（写入）b.将存储器的内容读取到寄存器中（载入）</p> 
<p><strong>5）写回周期（WB）</strong></p> 
<p>将程序结果（来自ALU运算或载入指令）写入寄存器堆</p> 
<h3><a id="13_RISC_56"></a>1.3 RISC经典五级流水线</h3> 
<p>下面这种情况没有采用流水线结构，是简单的顺序执行，在执行完一个指令的五个周期后，才能执行下一条指令，如图所示：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/d6/50/285k5FCt_o.png"></p> 
<p>这种方法存在着一个问题，比如参与运算的ALU单元平均在五个周期种只被使用了一次，硬件资源造成的很大程度上的浪费。于是我们采用了流水线结构，如下图所示：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/30/4a/YDhochQI_o.png"></p> 
<p>流水线结构在每个时钟周期都会启动一条指令，其性能会达到非流水化处理器的5倍（理想情况下）。比如ALU单元，在每一个时钟周期都被用到了，相比于非流水化大大提高了硬件的利用率。IF ID EX MEM WB值得是指令集的5个时钟周期。</p> 
<p>可能很难相信流水线是这么地简单，实际上，它的确不是这么简单。</p> 
<p>下图是流水化形式的RISC数据路径的简化版本。如图：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/07/6a/Ojty87Gv_o.png"></p> 
<p>流水线可以看作一系列随时间移动的数据路径。上图给出了数据路径不同部分之间的重叠，时钟周期数5（CC5）表示稳定状态，此状态下，一个时钟周期内，运行着五条指令的不同部分。寄存器左侧虚线表示写入，右侧虚线表示读取。IM表示指令存储器，DM表示数据存储器，CC表示时钟周期。</p> 
<p>我们也可以看出来，主要功能单元（如ALU）是在不同周期使用的，因此多条指令的重叠执行不会引发多少冲突（实际上，不可避免会存在些许冲突即冒险问题，在后面会提到及其解决方案）。以下三点可以看出：</p> 
<p>1）采用分离的指令存储器及数据存储器，并采用分离缓存的方式避免二者的访问冲突。不过相应开销是：存储器系统必须提供5倍的带宽。</p> 
<p>2）在两个阶段都使用了寄存器堆（MIPS中由32个寄存器）：一是在ID中进行读取，一是在WB中进行写入。每次时钟周期会执行两次读取和一次写入。我们在时钟的前半周期写寄存器，后半周期读寄存器</p> 
<p>3）为了每个时钟周期都会启动一条新指令，必须在IF阶段增加一加法器，一边为下一条指令做准备。此外，我们会在ID期间计算潜在的分支目标。</p> 
<p>你会发现流水线最重要的就是：</p> 
<p><strong>1. 确保流水线中的指令不会试图在相同时间使用硬件资源。<br> 2. 不同流水级中的指令不会互相干扰</strong></p> 
<p>因此在连续流水级中引入了<strong>流水线寄存器</strong>，如图所示<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/1a/11/JRrRyCuq_o.png"></p> 
<p>在流水化处理器中，如果要将中间结果从一级传送到另外一级，而源寄存器与目标地址可能并非直接相邻，这时候就是流水线寄存器发挥作用的时候了。例如：要在存储指令中存储的寄存器值是在ID期间进行读取的，但要等到MEM才会真正用到；他在MEM级中通过两个流水线寄存器传送到数据寄存器。于此类似，ALU指令的结果是在EX期间计算的，但要等到WB才会实际存储；</p> 
<p>所以有必要对每个寄存器进行命名，称为：IF/ID,ID/EX,EX/MEM,MEM/WB。</p> 
<p><strong>流水化作用</strong>：提高了CPU指令吞吐量（单位时间内完成的指令数）。但不会缩短单条指令的执行时间。实际上它还会产生额外的开销</p> 
<p><strong>流水线开销</strong>：流水线寄存器延迟和时钟偏差。</p> 
<h2><a id="__105"></a>二、 流水化冒险</h2> 
<p>上面介绍的流水线，我们假定指令之间都没有相互依赖关系。可实际上，流水线中的指令可能是存在依赖关系的。</p> 
<p>若产生了依赖关系，再按照之前无停顿的顺序执行，就会产生冒险问题。有以下三种冒险：</p> 
<p><strong>1）结构冒险</strong>：比如两个指令都要访问存储器端口，可存储器只有一个写端口，这咋办？这时候就产生了资源冲突即结构冒险。</p> 
<p><strong>2）数据冒险</strong>：实际上，指令是存在一些先后顺序的，如果一些指令取决于先前的指令的结果，就可能导致数据冒险。</p> 
<p><strong>3）控制冒险</strong>：比如C语言中的if else语句，分支指令及其他改变程序计数器的指令实现流水化时可能会导致控制冒险。</p> 
<p>这三种冒险总结如下表所示：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/8d/2d/3hPqZ9MV_o.png"></p> 
<h3><a id="21__120"></a>2.1 结构冒险</h3> 
<p>出现原因：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/74/ca/ugBCDqgq_o.png"></p> 
<p>如CC4阶段，同时对存储器进行了引用，如果只有一个存储器端口，就会产生冲突。</p> 
<p>当指令序列遇到这种冒险时，流水线将会使这些指令中的一个停顿，直到所需单元可用为止。这种停顿会增大CPI的值，使其不再是理想的1。我们把这些停顿称为<strong>流水线气泡</strong>或<strong>气泡</strong>。解决流图如下：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/0e/b4/rpfN6deC_o.png"></p> 
<p>载入指令强占了指令提取周期，导致流水线停顿。虽然浪费了流水线中的一个时钟周期，但避免了冲突。</p> 
<h3><a id="22__137"></a>2.2 数据冒险</h3> 
<p>举个栗子，以下指令：</p> 
<pre><code>DADD   R1,R2,R3 	 ;R1=R2+R3
DSUB   R4,R1,R5		 ;R4=R1-R5
AND    R6,R1,R7
OR     R8,R1,R9
XOR    R10,R1,R11
</code></pre> 
<p>DADD之后的指令都用到了DADD指令的结果。如图所示：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/5b/4e/Tw4iXfWG_o.png"></p> 
<p>DADD在WB流水级中写入R1的值，但DSUB在其ID中就要读取这个值，这个问题称为数据冒险。因为后面三条指令中使用DADD指令的结果时，由于要等到这些指令读取寄存器之后才会向其中写入，所以会导致冒险。</p> 
<h4><a id="221__155"></a>2.2.1 转发技术</h4> 
<p>这一问题，可以采用<strong>转发</strong>（forwarding）的简单硬件来解决（也称为<strong>旁路</strong>或<strong>短路</strong>）。此技术关键是：认识到DSUB要等到DADD实际生成结果之后才会真正用到它。DADD将此结果放在流水线寄存器中，然后转发，转发工作方式如下：</p> 
<p>1）来自EX/MEM和MEM/WB流水线寄存器的ALU结果总是被反馈回ALU的输入端</p> 
<p>2）如果转发硬件检测到前一个ALU操作对当前ALU操作的源寄存器进行了写入操作，则控制逻辑选择转发结果作为ALU的输入，而不是从寄存器堆中读取。</p> 
<p>如图所示：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/6a/f6/sQcQgRZL_o.png"></p> 
<p>这种情况不需要停顿，但是并非所有的数据冒险都可以通过转发解决。这就是下面提到的需要停顿的数据冒险</p> 
<h4><a id="222__169"></a>2.2.2 需要停顿的数据冒险</h4> 
<pre><code>LD     R1,0(R2)
DSUB   R4,R1,R5
AND    R6,R1,R7
OR     R8,R1,R9
</code></pre> 
<p>这个例子与上面的不同在于，上面的指令是ALU运算指令，其在EX阶段就能产生结果，但是载入指令LD就不能在当前周期产生结果，其必须在MEM周期得到结果。因此就没办法仅通过转发技术就消除这一冒险。我们需要增加一种称为流水线互锁以保持正确的执行模式。</p> 
<p>流水线互锁会导致流水线停顿，让需要使用某一数据的指令等待，直到源指令生成该数据为止。这种流水线互锁会引入一次停顿或者气泡。如图：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/7c/61/AtNVAG5R_o.png"></p> 
<h3><a id="23__186"></a>2.3 分支冒险（控制冒险）</h3> 
<p>对于MIPS流水线，控制冒险造成的性能损失可能比数据冒险还要大。在执行分支时，修改后的程序计数器的值可能等于也可能不等于当前值加4。介绍一个概念：</p> 
<p>选中分支：如果分支将程序计数器改为其目标地址，就代表选中分支，否则就是未选中位置。比如指令i是选中分支，通常会等到ID末尾，完成地址计算和对比之后才会改变程序计数器。</p> 
<p>处理分支最简单的方法是：在ID期间（此时对指令进行译码）检测到分支，就对分支之后的指令重新取值。第一个IF周期基本上就是一次停顿，因为它从来不会执行有用工作。如图所示：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/bb/44/ooOhtoAM_o.png"></p> 
<p>如果每个分支产生一个停顿，竟会使性能损失10%-20%，具体取决于分支频率，所以要研究一些用于应对这一损失的技术。</p> 
<p>有多种方法可以处理由分支延迟导致的流水线停顿，我们讨论四种简单的编译机制。我也很好奇它为啥会有这么多解决方案？？？</p> 
<h4><a id="231__202"></a>2.3.1 冻结或冲刷流水线</h4> 
<p>保留或删除分支之后的所有命令，直到知道目标分支为止。这也是上图的解决方案。这种情况下，开销是固定的，不能通过软件来缩减。</p> 
<h4><a id="232__206"></a>2.3.2 预测未选中机制</h4> 
<p>继续提取指令。将每一条分支都看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。如果分支被选中，就需要将已经提取的指令转为空操作，重新开始在目标地址提取指令。但这时候必须特别小心，因为在确切知道分支输入之前，不要改变处理器状态。复杂性在于：必须知道处理器状态可能何时被指令改变，以及如何撤销这种改变。实现过程如图所示：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/b4/35/gCC59RmJ_o.png"></p> 
<h4><a id="233__212"></a>2.3.3 预测选中机制</h4> 
<p>将所有分支都看作选中分支。只要对分支指令进行了译码并计算了目标地址，我们就假定该分支被选中，开始在目标位置提取和执行。</p> 
<h4><a id="234__216"></a>2.3.4 延迟分支</h4> 
<p>这种技术在RISC处理器种使用的非常广泛。在延迟分支种，带有一个分支延迟的执行周期为：</p> 
<p><em>分支指令<br> 依序后续指令<br> 选中时的分支目标</em></p> 
<p>依序后续指令位于分支延迟的间隔中。无论分支是否被选中，这一指令都会执行。我们要做的任务就是让这些必须进行的指令有效且可用。首先看一下延迟分支的行为特性。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/27/54/AU9WAmfR_o.png"></p> 
<p>尽管分支延迟可能长于1个时钟周期，但在实际中，几乎所有具有延迟的分支的处理器都会只有单个指令延迟。为了让这些指令延迟有效并可用，使用了多种优化方式，如下：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/d0/3a/8szjeQQ5_o.png"></p> 
<p>延迟分支的局限性在于</p> 
<p>a. 对于可排在延迟时隙中的指令有限制</p> 
<p>b. 在编译时预测分支是否可能被选中的能力有限。</p> 
<p>这种优化也都引入了一种取消或废除分支。在取消分支中，指令包含了预测分支的方向。当分支的行为与预期一致时，分支延迟时隙中的指令就像普通的延迟分支一样执行。不过也有可能把分支预测错误，此时，分支延迟时隙中的指令转为空操作。</p> 
<p>这四种方法的不同是：</p> 
<p>冻结或冲刷流水线导致对分支后续指令重新取值。此时会有一周期停顿；</p> 
<p>预测选中或未选中机制，导致选中分支目标后续指令变为空操作。</p> 
<p>延迟分支机制继续执行，不过采用调度，使其执行的指令尽可能有用。如果调度错误会将该分支转为空操作。</p> 
<h2><a id="_252"></a>三、流水化的实现</h2> 
<h3><a id="31_MIPS_254"></a>3.1 MIPS的简单实现</h3> 
<p>首先给出一种简单的非流水化实现，然后介绍流水化实现</p> 
<p>每种MIPS指令都可以在最多5个时钟周期中实现，分述如下：</p> 
<p>1）指令提取周期（IF）</p> 
<blockquote> 
 <p>Mem[PC] ==&gt; IR<br> PC + 4 ==&gt; NPC<br> 操作：送出PC到IR中，将PC递增4。IR保存将在后续时钟周期中需要的指令。NPC用于保存下一顺序PC</p> 
</blockquote> 
<p>2）指令译码/寄存器提取周期（ID）</p> 
<blockquote> 
 <p>Reg[rs] == &gt; A<br> Reg[rt] == &gt; B<br> IR的符号扩展立即数字段==&gt; Imm<br> 操作：对该指令进行译码，并访问寄存器堆（rs，rt为源寄存器）放到临时寄存器A和B中，IR的低16位也进行了符号扩展，并存储到临时寄存器Imm中，供下一个周期使用。</p> 
</blockquote> 
<p>3）执行/有效地址周期（EX）</p> 
<p>ALU对前一周期准备的操作数进行操作，根据MIPS指令类型执行以下4中功能之一</p> 
<blockquote> 
 <p>存储器引用<br> A + Imm ==&gt; ALUOUTPUT<br> 操作：ALU将操作数相加，得到实际地址，并将结果放在ALUOUTPUT中</p> 
</blockquote> 
<blockquote> 
 <p>寄存器-寄存器ALU指令<br> A func B ==&gt; ALUOUTPUT<br> 操作：对A,B中的取值执行由功能代码指定的操作，将结果放在ALUOUTPUT中</p> 
</blockquote> 
<blockquote> 
 <p>寄存器-立即数ALU指令<br> A op Imm ==&gt; ALUOUTPUT<br> 操作：对A,Imm中的取值执行由操作代码指定的操作，将结果放在ALUOUTPUT中</p> 
</blockquote> 
<blockquote> 
 <p>分支<br> NPC + (Imm &lt;&lt; 2)==&gt; ALUOUTPUT<br> (A == 0) ==&gt; Cond<br> 操作：ALU将NPC加到Imm中的符号扩展立即数，将立即数左移2位，得到一个字偏移量，以计算分支目标。Cond为0是分支的标志。</p> 
</blockquote> 
<p>4）存储器访问（MEM）</p> 
<p>对所有的指令更新PC：NPC ==&gt; PC</p> 
<blockquote> 
 <p>存储器引用<br> Mem[ALUOUTPUT] ==&gt; LMD 或<br> B ==&gt; Mem[ALUOUTPUT]<br> 操作：访问寄存器。如果指令为载入指令，则从存储器返回数据，将其放入LMD（载入存储器数据）寄存器中。其都需要在ALUOUT存放的ALU计算得到的实际地址。</p> 
</blockquote> 
<blockquote> 
 <p>分支<br> If (cond) ALUOUTPUT ==&gt; PC<br> 操作：如果指令为分支指令，则用寄存器ALUOUTPUT中的分支目标地址代替PC</p> 
</blockquote> 
<p>5）写回周期（WB）</p> 
<blockquote> 
 <p>寄存器-寄存器ALU指令<br> ALUOUTPUT ==&gt; Regs[rd]</p> 
</blockquote> 
<blockquote> 
 <p>寄存器-立即数ALU指令<br> ALUOUTPUT ==&gt; Regs[rt]</p> 
</blockquote> 
<blockquote> 
 <p>载入指令<br> LMD ==&gt; Regs[rt]</p> 
</blockquote> 
<p>操作：无论结果来自存储器系统（在LMD中）还是ALU，都将其写到寄存器堆中。</p> 
<p>此中，rs，rt为两个源寄存器，rd为目的寄存器。</p> 
<p>同时出现一个问题，在写回周期的载入指令中，为什么非要通过LMD才能写回寄存器呢？看下面这个数据流图就明白了：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/f6/e6/wWmhvuHw_o.png"><br> 因为存储器数据只能容国LMD存储至寄存器堆</p> 
<p>此中，mux为多工器即数据选择器。</p> 
<h3><a id="32_MIPS_338"></a>3.2 MIPS基本流水线</h3> 
<p>上图为顺序结构，我们几乎不需要什么改变就可以对上图的数据路径实现流水线。如图：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/6a/d9/S0a2Hmjd_o.png"></p> 
<p>流水线寄存器用于从一个流水级向下一个流水级传送数据和控制。每个流水级上的事件如下：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/19/4c/QDysPaQT_o.png"></p> 
<p>注意：前两级的操作与当前指令类型无关。由于要等到ID级结束时才会对指令进行译码，所以前两级操作必须与当前指令无关。IF行为取决于EX/MEM中的指令是否为选中分支。如果是，则会在IF结束时将EX/MEM中的分支指令的目标地址写入PC中，如果不是，则写回递增后的PC.</p> 
<p>分析一下多工器的作用：</p> 
<p>ALU级的两个多工器根据指令类型设定，由ID/EX寄存器的IR字段规定。上面的ALU输入多工器根据该指令是否为分支来设定，下面的多工器根据指令时寄存器-寄存器操作，还是ALU操作还是任意其他类型的操作来设定的。IF级的多工器选择是递增PC的值，还是EX/MEM.ALUOUTPUT的值来写入PC。这个多工器由EX/MEM.Cond字段控制。第四个多工器由WB级的指令是载入指令还是ALU指令来控制。</p> 
<h3><a id="33__358"></a>3.3 处理分支问题</h3> 
<p>在MIPS中，分支需要对比两个寄存器的值，在ID周期结束时完成此判断。为了充分利用尽早判断出该分支是否命中懂得优势，都必须尽早计算PC。在ID期间计算分支目标地址需要一个加法器。下图为修改后额流水化数据路径。<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/a4/ac/KWdo6I3J_o.png"><br> 增加独立的加法器在ID期间做出分支判断，分支仅需要停顿1个时钟周期</p> 
<h2><a id="_366"></a>四、交叉问题/记分卡</h2> 
<p>如果存在不可避免地冒险，冒险检测硬件会使流水线停顿。在清除这种相关性之前，不会提取或发射指令。为了弥补这些性能地损失，编译器尝试调度指令来避免冒险；这种方法称为<strong>编译器调度</strong>或<strong>静态调度</strong>。</p> 
<p>目前为止，讨论的所有技术都是使用循序指令发射，无调度，这意味着如果一条指令在流水线中停顿，将不能处理后续指令。在采用循序发射时，如果两条指令之间存在冒险，即使后面存在一些不相关的、不会停顿的指令，流水线也会停顿。</p> 
<p>在流水线中，结构性冒险和数据冒险都是在指令译码ID期间进行检查的：当一条指令可以正确执行时，也是从ID发射出去的。我们必须将发射过程分为两部分：检查结构性冒险以及等待数据冒险的消失。循序对指令进行译码和发射；但是，我们希望指令在其数据操作数可用是立即开始执行。因此流水线是乱序执行的，也就暗示是乱序完成的。为了实现乱序执行，我们必须将ID流水级分为两级。</p> 
<p><strong>1）发射</strong>：指令译码，检查结构性冒险</p> 
<p><strong>2）读取操作数</strong>：等到没有数据冒险，随后读取操作数</p> 
<p>采用计分卡的<strong>动态调度</strong></p> 
<p>在动态调度流水线中，所有指令都是循序通过发射级；但是，它们可能在第二级读取操作数级停顿，或者绕过其他指令，然后进行乱序执行状态。记分卡技术再有足够的资源、没有数据依赖时，允许指令乱序执行。这一功能是在CDC 6600记分卡中开发的，因此而得名。</p> 
<p>在介绍记分卡之前先介绍一种乱序执行可能会出现的写后读（WAR）数据冒险问题，这在之前循序执行指令时是不会出现的，情况如下：</p> 
<pre><code>DIV.D  FO,F2,F4
ADD.D  F10,F0,F8
SUB.D  F8,F8,F14
</code></pre> 
<p>ADD.D和SUB.D之间存在一种反相关性：意思就是如果乱序执行时先执行了SUB.D就会导致ADD.D数据错误，这就是读后写问题。于此类似，为避免违反输出相关性，也必须检查写后写WAW问题。而记分卡通过停顿反相关中设计的后续指令，避免了两种冒险。</p> 
<p>记分卡目标：通过尽早执行指令，保持每时钟周期1条指令的执行速率。</p> 
<p>记分卡负责：指令的发射与执行，包括所有的冒险检测任务</p> 
<p>要充分利用乱序执行，需要在其EX级中同时有多条指令。这一点可以通过多个功能单元、流水化功能单元或同时利用两者来实现。</p> 
<p>CDC6600拥有16个独立的功能单元，包括4个浮点单元5个存储器引用单元和7个整数运算单元。如图：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ec/a0/VwIF6dxd_o.png"></p> 
<p>记分卡的功能时控制指令执行。如上图：共有两个浮点乘法器、一个浮点除法器、一个浮点加法器和一个整数单元。一组总线（两个输入和一个输出）充当一组功能单元。</p> 
<p>每条指令进入记分卡，都会构建一条数据相关性记录；并由记分卡判断指令什么时候能够读取它的操作数并开始执行。</p> 
<p>在详细介绍记分卡之前，我们需要知道每条指令都需要经历四个执行步骤：</p> 
<p><strong>1）发射</strong>，如果指令的功能单元空闲，并且不存在冒险时，记分卡向功能单元发射指令，并更新内部数据结构。如果存在结构性冒险或WAW冒险，则指令发射停顿，在清除这些冒险之前，不会再发射其他指令。当发射级停顿时，会导致指令提取与发射之间的缓冲区填满；如果缓冲区是拥有多条指令的队列，则在队列填满后停顿。</p> 
<p><strong>2）读取操作数</strong>，记分卡见时源操作数的可用性。源操作数可用时，记分卡告诉功能单元继续从寄存器读取操作数，并开始执行。记分卡在这一步动态解决RAW问题，可以发送指令以进行乱序执行</p> 
<p><strong>3）执行</strong>，功能单元接收到操作数开始执行。结果准备就绪后，通知记分卡已经完成执行</p> 
<p><strong>4）写结果</strong>，记分卡知道功能单元已经完成执行，则检查WAR冒险，并在必要时停顿正在完成的指令。</p> 
<p>一般来说，存在以下情况时，不能允许一条正在执行的指令写入其结果：</p> 
<p>a. 在正在执行的指令前边有一条指令还没有读取其操作数（WAR数据冒险）</p> 
<p>b. 这些操作数之一与正在执行指令的结果是同一寄存器（WAW数据冒险）</p> 
<p>记分卡究竟是怎么执行的呢？看一个例子：</p> 
<pre><code>L.D    F6,34(R2)
L.D    F2,45(R3)
MUL.D  F0,F2,F4
SUB.D  F8,F6,F2
DIV.D  F10,F0,F6
ADD.D  F6,F8,F2
</code></pre> 
<p>记分卡中的信息如下</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/62/b4/6KAkvfuS_o.png"></p> 
<p>记分卡共有3个部分：</p> 
<p><strong>1）指令状态</strong>：指出指令位于4个步骤中的哪一步</p> 
<p><strong>2）功能单元状态</strong>：指出功能单元FU的状态，共有9个字段</p> 
<p><em>忙：指示该单元是否繁忙。<br> Op：在此单元中执行的运算，如加减<br> Fi：目标寄存器<br> Fj，Fk：源寄存器标号<br> Qj，Qk：生成源寄存器Fj、Fk的功能单元<br> Rj，Rk：只是Fj，Fk已准备就绪尚未读取的标记。在读取操作数后将其设置为否</em></p> 
<p><strong>3）寄存器结果状态</strong>：如果一条活动指令以该寄存器为目标寄存器，则指出哪个功能单元将写入寄存器。只要没有向该寄存器写入的未完成指令，则将此字段设置为空。</p> 
<p>再说明一下每个执行步骤中记分卡都需要做些什么：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/fa/d4/es7BVndr_o.png"></p> 
<p>记分卡利用ILP(指令级并行)，在最大程度上降低因为程序数据相关导致的停顿数目。在消除停顿方面，记分卡受以下几个因素的影响。</p> 
<p><strong>1）指令间可用并行数</strong>：这一因素决定了能否找到要执行的独立命令</p> 
<p><strong>2）记分卡的项数</strong>：这一因素决定了流水线为了查找不相关命令可以向前查找多少条指令。这组作为潜在执行对象的指令被称为窗口。记分卡的大小决定了窗口的大小。</p> 
<p><strong>3）功能单元的数目和类型</strong>：这一因素决定了结构性冒险的重要性，他可能会在使用动态调度是增加。</p> 
<p><strong>4）存在反相关和数据相关</strong>：它们会导致WAR和WAW停顿。</p> 
<p>啊！睡个好觉！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5fb6992b17695bf64b92a26ff5144a57/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java——计算用户输入的日期离1900年1月1日相距多少天</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43df8358935e7e6b85353c05b4482780/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序详解wx:if elif else的用法(搭配view、block)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>