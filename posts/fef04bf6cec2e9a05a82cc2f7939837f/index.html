<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>密码学—安全归约问题(Reduction) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/fef04bf6cec2e9a05a82cc2f7939837f/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="密码学—安全归约问题(Reduction)">
  <meta property="og:description" content="Reduction in Cryptography me看了很多文章，但是还是有点不太明白，总之学习之前你要有一定的密码学基础以及要记住一句话：“原命题与逆否命题同真同假！”
归约 首先用词应该是归约(reduction)，而不是规约。
归约通俗的讲，就是把一个密码方案的安全性建立在一个已知的困难问题上。我们假设存在PPT的敌手(adversary)可以以不可忽略(non-negligible)的优势(advantage)攻破此密码方案，那么通过归约(reduction)，就可以同样以不可忽略的优势破解该困难问题。这与我们对该困难问题已知的困难性(hardness)相互矛盾(contradiction)，所以不可能存在这样的敌手去攻破我们的密码方案，因此他是安全的。
1 从问题出发 假设现在我们提出了一个密码学方案或者协议 Π \Pi Π,我们需要证明它是安全的。怎么证明？
我们的协议一般是建立在已经被证明安全的协议/方案上面，或者建立在某些困难问题（记为Y）上面，比如RSA公钥加密算法就是建立在因数分解困难问题上。为了简化证明，站在巨人的肩膀上，我们希望通过搭建下面的逻辑命题关系来完成我们的证明。
条件命题1：只要Y是安全的，那么我们的方案 Π \Pi Π就是安全的。换句话说，若Y被有效攻破，那么 Π \Pi Π就不再安全。
这样做的好处是，我们站在了巨人的肩膀上：我们不需要从头开始证明，而是从Y开始。大大简化我们的证明过程。
密码学中的归约证明（reduction proof）是密码学非常重要的知识。现代密码学中的几大公钥加密算法建立在几个困难问题假设上面，比如大整数因数分解困难问题（Integer factorization）和离散对数问题（Discrete log problem）。很多现代密码协议或者密码加密方案建立在这些困难问题上面，比如RSA公钥加密算法就是建立在因数分解困难问题上，因此，如果某一天该困难问题能被快速计算出来（多项式时间复杂度），那么所有建立在这个假设上面的协议/方案都变得不安全了。
如何去证明呢？ 根据离散数学的条件命题的逻辑等价式，若两个命题有如下关系： p → q p\rightarrow q p→q,等价于 ⇁ q → ⇀ p \rightharpoondown q\rightarrow \rightharpoonup p ⇁q→⇀p 。比如“只要晴天，我就去跑步”，等价于“如果我不去跑步，那么不是晴天”。这个命题等价式是“反证法”的基础。它被用在规约证明中证明某一个新提出的方案X的安全性（也即是下面的Thm），证明的形式为：
Thm（定理）：Y 是安全的 → \rightarrow →X是安全的。
证明：
通过等价变换，也即是要证明（记为条件命题2）：X不是安全的 → \rightarrow →Y不是安全的。
条件命题2进一步解释为：如果存在PPT的对手A可以攻破X，那么我们能构造一个PPT的敌手B来攻破Y。
其中，X是我们新提出的方案，Y某一个困难问题，PPT是多项式概率时间的英文缩写。“构造”一词可以理解为模拟。
如果我们能够让上面粗体的条件命题2成立，那么我们就完成了归约证明。这其实是一个反证法：若上面粗体的条件命题2成立，也意味着Thm成立，完成证明。
小结：现在我们明白了我们为什么要使用归约证明，以及使用归约证明的基本形式。接下来的问题是，如何来构造这个条件命题？
2 构造条件命题 我们将上面（B,Y）和(A,X)的关系表示成下图。其中A是试图攻破X的敌手；B是试图攻破Y的敌手。A作为B的一部分，B并不知道A是如何工作的。B是A的外部环境，它要模拟对A的输入和接收A的输出，让A完成对X的攻击游戏。密码学中经常使用Game的形式来定义一个协议的安全性。虽然A的外部环境是由B模拟的，但是，我们要求该模拟的环境等价于真实的A攻击X的game的环境（或者说A无法区分其外部环境是模拟的还是真实的）。因此，这里我们也叫B为模拟器。
除了B要完成上面的工作，它还需要应对别人（B的外部环境）对它的挑战：挑战B能否攻破Y。
结合下图，intuitively，在B接收到外部环境的挑战（chel）之后，将chel进行适当变换（图中红色部分，也即是进行模拟），将其输入给A，让A挑战X。B根据A的输出，适当地变换输出值，输出给外部环境，完成挑战。因此，B对Y的挑战转嫁到A对X的挑战上了。如果我们能够将下面条件关系关联起来，就完成了证明：A对X挑战成功-&amp;gt;B对Y挑战成功，或者说 只要X不安全 -&amp;gt; 那么Y就不安全。
如何建模“挑战成功”？我们使用概率。在二选一的Game中，如果A成功的概率为1/2&#43;non-neg(n),那么A就是成功的。neg（n）表示很小的值；而non-neg表示不是很小的值。同理，如果B要赢这个挑战Y的Game，其成功的概率也需要1/2&#43;non-neg(n)。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-06-16T09:24:03+08:00">
    <meta property="article:modified_time" content="2021-06-16T09:24:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">密码学—安全归约问题(Reduction)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Reduction_in_Cryptography_0"></a>Reduction in Cryptography</h2> 
<hr> 
<p>me看了很多文章，但是还是有点不太明白，总之学习之前你要有一定的密码学基础以及要记住一句话：“<strong>原命题与逆否命题同真同假！</strong>”</p> 
<h4><a id="_3"></a>归约</h4> 
<p>首先用词应该是归约(reduction)，而不是规约。<br> 归约通俗的讲，就是把一个密码方案的安全性建立在一个已知的困难问题上。我们假设存在PPT的敌手(adversary)可以以不可忽略(non-negligible)的优势(advantage)攻破此密码方案，那么通过归约(reduction)，就可以同样以不可忽略的优势破解该困难问题。这与我们对该困难问题已知的困难性(hardness)相互矛盾(contradiction)，所以不可能存在这样的敌手去攻破我们的密码方案，因此他是安全的。</p> 
<h3><a id="1__7"></a>1 从问题出发</h3> 
<p>假设现在我们提出了一个密码学方案或者协议<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Π 
        
       
      
        \Pi 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Π</span></span></span></span></span>,我们需要证明它是安全的。怎么证明？</p> 
<p>我们的协议一般是建立在已经被证明安全的协议/方案上面，或者建立在某些困难问题（记为Y）上面，比如RSA公钥加密算法就是建立在因数分解困难问题上。为了简化证明，站在巨人的肩膀上，我们希望通过搭建下面的逻辑命题关系来完成我们的证明。</p> 
<p><strong>条件命题1：只要Y是安全的，那么我们的方案<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          Π 
         
        
       
         \Pi 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Π</span></span></span></span></span>就是安全的。换句话说，若Y被有效攻破，那么<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          Π 
         
        
       
         \Pi 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Π</span></span></span></span></span>就不再安全。</strong></p> 
<p>这样做的好处是，我们站在了巨人的肩膀上：我们不需要从头开始证明，而是从Y开始。大大简化我们的证明过程。</p> 
<blockquote> 
 <p>密码学中的归约证明（reduction proof）是密码学非常重要的知识。现代密码学中的几大公钥加密算法建立在几个困难问题假设上面，比如大整数因数分解困难问题（Integer factorization）和离散对数问题（Discrete log problem）。很多现代密码协议或者密码加密方案建立在这些困难问题上面，比如RSA公钥加密算法就是建立在因数分解困难问题上，因此，如果某一天该困难问题能被快速计算出来（多项式时间复杂度），那么所有建立在这个假设上面的协议/方案都变得不安全了。</p> 
</blockquote> 
<h4><a id="_19"></a>如何去证明呢？</h4> 
<p>根据离散数学的条件命题的逻辑等价式，若两个命题有如下关系： <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
         → 
        
       
         q 
        
       
      
        p\rightarrow q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span></span></span></span></span>,等价于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ⇁ 
        
       
         q 
        
       
         → 
        
       
         ⇀ 
        
       
         p 
        
       
      
        \rightharpoondown q\rightarrow \rightharpoonup p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">⇁</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">q</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">⇀</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span> 。比如“只要晴天，我就去跑步”，等价于“如果我不去跑步，那么不是晴天”。这个命题等价式是“反证法”的基础。它被用在规约证明中证明某一个新提出的方案X的安全性（也即是下面的Thm），证明的形式为：</p> 
<p>Thm（定理）：Y 是安全的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         → 
        
       
      
        \rightarrow 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">→</span></span></span></span></span>X是安全的。</p> 
<p>证明：</p> 
<p><em>通过等价变换，也即是要证明（记为条件命题2）：<strong>X不是安全的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           → 
          
         
        
          \rightarrow 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">→</span></span></span></span></span>Y不是安全的</strong>。</em></p> 
<p><em>条件命题2进一步解释为：<strong>如果存在PPT的对手A可以攻破X，那么我们能</strong>构造<strong>一个PPT的敌手B来攻破Y。</strong></em></p> 
<p>其中，X是我们新提出的方案，Y某一个困难问题，PPT是多项式概率时间的英文缩写。“构造”一词可以理解为模拟。</p> 
<p>如果我们能够让上面粗体的条件命题2成立，那么我们就完成了归约证明。<strong>这其实是一个反证法：若上面粗体的条件命题2成立，也意味着Thm成立，完成证明。</strong></p> 
<p>小结：现在我们明白了我们为什么要使用归约证明，以及使用归约证明的基本形式。接下来的问题是，如何来构造这个条件命题？</p> 
<h3><a id="2__38"></a>2 构造条件命题</h3> 
<p>我们将上面（B,Y）和(A,X)的关系表示成下图。其中A是试图攻破X的敌手；B是试图攻破Y的敌手。A作为B的一部分，B并不知道A是如何工作的。B是A的外部环境，它要模拟对A的输入和接收A的输出，让A完成对X的攻击游戏。密码学中经常使用Game的形式来定义一个协议的安全性。虽然A的外部环境是由B模拟的，但是，我们要求该模拟的环境等价于真实的A攻击X的game的环境（或者说A无法区分其外部环境是模拟的还是真实的）。因此，这里我们也叫B为模拟器。</p> 
<p>除了B要完成上面的工作，它还需要应对别人（B的外部环境）对它的挑战：挑战B能否攻破Y。</p> 
<p>结合下图，intuitively，在B接收到外部环境的挑战（chel）之后，将chel进行适当变换（图中红色部分，也即是进行模拟），将其输入给A，让A挑战X。B根据A的输出，适当地变换输出值，输出给外部环境，完成挑战。因此，<strong>B对Y的挑战转嫁到A对X的挑战上了</strong>。如果我们能够将下面条件关系关联起来，就完成了证明：A对X挑战成功-&gt;B对Y挑战成功，或者说 只要X不安全 -&gt; 那么Y就不安全。</p> 
<p>如何建模“挑战成功”？我们使用概率。在二选一的Game中，如果A成功的概率为1/2+non-neg(n),那么A就是成功的。neg（n）表示很小的值；而non-neg表示不是很小的值。同理，如果B要赢这个挑战Y的Game，其成功的概率也需要1/2+non-neg(n)。</p> 
<p><img src="https://images2.imgbox.com/7b/9c/YXyxjWqk_o.jpg" alt="在这里插入图片描述"><br> 小结：</p> 
<p>证明过程需要：</p> 
<p>（1）PPT：A是PPT的；红色部分的计算复杂度是PPT的。具体“红色部分”是什么呢？不同的协议不一样，下面会给出example。</p> 
<p>（2）模拟：B所模拟A的外部环境需要看起来像“挑战X的game”的外部环境。</p> 
<p>（3） 概率：通过概率计算出下面命题成立，来证明“A对X挑战成功<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         → 
        
       
      
        \rightarrow 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">→</span></span></span></span></span>B对Y挑战成功”：P(A) = 1/2+non-neg(n) <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         → 
        
       
      
        \rightarrow 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">→</span></span></span></span></span> P(B) =1/2+non-neg(n)（它的逆反命题是：只要Y是安全 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         → 
        
       
      
        \rightarrow 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">→</span></span></span></span></span> 那么X就是安全）</p> 
<h3><a id="_61"></a><strong>如有错误，欢迎交流指正，谢谢！</strong></h3> 
<p>reference</p> 
<ol><li> <p><a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DzHMecblCmAM%26list%3DPL4wmOqlgHT2lBQfChNbkNaTlJOXrqIlHe%26index%3D3" rel="nofollow">https://www.youtube.com/watch?v=zHMecblCmAM&amp;list=PL4wmOqlgHT2lBQfChNbkNaTlJOXrqIlHe&amp;index=3</a></p> </li><li> <p>《Introduction to Modern Cryptography, second edition》, page 65.</p> </li><li> <p>参考：https://www.zhihu.com/question/49441102/answer/1737942968</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/561520527a011d6af849f6e0c4b5da1a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于RxJava2.0&#43;Retrofit2.0超大文件分块（分片）上传（带进度）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e78b73fc8ac0993d4018f33a2aee0a17/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">❤520情人节送女朋友的生日礼物~html&#43;css&#43;js实现抖音炫酷樱花3D相册(含音乐)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>