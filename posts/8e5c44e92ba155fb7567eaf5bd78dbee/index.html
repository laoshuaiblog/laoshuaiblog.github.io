<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【ES6】Set和Map数据结构 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/8e5c44e92ba155fb7567eaf5bd78dbee/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【ES6】Set和Map数据结构">
  <meta property="og:description" content="目录
Set
用法 Set属性和方法
遍历
Map
用法
属性和方法
遍历 Set 用法 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
Set本身是一个构造函数，用来生成 Set 数据结构。add()方法向 Set 结构加入成员。例：
const s = new Set(); [2, 3, 2, 4, 4, 5, 2].forEach(x =&amp;gt; s.add(x)); for (let i of s) { console.log(i); } // 2 3 4 5 上面代码通过add()方法加入成员，遍历输出后可见没有重复的值。
Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。所以可以用Set来给数组去重。例：
//单个数组去重 let array = [1, 2, 2, 3, 3, 4, 5, 5] let uniqueArray = new Set(array) console.log(uniqueArray) //两个数组去重 const array1 = [1, 2, 3, 4] const array2 = [3, 4, 5, 6] // 将两个数组合并并使用Set去重 const mergedArray = new Set([.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-25T11:25:00+08:00">
    <meta property="article:modified_time" content="2024-03-25T11:25:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【ES6】Set和Map数据结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li> <p id="main-toc"><strong>目录</strong></p> <p id="Set-toc" style="margin-left:0px;"><a href="#Set" rel="nofollow">Set</a></p> <p id="%E7%94%A8%E6%B3%95%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%94%A8%E6%B3%95%C2%A0" rel="nofollow">用法 </a></p> <p id="Set%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#Set%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95" rel="nofollow">Set属性和方法</a></p> <p id="%C2%A0%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%C2%A0%E9%81%8D%E5%8E%86" rel="nofollow"> 遍历</a></p> <p id="Map-toc" style="margin-left:0px;"><a href="#Map" rel="nofollow">Map</a></p> <p id="%C2%A0%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A0%E7%94%A8%E6%B3%95" rel="nofollow"> 用法</a></p> <p id="%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95" rel="nofollow">属性和方法</a></p> <p id="%E9%81%8D%E5%8E%86%C2%A0-toc" style="margin-left:40px;"><a href="#%E9%81%8D%E5%8E%86%C2%A0" rel="nofollow">遍历 </a></p> 
  <hr id="hr-toc"><p></p> <h2>Set</h2> </li></ul> 
<h3 id="%E7%94%A8%E6%B3%95%C2%A0">用法 </h3> 
<p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p> 
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。<code>add()</code>方法向 Set 结构加入成员。例：</p> 
<pre><code>const s = new Set();

[2, 3, 2, 4, 4, 5, 2].forEach(x =&gt; s.add(x));

for (let i of s) {
  console.log(i);
}
// 2 3 4 5</code></pre> 
<p>上面代码通过add()方法加入成员，遍历输出后可见没有重复的值。</p> 
<p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。所以可以用Set来给数组去重。例：</p> 
<pre><code>//单个数组去重
let array = [1, 2, 2, 3, 3, 4, 5, 5]
let uniqueArray = new Set(array)
console.log(uniqueArray)

//两个数组去重
const array1 = [1, 2, 3, 4]
const array2 = [3, 4, 5, 6]

// 将两个数组合并并使用Set去重
const mergedArray = new Set([...array1, ...array2])
console.log(mergedArray)

// 计算两个数组的交集
const intersection = array1.filter((item) =&gt; array2.includes(item))
console.log(intersection)

// 计算两个数组的并集
const union = [...new Set([...array1, ...array2])]
console.log(union)

// 计算两个数组的差集
// const difference = array1.filter((item) =&gt; !array2.includes(item))
// console.log(difference)
const difference1 = array1.filter((item) =&gt; !array2.includes(item))
const difference2 = array2.filter((item) =&gt; !array1.includes(item))

const symmetricDifference = [...difference1, ...difference2]

console.log(symmetricDifference)
</code></pre> 
<p>上面的方法也可以用于，去除字符串里面的重复字符。</p> 
<pre><code>[...new Set('ababbc')].join('')
// "abc"</code></pre> 
<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>"5"</code>是两个不同的值。“Same-value-zero equality”可用来判断Set 内部两个值是否不同，类似于精确相等运算符（<code>===</code>），区别在于向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p> 
<pre><code>let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}
</code></pre> 
<p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等的。</p> 
<p>另外，两个对象总是不相等的。</p> 
<pre><code>let set = new Set();

set.add({});
set.size // 1

set.add({});
set.size // 2
</code></pre> 
<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p> 
<h3 id="Set%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">Set属性和方法</h3> 
<p>Set 结构的实例有以下属性。</p> 
<ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul> 
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p> 
<ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul> 
<h3 id="%C2%A0%E9%81%8D%E5%8E%86"> 遍历</h3> 
<p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p> 
<ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul> 
<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p> 
<ul><li> <h2 id="Map">Map</h2> </li></ul> 
<h3 id="%C2%A0%E7%94%A8%E6%B3%95"> 用法</h3> 
<p>Map 数据结构，类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p> 
<p>添加、删除成员：</p> 
<pre><code>const m = new Map();
const o = {p: 'Hello World'};

m.set(o, 'content')
m.get(o) // "content"

m.has(o) // true
m.delete(o) // true
m.has(o) // false
</code></pre> 
<p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p> 
<p>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。例：</p> 
<pre><code>const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

map.size // 2
map.has('name') // true
map.get('name') // "张三"
map.has('title') // true
map.get('title') // "Author"
</code></pre> 
<p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p> 
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。如果读取一个未知的键，则返回<code>undefined</code>。</p> 
<h3 id="%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">属性和方法</h3> 
<ul><li><strong>size 属性</strong></li></ul> 
<p><code>size</code>属性返回 Map 结构的成员总数。</p> 
<ul><li><strong>Map.prototype.set(key, value)</strong></li></ul> 
<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p> 
<ul><li><strong>Map.prototype.get(key)</strong></li></ul> 
<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p> 
<ul><li><strong>Map.prototype.has(key)</strong></li></ul> 
<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p> 
<ul><li><strong>Map.prototype.delete(key)</strong></li></ul> 
<p><code>delete()</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p> 
<ul><li><strong>Map.prototype.clear()</strong></li></ul> 
<p><code>clear()</code>方法清除所有成员，没有返回值。</p> 
<h3 id="%E9%81%8D%E5%8E%86%C2%A0">遍历 </h3> 
<p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p> 
<ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul> 
<p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c9c89cd2f64f509846e94a120c63ece/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">中国历年台风最佳路径数据集(1949-2019)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cef575f8a5e9a3397de909238d5abd26/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">由浅到深认识Java语言（26）：阶段性练习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>