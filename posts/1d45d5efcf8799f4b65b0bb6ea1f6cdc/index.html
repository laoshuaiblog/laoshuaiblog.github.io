<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于Vue中props的详解 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/1d45d5efcf8799f4b65b0bb6ea1f6cdc/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="关于Vue中props的详解">
  <meta property="og:description" content="看一下官方文档：
组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。父组件的数据需要通过 prop 才能下发到子组件中。
也就是props是子组件访问父组件数据的唯一接口。
详细一点解释就是：
一个组件可以直接在模板里面渲染data里面的数据（双大括号）。
子组件不能直接在模板里面渲染父元素的数据。
如果子组件想要引用父元素的数据，那么就在prop里面声明一个变量（比如a），这个变量就可以引用父元素的数据。然后在模板里渲染这个变量（前面的a），这时候渲染出来的就是父元素里面的数据。
1. 基本用法 图1-props
&amp;lt;div id=&#34;app1&#34;&amp;gt; &amp;lt;!-- hello引用父元素的hello，它也可以引用message,greet，world等 --&amp;gt; &amp;lt;child :hello=&#39;hello&#39;&amp;gt;&amp;lt;/child&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var com1 = Vue.component(&#39;child&#39;,{ // 声明在prop中的变量可以引用父元素的数据 props:[&#39;hello&#39;], // 这里渲染props中声明的那个hello template:&#39;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;{{ hello }}&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&#39;, }) var app1 = new Vue ({ el: &#39;#app1&#39;, data: { greet: { hello:&#39;hello,&#39;, world: &#39;world&#39;, }, message: &#39;message1&#39;, } }) &amp;lt;/script&amp;gt; 2. camelCase vs. kebab-case：js中用驼峰式命名，在html中替换成短横线分隔式命名 &amp;lt;!-- 在 HTML 中使用 kebab-case --&amp;gt; &amp;lt;child my-message=&#34;hello!&#34;&amp;gt;&amp;lt;/child&amp;gt; &amp;lt;script&amp;gt; Vue.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2018-07-23T00:11:08+08:00">
    <meta property="article:modified_time" content="2018-07-23T00:11:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于Vue中props的详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>看一下官方文档：</p> 
<blockquote> 
 <p>组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。父组件的数据需要通过 prop 才能下发到子组件中。</p> 
</blockquote> 
<p>也就是<code>props</code>是子组件访问父组件数据的唯一接口。</p> 
<p>详细一点解释就是：</p> 
<p>一个组件可以直接在模板里面渲染data里面的数据（双大括号）。</p> 
<p>子组件不能直接在模板里面渲染父元素的数据。</p> 
<p>如果子组件想要引用父元素的数据，那么就在prop里面声明一个变量（比如a），这个变量就可以引用父元素的数据。然后在模板里渲染这个变量（前面的a），这时候渲染出来的就是父元素里面的数据。<br>  </p> 
<h3>1. 基本用法</h3> 
<p><img alt="" class="has" src="https://images2.imgbox.com/4b/ef/LzRfIc1l_o.jpg"></p> 
<p>图1-props</p> 
<pre class="has"><code>    &lt;div id="app1"&gt;
        &lt;!-- hello引用父元素的hello，它也可以引用message,greet，world等 --&gt;
        &lt;child :hello='hello'&gt;&lt;/child&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var com1 = Vue.component('child',{
            // 声明在prop中的变量可以引用父元素的数据
            props:['hello'],
           // 这里渲染props中声明的那个hello
            template:'&lt;div&gt;&lt;p&gt;{<!-- -->{ hello }}&lt;/p&gt;&lt;/div&gt;',
        })

        var app1 = new Vue ({
            el: '#app1',
            data: {
                greet: {
                    hello:'hello,',
                    world: 'world',
                },
                message: 'message1',
            }
        })
    &lt;/script&gt;
</code></pre> 
<p> </p> 
<h3>2. camelCase vs. kebab-case：js中用驼峰式命名，在html中替换成短横线分隔式命名</h3> 
<pre class="has"><code>&lt;!-- 在 HTML 中使用 kebab-case --&gt;
&lt;child my-message="hello!"&gt;&lt;/child&gt;

&lt;script&gt;
    Vue.component('child', {
        // 在 JavaScript 中使用 camelCase
        props: ['myMessage'],
        template: '&lt;span&gt;{<!-- -->{ myMessage }}&lt;/span&gt;'
    })
&lt;/script&gt;
</code></pre> 
<p> </p> 
<h3>3.单向数据流： props是单向绑定的</h3> 
<p>当父组件的属性变化时，将传导给子组件，但是反过来不会。</p> 
<p>每次父组件更新时，子组件的所有 prop 都会更新为最新值。</p> 
<p>不要在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</p> 
<p>在两种情况下，我们很容易忍不住想去修改 prop 中数据：</p> 
<ol><li>Prop 作为初始值传入后，子组件想把它当作局部数据来用；</li><li>Prop 作为原始数据传入，由子组件处理成其它数据输出。</li></ol> 
<p>对这两种情况，正确的应对方式是：<br> 定义一个局部变量，并用 prop 的值初始化它：</p> 
<pre class="has"><code>    props: ['initialCounter'],
    data: function () {
      return { counter: this.initialCounter }
    }
    
</code></pre> 
<p>定义一个计算属性，处理 prop 的值并返回：</p> 
<pre class="has"><code>    props: ['size'],
    computed: {
      normalizedSize: function () {
        return this.size.trim().toLowerCase()
      }
    }
</code></pre> 
<p> <br> 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p> 
<p>举个例子：</p> 
<pre class="has"><code>    &lt;div id="app3"&gt;
        &lt;my-component :object='object'&gt;&lt;/my-component&gt;
    &lt;/div&gt;
    &lt;script src="http://vuejs.org/js/vue.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        //
        var mycom = Vue.component('my-component', {
            //添加一个input改变子组件的childOject，那么父元素的object也会被改变，但是Vue没有报错！
            template: '&lt;p&gt;{<!-- -->{ object.name }} is {<!-- -->{ object.age }} years old.&lt;br&gt;&lt;input v-model="childObject.name" type="text"&gt;&lt;/p&gt;',
            props: ['object','school'],
            data: function () {
                // 子组件的childObject 和 父组件的object 指向同一个对象
                return {
                    childObject: this.object
                }
            }
        });
        var app3 = new Vue({
            el: '#app3',
            data: {
                object:{
                    name: 'Xueying',
                    age: '21',
                },
                school:'SCUT',
            },
        })
    &lt;/script&gt;
</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/d9/0f/2E99azjb_o.jpg"></p> 
<p>图2-改变childObject.name，object.name也改变</p> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/17/3a/H8R8wWqQ_o.jpg"></p> 
<p>图3-控制台输出app3.object.name</p> 
<p> </p> 
<p> </p> 
<h3>4. props验证</h3> 
<p>可以为prop指定验证规则，如果传入的数据不符合要求，Vue会发出警告。</p> 
<p>具体验证规则见官方文档：<a href="https://link.jianshu.com?t=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents.html" rel="nofollow">Prop验证规则</a><br>  </p> 
<h3>5. $parent</h3> 
<p>$parent 也可以用来访问父组件的数据。</p> 
<p>而且子组件可以通过$parent 来直接修改父组件的数据，不会报错！</p> 
<p>可以使用props的时候，尽量使用props显式地传递数据（可以很清楚很快速地看出子组件引用了父组件的哪些数据）。</p> 
<p>另外在一方面，直接在子组件中修改父组件的数据是很糟糕的做法，props单向数据流就没有这种顾虑了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f8a825d5d493799da23d6505d6f4323/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode 441. 排列硬币</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e8819b9cc789e12b35504297120f2d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue源码学习之callHook钩子函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>