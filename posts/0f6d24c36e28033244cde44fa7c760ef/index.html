<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java 数据结构 优先级队列(PriorityQueue) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/0f6d24c36e28033244cde44fa7c760ef/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="java 数据结构 优先级队列(PriorityQueue)">
  <meta property="og:description" content="目录
优先级队列
堆的概念
堆的性质
堆的存储方式
堆的创建
堆的插入
堆的删除
用堆模拟实现优先级队列
PriorityQueue的特性
PriorityQueue常用接口介绍
堆排序
优先级队列 前面介绍过队列，队列是一种先进先出(FIFO)的数据结构，但有些情况下，操作的数据可能带有优
先级，一般出队 列时，可能需要优先级高的元素先出队列，该中场景下，使用队列显然不合适，
比如：在手机上玩游戏的时候，如 果有来电，那么系统应该优先处理打进来的电话；初中那会班
主任排座位时可能会让成绩好的同学先挑座位。
在这种情况下，数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新
的对象。这种数据结构就是优先级队列(Priority Queue)。
PriorityQueue底层使用了堆这种数据结构，而堆实际就是在完全二叉树的基础上进行了一些调整
堆的概念 如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储
方式存储 在一个一维数组中，并满足：Ki &amp;lt;= K2i&#43;1 且 Ki&amp;lt;= K2i&#43;2 (Ki &amp;gt;= K2i&#43;1 且 Ki &amp;gt;= K2i&#43;2) i
= 0，1，2…，则称为 小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫
做最小堆或小根堆
堆的性质 1.堆中某个节点的值总是不大于或不小于其父节点的值； 2.堆总是一棵完全二叉树 堆的存储方式 从堆的概念可知，堆是一棵完全二叉树，因此可以层序的规则采用顺序的方式来高效存储，
注意：对于非完全二叉树，则不适合使用顺序方式进行存储，因为为了能够还原二叉树，空间中必须要存储空节点，就会导致空间利用率比较低。
将元素存储到数组中后，可以根据二叉树章节的性质5对树进行还原。假设i为节点在数组中的下标，则有：
如果i为0，则i表示的节点为根节点，否则i节点的双亲节点为 (i - 1)/2
如果2 * i &#43; 1 小于节点个数，则节点i的左孩子下标为2 * i &#43; 1，否则没有左孩子
如果2 * i &#43; 2 小于节点个数，则节点i的右孩子下标为2 * i &#43; 2，否则没有右孩子">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-14T20:56:16+08:00">
    <meta property="article:modified_time" content="2024-03-14T20:56:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java 数据结构 优先级队列(PriorityQueue)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">优先级队列</a></p> 
<p id="%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">堆的概念</a></p> 
<p id="%E5%A0%86%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:0px;"><a href="#%E5%A0%86%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">堆的性质</a></p> 
<p id="%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F" rel="nofollow">堆的存储方式</a></p> 
<p id="%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:0px;"><a href="#%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">堆的创建</a></p> 
<p id="%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:0px;"><a href="#%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">堆的插入</a></p> 
<p id="%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:0px;"><a href="#%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">堆的删除</a></p> 
<p id="%E7%94%A8%E5%A0%86%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E7%94%A8%E5%A0%86%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">用堆模拟实现优先级队列</a></p> 
<p id="PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:0px;"><a href="#PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7" rel="nofollow">PriorityQueue的特性</a></p> 
<p id="PriorityQueue%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#PriorityQueue%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D" rel="nofollow">PriorityQueue常用接口介绍</a></p> 
<p id="%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">堆排序</a></p> 
<hr id="hr-toc"> 
<h2><span style="color:#333333;"><strong>优先级队列</strong></span></h2> 
<p></p> 
<div></div> 
<div> 
 <p><span style="color:#333333;">前面介绍过队列，<strong>队列是一种先进先出(FIFO)的数据结构</strong>，但有些情况下，操作的数据可能带有优</span></p> 
 <p><br><span style="color:#333333;">先级，一般出队 列时，可能需要优先级高的元素先出队列，该中场景下，使用队列显然不合适，</span></p> 
 <p><br><span style="color:#333333;">比如：在手机上玩游戏的时候，如 果有来电，那么系统应该优先处理打进来的电话；初中那会班</span></p> 
 <p><br><span style="color:#333333;">主任排座位时可能会让成绩好的同学先挑座位。</span></p> 
 <p><br><span style="color:#333333;">在这种情况下，数据结构应该提供两个最基本的操作，一个是<strong>返回最高优先级对象</strong>，一个是<strong>添加新</strong></span></p> 
 <p><br><span style="color:#333333;"><strong>的对象</strong>。<strong>这种数据结构就是优先级队列(Priority Queue)。</strong></span></p> 
 <p><br><strong><span style="color:#333333;">PriorityQueue底层使用了堆这种数据结构，而堆实际就是在完全二叉树的基础上进行了一些调整</span></strong></p> 
 <p></p> 
</div> 
<hr> 
<h2 id="%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5">堆的概念</h2> 
<div></div> 
<div> 
 <p>如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储</p> 
 <p>方式存储 在一个一维数组中，并满足：Ki &lt;= K2i+1 且 Ki&lt;= K2i+2 (Ki &gt;= K2i+1 且 Ki &gt;= K2i+2) i</p> 
 <p>= 0，1，2…，则称为 小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫</p> 
 <p>做最小堆或小根堆</p> 
</div> 
<div></div> 
<div> 
 <hr> 
 <h2 id="%E5%A0%86%E7%9A%84%E6%80%A7%E8%B4%A8"><strong>堆的性质</strong></h2> 
 <p></p> 
</div> 
<div></div> 
<div> 
 <strong><span style="color:#333333;">1.堆中某个节点的值总是不大于或不小于其父节点的值； </span></strong> 
</div> 
<div></div> 
<div> 
 <strong><span style="color:#333333;">2.堆总是一棵完全二叉树</span></strong> 
</div> 
<p></p> 
<hr> 
<h2 id="%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span style="color:#333333;"><strong>堆的存储方式 </strong></span></h2> 
<p></p> 
<p><span style="color:#333333;">从堆的概念可知，</span><span style="color:#333333;"><strong>堆是一棵完全二叉树，因此可以层序的规则采用顺序的方式来高效存储</strong></span><span style="color:#333333;">，</span></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/1e/cc/9H2yzBdk_o.png" width="647"></p> 
<p></p> 
<p>注意：对于非完全二叉树，则不适合使用顺序方式进行存储，因为为了能够还原二叉树，空间中必须要存储空节点，就会导致空间利用率比较低。</p> 
<p>将元素存储到数组中后，可以根据二叉树章节的性质5对树进行还原。假设i为节点在数组中的下标，则有：</p> 
<p><strong>如果i为0，则i表示的节点为根节点，否则i节点的双亲节点为 (i - 1)/2</strong></p> 
<p><strong>如果2 * i + 1 小于节点个数，则节点i的左孩子下标为2 * i + 1，否则没有左孩子</strong></p> 
<p><strong>如果2 * i + 2 小于节点个数，则节点i的右孩子下标为2 * i + 2，否则没有右孩子</strong></p> 
<p></p> 
<hr> 
<h2 id="%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA">堆的创建</h2> 
<p></p> 
<p><strong>图解</strong></p> 
<p><img alt="" height="674" src="https://images2.imgbox.com/7b/05/lM5UVCOU_o.png" width="1200"></p> 
<p></p> 
<p><strong>代码例子：</strong></p> 
<pre><code class="hljs">public void shiftDown(int[] array, int parent) {
// child先标记parent的左孩子，因为parent可能右左没有右
    int child = 2 * parent + 1;
    int size = array.length;
while (child &lt; size) {
// 如果右孩子存在，找到左右孩子中较小的孩子,用child进行标记
    if(child+1 &lt; size &amp;&amp; array[child+1] &lt; array[child]){
    child += 1;
}
// 如果双亲比其最小的孩子还小，说明该结构已经满足堆的特性了
    if (array[parent] &lt;= array[child]) {
    break;
    }else{
// 将双亲与较小的孩子交换
    int t = array[parent];
    array[parent] = array[child];
    array[child] = t;
// parent中大的元素往下移动，可能会造成子树不满足堆的性质，因此需要继续向下调整
    parent = child;
    child = parent * 2 + 1;
}
}
}</code></pre> 
<p><strong>注意：在调整以parent为根的二叉树时，必须要满足parent的左子树和右子树已经是堆了才可以向下调整</strong></p> 
<p></p> 
<hr> 
<h2 id="%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5">堆的插入</h2> 
<p></p> 
<p>堆的插入总共需要两个步骤：</p> 
<p><strong>1. 先将元素放入到底层空间中(注意：空间不够时需要扩容)</strong></p> 
<p><strong>2. 将最后新插入的节点向上调整，直到满足堆的性质</strong></p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/cc/31/TuFt6M8r_o.png" width="1200"></p> 
<p></p> 
<p><strong>做法：</strong></p> 
<pre><code class="hljs">public void shiftUp(int child) {
// 找到child的双亲
    int parent = (child - 1) / 2;
while (child &gt; 0) {
// 如果双亲比孩子大，parent满足堆的性质，调整结束
    if (array[parent] &gt; array[child]) {
    break;
}
    else{
// 将双亲与孩子节点进行交换
    int t = array[parent];
    array[parent] = array[child];
    array[child] = t;
// 小的元素向下移动，可能到值子树不满足对的性质，因此需要继续向上调增
    child = parent;
    parent = (child - 1) / 1;
}
}
}</code></pre> 
<p></p> 
<hr> 
<h2 id="%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4">堆的删除</h2> 
<p></p> 
<p><strong>注意：堆的删除一定删除的是堆顶元素。</strong>具体如下：</p> 
<p><strong>1. 将堆顶元素对堆中最后一个元素交换</strong></p> 
<p><strong>2. 将堆中有效数据个数减少一个</strong></p> 
<p><strong>3. 对堆顶元素进行向下调整</strong></p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/08/32/6KxeVWdW_o.png" width="1200"></p> 
<p></p> 
<p><strong>做法:</strong></p> 
<pre><code class="hljs">//删除
    public int poll(int index) {
        if (empty()) {
            return -1;
        }
        int oldVal = elem[index];
        //先把要删除的元素的下标跟最后一个下标元素进行交换
        swap(index, usdSize - 1);
        //然后长度--
        usdSize--;
        //然后向下调整
        siftDown(index, usdSize);
        return oldVal;
    }</code></pre> 
<p></p> 
<hr> 
<h2 id="%E7%94%A8%E5%A0%86%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><strong>用堆模拟实现优先级队列</strong></h2> 
<p></p> 
<p><strong>做法:</strong></p> 
<pre><code class="hljs">public class MyPriorityQueue {
// 演示作用，不再考虑扩容部分的代码
    private int[] array = new int[100];
    private int size = 0;
    public void offer(int e) {
    array[size++] = e;
    shiftUp(size - 1);
}
public int poll() {
    int oldValue = array[0];
    array[0] = array[--size];
    shiftDown(0);
    return oldValue;
}
public int peek() {
    return array[0];
}
}</code></pre> 
<p></p> 
<hr> 
<h2 id="PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7"><strong>PriorityQueue的特性</strong></h2> 
<p></p> 
<p><strong>Java集合框架中提供了PriorityQueue和PriorityBlockingQueue两种类型的优先级队列，</strong></p> 
<p><strong>PriorityQueue是线程不安全的，PriorityBlockingQueue是线程安全的</strong></p> 
<p><img alt="" height="482" src="https://images2.imgbox.com/cd/fb/4WtVgng3_o.png" width="559"></p> 
<p></p> 
<p><strong>关于PriorityQueue的使用要注意：</strong></p> 
<p><br><strong>1. 使用时必须导入PriorityQueue所在的包，即：</strong></p> 
<pre><code class="hljs">import java.util.PriorityQueue;</code></pre> 
<p><strong>2. PriorityQueue中放置的元素必须要能够比较大小，不能插入无法比较大小的对象，否则会抛出<br> ClassCastException异常</strong></p> 
<p><strong>3. 不能插入null对象，否则会抛出NullPointerException</strong></p> 
<p><strong>4. 没有容量限制，可以插入任意多个元素，其内部可以自动扩容</strong></p> 
<p><strong>5. 插入和删除元素的时间复杂度为</strong></p> 
<p><strong>6. PriorityQueue底层使用了堆数据结构</strong></p> 
<p><strong>7. PriorityQueue默认情况下是小堆---即每次获取到的元素都是最小的元素</strong></p> 
<p></p> 
<hr> 
<h2 id="PriorityQueue%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D">PriorityQueue常用接口介绍</h2> 
<p></p> 
<p><strong>1. 优先级队列的构造</strong></p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/77/6c/9j3yCM6o_o.png" width="1016"></p> 
<p><strong>代码例子：</strong></p> 
<pre><code class="hljs">static void TestPriorityQueue(){
// 创建一个空的优先级队列，底层默认容量是11
PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;();
// 创建一个空的优先级队列，底层的容量为initialCapacity
PriorityQueue&lt;Integer&gt; q2 = new PriorityQueue&lt;&gt;(100);
    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    list.add(4);
    list.add(3);
    list.add(2);
    list.add(1);
// 用ArrayList对象来构造一个优先级队列的对象
// q3中已经包含了三个元素
PriorityQueue&lt;Integer&gt; q3 = new PriorityQueue&lt;&gt;(list);
    System.out.println(q3.size());
    System.out.println(q3.peek());
}</code></pre> 
<div> 
 <strong><span style="color:#333333;">注意：默认情况下，</span><span style="color:#333333;">PriorityQueue</span><span style="color:#333333;">队列是小堆，如果需要大堆需要用户提供比较器 </span></strong> 
</div> 
<p></p> 
<p><strong>例子：</strong></p> 
<pre><code class="hljs">// 用户自己定义的比较器：直接实现Comparator接口，然后重写该接口中的compare方法即可
class IntCmp implements Comparator&lt;Integer&gt;{
@Override
public int compare(Integer o1, Integer o2) {
    return o2-o1;
}
}
public class TestPriorityQueue {
public static void main(String[] args) {
PriorityQueue&lt;Integer&gt; p = new PriorityQueue&lt;&gt;(new IntCmp());
    p.offer(4);
    p.offer(3);
    p.offer(2);
    p.offer(1);
    p.offer(5);
System.out.println(p.peek());
}
}</code></pre> 
<div> 
 <strong><span style="color:#333333;">此时创建出来的就是一个大堆</span></strong> 
</div> 
<p></p> 
<hr> 
<h2 id="%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</h2> 
<p>堆排序即利用堆的思想来进行排序，总共分为两个步骤：</p> 
<p><strong>1. 建堆</strong></p> 
<p>升序：建大堆</p> 
<p>降序：建小堆</p> 
<p><strong>2. 利用堆删除思想来进行排序</strong></p> 
<p>建堆和堆删除中都用到了向下调整，因此掌握了向下调整，就可以完成堆排序</p> 
<p><img alt="" height="793" src="https://images2.imgbox.com/a2/6e/EMub51BX_o.png" width="819"></p> 
<p></p> 
<p><strong>这里利用大根堆进行堆的排序</strong></p> 
<p><strong>从小到大排序,我们需要建立大根堆</strong></p> 
<p><strong>思路：创建大根堆，每次让下标为0的元素跟最后一个元素交换，然后调整，调整完，下标--</strong></p> 
<pre><code class="hljs">    //堆排序
    public void heapSort() {
        //下标最后一个的元素
        int end = usdSize - 1;
        //调整到下标为0的元素的时候结束
        while (end &gt; 0) {
            //跟下标为0的元素进行交换
            swap(0, end);
            //向下调整
            siftDown(0, end);
            //然后倒数第二个换,以此类推
            end--;
        }
    }</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86faf8bcf15af67f8419eaa062fcbf12/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS删除树形结构中childKey数组为空的数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/adb8738235f4c3471ce50a42e991ddd0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于 Java Web 项目的 SpringBoot 框架初始化模板</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>