<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-＞链表分类与oj（题），带你提升代码好感 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/04c26953bd02d97c6cbdfbd12fb75c9f/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="数据结构-＞链表分类与oj（题），带你提升代码好感">
  <meta property="og:description" content="✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉
🍎个人主页：橘橙黄又青-CSDN博客
1.🍎链表的分类 前面我们学过顺序表，顺序表问题：
1. 中间/头部的插入删除，时间复杂度为O(N)2. 增容需要申请新空间，拷贝数据，释放旧空间。会有不小的消耗。3. 增容一般是呈2倍的增长，势必会有一定的空间浪费。例如当前容量为100，满了以后增容到 200，我们再继续插入了5个数据，后面没有数据插入了，那么就浪费了95个数据空间。 这些问题，链表给出了相应的答案。
概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表 中的指针链接次序实现的 。
比如说我们前面学习的单链表就是如此。
单链表是单向不循环不带头链表
实际中要实现的链表的结构非常多样，以下情况组合起来就有8种链表结构：
1. 单向、双向2. 带头、不带头3. 循环、非循环 又称2x2x2 图解：
1. 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结 构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。2. 带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都 是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带 来很多优势，实现反而简单了，后面我们代码实现了就知道了。 2.🍎链表相关基础oj 题目链接设计链表. - 力扣（LeetCode）两数相加. - 力扣（LeetCode）合并两个有序链表. - 力扣（LeetCode）两两交换链表中的节点. - 力扣（LeetCode）删除排序链表中的重复元素. - 力扣（LeetCode）删除排序链表中的重复元素II. - 力扣（LeetCode）相交链表. - 力扣（LeetCode）移除链表元素. - 力扣（LeetCode）回文链表. - 力扣（LeetCode）奇偶链表. - 力扣（LeetCode）链表的中间结点. - 力扣（LeetCode）链表最大孪生和. - 力扣（LeetCode）两两交换链表中的节点404: This page could not be found 合并两个链表中，可以安排一个哨兵（头）可以减少判断空的代码。
哨兵位的申请：
这些都是比较好的题目，
接下来我们分析几道题目
题目链接反转链表. - 力扣（LeetCode）反转链表II. - 力扣（LeetCode）链表中间节点问题. - 力扣（LeetCode）环形链表的约瑟夫问题环形链表的约瑟夫问题_牛客题霸_牛客网 2.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-07T14:40:54+08:00">
    <meta property="article:modified_time" content="2024-03-07T14:40:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-＞链表分类与oj（题），带你提升代码好感</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1200" src="https://images2.imgbox.com/03/be/ikJzOjA5_o.png" width="1200"></p> 
<p>✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉</p> 
<p>🍎个人主页：<a href="https://blog.csdn.net/chendemingxxx?spm=1011.2266.3001.5343" title="橘橙黄又青-CSDN博客">橘橙黄又青-CSDN博客</a></p> 
<h2>1.🍎链表的分类</h2> 
<p>前面我们学过顺序表，顺序表问题：</p> 
<blockquote> 
 <ul><li>1. 中间/头部的插入删除，时间复杂度为O(N)</li><li>2. 增容需要申请新空间，拷贝数据，释放旧空间。会有不小的消耗。</li><li>3. 增容一般是呈2倍的增长，势必会有一定的空间浪费。例如当前容量为100，满了以后增容到 200，我们再继续插入了5个数据，后面没有数据插入了，那么就浪费了95个数据空间。</li></ul> 
</blockquote> 
<p>这些问题，链表给出了相应的答案。</p> 
<p><span style="color:#fe2c24;"><strong>概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表 中的指针链接次序实现的 。</strong></span></p> 
<p> 比如说我们前面学习的单链表就是如此。</p> 
<p></p> 
<p>单链表是单向不循环不带头链表</p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/c2/e5/FAnLgV4M_o.png" width="1200"></p> 
<p> <img alt="" height="454" src="https://images2.imgbox.com/06/c8/1ub3I0ai_o.png" width="891"></p> 
<p>实际中要实现的链表的结构非常多样，以下情况组合起来就有8种链表结构：</p> 
<ul><li>1. 单向、双向</li><li>2. 带头、不带头</li><li>3. 循环、非循环</li></ul> 
<p>又称2x2x2 </p> 
<p>图解：</p> 
<p><img alt="" height="650" src="https://images2.imgbox.com/03/5d/S8C0OtsP_o.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="634" src="https://images2.imgbox.com/88/90/EnIo5ilk_o.png" width="1200"></p> 
<p> <img alt="" height="591" src="https://images2.imgbox.com/09/e2/BSby5Lf3_o.png" width="1200"></p> 
<blockquote> 
 <ul><li>1. 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结 构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。</li><li>2. 带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都 是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带 来很多优势，实现反而简单了，后面我们代码实现了就知道了。 </li></ul> 
</blockquote> 
<h2>2.🍎链表相关基础oj</h2> 
<p></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th style="width:191px;">题目</th><th style="width:307px;">链接</th></tr></thead><tbody><tr><td style="width:191px;">设计链表</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/design-linked-list/solution/she-ji-lian-biao-cyu-yan-xiang-jie-by-go-0gnm/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">两数相加</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-cyu-yan-xiang-jie-do-7p20/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;"><span style="color:#fe2c24;">合并两个有序链表</span></td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-cyu-ya-0xyy/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">两两交换链表中的节点</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-vsan/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">删除排序链表中的重复元素</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/solution/shan-chu-pai-xu-lian-biao-zhong-de-zhong-dz03/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">删除排序链表中的重复元素II</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/shan-chu-pai-xu-lian-biao-zhong-de-zhong-pujt/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">相交链表</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-cyu-yan-xiang-jie-b-201f/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">移除链表元素</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-cyu-yan-xiang-j-jcgp/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">回文链表</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-cyu-yan-xiang-jie-by-g-d3n0/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">奇偶链表</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/odd-even-linked-list/solution/qi-ou-lian-biao-cyu-yan-xiang-jie-by-goo-v9wt/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">链表的中间结点</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-cyu-yan-elyz/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">链表最大孪生和</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/maximum-twin-sum-of-a-linked-list/solution/lian-biao-zui-da-luan-sheng-he-cyu-yan-x-phyp/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td style="width:191px;">两两交换链表中的节点</td><td style="width:307px;"><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/sol" rel="nofollow" title="404: This page could not be found">404: This page could not be found</a></td></tr></tbody></table> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>合并两个链表中，可以安排一个哨兵（头）可以减少判断空的代码。</strong></span></p> 
<p>哨兵位的申请：</p> 
<p><img alt="" height="72" src="https://images2.imgbox.com/2a/66/IYS33s0r_o.png" width="904"></p> 
<p>这些都是比较好的题目，</p> 
<p>接下来我们分析几道题目</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th>题目</th><th>链接</th></tr></thead><tbody><tr><td>反转链表</td><td><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-cyu-yan-xiang-jie-by-2m9c/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td>反转链表II</td><td><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/by-goodgoodday-2px8/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td>链表中间节点问题</td><td><a href="https://leetcode.cn/problems/middle-of-the-linked-list/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></td></tr><tr><td>环形链表的约瑟夫问题</td><td><a href="https://www.nowcoder.com/share/jump/458919331709630997816" rel="nofollow" title="环形链表的约瑟夫问题_牛客题霸_牛客网">环形链表的约瑟夫问题_牛客题霸_牛客网</a></td></tr></tbody></table> 
<h3>2.1🍎第一个反转链表</h3> 
<h4>第一种：头插法</h4> 
<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 //头插术
typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {
    ListNode* returnHead = NULL;
    ListNode* ListLt = head;
    while(ListLt != NULL){
        //保存下一个节点
        ListNode* temp = ListLt -&gt; next;
        //换头手术
        ListLt -&gt; next = returnHead;
        returnHead = ListLt;
        //迭代
        ListLt = temp;

    }
    return returnHead;
}</code></pre> 
<p></p> 
<p>这里说一个错误代码：</p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/49/16/db6wBeaD_o.png" width="904"></p> 
<p>输出结果为1，为什么来：</p> 
<p> <img alt="" height="988" src="https://images2.imgbox.com/f6/a8/Yy0G37wp_o.png" width="1200"></p> 
<p>所以temp要保存下一个节点。 </p> 
<h4>第二种解法：</h4> 
<p>三指针法：</p> 
<p>代码：</p> 
<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {
    if(head == NULL){
        return head;
    }
    ListNode* n1 = NULL;
    ListNode* n2 = head;
    ListNode* n3 = head -&gt; next;
    ListNode* pcur = head;
    while(n2){
        n2-&gt; next = n1;
        n1 = n2;
        n2 = n3;
        if(n3){//这里防止n3为空，如果为空就无next
            n3 = n3 -&gt; next; 
        }
    }
    return n1;
}</code></pre> 
<p>图解：</p> 
<p><img alt="" height="991" src="https://images2.imgbox.com/97/82/PzOfznhL_o.png" width="1200"></p> 
<p>链表II与这个差不多，思路更为复杂。 </p> 
<p></p> 
<h3>2.2🍎链表中间节点问题</h3> 
<p>可以遍历链表计数除2，也可以使用双指针法</p> 
<p>双指针法：</p> 
<p>思路：</p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/ad/fe/s1ot3zYB_o.png" width="1200">代码：</p> 
<p></p> 
<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 typedef struct ListNode ListNode;
struct ListNode* middleNode(struct ListNode* head) {
    ListNode* slow,*fast;
    slow = fast = head;
    while(fast &amp;&amp; fast -&gt; next){
        slow = slow -&gt; next;
        fast = fast -&gt; next -&gt; next;
    }
    return slow;
}</code></pre> 
<p><span style="color:#fe2c24;">值得注意的是循环条件不能写成 fast -&gt; next &amp;&amp;fast ，原因是计算机编译器是从左往右编译的，如果fast为空，就没有fast -&gt; next。</span></p> 
<p><span style="color:#fe2c24;">快慢指针法以后会经常使用务必理解.</span></p> 
<h4 style="background-color:transparent;">2.3.环形链表的约瑟夫问题 </h4> 
<p>题目:</p> 
<p><img alt="" height="916" src="https://images2.imgbox.com/2c/83/peoVcgkW_o.png" width="429"></p> 
<p>这里我们输入Li 它就有暗示，说明已经有结构体结构了<img alt="" height="491" src="https://images2.imgbox.com/e7/e7/DbvdmCgp_o.png" width="971"></p> 
<p>解题代码：</p> 
<pre><code class="language-cpp">/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param n int整型 
 * @param m int整型 
 * @return int整型
 */
 typedef struct ListNode ListNode;
//申请一个节点
 ListNode* BuyNode(int x){
    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
    newNode -&gt; val = x;
    newNode -&gt; next = NULL;
    return newNode;

 }
 ListNode* creteList(int n){
    ListNode* phead = BuyNode(1);
    ListNode* ptail = phead;
    //创建链表和标号
    for (int i = 2; i &lt;= n; i++) {
        ptail -&gt; next = BuyNode(i);
        ptail = ptail -&gt; next;
    }
    //链表首尾链接
    ptail -&gt; next = phead;
    return phead;
 }
#include &lt;stdio.h&gt;
int ysf(int n, int m ) {
    //逢m删除节点
    ListNode* head = creteList(n);
    ListNode* pcur = head;
    //前驱节点
    ListNode* prev = NULL;
    
    int conut = 1;
    while (pcur -&gt;next != pcur) {
        if(conut == m){
            //删除当前节点
            prev -&gt; next = pcur -&gt;next;
            free(pcur);
            //删除节点后往后走，让pcur走到新的位置，conut为初始值
            pcur = prev -&gt; next;
            conut = 1;
        }
        else{
            //pcur往后走
            prev = pcur;
            pcur =  pcur -&gt; next;
            conut++;
        }
    }
    //此时pcur节点就是活下来的节点
    return pcur -&gt; val;
}</code></pre> 
<h3 style="background-color:transparent;"><img alt="" height="692" src="https://images2.imgbox.com/ee/e6/wJiIbXvz_o.png" width="1200"></h3> 
<p>试试效果：</p> 
<p> <img alt="" height="552" src="https://images2.imgbox.com/bd/31/chBbdE1s_o.png" width="1200"></p> 
<h3 style="background-color:transparent;">3.🍎上节链表代码建议重复观看</h3> 
<p>SList.c文件：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a0/37/I8vnb08M_o.png" width="831"></p> 
<p> SList.h文件</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b1/e2/LuEDxxi5_o.png" width="1047"></p> 
<p> test.c文件测试代码： </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f1/33/0GnrtYMR_o.png" width="1093"></p> 
<p> test.c文件代码</p> 
<pre><code class="language-cpp">#include"SList.h"

//void SlistTest01() {
// 
//	链表的打印
//	SLTNode* node1 = (SLTNode*)malloc(sizeof(SLTNode));
//	node1-&gt;data = 1;
//	SLTNode* node2 = (SLTNode*)malloc(sizeof(SLTNode));
//	node2-&gt;data = 2;
//	SLTNode* node3 = (SLTNode*)malloc(sizeof(SLTNode));
//	node3-&gt;data = 3;
//	SLTNode* node4 = (SLTNode*)malloc(sizeof(SLTNode));
//	node4-&gt;data = 4;
//
//	node1-&gt;next = node2;
//	node2-&gt;next = node3;
//	node3-&gt;next = node4;
//	node4-&gt;next = NULL;
//
//	SLTNode* plist = node1;
//	SLTPrint(plist);
//}
void SlistTest02() {
	//尾插测试
	SLTNode* plist = NULL;
	SLTPushBack(&amp;plist, 1);
	SLTPushBack(&amp;plist, 2);
	SLTPushBack(&amp;plist, 3);
	SLTPushBack(&amp;plist, 4);
	SLTPrint(plist); //1-&gt;2-&gt;3-&gt;4-&gt;NULL
	//头插测试
	//SLTPushFront(&amp;plist, 5);
	//SLTPrint(plist);          //5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
	//SLTPushFront(&amp;plist, 6);
	//SLTPrint(plist);         //6-&gt;5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
	//SLTPushFront(&amp;plist, 7);
	//SLTPrint(plist);         //7-6-&gt;5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL

	SLTPopBack(&amp;plist);
	SLTPrint(plist);//1-&gt;2-&gt;3-&gt;NULL
	SLTPopBack(&amp;plist);
	SLTPrint(plist);//1-&gt;2-&gt;3-&gt;NULL
	SLTPopBack(&amp;plist);
	SLTPrint(plist);//1-&gt;2-&gt;3-&gt;NULL
	SLTPopBack(&amp;plist);
	SLTPrint(plist);//1-&gt;2-&gt;3-&gt;NULL
	SLTPopBack(&amp;plist);
	SLTPrint(plist);//1-&gt;2-&gt;3-&gt;NULL
}

void SlistTest03() {
	SLTNode* plist = NULL;
	SLTPushBack(&amp;plist, 1);
	SLTPushBack(&amp;plist, 2);
	SLTPushBack(&amp;plist, 3);
	SLTPushBack(&amp;plist, 4);
	SLTPrint(plist); //1-&gt;2-&gt;3-&gt;4-&gt;NULL

	SListDesTroy(&amp;plist);


	头删
	//SLTPopFront(&amp;plist);
	//SLTPrint(plist);    //2-&gt;3-&gt;4-&gt;NULL
	//SLTPopFront(&amp;plist);
	//SLTPrint(plist);    //3-&gt;4-&gt;NULL
	//SLTPopFront(&amp;plist);
	//SLTPrint(plist);    //4-&gt;NULL
	//SLTPopFront(&amp;plist);
	//SLTPrint(plist);    //NULL
	//SLTPopFront(&amp;plist);
	//SLTPrint(plist);    //assert
	
	//查找测试
	//SLTNode* FindRet = SLTFind(&amp;plist, 3);
	//if (FindRet) {
	//	printf("找到了！\n");
	//}
	//else {
	//	printf("未找到！\n");
	//}
	//SLTInsert(&amp;plist, FindRet, 100);
	//SLTInsertAfter(FindRet, 100);
	
	//删除指定位置的节点测试
	//SLTErase(&amp;plist, FindRet);
	//SLTPrint(plist); //1-&gt;2-&gt;3-&gt;NULL
}
int main() {
	//SlistTest01();
	//SlistTest02();
	SlistTest03();
	return 0;
}</code></pre> 
<p>SList.c文件代码：</p> 
<pre><code class="language-cpp">#include"SList.h"
//打印
void SLTPrint(SLTNode* phead) {
	SLTNode* pcur = phead;
	while (pcur)
	{
		printf("%d-&gt;", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("NULL\n");
}
//开辟空间
SLTNode* SLTBuyNode(SLTDataType x) {
	SLTNode* newnode = (SLTNode*)malloc(sizeof(SLTNode));
	if (newnode == NULL) {
		perror("malloc fail!");
		exit(1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;

	return newnode;
}
//
void SLTPushBack(SLTNode** pphead, SLTDataType x) {
	assert(pphead);
	//开辟空间
	SLTNode* newnode = SLTBuyNode(x);

	//链表为空，新节点作为phead
	if (*pphead == NULL) {
		*pphead = newnode;
		return;
	}
	//链表不为空，找尾节点
	SLTNode* ptail = *pphead;
	while (ptail-&gt;next)
	{
		ptail = ptail-&gt;next;
	}
	//ptail就是尾节点
	ptail-&gt;next = newnode;
}
//头插
void SLTPushFront(SLTNode** pphead, SLTDataType x) {
	assert(pphead);
	SLTNode* newnode = SLTBuyNode(x);

	//newnode *pphead
	newnode-&gt;next = *pphead;
	*pphead = newnode;
}
//尾删
void SLTPopBack(SLTNode** pphead) {
	assert(pphead);
	//链表不能为空
	assert(*pphead);

	//链表不为空
	//链表只有一个节点，有多个节点
	if ((*pphead)-&gt;next == NULL) {
		free(*pphead);
		*pphead = NULL;
		return;
	}
	SLTNode* ptail = *pphead;
	SLTNode* prev = NULL;
	while (ptail-&gt;next)
	{
		prev = ptail;
		ptail = ptail-&gt;next;
	}

	prev-&gt;next = NULL;
	//销毁尾结点
	free(ptail);
	ptail = NULL;
}
//头删
void SLTPopFront(SLTNode** pphead) {
	assert(pphead);
	//链表不能为空
	assert(*pphead);

	//让第二个节点成为新的头
	//把旧的头结点释放掉
	SLTNode* next = (*pphead)-&gt;next;
	free(*pphead);
	*pphead = next;
}
//查找
SLTNode* SLTFind(SLTNode** pphead, SLTDataType x) {
	assert(pphead);

	//遍历链表
	SLTNode* pcur = *pphead;
	while (pcur) //等价于pcur != NULL
	{
		if (pcur-&gt;data == x) {
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	//没有找到
	return NULL;
}
//在指定位置之前插入数据
void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x) {
	assert(pphead);
	assert(pos);
	//要加上链表不能为空
	assert(*pphead);

	SLTNode* newnode = SLTBuyNode(x);
	//pos刚好是头结点
	if (pos == *pphead) {
		//头插
		SLTPushFront(pphead, x);
		return;
	}

	//pos不是头结点的情况
	SLTNode* prev = *pphead;
	while (prev-&gt;next != pos)
	{
		prev = prev-&gt;next;
	}
	//prev -&gt; newnode -&gt; pos
	prev-&gt;next = newnode;
	newnode-&gt;next = pos;
}
//在指定位置之后插入数据
void SLTInsertAfter(SLTNode* pos, SLTDataType x) {
	assert(pos);

	SLTNode* newnode = SLTBuyNode(x);

	//pos newnode pos-&gt;next
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
}
//删除pos节点
void SLTErase(SLTNode** pphead, SLTNode* pos) {
	assert(pphead);
	assert(*pphead);
	assert(pos);

	//pos刚好是头结点，没有前驱节点，执行头删
	if (*pphead == pos) {
		//头删
		SLTPopFront(pphead);
		return;
	}

	SLTNode* prev = *pphead;
	while (prev-&gt;next != pos)
	{
		prev = prev-&gt;next;
	}
	//prev pos pos-&gt;next
	prev-&gt;next = pos-&gt;next;
	free(pos);
	pos = NULL;
}
//删除pos之后的节点
void SLTEraseAfter(SLTNode* pos) {
	assert(pos);
	//pos-&gt;next不能为空
	assert(pos-&gt;next);

	//pos  pos-&gt;next  pos-&gt;next-&gt;next
	SLTNode* del = pos-&gt;next;
	pos-&gt;next = pos-&gt;next-&gt;next;
	free(del);
	del = NULL;
}
//销毁链表
void SListDesTroy(SLTNode** pphead) {
	assert(pphead);
	assert(*pphead);

	SLTNode* pcur = *pphead;
	while (pcur)
	{
		SLTNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	*pphead = NULL;
}</code></pre> 
<p>SList.h文件代码：</p> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;

typedef int SLTDataType;
//链表是由节点组成
typedef struct SListNode
{
	SLTDataType data;
	struct SListNode* next;
}SLTNode;

//typedef struct SListNode SLTNode;
//打印链表
void SLTPrint(SLTNode* phead);

//链表的头插、尾插
void SLTPushBack(SLTNode** pphead, SLTDataType x);
void SLTPushFront(SLTNode** pphead, SLTDataType x);

//链表的头删、尾删
void SLTPopBack(SLTNode** pphead);
void SLTPopFront(SLTNode** pphead);

//查找
SLTNode* SLTFind(SLTNode** pphead, SLTDataType x);

//在指定位置之前插入数据
void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x);
//在指定位置之后插入数据
void SLTInsertAfter(SLTNode* pos, SLTDataType x);

//删除pos节点
void SLTErase(SLTNode** pphead, SLTNode* pos);
//删除pos之后的节点
void SLTEraseAfter(SLTNode* pos);

//销毁链表
void SListDesT</code></pre> 
<p>今天就到这里了，都看到这里了，点一个赞吧，感谢观看。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/337b0290450bccdd4c303c9a6f5c7847/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【java开发者工具】IDEA（java编程语言开发的集成环境）带你了解背后故事与基础操作指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bea30b4a7e7cd732245d828411e6dffe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（k8s中）docker netty OOM问题记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>