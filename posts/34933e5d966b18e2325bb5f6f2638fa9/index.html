<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java高级编程——多线程 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/34933e5d966b18e2325bb5f6f2638fa9/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Java高级编程——多线程">
  <meta property="og:description" content="Java高级编程——多线程 高级部分使用IDEA编写代码！！！！！！！ 目录
Java高级编程之多线程
一、基本概念：程序、进程、线程
1.基本概念
2.使用多线程的优点
3.何时需要多线程
二、线程的创建和使用
1.线程的创建和启动
2.Thread类
3.API中创建线程的两种方式
代码演示
代码演示 4.线程的调度
三、线程的生命周期
1.JDK中用Thread.State类定义了线程的几种状态
四、线程的同步
1.问题的提出
2.Synchronized的使用方法
3.代码演示
使用同步代码解决实现Runnable接口的线程安全问题
使用同步代码解决实现继承的线程安全问题
使用同步方法解决实现Runnable接口的线程安全问题
使用同步方法解决实现继承的线程安全问题
解决单例设计模式之懒汉式(线程安全)
4.线程的死锁问题
代码演示
5.JDK 5.0新增解决线程安全方法（lock锁的方式）
代码演示
五、线程的通信
1.概念
2.代码演示
3.经典例题：生产者/消费者问题
代码演示
六、JDK5.0新增线程创建方式
1.新增方式一：实现Callable接口
代码演示
2.新增方式二：使用线程池
线程池相关API
一、基本概念：程序、进程、线程 1.基本概念 程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段静态的代码，静态对象。
进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期
如：运行中的QQ，运行中的MP3播放器
程序是静态的，进程是动态的
进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域
线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。
若一个进程同一时间并行执行多个线程，就是支持多线程的
线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开 销小
一个进程中的多个线程共享相同的内存单元/内存地址空间——&amp;gt;它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资 源可能就会带来安全的隐患。
单核CPU和多核CPU的理解
 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程 的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以 把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时 间单元特别短，因此感觉不出来。
 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）
 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。
并行与并发
 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-29T21:36:37+08:00">
    <meta property="article:modified_time" content="2023-05-29T21:36:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java高级编程——多线程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B" style="text-align:center;">Java高级编程——多线程</h2> 
<p></p> 
<p></p> 
<blockquote> 
 <p><span style="color:#be191c;"><strong>高级部分使用IDEA编写代码！！！！！！！ </strong></span><img alt="" height="45" src="https://images2.imgbox.com/9c/2a/zuiZtelF_o.png" width="43"></p> 
 <p></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B-toc" style="margin-left:0px;"><a href="#Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B" rel="nofollow">Java高级编程之多线程</a></p> 
<p id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B" rel="nofollow">一、基本概念：程序、进程、线程</a></p> 
<p id="1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">1.基本概念</a></p> 
<p id="2.%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9" rel="nofollow">2.使用多线程的优点</a></p> 
<p id="%C2%A03.%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%C2%A03.%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B" rel="nofollow"> 3.何时需要多线程</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8" rel="nofollow"> 二、线程的创建和使用</a></p> 
<p id="1.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8-toc" style="margin-left:40px;"><a href="#1.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8" rel="nofollow">1.线程的创建和启动</a></p> 
<p id="%C2%A02.Thread%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%C2%A02.Thread%E7%B1%BB" rel="nofollow"> 2.Thread类</a></p> 
<p id="%C2%A03.API%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%C2%A03.API%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow"> 3.API中创建线程的两种方式</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow"> 代码演示</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%C2%A0" rel="nofollow">代码演示 </a></p> 
<p id="%C2%A04.%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%C2%A04.%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6" rel="nofollow"> 4.线程的调度</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">三、线程的生命周期</a></p> 
<p id="1.JDK%E4%B8%AD%E7%94%A8Thread.State%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%BA%86%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81-toc" style="margin-left:40px;"><a href="#1.JDK%E4%B8%AD%E7%94%A8Thread.State%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%BA%86%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81" rel="nofollow">1.JDK中用Thread.State类定义了线程的几种状态</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5" rel="nofollow">四、线程的同步</a></p> 
<p id="1.%E9%97%AE%E9%A2%98%E7%9A%84%E6%8F%90%E5%87%BA-toc" style="margin-left:40px;"><a href="#1.%E9%97%AE%E9%A2%98%E7%9A%84%E6%8F%90%E5%87%BA" rel="nofollow">1.问题的提出</a></p> 
<p id="%C2%A02.Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A02.Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow"> 2.Synchronized的使用方法</a></p> 
<p id="%C2%A03.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%C2%A03.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow"> 3.代码演示</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98" rel="nofollow">使用同步代码解决实现Runnable接口的线程安全问题</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98" rel="nofollow">使用同步代码解决实现继承的线程安全问题</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98" rel="nofollow">使用同步方法解决实现Runnable接口的线程安全问题</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98" rel="nofollow">使用同步方法解决实现继承的线程安全问题</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%87%92%E6%B1%89%E5%BC%8F(%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8)-toc" style="margin-left:80px;"><a href="#%E8%A7%A3%E5%86%B3%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%87%92%E6%B1%89%E5%BC%8F%28%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%29" rel="nofollow">解决单例设计模式之懒汉式(线程安全)</a></p> 
<p id="4.%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#4.%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98" rel="nofollow">4.线程的死锁问题</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow"> 代码演示</a></p> 
<p id="%C2%A05.JDK%205.0%E6%96%B0%E5%A2%9E%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%96%B9%E6%B3%95%EF%BC%88lock%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%89-toc" style="margin-left:40px;"><a href="#%C2%A05.JDK%205.0%E6%96%B0%E5%A2%9E%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%96%B9%E6%B3%95%EF%BC%88lock%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%89" rel="nofollow"> 5.JDK 5.0新增解决线程安全方法（lock锁的方式）</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow"> 代码演示</a></p> 
<p id="%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1" rel="nofollow">五、线程的通信</a></p> 
<p id="1.%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.%E6%A6%82%E5%BF%B5" rel="nofollow">1.概念</a></p> 
<p id="%C2%A02.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%C2%A02.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow"> 2.代码演示</a></p> 
<p id="3.%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%2F%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#3.%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%2F%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" rel="nofollow">3.经典例题：生产者/消费者问题</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow">代码演示</a></p> 
<p id="%E5%85%AD%E3%80%81JDK5.0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81JDK5.0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F" rel="nofollow">六、JDK5.0新增线程创建方式</a></p> 
<p id="1.%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#1.%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3" rel="nofollow">1.新增方式一：实现Callable接口</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow"> 代码演示</a></p> 
<p id="2.%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#2.%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">2.新增方式二：使用线程池</a></p> 
<p id="%C2%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3API-toc" style="margin-left:80px;"><a href="#%C2%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3API" rel="nofollow"> 线程池相关API</a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B">一、基本概念：程序、进程、线程</h2> 
<h3 id="1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.基本概念</h3> 
<p><span style="color:#fe2c24;"><strong>程序(program)</strong></span>是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段静态的代码，静态对象。</p> 
<p><span style="color:#fe2c24;"><strong>进程(process)</strong></span>是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</p> 
<p>如：运行中的QQ，运行中的MP3播放器</p> 
<p>程序是静态的，进程是动态的</p> 
<p>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</p> 
<p><span style="color:#fe2c24;"><strong>线程(thread)</strong></span>，进程可进一步细化为线程，是一个程序内部的一条执行路径。</p> 
<p>若一个进程同一时间并行执行多个线程，就是支持多线程的</p> 
<p>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开 销小</p> 
<p>一个进程中的多个线程共享相同的内存单元/内存地址空间——&gt;它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资 源可能就会带来安全的隐患。</p> 
<p class="img-center"><img alt="" height="247" src="https://images2.imgbox.com/44/d4/xoZO2rbr_o.png" width="445"></p> 
<p><span style="color:#fe2c24;"><strong>单核CPU和多核CPU的理解</strong></span></p> 
<p> 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程 的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以 把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时 间单元特别短，因此感觉不出来。</p> 
<p> 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</p> 
<p> 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</p> 
<p><span style="color:#fe2c24;"><strong>并行与并发</strong></span></p> 
<p> 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</p> 
<p> 并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</p> 
<h3 id="2.%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9">2.使用多线程的优点</h3> 
<p class="img-center"><img alt="" height="239" src="https://images2.imgbox.com/1b/5e/8Jc4nSaU_o.png" width="706"></p> 
<h3 id="%C2%A03.%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"> 3.何时需要多线程</h3> 
<p> 程序需要同时执行两个或多个任务。</p> 
<p> 程序需要实现一些需要等待的任务时，如用户输入、文件读写 操作、网络操作、搜索等。</p> 
<p> 需要一些后台运行的程序时。</p> 
<p style="text-align:center;"></p> 
<hr> 
<h2 id="%C2%A0%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"> 二、线程的创建和使用</h2> 
<h3 id="1.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8">1.线程的创建和启动</h3> 
<p class="img-center"><img alt="" height="233" src="https://images2.imgbox.com/97/f1/o2DmJPSE_o.png" width="764"></p> 
<h3 id="%C2%A02.Thread%E7%B1%BB"> 2.Thread类</h3> 
<p class="img-center"><img alt="" height="602" src="https://images2.imgbox.com/f4/95/mmjkHoRf_o.png" width="1200"></p> 
<h3 id="%C2%A03.API%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"> 3.API中创建线程的两种方式</h3> 
<p class="img-center"><img alt="" height="357" src="https://images2.imgbox.com/34/bd/LoKcZdx0_o.png" width="650"></p> 
<p class="img-center"><img alt="" height="287" src="https://images2.imgbox.com/2b/fa/1NwPx16F_o.png" width="718"></p> 
<h4 id="%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"> 代码演示</h4> 
<pre><code class="language-java">package com.tyl.com;

/**
 *
 * @author tyl tyl202061@gmail.com
 * @Package：com.tyl.com
 * @Project：workidea
 * @Filename：ThreadTest
 * @create 2023-05-10 16:54
 *
 * 多线程的创建，方式一：继承于Thread类
 * 1,创建一个继承于Thread.类的子类
 * 2,重写Thread类的run() &gt;&gt;&gt;&gt; 将此线程执行的操作声明在run()中
 * 3.创建Thread类的子类的对象
 * 4.通过此对象调用start()
 *
 * 例子：追历00以内的所有的偶数
 */

//创建一个继承于Thread类的子类
class MyThread extends Thread{
    //重写Thread类的run()
    @Override
    public void run() {
       for(int i = 0;i &lt; 100; i++){
           if(i % 2 == 0){
               System.out.println(Thread.currentThread().getName() + ":" + i);
           }
       }
    }
}

public class ThreadTest {
    public static void main(String[] args) {
        //创建Thread类的子类的对象
        MyThread t1 = new MyThread();

        //通过此对象调用start() ①启动当前线程。②调用当前线程的run()
        t1.start();

        // 问题一、我们不能通过直接调用run()的方式启动线程。
//        t1.run();

        // 间题二：再启动一个线程，遍历100以内的偶数
//        t1.start(); // 不可以还让已经start（）的线程去执行。会报ILLegal ThreadstateException
        // 我们需要重新速一个线程的对象
        MyThread t2 = new MyThread();
        t2.start();

        //如下操作仍然是在main线程中执行的。
        for(int i = 0;i &lt; 100; i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i + "----------------main()---------------");
            }
        }
    }
}
</code></pre> 
<pre><code class="language-java">package com.tyl.java;

/**
 * @author tyl tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename：ThreadDemo
 * @create 2023-05-10 17:23
 *
 * 练习：创建两个分线程，其中一个线程遍励100以内的偶数，另一个线程遍阳以内的奇数
 */

public class ThreadDemo {
    public static void main(String[] args) {
//        MyThread1 m1 = new MyThread1();
//        MyThread2 m2 = new MyThread2();
//
//        m1.start();
//        m2.start();

        //创建Thread类的匿名子类的方式
        new Thread(){
            @Override
            public void run() {
                for(int i = 0;i &lt; 100; i++){
                    if(i % 2 == 0){
                        System.out.println(Thread.currentThread().getName() + ":" + i);
                    }
                }
            }
        }.start();

        new Thread(){
            @Override
            public void run() {
                for(int i = 0;i &lt; 100; i++){
                    if(i % 2 != 0){
                        System.out.println(Thread.currentThread().getName() + ":" + i);
                    }
                }
            }
        }.start();
    }
}

class MyThread1 extends Thread{
    @Override
    public void run() {
        for(int i = 0;i &lt; 100; i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}

class MyThread2 extends Thread{
    @Override
    public void run() {
        for(int i = 0;i &lt; 100; i++){
            if(i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}
</code></pre> 
<pre><code class="language-java">package com.tyl.java;

/**
 * @author tyl tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename：ThreadMethodTest
 * @create 2023-05-10 17:59
 *
 *测试Thread中的常用方法：
 * 1.start（）:启动当前线程：调用当前线程的run（）
 * 2,run（）:通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中
 * 3.currentThread（）:静态方法，返回执行当前代码的线程
 * 4.getName（）:获取当前线程的名字
 * 5.setName（）:设置当前线程的名字
 * 6.yield() :释放当前cpu的执行权
 * 7.join（）:在线0中调用线品的的0in（）,此时线品就进入阻塞状态，直到线b完全执行完以后，线品才
 *            结束阻塞状态。
 * 8.Stop（）:己过时。当执行此方法时，强制结束当前线程。
 * 9.sLeep(Long millitime):让当前线理睡眠”指定的nillitime毫秒。庄指定的millitime毫秒时间内，当前
 *                          线程是阻塞状态。
 * 10.isAlive（）:判断当前线程是否存活
 *
 * 线程的优先级等级
 * MAX_PRIORITY：10
 * MIN _PRIORITY：1
 * NORM_PRIORITY：5 默认优先级
 *
 * getPriority() ：返回线程优先值
 * setPriority(int newPriority) ：改变线程的优先级
 *
 * 说明：高优先级的线程要抢占低优先级线程山的执行权。但是只是从概率上讲，高优先级的线程高授率的情况下
 * 被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行.
 */

class HelloThread extends Thread{
    @Override
    public void run() {
        for(int i = 0;i &lt; 100; i++){
            if(i % 2 == 0){

//                try {
//                    sleep(10);
//                } catch (InterruptedException e) {
//                    throw new RuntimeException(e);
//                }
                System.out.println(Thread.currentThread().getName() + ":" +Thread.currentThread().getPriority() + ":" + i);
            }

//            if(i % 20 == 0){
//                yield();
//            }
        }
    }

    public HelloThread(String name){
        super(name);
    }
}

public class ThreadMethodTest {
    public static void main(String[] args) {
        HelloThread h1 = new HelloThread("thread:1");
//        h1.setName("线程1");

        // 设置分线程的优先级
        h1.setPriority(Thread.MAX_PRIORITY);

        h1.start();

        // 给主线程命名
        Thread.currentThread().setName("主线程");
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);

        for(int i = 0;i &lt; 100; i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + Thread.currentThread().getPriority() + ":" + i);
            }

//            if(i == 20){
//                try {
//                    h1.join();
//                } catch (InterruptedException e) {
//                    throw new RuntimeException(e);
//                }
//            }
        }

        System.out.println(h1.isAlive());
    }
}
</code></pre> 
<pre><code class="language-java">package com.tyl.java;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename：WindowTest
 * @create 2023-05-10 19:09
 *
 * 例子：创建三个窗口卖票，总票数为100张  使用继承Thread类的方式
 * 存在线程的安全问题，待解决。
 */

class Window extends Thread{

    private static int ticket = 100;
    @Override
    public void run() {
        while (true){
            if(ticket &gt; 0){
                System.out.println(getName() + ":买票，票号为：" + ticket);
                ticket--;
            }else {
                break;
            }
        }
    }
}

public class WindowTest {
    public static void main(String[] args) {
        Window t1 = new Window();
        Window t2 = new Window();
        Window t3 = new Window();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();

    }
}
</code></pre> 
<p></p> 
<hr> 
<p class="img-center"><img alt="" height="213" src="https://images2.imgbox.com/b7/61/dCp9p7qC_o.png" width="757"></p> 
<h4 id="%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%C2%A0">代码演示 </h4> 
<pre><code class="language-java">package com.tyl.com;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.com
 * @Project：workidea
 * @Filename：ThreadTest1
 * @create 2023-05-10 19:24
 *
 *创建多线程的方式二：实现RunnabLe接口
 * 1.创建一个实现了RunnabLe.接口的类
 * 2.实现类去实现Runnable中的抽象方法：run（）
 * 3.创建实现类的对象
 * 4.将此对象作为参数传递到Thread.类的构造器中，创建Thread类的对象
 * 5.通Thread.类的对象调用start（）
 *
 *比较创建线程的两种方式。
 * 开发中：优先选择：实现Runnable接口的方式
 *    原因：1.实现的方式没有类的单继承性的局限性
 *         2.实现的方式更适合来处理多个线程有共享数据的情况。
 * 联系：public class Thread implements Runnable
 * 相同点：两种方式都需要重写run（）,将线程要执行的逻辑声明在run（）中。
 *
 */

//创建一个实现了RunnabLe.接口的类
class MThread implements Runnable{
    //实现类去实现Runnable中的抽象方法：run（）
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}

public class ThreadTest1 {
    public static void main(String[] args) {
        //创建实现类的对象
        MThread mThread = new MThread();
        //将此对象作为参数传递到Thread.类的构造器中，创建Thread类的对象
        Thread t1 = new Thread(mThread);
        t1.setName("线程1");
        //通过Thread.类的对象调用start（）
        t1.start();

        //再启动一个线程，遍历100以内的偶数
        Thread t2 = new Thread(mThread);
        t2.setName("线程2");
        t2.start();
    }
}
</code></pre> 
<pre><code class="language-java">package com.tyl.java;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename：WindowTest1
 * @create 2023-05-10 21:51
 *
 * 例子：创建三个窗口卖票，总票数为100张  使用实现Runnable接口的方式
 * 存在线程的安全问题，待解决。
 */
class Window1 implements Runnable{

    private int ticket = 100;
    @Override
    public void run() {
        while (true){
            if(ticket &gt; 0){
                System.out.println(Thread.currentThread().getName() + ":买票，票号为：" + ticket);
                ticket--;
            }else {
                break;
            }
        }
    }

}
public class WindowTest1 {
    public static void main(String[] args) {
        Window1 w = new Window1();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre> 
<hr> 
<p class="img-center"><img alt="" height="312" src="https://images2.imgbox.com/1c/c7/BZegHYEd_o.png" width="722"></p> 
<h3 id="%C2%A04.%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"> 4.线程的调度</h3> 
<p class="img-center"><img alt="" height="275" src="https://images2.imgbox.com/9b/fa/Mhysw7Tk_o.png" width="668"></p> 
<p class="img-center"><img alt="" height="267" src="https://images2.imgbox.com/1b/3d/BrEVa213_o.png" width="593"></p> 
<p class="img-center"><img alt="" height="317" src="https://images2.imgbox.com/5d/c1/R3bcWsnk_o.png" width="690"></p> 
<blockquote> 
 <p><strong>重点： </strong></p> 
 <ol><li>谈谈你对程序、进程、线程的理解</li><li>代码完成继承Thread的方式创建分线程，并遍历100以内的自然数</li><li>代码完成实现Runnable接口的方法创建分线程，并遍历100以内的自然数</li><li>对比两种创建方式</li><li>说说你对IDEA中Project和Module的理解</li></ol> 
</blockquote> 
<hr> 
<h2 id="%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">三、线程的生命周期</h2> 
<h3 id="1.JDK%E4%B8%AD%E7%94%A8Thread.State%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%BA%86%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81">1.JDK中用Thread.State类定义了线程的几种状态</h3> 
<p class="img-center"><img alt="" height="451" src="https://images2.imgbox.com/32/b8/DoibbWmV_o.png" width="968"></p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/2a/fd/mWB4eRea_o.png" width="801"></p> 
<hr> 
<h2 id="%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5">四、线程的同步</h2> 
<h3 id="1.%E9%97%AE%E9%A2%98%E7%9A%84%E6%8F%90%E5%87%BA">1.问题的提出</h3> 
<p class="img-center"><img alt="" height="351" src="https://images2.imgbox.com/ed/40/ifllBJvU_o.png" width="758"></p> 
<h3 id="%C2%A02.Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"> 2.Synchronized的使用方法</h3> 
<p class="img-center"><img alt="" height="365" src="https://images2.imgbox.com/2a/19/AaMfaAKW_o.png" width="744"></p> 
<p></p> 
<p class="img-center"><img alt="" height="405" src="https://images2.imgbox.com/39/69/biYnXxli_o.png" width="740"></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/d3/34/c3Pj9gj9_o.png" width="764"></p> 
<p></p> 
<p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/a2/ae/oLDojEVW_o.png" width="720"></p> 
<p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/51/3e/EKGPg5y0_o.png" width="755"></p> 
<h3 id="%C2%A03.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"> 3.代码演示</h3> 
<h4 id="%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">使用同步代码解决实现Runnable接口的线程安全问题</h4> 
<pre><code class="language-java">package com.tyl.java;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @create 2023-05-10 21:51
 * &lt;p&gt;
 *  * 例子：创建三个窗口卖票，总票数为100张  使用实现Runnable接口的方式
 *  * 存在线程的安全问题，待解决。
 *  * &lt;p&gt;
 *  * 1.问题：卖票过程中，出现了重票、错票--&gt;出现了线程的安全问题
 *  * 2.问题出现的原因：当个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票
 *  * 3.如何解决：当一个线程在操作ticket的时候，其他线程不能参与进来。直到线程操作完ticket时，其他
 *  * 线程才可以开始操作ticket。这种情况即使线程出现了阻，也不能被改变，
 *  * &lt;p&gt;
 *  * 4.在jαvα中，我们通过同步机制，来解决线程的安全问题。
 *  * &lt;p&gt;
 *  * 方式一：同步代码块
 *  * synchronized（同步监视器）{
 *  //需要被同步的代码
 *  }
 *  说明：1.操作共享数据的代码，即为需要被同步的代码 ---&gt;&gt;不能包多 也不能包少
 *       2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。
 *       3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。
 *           要求：多个线程必须要共用同一把锁。
 *       4.补充：在实现Runnable接口创建多线程的方式中，我们可以考怎使用this充当同步监视器
 *
 *  * 方式二：同步方法
 * &lt;p&gt;
 * 5.同步的方式，解决了线程的安全问题。---好处
 *   操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。
 */
class Window1 implements Runnable{

    private int ticket = 100;
    Object obj = new Object();

    @Override
    public void run() {
        while (true){
//            synchronized (obj){
            synchronized (this){ // 此时的this:唯一的Window1的对象
                if(ticket &gt; 0){

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    System.out.println(Thread.currentThread().getName() + ":买票，票号为：" + ticket);
                    ticket--;
                }else {
                    break;
                }
            }
        }
    }

}
public class WindowTest1 {
    public static void main(String[] args) {
        Window1 w = new Window1();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre> 
<h4 id="%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">使用同步代码解决实现继承的线程安全问题</h4> 
<pre><code class="language-java">package com.tyl.java;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename：WindowTest
 * @create 2023-05-10 19:09
 * &lt;p&gt;
 * 例子：创建三个窗口卖票，总票数为100张  使用继承Thread类的方式
 *
 *使用同步代码块解决继承Thread.类的方式的线程安全问题
 *
 * 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器.考虑使用当前类充当同步监视器
 *
 */

class Window extends Thread{

    private static int ticket = 100;
    private static Object obj = new Object();
    @Override
    public void run() {
        while (true){
//            synchronized (obj){ //synchronized (this){ 是错误的
//            错误的方式：this代表着t1,t2,t3三个对象
            synchronized (Window.class){ // CLass cLazz Window2.cLass
                if(ticket &gt; 0){

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    System.out.println(getName() + ":买票，票号为：" + ticket);
                    ticket--;
                }else {
                    break;
                }
            }
        }
    }
}

public class WindowTest {
    public static void main(String[] args) {
        Window t1 = new Window();
        Window t2 = new Window();
        Window t3 = new Window();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();

    }
}
</code></pre> 
<h4 id="%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">使用同步方法解决实现Runnable接口的线程安全问题</h4> 
<pre><code class="language-java">package com.tyl.java;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename：WindowTest3
 * @create 2023-05-12 17:20
 *
 * 使用同步方法解决实现Runnable接口的线程安全问题
 *    关于同步方法的总结：
 * 1：同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
 * 2.非静态的同步方法，同步监视器是：this
 * 静态的同步方法，同步监视器是：当前类本身
 */
class Window3 implements Runnable {

    private int ticket = 100;

    @Override
    public void run() {
        while (true) {
            show();
        }
    }

    public synchronized void show(){ // 同步监视器：this
        if (ticket &gt; 0) {

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + ":买票，票号为：" + ticket);
            ticket--;
        }
    }
}

public class WindowTest3 {
    public static void main(String[] args) {
        Window1 w = new Window1();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre> 
<h4 id="%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">使用同步方法解决实现继承的线程安全问题</h4> 
<pre><code class="language-java">package com.tyl.java;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename：WindowTest4
 * @create 2023-05-12 17:26
 *
 *使用同步方法解决实现继承的线程安全问题
 */
class Window4 extends Thread {

    private static int ticket = 100;

    @Override
    public void run() {
        while (true) {
            show();
        }
    }
    public static synchronized void show(){ // 同步监视器：Window4.class
//    public static synchronized void show(){ // 同步监视器：t1,t2,t3  此种解决方式是错误的
        if (ticket &gt; 0) {

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + ":买票，票号为：" + ticket);
            ticket--;
        }
    }
}


public class WindowTest4 {
    public static void main(String[] args) {
        Window t1 = new Window();
        Window t2 = new Window();
        Window t3 = new Window();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();

    }
}
</code></pre> 
<h4 id="%E8%A7%A3%E5%86%B3%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%87%92%E6%B1%89%E5%BC%8F(%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8)">解决单例设计模式之懒汉式(线程安全)</h4> 
<pre><code class="language-java">package com.tyl.java1;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java1
 * @Project：workidea
 * @Filename：BankTest
 * @create 2023-05-12 17:50
 */
public class BankTest {
}

class Bank {
    private Bank() {}

    private static Bank instance = null;

    //    public static synchronized Bank getInstance() {
    public static Bank getInstance() {
        //方式一：效率稍差
//        synchronized (Bank.class) {
//            if(instance == null ){
//                instance = new Bank();
//            }
//            return instance;
//        }

        // 方式二: 效率更高
        if (instance == null) {
            synchronized (Bank.class) {
                if (instance == null) {
                    instance = new Bank();
                }
            }
        }
        return instance;
    }
}</code></pre> 
<h3 id="4.%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98">4.线程的死锁问题</h3> 
<p class="img-center"><img alt="" height="284" src="https://images2.imgbox.com/9e/3a/XNKY4ZMX_o.png" width="764"></p> 
<h4> 代码演示</h4> 
<pre><code class="language-java">package com.tyl.java1;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java1
 * @Project：workidea
 * @Filename：ThreadTest
 * @create 2023-05-15 16:54
 *
 * 演示线程的死锁问题
 * 1.死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，
 * 都在等待对方放弃自已需要的同步资源，就形成了线程的死锁
 *
 * 2.说明：
 * 1）出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
 * 2）我们使用同步时，要避免出现死锁。
 */
public class ThreadTest {
    public static void main(String[] args) {

        StringBuffer s1 = new StringBuffer();
        StringBuffer s2 = new StringBuffer();

        new Thread(){
            @Override
            public void run() {
                synchronized(s1){
                    s1.append("a");
                    s2.append("1");

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    synchronized (s2){
                        s1.append("b");
                        s2.append("2");

                        System.out.println(s1);
                        System.out.println(s2);
                    }

                }

            }
        }.start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized(s2){
                    s1.append("c");
                    s2.append("3");

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    synchronized (s1){
                        s1.append("d");
                        s2.append("4");

                        System.out.println(s1);
                        System.out.println(s2);
                    }

                }
            }
        }){}.start();
    }
}
</code></pre> 
<h3 id="%C2%A05.JDK%205.0%E6%96%B0%E5%A2%9E%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%96%B9%E6%B3%95%EF%BC%88lock%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%89"> 5.JDK 5.0新增解决线程安全方法（lock锁的方式）</h3> 
<p class="img-center"><img alt="" height="305" src="https://images2.imgbox.com/f4/2e/V9h1btqO_o.png" width="694"></p> 
<p></p> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/ca/76/ATHnE6cw_o.png" width="641"></p> 
<p></p> 
<p class="img-center"><img alt="" height="340" src="https://images2.imgbox.com/72/be/yyHFYHAl_o.png" width="662"></p> 
<h4> 代码演示</h4> 
<pre><code class="language-java">package com.tyl.java1;

import java.util.concurrent.locks.ReentrantLock;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java1
 * @Project：workidea
 * @Filename: LockTest
 * @create 2023-05-15 17:25
 *
 * 解决线程安全问题的方式三：Lock锁--JDK5.日新增
 *
 * 1.面试题：synchronized与Lock的异同？
 * 相同：二者都可以解决线程安全问题
 * 不同：synchronized.机制在执行完相应的同步代码以后，自动的释放同步监视器
 *       Lock需要手动的启动同步(Lock（）)，同时结束同步也需要手动的实现(unLock（）)
 *
 * 2.面试题：如何解决线程安全问题？有几种方式?
 */

class Window implements Runnable{
    private int ticket = 100;
    //实例化ReentrantLock
    private ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() {
        while(true){
            try {

                // 调用锁定方法札ock（）
                lock.lock();

                if(ticket &gt; 0){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    System.out.println(Thread.currentThread().getName() + ": 售票，票号为：" + ticket);
                    ticket--;
                }else{
                    break;
                }
            }finally {
                //调用解锁方法：unLock（）
                lock.unlock();
            }
        }
    }
}
public class LockTest {
    public static void main(String[] args) {
        Window w = new Window();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();


    }



}
</code></pre> 
<h2 id="%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1">五、线程的通信</h2> 
<h3 id="1.%E6%A6%82%E5%BF%B5">1.概念</h3> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/8d/20/IKzKNV65_o.png" width="714"></p> 
<p></p> 
<p class="img-center"><img alt="" height="270" src="https://images2.imgbox.com/06/9a/qZ9CJwGv_o.png" width="759"></p> 
<p class="img-center"><img alt="" height="229" src="https://images2.imgbox.com/ca/6b/T5OWqiZH_o.png" width="772"></p> 
<h3 id="%C2%A02.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"> 2.代码演示</h3> 
<pre><code class="language-java">package com.tyl.java2;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java2
 * @Project：workidea
 * @Filename: CommunicationTest
 * @create 2023-05-15 18:08
 *
 * 例 题
 * 使用两个线程打印 1-100。线程1, 线程2 交替打印
 *   涉及到的三个方法：
 * wa1t（）:一且执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
 * notify（）: 一旦执行此方，法就会唤醒被wait的一个线程。如果有多个线程被wait,就唤醒优先级高的那个。
 * notifyAll（）:一旦执行此方法，就会唤醒所有被wait的线程。
 *
 * 说明：
 * 1.wait（）,notify（）,notifyALL（）三个方法必须使用在同步代码块或同步方法中。
 * 2.wait（）,notify（）,notifyALL（）三个方法的调用者必须是同步代码块或同步方法中的同步监视器。
 *   否则，会出现ILLegaLMonitorstateException异常
 * 3.wait（）,notify（）,notifyALL（）三个方法是定以在java.Lang.Object类中，
 */
class Number implements Runnable{
    private int number = 1;
    private Object obj = new Object();

    @Override
    public void run() {
        while(true){

            synchronized (obj){

                obj.notify();

                if(number &lt;= 100){

                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    System.out.println(Thread.currentThread().getName() + ":" + number);
                    number++;

                    try {
                        // 使得调用如下wa1t（）方法的线程进入阻塞状态
                        obj.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                }else {
                    break;
                }
            }
        }
    }
}

public class CommunicationTest {
    public static void main(String[] args) {
        Number number = new Number();

        Thread t1 = new Thread(number);
        Thread t2 = new Thread(number);

        t1.setName("线程1");
        t2.setName("线程2");

        t1.start();
        t2.start();
    }

}
</code></pre> 
<blockquote> 
 <p><span style="color:#be191c;"><strong>面试题：sleep（）和wait（）的异同？</strong></span></p> 
 <p><strong><span style="color:#0d0016;">1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br> 2.不同点：1)两个方法声明的位置不同：Thread类中声明sLeep（）,Object.类中声明wait（）<br> 2)调用的要求不同：sLeep（）可以在任何需要的场景下调用。wait（）必须使用在同步代码块或同步方法中<br> 3)关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sLeep（）不会释放锁，wait（）会释放锁。</span></strong></p> 
</blockquote> 
<h3 id="3.%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%2F%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">3.经典例题：生产者/消费者问题</h3> 
<p class="img-center"><img alt="" height="281" src="https://images2.imgbox.com/f6/72/aZF3ROlT_o.png" width="801"></p> 
<p></p> 
<h4 id="%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">代码演示</h4> 
<pre><code class="language-java">package com.tyl.java2;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java2
 * @Project：workidea
 * @Filename: ProductTest
 * @create 2023-05-15 21:42
 *
 * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处
 * 取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图
 * 生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通
 * 知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如
 * 果店中有产品了再通知消费者来取走产品。
 *
 *分析：
 * 1.是否是多线程问题？是，生产者线程，消费者线程
 * 2.是否有共享数据？是，店员（或产品）
 * 3.如何解决线程的安全问题？同步机制有三种方法
 * 4.是否涉及线程的通信？是
 */

class Clerk{

    private int productCount = 0;

    // 生产产品
    public synchronized void produceProduct() {
        if(productCount &lt; 20){
            productCount++;
            System.out.println(Thread.currentThread().getName() + "： 开始生产第" + productCount + "个产品");

            notify();

        }else {
            try {
                wait();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    // 消费产品
    public synchronized void consumeProduct() {
        if(productCount &gt; 0){
            System.out.println(Thread.currentThread().getName() + "： 开始消费第" + productCount + "个产品");
            productCount--;

            notify();

        }else {
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

class Producer extends Thread{  //生产者
    private Clerk clerk;

    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+": 开始生产产品...........");

        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        while (true){
            clerk.produceProduct();
        }

    }
}

class Consumer extends Thread{  //消费者
    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+": 开始消费产品...........");

        try {
            Thread.sleep(20);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        while (true){
            clerk.consumeProduct();
        }

    }
}
public class ProductTest {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();

        Producer p1 = new Producer(clerk);
        p1.setName("生产者1");

        Consumer c1 = new Consumer(clerk);
        c1.setName("消费者1");

        Consumer c2 = new Consumer(clerk);
        c2.setName("消费者2");

        p1.start();
        c1.start();
        c2.start();

    }

}
</code></pre> 
<h2 id="%E5%85%AD%E3%80%81JDK5.0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F">六、JDK5.0新增线程创建方式</h2> 
<h3 id="1.%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3">1.新增方式一：实现Callable接口</h3> 
<p>与使用Runnable相比， Callable功能更强大些</p> 
<p> 相比run()方法，可以有返回值</p> 
<p> 方法可以抛出异常</p> 
<p> 支持泛型的返回值</p> 
<p> 需要借助FutureTask类，比如获取返回结果</p> 
<p class="img-center"><img alt="" height="230" src="https://images2.imgbox.com/42/bd/2tcX1YVv_o.png" width="650"></p> 
<h4> 代码演示</h4> 
<pre><code class="language-java">package com.tyl.java2;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java2
 * @Project：workidea
 * @Filename: ThreadNew
 * @create 2023-05-15 22:12
 *
 * 创建线程的方式三：实现Callable接口。--JDK5.9新增
 *
 * 如何理解实现Callable:接口的方式创建多线程比实现RunnabLe接口创建多线程方式强大？
 * 1.caLL可以有返回值的。
 * 2.caLL（）可以抛出异常，被外面的操作捕获，获取异常的信息
 * 3.Callable是支持泛型的
 */
// 1.创建一个实现Callable的实现类
class NumThread implements Callable{
    // 2.实现call方法，将此线程需要执行的操作声明在call（）中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i &lt;= 100 ; i++) {
            if(i % 2 == 0){
                System.out.println(i);
                sum += i;
            }
        }
        return sum;

        }
}

public class ThreadNew {
    public static void main(String[] args) {
        // 3.创建Callable接口实现类的对象
        NumThread numThread = new NumThread();
        // 4.将此Callable:接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        // 5.Future Task的对象作为参数传递到Thread.类的构造器中，创建Thread对象，并调用start（）
        new Thread(futureTask).start();

        Object sum = null;
        try {
            // 6.获取Callable中call方法的返因值
            // get（）返回值即为FutureTask构造器参数Callable实现类重写的call（）的返回值
            sum = futureTask.get();
            System.out.println("总和为：" +sum);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }

    }
}
</code></pre> 
<h3 id="2.%E6%96%B0%E5%A2%9E%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0">2.新增方式二：使用线程池</h3> 
<p class="img-center"><img alt="" height="329" src="https://images2.imgbox.com/34/29/B1r8EXnJ_o.png" width="705"></p> 
<h4 id="%C2%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3API"> 线程池相关API</h4> 
<p class="img-center"><img alt="" height="344" src="https://images2.imgbox.com/fa/a9/2HjjDSoH_o.png" width="730"></p> 
<pre><code class="language-java">package com.tyl.java2;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java2
 * @Project：workidea
 * @Filename: ThreadPool
 * @create 2023-05-15 22:48
 *
 * 创建线程的方式四：使用线程池
 *好处
 * 1.提高响应速度（减少了创建新线程的时间）
 * 2.降低资源消耗(重复利用线程池中线程，不需要每次都创建)
 * 3.便于线程管理
 *   corePoolSize:核心池的大小
 *   maximumPooLSize:最大线程数
 *   keepAliveTime:线程没有任务时最多保持多长时间后会终止
 *
 *   面试题：创建多线程有几种方式？四种！
 */

class NumberThread implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i &lt;= 100; i++) {
            if(i%2 == 0){
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
}

class NumberThread1 implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i &lt;= 100; i++) {
            if(i%2 != 0){
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
}

public class ThreadPool {
    public static void main(String[] args) {
        // 1.提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;

        // 设置线程池的属性
//        System.out.println(service.getClass());
//        service1.setCorePoolSize(15);
//        service1.setKeepAliveTime();

        // 2.执行指定的线程的操作。需要提供实现RunnabLe:接口或Callable接口实现类的对象
        service.execute(new NumberThread()); //适合适用于Runnable
        service.execute(new NumberThread1());

//        service.submit(); //适合使用于Callable

        // 3.关闭连接池
        service.shutdown();
    }
}
</code></pre> 
<blockquote> 
 <p><strong>多线程还挺重要，得好好把握！！！！！！</strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03e43104e040debf84508aeb355ae6fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android | Android OS 源码结构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c56aedb31a30aad8933a4ad0ba42b846/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java注解编译期处理AbstractProcessor详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>