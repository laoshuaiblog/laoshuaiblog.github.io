<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; Mutable - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/6184e96db6a40530fc6a1816ad4a0b9c/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="C&#43;&#43; Mutable">
  <meta property="og:description" content="1、mutable 含义及常规使用 mutable 英文中表示，易变的，不定的；性情不定的，而在代码中表示 可变数据成员。
由前面整理的 const详解 知道，由const修饰的成员函数中，不能对成员变量进行修改，因为隐藏的形参是 const 属性的。
而实际开发过程中，我们可能需要对某些成员变量进行修改，就需要用到 mutable。
class constA { public: constA(int a):m_a(a){} void funcA() const { cout &amp;lt;&amp;lt; &#43;&#43;m_a &amp;lt;&amp;lt; endl; } mutable int m_a; }; main.cpp constA ab(10); ab.funcA(); const constA abc(11); abc.funcA(); abc.m_a = 15; abc.funcA(); 输出 11 12 16 这里可以看到在const的成员函数中，可以对mutable修饰的变量进行修改。 而对于const对象，它的成员变量依然可以进行修改。
总结一句话：一个 可变数据成员，永远不会是const，即使它是const 对象的成员。
2、用于lambda表达式 前面整理的lambda表达式及其原理 时我们知道，在lambda捕捉列表 [ = ] 采用 传值方式捕捉外部变量 时，编译器将该表达式翻译成一个未命名类的未命名对象。该类含有一个经过const 修饰放入重载调用运算符。如下：
int func() {	int a =10; int b = 20; auto addfun = [=] (const int c ) -&amp;gt; int { return a&#43;c; }; int c = addfun(b); cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl; }; 等同于 class Myclass { public: Myclass( int a ) : m_a(a){};	//该形参对应捕获的变量 //该调用运算符的返回类型、形参和函数体都与lambda一致 int operator()(const int c) const { return a &#43; c; } private: int m_a;	//该数据对应通过值捕获的变量 }; 而加入 mutable后，相当于把 operator 的 const 修饰去掉，这样就可在函数内部对 传值方式捕捉的变量进行修改。具体书写方式如下：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-08-04T20:34:56+08:00">
    <meta property="article:modified_time" content="2021-08-04T20:34:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; Mutable</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1mutable__0"></a>1、mutable 含义及常规使用</h2> 
<p>mutable 英文中表示，易变的，不定的；性情不定的，而在代码中表示 <strong>可变数据成员</strong>。</p> 
<p>由前面整理的<a href="https://blog.csdn.net/weixin_39640298/article/details/85056516"> const详解 </a>知道，由const修饰的成员函数中，不能对成员变量进行修改，因为隐藏的形参是 const 属性的。</p> 
<p>而实际开发过程中，我们可能需要对某些成员变量进行修改，就需要用到 mutable。</p> 
<pre><code>class constA
{
public:
	constA(int a):m_a(a){}
	void funcA() const { cout &lt;&lt; ++m_a &lt;&lt; endl; }

	mutable int m_a;
};

main.cpp

	constA ab(10);
	ab.funcA();

	const constA abc(11);
	abc.funcA();
	abc.m_a = 15;
	abc.funcA();

输出
	11
	12
	16
</code></pre> 
<p>这里可以看到在const的成员函数中，可以对mutable修饰的变量进行修改。 而对于const对象，它的成员变量依然可以进行修改。</p> 
<p>总结一句话：<strong>一个 可变数据成员，永远不会是const，即使它是const 对象的成员</strong>。</p> 
<h2><a id="2lambda_38"></a>2、用于lambda表达式</h2> 
<p>前面整理的<a href="https://blog.csdn.net/weixin_39640298/article/details/84996642">lambda表达式及其原理</a> 时我们知道，在lambda捕捉列表 [ = ] 采用 <strong>传值方式捕捉外部变量</strong> 时，编译器将该表达式翻译成<strong>一个未命名类的未命名对象。该类含有一个经过const 修饰放入重载调用运算符</strong>。如下：</p> 
<pre><code>int func()
{	
	int a =10;
	int b = 20;
	auto addfun = [=] (const int c ) -&gt; int { return a+c; };
	
	int c = addfun(b);    
	cout &lt;&lt; c &lt;&lt; endl;
};

等同于

class Myclass
{
public:
	Myclass( int a ) : m_a(a){};	//该形参对应捕获的变量
	
	//该调用运算符的返回类型、形参和函数体都与lambda一致
	int operator()(const int c) const
	{
		return a + c;
	}
	
private:
	int m_a;		//该数据对应通过值捕获的变量
};

</code></pre> 
<p>而加入 mutable后，相当于把 operator 的 const 修饰去掉，这样就可在函数内部对 传值方式捕捉的变量进行修改。具体书写方式如下：</p> 
<pre><code>[capture list] (parameter list)  mutable  -&gt; return type {function body}
</code></pre> 
<h2><a id="3const_cast__77"></a>3、和const_cast 比较</h2> 
<p>前面整理的<a href="https://blog.csdn.net/weixin_39640298/article/details/85418743">C++强制类型转换</a> 时，<code>const_cast&lt;type&gt;(expression)</code> 可以 <strong>改变表达式中的常量性或易变性</strong>。</p> 
<p>而他两个的区别在于：<br> <strong>1、const_cast 中的 type 必须是指针或者引用<br> 2、mutable 一般只用于成员变量和lambda表达式</strong></p> 
<p>好了就整理到这了</p> 
<p><strong>感谢大家，我是假装很努力的YoungYangD（小羊）</strong></p> 
<p>参考资料：<br> 《C++ primer 第五版》</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/34981f13dc239b8cad960cce90ed5d6d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">停车场系统无法连接服务器,手动挡停车场 联机版无法连接服务器是什么原因...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df2feef889af2f0da149e766a3cc41ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">股票交易系统的服务器,股标交易传输系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>