<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>javaee——进程和线程的区别和联系 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/13b21b958717e109b09b5bcdfa70bcdb/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="javaee——进程和线程的区别和联系">
  <meta property="og:description" content="1.1 概念 1) 线程是什么 一个线程就是一个 &#34;执行流&#34;. 每个线程之间都可以按照顺讯执行自己的代码. 多个线程之间 &#34;同时&#34; 执行 着多份代码. 还是回到我们之前
2）进程和线程的区别 进程是包含线程的. 每个进程至少有一个线程存在，即主线程。 进程和进程之间不共享内存空间. 同一个进程的线程之间共享同一个内存空间.
进程是系统分配资源的最小单位，线程是系统调度的最小单位。
3）Java 的线程 和 操作系统线程 的关系 线程是操作系统中的概念. 操作系统内核实现了线程这样的机制, 并且对用户层提供了一些 API 供用户使 用(例如 Linux 的 pthread 库). Java 标准库中 Thread 类可以视为是对操作系统提供的 API 进行了进一步的抽象和封装.
1.2 创建线程 方法1 继承 Thread 类 1) 继承 Thread 来创建一个线程类.
class MyThread extends Thread { @Override public void run() { System.out.println(&#34;这里是线程运行的代码&#34;); } } 2) 创建 MyThread 类的实例
3) 调用 start 方法启动线程">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-19T09:21:36+08:00">
    <meta property="article:modified_time" content="2024-01-19T09:21:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">javaee——进程和线程的区别和联系</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.1 概念</h2> 
<h4>1) 线程是什么</h4> 
<p>一个线程就是一个 "执行流". 每个线程之间都可以按照顺讯执行自己的代码. 多个线程之间 "同时" 执行 着多份代码. 还是回到我们之前</p> 
<h4>2）进程和线程的区别</h4> 
<p>进程是包含线程的. 每个进程至少有一个线程存在，即主线程。 进程和进程之间不共享内存空间. 同一个进程的线程之间共享同一个内存空间.</p> 
<p>进程是系统分配资源的最小单位，线程是系统调度的最小单位。</p> 
<h4>3）Java 的线程 和 操作系统线程 的关系</h4> 
<p>线程是操作系统中的概念. 操作系统内核实现了线程这样的机制, 并且对用户层提供了一些 API 供用户使 用(例如 Linux 的 pthread 库). Java 标准库中 Thread 类可以视为是对操作系统提供的 API 进行了进一步的抽象和封装.</p> 
<h2>1.2 创建线程</h2> 
<h4>方法1 继承 Thread 类</h4> 
<p>1) 继承 Thread 来创建一个线程类.</p> 
<blockquote> 
 <pre><code class="hljs">class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("这里是线程运行的代码");
   }
}
</code></pre> 
</blockquote> 
<p>2) 创建 MyThread 类的实例</p> 
<p>3) 调用 start 方法启动线程</p> 
<h4>方法2 实现 Runnable 接口</h4> 
<p>1) 实现 Runnable 接口</p> 
<pre><code class="hljs">class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("这里是线程运行的代码");
   }
}
</code></pre> 
<p>2) 创建 Thread 类实例, 调用 Thread 的构造方法时将 Runnable 对象作为 target 参数.</p> 
<p>3) 调用 start 方法</p> 
<p><strong>对比上面两种方法:</strong></p> 
<p>继承 Thread 类, 直接使用 this 就表示当前线程对象的引用. 实现 Runnable 接口, this 表示的是 MyRunnable 的引用. 需要使用 Thread.currentThread()</p> 
<h2>1.3Thread 类及常见方法</h2> 
<h4>1）常见方法</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>方法</strong></td><td><strong>说明</strong></td></tr><tr><td>Thread()</td><td>创建线程对象</td></tr><tr><td>Thread(Runnable target)</td><td>使用 Runnable 对象创建线程对象</td></tr><tr><td>Thread(String name)</td><td>创建线程对象，并命名</td></tr><tr><td>Thread(Runnable target, String name)</td><td>使用 Runnable 对象创建线程对象，并命名</td></tr><tr><td>Thread(ThreadGroup group, Runnable target)</td><td>线程可以被用来分组管理，分好的组即为线程组，这 个目前我们了解即可</td></tr></tbody></table> 
<p></p> 
<h4>2）Thread 的几个常见属性</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p>属性</p> </td><td>获取方法</td></tr><tr><td>ID</td><td> <p>getld()</p> </td></tr><tr><td>名称</td><td>getName()</td></tr><tr><td>状态</td><td>getState()</td></tr><tr><td>优先级</td><td>getPriority()</td></tr><tr><td>是否后台线程</td><td>idDaemon()</td></tr><tr><td>是否存活</td><td>isAlive()</td></tr><tr><td>是否被中断</td><td>inlnterrupted()</td></tr></tbody></table> 
<p>ID 是线程的唯一标识，不同线程不会重复</p> 
<p>名称是各种调试工具用到</p> 
<p>状态表示线程当前所处的一个情况，下面我们会进一步说明</p> 
<p>优先级高的线程理论上来说更容易被调度到</p> 
<p>关于后台线程，需要记住一点：JVM会在一个进程的所有非后台线程结束后，才会结束运行。</p> 
<p>是否存活，即简单的理解，为 run 方法是否运行结束了</p> 
<h4>3）中断一个线程</h4> 
<p>目前常见的有以下两种方式：</p> 
<p>1. 通过共享的标记来进行沟通</p> 
<p>2. 调用 interrupt() 方法来通知</p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/83/14/Pj6qqlsp_o.png" width="734"></p> 
<h4>4）等待一个线程-join()</h4> 
<p><img alt="" height="167" src="https://images2.imgbox.com/aa/8d/dookgSwm_o.png" width="741"></p> 
<h4>5）获取当前线程引用</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>方法</strong></td><td><strong>说明</strong></td></tr><tr><td>public static Thread currentThread();</td><td>返回当前线程对象的引用</td></tr></tbody></table> 
<p></p> 
<h4>6）休眠当前线程</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>方法</strong></td><td><strong>说明</strong></td></tr><tr><td>public static void sleep(long millis) throws InterruptedException</td><td>休眠当前线程 millis 毫秒</td></tr><tr><td>public static void sleep(long millis, int nanos) throws InterruptedException</td><td>可以更高精度的休眠</td></tr></tbody></table> 
<p></p> 
<h2>1.4线程状态</h2> 
<p>NEW: 安排了工作, 还未开始行动</p> 
<p>RUNNABLE: 可工作的. 又可以分成正在工作中和即将开始工作.</p> 
<p>BLOCKED: 这几个都表示排队等着其他事情</p> 
<p>WAITING: 这几个都表示排队等着其他事情</p> 
<p>TIMED_WAITING: 这几个都表示排队等着其他事情</p> 
<p>TERMINATED: 工作完成了.</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/755205094318aca7cb0c968df192c6b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">批量截掉MP3文件的固定时间的python代码（亲测贼好用哦）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7341e40be9b39a36183dad5d746aa067/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构-Java逆天操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>