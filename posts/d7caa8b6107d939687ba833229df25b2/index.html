<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详解Java反射机制 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/d7caa8b6107d939687ba833229df25b2/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="详解Java反射机制">
  <meta property="og:description" content="一、什么是JAVA的反射机制
Java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的类的内部信息，包括其方法（诸如public, static 等）、父类（例如Object）、实现接口（例如Cloneable），也包括属性和方法的所有信息，并可于运行时改变属性值或调用方法。
Java反射机制容许程序在运行时加载、探知、使用编译期间完全未知的类。Java可以加载一个运行时才得知名称的类，获得其完整结构。
简言之，JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
二、JDK中提供的Reflection API
Java反射相关的API在包java.lang.reflect中，JDK 1.6.0的reflect包如下图：
该类下的几个主要类和接口 三、JAVA反射机制提供了什么功能
=========================================
Java反射机制提供如下功能（用途）：
在运行时判断任意一个对象所属的类
在运行时构造任意一个类的对象
在运行时判段任意一个类所具有的成员变量和方法
在运行时调用任一个对象的方法
在运行时创建新类对象
=======================================
一个对象的创建分三步完成：
1、加载类到内存； 2、静态资源初始化； 3、创建对象；
一个类对应一个字节码文件*.class，反射研究的就是字节码文件；一个字节码文件中主要包含类的成员变量、方法、构造方法；通过该字节码文件可以获取该类的相关信息。同一个字节码文件可以构建多个对象；
//类的字节码文件 MyA a1=new MyA(); //获得该类的字节码文件 Class clazz=a1.getClass(); 对象类型有字节码文件，基础的数据类型也有相应的字节码文件。
int.class void.class 在使用Java的反射功能时，基本首先都要获取类的Class字节码对象，再通过Class对象获取其他的对象。
1、获取类的Class字节码对象
Class 类的实例表示正在运行的 Java 应用程序中的类和接口。获取类的Class对象有多种方式：
2、获取类的属性
可以通过反射机制得到某个类的某个属性，然后可以改变对应于这个类的某个实例的该属性值。JAVA 的Class&amp;lt;T&amp;gt;类提供了几个方法获取类的属性。
public Field getField(String name) 返回某类一个public修饰的成员变量（public，包括父类中定义）；
public Field[] getFields() 返回一个数组，数组中包含某类下的public修饰的所有成员变量(public，包括父类中定义)；
public Field getDeclaredField(String name) 返回某类一个private修饰的成员变量（private，不包括父类中定义）；
public Field[] getDeclaredFields() 返回一个数组，数组中包含某类下的所有private修饰的成员变量(private，不包括父类中定义)；
3、获取类的方法
通过反射机制得到某个类的某个方法，然后可以调用对应于这个类的某个实例的该方法，Class&amp;lt;T&amp;gt;类提供了几个方法获取类的方法。
public Method getMethod(String name,Class&amp;lt;?&amp;gt;... parameterTypes) 通过方法名和方法的入参得到一个某类下的public修饰的Method方法对象（public，包括父类中定义）；">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2015-06-14T16:06:08+08:00">
    <meta property="article:modified_time" content="2015-06-14T16:06:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详解Java反射机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>一、什么是JAVA的反射机制</strong></p> 
<p>Java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的类的内部信息，包括其方法（诸如public, static 等）、父类（例如Object）、实现接口（例如Cloneable），也包括属性和方法的所有信息，并可于运行时改变属性值或调用方法。</p> 
<p>Java反射机制容许程序在运行时加载、探知、使用编译期间完全未知的类。Java可以加载一个运行时才得知名称的类，获得其完整结构。</p> 
<p>简言之，<strong>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</strong></p> 
<p><strong>二、JDK中提供的Reflection API</strong></p> 
<p>Java反射相关的API在包<strong>java.lang.reflect</strong>中，JDK 1.6.0的reflect包如下图：</p> 
<p><img src="https://images2.imgbox.com/3f/b4/VV6lsNeV_o.jpg" alt="这里写图片描述" title=""></p> 
<p>该类下的几个主要类和接口 <br> <img src="https://images2.imgbox.com/c2/29/wMWCIdw6_o.jpg" alt="这里写图片描述" title=""></p> 
<p><strong>三、JAVA反射机制提供了什么功能</strong></p> 
<p>=========================================</p> 
<p><strong>Java反射机制提供如下功能（用途）：</strong></p> 
<p>在运行时判断任意一个对象所属的类</p> 
<p>在运行时构造任意一个类的对象</p> 
<p>在运行时判段任意一个类所具有的成员变量和方法</p> 
<p>在运行时调用任一个对象的方法</p> 
<p>在运行时创建新类对象</p> 
<p>=======================================</p> 
<p>一个对象的创建分三步完成：</p> 
<p>1、加载类到内存； <br> 2、静态资源初始化； <br> 3、创建对象；</p> 
<p>一个类对应一个字节码文件*.class，反射研究的就是字节码文件；一个字节码文件中主要包含类的成员变量、方法、构造方法；通过该字节码文件可以获取该类的相关信息。同一个字节码文件可以构建多个对象；</p> 
<pre class="prettyprint"><code class=" hljs oxygene"><span class="hljs-comment">//类的字节码文件</span>
MyA a1=<span class="hljs-keyword">new</span> MyA();
<span class="hljs-comment">//获得该类的字节码文件</span>
<span class="hljs-keyword">Class</span> clazz=a1.getClass();</code></pre> 
<p>对象类型有字节码文件，基础的数据类型也有相应的字节码文件。</p> 
<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">int</span>.<span class="hljs-keyword">class</span>
<span class="hljs-keyword">void</span>.<span class="hljs-keyword">class</span>
</code></pre> 
<p><strong>在使用Java的反射功能时，基本首先都要获取类的Class字节码对象，再通过Class对象获取其他的对象。</strong></p> 
<p><strong>1、获取类的Class字节码对象</strong></p> 
<p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。获取类的Class对象有多种方式：</p> 
<p><img src="https://images2.imgbox.com/ce/2e/g55kd4Nt_o.png" alt="这里写图片描述" title=""></p> 
<p><strong>2、获取类的属性</strong></p> 
<p>可以通过反射机制得到某个类的某个属性，然后可以改变对应于这个类的某个实例的该属性值。JAVA 的<code>Class&lt;T&gt;</code>类提供了几个方法获取类的属性。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> Field <span class="hljs-title">getField</span>(String name) </code></pre> 
<p>返回某类一个public修饰的成员变量（public，包括父类中定义）；</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> Field[] <span class="hljs-title">getFields</span>() </code></pre> 
<p>返回一个数组，数组中包含某类下的public修饰的所有成员变量(public，包括父类中定义)；</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> Field  <span class="hljs-title">getDeclaredField</span>(String name) </code></pre> 
<p>返回某类一个private修饰的成员变量（private，不包括父类中定义）；</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> Field[] <span class="hljs-title">getDeclaredFields</span>() </code></pre> 
<p>返回一个数组，数组中包含某类下的所有private修饰的成员变量(private，不包括父类中定义)；</p> 
<p><strong>3、获取类的方法</strong></p> 
<p>通过反射机制得到某个类的某个方法，然后可以调用对应于这个类的某个实例的该方法，<code>Class&lt;T&gt;</code>类提供了几个方法获取类的方法。</p> 
<pre class="prettyprint"><code class=" hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">Method</span>  <span class="hljs-title">getMethod</span><span class="hljs-params">(String name,<span class="hljs-keyword">Class</span>&lt;?&gt;... parameterTypes)</span> </span></code></pre> 
<p>通过方法名和方法的入参得到一个某类下的public修饰的Method方法对象（public，包括父类中定义）；</p> 
<pre class="prettyprint"><code class=" hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">Method</span>[]  <span class="hljs-title">getMethods</span><span class="hljs-params">()</span> </span></code></pre> 
<p>得到某类下的public修饰的所有Method方法对象（public，包括父类定义的）</p> 
<pre class="prettyprint"><code class=" hljs r">public MethodgetDeclaredMethod(Stringname,Class&lt;?&gt;<span class="hljs-keyword">...</span> parameterTypes)</code></pre> 
<p>通过方法名和方法的入参得到一个某类下的private修饰的Method方法对象（private，不包括父类中定义）；；</p> 
<pre class="prettyprint"><code class=" hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">Method</span>[] <span class="hljs-title">getDeclaredMethods</span><span class="hljs-params">()</span> </span></code></pre> 
<p>得到某类下的private修饰的所有Method方法对象（private，不包括父类定义的）</p> 
<pre class="prettyprint"><code class=" hljs cs">通过反射获得类的方法（<span class="hljs-keyword">public</span>）

MyA m1=<span class="hljs-keyword">new</span> MyA();

Class clazz=m1.getClass();

<span class="hljs-comment">//方法名，入参</span>
clazz.getMethod(<span class="hljs-string">"setAge"</span>,<span class="hljs-keyword">int</span>.class);

<span class="hljs-comment">//获得方法名之后，如何调用该方法(对象，入参)</span>
setAge.invoke(m1,<span class="hljs-number">23</span>);<span class="hljs-comment">//调用m1下的该方法</span>

m1.getAge();<span class="hljs-comment">//23</span>

注意：
setAge.invoke(<span class="hljs-keyword">null</span>,<span class="hljs-number">23</span>);

当前类下的不依赖对象的方法（静态方法）要被执行；
</code></pre> 
<p><strong>4、获取类的Constructor构造方法</strong></p> 
<p>通过反射机制得到某个类的构造器，然后可以调用该构造器创建该类的一个实例<code>Class&lt;T&gt;</code> 类提供了几个方法获取类的构造器。</p> 
<p><code>public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) <br> </code> <br> 通过构造方法的入参返回一个有相应入参的 Constructor 对象（public，包括父类中定义）； </p> 
<pre class="prettyprint"><code class=" hljs delphi"><span class="hljs-keyword">public</span>   <span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;?&gt;[]    <span class="hljs-title">getConstructors</span><span class="hljs-params">()</span> </span></code></pre> 
<p>返回一个数组，该数组中包含该类下的所有构造方法（public，包括父类中定义）； </p> 
<pre class="prettyprint"><code class=" hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;<span class="hljs-title">T</span>&gt;  <span class="hljs-title">getDeclaredConstructor</span><span class="hljs-params">(<span class="hljs-keyword">Class</span>&lt;?&gt;... parameterTypes)</span></span></code></pre> 
<p>通过构造方法的入参返回一个有相应入参的 Constructor 对象（private，不包括父类中定义）； </p> 
<pre class="prettyprint"><code class=" hljs delphi"><span class="hljs-keyword">public</span>    <span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;?&gt;[]     <span class="hljs-title">getDeclaredConstructors</span><span class="hljs-params">()</span></span></code></pre> 
<p>返回一个数组，该数组中包含该类下的所有构造方法（private，不包括父类中定义）； </p> 
<p><strong>5、创建类的实例</strong></p> 
<p>通过反射机制创建类的实例，有几种方法可以创建</p> 
<p><strong>调用无自变量的构造器</strong></p> 
<p>1、调用类的Class对象的<strong>newInstance</strong>方法，该方法会调用对象的<strong>默认构造器</strong>，如果没有默认构造器，会调用失败（所以，在实际应用中用到这种方法时，如果要重写一个类的带参数的构造方法，就一定要把不带参数的构造方法显式定义出来）.</p> 
<pre class="prettyprint"><code class=" hljs delphi"><span class="hljs-keyword">Class</span>&lt;?&gt; classType = ExtendType.<span class="hljs-keyword">class</span>;
<span class="hljs-keyword">Object</span> inst = classType.newInstance();

System.<span class="hljs-keyword">out</span>.println(inst);
输出：
<span class="hljs-keyword">Type</span>:<span class="hljs-keyword">Default</span> <span class="hljs-function"><span class="hljs-keyword">Constructor</span>
<span class="hljs-title">ExtendType</span>:</span><span class="hljs-keyword">Default</span> <span class="hljs-function"><span class="hljs-keyword">Constructor</span>
<span class="hljs-title">com</span>.<span class="hljs-title">quincy</span>.<span class="hljs-title">ExtendType</span>@<span class="hljs-title">d80be3</span>
</span></code></pre> 
<p><strong>2、调用默认Constructor对象的newInstance方法</strong></p> 
<pre class="prettyprint"><code class=" hljs delphi"><span class="hljs-keyword">Class</span>&lt;?&gt; classType = ExtendType.<span class="hljs-keyword">class</span>;
<span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;?&gt; <span class="hljs-title">constructor1</span> = <span class="hljs-title">classType</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">()</span>;</span>
<span class="hljs-keyword">Object</span> inst = constructor1.newInstance();
System.<span class="hljs-keyword">out</span>.println(inst);
输出：
<span class="hljs-keyword">Type</span>:<span class="hljs-keyword">Default</span> Constrructor
ExtendType:<span class="hljs-keyword">Default</span> Constru
com.quincy.ExtendType@<span class="hljs-number">1006</span>d756d75

</code></pre> 
<p><strong>调用带参数构造器</strong></p> 
<p><strong>3、调用带参数Constructor对象的newInstance方法</strong></p> 
<pre class="prettyprint"><code class=" hljs avrasm">Constructor&lt;?&gt; constructor2 =

classType<span class="hljs-preprocessor">.getDeclaredConstructor</span>(int<span class="hljs-preprocessor">.class</span>, String<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>

Object inst = constructor2<span class="hljs-preprocessor">.newInstance</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"123"</span>)<span class="hljs-comment">;</span>

System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(inst)<span class="hljs-comment">;</span>

输出：

<span class="hljs-label">Type:</span>Default Constructor
<span class="hljs-label">ExtendType:</span>Constructor with parameters
<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.quincy</span><span class="hljs-preprocessor">.ExtendType</span><span class="hljs-localvars">@15</span>e83f9
</code></pre> 
<p><strong>6、调用类的函数</strong></p> 
<p>通过反射获取类Method方法对象，调用Field的Invoke方法调用函数（方法）。</p> 
<p>参见上面<strong>获取类的方法</strong>；</p> 
<p><strong>7、设置/获取类的属性值</strong></p> 
<p>通过反射获取类的成员变量，调用成员变量的方法设置或获取值；</p> 
<pre class="prettyprint"><code class=" hljs cs">MyA m1=<span class="hljs-keyword">new</span> MyA(<span class="hljs-string">"zhangsan"</span>);
MyA m2=<span class="hljs-keyword">new</span> MyA(<span class="hljs-string">"lisi"</span>);

Class clazz=m1.getClass();
<span class="hljs-comment">//获得MyA类的所有成员变量</span>
Field[] fields=clazz.getFields();

<span class="hljs-comment">//获得MyA下名为"name"的成员变量</span>
Field nameField=clazz.getField(<span class="hljs-string">"name"</span>);
以上适用于用<span class="hljs-keyword">public</span>修饰的成员变量，如果成员变量使用<span class="hljs-keyword">private</span>修饰的则拿不到；要用以下方法：

//nameField是一个引用（地址）
Field nameField=clazz.getDeclaredField(<span class="hljs-string">"name"</span>);
<span class="hljs-comment">//如果该成员变量使用private修饰的，要加下面一句</span>
nameField.setAccessible(<span class="hljs-string">"true"</span>);

------------------要指定获得哪一个对象上的数据
<span class="hljs-comment">//获得m1中nameField对应的成员变量的名字</span>
String name=nameField.<span class="hljs-keyword">get</span>(m1);

<span class="hljs-comment">//获得m2中nameField对应的成员变量的名字</span>
String name=nameField.<span class="hljs-keyword">get</span>(m2);

--------------------为m1中的成员变量设值
nameField.<span class="hljs-keyword">set</span>(m1,<span class="hljs-string">"张三"</span>);<span class="hljs-comment">//覆盖掉zhangsan </span>

<span class="hljs-comment">//获得nameField对应的成员变量的类型</span>
nameField.getType();
</code></pre> 
<p><strong>四、动态创建代理类</strong></p> 
<p>代理模式：代理模式的作用=为其他对象提供一种代理以控制对这个对象的访问。</p> 
<p><strong>代理模式的角色：</strong></p> 
<p>抽象角色：声明真实对象和代理对象的共同接口 <br> 代理角色：代理角色内部包含有真实对象的引用，从而可以操作真实对象。</p> 
<p>真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</p> 
<p><strong>动态代理：</strong>：</p> 
<p>java.lang.reflect.Proxy <br> Proxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类 <br> InvocationHandler <br> 是代理实例的调用处理程序实现的接口，每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序的 invoke 方法。</p> 
<p>动态Proxy是这样的一种类:</p> 
<p>它是在运行生成的类，在生成时你必须提供一组Interface给它，然后该class就宣称它实现了这些interface。你可以把该class的实例当作这些interface中的任何一个来用。当然，这个Dynamic Proxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</p> 
<p>在使用动态代理类时，我们必须实现ndler接口</p> 
<p>有关代理模式的具体了解请参看本人设计模式相关文章。</p> 
<p>补充：</p> 
<p>1、 <br> `MyA a1=new MyA();</p> 
<p>Class clazz=a1.getClass();</p> 
<p>MyA a2=new MyA();</p> 
<p>if(a1 == a2)…//不相等，比较的是引用（地址）</p> 
<p>if(clazz == a2.getClass())…//相等（是由同一个字节码文</p> 
<p>件构建的，都相当于：new MyA().getClass()） <br> `</p> 
<p>2、拿到一个字节码文件之后，如何判断它是一个<strong>对象类型还是普通的数据类型</strong>？</p> 
<pre class="prettyprint"><code class=" hljs d"><span class="hljs-comment">//基础数据类型返回true，对象类型返回false</span>
clazz.isPrimitive();<span class="hljs-comment">//false</span>

<span class="hljs-keyword">int</span>.<span class="hljs-keyword">class</span>.inPrimitive();<span class="hljs-comment">//true</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51fdc8e230e09ffaafcac94b2a45b6a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安装ggplot2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9e86aba8d07e30ef8f00a9da2457c94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">半同步/半异步并发模式进程池实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>