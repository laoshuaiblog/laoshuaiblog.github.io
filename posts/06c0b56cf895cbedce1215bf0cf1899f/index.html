<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>干货|Webhook配置钉钉/飞书机器人告警 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/06c0b56cf895cbedce1215bf0cf1899f/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="干货|Webhook配置钉钉/飞书机器人告警">
  <meta property="og:description" content="马嘉炜 | Zabbix开源社区签约专家
SRE运维工程师，六年Zabbix监控系统使用经验。在Zabbix架构设计及性能优化领域有丰富的经验，擅长监控模板制作及Zabbix API的二次开发。
官方使用手册《Zabbix标准模板指南》译者
简介
自 Zabbix 4.4.4 版本开始，Zabbix 的报警媒介类型加入了Webhook的支持。
Webhook 类型可用于使用自定义 JavaScript 代码进行 HTTP 调用，可以很方便的和外部系统进行集成，例如钉钉机器人、飞书机器人、企业微信等。
也可以集成第三方的系统来实现更加高级的功能，例如当主机自动注册到 Zabbix 中时，通过 Webhook 类型调用 API，将资产信息同步到 CMDB 系统，或者报警发生时，调用自动化平台的 API 来实现故障自愈的能力。
Webhook VS 自定义脚本
配置钉钉机器人告警
一、创建报警媒介
打开 Web 界面，并导航到管理 -&amp;gt; 报警媒介类型，点击右上角创建媒介类型
配置报警媒介类型
配置参考如下： 名称：DingTalk
类型：Webhook
参数：
| 名称 | 值 | 说明 |
| —- | —- | —- |
| HTTPProxy | | Http代理地址 |
| Message | {ALERT.MESSAGE} | 告警消息内容 |">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-11-10T10:17:41+08:00">
    <meta property="article:modified_time" content="2022-11-10T10:17:41+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">干货|Webhook配置钉钉/飞书机器人告警</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>马嘉炜 | Zabbix开源社区签约专家</p> 
<p>SRE运维工程师，六年Zabbix监控系统使用经验。在Zabbix架构设计及性能优化领域有丰富的经验，擅长监控模板制作及Zabbix API的二次开发。</p> 
<p>官方使用手册《Zabbix标准模板指南》译者</p> 
<p>简介<br> 自 Zabbix 4.4.4 版本开始，Zabbix 的报警媒介类型加入了Webhook的支持。</p> 
<p>Webhook 类型可用于使用自定义 JavaScript 代码进行 HTTP 调用，可以很方便的和外部系统进行集成，例如钉钉机器人、飞书机器人、企业微信等。</p> 
<p>也可以集成第三方的系统来实现更加高级的功能，例如当主机自动注册到 Zabbix 中时，通过 Webhook 类型调用 API，将资产信息同步到 CMDB 系统，或者报警发生时，调用自动化平台的 API 来实现故障自愈的能力。</p> 
<p><strong>Webhook VS 自定义脚本</strong></p> 
<p><img src="https://images2.imgbox.com/28/6b/6Z8dKXrI_o.png" alt="在这里插入图片描述"></p> 
<p><strong>配置钉钉机器人告警</strong><br> 一、创建报警媒介<br> 打开 Web 界面，并导航到管理 -&gt; 报警媒介类型，点击右上角创建媒介类型</p> 
<p><img src="https://images2.imgbox.com/5c/98/98HS5IjT_o.png" alt="在这里插入图片描述"></p> 
<ol><li>配置报警媒介类型<br> 配置参考如下：</li></ol> 
<p>名称：DingTalk<br> 类型：Webhook<br> 参数：<br> | 名称 | 值 | 说明 |<br> | —- | —- | —- |<br> | HTTPProxy | | Http代理地址 |<br> | Message | {ALERT.MESSAGE} | 告警消息内容 |<br> | Subject | {ALERT.SUBJECT} | 告警消息主题 |<br> | To | {ALERT.SENDTO} | 告警消息接收者 |</p> 
<p>脚本：见下文<br> 超时：30s</p> 
<p>其他配置及说明参考文档：Webhook</p> 
<p>脚本内容：</p> 
<pre><code class="prism language-bash">try <span class="token punctuation">{<!-- --></span>    // 实例化参数
    var params <span class="token operator">=</span> JSON.parse<span class="token punctuation">(</span>value<span class="token punctuation">)</span>,
        req <span class="token operator">=</span> new HttpRequest<span class="token punctuation">(</span><span class="token punctuation">)</span>,
        msg <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
            msgtype: <span class="token string">'text'</span>,
            text: <span class="token punctuation">{<!-- --></span>
                content: params.Subject + <span class="token string">'\n'</span> + params.Message
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>,
        resp<span class="token punctuation">;</span>    // 判断是否需要配置HTTP代理
    <span class="token keyword">if</span> <span class="token punctuation">(</span>params.HTTPProxy<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        req.setProxy<span class="token punctuation">(</span>params.HTTPProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    // 添加header头变量
    req.addHeader<span class="token punctuation">(</span><span class="token string">'Content-Type: application/json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // 发送HTTP Post请求，格式：req.post<span class="token punctuation">(</span>url, data<span class="token punctuation">)</span>
    resp <span class="token operator">=</span> req.post<span class="token punctuation">(</span>params.To,        JSON.stringify<span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>    // 判断HTTP请求返回的状态码，非200则抛出异常
    <span class="token keyword">if</span> <span class="token punctuation">(</span>req.getStatus<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        throw <span class="token string">'Response code: '</span> + req.getStatus<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    // 返回响应结果
    resp <span class="token operator">=</span> JSON.parse<span class="token punctuation">(</span>resp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token builtin class-name">return</span> JSON.stringify<span class="token punctuation">(</span>resp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>catch <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>    throw <span class="token string">'Failed with error: '</span> + error<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>脚本解析：<br> var params = JSON.parse(value): 脚本外传入的参数存放在value变量内，数据为json格式。通过JSON.parse方法转换为JavaScript的对象。例如params.Subject对应的就是上面{ALERT.SUBJECT}的值<br> req = new HttpRequest(): 实例化一个HTTP对象。该对象封装了 cURL 句柄，允许发送简单的 HTTP请求。错误将作为异常抛出。</p> 
<p>注意：在Zabbix5.4之前，该对象名为CurlHttpRequest。</p> 
<p>msg: HTTP请求的数据，这里是将告警的主题和内容封装为一个钉钉机器人支持的数据格式。<br> resp: HTTP请求响应对象。<br> req.setProxy(params.HTTPProxy): 设置HTTP代理。<br> req.addHeader(‘Content-Type: application/json’): 添加HTTP请求的header头变量。<br> resp = req.post(params.To, JSON.stringify(msg)): 发送HTTP Post请求。JSON.stringify方法将JavaScript的对象转换为json格式。<br> req.getStatus(): HTTP请求的响应状态码。</p> 
<p>其他Webhook脚本案例参考：Webhook 脚本范例<br> JavaScript内置的对象及方法参考：JavaScript对象</p> 
<p>配置完成后如下图所示</p> 
<p><img src="https://images2.imgbox.com/c4/af/OCCifvD0_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/53/71/qXV4gfV9_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>配置消息模版<br> 选择Message template标签页，并添加Message type（消息类型），消息类型、主题、消息的内容根据实际需求配置即可，也可以直接使用默认的内容。</li></ol> 
<p><img src="https://images2.imgbox.com/65/95/VofeXjFC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/37/42/I8VK0Qqe_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/bf/4a/YLEyxM8W_o.png" alt="在这里插入图片描述"></p> 
<p>注意：主题和消息的内容支持macro宏变量，具体的宏变量可参考官方文档</p> 
<p>选项页面可配置告警的并发及重试，可以根据实际情况来配置。</p> 
<p><strong>二、获取自定义机器人Webhook</strong></p> 
<ol><li> <p>选择需要添加机器人的群聊，然后依次单击群设置 &gt; 智能群助手。<br> <img src="https://images2.imgbox.com/e6/64/PosTkfnL_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在机器人管理页面选择自定义机器人，输入机器人名字并选择要发送消息的群，同时可以为机器人设置机器人头像。<br> 图片<br> <img src="https://images2.imgbox.com/9d/54/esVTcRar_o.png" alt="在这里插入图片描述"></p> </li><li> <p>完成必要的安全设置，勾选我已阅读并同意《自定义机器人服务及免责条款》，然后单击完成。<br> <img src="https://images2.imgbox.com/87/c0/zGUd3rLQ_o.png" alt="在这里插入图片描述"></p> </li><li> <p>完成安全设置后，复制出机器人的Webhook地址，可用于向这个群发送消息，格式如下：<br> https://oapi.dingtalk.com/robot/send?access_token=XXXXXX</p> </li></ol> 
<p><strong>三、测试告警发送</strong><br> 回到报警媒介类型页面，找到刚才创建的报警媒介，并点击右侧的测试</p> 
<p><img src="https://images2.imgbox.com/b1/2a/YTupV0Hx_o.png" alt="在这里插入图片描述"></p> 
<p>将刚才配置的消息模版的主题粘贴到Subject输入框中，内容粘贴到Message输入框中，并将机器人的Webhook地址粘贴到To的输入框中，点击测试。<br> <img src="https://images2.imgbox.com/a4/99/u9ugThei_o.png" alt="在这里插入图片描述"></p> 
<p>确认钉钉群将收到告警消息</p> 
<p><img src="https://images2.imgbox.com/eb/d7/0f3YKg1e_o.png" alt="在这里插入图片描述"></p> 
<p><strong>四、配置告警</strong></p> 
<ol><li>创建动作<br> Web界面导航到配置 -&gt; 动作 -&gt; Trigger actions，点击右上角的创建动作<br> <img src="https://images2.imgbox.com/92/86/ezYbXbno_o.png" alt="在这里插入图片描述"></li></ol> 
<p>配置动作的名称<br> <img src="https://images2.imgbox.com/34/0d/Kwa4e5Zm_o.png" alt="在这里插入图片描述"></p> 
<p>配置具体的操作细节</p> 
<p>注意：需要配置指定的发送用户，及发送的媒介<br> <img src="https://images2.imgbox.com/7e/fe/2PPUrGdy_o.png" alt="在这里插入图片描述"></p> 
<p><strong>2. 配置告警通知Webhook</strong><br> Web界面导航到管理 -&gt; 用户，找到刚才配置的发送用户，并选择报警媒介的标签页</p> 
<p>类型选择刚才创建的报警媒介DingTalk，并将钉钉机器人的Webhook地址填入收件人的输入框，如图所示<br> <img src="https://images2.imgbox.com/b9/ee/TzAulWuD_o.png" alt="在这里插入图片描述"></p> 
<p>注意：用户需要有具体主机的可读权限才可以收到主机的告警信息。</p> 
<p><strong>3. 确认能够接受告警</strong><br> <img src="https://images2.imgbox.com/de/68/9Mdow3ee_o.png" alt="在这里插入图片描述"></p> 
<p>配置其他Webhook类型的告警<br> Webhook 类型除了能够配置钉钉机器人，同样也支持飞书、企业微信等。区别仅仅是在JavaScript脚本及飞书、企业微信的Webhook地址不一样。</p> 
<p><strong>一、配置飞书机器人告警</strong></p> 
<ol><li>配置报警媒介类型<br> 配置参考如下：</li></ol> 
<p>名称：Feishu<br> 类型：Webhook<br> 参数：<br> | 名称 | 值 | 说明 |<br> | —- | —- | —- |<br> | HTTPProxy | | Http代理地址 |<br> | Message | {ALERT.MESSAGE} | 告警消息内容 |<br> | Subject | {ALERT.SUBJECT} | 告警消息主题 |<br> | To | {ALERT.SENDTO} | 告警消息接收者 |</p> 
<p>脚本：见下文<br> 超时：30s</p> 
<p>其他配置及说明参考文档：Webhook</p> 
<p>脚本内容：</p> 
<p>t</p> 
<pre><code class="prism language-bash">ry <span class="token punctuation">{<!-- --></span>    // 实例化参数
    var params <span class="token operator">=</span> JSON.parse<span class="token punctuation">(</span>value<span class="token punctuation">)</span>,
        req <span class="token operator">=</span> new HttpRequest<span class="token punctuation">(</span><span class="token punctuation">)</span>,
        msg <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
            msg_type: <span class="token string">'text'</span>,
            content: <span class="token punctuation">{<!-- --></span>
                text: params.Subject + <span class="token string">'\n'</span> + params.Message
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>,
        resp<span class="token punctuation">;</span>    // 判断是否需要配置HTTP代理
    <span class="token keyword">if</span> <span class="token punctuation">(</span>params.HTTPProxy<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        req.setProxy<span class="token punctuation">(</span>params.HTTPProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    // 添加header头变量
    req.addHeader<span class="token punctuation">(</span><span class="token string">'Content-Type: application/json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // 发送HTTP Post请求，格式：req.post<span class="token punctuation">(</span>url, data<span class="token punctuation">)</span>
    resp <span class="token operator">=</span> req.post<span class="token punctuation">(</span>params.To,        JSON.stringify<span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>    // 判断HTTP请求返回的状态码，非200则抛出异常
    <span class="token keyword">if</span> <span class="token punctuation">(</span>req.getStatus<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>        throw <span class="token string">'Response code: '</span> + req.getStatus<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    // 返回响应结果
    resp <span class="token operator">=</span> JSON.parse<span class="token punctuation">(</span>resp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token builtin class-name">return</span> JSON.stringify<span class="token punctuation">(</span>resp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>catch <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>    throw <span class="token string">'Failed with error: '</span> + error<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>细心的同学可以发现，脚本内容和钉钉机器人相比，只有msg变量的部分有些许更改。</p> 
<p><strong>2. 配置消息模版</strong><br> 选择Message template标签页，并添加Message type（消息类型），消息类型、主题、消息的内容根据实际需求配置即可，也可以直接使用默认的内容。</p> 
<p><img src="https://images2.imgbox.com/ab/f2/Z7f3zPUI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/32/c2/dZyzEKlF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/70/dc/pt7fj5CN_o.png" alt="在这里插入图片描述"></p> 
<p>注意：主题和消息的内容支持macro宏变量，具体的宏变量可参考官方文档</p> 
<p>选项页面可配置告警的并发及重试，可以根据实际情况来配置。</p> 
<p>二、获取自定义机器人Webhook<br> 配置飞书机器人参考：自定义机器人指南</p> 
<p>配置完成后获取到的Webhook地址，格式如下：</p> 
<p>https://open.feishu.cn/open-apis/bot/v2/hook/xxxxxxxxxxxxxxxxx</p> 
<p>其余测试及配置告警的方法可参考上文钉钉机器人配置部分。</p> 
<p>注意: 发送的媒介及用户的报警媒介收件人地址需要更改。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/52e1ca3ebb4f0a0c03f7d6e5800fa0c5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">cache三种地址映像</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4671219f170dac69e453bcaa5446a942/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">netstat详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>