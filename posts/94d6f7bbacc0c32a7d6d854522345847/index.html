<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kotlin实现ajax,Kotlin调用JavaScript - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/94d6f7bbacc0c32a7d6d854522345847/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="kotlin实现ajax,Kotlin调用JavaScript">
  <meta property="og:description" content="Kotlin 已被设计为能够与 Java 平台轻松互操作。它将 Java 类视为 Kotlin 类，并且
Java 也将 Kotlin 类视为 Java 类。但是，JavaScript 是一种动态类型语言，这意味着
它不会在编译期检查类型。你可以通过动态类型在
Kotlin 中自由地与 JavaScript 交流，但是如果你想要 Kotlin 类型系统的全部威力
，你可以为 JavaScript 库创建 Kotlin 头文件。
内联 JavaScript
你可以使用 js(“……”) 函数将一些 JavaScript 代码嵌入到 Kotlin 代码中。
例如：
fun jsTypeOf(o: Any): String {
return js(&#34;typeof o&#34;)
}
js 的参数必须是字符串常量。因此，以下代码是不正确的：
fun jsTypeOf(o: Any): String {
return js(getTypeof() &#43; &#34; o&#34;) // 此处报错
}
fun getTypeof() = &#34;typeof&#34;
external 修饰符
要告诉 Kotlin 某个声明是用纯 JavaScript 编写的，你应该用 external 修饰符来标记它。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-08-06T22:55:34+08:00">
    <meta property="article:modified_time" content="2021-08-06T22:55:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kotlin实现ajax,Kotlin调用JavaScript</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>Kotlin 已被设计为能够与 Java 平台轻松互操作。它将 Java 类视为 Kotlin 类，并且</p> 
 <p>Java 也将 Kotlin 类视为 Java 类。但是，JavaScript 是一种动态类型语言，这意味着</p> 
 <p>它不会在编译期检查类型。你可以通过动态类型在</p> 
 <p>Kotlin 中自由地与 JavaScript 交流，但是如果你想要 Kotlin 类型系统的全部威力</p> 
 <p>，你可以为 JavaScript 库创建 Kotlin 头文件。</p> 
 <p>内联 JavaScript</p> 
 <p>你可以使用 js(“……”) 函数将一些 JavaScript 代码嵌入到 Kotlin 代码中。</p> 
 <p>例如：</p> 
 <p>fun jsTypeOf(o: Any): String {<!-- --></p> 
 <p>return js("typeof o")</p> 
 <p>}</p> 
 <p>js 的参数必须是字符串常量。因此，以下代码是不正确的：</p> 
 <p>fun jsTypeOf(o: Any): String {<!-- --></p> 
 <p>return js(getTypeof() + " o") // 此处报错</p> 
 <p>}</p> 
 <p>fun getTypeof() = "typeof"</p> 
 <p>external 修饰符</p> 
 <p>要告诉 Kotlin 某个声明是用纯 JavaScript 编写的，你应该用 external 修饰符来标记它。</p> 
 <p>当编译器看到这样的声明时，它假定相应类、函数或</p> 
 <p>属性的实现由开发人员提供，因此不会尝试从声明中生成任何 JavaScript 代码。</p> 
 <p>这意味着你应该省略 external 声明内容的代码体。例如：</p> 
 <p>external fun alert(message: Any?): Unit</p> 
 <p>external class Node {<!-- --></p> 
 <p>val firstChild: Node</p> 
 <p>fun append(child: Node): Node</p> 
 <p>fun removeChild(child: Node): Node</p> 
 <p>// 等等</p> 
 <p>}</p> 
 <p>external val window: Window</p> 
 <p>请注意，嵌套的声明会继承 external 修饰符，即在 Node 类中，我们在</p> 
 <p>成员函数和属性之前并不放置 external。</p> 
 <p>external 修饰符只允许在包级声明中使用。 你不能声明一个非 external 类的 external 成员。</p> 
 <p>声明类的(静态)成员</p> 
 <p>在 JavaScript 中，你可以在原型或者类本身上定义成员。即：</p> 
 <p>function MyClass() {<!-- --></p> 
 <p>}</p> 
 <p>MyClass.sharedMember = function() { /* 实现 */ };</p> 
 <p>MyClass.prototype.ownMember = function() { /* 实现 */ };</p> 
 <p>Kotlin 中没有这样的语法。然而，在 Kotlin 中我们有伴生(companion)对象。Kotlin 以特殊的方式处理</p> 
 <p>external 类的伴生对象：替代期待一个对象的是，它假定伴生对象的成员</p> 
 <p>就是该类自身的成员。要描述来自上例中的 MyClass，你可以这样写：</p> 
 <p>external class MyClass {<!-- --></p> 
 <p>companion object {<!-- --></p> 
 <p>fun sharedMember()</p> 
 <p>}</p> 
 <p>fun ownMember()</p> 
 <p>}</p> 
 <p>声明可选参数</p> 
 <p>一个外部函数可以有可选参数。</p> 
 <p>JavaScript 实现实际上如何计算这些参数的默认值，是 Kotlin 所不知道的，</p> 
 <p>因此在 Kotlin 中不可能使用通常的语法声明这些参数。</p> 
 <p>你应该使用以下语法：</p> 
 <p>external fun myFunWithOptionalArgs(x: Int,</p> 
 <p>y: String = definedExternally,</p> 
 <p>z: Long = definedExternally)</p> 
 <p>这意味着你可以使用一个必需参数和两个可选参数来调用 myFunWithOptionalArgs(它们的</p> 
 <p>默认值由一些 JavaScript 代码算出)。</p> 
 <p>扩展 JavaScript 类</p> 
 <p>你可以轻松扩展 JavaScript 类，因为它们是 Kotlin 类。只需定义一个 external 类并用</p> 
 <p>非 external 类扩展它。例如：</p> 
 <p>external open class HTMLElement : Element() {<!-- --></p> 
 <p>/* 成员 */</p> 
 <p>}</p> 
 <p>class CustomElement : HTMLElement() {<!-- --></p> 
 <p>fun foo() {<!-- --></p> 
 <p>alert("bar")</p> 
 <p>}</p> 
 <p>}</p> 
 <p>有一些限制：</p> 
 <p>当一个外部基类的函数被签名重载时，不能在派生类中覆盖它。</p> 
 <p>不能覆盖一个使用默认参数的函数。</p> 
 <p>请注意，你无法用外部类扩展非外部类。</p> 
 <p>external 接口</p> 
 <p>JavaScript 没有接口的概念。当函数期望其参数支持 foo</p> 
 <p>和 bar 方法时，只需传递实际具有这些方法的对象。</p> 
 <p>对于静态类型的 Kotlin，你可以使用接口来表达这点，例如：</p> 
 <p>external interface HasFooAndBar {<!-- --></p> 
 <p>fun foo()</p> 
 <p>fun bar()</p> 
 <p>}</p> 
 <p>external fun myFunction(p: HasFooAndBar)</p> 
 <p>外部接口的另一个使用场景是描述设置对象。例如：</p> 
 <p>external interface JQueryAjaxSettings {<!-- --></p> 
 <p>var async: Boolean</p> 
 <p>var cache: Boolean</p> 
 <p>var complete: (JQueryXHR, String) -&gt; Unit</p> 
 <p>// 等等</p> 
 <p>}</p> 
 <p>fun JQueryAjaxSettings(): JQueryAjaxSettings = js("{}")</p> 
 <p>external class JQuery {<!-- --></p> 
 <p>companion object {<!-- --></p> 
 <p>fun get(settings: JQueryAjaxSettings): JQueryXHR</p> 
 <p>}</p> 
 <p>}</p> 
 <p>fun sendQuery() {<!-- --></p> 
 <p>JQuery.get(JQueryAjaxSettings().apply {<!-- --></p> 
 <p>complete = { (xhr, data) -&gt;</p> 
 <p>window.alert("Request complete")</p> 
 <p>}</p> 
 <p>})</p> 
 <p>}</p> 
 <p>外部接口有一些限制：</p> 
 <p>它们不能在 is 检查的右侧使用。</p> 
 <p>as 转换为外部接口总是成功(并在编译时产生警告)。</p> 
 <p>它们不能作为具体化类型参数传递。</p> 
 <p>它们不能用在类的字面值表达式(即 I::class)中。</p> 
 <p>¥ 我要打赏</p> 
 <p>纠错/补充</p> 
 <p>收藏</p> 
 <p>加QQ群啦，易百教程官方技术学习群</p> 
 <p>注意：建议每个人选自己的技术方向加群，同一个QQ最多限加 3 个群。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d10ee56e7953ed6541af11825ab180a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">服务器的socket编程UDP协议,C#编程 socket编程之udp服务器端和客户端-.net</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f4092570362f9c281af8da4b71d057d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kotlin实现ajax,Kotlin 中调用 JavaScript</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>