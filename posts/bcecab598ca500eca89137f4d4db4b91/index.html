<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用户控件 UserControl类 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/bcecab598ca500eca89137f4d4db4b91/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="用户控件 UserControl类">
  <meta property="og:description" content="UserControl类时专门管理用户控件的类，是用户控件类的统称。用户控件就是扩展名为.ascx的Web窗体组件，与普通的服务器控件一样，其不具备单独运行的能力，必须依附于窗体页才能正常运行。通常用其来制作特殊服务器控件，或多个服务器控件的组合形式。
UserControl类以编程方式访问控件，并提供动态加载及调用等许多特性。用户控件在运行时，被编译为UserControl对象，并驻留在服务器内存中。
语法定义：
//namespace System.Web.UI
public class UserControl : TemplateControl, IAttributeAccessor, INamingContainer, IUserControlDesignerAccessor
UserControl类的构造函数：
public UserControl();
在运行时通常不适用new关键字创建UserControl对象，而是以动态加载.ascx文件的形式创建，其加载方法如下：
UserControl myUser = (UserControl)this.LoadControl(&#34;myDropDwon.ascx&#34;);
属性详解
UserControl类的属性用来在用户控件运行时获取上下文信息，下面列出这些属性及其说明
Application:Web请求的应用程序对象
Attributes:用户控件的所有属性
Cache:用户控件的缓存对象
CachePolity:用户控件的缓存参数集合
IsPostBack:是否是第一次加载用户控件
应用1：动态加载用户控件并获取其公共属性
本例主要说明动态加载用户控件，以及如何设置用户控件的公共属性。实例的用户控件是一个选择部门填充用户的复合控件，可以在项目中被多次调用。
在网站根目录下，添加一个用户控件，命名为“mydropdown.ascx”.
在用户控件内，添加两个DropDownList，属性设置如下：
&amp;lt;%@ Control Language=&#34;C#&#34; AutoEventWireup=&#34;true&#34; CodeFile=&#34;mydropdown.ascx.cs&#34; Inherits=&#34;mydropdown&#34; %&amp;gt; &amp;lt;asp:DropDownList ID=&#34;DropDownList1&#34; runat=&#34;server&#34; AutoPostBack=&#34;True&#34; OnSelectedIndexChanged=&#34;DropDownList1_SelectedIndexChanged1&#34;&amp;gt; &amp;lt;asp:ListItem Value=&#34;0&#34;&amp;gt;技术部&amp;lt;/asp:ListItem&amp;gt; &amp;lt;asp:ListItem Value=&#34;1&#34;&amp;gt;测试部&amp;lt;/asp:ListItem&amp;gt; &amp;lt;asp:ListItem Value=&#34;2&#34;&amp;gt;销售部&amp;lt;/asp:ListItem&amp;gt; &amp;lt;/asp:DropDownList&amp;gt; &amp;lt;asp:DropDownList ID=&#34;DropDownList2&#34; runat=&#34;server&#34;&amp;gt;&amp;lt;/asp:DropDownList&amp;gt; 为DropDownList1添加事件“SelectedIndexChanged”,代码如下：
protected void DropDownList1_SelectedIndexChanged1(object sender, EventArgs e) { DropDownList2.Items.Clear();//首先清空 switch (DropDownList1.SelectedValue) { case &#34;0&#34;: DropDownList2.Items.Add(&#34;刘一&#34;); DropDownList2.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2010-10-24T12:48:00+08:00">
    <meta property="article:modified_time" content="2010-10-24T12:48:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用户控件 UserControl类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>UserControl类时专门管理用户控件的类，是用户控件类的统称。用户控件就是扩展名为.ascx的Web窗体组件，与普通的服务器控件一样，其不具备单独运行的能力，必须依附于窗体页才能正常运行。通常用其来制作特殊服务器控件，或多个服务器控件的组合形式。</p> 
<p>UserControl类以编程方式访问控件，并提供动态加载及调用等许多特性。<span style="color:#ff0000">用户控件在运行时，被编译为UserControl对象，并驻留在服务器内存中。</span></p> 
<p><strong>语法定义：</strong></p> 
<p>//namespace System.Web.UI</p> 
<p>public class UserControl : TemplateControl, IAttributeAccessor, INamingContainer, IUserControlDesignerAccessor</p> 
<p> </p> 
<p><strong>UserControl类的构造函数：</strong></p> 
<p>public UserControl();</p> 
<p>在运行时通常不适用new关键字创建UserControl对象，而是以动态加载.ascx文件的形式创建，其加载方法如下：</p> 
<p>UserControl myUser = (UserControl)this.LoadControl("myDropDwon.ascx");</p> 
<p> </p> 
<p><strong>属性详解</strong></p> 
<p>UserControl类的属性用来在用户控件运行时获取上下文信息，下面列出这些属性及其说明</p> 
<p>Application:Web请求的应用程序对象</p> 
<p>Attributes:用户控件的所有属性</p> 
<p>Cache:用户控件的缓存对象</p> 
<p>CachePolity:用户控件的缓存参数集合</p> 
<p>IsPostBack:是否是第一次加载用户控件</p> 
<p> </p> 
<p><strong>应用1：动态加载用户控件并获取其公共属性</strong></p> 
<p>本例主要说明动态加载用户控件，以及如何设置用户控件的公共属性。实例的用户控件是一个选择部门填充用户的复合控件，可以在项目中被多次调用。</p> 
<p>在网站根目录下，添加一个用户控件，命名为“mydropdown.ascx”.</p> 
<p>在用户控件内，添加两个DropDownList，属性设置如下：</p> 
<pre><code class="language-csharp">&lt;%@ Control Language="C#" AutoEventWireup="true" CodeFile="mydropdown.ascx.cs" 
Inherits="mydropdown" %&gt;

&lt;asp:DropDownList ID="DropDownList1" runat="server" AutoPostBack="True" OnSelectedIndexChanged="DropDownList1_SelectedIndexChanged1"&gt;
    &lt;asp:ListItem Value="0"&gt;技术部&lt;/asp:ListItem&gt;
    &lt;asp:ListItem Value="1"&gt;测试部&lt;/asp:ListItem&gt;
    &lt;asp:ListItem Value="2"&gt;销售部&lt;/asp:ListItem&gt;
&lt;/asp:DropDownList&gt;
&lt;asp:DropDownList ID="DropDownList2" runat="server"&gt;&lt;/asp:DropDownList&gt;</code></pre> 
<p><br> 为DropDownList1添加事件“SelectedIndexChanged”,代码如下：</p> 
<pre><code class="language-csharp">    protected void DropDownList1_SelectedIndexChanged1(object sender, EventArgs e)
    {
        DropDownList2.Items.Clear();//首先清空
        switch (DropDownList1.SelectedValue)
        {
            case "0":
                DropDownList2.Items.Add("刘一");
                DropDownList2.Items.Add("刘二");
                break;
            case "1":
                DropDownList2.Items.Add("王一");
                DropDownList2.Items.Add("王二");
                break;
            case "2":
                DropDownList2.Items.Add("张一");
                DropDownList2.Items.Add("张二");
                break;
        }
    }</code></pre> 
<p>添加用户控件的公共属性“SelectValue”，并在Page_Load事件中初始化其值，代码如下：</p> 
<pre><code class="language-csharp">    protected void Page_Load(object sender, EventArgs e)
    {
        SelectValue = DropDownList2.SelectedValue;
    }
    string _value;
    public string SelectValue
    {
        get { return _value; }
        set { _value = value; }
    }</code></pre> 
<p>打开Default.aspx页，添加一个Button按钮，设置其“Text”属性为“保存”。然后添加一个运行于服务器端的“div”元素，设置其“ID”属性为“Div1”.</p> 
<pre><code class="language-csharp">&lt;html xmlns="http://www.w3.org/1999/xhtml" &gt;
&lt;head runat="server"&gt;
    &lt;title&gt;无标题页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id="form1" runat="server"&gt;
    &lt;dir runat="server" id="div1"&gt;
    &lt;/dir&gt;
    &lt;div&gt;
        &lt;asp:Button ID="Button1" runat="server" OnClick="Button1_Click" Text="保存" /&gt;&lt;/div&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p> </p> 
<p>在当前页使用“Register”指令注册用户控件，代码如下：</p> 
<p>&lt;%@ Register Src="mydropdown.ascx" TagName="mydropdown" TagPrefix="uc1" %&gt;</p> 
<p>双击“保存”按钮，添加其Click事件的代码，如下：</p> 
<pre><code class="language-csharp">   protected void Button1_Click(object sender, EventArgs e)
    {
        mydropdown myuser = (mydropdown)div1.Controls[0].FindControl("user1");
            Response.Write(myuser.SelectValue);
    }</code></pre> 
<p>在Page_Load事件中添加动态加载用户控件的代码，如下所示：</p> 
<pre><code class="language-csharp">    protected void Page_Load(object sender, EventArgs e)
    {
        mydropdown myuser = (mydropdown)this.LoadControl("mydropdown.ascx");
        myuser.ID = "user1";
        div1.Controls.Add(myuser);//固定动态加载的用户控件的位置
    }</code></pre> 
<p><br> 输出结果：<br>  <img alt="" src="https://images2.imgbox.com/d6/de/aCtZPClc_o.gif"></p> 
<p><br>  用户控件事件的应用</p> 
<p>既然用户控件可以有自己的属性，那也一样可以有自己的事件。给自己的控件添加一个事件有的时候往往可以解决大难题，比如我们定义了一个用户控件，里面包含了一个GridView，如下图所示，记录的右边有一个“处理”按钮，这个记录都是待办记录，处理完后会变成已处理的记录，故此时GridView的数据要重新绑定。重新绑定之后，我们希望寄存页面的TreeView控件的数据也跟着回调刷新。解决这个问题最好的办法是在用户控件中添加事件，此事件负责（触发）TreeView控件数据的刷新。</p> 
<p> <img alt="" src="https://images2.imgbox.com/25/15/HR1zaBix_o.jpg"></p> 
<pre><code class="language-csharp">public partial class Task_Controls_uTodoTaskList : ListUC
{
    public event ReLoadEventHandler ReLoadTreeViewData; //定义一个事件

    protected void lbtnHandle_Click(object sender, EventArgs e)  // Add by 梁宗桥
    {
        //进行回调绑定。
        this.DataBind();
        if (ReLoadTreeViewData != null)
        {
            this.ReLoadTreeViewData();
        }
    }
}
</code></pre> 
<p>在MyTask.aspx页面的Page_Load页面中，注册一个“待办任务列表控件 刷新TreeView”的事件，注册之后，此事件什么时候执行完全取决于UTodoTaskList用户控件的需要。此过程是由内到外的调用（回调），即是用户控件调用MyTask.aspx中的事件处理程序BindTaskTreeData.</p> 
<pre><code class="language-csharp">UTodoTaskList.ReLoadTreeViewData += new ReLoadEventHandler(BindTaskTreeData); </code></pre> 
<p> </p> 
<pre><code class="language-csharp">    public void BindTaskTreeData()
    {
 
        if (Type.ToLower().Equals("all"))
        {
            UTaskTree.SetNodeText("todocheck", GetTasksConnt("todocheck", UserLoginer.LoginUser.ID) + Management.GetApprovalCount("todocheck", UserLoginer.LoginUser.EmplCode) + getYYZXTodoTaskCount(UserLoginer.LoginUser.EmplCode, "todocheck"));
            UTaskTree.SetNodeText("allowcancel", GetTasksConnt("allowcancel", UserLoginer.LoginUser.ID) + Management.GetApprovalCount("allowcancel", UserLoginer.LoginUser.EmplCode) + getYYZXTodoTaskCount(UserLoginer.LoginUser.EmplCode, "allowcancel"));
            UTaskTree.SetNodeText("checked", GetTasksConnt("checked", UserLoginer.LoginUser.ID) + Management.GetApprovalCount("checked", UserLoginer.LoginUser.EmplCode) + getYYZXTodoTaskCount(UserLoginer.LoginUser.EmplCode, "checked"));
        }
        else
        {
            UTaskTree.SetNodeText("todocheck", GetTasksConnt("todocheck", UserLoginer.LoginUser.ID) + getYYZXTodoTaskCount(UserLoginer.LoginUser.EmplCode, "todocheck"));
            UTaskTree.SetNodeText("allowcancel", GetTasksConnt("allowcancel", UserLoginer.LoginUser.ID) + getYYZXTodoTaskCount(UserLoginer.LoginUser.EmplCode, "allowcancel"));
            UTaskTree.SetNodeText("checked", GetTasksConnt("checked", UserLoginer.LoginUser.ID) + getYYZXTodoTaskCount(UserLoginer.LoginUser.EmplCode, "checked"));
        }

        UTaskTree.SetNodeText("todotask", Management.GetTodoTaskCount("todotask", string.Empty, UserLoginer.LoginUser.ID));
        UTaskTree.SetNodeText("overdue", Management.GetTodoTaskCount("overdue", string.Empty, UserLoginer.LoginUser.ID));
        UTaskTree.SetNodeText("completedtask", Management.GetCompletedTaskCount(string.Empty, UserLoginer.LoginUser.ID));

    }</code></pre> 
<p><br> 意义：在用户控件中定义了事件，就间接实现对寄存页面各块功能的控制，基本可以说是指哪打哪（有需要可以定义各种事件）。</p> 
<p><br> </p> 
<p>工作流用户控件对事件的使用体现就更加淋漓尽致了。</p> 
<p></p> 
<pre><code class="language-csharp"> WFButtons1.AfterCall += new WorkFlow_Control_WFButtons.AfterCallEventHandler(WFButtons1_AfterCall);</code></pre> 
<br> 
<br> 
<br>   
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b00bc4da6d8f9e9bdbb0882792bfdbf2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">有关Segment fault的总结(转自海斌)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a3f3bb86727d7666ddad9e0a90fd1ac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">业务层和持久层单元测试的实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>