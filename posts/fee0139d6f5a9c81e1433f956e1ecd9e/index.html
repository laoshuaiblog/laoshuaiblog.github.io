<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解java反射机制 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/fee0139d6f5a9c81e1433f956e1ecd9e/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="深入理解java反射机制">
  <meta property="og:description" content="一，java的核心机制 java有两种核心机制:java虚拟机(JavaVirtual Machine)与垃圾收集机制(Garbage collection)：
Java虚拟机：是运行所有Java程序的抽象计算机，是Java语言的运行环境，在其上面运行Java代码编译后的字节码程序，java虚拟机实现了平台无关性。 Java垃圾回收（Garbage Collection）：自动释放不用对象内存空间，在java程序运行过程中自动进行，垃圾收集机制可大大缩短编程时间，保护程序的完整性，是Java语言安全性策略的一个重要部份。 二，java虚拟机及其结构 java垃圾回收不需要程序员手动操作，我们经常需要关注的是java虚拟机，java虚拟机承载着程序从源码到运行的全部工作。 Java虚拟机是可运行Java代码的假想计算机，有自己想象中的硬件，如处理器、堆栈、寄存器等，还具有相应的指令系统，可以执行 Java 的字节码程序。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 对于 JVM 的基本结构，我们可以从下图可以大致了解： 图片来自Java 虚拟机体系结构
三，程序的运行过程 从源文件创建到程序运行，Java程序要经过两大步骤：编译，运行；1、源文件由编译器编译成字节码（ByteCode） 2、字节码由java虚拟机解释运行。
第一步(编译): 创建完源文件之后，程序会被编译器编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用。。编译后的字节码文件格式主要分为两部分：常量池和方法字节码。 第二步（运行）：java类运行的过程大概可分为两个过程：1、类的加载 2、执行。 四，类的加载 类加载过程 java程序经过编译后形成*.class文件。通过类加载器将字节码(*.class)加载入JVM的内存中。JVM将类加载过程分成加载，连接，初始化三个阶段，其中连接阶段又可分为验证，准备，解析三个阶段。 JVM 的类加载是通过 ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：
1）Bootstrap ClassLoader启动类加载器
负责加载$JAVA_HOME中jre/lib/里所有的 class(JDK 代表 JDK 的安装目录，下同)，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的java.*开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器由 C&#43;&#43; 实现，不是 ClassLoader 子类。无法被 Java 程序直接引用的。
2）Extension ClassLoader扩展类加载器
该加载器由sun.misc.Launcher ExtClassLoader实现，负责加载Java平台中扩展功能的一些jar包，包括 JAVA_HOME中jre/lib/.jar或-Djava.ext.dirs指定目录下的 jar 包。即JDK\jre\lib\ext目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器
3）App ClassLoader应用程序类加载器
。该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，负责记载 classpath 中指定的 jar 包及目录中 class，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
启动类加载器：它使用 C&#43;&#43; 实现（这里仅限于 Hotspot，也就是 JDK1.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-07-24T02:32:36+08:00">
    <meta property="article:modified_time" content="2016-07-24T02:32:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解java反射机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="一java的核心机制">一，java的核心机制</h2> 
<p>java有两种核心机制:java虚拟机(JavaVirtual Machine)与垃圾收集机制(Garbage collection)：</p> 
<pre><code>    Java虚拟机：是运行所有Java程序的抽象计算机，是Java语言的运行环境，在其上面运行Java代码编译后的字节码程序，java虚拟机实现了平台无关性。

    Java垃圾回收（Garbage Collection）：自动释放不用对象内存空间，在java程序运行过程中自动进行，垃圾收集机制可大大缩短编程时间，保护程序的完整性，是Java语言安全性策略的一个重要部份。
</code></pre> 
<h2 id="二java虚拟机及其结构">二，java虚拟机及其结构</h2> 
<p>java垃圾回收不需要程序员手动操作，我们经常需要关注的是java虚拟机，java虚拟机承载着程序从源码到运行的全部工作。 <br> Java虚拟机是可运行Java代码的假想计算机，有自己想象中的硬件，如处理器、堆栈、寄存器等，还具有相应的指令系统，可以执行 Java 的字节码程序。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 <br> 对于 JVM 的基本结构，我们可以从下图可以大致了解： <br> <img src="https://images2.imgbox.com/e1/1e/iFnQcDLX_o.jpg" alt="这里写图片描述" title=""></p> 
<blockquote> 
 <p>图片来自<a href="http://hxraid.iteye.com/blog/676235" rel="nofollow">Java 虚拟机体系结构</a></p> 
</blockquote> 
<h2 id="三程序的运行过程">三，程序的运行过程</h2> 
<p>从源文件创建到程序运行，Java程序要经过两大步骤：编译，运行；1、源文件由编译器编译成字节码（ByteCode） 2、字节码由java虚拟机解释运行。</p> 
<pre><code>    第一步(编译): 创建完源文件之后，程序会被编译器编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用。。编译后的字节码文件格式主要分为两部分：常量池和方法字节码。

    第二步（运行）：java类运行的过程大概可分为两个过程：1、类的加载  2、执行。
</code></pre> 
<h2 id="四类的加载">四，类的加载</h2> 
<h3 id="类加载过程">类加载过程</h3> 
<pre><code>   java程序经过编译后形成*.class文件。通过类加载器将字节码(*.class)加载入JVM的内存中。JVM将类加载过程分成加载，连接，初始化三个阶段，其中连接阶段又可分为验证，准备，解析三个阶段。
</code></pre> 
<p>JVM 的类加载是通过 ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</p> 
<p><img src="https://images2.imgbox.com/01/78/SIOfGDkr_o.png" alt="这里写图片描述" title=""> <br> 1）Bootstrap ClassLoader启动类加载器</p> 
<p>负责加载$JAVA_HOME中jre/lib/里所有的 class(JDK 代表 JDK 的安装目录，下同)，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的java.*开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器由 C++ 实现，不是 ClassLoader 子类。无法被 Java 程序直接引用的。</p> 
<p>2）Extension ClassLoader扩展类加载器</p> 
<p>该加载器由sun.misc.Launcher<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame"> 
   
   <span class="math" id="MathJax-Span-1" style="width: 34.095em; display: inline-block;"><span style="display: inline-block; position: relative; width: 27.699em; height: 0px; font-size: 123%;"><span style="position: absolute; clip: rect(1.304em 1000em 2.659em -0.431em); top: -2.274em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">E<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">x</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math-italic;">t</span><span class="mi" id="MathJax-Span-6" style="font-family: MathJax_Math-italic;">C<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.057em;"></span></span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math-italic;">l</span><span class="mi" id="MathJax-Span-8" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-9" style="font-family: MathJax_Math-italic;">s</span><span class="mi" id="MathJax-Span-10" style="font-family: MathJax_Math-italic;">s</span><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math-italic;">L</span><span class="mi" id="MathJax-Span-12" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-14" style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-16" style="font-family: MathJax_Math-italic;">r</span><span class="texatom" id="MathJax-Span-17"><span class="mrow" id="MathJax-Span-18"><span class="mo" id="MathJax-Span-19"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">实</span></span></span></span><span class="texatom" id="MathJax-Span-20"><span class="mrow" id="MathJax-Span-21"><span class="mo" id="MathJax-Span-22"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">现</span></span></span></span><span class="texatom" id="MathJax-Span-23"><span class="mrow" id="MathJax-Span-24"><span class="mo" id="MathJax-Span-25"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">，</span></span></span></span><span class="texatom" id="MathJax-Span-26"><span class="mrow" id="MathJax-Span-27"><span class="mo" id="MathJax-Span-28"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">负</span></span></span></span><span class="texatom" id="MathJax-Span-29"><span class="mrow" id="MathJax-Span-30"><span class="mo" id="MathJax-Span-31"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">责</span></span></span></span><span class="texatom" id="MathJax-Span-32"><span class="mrow" id="MathJax-Span-33"><span class="mo" id="MathJax-Span-34"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">加</span></span></span></span><span class="texatom" id="MathJax-Span-35"><span class="mrow" id="MathJax-Span-36"><span class="mo" id="MathJax-Span-37"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">载</span></span></span></span><span class="mi" id="MathJax-Span-38" style="font-family: MathJax_Math-italic;">J<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.057em;"></span></span><span class="mi" id="MathJax-Span-39" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-40" style="font-family: MathJax_Math-italic;">v</span><span class="mi" id="MathJax-Span-41" style="font-family: MathJax_Math-italic;">a</span><span class="texatom" id="MathJax-Span-42"><span class="mrow" id="MathJax-Span-43"><span class="mo" id="MathJax-Span-44"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">平</span></span></span></span><span class="texatom" id="MathJax-Span-45"><span class="mrow" id="MathJax-Span-46"><span class="mo" id="MathJax-Span-47"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">台</span></span></span></span><span class="texatom" id="MathJax-Span-48"><span class="mrow" id="MathJax-Span-49"><span class="mo" id="MathJax-Span-50"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">中</span></span></span></span><span class="texatom" id="MathJax-Span-51"><span class="mrow" id="MathJax-Span-52"><span class="mo" id="MathJax-Span-53"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">扩</span></span></span></span><span class="texatom" id="MathJax-Span-54"><span class="mrow" id="MathJax-Span-55"><span class="mo" id="MathJax-Span-56"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">展</span></span></span></span><span class="texatom" id="MathJax-Span-57"><span class="mrow" id="MathJax-Span-58"><span class="mo" id="MathJax-Span-59"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">功</span></span></span></span><span class="texatom" id="MathJax-Span-60"><span class="mrow" id="MathJax-Span-61"><span class="mo" id="MathJax-Span-62"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">能</span></span></span></span><span class="texatom" id="MathJax-Span-63"><span class="mrow" id="MathJax-Span-64"><span class="mo" id="MathJax-Span-65"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">的</span></span></span></span><span class="texatom" id="MathJax-Span-66"><span class="mrow" id="MathJax-Span-67"><span class="mo" id="MathJax-Span-68"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">一</span></span></span></span><span class="texatom" id="MathJax-Span-69"><span class="mrow" id="MathJax-Span-70"><span class="mo" id="MathJax-Span-71"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">些</span></span></span></span><span class="mi" id="MathJax-Span-72" style="font-family: MathJax_Math-italic;">j</span><span class="mi" id="MathJax-Span-73" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-74" style="font-family: MathJax_Math-italic;">r</span><span class="texatom" id="MathJax-Span-75"><span class="mrow" id="MathJax-Span-76"><span class="mo" id="MathJax-Span-77"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">包</span></span></span></span><span class="texatom" id="MathJax-Span-78"><span class="mrow" id="MathJax-Span-79"><span class="mo" id="MathJax-Span-80"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">，</span></span></span></span><span class="texatom" id="MathJax-Span-81"><span class="mrow" id="MathJax-Span-82"><span class="mo" id="MathJax-Span-83"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">包</span></span></span></span><span class="texatom" id="MathJax-Span-84"><span class="mrow" id="MathJax-Span-85"><span class="mo" id="MathJax-Span-86"><span style="font-family: STIXGeneral, 'Arial Unicode MS', serif; font-size: 81%; font-style: normal; font-weight: normal;">括</span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.33em;"></span></span> 
  </span><script type="math/tex" id="MathJax-Element-1">ExtClassLoader实现，负责加载Java平台中扩展功能的一些 jar 包，包括</script>JAVA_HOME中jre/lib/<em>.jar或-Djava.ext.dirs指定目录下的 jar 包。即JDK\jre\lib\ext目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如javax.</em>开头的类），开发者可以直接使用扩展类加载器</p> 
<p>3）App ClassLoader应用程序类加载器</p> 
<p>。该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，负责记载 classpath 中指定的 jar 包及目录中 class，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p> 
<p>启动类加载器：它使用 C++ 实现（这里仅限于 Hotspot，也就是 JDK1.5 之后默认的虚拟机，有很多其他的虚拟机是用 Java 语言实现的），是虚拟机自身的一部分。 <br> 所有其他的类加载器：这些类加载器都由 Java 语言实现，独立于虚拟机之外，并且全部继承自抽象类 java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 <br> 应用程序都是由这三种类加载器互相配合进行加载的，我们还可以加入自定义的类加载器。</p> 
<h4 id="加载">加载</h4> 
<p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p> 
<pre><code>通过一个类的全限定名来获取其定义的二进制字节流。
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。
</code></pre> 
<p>注意，这里第 1 条中的二进制字节流并不只是单纯地从 Class 文件中获取，比如它还可以从 Jar 包中获取、从网络中获取（最典型的应用便是 Applet）、由其他文件生成（JSP 应用）等。</p> 
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p> 
<pre><code>   JVM主要在程序第一次主动使用类的时候，才会去加载该类。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到用的时候才把它加载进来，而且只加载一次。
</code></pre> 
<p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从 Custom ClassLoader 到 BootStrap ClassLoader 逐层检查，只要某个 Classloader 已加载就视为已加载此类，保证此类只所有 ClassLoade r加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 <br> 这几种类加载器的层次关系如下图所示：</p> 
<p><img src="https://images2.imgbox.com/ee/79/AGvvHL6r_o.png" alt="这里写图片描述" title=""></p> 
<p>这种层次关系称为类加载器的双亲委派模型。双亲委派模型的工作流程是：</p> 
<pre><code>   如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。
</code></pre> 
<h4 id="验证">验证</h4> 
<p>验证的目的是为了确保 Class 文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p> 
<h4 id="准备">准备</h4> 
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p> 
<pre><code>   这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。

   这里所设置的初始值通常情况下是数据类型默认的零值（如 0、0L、null、false 等），而不是被在 Java 代码中被显式地赋予的值。
</code></pre> 
<h4 id="解析">解析</h4> 
<p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。</p> 
<p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info 四种常量类型。</p> 
<pre><code>    1、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。

    2、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束
</code></pre> 
<h4 id="初始化">初始化</h4> 
<p>类初始化是类加载过程的最后一个阶段，到初始化阶段，才真正开始执行类中的 Java 程序代码。虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：</p> 
<pre><code>   遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的 Java 代码场景是：使用 new 关键字实例化对象时、读取或设置一个类的静态字段（static）时（被 static 修饰又被 final 修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。
   使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。
   当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
   当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。
</code></pre> 
<p>虚拟机规定只有这四种情况才会触发类的初始化，称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化，称为被动引用。</p> 
<blockquote> 
 <p>本大段参考引用及图片来自<a href="http://wiki.jikexueyuan.com/project/java-vm/" rel="nofollow">深入理解 Java 虚拟机 </a></p> 
</blockquote> 
<h2 id="五静态加载和动态加载">五，静态加载和动态加载</h2> 
<pre><code>Java初始化一个类的时候可以用new 操作符来初始化,也可通过Class.forName的方式来得到一个Class类型的实例,然后通过这个Class类型的实例的newInstance来初始化.我们把前者叫做JAVA的静态加载,把后者叫做动态加载.。
</code></pre> 
<p>有时候我们说某个语言具有很强的动态性，有时候我们会区分动态和静态的不同技术与作法。我们朗朗上口动态绑定（dynamic binding）、动态链接（dynamic linking）、动态加载（dynamic loading）等。然而“动态”一词其实没有绝对而普遍适用的严格定义，有时候甚至像面向对象当初被导入编程领域一样，一人一把号，各吹各的调。 <br> 一般而言，开发者社群说到动态语言，大致认同的一个定义是：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。 <br> 尽管在这样的定义与分类下Java不是动态语言，它却有着一个非常突出的动态相关机制：Reflection。Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。</p> 
<pre><code>    静态加载的时候如果在运行环境中找不到要初始化的类,抛出的是NoClassDefFoundError,它在JAVA的异常体系中是一个Error.

    动态态加载的时候如果在运行环境中找不到要初始化的类,抛出的是ClassNotFoundException,它在JAVA的异常体系中是一个checked异常,在写代码的时候就需要catch.
</code></pre> 
<h2 id="六反射">六，反射</h2> 
<p>JAVA反射机制：</p> 
<pre><code>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
</code></pre> 
<p>Java反射机制主要提供了以下功能：</p> 
<pre><code>在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。
</code></pre> 
<p>Java有个Object 类，是所有Java 类的继承根源，其内声明了数个应该在所有Java 类中被改写的方法：hashCode()、equals()、clone()、toString()、getClass()等。其中getClass()返回一个Class 对象。</p> 
<pre><code>   Class 类十分特殊。它和一般类一样继承自Object，其实体用以表达Java程序运行时的classes和interfaces，也用来表达enum、array、primitive Java types（boolean, byte, char, short, int, long, float, double）以及关键词void。当一个class被加载，或当加载器（class loader）的defineClass()被JVM调用，JVM 便自动产生一个Class 对象。
</code></pre> 
<p>如果您想借由“修改Java标准库源码”来观察Class 对象的实际生成时机（例如在Class的constructor内添加一个println()），这样是行不通的！因为Class并没有public constructor。</p> 
<p>Class是Reflection故事起源。针对任何您想探勘的类，唯有先为它产生一个Class 对象，接下来才能经由后者唤起为数十多个的Reflection APIs。Reflection机制允许程序在正在执行的过程中，利用Reflection APIs取得任何已知名称的类的内部信息，包括：package、 type parameters、 superclass、 implemented interfaces、 inner classes、 outer classes、 fields、 constructors、 methods、 modifiers等，并可以在执行的过程中，动态生成instances、变更fields内容或唤起methods。</p> 
<blockquote> 
 <p>本段来自于百度百科 JAVA反射机制</p> 
</blockquote> 
<p>从Class中获取信息</p> 
<p>Class类提供了大量的实例方法来获取该Class对象所对应的详细信息,Class类大致包含如下方法,其中每个方法都包含多个重载版本,因此我们只是做简单的介绍,详细请参考JDK文档</p> 
<p>获取类内信息</p> 
<pre class="prettyprint"><code class=" hljs delphi">获取内容    方法签名
构造器 <span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">getConstructor</span><span class="hljs-params">(<span class="hljs-keyword">Class</span>&lt;?&gt;... parameterTypes)</span>
包含的方法   <span class="hljs-title">Method</span> <span class="hljs-title">getMethod</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name, <span class="hljs-keyword">Class</span>&lt;?&gt;... parameterTypes)</span>
包含的属性   <span class="hljs-title">Field</span> <span class="hljs-title">getField</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name)</span>
包含的<span class="hljs-title">Annotation</span>   &lt;<span class="hljs-title">A</span> <span class="hljs-title">extends</span> <span class="hljs-title">Annotation</span>&gt; <span class="hljs-title">A</span> <span class="hljs-title">getAnnotation</span><span class="hljs-params">(<span class="hljs-keyword">Class</span>&lt;A&gt; annotationClass)</span>
内部类 <span class="hljs-title">Class</span>&lt;?&gt;[] <span class="hljs-title">getDeclaredClasses</span><span class="hljs-params">()</span>
外部类 <span class="hljs-title">Class</span>&lt;?&gt; <span class="hljs-title">getDeclaringClass</span><span class="hljs-params">()</span>
所实现的接口  <span class="hljs-title">Class</span>&lt;?&gt;[] <span class="hljs-title">getInterfaces</span><span class="hljs-params">()</span>
修饰符 <span class="hljs-title">int</span> <span class="hljs-title">getModifiers</span><span class="hljs-params">()</span>
所在包 <span class="hljs-title">Package</span> <span class="hljs-title">getPackage</span><span class="hljs-params">()</span>
类名  <span class="hljs-title">String</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span>
简称  <span class="hljs-title">String</span> <span class="hljs-title">getSimpleName</span><span class="hljs-params">()</span></span></code></pre> 
<p>一些判断类本身信息的方法</p> 
<pre class="prettyprint"><code class=" hljs xml">判断内容    方法签名
注解类型?   boolean isAnnotation()
使用了该Annotation修饰?   boolean isAnnotationPresent(Class<span class="php"><span class="hljs-class">&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Annotation</span>&gt; <span class="hljs-title">annotationClass</span>)
匿名类?    <span class="hljs-title">boolean</span> <span class="hljs-title">isAnonymousClass</span>()
数组? <span class="hljs-title">boolean</span> <span class="hljs-title">isArray</span>()
枚举? <span class="hljs-title">boolean</span> <span class="hljs-title">isEnum</span>()
原始类型?   <span class="hljs-title">boolean</span> <span class="hljs-title">isPrimitive</span>()
接口? <span class="hljs-title">boolean</span> <span class="hljs-title">isInterface</span>()
<span class="hljs-title">obj</span>是否是该<span class="hljs-title">Class</span>的实例 <span class="hljs-title">boolean</span> <span class="hljs-title">isInstance</span>(<span class="hljs-title">Object</span> <span class="hljs-title">obj</span>)</span></span></code></pre> 
<blockquote> 
 <p>参考 <a href="http://blog.csdn.net/zjf280441589/article/details/50453776">Java 反射 </a></p> 
</blockquote> 
<p>1，获取class <br> <img src="https://images2.imgbox.com/3f/dc/07fd1rxO_o.jpg" alt="这里写图片描述" title=""></p> 
<blockquote> 
 <p>这张图忘记从哪保存的了</p> 
</blockquote> 
<p>主有三种获得class的途径，使用时要注意区别</p> 
<pre><code> a,类型.class  如： String.class使用类名加“.class”的方式即会返回与该类对应的Class对象。这个方法可以直接获得与指定类关联的Class对象，而并不需要有该类的对象存在。
 b,Class.forName("类名");该方法可以根据字符串参数所指定的类名获取与该类关联的Class对象。如果该类还没有被装入，该方法会将该类装入JVM。forName方法的参数是类的完 整限定名（即包含包名）。通常用于在程序运行时根据类名动态的载入该类并获得与之对应的Class对象。
 c, obj.getClass();所有Java对象都具备这个方法，该方法用于返回调用该方法的对象的所属类关联的Class对象
</code></pre> 
<p>2、获取构造方法</p> 
<p>Class类提供了四个public方法，用于获取某个类的构造方法：</p> 
<pre class="prettyprint"><code class=" hljs oxygene"><span class="hljs-function"><span class="hljs-keyword">Constructor</span> <span class="hljs-title">getConstructor</span><span class="hljs-params">(<span class="hljs-keyword">Class</span>[] <span class="hljs-keyword">params</span>)</span>根据构造函数的参数，返回一个具体的具有<span class="hljs-title">public</span>属性的构造函数

<span class="hljs-title">Constructor</span> <span class="hljs-title">getConstructors</span><span class="hljs-params">()</span>     返回所有具有<span class="hljs-title">public</span>属性的构造函数数组

<span class="hljs-title">Constructor</span> <span class="hljs-title">getDeclaredConstructor</span><span class="hljs-params">(<span class="hljs-keyword">Class</span>[] <span class="hljs-keyword">params</span>)</span>     根据构造函数的参数，返回一个具体的构造函数（不分<span class="hljs-title">public</span>和非<span class="hljs-title">public</span>属性）

<span class="hljs-title">Constructor</span> <span class="hljs-title">getDeclaredConstructors</span><span class="hljs-params">()</span>    返回该类中所有的构造函数数组（不分<span class="hljs-title">public</span>和非<span class="hljs-title">public</span>属性）</span></code></pre> 
<pre class="prettyprint"><code class=" hljs avrasm">
* <span class="hljs-number">1</span> 反射出无参的构造方法并得到对象
　　* 注意:
　　* <span class="hljs-number">1</span> 在Class<span class="hljs-preprocessor">.forName</span>()中应该传入含有包名的类全名
　　* <span class="hljs-number">2</span> newInstance()方法的本质是调用类的无参Public构造方法
　　*/
　　String className1=<span class="hljs-string">"cn.testreflect.Worker"</span><span class="hljs-comment">;</span>
　　Class clazz1=Class<span class="hljs-preprocessor">.forName</span>(className1)<span class="hljs-comment">;</span>
　　Object object1=clazz1<span class="hljs-preprocessor">.newInstance</span>()<span class="hljs-comment">;</span>
　　System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"object1.toString()="</span>+object1<span class="hljs-preprocessor">.toString</span>())<span class="hljs-comment">;</span>
　　<span class="hljs-comment">/**
　　* 2 反射出带参数的构造方法并得到对象
　　*/</span>
　　String className2=<span class="hljs-string">"cn.testreflect.Worker"</span><span class="hljs-comment">;</span>
　　Class clazz2=Class<span class="hljs-preprocessor">.forName</span>(className2)<span class="hljs-comment">;</span>
　　Constructor constructor1=clazz2<span class="hljs-preprocessor">.getConstructor</span>(int<span class="hljs-preprocessor">.class</span>,String<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>
　　Object object2=constructor1<span class="hljs-preprocessor">.newInstance</span>(<span class="hljs-number">18</span>,<span class="hljs-string">"小明"</span>)<span class="hljs-comment">;</span>
　　System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"object2.toString()="</span>+object2<span class="hljs-preprocessor">.toString</span>())<span class="hljs-comment">;</span></code></pre> 
<p>3、获取类的成员方法</p> 
<p>与获取构造方法的方式相同，存在四种获取成员方法的方式。　</p> 
<pre class="prettyprint"><code class=" hljs oxygene"><span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">getMethod</span><span class="hljs-params">(String name, <span class="hljs-keyword">Class</span>[] <span class="hljs-keyword">params</span>)</span> 根据方法名和参数，返回一个具体的具有<span class="hljs-title">public</span>属性的方法

<span class="hljs-title">Method</span>[] <span class="hljs-title">getMethods</span><span class="hljs-params">()</span> 返回所有具有<span class="hljs-title">public</span>属性的方法数组

<span class="hljs-title">Method</span> <span class="hljs-title">getDeclaredMethod</span><span class="hljs-params">(String name, <span class="hljs-keyword">Class</span>[] <span class="hljs-keyword">params</span>)</span>  根据方法名和参数，返回一个具体的方法（不分<span class="hljs-title">public</span>和非<span class="hljs-title">public</span>属性）

<span class="hljs-title">Method</span>[] <span class="hljs-title">getDeclaredMethods</span><span class="hljs-params">()</span> 返回该类中的所有的方法数组（不分<span class="hljs-title">public</span>和非<span class="hljs-title">public</span>属性）</span></code></pre> 
<pre class="prettyprint"><code class=" hljs avrasm"> * 调用对象的带参数的方法
　　*/
　　String className5=<span class="hljs-string">"cn.testreflect.Worker"</span><span class="hljs-comment">;</span>
　　Class clazz5=Class<span class="hljs-preprocessor">.forName</span>(className5)<span class="hljs-comment">;</span>
　　Method method=clazz5<span class="hljs-preprocessor">.getMethod</span>(<span class="hljs-string">"printMessage"</span>, 
String<span class="hljs-preprocessor">.class</span>,int<span class="hljs-preprocessor">.class</span>,int<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>
　　Object object5=clazz5<span class="hljs-preprocessor">.newInstance</span>()<span class="hljs-comment">;</span>
　　method<span class="hljs-preprocessor">.invoke</span>(object5, <span class="hljs-string">"周星星"</span>,<span class="hljs-number">50</span>,<span class="hljs-number">9527</span>)<span class="hljs-comment">;</span>
　　} catch (Exception e) {
　　System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(e<span class="hljs-preprocessor">.toString</span>())<span class="hljs-comment">;</span>
　　}</code></pre> 
<p>4、获取类的成员变量（成员属性）</p> 
<p>存在四种获取成员属性的方法</p> 
<pre class="prettyprint"><code class=" hljs cs">Field getField(String name)  根据变量名，返回一个具体的具有<span class="hljs-keyword">public</span>属性的成员变量

Field[] <span class="hljs-title">getFields</span>()  返回具有<span class="hljs-keyword">public</span>属性的成员变量的数组

Field <span class="hljs-title">getDeclaredField</span>(String name) 根据变量名，返回一个成员变量（不分<span class="hljs-keyword">public</span>和非<span class="hljs-keyword">public</span>属性）

Field[] <span class="hljs-title">getDelcaredFields</span>() 返回所有成员变量组成的数组（不分<span class="hljs-keyword">public</span>和非<span class="hljs-keyword">public</span>属性）</code></pre> 
<pre class="prettyprint"><code class=" hljs avrasm">* <span class="hljs-number">1</span> 获取类的私有字段
　　* 注意:
　　* 获取共有字段应调用clazz3<span class="hljs-preprocessor">.getField</span>(name)方法
　　*/
　　String className3=<span class="hljs-string">"cn.testreflect.Worker"</span><span class="hljs-comment">;</span>
　　Class clazz3=Class<span class="hljs-preprocessor">.forName</span>(className3)<span class="hljs-comment">;</span>
　　Field ageField1=clazz3<span class="hljs-preprocessor">.getDeclaredField</span>(<span class="hljs-string">"age"</span>)<span class="hljs-comment">;</span>
　　System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"ageField1="</span>+ageField1)<span class="hljs-comment">;</span>
　　<span class="hljs-comment">/**
　　* 2 获取和更改某个对象的私有字段
　　* 即模拟get()和set()方法
　　*/</span>
　　String className4=<span class="hljs-string">"cn.testreflect.Worker"</span><span class="hljs-comment">;</span>
　　Class clazz4=Class<span class="hljs-preprocessor">.forName</span>(className4)<span class="hljs-comment">;</span>
　　Field ageField2=clazz4<span class="hljs-preprocessor">.getDeclaredField</span>(<span class="hljs-string">"age"</span>)<span class="hljs-comment">;</span>
　　Object object4=constructor1<span class="hljs-preprocessor">.newInstance</span>(<span class="hljs-number">18</span>,<span class="hljs-string">"小明"</span>)<span class="hljs-comment">;</span>
　　//取消访问私有字段的合法性检查
　　ageField2<span class="hljs-preprocessor">.setAccessible</span>(true)<span class="hljs-comment">;</span>
　　//获取对象的私有字段
　　Object ageObject4=ageField2<span class="hljs-preprocessor">.get</span>(object4)<span class="hljs-comment">;</span>
　　System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"ageObject4="</span>+ageObject4)<span class="hljs-comment">;</span>
　　//再更改对象的私有字段的值
　　ageField2<span class="hljs-preprocessor">.set</span>(object4, <span class="hljs-number">9527</span>)<span class="hljs-comment">;</span>
　　//重新获得
　　Object ageObject5=ageField2<span class="hljs-preprocessor">.get</span>(object4)<span class="hljs-comment">;</span>
　　System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"ageObject5="</span>+ageObject5)<span class="hljs-comment">;</span></code></pre> 
<p>本文章还参考引用很多文章的精华，是我理解这么长时间理解和运用反射期间根据看到的博文和我的理解不断修改而来，可能还不尽完美，以后会持续删减和添加</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d8fbf369f7ec8989c756f3512e3e41a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js中return false,return,return true的用法及区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/35a804e8305505b47e31836b4b8ba8d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux下开启Hadoop的9000端口方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>