<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[数据结构初阶】栈 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/9b819c74827da45c1e5888634e6c79f2/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="[数据结构初阶】栈">
  <meta property="og:description" content="各位读者老爷好，鼠鼠我好久没写博客了（太摆烂了），今天就基于C语言浅介绍一下数据结构里面的栈，希望对你有所帮助吧。
目录
1.栈的概念及结构
2.栈的实现
2.1定义栈
2.2.初始化栈 2.3.入栈
2.4.出栈
2.5.获取栈顶元素
2.6.获取栈中有效元素个数
2.7.检查栈是否为空，如果为空返回真，如果不为空返回假
2.8.销毁栈 3.栈小应用
3.1.Stack.h
3.2.Stack.c 3.3.test.c 4.小知识
5.ending
1.栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入、删除和访问元素操作（ps：我们之前介绍的顺序表和链表都可以在任意位置插入、删除和访问）。进行数据插入、删除和访问操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
这里有几个概念需要理解，将栈比喻成手枪弹夹十分合适：
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶，弹夹出入弹口就像栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
后进先出的原则：栈中的数据元素的插入、删除和访问均要遵循这个原则。栈中的数据元素就像子弹，先进入弹夹的子弹会后射出，后进入弹夹的子弹会先射出，栈中数据元素在栈中的操作就像弹夹的子弹一般。
举个列子解释栈中元素遵守的后进先出原则如图：
2.栈的实现 栈的实现一般可以使用数组或者链表实现，实现出来的栈只要满足数据结构对栈的定义即可。相对而言数组的结构实现更优一些，因为数组在尾上插删数据的代价比较小。所以下面我们实现一下以数组尾部为栈顶的数组栈。
而定长的静态栈的结构，实际中一般不实用，所以我们主要实现下面的支持动态增长的栈。
我们栈主要实现以下功能：
typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }Stack; //初始化栈 void StackInit(Stack* ps); // 入栈 void StackPush(Stack* ps, STDataType data); // 出栈 void StackPop(Stack* ps); // 获取栈顶元素 STDataType StackTop(Stack* ps); // 获取栈中有效元素个数 int StackSize(Stack* ps); // 检测栈是否为空，如果为空返回真，如果不为空返回假 bool StackEmpty(Stack* ps); // 销毁栈 void StackDestroy(Stack* ps); 2.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-07T17:34:28+08:00">
    <meta property="article:modified_time" content="2024-03-07T17:34:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[数据结构初阶】栈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>各位读者老爷好，鼠鼠我好久没写博客了（太摆烂了），今天就基于C语言浅介绍一下数据结构里面的栈，希望对你有所帮助吧。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b9/96/bImyxSHh_o.jpg"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">1.栈的概念及结构</a></p> 
<p id="2.%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2.%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2.栈的实现</a></p> 
<p id="2.1%E5%AE%9A%E4%B9%89%E6%A0%88-toc" style="margin-left:80px;"><a href="#2.1%E5%AE%9A%E4%B9%89%E6%A0%88" rel="nofollow">2.1定义栈</a></p> 
<p id="2.2.%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88%C2%A0-toc" style="margin-left:80px;"><a href="#2.2.%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88%C2%A0" rel="nofollow">2.2.初始化栈 </a></p> 
<p id="2.3.%E5%85%A5%E6%A0%88-toc" style="margin-left:80px;"><a href="#2.3.%E5%85%A5%E6%A0%88" rel="nofollow">2.3.入栈</a></p> 
<p id="2.4.%E5%87%BA%E6%A0%88-toc" style="margin-left:80px;"><a href="#2.4.%E5%87%BA%E6%A0%88" rel="nofollow">2.4.出栈</a></p> 
<p id="2.5.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#2.5.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0" rel="nofollow">2.5.获取栈顶元素</a></p> 
<p id="2.6.%E8%8E%B7%E5%8F%96%E6%A0%88%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.6.%E8%8E%B7%E5%8F%96%E6%A0%88%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0" rel="nofollow">2.6.获取栈中有效元素个数</a></p> 
<p id="2.7.%E6%A3%80%E6%9F%A5%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E7%9C%9F%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E5%81%87-toc" style="margin-left:80px;"><a href="#2.7.%E6%A3%80%E6%9F%A5%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E7%9C%9F%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E5%81%87" rel="nofollow">2.7.检查栈是否为空，如果为空返回真，如果不为空返回假</a></p> 
<p id="2.8.%E9%94%80%E6%AF%81%E6%A0%88%C2%A0-toc" style="margin-left:80px;"><a href="#2.8.%E9%94%80%E6%AF%81%E6%A0%88%C2%A0" rel="nofollow">2.8.销毁栈 </a></p> 
<p id="3.%E6%A0%88%E5%B0%8F%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#3.%E6%A0%88%E5%B0%8F%E5%BA%94%E7%94%A8" rel="nofollow">3.栈小应用</a></p> 
<p id="3.1.Stack.h-toc" style="margin-left:80px;"><a href="#3.1.Stack.h" rel="nofollow">3.1.Stack.h</a></p> 
<p id="3.2.Stack.c%C2%A0-toc" style="margin-left:80px;"><a href="#3.2.Stack.c%C2%A0" rel="nofollow">3.2.Stack.c </a></p> 
<p id="3.3.test.c%C2%A0-toc" style="margin-left:80px;"><a href="#3.3.test.c%C2%A0" rel="nofollow">3.3.test.c </a></p> 
<p id="4.%E5%B0%8F%E7%9F%A5%E8%AF%86-toc" style="margin-left:40px;"><a href="#4.%E5%B0%8F%E7%9F%A5%E8%AF%86" rel="nofollow">4.小知识</a></p> 
<p id="5.ending-toc" style="margin-left:40px;"><a href="#5.ending" rel="nofollow">5.ending</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h3 id="1.%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">1.栈的概念及结构</h3> 
<p>栈：一种特殊的线性表，其只允许在固定的一端进行插入、删除和访问元素操作（ps：我们之前介绍的顺序表和链表都可以在任意位置插入、删除和访问）。进行数据插入、删除和访问操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。</p> 
<blockquote> 
 <p>这里有几个概念需要理解，将栈比喻成手枪弹夹十分合适：<br> 压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶，弹夹出入弹口就像栈顶。</p> 
 <p>出栈：栈的删除操作叫做出栈。出数据也在栈顶。</p> 
 <p>后进先出的原则：栈中的数据元素的插入、删除和访问均要遵循这个原则。栈中的数据元素就像子弹，先进入弹夹的子弹会后射出，后进入弹夹的子弹会先射出，栈中数据元素在栈中的操作就像弹夹的子弹一般。</p> 
</blockquote> 
<blockquote> 
 <p style="text-align:center;"><img alt="" class="left" height="443" src="https://images2.imgbox.com/d9/b2/A2MGVWKc_o.png" width="536">举个列子解释栈中元素遵守的后进先出原则如图：</p> 
</blockquote> 
<h3 id="2.%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0">2.栈的实现</h3> 
<p>栈的实现一般可以使用数组或者链表实现，实现出来的栈只要满足数据结构对栈的定义即可。相对而言数组的结构实现更优一些，因为数组在尾上插删数据的代价比较小。所以下面我们实现一下以数组尾部为栈顶的数组栈。</p> 
<p>而定长的静态栈的结构，实际中一般不实用，所以我们主要实现下面的支持动态增长的栈。</p> 
<p>我们栈主要实现以下功能：</p> 
<pre><code class="language-cs">typedef int STDataType;

typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}Stack;


//初始化栈
void StackInit(Stack* ps);

// 入栈 
void StackPush(Stack* ps, STDataType data);

// 出栈 
void StackPop(Stack* ps);

// 获取栈顶元素 
STDataType StackTop(Stack* ps);

// 获取栈中有效元素个数 
int StackSize(Stack* ps);

// 检测栈是否为空，如果为空返回真，如果不为空返回假 
bool StackEmpty(Stack* ps);

// 销毁栈 
void StackDestroy(Stack* ps);</code></pre> 
<h4 id="2.1%E5%AE%9A%E4%B9%89%E6%A0%88">2.1定义栈</h4> 
<pre><code class="language-cs">typedef int STDataType;

typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}Stack;</code></pre> 
<p>方便后续代码的维护，我们先不妨将int重命名成STDataType。由于实现动态生长的栈我们需要一个STDataType*类型指针a维护以后动态申请的空间（用来存放需存储的数据元素的）。用top指向栈顶元素的下一个元素（可以理解成元素个数）。用capacity记录以后动态图申请空间的大小。将a、top和capacity用结构体包起来并重命名成Stack。画下图方便理解：</p> 
<blockquote> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/2c/dd/KlfCOir1_o.png"></p> 
</blockquote> 
<h4 id="2.2.%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88%C2%A0">2.2.初始化栈 </h4> 
<pre><code class="language-cs">//初始化栈
void StackInit(Stack*ps)
{
	assert(ps);
	ps-&gt;a = NULL;
	ps-&gt;top = 0;
	ps-&gt;capacity = 0;
}</code></pre> 
<p>断言防止传入的Stack变量地址为空。不妨将a初始化为NULL，所以易知capacity初始化为0合适，由于将top设计成指向栈顶元素下一个元素（或者理解成元素个数） ，所以top也初始化为0。</p> 
<h4 id="2.3.%E5%85%A5%E6%A0%88" style="background-color:transparent;">2.3.入栈</h4> 
<pre><code class="language-cs">//入栈
void StackPush(Stack* ps, STDataType data)
{
	assert(ps);

	//扩容
	if (ps-&gt;top == ps-&gt;capacity)
	{
		int newcapacity = (ps-&gt;capacity == 0) ? 4 : (ps-&gt;capacity * 2);
		STDataType* tmp = realloc(ps-&gt;a, newcapacity * sizeof(STDataType));
		if (tmp == NULL)
		{
			perror("realloc fail:");
			return;
		}
		ps-&gt;capacity = newcapacity;
		ps-&gt;a = tmp;
	}

	ps-&gt;a[ps-&gt;top] = data;
	ps-&gt;top++;
}</code></pre> 
<p>断言防止传入的Stack变量地址为空（这点以下如有相同不再赘述）。 当top和capacity相等时说明动态申请的空间不足以支持元素入栈，使用扩容逻辑（扩容了记得更新capacity），将元素在数组尾部入栈，top加一即可。</p> 
<h4 id="2.4.%E5%87%BA%E6%A0%88">2.4.出栈</h4> 
<pre><code class="language-cs">//出栈
void StackPop(Stack* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	ps-&gt;top--;
}</code></pre> 
<p>断言防止栈为空的时候仍然出栈。元素在数组尾部出栈将top减一即可。 </p> 
<h4 id="2.5.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0">2.5.获取栈顶元素</h4> 
<pre><code class="language-cs">//获取栈顶元素
STDataType StackTop(Stack* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	return ps-&gt;a[ps-&gt;top - 1];
}</code></pre> 
<p>断言防止栈为空时获取栈顶元素（栈为空时获取的栈顶元素不是有效元素）。根据设定，易知top指向栈顶元素的下一个元素，所以ps-&gt;a[ps-&gt;top-1]就是栈顶元素。</p> 
<h4 id="2.6.%E8%8E%B7%E5%8F%96%E6%A0%88%E4%B8%AD%E6%9C%89%E6%95%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">2.6.获取栈中有效元素个数</h4> 
<pre><code class="language-cs">//获取栈中有效元素个数
int StackSize(Stack* ps)
{
	assert(ps);
	return ps-&gt;top;
}</code></pre> 
<p>根据设定，我们知道top的含义之一就是有效元素个数，所以返回ps-&gt;top即可。 </p> 
<h4 id="2.7.%E6%A3%80%E6%9F%A5%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E7%9C%9F%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%B8%BA%E7%A9%BA%E8%BF%94%E5%9B%9E%E5%81%87">2.7.检查栈是否为空，如果为空返回真，如果不为空返回假</h4> 
<pre><code class="language-cs">//检测栈是否为空，如果为空返回真，不为空返回假
bool StackEmpty(Stack* ps)
{
	assert(ps);
	return ps-&gt;top == 0;
}</code></pre> 
<p>实现这个功能的话返回ps-&gt;top==0能很好的形成逻辑自洽。当栈为空时，ps-&gt;top==0为真，返回真；当栈不为空时，ps-&gt;top==0为假，返回假。 </p> 
<h4 id="2.8.%E9%94%80%E6%AF%81%E6%A0%88%C2%A0">2.8.销毁栈 </h4> 
<pre><code class="language-cs">//销毁栈
void StackDestroy(Stack* ps)
{
	assert(ps);
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;top = ps-&gt;capacity = 0;
}</code></pre> 
<p>我们再回顾一下栈的想象图： </p> 
<blockquote> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/dd/32/ZOlPyGT1_o.png"></p> 
</blockquote> 
<p>对于栈的销毁来说，我们需要主动释放动态申请的内存，就是结构体Stack成员中指针a指向的空间（这块空间也是来存放需存放数据元素的）。所以free掉ps-&gt;a，再将ps-&gt;a置成NULL、将ps-&gt;top和ps-&gt;capacity置成0即可。</p> 
<h3 id="3.%E6%A0%88%E5%B0%8F%E5%BA%94%E7%94%A8">3.栈小应用</h3> 
<p>上面这么多代码说不定老爷们看到云里雾里，但是没关系，鼠鼠我写一个工程运用一下上面代码（该工程包含上面所有代码），有兴趣的老爷们可以将下面三个文件放到同一个工程下面玩玩，再参考上面鼠鼠的愚见所不定会明白点！</p> 
<h4 id="3.1.Stack.h">3.1.Stack.h</h4> 
<pre><code class="language-cs">#pragma once
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;stdlib.h&gt;


typedef int STDataType;

typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}Stack;


//初始化栈
void StackInit(Stack* ps);

// 入栈 
void StackPush(Stack* ps, STDataType data);

// 出栈 
void StackPop(Stack* ps);

// 获取栈顶元素 
STDataType StackTop(Stack* ps);

// 获取栈中有效元素个数 
int StackSize(Stack* ps);

// 检测栈是否为空，如果为空返回真，如果不为空返回假 
bool StackEmpty(Stack* ps);

// 销毁栈 
void StackDestroy(Stack* ps);</code></pre> 
<h4 id="3.2.Stack.c%C2%A0">3.2.Stack.c </h4> 
<pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS
#include"Stack.h"


//初始化栈
void StackInit(Stack*ps)
{
	assert(ps);
	ps-&gt;a = NULL;
	ps-&gt;top = 0;
	ps-&gt;capacity = 0;
}

//入栈
void StackPush(Stack* ps, STDataType data)
{
	assert(ps);

	//扩容
	if (ps-&gt;top == ps-&gt;capacity)
	{
		int newcapacity = (ps-&gt;capacity == 0) ? 4 : (ps-&gt;capacity * 2);
		STDataType* tmp = realloc(ps-&gt;a, newcapacity * sizeof(STDataType));
		if (tmp == NULL)
		{
			perror("realloc fail:");
			return;
		}
		ps-&gt;capacity = newcapacity;
		ps-&gt;a = tmp;
	}

	ps-&gt;a[ps-&gt;top] = data;
	ps-&gt;top++;
}

//出栈
void StackPop(Stack* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	ps-&gt;top--;
}

//获取栈顶元素
STDataType StackTop(Stack* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	return ps-&gt;a[ps-&gt;top - 1];
}

//获取栈中有效元素个数
int StackSize(Stack* ps)
{
	assert(ps);
	return ps-&gt;top;
}

//检测栈是否为空，如果为空返回真，不为空返回假
bool StackEmpty(Stack* ps)
{
	assert(ps);
	return ps-&gt;top == 0;
}

//销毁栈
void StackDestroy(Stack* ps)
{
	assert(ps);
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;top = ps-&gt;capacity = 0;
}</code></pre> 
<h4 id="3.3.test.c%C2%A0">3.3.test.c </h4> 
<pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS
#include"Stack.h"
int main()
{
	Stack s;
	StackInit(&amp;s);
	StackPush(&amp;s, 1);
	StackPush(&amp;s, 2);
	StackPush(&amp;s, 3);
	StackPush(&amp;s, 4);
	StackPush(&amp;s, 5);
	printf("%d\n", StackSize(&amp;s));
	StackPop(&amp;s);
	printf("%d\n", StackSize(&amp;s));
	StackPush(&amp;s, 6);
	while (!StackEmpty(&amp;s))
	{
		printf("%d ", StackTop(&amp;s));
		StackPop(&amp;s);
	}
	printf("\n");
	printf("%d", StackSize(&amp;s));
	StackDestroy(&amp;s);
	return 0;
}</code></pre> 
<blockquote> 
 <p style="text-align:center;"><img alt="" class="left" height="420" src="https://images2.imgbox.com/b7/bc/mZjpmbRq_o.png" width="399">运行结果如图可以看看： </p> 
</blockquote> 
<p> 刚开始栈顶入栈五个数据元素，所以第一个printf打印5；然后将数据元素5栈顶出栈，所以第二个printf打印4；再次入栈数据元素6，此时栈内数据元素从栈底到栈顶分别为：1、2、3、4、6。</p> 
<p>那我们如何打印栈内所有数据元素呢？</p> 
<p>其实写一个如图中的while循环即可，由于栈要严格按照它的规定去访问数据元素，所以访问的数据元素只能时栈顶的，想要访问栈顶数据元素的前一个数据元素就必须将栈顶数据元素出栈才能访问到栈顶数据元素前一个数据元素，所以访问一遍栈后栈也就空了。</p> 
<p>根据分析，while循环打印出来的应该是6 4 3 2 1。后面的printf打印为0也证明栈已经空了。</p> 
<h3 id="4.%E5%B0%8F%E7%9F%A5%E8%AF%86">4.小知识</h3> 
<p>应该有一些老爷们听说过"栈溢出"这个概念，但我们这篇博客介绍的栈不是"栈溢出"的那个栈。</p> 
<p>咱们这篇博客讲的栈是数据结构这门学科的概念，是一种数据结构，这个“栈”不存在“栈溢出”的概念。</p> 
<p>“栈溢出”讲的栈是操作系统或者编程语言这些学科的概念。我们知道内存会划分成各种区域，其中有一个区域为栈区，“栈溢出”这个栈就是一个内存区域。很多情况会导致栈溢出，比如一个递归程序，由于递归返回条件有问题，导致递归不断建立栈帧，使得栈区空间没了还在建立栈帧就导致“栈溢出”。</p> 
<h3 id="5.ending">5.ending</h3> 
<p>老弟我也是小白，如果有错误恳请各位大佬指正啊，感谢各位佬阅读到这里了！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dc6dfee8d71d04687ac91b752c68ac39/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【WEEK1】 【DAY2】 【DAY3】【DAY4】新建SpringMVC项目【中文版】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40c9c7067907cbdff28d88f067420ad1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenStack之Nova</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>