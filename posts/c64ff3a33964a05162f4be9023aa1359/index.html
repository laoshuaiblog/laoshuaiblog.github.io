<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java8的lambda中的map相关操作 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/c64ff3a33964a05162f4be9023aa1359/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="java8的lambda中的map相关操作">
  <meta property="og:description" content="0 入门详解篇 1 史上最简单入门：java8的lambda中的map相关操作:基础及注意事项图文详解
2 java8的lambda中collect接口案例及原理详解,官方文档解读
3 java8:封装lambda泛型工具类之list转为map
4 java8的lambda中的map操作：合并两个map
1 以下是正文 英文地址：https://www.baeldung.com/java-merge-maps
原文链接：https://blog.csdn.net/w605283073/article/details/82987157
1. 介绍
本入门教程将介绍Java8中如何合并两个map。如果想学习入门教程点击开篇0入门篇：lambda表达式:list转map
更具体说来，我们将研究不同的合并方案，包括Map含有重复元素的情况。
2. 初始化 我们定义两个map实例
private static Map&amp;lt;String, Employee&amp;gt; map1 = new HashMap&amp;lt;&amp;gt;(); private static Map&amp;lt;String, Employee&amp;gt; map2 = new HashMap&amp;lt;&amp;gt;(); Employee类
public class Employee { private Long id; private String name; // 此处省略构造方法, getters, setters方法 } 然后往map中存入一些数据
Employee employee1 = new Employee(1L, &#34;Henry&#34;); map1.put(employee1.getName(), employee1); Employee employee2 = new Employee(22L, &#34;Annie&#34;); map1.put(employee2.getName(), employee2); Employee employee3 = new Employee(8L, &#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2018-11-19T23:40:22+08:00">
    <meta property="article:modified_time" content="2018-11-19T23:40:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java8的lambda中的map相关操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4></h4> 
<h4>0 入门详解篇</h4> 
<p>1 <span style="color:#f33b45;"> </span> <a href="https://blog.csdn.net/wabiaozia/article/details/103321752">史上最简单入门：java8的lambda中的map相关操作:基础及注意事项图文详解</a></p> 
<p>2   <a href="https://blog.csdn.net/wabiaozia/article/details/103323564">java8的lambda中collect接口案例及原理详解,官方文档解读</a></p> 
<p>3   <a href="https://blog.csdn.net/wabiaozia/article/details/93424613">java8:封装lambda泛型工具类之list转为map</a></p> 
<p>4   <a href="https://blog.csdn.net/wabiaozia/article/details/84262195">java8的lambda中的map操作：合并两个map</a></p> 
<p></p> 
<hr> 
<h4>1 以下是正文</h4> 
<p>英文地址：<a href="https://www.baeldung.com/java-merge-maps" rel="nofollow">https://www.baeldung.com/java-merge-maps</a></p> 
<p>原文链接：<a href="https://blog.csdn.net/w605283073/article/details/82987157">https://blog.csdn.net/w605283073/article/details/82987157</a></p> 
<p><strong>1. 介绍</strong></p> 
<p>本入门教程将介绍Java8中如何<span style="color:#f33b45;">合并两个map</span>。如果想学习入门教程点击开篇<span style="color:#f33b45;">0入门篇</span>：<a href="https://blog.csdn.net/wabiaozia/article/details/103321752">lambda表达式:list转map</a></p> 
<p>更具体说来，我们将研究<span style="color:#f33b45;">不同的合并方案</span>，包括Map含有重复元素的情况。</p> 
<h3 id="init"><a name="t1"></a><strong>2. 初始化</strong></h3> 
<p>我们定义两个map实例</p> 
<pre class="has"><code>private static Map&lt;String, Employee&gt; map1 = new HashMap&lt;&gt;();

private static Map&lt;String, Employee&gt; map2 = new HashMap&lt;&gt;();</code></pre> 
<p><em>Employee类</em></p> 
<pre class="has"><code>public class Employee {


private Long id;

private String name;


// 此处省略构造方法, getters, setters方法

}</code></pre> 
<p>然后往map中存入一些数据</p> 
<pre class="has"><code>Employee employee1 = new Employee(1L, "Henry");

map1.put(employee1.getName(), employee1);

Employee employee2 = new Employee(22L, "Annie");

map1.put(employee2.getName(), employee2);

Employee employee3 = new Employee(8L, "John");

map1.put(employee3.getName(), employee3);


Employee employee4 = new Employee(2L, "George");

map2.put(employee4.getName(), employee4);

Employee employee5 = new Employee(3L, "Henry");

map2.put(employee5.getName(), employee5);</code></pre> 
<p>特别需要注意的是<em>employee1</em> 和 <em>employee5在map中有完全相同的key（name）。</em></p> 
<h3 id="merge"><a name="t2"></a><strong>3. <em>Map.merge()</em></strong></h3> 
<p>Java8为<strong> <em>java.util.Map接口新增了merge()函数。</em></strong></p> 
<p> <em>merge()</em>  函数的作用是: 如果给定的key之前没设置value 或者value为null, 则将给定的value关联到这个key上.</p> 
<p>否则，通过给定的remaping函数计算的结果来替换其value。如果remapping函数的计算结果为null，将解除此结果。</p> 
<p>First, let’s construct a new <em>HashMap</em> by copying all the entries from the <em>map1</em>:</p> 
<p>首先，我们通过拷贝map1中的元素来构造一个新的<em>HashMap</em></p> 
<pre class="has"><code>Map&lt;String, Employee&gt; map3 = new HashMap&lt;&gt;(map1);</code></pre> 
<p>然后引入merge函数和合并规则</p> 
<pre class="has"><code>map3.merge(key, value, (v1, v2) -&gt; new Employee(v1.getId(),v2.getName())</code></pre> 
<p>最后对map2进行迭代将其元素合并到map3中</p> 
<pre class="has"><code>map2.forEach(

(key, value) -&gt; map3.merge(key, value, (v1, v2) -&gt; new Employee(v1.getId(),v2.getName())));</code></pre> 
<pre class="has"><code class="language-html">运行程序并打印结果如下：</code></pre> 
<pre class="has"><code>John=Employee{id=8, name='John'}

Annie=Employee{id=22, name='Annie'}

George=Employee{id=2, name='George'}

Henry=Employee{id=1, name='Henry'}</code></pre> 
<p>最终，通过结果可以看出，实现了两个map的合并，对重复的key也合并为同一个元素。</p> 
<p>注意最后一个<em>Employee</em>的id来自map1而name来自map2.</p> 
<p>原因是我们的merge函数的定义</p> 
<pre class="has"><code>(v1, v2) -&gt; new Employee(v1.getId(), v2.getName())</code></pre> 
<h3 id="concat"><a name="t3"></a><strong>4. <em>Stream.concat()</em></strong></h3> 
<p><em>Java8的Stream</em> API 也为解决该问题提供了较好的解决方案。</p> 
<p>首先需要将两个map合为一个<strong><em>Stream。</em></strong></p> 
<pre class="has"><code>Stream combined = Stream.concat(map1.entrySet().stream(), map2.entrySet().stream());</code></pre> 
<p>我们需要将entry sets作为参数，然后利用<em>Collectors.toMap()</em>:将结果放到新的map中。</p> 
<pre class="has"><code>Map&lt;String, Employee&gt; result = combined.collect(

Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</code></pre> 
<p>该方法可以实现map的合并，但是有重复key会报<em>IllegalStateException异常。</em></p> 
<p>为了解决这个问题，我们需要加入lambda表达式merger作为第三个参数</p> 
<pre class="has"><code>(value1, value2) -&gt; new Employee(value2.getId(), value1.getName())</code></pre> 
<p>当检测到有重复Key时就会用到该lambda表达式。</p> 
<p>现在把上面代码组合在一起：</p> 
<pre class="has"><code>Map&lt;String, Employee&gt; result = Stream.concat(map1.entrySet().stream(), map2.entrySet().stream())

.collect(Collectors.toMap(

Map.Entry::getKey,

Map.Entry::getValue,

(value1, value2) -&gt; new Employee(value2.getId(), value1.getName())));</code></pre> 
<p>最终的结果</p> 
<pre class="has"><code>George=Employee{id=2, name='George'}

John=Employee{id=8, name='John'}

Annie=Employee{id=22, name='Annie'}

Henry=Employee{id=3, name='Henry'}</code></pre> 
<p>从结果可以看出重复的key<em> “</em><em>Henry</em><em>”将合并为一个新的键值对，id取自map2，name取自map1。</em></p> 
<p></p> 
<h3 id="of"><a name="t4"></a><em>5. Stream.of()</em></h3> 
<p>通过Stream.of()方法不需要借助其他stream就可以实现map的合并。</p> 
<pre class="has"><code>Map&lt;String, Employee&gt; map3 = Stream.of(map1, map2)

.flatMap(map -&gt; map.entrySet().stream())

.collect(Collectors.toMap(

Map.Entry::getKey,

Map.Entry::getValue,

(v1, v2) -&gt; new Employee(v1.getId(), v2.getName())));</code></pre> 
<p>首先将map1和map2的元素合并为同一个流，然后再转成map。通过使用v1的id和v2的name来解决重复key的问题。</p> 
<p>map3的运行打印结果如下：</p> 
<h3><a name="t5"></a><em>6. Simple Streaming</em></h3> 
<p>我们还可以借助stream的管道操作来实现map合并。</p> 
<pre class="has"><code>Map&lt;String, Employee&gt; map3 = map2.entrySet()

.stream()

.collect(Collectors.toMap(

Map.Entry::getKey,

Map.Entry::getValue,

(v1, v2) -&gt; new Employee(v1.getId(), v2.getName()),

() -&gt; new HashMap&lt;&gt;(map1)));</code></pre> 
<p>结果如下：</p> 
<pre class="has"><code>{John=Employee{id=8, name='John'},

Annie=Employee{id=22, name='Annie'},

George=Employee{id=2, name='George'},

Henry=Employee{id=1, name='Henry'}}</code></pre> 
<h3><a name="t6"></a><em>7. StreamEx</em></h3> 
<p>我们还可以使<strong><em>Stream</em> API</strong> 的增强库</p> 
<pre class="has"><code>Map&lt;String, Employee&gt; map3 = EntryStream.of(map1)

.append(EntryStream.of(map2))

.toMap((e1, e2) -&gt; e1);</code></pre> 
<p>注意 <em>(e1, e2) -&gt; e1</em> 表达式来处理重复key的问题，如果没有该表达式依然会报<em>IllegalStateException异常。</em></p> 
<p>结果：</p> 
<pre class="has"><code>{George=Employee{id=2, name='George'},

John=Employee{id=8, name='John'},

Annie=Employee{id=22, name='Annie'},

Henry=Employee{id=1, name='Henry'}}</code></pre> 
<p>8 总结</p> 
<p><strong><em>本文使用了Map.merge(), Stream API, StreamEx</em> 库实现map的合并。</strong></p> 
<p>本文源码：<a href="https://github.com/eugenp/tutorials/tree/master/core-java-collections">https://github.com/eugenp/tutorials/tree/master/core-java-collections</a></p> 
<h4>二：Java8使List转为Map</h4> 
<p><a href="https://blog.csdn.net/hanerer1314/article/details/78826068">https://blog.csdn.net/hanerer1314/article/details/78826068</a></p> 
<pre class="has"><code>import com.yang.test.User;
 
import javax.jws.soap.SOAPBinding;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
 
public class Main {
 
    public static void main(String[] args) {
 
        List&lt;User&gt; userlist = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt;10; i++) {
 
            userlist.add(new User("张三"+i,i));
        }
        System.out.println(getAllages(userlist).size());
 
        System.out.println(getUser2Map(userlist));
 
        System.out.println(getUser2MapUser(userlist));
 
        System.out.println(getUser2MapUser2(userlist));
 
          System.out.println(getUser2MapUser3(userlist));
 
    }
 
    public static List&lt;Integer&gt; getAllages(List&lt;User&gt;userlist){
        return  userlist.stream().map(user -&gt; user.getAge()).collect(Collectors.toList());
    }
 
    public static Map&lt;Integer,String&gt; getUser2Map(List&lt;User&gt;userlist){
 
        return userlist.stream().collect(Collectors.toMap(User::getAge,User::getName));
    }
 
    public static Map&lt;Integer,User&gt; getUser2MapUser(List&lt;User&gt;userlist){
 
        return userlist.stream().collect(Collectors.toMap(User::getAge,User-&gt; User));
    }
 
    /**
     * 比较优雅的写法是这样的
     * @param userlist
     * @return
     */
    public static Map&lt;Integer,User&gt; getUser2MapUser2(List&lt;User&gt;userlist){
 
        return userlist.stream().collect(Collectors.toMap(User::getAge, Function.identity()));
    }
 
    /**
     * 重复key的情况下 简单的使用后者覆盖前者的
     */
    public static Map&lt;Integer,User&gt; getUser2MapUser3(List&lt;User&gt;userlist){
 
        return userlist.stream().collect(Collectors.toMap(User::getAge, Function.identity(),(key1,key2)-&gt;key2));
    }
 
    /**
     *指定map的具体实现
     * @param userlist
     * @return
     */
    public static Map&lt;Integer,User&gt; getUser2MapUser4(List&lt;User&gt;userlist){
 
        return userlist.stream().collect(Collectors.toMap(User::getAge, Function.identity(),(key1,key2)-&gt;key2, LinkedHashMap::new));
    }
}
</code></pre> 
<p>Function.identity()用的默认的也可以是x-&gt;x 即value是user</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2373e1a8e0b7e58c318364e1e5b98fa3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Maven搭建Mybatis逆向工程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/14c9f43394a87127f6604e8e6bc4495e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">为什么8位有符号数的取值范围是-128 ~127</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>