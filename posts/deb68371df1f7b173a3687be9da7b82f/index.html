<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM学习笔记 - 第一章  什么是JVM？JVM基础入门和Java体系架构 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/deb68371df1f7b173a3687be9da7b82f/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="JVM学习笔记 - 第一章  什么是JVM？JVM基础入门和Java体系架构">
  <meta property="og:description" content="第一章 JVM和Java体系架构 目录：0.什么是JVM？1.学习JVM的目的2.Java VS C&#43;&#43;3.Java的跨平台性4.字节码5.Java生态圈6.虚拟机介绍6.1虚拟机的概念6.2Java虚拟机6.3.JVM的位置6.4 JVM的整体结构 7. Java代码的执行流程8. JVM架构模型9. 两种架构的举例10. 反编译字节码文件11. 架构总结12. JVM的生命周期 目录： 0.什么是JVM？ JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。
Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，
使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 打个比方，如果数学公式是Java程序，那么公式的推导过程就是JVM干的事
关系图：
1.学习JVM的目的 面试的需要（BATJ、TMD，PKQ等面试都爱问）中高级程序员必备技能：项目管理、调优的需求追求极客的精神，比如：垃圾回收算法、JIT（即时编译器）、底层原理能够明白为什么Java最早期被称为解释型语言为了今后更好的解决线上排查问题可以通过调整JVM相关参数提高Java应用的性能可以清楚知道Java程序是如何执行的 2.Java VS C&#43;&#43; 垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。 3.Java的跨平台性 每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理。随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。
4.字节码 我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。
5.Java生态圈 Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。
作为一个平台，Java虚拟机扮演着举足轻重的作用 Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分 作为一种文化，Java几乎成为了&#34;开源&#34;的代名词。 第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。 作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。 6.虚拟机介绍 6.1虚拟机的概念 所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。
大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。 6.2Java虚拟机 Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。
特点： 一次编译，到处运行自动内存管理自动垃圾回收功能 6.3.JVM的位置 JVM是运行在操作系统之上的，它与硬件没有直接的交互
Java的体系结构
6.4 JVM的整体结构 HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器（JIT)并存的架构。在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C&#43;&#43;程序一较高下的地步。执行引擎包含三部分：解释器，即时编译器，垃圾回收器
这个图要背下来↑ 7. Java代码的执行流程 8. JVM架构模型 Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：
基于栈式架构的特点 设计和实现更简单，适用于资源受限的系统避开了寄存器的分配难题：使用零地址指令方式分配指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现不需要硬件支持，可移植性更好，更好实现跨平台 基于寄存器架构的特点 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差性能优秀和执行更高效花费更少的指令去完成一项操作在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主 9.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-02-23T15:42:50+08:00">
    <meta property="article:modified_time" content="2021-02-23T15:42:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM学习笔记 - 第一章  什么是JVM？JVM基础入门和Java体系架构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>第一章 JVM和Java体系架构</h4> 
 <ul><li><a href="#_2" rel="nofollow">目录：</a></li><li><ul><li><a href="#0JVM_3" rel="nofollow">0.什么是JVM？</a></li><li><a href="#1JVM_18" rel="nofollow">1.学习JVM的目的</a></li><li><a href="#2Java_VS_C_31" rel="nofollow">2.Java VS C++</a></li><li><a href="#3Java_34" rel="nofollow">3.Java的跨平台性</a></li><li><a href="#4_42" rel="nofollow">4.字节码</a></li><li><a href="#5Java_48" rel="nofollow">5.Java生态圈</a></li><li><a href="#6_58" rel="nofollow">6.虚拟机介绍</a></li><li><ul><li><a href="#61_59" rel="nofollow">6.1虚拟机的概念</a></li><li><a href="#62Java_65" rel="nofollow">6.2Java虚拟机</a></li><li><a href="#63JVM_76" rel="nofollow">6.3.JVM的位置</a></li><li><a href="#64_JVM_85" rel="nofollow">6.4 JVM的整体结构</a></li></ul> 
   </li><li><a href="#7_Java_94" rel="nofollow">7. Java代码的执行流程</a></li><li><a href="#8_JVM_99" rel="nofollow">8. JVM架构模型</a></li><li><a href="#9__114" rel="nofollow">9. 两种架构的举例</a></li><li><a href="#10__136" rel="nofollow">10. 反编译字节码文件</a></li><li><a href="#11__186" rel="nofollow">11. 架构总结</a></li><li><a href="#12_JVM_197" rel="nofollow">12. JVM的生命周期</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>目录：</h2> 
<h3><a id="0JVM_3"></a>0.什么是JVM？</h3> 
<ul><li>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</li><li>引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。<br> Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，<br> 使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</li><li>Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</li></ul> 
<p><strong>打个比方，如果数学公式是Java程序，那么公式的推导过程就是JVM干的事</strong></p> 
<blockquote> 
 <p>关系图：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f4/d0/eTWFc9dM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1JVM_18"></a>1.学习JVM的目的</h3> 
<ul><li>面试的需要（BATJ、TMD，PKQ等面试都爱问）</li><li>中高级程序员必备技能：项目管理、调优的需求</li><li>追求极客的精神，比如：垃圾回收算法、JIT（即时编译器）、底层原理</li><li>能够明白为什么Java最早期被称为解释型语言</li><li>为了今后更好的解决线上排查问题</li><li>可以通过调整JVM相关参数提高Java应用的性能</li><li>可以清楚知道Java程序是如何执行的</li></ul> 
<h3><a id="2Java_VS_C_31"></a>2.Java VS C++</h3> 
<ul><li>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</li><li>C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。</li></ul> 
<h3><a id="3Java_34"></a>3.Java的跨平台性</h3> 
<ul><li>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理。</li><li>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</li><li>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。<br> <img src="https://images2.imgbox.com/10/b6/8HMK6RWz_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="4_42"></a>4.字节码</h3> 
<ul><li>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：<code>jvm字节码</code>。</li><li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</li><li>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。<br> <img src="https://images2.imgbox.com/9c/bf/WwnLCpb9_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="5Java_48"></a>5.Java生态圈</h3> 
<p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p> 
<ul><li>作为一个平台，Java虚拟机扮演着举足轻重的作用 
  <ul><li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li></ul> </li><li>作为一种文化，Java几乎成为了"开源"的代名词。 
  <ul><li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li><li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li></ul> </li><li>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li></ul> 
<h3><a id="6_58"></a>6.虚拟机介绍</h3> 
<h4><a id="61_59"></a>6.1虚拟机的概念</h4> 
<p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p> 
<ul><li>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li><li>程序虚拟机的典型代表就是<code>Java虚拟机</code>，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li><li>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</li></ul> 
<h4><a id="62Java_65"></a>6.2Java虚拟机</h4> 
<ul><li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li><li>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。<br> <strong>特点：</strong></li></ul> 
<ol><li><code>一次编译，到处运行</code></li><li><code>自动内存管理</code></li><li><code>自动垃圾回收功能</code></li></ol> 
<h4><a id="63JVM_76"></a>6.3.JVM的位置</h4> 
<blockquote> 
 <p>JVM是运行在操作系统之上的，它与硬件没有直接的交互<br> <img src="https://images2.imgbox.com/b5/f4/RNjWgMTR_o.png" alt="在这里插入图片描述"><br> Java的体系结构<br> <img src="https://images2.imgbox.com/16/46/n2XHy78f_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="64_JVM_85"></a>6.4 JVM的整体结构</h4> 
<ul><li><code>HotSpot VM</code>是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器（JIT)并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li><li>执行引擎包含三部分：<code>解释器</code>，<code>即时编译器</code>，<code>垃圾回收器</code><br> <img src="https://images2.imgbox.com/bc/4f/39vMhkJK_o.png" alt="在这里插入图片描述">这个图要背下来↑</li></ul> 
<h3><a id="7_Java_94"></a>7. Java代码的执行流程</h3> 
<p><img src="https://images2.imgbox.com/91/a3/RWcNhwjx_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="8_JVM_99"></a>8. JVM架构模型</h3> 
<p>Java编译器输入的指令流基本上是一种<code>基于栈的指令集架构</code>，另外一种指令集架构则是<code>基于寄存器的指令集架构</code>。具体来说：这两种架构之间的区别：</p> 
<ul><li>基于栈式架构的特点 
  <ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题：使用<code>零地址指令方式分配</code></li><li>指令流中的指令大部分是<code>零地址指令</code>，其执行过程依赖于<code>操作栈</code>。<code>指令集更小，编译器容易实现</code></li><li>不需要硬件支持，<code>可移植性更好</code>，更好<code>实现跨平台</code></li></ul> </li><li>基于寄存器架构的特点 
  <ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则<code>完全依赖硬件</code>，与硬件的耦合度高，<code>可移植性差</code></li><li><code>性能优秀和执行更高效</code></li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，<code>基于寄存器架构</code>的指令集往往都<code>以一地址指令、二地址指令和三地址指令为主</code>，而基于<code>栈式架构</code>的指令集却是<code>以零地址指令为主</code></li></ul> </li></ul> 
<h3><a id="9__114"></a>9. 两种架构的举例</h3> 
<p>同样执行2+3这种逻辑操作，其指令分别如下：</p> 
<ul><li>基于栈的计算流程（以Java虚拟机为例）</li></ul> 
<pre><code class="prism language-xml">iconst_2 //常量2入栈
istore_1
iconst_3 // 常量3入栈
istore_2
iload_1
iload_2
iadd //常量2/3出栈，执行相加
istore_0 // 结果5入栈
</code></pre> 
<ul><li>基于寄存器的计算流程</li></ul> 
<pre><code class="prism language-xml">mov eax,2 //将eax寄存器的值设为2
add eax,3 //使eax寄存器的值加3
</code></pre> 
<h3><a id="10__136"></a>10. 反编译字节码文件</h3> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackStruTest</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java">javap <span class="token operator">-</span>v StackStruTest<span class="token punctuation">.</span><span class="token keyword">class</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/95/0e/ebk5t7tx_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>反编译得到的指令</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V
    flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC
    Code<span class="token operator">:</span>
      stack<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span><span class="token operator">:</span> iconst_2  <span class="token comment">// 将常量 2 压入栈中</span>
         <span class="token number">1</span><span class="token operator">:</span> istore_1  <span class="token comment">// 将常量 2 保存至变量 i 中</span>
         <span class="token number">2</span><span class="token operator">:</span> iconst_3  <span class="token comment">// 将常量 3 压入栈中</span>
         <span class="token number">3</span><span class="token operator">:</span> istore_2  <span class="token comment">// 将常量 3 保存至变量 j 中</span>
         <span class="token number">4</span><span class="token operator">:</span> iload_1   <span class="token comment">// 加载变量 i</span>
         <span class="token number">5</span><span class="token operator">:</span> iload_2   <span class="token comment">// 加载变量 j</span>
         <span class="token number">6</span><span class="token operator">:</span> iadd      <span class="token comment">// 执行累加操作</span>
         <span class="token number">7</span><span class="token operator">:</span> istore_3  <span class="token comment">// 加法结果保存在变量 k 中</span>
         <span class="token number">8</span><span class="token operator">:</span> <span class="token keyword">return</span>
      LineNumberTable<span class="token operator">:</span>
        line <span class="token number">10</span><span class="token operator">:</span> <span class="token number">0</span>
        line <span class="token number">11</span><span class="token operator">:</span> <span class="token number">2</span>
        line <span class="token number">12</span><span class="token operator">:</span> <span class="token number">4</span>
        line <span class="token number">13</span><span class="token operator">:</span> <span class="token number">8</span>
      LocalVariableTable<span class="token operator">:</span>
        Start  Length  Slot  Name   Signature
            <span class="token number">0</span>       <span class="token number">9</span>     <span class="token number">0</span>  args   <span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span>
            <span class="token number">2</span>       <span class="token number">7</span>     <span class="token number">1</span>     i   I
            <span class="token number">4</span>       <span class="token number">5</span>     <span class="token number">2</span>     j   I
            <span class="token number">8</span>       <span class="token number">1</span>     <span class="token number">3</span>     k   I
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="11__186"></a>11. 架构总结</h3> 
<ul><li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</li><li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</li><li>因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构</li></ul> 
<blockquote> 
 <p>栈：跨平台性、指令集小、指令多；执行性能比寄存器差，<code>以零地址指令为主</code></p> 
 <p>寄存器：<code>性能优秀和执行更高效</code></p> 
</blockquote> 
<h3><a id="12_JVM_197"></a>12. JVM的生命周期</h3> 
<blockquote> 
 <p>启动–&gt;执行–&gt;退出</p> 
</blockquote> 
<ul><li>虚拟机的启动 
  <ul><li>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</li></ul> </li><li>虚拟机的执行 
  <ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li><li>程序开始执行时他才运行，程序结束时他就停止</li><li><code>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</code></li></ul> </li><li>虚拟机的退出 
  <ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用<code>Runtime类或System类的exit( )</code>方法，或<code>Runtime类的halt( )</code>方法，并且Java安全管理器也允许这次<code>exit( )</code>或<code>halt( )</code>操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1bc6afa4f5b3820bb541f49f85e254b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">百度地图 路径规划   错误 errorcode: 230</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2c1eb5d668caef83c075055043cf1aa0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小程序生成二维码(使用weapp-qrcode)以及相应的bug汇总</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>