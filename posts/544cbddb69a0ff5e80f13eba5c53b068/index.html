<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-＞双向链表带你体验开火车（哨兵）与拼接火车（应用）厢的乐趣 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/544cbddb69a0ff5e80f13eba5c53b068/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="数据结构-＞双向链表带你体验开火车（哨兵）与拼接火车（应用）厢的乐趣">
  <meta property="og:description" content="✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉
🍎个人主页：橘橙黄又青-CSDN博客
目的：学习双向带头链表的增，删，查，销毁。
1.🍎 双向链表的结构 注意：这⾥的“带头”跟前⾯我们说的“头节点”是两个概念，实际前⾯的在单链表阶段称呼不严 谨，但是为了同学们更好的理解就直接称为单链表的头节点。 带头链表⾥的头节点，实际为“哨兵位”，哨兵位节点不存储任何有效元素，只是站在这⾥“放哨 的”
哨兵位”存在的意义： 遍历循环链表避免死循环。
结构图解：
代码：
2. 🍎双向链表的实现 双向链表的定义结构：
链表空间申请节点，和初始化： 2.1🍎🍎哨兵位的申请 2.2🍎🍎带头双向链表打印 我们来分析分析：
代码：
这里补充一下：为什么是传值？因为临时拷贝一份打印就行，不用打印链表。
2.3🍎🍎双向链表的头插 2.4🍎🍎双向链表的尾插 尾插一个val尾x的元素
2.5🍎🍎双向链表的头删 2.6🍎🍎双向链表的尾删 2.7🍎🍎双线链表的查找 2.8🍎🍎双向链表在指定位置插入 2.9🍎🍎双向链表删除指定位置节点 2.10🍎🍎 双向链表销毁 3.🍎项目代码 Test.c
#include&#34;List.h&#34; void ListTest01() { //LTNode* plist = NULL; //LTInit(&amp;amp;plist); LTNode* plist = LTInit(); //尾插 //LTPushBack(plist, 1); //LTPushBack(plist, 2); //LTPushBack(plist, 3); //LTPushBack(plist, 4); //LTPrint(plist); //头插 LTPushFront(plist, 1); LTPushFront(plist, 2); LTPushFront(plist, 3); LTPushFront(plist, 4); LTPrint(plist); //4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt; // //LTPopBack(plist); //LTPrint(plist); //LTPopBack(plist); //LTPrint(plist); //LTPopBack(plist); //LTPrint(plist); //LTPopBack(plist); //LTPrint(plist); //LTPopBack(plist); //LTPrint(plist); // //头删 //LTPopFront(plist); //LTPrint(plist); //LTPopFront(plist); //LTPrint(plist); //LTPopFront(plist); //LTPrint(plist); //LTPopFront(plist); //LTPrint(plist); //LTPopFront(plist); //LTPrint(plist); LTNode* findRet = LTFind(plist, 3); /*if (findRet == NULL) { printf(&#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-11T20:57:13+08:00">
    <meta property="article:modified_time" content="2024-03-11T20:57:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-＞双向链表带你体验开火车（哨兵）与拼接火车（应用）厢的乐趣</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1200" src="https://images2.imgbox.com/38/5d/G1S621q0_o.png" width="1200"></p> 
<p>✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉</p> 
<p>🍎个人主页：<a href="https://blog.csdn.net/chendemingxxx?spm=1011.2266.3001.5343" title="橘橙黄又青-CSDN博客">橘橙黄又青-CSDN博客</a></p> 
<p><strong><span style="color:#fe2c24;">目的：学习双向带头链表的增，删，查，销毁。</span></strong></p> 
<h2>1.🍎 双向链表的结构</h2> 
<blockquote> 
 <p>注意：这⾥的“带头”跟前⾯我们说的“头节点”是两个概念，实际前⾯的在单链表阶段称呼不严 谨，但是为了同学们更好的理解就直接称为单链表的头节点。 带头链表⾥的头节点，实际为“哨兵位”，哨兵位节点不存储任何有效元素，只是站在这⾥“放哨 的”</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong> 哨兵位”存在的意义： 遍历循环链表避免死循环。</strong></span></p> 
<p>结构图解：</p> 
<p><img alt="" height="469" src="https://images2.imgbox.com/0f/6d/SCjtZ0Xk_o.png" width="1200"> 代码：</p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/f6/c5/YHTU6zEI_o.png" width="653"></p> 
<h2 style="background-color:transparent;">2. 🍎双向链表的实现</h2> 
<p></p> 
<p>双向链表的定义结构：</p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/1a/8b/S7vR4Zaz_o.png" width="690"></p> 
<p>链表空间申请节点，和初始化： </p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/47/bc/cV5RMJ5F_o.png" width="870"></p> 
<h3 style="background-color:transparent;">2.1🍎🍎哨兵位的申请</h3> 
<p><img alt="" height="186" src="https://images2.imgbox.com/91/38/PIkt55Tw_o.png" width="746"></p> 
<h3>2.2🍎🍎带头双向链表打印 </h3> 
<p>我们来分析分析：</p> 
<p><img alt="" height="677" src="https://images2.imgbox.com/55/79/UOUkl8na_o.png" width="1200"></p> 
<p> 代码：</p> 
<p><img alt="" height="408" src="https://images2.imgbox.com/c0/dd/QzRDspzg_o.png" width="706"></p> 
<p>这里补充一下：为什么是传值？因为临时拷贝一份打印就行，不用打印链表。</p> 
<p> <img alt="" height="639" src="https://images2.imgbox.com/44/70/XTjbuYrT_o.png" width="1200"></p> 
<h3> 2.3🍎🍎双向链表的头插</h3> 
<p><img alt="" height="664" src="https://images2.imgbox.com/01/3a/q9m150l2_o.png" width="1117"></p> 
<h3>2.4🍎🍎双向链表的尾插 </h3> 
<p>尾插一个val尾x的元素</p> 
<p><img alt="" height="650" src="https://images2.imgbox.com/2e/6d/PqRr8X7J_o.png" width="916"></p> 
<h3> 2.5🍎🍎双向链表的头删</h3> 
<p> <img alt="" height="738" src="https://images2.imgbox.com/c2/b5/l7NnlMcI_o.png" width="935"></p> 
<h3> 2.6🍎🍎双向链表的尾删</h3> 
<p> <img alt="" height="693" src="https://images2.imgbox.com/52/ff/7qErH2oV_o.png" width="1098"></p> 
<h3>2.7🍎🍎双线链表的查找 </h3> 
<p><img alt="" height="480" src="https://images2.imgbox.com/37/8f/bbpIX1qI_o.png" width="949"></p> 
<h3 style="background-color:transparent;">2.8🍎🍎双向链表在指定位置插入</h3> 
<p> <img alt="" height="620" src="https://images2.imgbox.com/00/e6/tJdxiMb4_o.png" width="875"></p> 
<h3>2.9🍎🍎双向链表删除指定位置节点</h3> 
<p><img alt="" height="621" src="https://images2.imgbox.com/b2/f0/nxuNGR5F_o.png" width="736"></p> 
<h3 style="background-color:transparent;">2.10🍎🍎 双向链表销毁 </h3> 
<p><img alt="" height="1043" src="https://images2.imgbox.com/4f/ea/lmxGD5Z0_o.png" width="1200"></p> 
<h2>3.🍎项目代码</h2> 
<p>Test.c</p> 
<pre><code class="language-cpp">#include"List.h"
void ListTest01() {
	//LTNode* plist = NULL;
	//LTInit(&amp;plist);

	LTNode* plist = LTInit();
	//尾插
	//LTPushBack(plist, 1);
	//LTPushBack(plist, 2);
	//LTPushBack(plist, 3);
	//LTPushBack(plist, 4);
	//LTPrint(plist);
	//头插
	LTPushFront(plist, 1);
	LTPushFront(plist, 2);
	LTPushFront(plist, 3);
	LTPushFront(plist, 4);
	LTPrint(plist);       //4-&gt;3-&gt;2-&gt;1-&gt;

	//
	//LTPopBack(plist);
	//LTPrint(plist);
	//LTPopBack(plist);
	//LTPrint(plist);
	//LTPopBack(plist);
	//LTPrint(plist);
	//LTPopBack(plist);
	//LTPrint(plist);
	//LTPopBack(plist);
	//LTPrint(plist);
	//
	//头删
	//LTPopFront(plist);
	//LTPrint(plist);
	//LTPopFront(plist);
	//LTPrint(plist);
	//LTPopFront(plist);
	//LTPrint(plist);
	//LTPopFront(plist);
	//LTPrint(plist);
	//LTPopFront(plist);
	//LTPrint(plist);

	LTNode* findRet = LTFind(plist, 3);
	/*if (findRet == NULL) {
		printf("未找到！\n");
	}
	else {
		printf("找到了！\n");
	}*/
	在指定位置之后插入数据
	//LTInsert(findRet, 66); //4-&gt;3-&gt;2-&gt;1-&gt;66-&gt;
	//LTPrint(plist);

	//删除pos位置的节点
	LTErase(findRet);
	LTPrint(plist);
	LTDesTroy(plist);
	plist = NULL;
}

int main() {
	ListTest01();
	return 0;
}</code></pre> 
<p>List.h代码：</p> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;

//定义双向链表中节点的结构
typedef int LTDataType;
typedef struct ListNode {
	LTDataType data;
	struct ListNode* prev;
	struct ListNode* next;
}LTNode;

//注意，双向链表是带有哨兵位的，插入数据之前链表中必须要先初始化一个哨兵位
//void LTInit(LTNode** pphead);
LTNode* LTInit();
//void LTDesTroy(LTNode** pphead);
void LTDesTroy(LTNode* phead);   //推荐一级（保持接口一致性）

void LTPrint(LTNode* phead);

//不需要改变哨兵位，则不需要传二级指针
//如果需要修改哨兵位的话，则传二级指针

//头插，尾插
void LTPushBack(LTNode* phead, LTDataType x);
void LTPushFront(LTNode* phead, LTDataType x);

//头删、尾删
void LTPopBack(LTNode* phead);
void LTPopFront(LTNode* phead);

//查找
LTNode* LTFind(LTNode* phead, LTDataType x);

//在pos位置之后插入数据
void LTInsert(LTNode* pos, LTDataType x);
//删除pos位置的数据
void LTErase(LTNode* pos);
</code></pre> 
<p>List.c代码：</p> 
<pre><code class="language-cpp">#include"List.h"
LTNode* LTBuyNode(LTDataType x) {
	LTNode* newnode = (LTNode*)malloc(sizeof(LTNode));
	if (newnode == NULL) {
		perror("malloc fail!");
		exit(1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = newnode-&gt;prev = newnode;

	return newnode;
}
//void LTInit(LTNode** pphead) {
//	*pphead = (LTNode*)malloc(sizeof(LTNode));
//	if (*pphead == NULL) {
//		perror("malloc fail!");
//		exit(1);
//	}
//	(*pphead)-&gt;data = -1;
//	(*pphead)-&gt;next = (*pphead)-&gt;prev = *pphead;
//}

//哨兵位，不含数据。存在目的：避免链表死循环
LTNode* LTInit() {
	LTNode* phead = LTBuyNode(-1);
	return phead;
}

//尾插
void LTPushBack(LTNode* phead, LTDataType x) {
	assert(phead);
	LTNode* newnode = LTBuyNode(x);
	//phead phead-&gt;prev(ptail)  newnode
	newnode-&gt;next = phead;
	newnode-&gt;prev = phead-&gt;prev;

	phead-&gt;prev-&gt;next = newnode;
	phead-&gt;prev = newnode;
}

//头插
void LTPushFront(LTNode* phead, LTDataType x) {
	assert(phead);

	LTNode* newnode = LTBuyNode(x);
	//phead newnode phead-&gt;next
	newnode-&gt;next = phead-&gt;next;
	newnode-&gt;prev = phead;

	phead-&gt;next-&gt;prev = newnode;
	phead-&gt;next = newnode;
}


//链表打印
void LTPrint(LTNode* phead) {
	//phead不能为空
	assert(phead);
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		printf("%d-&gt;", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}


//尾删
void LTPopBack(LTNode* phead) {
	assert(phead);
	//链表为空：只有一个哨兵位节点
	assert(phead-&gt;next != phead);

	LTNode* del = phead-&gt;prev;
	LTNode* prev = del-&gt;prev;

	prev-&gt;next = phead;
	phead-&gt;prev = prev;

	free(del);
	del = NULL;
}
//头删
void LTPopFront(LTNode* phead) {
	assert(phead);
	assert(phead-&gt;next != phead);

	LTNode* del = phead-&gt;next;
	LTNode* next = del-&gt;next;

	//phead del next
	next-&gt;prev = phead;
	phead-&gt;next = next;

	free(del);
	del = NULL;
}

//查找
LTNode* LTFind(LTNode* phead, LTDataType x) {
	assert(phead);
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		if (pcur-&gt;data == x) {
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	return NULL;
}

//在pos位置之后插入数据
void LTInsert(LTNode* pos, LTDataType x) {
	assert(pos);
	LTNode* newnode = LTBuyNode(x);
	//pos newnode pos-&gt;next
	newnode-&gt;next = pos-&gt;next;
	newnode-&gt;prev = pos;

	pos-&gt;next-&gt;prev = newnode;
	pos-&gt;next = newnode;
}

//删除pos位置的数据
void LTErase(LTNode* pos) {
	assert(pos);

	//pos-&gt;prev pos  pos-&gt;next
	pos-&gt;next-&gt;prev = pos-&gt;prev;
	pos-&gt;prev-&gt;next = pos-&gt;next;

	free(pos);
	pos = NULL;
}

//void LTDesTroy(LTNode** pphead) {
//	assert(pphead);
//	//哨兵位不能为空
//	assert(*pphead);
//
//	LTNode* pcur = (*pphead)-&gt;next;
//	while (pcur != *pphead)
//	{
//		LTNode* next = pcur-&gt;next;
//		free(pcur);
//		pcur = next;
//	}
//	//链表中只有一个哨兵位
//	free(*pphead);
//	*pphead = NULL;
//}

//链表销毁
void LTDesTroy(LTNode* phead) {
	//哨兵位不能为空
	assert(phead);

	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		LTNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	//链表中只有一个哨兵位
	free(phead);
	phead = NULL;
}</code></pre> 
<p>感谢观看，都看到这里了，点一个赞，谢谢。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/750db0e8a8a619a06ae14f5c1dba8e12/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL优化大总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac2f4be310c15eb53708863a585fbd69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">R语言快速读取数据vroom</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>