<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>万字长文带你了解nginx的安装与使用 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/6a74573d974b0fc880913589d29fb1fe/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="万字长文带你了解nginx的安装与使用">
  <meta property="og:description" content="概述 Nginx是一个高性能的HTTP和反向代理服务器，特点是占有内存少，并发能力强，事实上Nginx的并发能力确实在同类型的网页服务器中表现特别出色。常见的软件代理服务还有HA proxy、Varnish和Squid等。
nginx的安装 安装nginx的依赖 yum install -y gcc gcc-c&#43;&#43; make libtool wget pcre pcre-devel zlib zlib-devel openssl openssl-devel 下载nginx wget http://nginx.org/download/nginx-1.23.1.tar.gz 解压压缩包 tar -zxvf nginx cd nginx-1.23.1/ 安装 ./configure make &amp;amp;&amp;amp; make install 注意：安装完成后的路径为：/usr/local/nginx
启动 /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 在本地浏览器访问80端口，看到如下画面，说明nginx启动成功。如果网络不通，请注意检查linux的防火墙是否开启。
常用命令 普通启动服务：/usr/local/nginx/sbin/nginx 配置文件启动：/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 暴力停止服务：/usr/local/nginx/sbin/nginx -s stop 优雅停止服务：/usr/local/nginx/sbin/nginx -s quit 检查配置文件：/usr/local/nginx/sbin/nginx -t 重新加载配置：/usr/local/nginx/sbin/nginx -s reload 查看相关进程：ps -ef | grep nginx 测试反向代理 实现目标如下图所示，nginx监听80端口，并把请求转发到8080，在服务端启动一个tomcat监听8080用于测试。
nginx配置修改 修改nginx配置
vi /usr/local/nginx/conf/nginx.conf server { listen 80; server_name 192.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-11T22:07:31+08:00">
    <meta property="article:modified_time" content="2023-05-11T22:07:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">万字长文带你了解nginx的安装与使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>概述</h2> 
<p>Nginx是一个高性能的HTTP和反向代理服务器，特点是占有内存少，并发能力强，事实上Nginx的并发能力确实在同类型的网页服务器中表现特别出色。常见的软件代理服务还有HA proxy、Varnish和Squid等。</p> 
<h2><a id="nginx_2"></a>nginx的安装</h2> 
<h3><a id="nginx_3"></a>安装nginx的依赖</h3> 
<pre><code>yum install -y gcc gcc-c++ make libtool wget pcre pcre-devel zlib zlib-devel openssl openssl-devel
</code></pre> 
<p><img src="https://images2.imgbox.com/52/79/EA6UKmXm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="nginx_8"></a>下载nginx</h3> 
<pre><code> wget http://nginx.org/download/nginx-1.23.1.tar.gz
</code></pre> 
<p><img src="https://images2.imgbox.com/2f/e2/ryd07iZ3_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_13"></a>解压压缩包</h3> 
<pre><code>tar -zxvf  nginx
cd nginx-1.23.1/
</code></pre> 
<p><img src="https://images2.imgbox.com/29/07/zcbe6Dua_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_19"></a>安装</h3> 
<pre><code> ./configure
 make &amp;&amp; make install
</code></pre> 
<p>注意：安装完成后的路径为：/usr/local/nginx</p> 
<h3><a id="_25"></a>启动</h3> 
<pre><code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
</code></pre> 
<p>在本地浏览器访问80端口，看到如下画面，说明nginx启动成功。如果网络不通，请注意检查linux的防火墙是否开启。<br> <img src="https://images2.imgbox.com/a0/4a/bvgzlesD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_31"></a>常用命令</h4> 
<pre><code>普通启动服务：/usr/local/nginx/sbin/nginx

配置文件启动：/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf

暴力停止服务：/usr/local/nginx/sbin/nginx -s stop

优雅停止服务：/usr/local/nginx/sbin/nginx -s quit

检查配置文件：/usr/local/nginx/sbin/nginx -t

重新加载配置：/usr/local/nginx/sbin/nginx -s reload

查看相关进程：ps -ef | grep nginx
</code></pre> 
<h3><a id="_48"></a>测试反向代理</h3> 
<p>实现目标如下图所示，nginx监听80端口，并把请求转发到8080，在服务端启动一个tomcat监听8080用于测试。<br> <img src="https://images2.imgbox.com/de/70/VeaxCRlh_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="nginx_52"></a>nginx配置修改</h4> 
<p>修改nginx配置</p> 
<pre><code> vi /usr/local/nginx/conf/nginx.conf
</code></pre> 
<pre><code> server {
        listen       80;
        server_name  192.168.0.109;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            proxy_pass http://127.0.0.1:8080;
            root   html;
            index  index.html index.htm;
        }
</code></pre> 
<h4><a id="tomcat_72"></a>tomcat</h4> 
<p>下载tomcat</p> 
<pre><code>wget http://archive.apache.org/dist/tomcat/tomcat-8/v8.0.23/bin/apache-tomcat-8.0.23.tar.gz
</code></pre> 
<p>解压</p> 
<pre><code>tar -zxvf apache-tomcat-8.0.23.tar.gz
</code></pre> 
<p>启动</p> 
<pre><code>/usr/local/tomcat/bin/startup.sh
</code></pre> 
<p>这里为了方便，直接关闭服务器的防火墙</p> 
<pre><code> /usr/local/tomcat/bin/shutdown.sh
</code></pre> 
<p>测试：<br> 在本地浏览器输入 http://192.168.0.109/，页面展示如下即代理成功。<br> <img src="https://images2.imgbox.com/50/21/gRha4fw9_o.png" alt="在这里插入图片描述"><br> 关闭tomcat</p> 
<pre><code>/usr/local/tomcat/bin/shutdown.sh
</code></pre> 
<h3><a id="url_97"></a>测试根据不同url分别路由</h3> 
<p><img src="https://images2.imgbox.com/a7/67/e90oByZq_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="nginx_101"></a>nginx配置修改</h4> 
<pre><code>

    server {
        listen       80;
        server_name  192.168.0.109;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location ~/edu/ { 
            proxy_pass  http://127.0.0.1:8080;
            root   html;
            index  index.html index.htm;
        }
        location ~/pro/{
            proxy_pass http://127.0.0.1:8081;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

</code></pre> 
<h4><a id="tomcat_132"></a>tomcat</h4> 
<p>拷贝另一个tomcat</p> 
<pre><code>cp -r tomcat /usr/local/tomcat2
</code></pre> 
<p>更改tomcat2的配置文件，修改端口号为8081</p> 
<pre><code>rm -f /usr/local/tomcat2/conf/server.xml
vi /usr/local/tomcat2/conf/server.xml
</code></pre> 
<p>拷贝如下内容到server.xml中</p> 
<pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--&gt;
&lt;!-- Note:  A "Server" is not itself a "Container", so you may not
     define subcomponents such as "Valves" at this level.
     Documentation at /docs/config/server.html
 --&gt;
&lt;Server port="8006" shutdown="SHUTDOWN"&gt;
  &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener" /&gt;
  &lt;!-- Security listener. Documentation at /docs/config/listeners.html
  &lt;Listener className="org.apache.catalina.security.SecurityListener" /&gt;
  --&gt;
  &lt;!--APR library loader. Documentation at /docs/apr.html --&gt;
  &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /&gt;
  &lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;
  &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" /&gt;
  &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt;
  &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /&gt;

  &lt;!-- Global JNDI resources
       Documentation at /docs/jndi-resources-howto.html
  --&gt;
  &lt;GlobalNamingResources&gt;
    &lt;!-- Editable user database that can also be used by
         UserDatabaseRealm to authenticate users
    --&gt;
    &lt;Resource name="UserDatabase" auth="Container"
              type="org.apache.catalina.UserDatabase"
              description="User database that can be updated and saved"
              factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
              pathname="conf/tomcat-users.xml" /&gt;
  &lt;/GlobalNamingResources&gt;

  &lt;!-- A "Service" is a collection of one or more "Connectors" that share
       a single "Container" Note:  A "Service" is not itself a "Container",
       so you may not define subcomponents such as "Valves" at this level.
       Documentation at /docs/config/service.html
   --&gt;
  &lt;Service name="Catalina"&gt;

    &lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;
    &lt;!--
    &lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-"
        maxThreads="150" minSpareThreads="4"/&gt;
    --&gt;


    &lt;!-- A "Connector" represents an endpoint by which requests are received
         and responses are returned. Documentation at :
         Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking)
         Java AJP  Connector: /docs/config/ajp.html
         APR (HTTP/AJP) Connector: /docs/apr.html
         Define a non-SSL/TLS HTTP/1.1 Connector on port 8080
    --&gt;
    &lt;Connector port="8081" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8444" /&gt;
    &lt;!-- A "Connector" using the shared thread pool--&gt;
    &lt;!--
    &lt;Connector executor="tomcatThreadPool"
               port="8080" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" /&gt;
    --&gt;
    &lt;!-- Define a SSL/TLS HTTP/1.1 Connector on port 8443
         This connector uses the NIO implementation that requires the JSSE
         style configuration. When using the APR/native implementation, the
         OpenSSL style configuration is required as described in the APR/native
         documentation --&gt;
    &lt;!--
    &lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
               maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
               clientAuth="false" sslProtocol="TLS" /&gt;
    --&gt;

    &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;
    &lt;Connector port="8010" protocol="AJP/1.3" redirectPort="8444" /&gt;


    &lt;!-- An Engine represents the entry point (within Catalina) that processes
         every request.  The Engine implementation for Tomcat stand alone
         analyzes the HTTP headers included with the request, and passes them
         on to the appropriate Host (virtual host).
         Documentation at /docs/config/engine.html --&gt;

    &lt;!-- You should set jvmRoute to support load-balancing via AJP ie :
    &lt;Engine name="Catalina" defaultHost="localhost" jvmRoute="jvm1"&gt;
    --&gt;
    &lt;Engine name="Catalina" defaultHost="localhost"&gt;

      &lt;!--For clustering, please take a look at documentation at:
          /docs/cluster-howto.html  (simple how to)
          /docs/config/cluster.html (reference documentation) --&gt;
      &lt;!--
      &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;
      --&gt;

      &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords
           via a brute-force attack --&gt;
      &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt;
        &lt;!-- This Realm uses the UserDatabase configured in the global JNDI
             resources under the key "UserDatabase".  Any edits
             that are performed against this UserDatabase are immediately
             available for use by the Realm.  --&gt;
        &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"
               resourceName="UserDatabase"/&gt;
      &lt;/Realm&gt;

      &lt;Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true"&gt;

        &lt;!-- SingleSignOn valve, share authentication between web applications
             Documentation at: /docs/config/valve.html --&gt;
        &lt;!--
        &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;
        --&gt;

        &lt;!-- Access log processes all example.
             Documentation at: /docs/config/valve.html
             Note: The pattern used is equivalent to using pattern="common" --&gt;
        &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="localhost_access_log" suffix=".txt"
               pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;

      &lt;/Host&gt;
    &lt;/Engine&gt;
  &lt;/Service&gt;
&lt;/Server&gt;
</code></pre> 
<p>启动两个tomcat</p> 
<pre><code>/usr/local/tomcat/bin/startup.sh
/usr/local/tomcat2/bin/startup.sh
</code></pre> 
<h4><a id="_293"></a>测试</h4> 
<p>在本地浏览器访问http://192.168.0.109/pro/a.html 出现<br> <img src="https://images2.imgbox.com/44/7b/6yQ29JrG_o.png" alt="在这里插入图片描述"></p> 
<p>在本地浏览器访问http://192.168.0.109/edu/a.html 出现<br> <img src="https://images2.imgbox.com/95/7d/KjkFFzDK_o.png" alt="在这里插入图片描述"><br> 说明根据不同url分别路由成功。</p> 
<h3><a id="_302"></a>测试负载均衡</h3> 
<p>当输入同一个uri时，nginx会根据负载均衡策略将报文分别打到不同的服务中。<br> <img src="https://images2.imgbox.com/ce/67/nvNN97ki_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="nginx_305"></a>修改nginx配置文件</h4> 
<pre><code>vi /usr/local/nginx/conf/nginx.conf


upstream myserver {
        server 192.168.206.128:8080;
        server 192.168.206.128:8081;
    }

    server {
        listen       80;
        server_name  192.168.206.128;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            proxy_pass http://myserver;
        }
</code></pre> 
<p>负载均衡策略讲解</p> 
<pre><code>默认 轮询
upstream myserver {
        server 192.168.206.128:8080;
        server 192.168.206.128:8081;   
 }
 权重分配，权重越大访问的可能性就越大，权重与访问的比率成正比
 upstream myserver {
        server 192.168.206.128:8080 weight=1;
        server 192.168.206.128:8081 weight=10;   
 }

hash 根据客户端的ip地址进行hash，将请求固定打到某个后端服务中，这是解决服务端间session无法同步的一个思路
 upstream myserver {
 		
        server 192.168.206.128:8080 weight=1;
        server 192.168.206.128:8081 weight=10;   
 }
按后端服务器的响应时间来分配请求，响应时间短的优先分配。例如：
 upstream myserver {
 		
        server 192.168.206.128:8080 ;
        server 192.168.206.128:8081;   
		fair;        
 }

</code></pre> 
<h4><a id="tomcat_356"></a>修改tomcat配置</h4> 
<p>在Tomcat2的webapps文件夹中，创建一个edu文件夹，在里边创建a.html<br> 并分别启动两个tomcat</p> 
<pre><code>mkdir -p /usr/local/tomcat2/webapps/edu
echo "&lt;h1&gt;This is 8081 Port&lt;/h1&gt;" &gt; /usr/local/tomcat2/webapps/edu/a.html
/usr/local/tomcat1/bin/startup.sh
/usr/local/tomcat2/bin/startup.sh
</code></pre> 
<h4><a id="_365"></a>测试</h4> 
<p>在浏览器中多次点击http://192.168.0.109/edu/a.html，会依次展示如下页面。<br> <img src="https://images2.imgbox.com/39/93/XgFMKZOr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/54/ca/4J9dQ10v_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_369"></a>动静分离</h3> 
<p>目前主流的访问静态资源的方案是通过CDN进行加速，但是nginx也是可以进行访问静态资源的，如果动态资源和静态资源同时存在，nginx会优先去访问静态资源。</p> 
<p>配置文件</p> 
<pre><code class="prism language-server">        listen       80;
        server_name  192.168.0.109;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location /www/ {
            root /data/;
            index index.html index.htm;
        }
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/720cab5964f518e45470a4a14c335401/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">hadoop安装文档</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2787c3a3df9ce41444c8a9e705315646/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux Nginx自定义安装目录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>