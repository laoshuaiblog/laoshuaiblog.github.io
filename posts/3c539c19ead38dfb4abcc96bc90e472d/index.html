<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>114.QTimer类和QWidget类 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/3c539c19ead38dfb4abcc96bc90e472d/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="114.QTimer类和QWidget类">
  <meta property="og:description" content="目录
一、QTimer类
定时器使用举例：
二、QWidget类 2.1设置父对象
2.2窗口位置
2.3窗口尺寸
2.4窗口标题和图标
2.5信号
2.6槽函数
示例代码：
一、QTimer类 QTimer 是 Qt 中用于实现定时器的类。它可以在一定的时间间隔内发射信号，用于执行一些特定的操作。要使用它，只需创建一个QTimer类对象，然后调用其 start() 函数开启定时器，此后QTimer对象就会周期性的发出 timeout() 信号。我们先来了解一下这个类的相关API。
// 构造函数 // 如果指定了父对象, 创建的堆内存可以自动析构 QTimer::QTimer(QObject *parent = nullptr); // 设置定时器时间间隔为 msec 毫秒 // 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发 void QTimer::setInterval(int msec); // 获取定时器的时间间隔, 返回值单位: 毫秒 int QTimer::interval() const; // 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔 [slot] void QTimer::start(); // 启动或重新启动定时器，超时间隔为msec毫秒。 [slot] void QTimer::start(int msec); // 停止定时器。 [slot] void QTimer::stop(); // 设置定时器精度 /* 参数: - Qt::PreciseTimer -&amp;gt; 精确的精度, 毫秒级 - Qt::CoarseTimer -&amp;gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度 - Qt::VeryCoarseTimer -&amp;gt; 非常粗糙的精度, 精度在1秒左右 */ void QTimer::setTimerType(Qt::TimerType atype); Qt::TimerType QTimer::timerType() const;	// 获取当前定时器的精度 // 如果定时器正在运行，返回true; 否则返回false。 bool QTimer::isActive() const; // 判断定时器是否只触发一次 bool QTimer::isSingleShot() const; // 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false void QTimer::setSingleShot(bool singleShot); 定时器使用举例： #include &#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-13T15:03:20+08:00">
    <meta property="article:modified_time" content="2024-01-13T15:03:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">114.QTimer类和QWidget类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81QTimer%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81QTimer%E7%B1%BB" rel="nofollow">一、QTimer类</a></p> 
<p id="%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A" rel="nofollow">定时器使用举例：</a></p> 
<p id="%E4%BA%8C%E3%80%81QWidget%E7%B1%BB%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81QWidget%E7%B1%BB%C2%A0" rel="nofollow">二、QWidget类 </a></p> 
<p id="2.1%E8%AE%BE%E7%BD%AE%E7%88%B6%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#2.1%E8%AE%BE%E7%BD%AE%E7%88%B6%E5%AF%B9%E8%B1%A1" rel="nofollow">2.1设置父对象</a></p> 
<p id="2.2%E7%AA%97%E5%8F%A3%E4%BD%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#2.2%E7%AA%97%E5%8F%A3%E4%BD%8D%E7%BD%AE" rel="nofollow">2.2窗口位置</a></p> 
<p id="2.3%E7%AA%97%E5%8F%A3%E5%B0%BA%E5%AF%B8-toc" style="margin-left:80px;"><a href="#2.3%E7%AA%97%E5%8F%A3%E5%B0%BA%E5%AF%B8" rel="nofollow">2.3窗口尺寸</a></p> 
<p id="2.4%E7%AA%97%E5%8F%A3%E6%A0%87%E9%A2%98%E5%92%8C%E5%9B%BE%E6%A0%87-toc" style="margin-left:80px;"><a href="#2.4%E7%AA%97%E5%8F%A3%E6%A0%87%E9%A2%98%E5%92%8C%E5%9B%BE%E6%A0%87" rel="nofollow">2.4窗口标题和图标</a></p> 
<p id="2.5%E4%BF%A1%E5%8F%B7-toc" style="margin-left:80px;"><a href="#2.5%E4%BF%A1%E5%8F%B7" rel="nofollow">2.5信号</a></p> 
<p id="2.6%E6%A7%BD%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.6%E6%A7%BD%E5%87%BD%E6%95%B0" rel="nofollow">2.6槽函数</a></p> 
<p id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">示例代码：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81QTimer%E7%B1%BB">一、QTimer类</h2> 
<blockquote> 
 <p><code>   QTimer</code> 是 Qt 中用于实现定时器的类。它可以在一定的时间间隔内发射信号，用于执行一些特定的操作。要使用它，只需创建一个QTimer类对象，然后调用其 start() 函数开启定时器，此后QTimer对象就会周期性的发出 timeout() 信号。我们先来了解一下这个类的相关API。</p> 
 <pre><code class="language-cpp">// 构造函数
// 如果指定了父对象, 创建的堆内存可以自动析构
QTimer::QTimer(QObject *parent = nullptr);

// 设置定时器时间间隔为 msec 毫秒
// 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发
void QTimer::setInterval(int msec);
// 获取定时器的时间间隔, 返回值单位: 毫秒
int QTimer::interval() const;

// 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔
[slot] void QTimer::start();
// 启动或重新启动定时器，超时间隔为msec毫秒。
[slot] void QTimer::start(int msec);
// 停止定时器。
[slot] void QTimer::stop();

// 设置定时器精度
/*
参数: 
    - Qt::PreciseTimer -&gt; 精确的精度, 毫秒级
    - Qt::CoarseTimer  -&gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度
    - Qt::VeryCoarseTimer -&gt; 非常粗糙的精度, 精度在1秒左右
*/
void QTimer::setTimerType(Qt::TimerType atype);
Qt::TimerType QTimer::timerType() const;	// 获取当前定时器的精度

// 如果定时器正在运行，返回true; 否则返回false。
bool QTimer::isActive() const;

// 判断定时器是否只触发一次
bool QTimer::isSingleShot() const;
// 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false
void QTimer::setSingleShot(bool singleShot);
</code></pre> 
 <h4 id="%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A" style="background-color:transparent;">定时器使用举例：</h4> 
 <pre><code class="language-cpp">#include "mainwindow.h"
#include "ui_mainwindow.h"
#include &lt;QTimer&gt;
#include &lt;QTime&gt;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);

    //创建定时器对象
    QTimer* timer=new QTimer(this);

    //修改定时器对象的精度
    timer-&gt;setTimerType(Qt::PreciseTimer);

    //按钮点击事件
    connect(ui-&gt;loopBtn,&amp;QPushButton::clicked,this,[=]()
    {
        //启动定时器
        if(timer-&gt;isActive())
        {
            timer-&gt;stop();//关闭定时器
            ui-&gt;loopBtn-&gt;setText("开始");
        }
        else
        {
            ui-&gt;loopBtn-&gt;setText("关闭");
            timer-&gt;start(1000);//1000ms=1s
        }
    });

    connect(timer,&amp;QTimer::timeout,this,[=]()
    {
        QTime tm=QTime::currentTime();
        //格式化当前得到的系统时间
        QString tmstr=tm.toString("hh:mm:ss.zzz");
        //设置要显示的时间
        ui-&gt;curTime-&gt;setText(tmstr);
    });

    //发射一次信号
    connect(ui-&gt;onceBtn,&amp;QPushButton::clicked,this,[=]()
    {
        //获取2s以后的系统时间
        QTimer::singleShot(2000,this,[=](){
        QTime tm=QTime::currentTime();
        //格式化当前得到的系统时间
        QString tmstr=tm.toString("hh:mm:ss.zzz");
        //设置要显示的时间
        ui-&gt;onceTime-&gt;setText(tmstr);
        });
    });
}

MainWindow::~MainWindow()
{
    delete ui;
}
</code></pre> 
 <p>这段代码创建了一个简单的Qt窗口应用程序，其中包含了两个按钮（"开始"和"关闭"按钮，分别由<code>ui-&gt;loopBtn</code>表示），以及两个标签（<code>ui-&gt;curTime</code>和<code>ui-&gt;onceTime</code>表示当前时间和一次性定时器的时间）。这个应用程序使用了<code>QTimer</code>类来实现定时功能。</p> 
 <p>下面是代码的主要功能和流程：</p> 
 <ol><li>创建了一个 <code>QTimer</code> 对象 <code>timer</code>，并设置了其精度为 <code>Qt::PreciseTimer</code>。</li><li>通过 lambda 表达式连接 "开始"/"关闭" 按钮的点击事件，以实现定时器的启动和停止。</li><li>连接 <code>timer</code> 的 <code>timeout</code> 信号到 lambda 表达式，每次定时器超时时更新当前时间标签 <code>ui-&gt;curTime</code>。</li><li>连接 "一次性" 按钮的点击事件，使用 <code>QTimer::singleShot</code> 实现一次性的定时器，延迟2秒后更新一次 <code>ui-&gt;onceTime</code> 标签。</li></ol> 
 <p>这个应用程序演示了 <code>QTimer</code> 的基本用法，用于处理定时事件和一次性定时操作。当用户点击 "开始" 按钮时，定时器启动，每秒更新一次当前时间。点击 "一次性" 按钮时，延迟2秒后更新一次一次性时间。点击 "关闭" 按钮时，定时器停止。</p> 
 <p>需要确保在 Qt 项目中添加了 <code>QTimer</code> 头文件的引用。这段代码在构造函数中完成了信号和槽的连接，并在析构函数中释放了 <code>ui</code> 对象。</p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81QWidget%E7%B1%BB%C2%A0">二、QWidget类 </h2> 
<blockquote> 
 <p>        QWidget类是所有窗口类的父类(控件类是也属于窗口类), 并且QWidget类的父类的QObject, 也就意味着所有的窗口类对象只要指定了父对象, 都可以实现内存资源的自动回收。<img alt="" height="1096" src="https://images2.imgbox.com/93/8a/1qM45VKT_o.png" width="1200"></p> 
 <h4 id="2.1%E8%AE%BE%E7%BD%AE%E7%88%B6%E5%AF%B9%E8%B1%A1">2.1设置父对象</h4> 
 <pre><code class="language-cpp">// 构造函数
QWidget::QWidget(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

// 公共成员函数
// 给当前窗口设置父对象
void QWidget::setParent(QWidget *parent);
void QWidget::setParent(QWidget *parent, Qt::WindowFlags f);
// 获取当前窗口的父对象, 没有父对象返回 nullptr
QWidget *QWidget::parentWidget() const;
</code></pre> 
 <h4 id="2.2%E7%AA%97%E5%8F%A3%E4%BD%8D%E7%BD%AE">2.2窗口位置</h4> 
 <pre><code class="language-cpp">//------------- 窗口位置 -------------
// 得到相对于当前窗口父窗口的几何信息, 边框也被计算在内
QRect QWidget::frameGeometry() const;
// 得到相对于当前窗口父窗口的几何信息, 不包括边框
const QRect &amp;geometry() const;
// 设置当前窗口的几何信息(位置和尺寸信息), 不包括边框
void setGeometry(int x, int y, int w, int h);
void setGeometry(const QRect &amp;);
    
// 移动窗口, 重新设置窗口的位置
void move(int x, int y);
void move(const QPoint &amp;);
</code></pre> 
 <h4 id="2.3%E7%AA%97%E5%8F%A3%E5%B0%BA%E5%AF%B8">2.3窗口尺寸</h4> 
 <pre><code class="language-cpp">//------------- 窗口尺寸 -------------
// 获取当前窗口的尺寸信息
QSize size() const
// 重新设置窗口的尺寸信息
void resize(int w, int h);
void resize(const QSize &amp;);
// 获取当前窗口的最大尺寸信息
QSize maximumSize() const;
// 获取当前窗口的最小尺寸信息
QSize minimumSize() const;
// 设置当前窗口固定的尺寸信息
void QWidget::setFixedSize(const QSize &amp;s);
void QWidget::setFixedSize(int w, int h);
// 设置当前窗口的最大尺寸信息
void setMaximumSize(const QSize &amp;);
void setMaximumSize(int maxw, int maxh);
// 设置当前窗口的最小尺寸信息
void setMinimumSize(const QSize &amp;);
void setMinimumSize(int minw, int minh);


// 获取当前窗口的高度    
int height() const;
// 获取当前窗口的最小高度
int minimumHeight() const;
// 获取当前窗口的最大高度
int maximumHeight() const;
// 给窗口设置固定的高度
void QWidget::setFixedHeight(int h);
// 给窗口设置最大高度
void setMaximumHeight(int maxh);
// 给窗口设置最小高度
void setMinimumHeight(int minh);

// 获取当前窗口的宽度
int width() const;
// 获取当前窗口的最小宽度
int minimumWidth() const;
// 获取当前窗口的最大宽度
int maximumWidth() const;
// 给窗口设置固定宽度
void QWidget::setFixedWidth(int w);
// 给窗口设置最大宽度
void setMaximumWidth(int maxw);
// 给窗口设置最小宽度
void setMinimumWidth(int minw);
</code></pre> 
 <h4 id="2.4%E7%AA%97%E5%8F%A3%E6%A0%87%E9%A2%98%E5%92%8C%E5%9B%BE%E6%A0%87">2.4窗口标题和图标</h4> 
 <pre><code class="language-cpp">//------------- 窗口图标 -------------
// 得到当前窗口的图标
QIcon windowIcon() const;
// 构造图标对象, 参数为图片的路径
QIcon::QIcon(const QString &amp;fileName);
// 设置当前窗口的图标
void setWindowIcon(const QIcon &amp;icon);

//------------- 窗口标题 -------------
// 得到当前窗口的标题
QString windowTitle() const;
// 设置当前窗口的标题
void setWindowTitle(const QString &amp;);
</code></pre> 
 <h4 id="2.5%E4%BF%A1%E5%8F%B7">2.5信号</h4> 
 <pre><code class="language-cpp">// QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy);
// 窗口的右键菜单策略 contextMenuPolicy() 参数设置为 Qt::CustomContextMenu, 按下鼠标右键发射该信号
[signal] void QWidget::customContextMenuRequested(const QPoint &amp;pos);
// 窗口图标发生变化, 发射此信号
[signal] void QWidget::windowIconChanged(const QIcon &amp;icon);
// 窗口标题发生变化, 发射此信号
[signal] void QWidget::windowTitleChanged(const QString &amp;title);

</code></pre> 
 <h4 id="2.6%E6%A7%BD%E5%87%BD%E6%95%B0">2.6槽函数</h4> 
 <pre><code class="language-cpp">//------------- 窗口显示 -------------
// 关闭当前窗口
[slot] bool QWidget::close();
// 隐藏当前窗口
[slot] void QWidget::hide();
// 显示当前创建以及其子窗口
[slot] void QWidget::show();
// 全屏显示当前窗口, 只对windows有效
[slot] void QWidget::showFullScreen();
// 窗口最大化显示, 只对windows有效
[slot] void QWidget::showMaximized();
// 窗口最小化显示, 只对windows有效
[slot] void QWidget::showMinimized();
// 将窗口回复为最大化/最小化之前的状态, 只对windows有效
[slot] void QWidget::showNormal();

//------------- 窗口状态 -------------
// 判断窗口是否可用
bool QWidget::isEnabled() const; // 非槽函数
// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件
// 参数true-&gt;可用, false-&gt;不可用
[slot] void QWidget::setEnabled(bool);
// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件
// 参数true-&gt;不可用, false-&gt;可用
[slot] void QWidget::setDisabled(bool disable);
// 设置窗口是否可见, 参数为true-&gt;可见, false-&gt;不可见
[slot] virtual void QWidget::setVisible(bool visible);

</code></pre> 
 <h4 id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A" style="background-color:transparent;">示例代码：</h4> 
 <pre><code class="language-cpp">#include "mainwindow.h"
#include "ui_mainwindow.h"
#include &lt;QDebug&gt;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);

    //设置窗口的最大尺寸
    //setMaximumSize(600,600);
    //设置窗口的最小尺寸
    //setMinimumSize(300,300);
    //设置窗口的固定尺寸
    //setFixedSize(500,500);
    //设置窗口标题
    setWindowTitle("xinwei");
    //给显示的窗口设置图标
    setWindowIcon(QIcon("D:\\我的简历\\微信图片_20240112145734.jpg"));

    connect(this,&amp;MainWindow::windowTitleChanged,this,[=](const QString &amp;title)
    {
        qDebug()&lt;&lt;"新的标题："&lt;&lt;title;
    });

    connect(this,&amp;MainWindow::windowIconChanged,this,[=](const QIcon &amp;icon)
    {
    qDebug()&lt;&lt;"当前窗口的图标被修改了";
    });

    setContextMenuPolicy(Qt::CustomContextMenu);
    connect(this,&amp;MainWindow::customContextMenuRequested,this,[=](const QPoint &amp;pos)
    {
        QMenu meun;
        meun.addAction("西红柿");
        meun.addAction("黄瓜");
        meun.addAction("西瓜");
        meun.exec(QCursor::pos());
    });
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::on_moveButt_clicked()
{
    QRect rect=this-&gt;frameGeometry();
    move(rect.topLeft()+QPoint(10,20));
}


void MainWindow::on_positionBut_clicked()
{
    QRect rect=this-&gt;frameGeometry();
    qDebug()&lt;&lt;"左上角："&lt;&lt;rect.topLeft();
    qDebug()&lt;&lt;"右上角："&lt;&lt;rect.topRight();
    qDebug()&lt;&lt;"左下角："&lt;&lt;rect.bottomLeft();
    qDebug()&lt;&lt;"右下角："&lt;&lt;rect.bottomRight();
    qDebug()&lt;&lt;"宽度："&lt;&lt;rect.width();
    qDebug()&lt;&lt;"高度："&lt;&lt;rect.height();
}


void MainWindow::on_geomeryBto_clicked()
{
    int x=100+rand()%500;
    int y=100+rand()%500;
    int width=this-&gt;width()+10;
    int height=this-&gt;height()+10;
    setGeometry(x,y,width,height);
}


void MainWindow::on_motiButton_clicked()
{
    setWindowTitle("你好，世界");
    setWindowIcon(QIcon("D:\\我的简历\\微信图片_20240112145725.jpg"));
}

</code></pre> 
 <p></p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db8cca37288076802c2bc3f2db09aa3f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pandas的iloc函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be08c23677c64175a1d26b1791d24511/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python中none的替换方法：pandas&amp;numpy</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>