<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ECMAScript 2024（ES15）将带来超实用的新特性 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/4fa3031da0034f3051035683640f94fd/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="ECMAScript 2024（ES15）将带来超实用的新特性">
  <meta property="og:description" content="ECMAScript语言规范每年都会进行一次更新，而备受期待的 ECMAScript 2024 将于 2024 年 6 月正式亮相。目前，ECMAScript 2024 的候选版本已经发布，为我们带来了一系列实用的新功能。接下来，就让我们一起先睹为快吧！
全文概览：
Promise.withResolversObject.groupBy / Map.groupByArrayBuffer.prototype.resizeArrayBuffer.prototype.transferString.prototype.isWellFormedString.prototype.toWellFormedAtomics.waitAsync正则表达式 v 标志 Promise.withResolvers() Promise.withResolvers() 允许创建一个新的 Promise，并同时获得 resolve 和 reject 函数。这在某些场景下非常有用，特别是当需要同时访问到 Promise 的 resolve 和 reject 函数时。
Promise.withResolvers() 完全等同于以下代码：
let resolve, reject; const promise = new Promise((res, rej) =&amp;gt; { resolve = res; reject = rej; }); 通常，当创建一个新的 Promise 时，会传递一个执行器函数给 Promise 构造函数，这个执行器函数接收两个参数：resolve 和 reject 函数。但在某些情况下，可能想要在 Promise 创建之后仍然能够访问到这两个函数。这就是 Promise.withResolvers() 的用武之地。
使用 Promise.withResolvers() 的一个例子：
const { promise, resolve, reject } = Promise.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-19T17:18:10+08:00">
    <meta property="article:modified_time" content="2024-02-19T17:18:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ECMAScript 2024（ES15）将带来超实用的新特性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><code>ECMAScript</code>语言规范每年都会进行一次更新，而备受期待的 ECMAScript 2024 将于 2024 年 6 月正式亮相。目前，ECMAScript 2024 的候选版本已经发布，为我们带来了一系列实用的新功能。接下来，就让我们一起先睹为快吧！<br> <img src="https://images2.imgbox.com/2b/2e/9h1bTZ6w_o.png" alt="在这里插入图片描述"><br> 全文概览：</p> 
<ul><li>Promise.withResolvers</li><li>Object.groupBy / Map.groupBy</li><li>ArrayBuffer.prototype.resize</li><li>ArrayBuffer.prototype.transfer</li><li>String.prototype.isWellFormed</li><li>String.prototype.toWellFormed</li><li>Atomics.waitAsync</li><li>正则表达式 v 标志</li></ul> 
<h3><a id="PromisewithResolvers_12"></a>Promise.withResolvers()</h3> 
<p>Promise.withResolvers() 允许创建一个新的 Promise，并同时获得 resolve 和 reject 函数。这在某些场景下非常有用，特别是当需要同时访问到 Promise 的 resolve 和 reject 函数时。</p> 
<p>Promise.withResolvers() 完全等同于以下代码：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">;</span>
<span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> rej</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  resolve <span class="token operator">=</span> res<span class="token punctuation">;</span>
  reject <span class="token operator">=</span> rej<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>通常，当创建一个新的 Promise 时，会传递一个执行器函数给 Promise 构造函数，这个执行器函数接收两个参数：resolve 和 reject 函数。但在某些情况下，可能想要在 Promise 创建之后仍然能够访问到这两个函数。这就是 Promise.withResolvers() 的用武之地。</p> 
<p>使用 Promise.withResolvers() 的一个例子：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> promise<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject <span class="token punctuation">}</span> <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">withResolvers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
<span class="token comment">// 在这里可以使用 resolve 和 reject 函数  </span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功！'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>  
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: 成功！  </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这个例子中，首先通过 Promise.withResolvers() 创建了一个新的 Promise，并同时获得了 resolve 和 reject 函数。然后，在 setTimeout 回调中使用 resolve 函数来解析这个 Promise。最后，添加了一个 .then 处理程序来处理 Promise 解析后的值。</p> 
<p>使用 Promise.withResolvers() 关键的区别在于解决和拒绝函数现在与 Promise 本身处于同一作用域，而不是在执行器中被创建和一次性使用。这可能使得一些更高级的用例成为可能，例如在重复事件中重用它们，特别是在处理流和队列时。这通常也意味着相比在执行器内包装大量逻辑，嵌套会更少。</p> 
<p>这个功能对于那些需要更细粒度控制 Promise 的状态，或者在 Promise 创建后仍然需要访问 resolve 和 reject 函数的场景来说非常有用。</p> 
<h3><a id="ObjectgroupBy__MapgroupBy_43"></a>Object.groupBy / Map.groupBy</h3> 
<p>Object.groupBy 和 Map.groupBy 方法用于数组分组。</p> 
<p>假设有一个由表示人员的对象组成的数组，需要按照年龄进行分组。可以使用forEach循环来实现，代码如下：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Eve"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> peopleByAge <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

people<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">person</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> age <span class="token operator">=</span> person<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>peopleByAge<span class="token punctuation">[</span>age<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    peopleByAge<span class="token punctuation">[</span>age<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  peopleByAge<span class="token punctuation">[</span>age<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>peopleByAge<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>输出结果如下：</p> 
<pre><code class="prism language-javascript"><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"28"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"Alice"</span><span class="token punctuation">,</span><span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"Eve"</span><span class="token punctuation">,</span><span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string-property property">"30"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>也可以使用reduce方法：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> peopleByAge <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">acc<span class="token punctuation">,</span> person</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> age <span class="token operator">=</span> person<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>acc<span class="token punctuation">[</span>age<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    acc<span class="token punctuation">[</span>age<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  acc<span class="token punctuation">[</span>age<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> acc<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>无论哪种方式，代码都略显繁琐。每次都要检查对象，看分组键是否存在，如果不存在，则创建一个空数组，并将项目添加到该数组中。</p> 
<h3><a id="_ObjectgroupBy__90"></a>使用 Object.groupBy 分组</h3> 
<p>可以通过以下方式来使用新的Object.groupBy方法：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> peopleByAge <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">person</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> person<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>可以看到，代码非常简洁！</p> 
<p>不过需要注意，使用Object.groupBy方法返回一个没有原型（即没有继承任何属性和方法）的对象。这意味着该对象不会继承Object.prototype上的任何属性或方法，例如hasOwnProperty或toString等。虽然这样做可以避免意外覆盖Object.prototype上的属性，但也意味着不能使用一些与对象相关的方法。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> peopleByAge <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">person</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> person<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>peopleByAge<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">"28"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// TypeError: peopleByAge.hasOwnProperty is not a function</span>
</code></pre> 
<p>在调用Object.groupBy时，传递给它的回调函数应该返回一个字符串或 Symbol 类型的值。如果回调函数返回其他类型的值，它将被强制转换为字符串。</p> 
<p>在这个例子中，回调函数返回的是一个数字类型的age属性值，但由于Object.groupBy方法要求键必须是字符串或 Symbol 类型，所以该数字会被强制转换为字符串类型。</p> 
<pre><code class="prism language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>peopleByAge<span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; [{"name":"Alice","age":28}, {"name":"Eve","age":28}]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>peopleByAge<span class="token punctuation">[</span><span class="token string">"28"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; [{"name":"Alice","age":28}, {"name":"Eve","age":28}]</span>
</code></pre> 
<h3><a id="_MapgroupBy__115"></a>使用 Map.groupBy 分组</h3> 
<p>Map.groupBy和Object.groupBy几乎做的是相同的事情，只是返回的结果类型不同。Map.groupBy返回一个Map对象，而不是像Object.groupBy返回一个普通的对象。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> ceo <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Jamie"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token literal-property property">reportsTo</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> manager <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token literal-property property">reportsTo</span><span class="token operator">:</span> ceo <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">[</span>
  ceo
  manager<span class="token punctuation">,</span>
  <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token literal-property property">reportsTo</span><span class="token operator">:</span> manager <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Eve"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token literal-property property">reportsTo</span><span class="token operator">:</span> ceo <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> peopleByManager <span class="token operator">=</span> Map<span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">person</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> person<span class="token punctuation">.</span>reportsTo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这里根据人的汇报上级将他们进行了分组。如果想通过对象来从这个Map中获取数据，那么要求这些对象具有相同的身份或引用。这是因为Map在比较键时使用的是严格相等（===），只有两个对象具有相同的引用，才能被认为是相同的键。</p> 
<pre><code class="prism language-javascript">peopleByManager<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ceo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; [{ name: "Alice", age: 28, reportsTo: ceo }, { name: "Eve", age: 28, reportsTo: ceo }]</span>
peopleByManager<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Jamie"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token literal-property property">reportsTo</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; undefined</span>
</code></pre> 
<p>在上面的例子中，如果尝试使用与ceo对象类似的对象作为键去访问Map中的项，由于这个对象与之前存储在Map中的ceo对象不是同一个对象，所以无法检索到对应的值。</p> 
<h3><a id="ArrayBufferprototyperesize_140"></a>ArrayBuffer.prototype.resize</h3> 
<p>ArrayBuffer 实例的 resize() 方法将 ArrayBuffer 调整为指定的大小，以字节为单位，前提是该 ArrayBuffer 是可调整大小的并且新的大小小于或等于该 ArrayBuffer 的 maxByteLength。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">maxByteLength</span><span class="token operator">:</span> <span class="token number">16</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span>byteLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 8</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span>resizable<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"缓冲区大小是可调整的！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  buffer<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意：</p> 
<ul><li> <p>如果 ArrayBuffer 已分离或不可调整大小，则抛出该错误。</p> </li><li> <p>如果 newLength 大于该 ArrayBuffer 的 maxByteLength，则抛出该错误。</p> </li></ul> 
<h3><a id="ArrayBufferprototypetransfer_160"></a>ArrayBuffer.prototype.transfer</h3> 
<p>transfer() 方法执行与结构化克隆算法相同的操作。它将当前 ArrayBuffer 的字节复制到一个新的 ArrayBuffer 对象中，然后分离当前 ArrayBuffer 对象，保留了当前 ArrayBuffer 的大小可调整性。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 创建一个 ArrayBuffer 并写入一些字节</span>
<span class="token keyword">const</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> view <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
view<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
view<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token comment">// 将缓冲区复制到另一个相同大小的缓冲区</span>
<span class="token keyword">const</span> buffer2 <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span>detached<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buffer2<span class="token punctuation">.</span>byteLength<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>
<span class="token keyword">const</span> view2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>buffer2<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>view2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>view2<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>

<span class="token comment">// 将缓冲区复制到一个更小的缓冲区</span>
<span class="token keyword">const</span> buffer3 <span class="token operator">=</span> buffer2<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buffer3<span class="token punctuation">.</span>byteLength<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>
<span class="token keyword">const</span> view3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>buffer3<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>view3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>view3<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>

<span class="token comment">// 将缓冲区复制到一个更大的缓冲区</span>
<span class="token keyword">const</span> buffer4 <span class="token operator">=</span> buffer3<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buffer4<span class="token punctuation">.</span>byteLength<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>
<span class="token keyword">const</span> view4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>buffer4<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>view4<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>view4<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>

<span class="token comment">// 已经分离，抛出 TypeError</span>
buffer<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: Cannot perform ArrayBuffer.prototype.transfer on a detached ArrayBuffer</span>
</code></pre> 
<h3><a id="StringprototypeisWellFormed_195"></a>String.prototype.isWellFormed()</h3> 
<p>isWellFormed() 方法返回一个表示该字符串是否包含单独代理项的布尔值。</p> 
<p>JavaScript 中的字符串是 UTF-16 编码的。UTF-16 编码中的代理对是指：</p> 
<blockquote> 
 <p>在UTF-16编码中，代理对（Surrogate Pair）是一种特殊的编码机制，用于表示那些超出基本多文种平面（BMP）的Unicode字符。这些字符的Unicode码点高于U+FFFF，因此无法用一个16位的UTF-16码元来表示。为了解决这个问题，UTF-16引入了代理对机制。<br> 代理对是由两个16位的码元组成的，一个称为高代理（或高代理码元），其码点范围在U+D800到U+DBFF之间；另一个称为低代理（或低代理码元），其码点范围在U+DC00到U+DFFF之间。这两个码元合在一起，可以表示一个超出BMP的Unicode字符。<br> 例如，Unicode码点U+10000（这是BMP之外的第一个码点）在UTF-16中的编码就是高代理码元U+D800和低代理码元U+DC00的组合，即“D800 DC00”。同样，码点U+10001的UTF-16编码就是“D800 DC01”，以此类推。<br> 通过这种方式，UTF-16编码能够完全表示所有Unicode字符，无论是BMP内的还是BMP外的。这种代理对机制是UTF-16编码方案的一个重要组成部分，使得UTF-16成为一种能够灵活处理各种语言字符的编码方式。</p> 
</blockquote> 
<p>isWellFormed() 让你能够测试一个字符串是否是格式正确的（即不包含单独代理项）。由于引擎能够直接访问字符串的内部表示，与自定义实现相比 isWellFormed() 更高效。如果需要将字符串转换为格式正确的字符串，可以使用 toWellFormed() 方法。isWellFormed() 让你可以对格式正确和格式错误的字符串进行不同的处理，比如抛出一个错误或将其标记为无效。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> strings <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token comment">// 单独的前导代理</span>
  <span class="token string">"ab\uD800"</span><span class="token punctuation">,</span>
  <span class="token string">"ab\uD800c"</span><span class="token punctuation">,</span>
  <span class="token comment">// 单独的后尾代理</span>
  <span class="token string">"\uDFFFab"</span><span class="token punctuation">,</span>
  <span class="token string">"c\uDFFFab"</span><span class="token punctuation">,</span>
  <span class="token comment">// 格式正确</span>
  <span class="token string">"abc"</span><span class="token punctuation">,</span>
  <span class="token string">"ab\uD83D\uDE04c"</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> str <span class="token keyword">of</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">isWellFormed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出：</span>
<span class="token comment">// false</span>
<span class="token comment">// false</span>
<span class="token comment">// false</span>
<span class="token comment">// false</span>
<span class="token comment">// true</span>
<span class="token comment">// true</span>
</code></pre> 
<p>如果传递的字符串格式不正确， encodeURI 会抛出错误。可以通过使用 isWellFormed() 在将字符串传递给 encodeURI() 之前测试字符串来避免这种情况。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> illFormed <span class="token operator">=</span> <span class="token string">"https://example.com/search?q=\uD800"</span><span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">encodeURI</span><span class="token punctuation">(</span>illFormed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// URIError: URI malformed</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>illFormed<span class="token punctuation">.</span><span class="token function">isWellFormed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">encodeURI</span><span class="token punctuation">(</span>illFormed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Ill-formed strings encountered."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Ill-formed strings encountered.</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="StringprototypetoWellFormed_247"></a>String.prototype.toWellFormed()</h3> 
<p>toWellFormed() 方法返回一个字符串，其中该字符串的所有单独代理项都被替换为 Unicode 替换字符 U+FFFD。</p> 
<p>toWellFormed() 迭代字符串的码元，并将任何单独代理项替换为 Unicode 替换字符 U+FFFD。这确保了返回的字符串格式正确并可用于期望正确格式字符串的函数，比如 encodeURI。由于引擎能够直接访问字符串的内部表示，与自定义实现相比 toWellFormed() 更高效。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> strings <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token comment">// 单独的前导代理</span>
  <span class="token string">"ab\uD800"</span><span class="token punctuation">,</span>
  <span class="token string">"ab\uD800c"</span><span class="token punctuation">,</span>
  <span class="token comment">// 单独的后尾代理</span>
  <span class="token string">"\uDFFFab"</span><span class="token punctuation">,</span>
  <span class="token string">"c\uDFFFab"</span><span class="token punctuation">,</span>
  <span class="token comment">// 格式正确</span>
  <span class="token string">"abc"</span><span class="token punctuation">,</span>
  <span class="token string">"ab\uD83D\uDE04c"</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> str <span class="token keyword">of</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toWellFormed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Logs:</span>
<span class="token comment">// "ab�"</span>
<span class="token comment">// "ab�c"</span>
<span class="token comment">// "�ab"</span>
<span class="token comment">// "c�ab"</span>
<span class="token comment">// "abc"</span>
<span class="token comment">// "ab😄c"</span>

</code></pre> 
<p>如果传递的字符串格式不正确， encodeURI 会抛出错误。可以先通过使用 toWellFormed() 将字符串转换为格式正确的字符串来避免这种情况。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> illFormed <span class="token operator">=</span> <span class="token string">"https://example.com/search?q=\uD800"</span><span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">encodeURI</span><span class="token punctuation">(</span>illFormed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// URIError: URI malformed</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">encodeURI</span><span class="token punctuation">(</span>illFormed<span class="token punctuation">.</span><span class="token function">toWellFormed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "https://example.com/search?q=%EF%BF%BD"</span>
</code></pre> 
<h3><a id="AtomicswaitAsync_290"></a>Atomics.waitAsync()</h3> 
<p>Atomics.waitAsync() 静态方法异步等待共享内存的特定位置并返回一个 Promise。与 Atomics.wait() 不同，waitAsync 是非阻塞的且可用于主线程。</p> 
<p>下面来看一个简单的例子，给定一个共享的 Int32Array。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> sab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedArrayBuffer</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> int32 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Int32Array</span><span class="token punctuation">(</span>sab<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>令一个读取线程休眠并在位置 0 处等待，预期该位置的值为 0。result.value 将是一个 promise。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> result <span class="token operator">=</span> Atomics<span class="token punctuation">.</span><span class="token function">waitAsync</span><span class="token punctuation">(</span>int32<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { async: true, value: Promise {&lt;pending&gt;} }</span>
</code></pre> 
<p>在该读取线程或另一个线程中，对内存位置 0 调用以令该 promise 解决为 “ok”。</p> 
<pre><code class="prism language-javascript">Atomics<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>int32<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { async: true, value: Promise {&lt;fulfilled&gt;: 'ok'} }</span>
</code></pre> 
<p>如果它没有解决为 “ok”，则共享内存该位置的值不符合预期（value 将是 “not-equal” 而不是一个 promise）或已经超时（该 promise 将解决为 “time-out”）。</p> 
<h3><a id="_v__313"></a>正则表达式 v 标志</h3> 
<p>RegExp v 标志是 u 标志的超集，并提供了另外两个功能：</p> 
<ul><li>字符串的 Unicode 属性： 通过 Unicode 属性转义，可以使用字符串的属性。</li></ul> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\p{RGI_Emoji}$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">v</span></span><span class="token punctuation">;</span>

<span class="token comment">// 匹配仅包含 1 个代码点的表情符号：</span>
re<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'⚽'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '\u26BD'</span>
<span class="token comment">// → true ✅</span>

<span class="token comment">// 匹配由多个代码点组成的表情符号：</span>
re<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'👨🏾‍⚕️'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '\u{1F468}\u{1F3FE}\u200D\u2695\uFE0F'</span>
<span class="token comment">// → true ✅</span>
</code></pre> 
<ul><li>设置符号： 允许在字符类之间进行集合操作。</li></ul> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\p{White_Space}&amp;&amp;\p{ASCII}]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">v</span></span><span class="token punctuation">;</span>
re<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// → true</span>
re<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'\u2028'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// → false</span>
</code></pre> 
<p>在JavaScript的正则表达式中，u 标志表示“Unicode”模式。当你在正则表达式中使用这个标志时，它会将模式视为Unicode序列的集合，而不仅仅是一组ASCII字符。这意味着正则表达式会正确地处理四个字节的UTF-16编码。</p> 
<p>具体来说，u 标志有以下几个作用：</p> 
<p>正确处理Unicode字符：不使用 u 标志时，正则表达式可能无法正确处理Unicode字符，尤其是那些超出基本多文种平面（BMP）的字符。使用 u 标志后，你可以匹配和处理任何有效的Unicode字符。</p> 
<p>改变量词的行为：在Unicode模式下，量词（如 *、+、?、{n}、{n,}、{n,m}）会匹配任何有效的Unicode字符，而不仅仅是ASCII字符。</p> 
<p>允许使用\p{…} 和 \P{…}：这两个是Unicode属性转义，允许匹配或不匹配具有特定Unicode属性的字符。例如，\p{Script=Arabic} 会匹配任何阿拉伯脚本的字符。</p> 
<p>正确处理Unicode转义：在Unicode模式下，你可以使用 \u{…} 来表示一个Unicode字符，其中 {…} 是一个四位的十六进制数。</p> 
<p>修正了某些正则表达式方法的行为：例如，String.prototype.match()、String.prototype.replace()、String.prototype.search() 和 RegExp.prototype.exec() 等方法在Unicode模式下会返回更准确的结果。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/16163976467d2ae6fb570a743a4ca672/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【React】使用lodash的debounce未生效</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dcc7be6a374cf631cebc97fe4f25eff2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">shell脚本文本三剑客grep，sed，awk</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>