<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker部署ftp，java连接踩坑记录 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/892fc8650c1131bc8aa50b8588945a61/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="docker部署ftp，java连接踩坑记录">
  <meta property="og:description" content="下载镜像
docker pull fauria/vsftpd 启动容器
docker run -d --network=host -v /app/deploy/ftp:/home/vsftpd -e FTP_USER=ftp -e FTP_PASS=123456 --name vsftpd --restart=always fauria/vsftpd 注意此处不需要端口映射，之前我只映射了，20，21，22等端口发现，可以连接上ftp但是无法打开目录上传下载文件
使用java连接ftp
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-net&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-net&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; private static final Logger logger = LoggerFactory.getLogger(FtpServiceImpl.class); // ip地址 @Value(&#34;${ftp.client.host}&#34;) private String host; // 端口号 @Value(&#34;${ftp.client.port}&#34;) private Integer port; // 用户名 @Value(&#34;${ftp.client.username}&#34;) private String username; // 密码 @Value(&#34;${ftp.client.password}&#34;) private String password; // session链接超时时间 @Value(&#34;${ftp.client.sessionConnectTimeout:15000}&#34;) private Integer sessionConnectTimeout; // channel链接超时时间 @Value(&#34;${ftp.client.channelConnectedTimeout:15000}&#34;) private Integer channelConnectedTimeout; /** * 检查SFTP目录或文件是否存在 * * @param remotePath * @return */ @Override public boolean checkFileExist(String remotePath) { FTPClient ftpClient = loginFtp(); try { ftpClient.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-23T17:44:45+08:00">
    <meta property="article:modified_time" content="2023-03-23T17:44:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker部署ftp，java连接踩坑记录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>下载镜像</p> 
<pre><code class="language-bash">docker pull fauria/vsftpd</code></pre> 
<p>启动容器</p> 
<pre><code class="language-bash">docker run -d --network=host -v /app/deploy/ftp:/home/vsftpd -e FTP_USER=ftp -e FTP_PASS=123456  --name vsftpd --restart=always fauria/vsftpd</code></pre> 
<p>注意此处不需要端口映射，之前我只映射了，20，21，22等端口发现，可以连接上ftp但是无法打开目录上传下载文件</p> 
<p><img alt="" height="755" src="https://images2.imgbox.com/1a/7b/hxBeccZp_o.png" width="641"></p> 
<p>使用java连接ftp</p> 
<pre><code class="language-XML">&lt;dependency&gt;
                &lt;groupId&gt;commons-net&lt;/groupId&gt;
                &lt;artifactId&gt;commons-net&lt;/artifactId&gt;
                &lt;version&gt;3.6&lt;/version&gt;
            &lt;/dependency&gt;</code></pre> 
<p></p> 
<pre><code class="language-java">private static final Logger logger = LoggerFactory.getLogger(FtpServiceImpl.class);
    // ip地址
    @Value("${ftp.client.host}")
    private String host;

    // 端口号
    @Value("${ftp.client.port}")
    private Integer port;

    // 用户名
    @Value("${ftp.client.username}")
    private String username;

    // 密码
    @Value("${ftp.client.password}")
    private String password;

    // session链接超时时间
    @Value("${ftp.client.sessionConnectTimeout:15000}")
    private Integer sessionConnectTimeout;

    // channel链接超时时间
    @Value("${ftp.client.channelConnectedTimeout:15000}")
    private Integer channelConnectedTimeout;


    /**
     * 检查SFTP目录或文件是否存在
     *
     * @param remotePath
     * @return
     */
    @Override
    public boolean checkFileExist(String remotePath) {
        FTPClient ftpClient = loginFtp();

        try {
            ftpClient.changeWorkingDirectory(remotePath);
            // 设置为被动模型 行内的ftp需要在这里再设置一下
            ftpClient.enterLocalPassiveMode();
            String[] listNames = ftpClient.listNames(remotePath);
            if(listNames == null){
                return false;
            }
            if(listNames.length &gt; 0){
                return true;
            }else{
                return false;
            }
        } catch (Exception e) {
            logger.warn("检查FTP目录或文件是否存在错误: ", e);
            return false;
        } finally {
            closeFtpClient(ftpClient);
        }
    }
    /**
     * 写远程文件
     *
     * @param data
     * @param remoteDirPath
     * @return
     */
    @Override
    public String writeFile(String data, String fileName, String remoteDirPath) {
        return writeFile(data.getBytes(StandardCharsets.UTF_8), fileName, remoteDirPath);
    }
    /**
     * 写远程文件
     *
     * @param data
     * @param remoteDirPath
     * @return
     */
    public String writeFile(byte[] data, String fileName, String remoteDirPath) {
        FTPClient ftpClient = loginFtp();
        try {
            boolean dirs = createDirs(remoteDirPath, ftpClient);
            if (!dirs) {
                logger.error("Remote path error. path:{}", remoteDirPath);
                return null;
            }

            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            ftpClient.enterLocalPassiveMode();
            try (ByteArrayInputStream inputStream = new ByteArrayInputStream(data)) {
                String remoteFilePath = remoteDirPath + "/" + fileName;
                logger.info("upload file:::{}", remoteFilePath);

                ftpClient.storeFile(remoteFilePath,inputStream);
                ftpClient.logout();
                return remoteFilePath;
            }
        } catch (IOException ex) {
            logger.error("写远程文件错误", ex);
        } finally {
            closeFtpClient(ftpClient);
        }
        return null;
    }

    /**
     * 登录FTP
     * 
     * @return
     */
    private FTPClient loginFtp() {
        FTPClient ftpClient = new FTPClient();
        ftpClient.setControlEncoding("UTF-8");
        try {
            //设置连接超时时间
            ftpClient.setDataTimeout(sessionConnectTimeout);
            ftpClient.setConnectTimeout(channelConnectedTimeout);
            logger.info("连接FTP服务器中:" + host + ":" + port);
            // 设置为被动模型
            ftpClient.enterLocalPassiveMode();
            //连接ftp服务器
            ftpClient.connect(host, port);
            //登录ftp服务器
            ftpClient.login(username, password);
            // 是否成功登录服务器
            int replyCode = ftpClient.getReplyCode();
            if (FTPReply.isPositiveCompletion(replyCode)) {
                logger.info("连接FTP服务器成功:" + host + ":" + port);
            } else {
                logger.error("连接FTP服务器失败:" + host + ":" + port);
                closeFtpClient(ftpClient);
            }
        } catch (IOException e) {
            logger.error("连接ftp服务器异常", e);
            throw new RuntimeException(e);
        }
        return ftpClient;
    }

    /**
     * 关闭FTP连接
     *
     * @param ftpClient
     */
    public void closeFtpClient(FTPClient ftpClient) {
        if (ftpClient.isConnected()) {
            try {
                ftpClient.disconnect();
            } catch (IOException e) {
                logger.error("关闭FTP连接异常", e);
                throw new RuntimeException(e);
            }
        }
    }
    /**
     * 创建FTP目录，如果目录不存在就创建
     *
     * @param dirPath
     * @param ftpClient
     * @return
     */
    private boolean createDirs(String dirPath, FTPClient ftpClient) throws IOException {
        if (StringUtils.isEmpty(dirPath)) {
            return false;
        }

        if (!ftpClient.changeWorkingDirectory(dirPath)) {
            boolean flag = this.changeAndMakeWorkingDir(ftpClient, dirPath);
            if (!flag) {
                logger.error("路径切换(创建目录)失败");
                return false;
            }
        }
        return true;

    }
    /**
     * 路径切换（没有则创建）
     *
     * @param ftpClient FTP服务器
     * @param path      路径
     */
    public boolean changeAndMakeWorkingDir(FTPClient ftpClient, String path) {
        boolean flag = false;
        try {
            String[] path_array = path.split("/");
            for (String s : path_array) {
                boolean b = ftpClient.changeWorkingDirectory(s);
                if (!b) {
                    ftpClient.makeDirectory(s);
                    ftpClient.changeWorkingDirectory(s);
                }
            }
            flag = true;
        } catch (IOException e) {
            logger.error("路径切换异常", e);
        }
        return flag;
    }
</code></pre> 
<p>容易踩坑点：</p> 
<p>被动连接模式：ftpClient.enterLocalPassiveMode();</p> 
<p>被动模式是ftp打开端口客户端连接该端口来传输数据，当时看了网上大部分的写法是将改行写在</p> 
<pre>//连接ftp服务器
ftpClient.connect(host, port);
//登录ftp服务器
ftpClient.login(username, password);</pre> 
<p>这两行后面或中间，但是会发生报错。需要将连接模式设置到这两行代码前面（这是我docker的ftp是这样。但是行内的ftp，需要将该连接模式设置到login后面才生效估计是和ftp服务器也有一点关系吧）</p> 
<p><br> 主动连接模式 ：ftpClient.enterLocalActiveMode();</p> 
<p>主动连接模式是客户端开发端口提供给ftp服务器来连，如果你本地防火墙打开了。那么你会发现你能连接ftp，但是下载或上传文件后文件是空的。java默认是主动模式</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00b66e1dffc3cf170bf12c11cdc61011/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">黑群手残升级出级不能启动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39218a7b1a00bdc7686eda8fb0e71820/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">逻辑回归（Logistic Regression）测试实例：糖尿病预测项目（不调库，手工推）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>