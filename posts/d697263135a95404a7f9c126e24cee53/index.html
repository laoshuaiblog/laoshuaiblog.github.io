<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>10. 批量插入 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/d697263135a95404a7f9c126e24cee53/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="10. 批量插入">
  <meta property="og:description" content="10. 批量插入 前言 上一章节，我们使用 PreparedStatement 操作了 BLOB 字段，下面我们再来看看批量插入的操作。
批量插入 1. 批量执行SQL语句 当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率
JDBC的批量处理语句包括下面三个方法：
addBatch(String)：添加需要批量处理的SQL语句或是参数；
executeBatch()：执行批量处理语句；
clearBatch(): 清空缓存的数据
通常我们会遇到两种批量执行SQL语句的情况：
多条SQL语句的批量处理；
一个SQL语句的批量传参；
2. 高效的批量插入 举例：向数据表中插入20000条数据
数据库中提供一个goods表。创建如下：
CREATE TABLE goods( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); 测试插入数据
mysql&amp;gt; insert into goods(name) values(&#39;test&#39;); Query OK, 1 row affected (0.00 sec) mysql&amp;gt; insert into goods(name) values(&#39;test1&#39;); Query OK, 1 row affected (0.01 sec) mysql&amp;gt; select * from goods; &#43;----&#43;-------&#43; | id | NAME | &#43;----&#43;-------&#43; | 1 | test | | 2 | test1 | &#43;----&#43;-------&#43; 2 rows in set (0.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-06-08T22:24:15+08:00">
    <meta property="article:modified_time" content="2021-06-08T22:24:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">10. 批量插入</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <h2>10. 批量插入</h2> 
 <h3>前言</h3> 
 <p>上一章节，我们使用 PreparedStatement 操作了 BLOB 字段，下面我们再来看看批量插入的操作。</p> 
 <h3>批量插入</h3> 
 <h4>1.  批量执行SQL语句</h4> 
 <p>当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p> 
 <p>JDBC的批量处理语句包括下面三个方法：</p> 
 <ul><li> <p>addBatch(String)：添加需要批量处理的SQL语句或是参数；</p> </li><li> <p>executeBatch()：执行批量处理语句；</p> </li><li> <p>clearBatch(): 清空缓存的数据</p> </li></ul> 
 <p>通常我们会遇到两种批量执行SQL语句的情况：</p> 
 <ul><li> <p>多条SQL语句的批量处理；</p> </li><li> <p>一个SQL语句的批量传参；</p> </li></ul> 
 <h4>2.  高效的批量插入</h4> 
 <p>举例：向数据表中插入20000条数据</p> 
 <ul><li> <p>数据库中提供一个goods表。创建如下：</p> </li></ul> 
 <pre class="has"><code class="language-go">CREATE TABLE goods(
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(20)
);
</code></pre> 
 <ul><li> <p>测试插入数据</p> </li></ul> 
 <pre class="has"><code class="language-go">mysql&gt; insert into goods(name) values('test');
Query OK, 1 row affected (0.00 sec)

mysql&gt; insert into goods(name) values('test1');
Query OK, 1 row affected (0.01 sec)

mysql&gt; select * from goods;
+----+-------+
| id | NAME  |
+----+-------+
|  1 | test  |
|  2 | test1 |
+----+-------+
2 rows in set (0.00 sec)

mysql&gt; 
</code></pre> 
 <p>2.1 实现层次一：使用Statement插入20000条数据</p> 
 <pre class="has"><code class="language-go">    //实现层次一：使用Statement
    //向数据表中插入20000条数据
    @Test
    public void test01() throws Exception {
        //1.获取连接
        Connection conn = JDBCUtils.getConnection();
        Statement st = conn.createStatement();

        //2.执行插入数据
//        String sql = "insert into goods(name) values('test1')";
//        st.executeUpdate(sql);
        //向数据表中插入20000条数据
        for (int i = 1; i &lt;= 20000; i++) {
            String sql = "insert into goods(name) values('test " + i +"')";
            st.executeUpdate(sql);
        }
    }
</code></pre> 
 <p>测试执行如下：</p> 
 <img alt="" src="https://images2.imgbox.com/51/b6/tm7Wf1R1_o.png"> 
</div> 
<figcaption>
  image-20201021224530188 
</figcaption> 
<p>执行之后的mysql数据：</p> 
<pre class="has"><code class="language-go">mysql&gt; select * from goods limit 10;
+----+--------+
| id | NAME   |
+----+--------+
|  3 | test1  |
|  4 | test1  |
|  5 | test 1 |
|  6 | test 2 |
|  7 | test 3 |
|  8 | test 4 |
|  9 | test 5 |
| 10 | test 6 |
| 11 | test 7 |
| 12 | test 8 |
+----+--------+
10 rows in set (0.00 sec)

mysql&gt; select count(1) from goods limit 10;
+----------+
| count(1) |
+----------+
|    20002 |
+----------+
1 row in set (0.00 sec)
</code></pre> 
<p>2.2 实现层次二：使用PreparedStatement插入20000条数据</p> 
<p>在上面可以看到耗时挺久的，下面我们改用 PreparedStatement 来插入数据看看。</p> 
<pre class="has"><code class="language-go">//实现层次二：使用PreparedStatement插入20000条数据
@Test
public void test02() throws Exception {
    //1.记录执行开始时间
    long start = System.currentTimeMillis();

    //2.获取数据库连接
    Connection conn = JDBCUtils.getConnection();

    //3.预编译SQL
    String sql = "insert into goods(name) values(?)";
    PreparedStatement ps = conn.prepareStatement(sql);

    //4.设置插入数据以及执行
    for (int i = 1; i &lt;= 20000; i++) {
        ps.setString(1, "test" + i);
        ps.executeUpdate();
    }

    //5.计算结束时间
    long end = System.currentTimeMillis();
    System.out.println("花费的时间为：" + (end - start));//

    //6.关闭资源
    JDBCUtils.closeResource(conn, ps);
}
</code></pre> 
<p>测试执行如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/68/b5/heDNOC3F_o.png"></p> 
<figcaption>
  image-20201021232054150 
</figcaption> 
<p>2.3 实现层次三：优化效率，将逐条SQL执行 改为 批处理执行</p> 
<ul><li> <p>配置mysql启用批处理执行 rewriteBatchedStatements=true</p> </li></ul> 
<p><img alt="" src="https://images2.imgbox.com/82/12/c3S5EKZI_o.png"></p> 
<figcaption>
  image-20201021233244936 
</figcaption> 
<pre class="has"><code class="language-go">user=root
password=*****
url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false
driverClass=com.mysql.cj.jdbc.Driver
</code></pre> 
<ul><li> <p>测试代码</p> </li></ul> 
<pre class="has"><code class="language-go">/**
 * 实现层次三：使用PreparedStatement插入20000条数据
 * 修改1：使用 addBatch() / executeBatch() / clearBatch()
 * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。
 *         ?rewriteBatchedStatements=true 写在配置文件的url后面
 *
 *
 * @throws Exception
 */
@Test
public void test03() throws Exception {
    //1.记录执行开始时间
    long start = System.currentTimeMillis();

    //2.获取数据库连接
    Connection conn = JDBCUtils.getConnection();

    //3.预编译SQL
    String sql = "insert into goods(name) values(?)";
    PreparedStatement ps = conn.prepareStatement(sql);

    //4.设置插入数据以及执行
    for (int i = 1; i &lt;= 20000; i++) {
        ps.setString(1, "test" + i);

        //执行批处理
        //1.“攒”sql
        ps.addBatch();
        if(i % 500 == 0){ // 当达到500，则开始批处理
            //2.执行
            ps.executeBatch();
            //3.清空
            ps.clearBatch();
        }
    }

    //5.计算结束时间
    long end = System.currentTimeMillis();
    System.out.println("花费的时间为：" + (end - start));//

    //6.关闭资源
    JDBCUtils.closeResource(conn, ps);
}
</code></pre> 
<p>执行测试如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/03/d1/nq28Pq85_o.png"></p> 
<figcaption>
  image-20201021233428872 
</figcaption> 
<p>2.4 实现层次四：优化效率，将批处理的多次提交 设置为 最后统一 commit() 提交</p> 
<p><img alt="" src="https://images2.imgbox.com/a5/9a/gUYmUWu6_o.png"></p> 
<figcaption>
  image-20201021233743941 
</figcaption> 
<pre class="has"><code class="language-go">/**
 * 实现层次四：优化效率，将批处理的多次提交 设置为 最后统一 commit() 提交
 * 使用Connection 的 setAutoCommit(false)  /  commit()
 *
 * @throws Exception
 */
@Test
public void test04() throws Exception {
    //1.记录执行开始时间
    long start = System.currentTimeMillis();

    //2.获取数据库连接
    Connection conn = JDBCUtils.getConnection();

    //1.设置为不自动提交数据
    conn.setAutoCommit(false);

    //3.预编译SQL
    String sql = "insert into goods(name) values(?)";
    PreparedStatement ps = conn.prepareStatement(sql);

    //4.设置插入数据以及执行
    for (int i = 1; i &lt;= 20000; i++) {
        ps.setString(1, "test" + i);

        //执行批处理
        //1.“攒”sql
        ps.addBatch();
        if(i % 500 == 0){ // 当达到500，则开始批处理
            //2.执行
            ps.executeBatch();
            //3.清空
            ps.clearBatch();
        }
    }

    //2.提交数据
    conn.commit();

    //5.计算结束时间
    long end = System.currentTimeMillis();
    System.out.println("花费的时间为：" + (end - start));//

    //6.关闭资源
    JDBCUtils.closeResource(conn, ps);
}
</code></pre> 
<p>测试执行如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/ae/0e/HIi6Zxv0_o.png"></p> 
<figcaption>
  image-20201021233840943 
</figcaption>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/daccfb2afbc823d3f3591868c9603d8b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">9. 操作BLOB类型字段</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac5b20e73bc98adf86321892dc9faf84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL索引：BST、AVL、红黑树，B-树、B&#43;树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>