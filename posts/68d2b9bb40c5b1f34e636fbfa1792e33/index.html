<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>全面盘点17个C&#43;&#43;17的高级特性 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/68d2b9bb40c5b1f34e636fbfa1792e33/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="全面盘点17个C&#43;&#43;17的高级特性">
  <meta property="og:description" content="全面盘点17个C&#43;&#43;17的高级特性 C&#43;&#43;17是目前比较常用的版本之一，今天花时间来梳理一下17个重要特性，所有的特性也不止这么点。
目录
1. 并行算法
2. If Initializers
3. 类模板参数推导（CTAD）
4. template `&amp;lt;auto&amp;gt;`
5. std::optional 和 std::variant
6. 折叠表达式
7. 结构化绑定
8.模板模板参数
9. 内联变量
10. 属性改进
11. 嵌套命名空间
12. 字面量改进
13. constexpr lambda
14. 捕获*this
15. 扩展的if和switch语句
16. 泛化的基于范围的for循环
17. if constexpr
总结
1. 并行算法 C&#43;&#43;17引入了许多并行版本的标准库中的算法。这些算法可以并行执行，因此在多核系统上可能会带来显著的性能提升。
之前写过一篇全面介绍这个特性的文章，可以看这篇：未来已来：C&#43;&#43;17 并行STL性能测评
例子：
#include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;execution&amp;gt; int main() { std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5}; std::sort(std::execution::par, v.begin(), v.end()); } 在此例子中，std::sort是并行执行的，以并行方式对向量v的元素进行排序。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-21T11:54:53+08:00">
    <meta property="article:modified_time" content="2024-03-21T11:54:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">全面盘点17个C&#43;&#43;17的高级特性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <h4>全面盘点17个C++17的高级特性</h4> 
 <p>C++17是目前比较常用的版本之一，今天花时间来梳理一下17个重要特性，所有的特性也不止这么点。</p> 
 <p>目录</p> 
 <ul><li><p>1. 并行算法</p></li><li><p>2. If Initializers</p></li><li><p>3. 类模板参数推导（CTAD）</p></li><li><p>4. template `&lt;auto&gt;`</p></li><li><p>5. std::optional 和 std::variant</p></li><li><p>6. 折叠表达式</p></li><li><p>7. 结构化绑定</p></li><li><p>8.模板模板参数</p></li><li><p>9. 内联变量</p></li><li><p>10. 属性改进</p></li><li><p>11. 嵌套命名空间</p></li><li><p>12. 字面量改进</p></li><li><p>13. constexpr lambda</p></li><li><p>14. 捕获*this</p></li><li><p>15. 扩展的if和switch语句</p></li><li><p>16. 泛化的基于范围的for循环</p></li><li><p>17. if constexpr</p></li><li><p>总结</p></li></ul> 
 <h4>1. 并行算法</h4> 
 <p>C++17引入了许多并行版本的标准库中的算法。这些算法可以并行执行，因此在多核系统上可能会带来显著的性能提升。</p> 
 <p>之前写过一篇全面介绍这个特性的文章，可以看这篇：<a href="" rel="nofollow">未来已来：C++17 并行STL性能测评</a></p> 
 <p>例子：</p> 
 <pre class="has"><code class="language-go">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;execution&gt;
int main() {
    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
    std::sort(std::execution::par, v.begin(), v.end());
}</code></pre> 
 <p>在此例子中，<code>std::sort</code>是并行执行的，以并行方式对向量<code>v</code>的元素进行排序。</p> 
 <h4>2. If Initializers</h4> 
 <p>C++17中的If初始化器是一项特性，它允许在if语句中直接初始化变量。这种初始化方式在一定程度上可以提高代码的可读性和简洁性。</p> 
 <p>在传统的C++中，我们通常会这样初始化变量：</p> 
 <pre class="has"><code class="language-go">int x;
if (condition) {
    x = 42;
} else {
    x = 24;
}</code></pre> 
 <p>而在C++17中，可以使用if初始化器来简化这个过程，使代码更加紧凑：</p> 
 <pre class="has"><code class="language-go">if (bool condition = /* some condition */) {
    int x = 42;
} else {
    int x = 24;
}</code></pre> 
 <p>在这个例子中，我们将变量<code>x</code>的初始化直接放在if语句中。变量<code>condition</code>在if语句中被定义和初始化，然后在if语句块中可用。这种方式更加直观和简洁，尤其是在简单的条件初始化时。</p> 
 <h4>3. 类模板参数推导（CTAD）</h4> 
 <p>CTAD 让编译器从类参数中自动推导出模板参数。这使得在不必显式指定模板参数的情况下更容易地使用模板。</p> 
 <p>往期对这个特性的全面阐述文章：<a href="" rel="nofollow">C++17那些事开篇之类模版参数推导(CTAD)</a></p> 
 <p>例如下面函数模版的例子(C++17之前)：</p> 
 <pre class="has"><code class="language-go">template &lt;typename T&gt;
void foo(T t) {
    // ...
}

int main() {
    foo(42);  // 编译器推导出T的类型为int
}</code></pre> 
 <p>在此例子中，当调用<code>foo(42)</code>时，编译器推导出<code>T</code>的类型是<code>int</code>.</p> 
 <h4>4. template <code>&lt;auto&gt;</code></h4> 
 <p>模板关键词被引入为非类型模板参数的占位符。它允许在模板中表示任何类型的值。</p> 
 <p>例子：</p> 
 <pre class="has"><code class="language-go">template&lt;auto value&gt;
struct constant {
    static constexpr auto get_value() { return value; }
};

// 用法
static_assert(constant&lt;42&gt;::get_value() == 42);</code></pre> 
 <h4>5. std::optional 和 std::variant</h4> 
 <p><code>std::optional</code> 和 <code>std::variant</code> 是C++17中引入的两个新类型。<code>std::optional</code> 表示一个可能存在也可能不存在的值，<code>std::variant</code> 代表一个类型安全的联合，可以保存不同类型的值。</p> 
 <p>例子：</p> 
 <pre class="has"><code class="language-go">#include &lt;optional&gt;
#include &lt;variant&gt;

int main() {
    std::optional&lt;int&gt; opt = 42;
    std::variant&lt;int, double&gt; var = 3.14;
}</code></pre> 
 <p>在这个例子中，<code>opt</code>是包含值42的可选整数，<code>var</code>是包含值3.14的变体。</p> 
 <h4>6. 折叠表达式</h4> 
 <p>在C++17中，折叠表达式提供了一种简洁的方式，用于对参数包执行二元操作。它们允许在不需要显式递归或迭代的情况下执行诸如求和、乘法或连接参数包中元素的操作。</p> 
 <p>例如：</p> 
 <pre class="has"><code class="language-go">#include &lt;iostream&gt;

template&lt;typename T&gt;
T sum(T t) {
    return t;
}

// 使用折叠表达式的递归情况
template&lt;typename T, typename... Args&gt;
T sum(T first, Args... args) {
    return first + sum(args...);
}

int main() {
    int total = sum(1, 2, 3, 4, 5);
    std::cout &lt;&lt; "总和: " &lt;&lt; total &lt;&lt; std::endl;
    
    return 0;
}</code></pre> 
 <p>递归<code>sum</code>函数中的折叠表达式<code>(first + ... + args)</code>对参数包中的每个元素应用了加法操作。</p> 
 <h4>7. 结构化绑定</h4> 
 <p>结构化绑定允许你将对象分解成其构成元素，类似于你可能会用到的元组拆包。</p> 
 <p>往期文章：<a href="" rel="nofollow">C++17结构化绑定</a></p> 
 <p>例子：</p> 
 <pre class="has"><code class="language-go">#include &lt;tuple&gt;
#include &lt;string&gt;
int main() {
    std::tuple&lt;int, std::string, double&gt; t(42, "hello", 3.14);
    auto [i, s, d] = t;  // i = 42, s = "hello", d = 3.14
}</code></pre> 
 <p>在此例子中，结构化绑定<code>[i, s, d]</code>将元组<code>t</code>分解成其构成元素。</p> 
 <h4>8.模板模板参数</h4> 
 <p>例如：在C++17中，语法 <code>template&lt;template&lt;class...&gt;typename bob&gt; struct foo {}</code> 声明了一个名为 <code>foo</code> 的模板，它接受一个名为 <code>bob</code> 的模板模板参数。模板模板参数 <code>bob</code> 本身接受任意数量的模板类型参数。</p> 
 <pre class="has"><code class="language-go">template &lt;template&lt;class...&gt; typename bob&gt;
struct foo {
    template&lt;typename T&gt;
    void bar(const bob&lt;T&gt;&amp; arg) {
        std::cout &lt;&lt; "size: " &lt;&lt; arg.size() &lt;&lt; std::endl;
    }
};

int main() {
    foo&lt;std::vector&gt; f;
    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    f.bar(vec);

    return 0;
}</code></pre> 
 <p>在 <code>main</code> 函数中，我们使用 <code>std::vector</code> 实例化了 <code>foo</code>，将其作为 <code>bob</code> 的模板参数。这使我们能够创建一个通用的结构 <code>foo</code>，可以与任何接受任意数量类型参数的模板一起工作，例如 <code>std::vector</code>、<code>std::list</code> 或用户定义的模板。</p> 
 <h4>9. 内联变量</h4> 
 <p>C++17允许在类的定义内部定义变量为内联的，这可以帮助减小二进制大小，可能通过防止变量在多个转换单元中的重复副本来提高性能。</p> 
 <p>例子：</p> 
 <pre class="has"><code class="language-go">class MyClass {
public:
    inline static int inlineVar = 42;
};

int main() {
    int localVar = MyClass::inlineVar;
}</code></pre> 
 <p>在这里，<code>inlineVar</code>是<code>MyClass</code>的内联静态成员变量。</p> 
 <h4>10. 属性改进</h4> 
 <p>C++17提供新的属性，并改进了已有的属性，允许开发人员为编译器提供更多的代码行为信息。</p> 
 <p>例子：</p> 
 <pre class="has"><code class="language-go">[[nodiscard]] int get_sum(int a, int b) {
    return a + b;
}

int main() {
    auto result = get_sum(1, 2);
    // 编译器可能会警告‘result’未使用
}</code></pre> 
 <p>在此例子中，<code>[[nodiscard]]</code>是可以应用于函数的属性，表示其返回值不应该被调用者丢弃。</p> 
 <h4>11. 嵌套命名空间</h4> 
 <p>C++17通过折叠表达式增强了变参模板，使得在处理参数包时的代码更为简洁和表达明了。</p> 
 <p>例子：</p> 
 <pre class="has"><code class="language-go">// 外部命名空间
namespace outer {
    // 内部命名空间
    namespace inner {
        void foo() {
            std::cout &lt;&lt; "在内部命名空间中" &lt;&lt; std::endl;
        }
    }
}

outer::inner::foo();</code></pre> 
 <p>嵌套命名空间定义提供了一种将代码层次化组织的方式，提高了可读性和可维护性，尤其是在大型项目中。它们还通过提供更加结构化的命名空间层次结构来帮助避免命名冲突。</p> 
 <h4>12. 字面量改进</h4> 
 <p>C++17增强了字面量，包括对整数和浮点字面量的改进，以及对真和假字面量的支持。</p> 
 <p>例子：</p> 
 <pre class="has"><code class="language-go">auto num = 123_456; // Underscore in integer literals  
auto pi = 3.1415_f; // Suffix for floating-point literals</code></pre> 
 <h4>13. constexpr Lambda</h4> 
 <p>C++17允许lambda函数成为constexpr，如果它们满足条件，就可以在需要编译时评估的上下文中使用，例如：</p> 
 <pre class="has"><code class="language-go">constexpr auto lambda = [](int x) { return x * 2; };
static_assert(lambda(5) == 10);</code></pre> 
 <p>在这个例子中，<code>lambda</code>是一个constexpr lambda，它接受一个整数x作为参数，然后返回x的两倍。<code>static_assert</code>检查在编译时，<code>lambda(5)</code>的值是否等于10。</p> 
 <h4>14. 捕获*this</h4> 
 <p>在lambda中捕获*this变得更加简单，允许直接访问包含对象的成员。</p> 
 <pre class="has"><code class="language-go">class Foo {
    int data = 42;
public:
    auto member_lambda() {
        return [*this] { std::cout &lt;&lt; data &lt;&lt; std::endl; };
    }
};

// 使用
Foo f;
f.member_lambda()(); // 输出 "42"</code></pre> 
 <h4>15. 扩展的if和switch语句</h4> 
 <p><code>if</code>或<code>switch</code>语句中的条件现在可以是任何表达式，不仅限于布尔条件。这使得控制流更加灵活，例如使用结构化绑定时：</p> 
 <pre class="has"><code class="language-go">if (const auto [it, inserted] = map.insert({"foo", bar}); inserted) {
    // ...
}</code></pre> 
 <p>在此例子中，<code>if</code>语句检查<code>inserted</code>变量是否为真，但条件还包括结构化绑定的赋值。</p> 
 <h4>16. 泛化的基于范围的for循环</h4> 
 <p>此改进支持不同于起始迭代器类型的标志或结束迭代器，这有助于处理以空终止的循环和其他类似情况。例如：</p> 
 <pre class="has"><code class="language-go">for (auto it = my_container.begin(); it != my_container.end(); ++it) {
   // ...
}</code></pre> 
 <p>在此例子中，<code>my_container</code>可能是使用不同类型的结束迭代器的容器，但循环仍然可以正确工作。</p> 
 <h4>17. if constexpr</h4> 
 <p>此特性通过允许编译器在编译时评估条件，从而实现更通用的代码。如果条件为真，则编译的代码中包含<code>if</code>块内的代码；否则，它将被丢弃。这可以通过在运行时删除不必要的分支来简化代码。例如：</p> 
 <pre class="has"><code class="language-go">if constexpr (std::is_same_v&lt;T, int&gt;) {
   // 用于int的特定代码
} else {
   // 用于其他类型的代码
}</code></pre> 
 <p>在这个例子中，<code>if constexpr</code>语句检查类型<code>T</code>是否为<code>int</code>，并相应地包含适当的代码。</p> 
 <h4>总结</h4> 
 <p>本节就先写这么多，其他内容下一节进行阐述。</p> 
 <hr> 
 <p><a href="" rel="nofollow">热度更新，手把手实现工业级线程池</a></p> 
 <p><a href="" rel="nofollow">快速拿下面试算法</a><br></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/8d/15/YiBleTVV_o.jpg" alt="6718a448a98d5abcf58ace50a61b695d.jpeg"></p> 
 <p><img src="https://images2.imgbox.com/ab/c0/VLN2tuub_o.jpg" alt="51e5e7b1ea90127e1c1b083e345f61ef.jpeg"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c08956cd553a8030d929c1dd5fc65552/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp微信小程序_购物车_下单页面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b18b05eecba1b618714e2dc8053204c2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C语言】指针&amp;&amp;二级指针&amp;&amp;数组指针&amp;&amp;指针数组详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>