<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>4.4 算 符 优 先 分 析 法 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/00a97761a324283b5aff54a6bef45700/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="4.4 算 符 优 先 分 析 法">
  <meta property="og:description" content="4.4 算 符 优 先 分 析 法 4.4.1 方法概述
所谓算符优先分析法就是依照算术表达式的四则运算过程而设计的一种语法分析方法。
这种分析方法首先要规定运算符之间(确切地说是终结符之间)的优先关系和结合性质,然后借助这种关系,比较相邻运算符的优先级来确定句型的可归约串并进行归约。
下面,以表达式的文法为例,说明采用这种分析法分析符号串 id &#43; id * id 的分析过程。
例如,文法 G [ E ]为
E → E &#43; E | E * E | ( E ) | id 这个文法是一个二义性文法,因而对句子 id &#43; id * id 有两种不同的规范归约,也就是在归约过程中句型的句柄不唯一。
句子 id &#43; id * id 的两种不同的规范归约过程如下:
第一个规范归约过程 第二个规范归约过程 (1 ) id &#43; id * id	(1 ) id &#43; id * id (2 ) E &#43; id * id	(2 ) E &#43; id * id (3 ) E &#43; E * id	(3 ) E &#43; E * id (4 ) E &#43; E * E	(4 ) E * id (5 ) E &#43; E	(5 ) E * E (6 ) E	(6 ) E 分析上述归约过程,句型 E &#43; E * id 在第一个规范归约中 id 是它的句柄;而在第二个规范归约中 E &#43; E 是它的句柄。此现象是由于没有定义运算符 &#43; 和 * 的优先关系而引起的。在第一个规范归约中是假定 * 优先于 &#43; ,所以不能立即把 E &#43; E 归约为 E ;而在第二个规范归约中是假定 &#43; 优先于 * ,因此必须先把 E &#43; E 归约为 E 。可见上述归约过程中起决定作用的是相邻两个终结符号之间的优先关系。于是算符优先分析法的关键在于用合适的方法去定义任何两个可能相邻出现的终结符号 a 和 b 之间的优先关系。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-08-07T15:34:17+08:00">
    <meta property="article:modified_time" content="2020-08-07T15:34:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">4.4 算 符 优 先 分 析 法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="44_________0"></a>4.4 算 符 优 先 分 析 法</h3> 
<p><strong>4.4.1 方法概述</strong></p> 
<p><strong>所谓算符优先分析法就是依照算术表达式的四则运算过程而设计的一种语法分析方法</strong>。</p> 
<p>这种分析方法首先要规定运算符之间(确切地说是终结符之间)的优先关系和结合性质,然后借助这种关系,比较相邻运算符的优先级来确定句型的可归约串并进行归约。</p> 
<p>下面,以表达式的文法为例,说明采用这种分析法分析符号串 id + id * id 的分析过程。</p> 
<p>例如,文法 G [ E ]为</p> 
<pre><code>E → E + E | E * E | ( E ) | id
</code></pre> 
<p>这个文法是一个二义性文法,因而对句子 id + id * id 有两种不同的规范归约,也就是在归约过程中句型的句柄不唯一。</p> 
<p>句子 id + id * id 的两种不同的规范归约过程如下:</p> 
<pre><code>第一个规范归约过程           第二个规范归约过程
(1 ) id + id * id			(1 ) id + id * id
(2 ) E + id * id			(2 ) E + id * id
(3 ) E + E * id				(3 ) E + E * id
(4 ) E + E * E				(4 ) E * id
(5 ) E + E					(5 ) E * E
(6 ) E						(6 ) E
</code></pre> 
<p>分析上述归约过程,句型 E + E * id 在第一个规范归约中 id 是它的句柄;而在第二个规范归约中 E + E 是它的句柄。此现象是由于没有定义运算符 + 和 * 的优先关系而引起的。在第一个规范归约中是假定 * 优先于 + ,所以不能立即把 E + E 归约为 E ;而在第二个规范归约中是假定 + 优先于 * ,因此必须先把 E + E 归约为 E 。可见上述归约过程中起决定作用的是相邻两个终结符号之间的优先关系。于是算符优先分析法的关键在于用合适的方法去定义任何两个可能相邻出现的终结符号 a 和 b 之间的优先关系。</p> 
<p>任何两个相邻终结符号 a 和 b 之间的优先关系有 3 种:</p> 
<pre><code>a &lt;· b	 a 的优先级低于 b
a =· b	 a 的优先级等于 b
a &gt;· b	a 的优先级高于 b
</code></pre> 
<p>注意,优先关系与出现的左右次序有关,这一点不同于数学中的 &lt; , = 和 &gt; 。例如,a &lt;· b不一定有 b &gt; · a 。通常表达式中运算符的优先关系有( &lt; · + 但没有 +&gt; ·(而是有 +&lt; ·(。</p> 
<p>一个文法的终结符号之间的优先关系可用一个矩阵来表示,矩阵的每一行每一列都是文法的终结符,矩阵元素是两终结符之间可能的优先关系。算符优先分析法借助优先关系矩阵(也称优先关系表,简称优先表)寻找句型的可归约串。</p> 
<p>需要指出的是,算符优先分析法并不是对所有的文法都适合,它对文法有一定的要求,要求文法是算符优先文法,也就是说,只有当描述语言的文法是算符优先文法,才能采用算符优先分析法进行语法分析。</p> 
<p>4.4.2 <strong>算符优先文法的定义</strong></p> 
<ol><li><strong>算符文法的定义</strong></li></ol> 
<p>设有文法 G ,若 G 中没有形如 U → … VW … 的规则,其中 V 和 W 为非终结符,则称 G 为算符文法,也称 OG 文法。也就是说,在算符文法中,任何一个规则右部都不存在两个非终结符相<br> 邻的情况,由定义可知,算符文法具有两个重要的性质(不证明,仅给出结论)。</p> 
<pre><code>性质 1 在算符文法中任何句型都不含两个相邻的非终结符。
性质 2 若 Ab 或 bA 出现在算符文法的句型 β 中,其中 A ∈ V N ,b ∈ V T ,则 β 中任何含 b的短语必含有 A 。
</code></pre> 
<ol start="2"><li><strong>定义任意两个终结符号之间的优先关系</strong></li></ol> 
<p>设 G 是一个算符文法,a 和 b 是任意两个终结符, P , Q , R 是非终结符,算符优先关系 &lt;·,·, &gt; ·定义如下:</p> 
<pre><code>(1 ) a= · b 当且仅当 G 中含有形如 P → … ab … 或 P → … aQb 的规则。

(2 ) a &lt;· b 当且仅当 G 中含有形如 P → … aR … 的规则,且 R ⇒+ b … 或 R ⇒ + Qb …。

(3 ) a &gt;· b 当且仅当 G 中含有形如 P → … Rb … 的规则,且 R ⇒+… a 或 R ⇒+… aQ 。
</code></pre> 
<p><strong>3. 算符优先文法的定义</strong></p> 
<p><strong>设有一个不含 ε 规则的算符文法 G ,如果任意两个终结符号对(a , b )在 &lt;·、 &gt; ·和 · 3 种关系中只有一种关系成立,则称 G 是算符优先文法,也称 OPG 文法</strong>。</p> 
<p>对前述算术表达式的文法<br> E → E + E | E * E | ( E ) | id<br> 由算符文法和算符优先文法的定义,我们不难证明该文法是一个算符文法,但不是算符优先文法。因为该文法的任一规则右部都不包含两个相邻的非终结符,所以该文法是算符文法。但是,由于 E → E + E 和 E ⇒+ E * E ,有+&lt;· * ,又由于 E → E * E 和 E ⇒+ E + E有 +&gt; · * ,即运算符 + 和 * 之间存在两种不同的优先关系,所以该表达式的文法只是算符文法而不是算符优先文法。</p> 
<p>若算术表达式的文法为</p> 
<pre><code>E → E + T | T
T → T * F | F
F → ( E ) | id
</code></pre> 
<p>显然,该算术表达式的文法是算符优先文法。</p> 
<p>4.4.3 <strong>算符优先关系表的构造</strong></p> 
<p>对算符优先文法,根据优先关系的定义,可按如下方法直接构造优先关系表。</p> 
<p>首先对文法每个非终结符 A 定义两个集合:</p> 
<pre><code>FIRSTVT ( A ) = { b | A ⇒+ b … 或A ⇒+ Bb …,b ∈ V T , B ∈ V N }

LASTVT ( A ) = { a | A ⇒+… a 或 A ⇒+… aB ,a ∈ V T , B ∈ V N }
</code></pre> 
<p>使用这两个集合,构造文法 G 的优先关系表的算法如下。</p> 
<pre><code>输入:算符优先文法 G 。

输出:关于文法 G 的优先关系表。
</code></pre> 
<p>方法:</p> 
<p>(1 )为每个非终结符 A 计算 FIRSTVT ( A )和 LASTVT ( A )。</p> 
<p>(2 )执行程序</p> 
<pre><code></code></pre> 
<pre><code>for (每个产生式 A → x 1 x 2 … x n )
for ( i =1 ; i &lt;= n -1 ; i ++ )
{ if (
x i ∈ V T 且 x i +1 ∈ V T )置 x i · x i +1 ;
if ( i &lt;= n -2 且 x i ∈ V T 、 x i +2 ∈ V T ,而 x i +1 ∈ V N )置 x i · x i +2 ;
if ( x i ∈ V T , x i +1 ∈ V N )
for ( FIRSTVT ( x i +1 )中的每个 b )置 x i &lt; · b ;
if ( x i ∈ V N , x i +1 ∈ V T )
for ( LASTVT ( x i )中的每个 a )置 a &gt;· x
i +1 ;
}
</code></pre> 
<p>(3 )对 FIRSTVT ( S )中的所有 b ,置 $ &lt;· b ;对 LASTVT ( S )中的所有 a ,置 a &gt; · $ ;置 $ · $ ( S 为文法开始符号)。</p> 
<pre><code></code></pre> 
<p>【例 4.12 】<br> 设有表达式的文法 G [ E ]:</p> 
<pre><code>E → E + T | T
T → T * F | F
F → ( E ) | id
</code></pre> 
<p>构造该文法的算符优先关系表。<br> 首先计算每个非终结符的 FIRSTVT 和 LASTVT ：<img src="https://images2.imgbox.com/76/95/ck1esLS3_o.png" alt="在这里插入图片描述"><br> 执行算法,逐条扫描文法规则,因有 E → ( E )的规则,则有(· )。<br> 寻找终结符在左边,非终结符在右边的符号对有</p> 
<pre><code>+ T 则 +&lt;· FIRSTVT ( T )
* F 则 * &lt;· FIRSTVT ( F )
( E 则( &lt;· FIRSTVT ( E )
</code></pre> 
<p>寻找非终结符在左边,终结符在右边的符号对有</p> 
<pre><code>E + 则 LASTVT ( E ) &gt;·+

T * 则 LASTVT ( T ) &gt;·*

E )则 LASTVT ( E ) &gt;· )
</code></pre> 
<p>最后,对 $ 有 $ · $ , $ &lt; · FIRSTVT ( E ), LASTVT ( E ) &gt; · $ ,从而构造出文法 G [ E ]的算符优先关系表如表 4.4 所示。</p> 
<p><img src="https://images2.imgbox.com/62/c1/lXGahSSM_o.png" alt="在这里插入图片描述"><br> 4.4.4 <strong>算符优先分析算法的设计</strong></p> 
<p>对于算符优先分析法,它虽然是一种自下而上的语法分析方法,但它并不是一种规范归约的分析方法。这是因为在算符优先文法中,仅在终结符号之间定义优先关系而未对非终结符定义优先关系,从而无法使用优先关系表去识别由单个非终结符组成的可归约串,也就是说,算符优先分析法不是用句柄来刻画可归约串,而是用最左素短语来刻画可归约串的。</p> 
<ol><li><strong>最左素短语</strong></li></ol> 
<p>所谓句型的<strong>素短语是指这样一种短语,它至少包含一个终结符,并且除自身之外,不再包含其他的素短语</strong>。句型最左边的素短语称为最左素短语。</p> 
<p>例如,考虑例 4.12 中的文法 G [ E ]的句型 T + T * F + id 的素短语和最左素短语。<br> 首先给出句型 T + T * F + id 的语法树,见图 4.5 。<br> <img src="https://images2.imgbox.com/58/87/Ht2xJevt_o.png" alt="在这里插入图片描述"></p> 
<p>由素短语定义可知 T * F 和 id 是素短语。 T * F 为最左素短语(注意: T 是该句型的句柄,而不是素短语)。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9fa05bc24da4d0df804010d5e4bf941/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IDEA里 java.lang.ClassNotFoundException: com.mysql.jdbc.Driver 问题解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3bfda2444a4b9c7b9ae9a220b0d7c441/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">二进制数表示法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>