<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux】程序的编译 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/7358f9b939541ab74c2f8bee99164585/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【Linux】程序的编译">
  <meta property="og:description" content="今天我们来介绍一下程序的编译过程 以及 一些相关的知识
目录 1. 程序环境2. 编译与链接2.1 编译2.2.1 预编译（预处理）2.2.2 编译2.2.3 汇编 2.2 链接 3. 预处理3.1 预定义符号3.2 #define3.2.1 #define 定义标识符3.2.2 #define 定义宏3.2.3 #define 替换规则3.2.4 # 与 #\#3.2.5 宏参数的副作用3.2.6 宏与函数的对比3.2.7 关于宏的一些练习 3.3 #undef3.4 命令行定义3.5 条件编译3.6 文件包含3.6.1 头文件被包含的方式3.6.2 嵌套文件包含 3.7 其他预处理命令 1. 程序环境 在 ANSI C的任何一种实现中，存在两个不同的环境。
第一种是翻译环境，在这个环境之中源代码被转化为可执行的机器指令
第二种是执行环境，它用于实际的执行代码
其中翻译环境可以分为 编译过程 和 链接过程。 编译可以分为 预处理，编译 ，汇编过程。接下来我们会对每一步进行比较详细的介绍。
2. 编译与链接 我们先创建一个文件test.c:
2.1 编译 2.2.1 预编译（预处理） gcc test.c -E &amp;gt; test.i 我们可以打开test.i来看一下，我们发现多出了许多内容，这是为什么？
其中有两部分比较值得我们注意：
在预处理阶段：
完成了头文件的包含#define 定义的符号和宏会被替换删除注释 2.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-05-11T22:29:12+08:00">
    <meta property="article:modified_time" content="2022-05-11T22:29:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux】程序的编译</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>今天我们来介绍一下程序的编译过程 以及 一些相关的知识</p> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1__3" rel="nofollow">1. 程序环境</a></li><li><a href="#2__13" rel="nofollow">2. 编译与链接</a></li><li><ul><li><a href="#21__20" rel="nofollow">2.1 编译</a></li><li><ul><li><a href="#221__24" rel="nofollow">2.2.1 预编译（预处理）</a></li><li><a href="#222__40" rel="nofollow">2.2.2 编译</a></li><li><a href="#223__55" rel="nofollow">2.2.3 汇编</a></li></ul> 
   </li><li><a href="#22__81" rel="nofollow">2.2 链接</a></li></ul> 
  </li><li><a href="#3__101" rel="nofollow">3. 预处理</a></li><li><ul><li><a href="#31__102" rel="nofollow">3.1 预定义符号</a></li><li><a href="#32_define_115" rel="nofollow">3.2 #define</a></li><li><ul><li><a href="#321_define__116" rel="nofollow">3.2.1 #define 定义标识符</a></li><li><a href="#322_define__158" rel="nofollow">3.2.2 #define 定义宏</a></li><li><a href="#323_define__212" rel="nofollow">3.2.3 #define 替换规则</a></li><li><a href="#324____244" rel="nofollow">3.2.4 # 与 #\#</a></li><li><a href="#325__289" rel="nofollow">3.2.5 宏参数的副作用</a></li><li><a href="#326__309" rel="nofollow">3.2.6 宏与函数的对比</a></li><li><a href="#327__338" rel="nofollow">3.2.7 关于宏的一些练习</a></li></ul> 
   </li><li><a href="#33_undef_403" rel="nofollow">3.3 #undef</a></li><li><a href="#34__411" rel="nofollow">3.4 命令行定义</a></li><li><a href="#35__448" rel="nofollow">3.5 条件编译</a></li><li><a href="#36__497" rel="nofollow">3.6 文件包含</a></li><li><ul><li><a href="#361__504" rel="nofollow">3.6.1 头文件被包含的方式</a></li><li><a href="#362__528" rel="nofollow">3.6.2 嵌套文件包含</a></li></ul> 
   </li><li><a href="#37__546" rel="nofollow">3.7 其他预处理命令</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__3"></a>1. 程序环境</h2> 
<p>在 ANSI C的任何一种实现中，存在两个不同的环境。<br> 第一种是翻译环境，在这个环境之中源代码被转化为可执行的机器指令<br> 第二种是执行环境，它用于实际的执行代码</p> 
<p>其中翻译环境可以分为 编译过程 和 链接过程。 编译可以分为 预处理，编译 ，汇编过程。接下来我们会对每一步进行比较详细的介绍。<br> <img src="https://images2.imgbox.com/52/4a/VrtqaFdJ_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="2__13"></a>2. 编译与链接</h2> 
<p>我们先创建一个文件test.c:<br> <img src="https://images2.imgbox.com/0d/ca/t38ET2dz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="21__20"></a>2.1 编译</h3> 
<hr> 
<h4><a id="221__24"></a>2.2.1 预编译（预处理）</h4> 
<pre><code class="prism language-c">gcc test<span class="token punctuation">.</span>c <span class="token operator">-</span>E <span class="token operator">&gt;</span> test<span class="token punctuation">.</span>i
</code></pre> 
<p>我们可以打开test.i来看一下，我们发现多出了许多内容，这是为什么？</p> 
<p>其中有两部分比较值得我们注意：<br> <img src="https://images2.imgbox.com/87/18/OCOE1ipd_o.png" alt="在这里插入图片描述"></p> 
<p>在预处理阶段：</p> 
<ol><li><strong>完成了头文件的包含</strong></li><li><strong>#define 定义的符号和宏会被替换</strong></li><li><strong>删除注释</strong></li></ol> 
<hr> 
<h4><a id="222__40"></a>2.2.2 编译</h4> 
<p>当我们完成了预处理，我们开始编译</p> 
<pre><code class="prism language-c">gcc test<span class="token punctuation">.</span>i <span class="token operator">-</span>S
</code></pre> 
<p><img src="https://images2.imgbox.com/3c/15/yRoL0iSG_o.png" alt="在这里插入图片描述"><br> 此时编译器把C语言转化为了汇编代码。<br> 其中包含了 语法分析，词法分析，语义分析，符号汇总</p> 
<p>汇编本身就是一门学科，所以这里只作简单了解。</p> 
<hr> 
<h4><a id="223__55"></a>2.2.3 汇编</h4> 
<pre><code class="prism language-c">gcc test<span class="token punctuation">.</span>s <span class="token operator">-</span>c
</code></pre> 
<p>在经过汇编之后，会产生一个文件 test.o (windows下叫做test.obj)，该文件也叫做 目标文件。<br> <img src="https://images2.imgbox.com/34/2e/gWyqPrLX_o.png" alt="在这里插入图片描述"><br> 我们发现，这明显是一个 二进制文件，该文件是 elf 格式的，可以简单理解为按段存储。<br> 也就是说，汇编 是把 汇编代码转化为二进制指令（机器指令）</p> 
<p>对于这种文件，我们可以通过 readelf 工具来转换成我们可以看懂的格式：<br> <img src="https://images2.imgbox.com/d6/76/ff0iQndB_o.png" alt="在这里插入图片描述"></p> 
<p>我们发现一些可以看懂的符号，test.c ,g_val,Add,main,printf ，我们发现这些符号都具有全局属性。</p> 
<hr> 
<p>为了更好解释这个问题，我重新写了两个例子：<br> <img src="https://images2.imgbox.com/7b/c1/bkBDHC1w_o.png" alt="在这里插入图片描述"><br> 我们现在有test.cpp,add.cpp,它们分别在编译阶段进行了<strong>符号汇总</strong>（只汇总全局符号），然后在汇编阶段生成 <strong>符号表</strong>。<br> <img src="https://images2.imgbox.com/2e/35/6CcYbOgT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/26/0d/Y9bQHYrp_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="22__81"></a>2.2 链接</h3> 
<p>当我们完成了汇编，连接就可以把多个目标文件和链接库进行链接：</p> 
<ol><li>合并段表</li><li>合并与重定位符号表</li></ol> 
<p>链接后得到的可执行文件的格式也是 elf 格式的。</p> 
<p>我们通过符号表的合并与重定位就可以找到来自其他文件的函数或者变量。<br> <img src="https://images2.imgbox.com/af/62/VGQRGPTl_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>我们可以将整个翻译过程 总结如下过程：<br> <img src="https://images2.imgbox.com/ac/38/zu1eHyx4_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="3__101"></a>3. 预处理</h2> 
<h3><a id="31__102"></a>3.1 预定义符号</h3> 
<p>C语言中村子许多内置的预定义符号</p> 
<pre><code class="prism language-c"><span class="token constant">__FILE__</span>    <span class="token comment">//进行编译的源文件</span>
<span class="token constant">__LINE__</span>   <span class="token comment">//文件当前的行号</span>
<span class="token constant">__DATE__</span>   <span class="token comment">//文件被编译的日期</span>
<span class="token constant">__TIME__</span>   <span class="token comment">//文件被编译的时间</span>
__STDC__   <span class="token comment">//如果编译器遵循ANSI C，其值为1，否则未定义</span>
</code></pre> 
<p>这些符号在我们编写日志信息的时候很好用，可以帮助我们定位文件，行号，时间等等。</p> 
<h3><a id="32_define_115"></a>3.2 #define</h3> 
<h4><a id="321_define__116"></a>3.2.1 #define 定义标识符</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">name</span> <span class="token expression">stuff</span></span>
</code></pre> 
<p>一些例子：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX</span> <span class="token expression"><span class="token number">1000</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">reg</span> <span class="token expression"><span class="token keyword">register</span>      </span><span class="token comment">//为 register这个关键字，创建一个简短的名字</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">do_forever</span> <span class="token expression"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>   </span><span class="token comment">//用更形象的符号来替换一种实现</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CASE</span> <span class="token expression"><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span>     </span><span class="token comment">//在写case语句的时候自动把 break写上。</span></span>
<span class="token comment">// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEBUG_PRINT</span> <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"file:%s\tline:%d\t \
             date:%s\ttime:%s\n"</span> <span class="token expression"><span class="token punctuation">,</span></span><span class="token punctuation">\</span>
             <span class="token expression"><span class="token constant">__FILE__</span><span class="token punctuation">,</span><span class="token constant">__LINE__</span> <span class="token punctuation">,</span>    </span><span class="token punctuation">\</span>
             <span class="token expression"><span class="token constant">__DATE__</span><span class="token punctuation">,</span><span class="token constant">__TIME__</span> <span class="token punctuation">)</span> </span></span>
<span class="token keyword">int</span> main
<span class="token punctuation">{<!-- --></span>
	reg <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
	do_forever<span class="token punctuation">;</span>
	DEBUG_PRINT<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当我们在define 定义标识符的时候，不建议加上";"<br> 比如，下面的场景下就会导致语法错误：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX</span> <span class="token expression"><span class="token number">1000</span><span class="token punctuation">;</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
		max <span class="token operator">=</span> MAX<span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h4><a id="322_define__158"></a>3.2.2 #define 定义宏</h4> 
<p>#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定<br> 义宏（define macro）。</p> 
<p>下面是宏的申明方式：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">name</span><span class="token expression"><span class="token punctuation">(</span> parament<span class="token operator">-</span>list <span class="token punctuation">)</span> stuff</span></span>
</code></pre> 
<p>其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中。<br> 注意：</p> 
<ol><li>参数列表的左括号必须与name紧邻。</li><li>如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分。</li></ol> 
<hr> 
<p>假设现在我们想定义一个实现乘法的宏：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span> x <span class="token punctuation">)</span> x <span class="token operator">*</span> x</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">SQUARE</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>置于程序之中，预处理器就会用下面的这个表达式替换上面的表达式：5*5.</p> 
<p>但是这样定义就一定是正确的吗?并不是，这段宏是存在问题的：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">SQUARE</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们的理想值是36，但是实际结果是 11，这是因为：替换文本时，参数x被替换成a + 1,所以这条语句实际上变成了：<strong>printf (“%d\n”,a + 1 * a + 1 );</strong>，这就导致了替换产生的表达式没有按照预想的次序进行求值。</p> 
<p>要想解决也十分简单：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
</code></pre> 
<p>同样，我们定义一个加法宏：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DOUBLE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
</code></pre> 
<p>这样也不是正确的，应该改成：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DOUBLE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre> 
<hr> 
<h4><a id="323_define__212"></a>3.2.3 #define 替换规则</h4> 
<p>在程序中拓展#define 定义符号与宏时，需要涉及几个步骤。</p> 
<ol><li>调用宏时，首先对参数进行检查，看看是否包含任何由#define 定义的符号。如果是，它们首先被替换</li><li>替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被它们的值替换</li><li>最后，对结果文件进行扫描，检查结果文件是否包含任何由#define 定义的符号，如果是，就重复上述处理过程。</li></ol> 
<p>这里需要注意：</p> 
<ol><li>宏参数和#define 定义中可以出现其他#define定义的变量。但是对于宏，不能出现递归</li><li>当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索</li></ol> 
<pre><code class="prism language-c">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DOUBLE</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">SQUARE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token function">SQUARE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  </span><span class="token comment">//可以调用其他宏</span></span>
<span class="token comment">//#define DOUBLE(X) ((DOUBLE(X))+(DOUBLE(X)))  不能递归调用</span>
<span class="token comment">//括号很重要</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token function">DOUBLE</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"M = %d\n"</span><span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串常量的M并不被搜索替换</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	
<span class="token punctuation">}</span>

</code></pre> 
<hr> 
<h4><a id="324____244"></a>3.2.4 # 与 ##</h4> 
<ul><li>#<br> 此时有一个场景，我们想把参数插入到字符串中，有扫描方法？</li></ul> 
<p>我们可以这样写：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRINT</span><span class="token expression"><span class="token punctuation">(</span>FORMAT<span class="token punctuation">,</span> VALUE<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"the value is "</span><span class="token expression">FORMAT</span><span class="token string">"\n"</span><span class="token expression"><span class="token punctuation">,</span> VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">PRINT</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>但是，这样写存在明显的局限性，只有当字符串作为宏参数的时候才可以直接把字符串放在字符串中。</p> 
<p>这时候我们可以使用 “#”,<strong>把一个宏参数变成对应的字符串</strong>：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRINT</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">,</span>FORMAT<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"the value of "</span><span class="token directive-hash">#</span><span class="token expression">X</span><span class="token string">"is "</span> <span class="token expression">FORMAT</span><span class="token string">"\n"</span><span class="token expression"><span class="token punctuation">,</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//the value of a is 10</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token function">PRINT</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//the value of f is 5.5</span>
	<span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">5.5f</span><span class="token punctuation">;</span>
	<span class="token function">PRINT</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">"%f"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>##</li></ul> 
<p>##可以把位于两边的符号合成一个符号，它允许宏定义从分离的文本片段创建标识符。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ADD_TO_SUM</span><span class="token expression"><span class="token punctuation">(</span>num<span class="token punctuation">,</span> value<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression">sum</span><span class="token punctuation">##</span><span class="token expression">num <span class="token operator">+=</span> value<span class="token punctuation">;</span></span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> sum5<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">ADD_TO_SUM</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//作用是：给sum5增加10.</span>
</code></pre> 
<hr> 
<h4><a id="325__289"></a>3.2.5 宏参数的副作用</h4> 
<p>MAX宏可以证明具有副作用的参数所引起的问题</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">)</span></span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
z <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">,</span> y<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x=%d y=%d z=%d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出的结果是什么？</span>
</code></pre> 
<p>我们得到的结果是：</p> 
<pre><code class="prism language-c">x<span class="token operator">=</span><span class="token number">6</span> y<span class="token operator">=</span><span class="token number">10</span> z<span class="token operator">=</span><span class="token number">9</span>
</code></pre> 
<hr> 
<h4><a id="326__309"></a>3.2.6 宏与函数的对比</h4> 
<p>宏通常被应用于执行简单的运算。比如在两个数中找出较大的一个。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre> 
<p>相较于函数，宏有一些函数不可代替的优点:</p> 
<ol><li> <p>用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比<br> 函数在程序的规模和速度方面更胜一筹</p> </li><li> <p>更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之<br> 这个宏怎可以适用于整形、长整型、浮点型等可以用于&gt;来比较的类型。宏是类型无关的</p> </li></ol> 
<hr> 
<p>但是，宏也也有一些缺点：</p> 
<ol><li>每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序<br> 的长度。</li><li>宏是没法调试的。</li><li>宏由于类型无关，也就不够严谨。</li><li>宏可能会带来运算符优先级的问题，导致程容易出现错。</li></ol> 
<p>对于宏和函数，我们要因地制宜，权衡利弊，进行合理的选择。</p> 
<hr> 
<h4><a id="327__338"></a>3.2.7 关于宏的一些练习</h4> 
<ol><li>写一个宏，可以将一个整数的二进制的奇数位和偶数位交换</li></ol> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SWAP</span><span class="token expression"><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token operator">&amp;</span><span class="token number">0xaaaaaaaa</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token operator">&amp;</span><span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
</code></pre> 
<p>我们以十进制数字 5为例子：</p> 
<pre><code class="prism language-c"><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000111</span>
取出所有奇数位： <span class="token number">5</span><span class="token operator">&amp;</span> <span class="token number">01010101</span> <span class="token number">01010101</span> <span class="token number">01010101</span> <span class="token number">01010101</span> <span class="token punctuation">(</span>即<span class="token number">0x55555555</span><span class="token punctuation">)</span>
   得到： <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000101</span>
   左移一位到偶数位：<span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00001010</span>
   
取出所有偶数位： <span class="token number">5</span><span class="token operator">&amp;</span> <span class="token number">10101010</span> <span class="token number">10101010</span> <span class="token number">10101010</span> <span class="token number">10101010</span> <span class="token punctuation">(</span>即<span class="token number">0xaaaaaaaa</span><span class="token punctuation">)</span>
   得到： <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000010</span>
   右移一位到奇数位 <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000001</span>
   
相加： <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00001011</span>
</code></pre> 
<hr> 
<ol start="2"><li>写一个宏，计算结构体某变量相对于首地址的偏移，并给出说明</li></ol> 
<p>这其实是C语言中定义的宏 offsetof,它可以计算出结构体中的成员变量的偏移量。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stddef.h&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">short</span> b<span class="token punctuation">;</span>
	<span class="token keyword">int</span> c<span class="token punctuation">;</span>
	<span class="token keyword">char</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//8</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//12</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么我们应该如何自定义出一个相同功能的宏呢？</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">OFFSETOF</span><span class="token expression"><span class="token punctuation">(</span>struct_name<span class="token punctuation">,</span>mem_name<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>struct_name<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>mem_name<span class="token punctuation">)</span></span></span>
</code></pre> 
<p>对于这种写法，我们可以理解为在0地址处放了一个结构体（实际上没有开辟空间）。<br> 我们同样可以改为：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">OFFSETOF</span><span class="token expression"><span class="token punctuation">(</span>struct_name<span class="token punctuation">,</span>mem_name<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>struct_name<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x40</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>mem_name<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">0x40</span></span></span>
</code></pre> 
<hr> 
<h3><a id="33_undef_403"></a>3.3 #undef</h3> 
<p>这条指令用于移除一个宏定义。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">NAME</span></span>
<span class="token comment">//如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。</span>
</code></pre> 
<h3><a id="34__411"></a>3.4 命令行定义</h3> 
<p>许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。</p> 
<p>例如：当我们根据同一个源文件要编译出不同的一个程序的不同版本的时候，这个特性有点用处。（假<br> 定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一<br> 个机器内存大写，我们需要一个数组能够大写.）</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> array <span class="token punctuation">[</span>ARRAY_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
   	 array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span> <span class="token punctuation">,</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>我们可以使用命令行参数进行编译：</p> 
<pre><code class="prism language-c">gcc <span class="token operator">-</span>D ARRAY_SIZE<span class="token operator">=</span><span class="token number">10</span> programe<span class="token punctuation">.</span>c
</code></pre> 
<hr> 
<h3><a id="35__448"></a>3.5 条件编译</h3> 
<p>在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件<br> 编译指令.</p> 
<p><img src="https://images2.imgbox.com/a1/a2/2yBlkF3y_o.png" alt="在这里插入图片描述"></p> 
<p>常见的条件编译指令</p> 
<p>1.常量表达式</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__DEBUG__</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">__DEBUG__</span></span>
<span class="token comment">//..</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<ol start="2"><li>多个分支的条件编译</li></ol> 
<p><img src="https://images2.imgbox.com/3f/a4/zVuPbGZA_o.png" alt="在这里插入图片描述"><br> 3. 判断是否被定义</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">symbol</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">symbol</span></span>
</code></pre> 
<ol start="4"><li>嵌套指令</li></ol> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>OS_UNIX<span class="token punctuation">)</span></span></span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">OPTION1</span></span>
		<span class="token function">unix_version_option1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">OPTION2</span></span>
		<span class="token function">unix_version_option2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>OS_MSDOS<span class="token punctuation">)</span></span></span>
		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">OPTION2</span></span>
			<span class="token function">msdos_version_option2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<hr> 
<h3><a id="36__497"></a>3.6 文件包含</h3> 
<p>我们已经知道， #include 指令可以使另外一个文件被编译。就像它实际出现于 #include 指令的地方<br> 一样。</p> 
<p>这种替换的方式很简单：<br> 预处理器先删除这条指令，并用包含文件的内容替换。<br> 这样一个源文件被包含10次，那就实际被编译10次。</p> 
<h4><a id="361__504"></a>3.6.1 头文件被包含的方式</h4> 
<ul><li>本地文件被包含的方式</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"filename"</span></span>
</code></pre> 
<p>其查找策略是： 先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数文件一样在标准位置查找文件。如果找不到就报编译错误。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;filename.h&gt;</span></span>
</code></pre> 
<p>查找策略：编译器查找库函数文件所在标准位置查找文件</p> 
<ul><li>Linux环境的标准头文件的路径</li></ul> 
<pre><code class="prism language-c"><span class="token operator">/</span>usr<span class="token operator">/</span>include
</code></pre> 
<p>这样是不是可以说，对于库文件也可以使用 “” 的形式包含？<br> 答案是肯定的，可以。<br> 但是这样做查找的效率就低些，当然这样也不容易区分是库文件还是本地文件了</p> 
<hr> 
<h4><a id="362__528"></a>3.6.2 嵌套文件包含</h4> 
<p>如何避免包含重复头文件呢？</p> 
<p>有两种方式：</p> 
<ul><li>pragma once</li><li>条件编译</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__TEST_H__</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__TEST_H__</span></span>
<span class="token comment">//头文件的内容</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">//__TEST_H__</span></span>
</code></pre> 
<hr> 
<h3><a id="37__546"></a>3.7 其他预处理命令</h3> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">error</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">line</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d6dc8616d0a236db1725ac4febd99143/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python中如何获取用户的输入，你一定要知道，学Python必看</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7400a601977ce7ebf73d1f021a6c7eb5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Cron表达式学习：每天十二点执行一次：0 0 12 * * ?</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>