<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>React 初次接触 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/a4d2bbdcd575d6207f0e27982d915f35/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="React 初次接触">
  <meta property="og:description" content="背景 还是为了完善高大上的在线文档系统，虽然比着葫芦画瓢的修改了一些所谓的代码，慢慢的才发现，原来这就是传说中的React，所以有比较又要囫囵吞枣一下React。
基本原理 参照《React技术揭秘》 网上有电子版 ，应该是个高手，点赞
概述 前端框架主要的作用是将数据的变化映射为UI的变化： UI=fn(state)
fn就是计算数据的变动导致UI是如何变化的，不同的框架中，fn的描述方式不同
主流的描述方式分为：
jsx：使UI和逻辑更紧密，它是ES语法糖.（从逻辑出发，扩展逻辑，描述UI）模板语法：使用HTML描述UI，它是HTML语法扩展。（从UI出发，扩展UI，描述逻辑） jsx是动态的，即使代码没有变，每次更新，都会重新编译，
模板语法是静态的，可以用来分析，哪些节点是动态的，哪些节点是静态的。有很大的优化空间。
不管是jsx还是模板语法，它们都是组织逻辑和UI的关系
根据UI变化方式（更新细粒度）不同，将框架可以分为三类：
应用级：数据变化时，重新渲染整个应用，React组件级：数据变化时，重新渲染数据有变化的组件Vue元素级：数据变化时，只渲染数据变化的DOM节点，Svelte 按下性能问题暂且不表，先想想，为啥会有这种差别呢？这是因为不同的框架，架构不同导致的。
我们的代码并不是立即执行的，而是先进行编译（语法转换、将ts转为js、压缩、polyfill等），将我们的代码转为宿主环境可以识别的代码。
React React经过编译之后返回的是createElement函数，所以每次数据变化，React都会从应用根节点重新加载整个应用。因此React无需知道是哪个变量发生变化导致的更新。
export const App = () =&amp;gt; { const [count, setCount] = useState(0); return /*#__PURE__*/React.createElement(&#34;div&#34;, { onClick: () =&amp;gt; setCount(conut&#43;&#43;) }, count); }; 所以这种框被架称为应用级框架
Vue3 Vue3经过编译之后返回的是组件的render函数，Vue3会为每个组件建立watchEffect事件，这个大致如下：
在页面首次进入或者watchEffect的依赖项发生变化时，都会调用组件的render函数。
render函数的返回值是本次更新的VNode，Vue会根据本次更新的VNode与上次更新做比较（patch），找到最优的更新路径，并且进行更新。 所以这种框架被称为组件级框架
function render(_ctx, _cache, $props, $setup, $data, $options) { return (_openBlock(), _createElementBlock(&#34;h1&#34;, { onClick: _cache[0] || (_cache[0] = $event =&amp;gt; (_ctx.count&#43;&#43;)) }, _toDisplayString(_ctx.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-17T17:22:00+08:00">
    <meta property="article:modified_time" content="2024-01-17T17:22:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">React 初次接触</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="xDTCJ">背景</h3> 
<p id="ude1cbcd1">还是为了完善高大上的在线文档系统，虽然比着葫芦画瓢的修改了一些所谓的代码，慢慢的才发现，原来这就是传说中的React，所以有比较又要囫囵吞枣一下React。</p> 
<h3 id="JhnAr">基本原理</h3> 
<p id="uf4acd84a">参照《React技术揭秘》 网上有电子版 ，应该是个高手，点赞</p> 
<p id="ua946c84f"></p> 
<p class="img-center"><img alt="" height="370" id="u488a0ab8" src="https://images2.imgbox.com/7d/a0/FBpj4zCT_o.png" width="291"></p> 
<h4 id="iBn4s"><strong>概述</strong></h4> 
<p id="udbb59162">前端框架主要的作用是将数据的变化映射为UI的变化： UI=fn(state)</p> 
<p id="uf9ae186f">fn就是计算数据的变动导致UI是如何变化的，不同的框架中，fn的描述方式不同</p> 
<p id="ufd307d54">主流的描述方式分为：</p> 
<ol><li id="u49ad1773">jsx：使UI和逻辑更紧密，它是ES语法糖.（从逻辑出发，扩展逻辑，描述UI）</li><li id="u2135ac35">模板语法：使用HTML描述UI，它是HTML语法扩展。（从UI出发，扩展UI，描述逻辑）</li></ol> 
<p id="uc0496963">jsx是动态的，即使代码没有变，每次更新，都会重新编译，</p> 
<p id="u42b4794b">模板语法是静态的，可以用来分析，哪些节点是动态的，哪些节点是静态的。有很大的优化空间。</p> 
<p id="uf817f7a7">不管是jsx还是模板语法，它们都是组织逻辑和UI的关系</p> 
<p id="ue4f6c49e">根据UI变化方式（更新细粒度）不同，将框架可以分为三类：</p> 
<ol><li id="u584cea32">应用级：数据变化时，重新渲染整个应用，React</li><li id="u5475706f">组件级：数据变化时，重新渲染数据有变化的组件Vue</li><li id="uef08e6b1">元素级：数据变化时，只渲染数据变化的DOM节点，Svelte</li></ol> 
<p id="u811ce440">按下性能问题暂且不表，先想想，为啥会有这种差别呢？这是因为不同的框架，架构不同导致的。</p> 
<p id="u682899aa">我们的代码并不是立即执行的，而是先进行编译（语法转换、将ts转为js、压缩、polyfill等），将我们的代码转为宿主环境可以识别的代码。</p> 
<h4 id="tIn1E"><strong>React</strong></h4> 
<p id="ua2158ce1">React经过编译之后返回的是createElement函数，所以每次数据变化，React都会从应用根节点重新加载整个应用。因此React无需知道是哪个变量发生变化导致的更新。</p> 
<p id="u1d2b739b"></p> 
<pre id="WpxpK"><code>export const App = () =&gt; {
  const [count, setCount] = useState(0);
  return /*#__PURE__*/React.createElement("div", {
    onClick: () =&gt; setCount(conut++)
  }, count);
};</code></pre> 
<p id="ud93e7a6d">所以这种框被架称为应用级框架</p> 
<h4 id="cHsfD"><strong>Vue3</strong></h4> 
<p id="u3ee62f7e">Vue3经过编译之后返回的是组件的render函数，Vue3会为每个组件建立watchEffect事件，这个大致如下：</p> 
<p id="u1fe61e6b">在页面首次进入或者watchEffect的依赖项发生变化时，都会调用组件的render函数。</p> 
<p id="u850a6089">render函数的返回值是本次更新的VNode，Vue会根据本次更新的VNode与上次更新做比较（patch），找到最优的更新路径，并且进行更新。 所以这种框架被称为组件级框架</p> 
<pre id="cMnXN"><code>function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("h1", {
    onClick: _cache[0] || (_cache[0] = $event =&gt; (_ctx.count++))
  }, _toDisplayString(_ctx.count), 1 /* TEXT */))
}</code></pre> 
<pre id="dkszC"><code>// patch是对比前后VNode变化的方法
watchEffect(() =&gt; patch(render(props), preVDOM), [conut])</code></pre> 
<h4 id="HxpWz"><strong>React性能</strong></h4> 
<p id="ueca3a41a">你肯定会问，我就改了个count的值，像React这样大动干戈，重新渲染整个应用，是不是很低效啊。</p> 
<p id="u1a10b117">其实，React在运行时阶段，做了一部分关键的优化。不管是Vue还是React，在编译之后返回的都是VNode。</p> 
<h4 id="CNn3d"><strong>双缓存机制</strong></h4> 
<p id="u249fc467">一方面，React在拿到编译之后的VNode，首先会在内存中和上次更新的VNode进行对比，找到具体更新的VNode并且在内存中更新，上次没有更新时(mount)，在内存中全部更新。</p> 
<p id="u8f144ef6"></p> 
<p id="uaaae9fd4"></p> 
<p class="img-center"><img alt="" height="736" id="u2920c2b9" src="https://images2.imgbox.com/72/08/ln9XVS2y_o.png" width="660"></p> 
<p id="u5af9a689">更多内容，查找对应的内容，我是只知道那么个意思就行。</p> 
<h3 id="O9FdR">React实现理解</h3> 
<p id="u0b2c5784">react 和 vue 都是基于 vdom 的前端框架：</p> 
<h4 id="hWreB">Vdom</h4> 
<p id="u602c102d">html中有很多属性根本用不到，但在更新时却要跟着重新设置一遍。能不能只对比我们关心的属性呢？</p> 
<p id="u03d72a6b">把这些单独摘出来用 JS 对象表示不就行了？这就是为什么要有 vdom，是它的第一个好处。</p> 
<p id="uf992e7d2">而且有了 vdom 之后，就没有和 dom 强绑定了，可以渲染到别的平台，比如 native、canvas 等等。</p> 
<p id="uf8a15e6d">这是 vdom 的第二个好处。为了更简洁，引入</p> 
<h4 id="eaSgX"><strong>dsl 的编译</strong></h4> 
<p id="u64346f6c">dsl 是 domain specific language，领域特定语言的意思，html、css 都是 web 领域的 dsl。</p> 
<p id="u4de2be73">直接写 vdom 太麻烦了，所以前端框架都会设计一套 dsl，然后编译成 render function，执行后产生 vdom。</p> 
<p id="u9a966225">vue 和 react 都是这样：</p> 
<p id="udce753fa"></p> 
<p class="img-center"><img alt="" height="129" id="u96969a7a" src="https://images2.imgbox.com/43/97/KJmM8fOj_o.png" width="680"></p> 
<p id="uf46d4024">这套 dsl 怎么设计呢？前端领域大家熟悉的描述 dom 的方式是 html，最好的方式自然是也设计成那样。</p> 
<p id="u30b8ddd8">所以 vue 的 template，react 的 jsx 就都是这么设计的。</p> 
<p id="ue3bc4f32">vue 的 template compiler 是自己实现的，而 react 的 jsx 的编译器是 babel 实现的，是两个团队合作的结果。</p> 
<p id="u430dd521"></p> 
<p class="img-center"><img alt="" height="91" id="u8b0f1790" src="https://images2.imgbox.com/3a/27/kWZXfRRJ_o.png" width="681"></p> 
<p id="ue72e67e6">编译成 render function 后再执行就是我们需要的 vdom。接下来渲染器把它渲染出来就行了。那渲染器怎么渲染 vdom 的呢？</p> 
<h4 id="dK53j"><strong>渲染 vdom</strong></h4> 
<p id="u3c0e7612">渲染 vdom 也就是通过 dom api 增删改 dom。</p> 
<p id="u811012a2">比如一个 div，那就要 document.createElement 创建元素，然后 setAttribute 设置属性，addEventListener 设置事件监听器。如果是文本，那就要 document.createTextNode 来创建。所以说根据 vdom 类型的不同，写个 if else，分别做不同的处理就行了。没错，不管 vue 还是 react，渲染器里这段 if else 是少不了的：</p> 
<p id="ua313b8d6"></p> 
<pre id="WUb4D"><code>switch (vdom.tag) {
  case HostComponent:
    // 创建或更新 dom
  case HostText:
    // 创建或更新 dom
  case FunctionComponent: 
    // 创建或更新 dom
  case ClassComponent: 
    // 创建或更新 dom
}</code></pre> 
<p id="u22ea872c">react 里是通过 tag 来区分 vdom 类型的，比如 HostComponent 就是元素，HostText 就是文本，FunctionComponent、ClassComponent 就分别是函数组件和类组件。那么问题来了，组件怎么渲染呢？</p> 
<p id="uf328d4ff">这就涉及到组件的原理了：</p> 
<h4 id="dMDEZ"><strong>组件</strong></h4> 
<p id="ue009f23b">我们的目标是通过 vdom 描述界面，在 react 里会使用 jsx。这样的 jsx 有的时候是基于 state 来动态生成的。如何把 state 和 jsx 关联起来呢？封装成 function、class 或者 option 对象的形式。然后在渲染的时候执行它们拿到 vdom 就行了。这就是组件的实现原理：</p> 
<p id="u4c49744c"></p> 
<pre id="ii384"><code>switch (vdom.tag) {
  case FunctionComponent: 
       const childVdom = vdom.type(props);
       
       render(childVdom);
       //...
  case ClassComponent: 
     const instance = new vdom.type(props);
     const childVdom = instance.render();
     
     render(childVdom);
     //...
}</code></pre> 
<p id="u6d234baa">如果是函数组件，那就传入 props 执行它，拿到 vdom 之后再递归渲染。如果是 class 组件，那就创建它的实例对象，调用 render 方法拿到 vdom，然后递归渲染。所以，大家猜到 vue 的 option 对象的组件描述方式怎么渲染了么？</p> 
<pre id="yp7Jf"><code>{
    data: {},
    props: {}
    render(h) {
        return h('div', {}, '');
    }
}</code></pre> 
<p id="u646d60c1">没错，就是执行下 render 方法就行：</p> 
<pre id="gRSgY"><code>const childVdom = option.render();
 
 render(childVdom);</code></pre> 
<p id="u013e09a7">大家可能平时会写单文件组件 sfc 的形式，那个会有专门的编译器，把 template 编译成 render function，然后挂到 option 对象的 render 方法上：</p> 
<p id="uc3b20adc"></p> 
<p class="img-center"><img alt="" height="441" id="uba6929c0" src="https://images2.imgbox.com/a5/cf/XpqKwq19_o.png" width="700"></p> 
<p id="u876670d7">所以组件本质上只是对产生 vdom 的逻辑的封装，函数的形式、option 对象的形式、class 的形式都可以。</p> 
<p id="uce392f1b">就像 vue3 也有了函数组件一样，组件的形式并不重要。</p> 
<p id="u81df3130">基于 vdom 的前端框架渲染流程都差不多，vue 和 react 很多方面是一样的。但是管理状态的方式不一样，vue 有响应式，而 react 则是 setState 的 api 的方式。</p> 
<p id="u711df6ec">真说起来，vue 和 react 最大的区别就是状态管理方式的区别，因为这个区别导致了后面架构演变方向的不同。</p> 
<h4 id="DjDqT"><strong>状态管理</strong></h4> 
<p id="u81221f4e">react 是通过 setState 的 api 触发状态更新的，更新以后就重新渲染整个 vdom。</p> 
<p id="u4ab6eb10">而 vue 是通过对状态做代理，get 的时候收集以来，然后修改状态的时候就可以触发对应组件的 render 了。</p> 
<p id="u933c1fac">有的同学可能会问，为什么 react 不直接渲染对应组件呢？</p> 
<p id="u42e73ef3">想象一下这个场景：</p> 
<p id="ub933646b">父组件把它的 setState 函数传递给子组件，子组件调用了它。</p> 
<p id="u41dfdc5a">这时候更新是子组件触发的，但是要渲染的就只有那个组件么？</p> 
<p id="ub1106225">明显不是，还有它的父组件。</p> 
<p id="uf681e78e">同理，某个组件更新实际上可能触发任意位置的其他组件更新的。</p> 
<p id="u01487664">所以必须重新渲染整个 vdom 才行。</p> 
<p id="u2ca525bd">那 vue 为啥可以做到精准的更新变化的组件呢？</p> 
<p id="u59bc1cc7">因为响应式的代理呀，不管是子组件、父组件、还是其他位置的组件，只要用到了对应的状态，那就会被作为依赖收集起来，状态变化的时候就可以触发它们的 render，不管是组件是在哪里的。</p> 
<p id="u743af029">这就是为什么 react 需要重新渲染整个 vdom，而 vue 不用。</p> 
<p id="u660f4142">这个问题也导致了后来两者架构上逐渐有了差异。</p> 
<h4 id="OkQk4"><strong>react 架构的演变</strong></h4> 
<p id="u6fd495ee">react15 的时候，和 vue 的渲染流程还是很像的，都是递归渲染 vdom，增删改 dom 就行。</p> 
<p id="u3a9ad686">但是因为状态管理方式的差异逐渐导致了架构的差异。</p> 
<p id="uce303c8d">react 的 setState 会渲染整个 vdom，而一个应用的所有 vdom 可能是很庞大的，计算量就可能很大。</p> 
<p id="u0c55fbf0">浏览器里 js 计算时间太长是会阻塞渲染的，会占用每一帧的动画、重绘重排的时间，这样动画就会卡顿。</p> 
<p id="u25fb8b78">作为一个有追求的前端框架，动画卡顿肯定是不行的。但是因为 setState 的方式只能渲染整个 vdom，所以计算量大是不可避免的。</p> 
<p id="u46662b1b">那能不能把计算量拆分一下，每一帧计算一部分，不要阻塞动画的渲染呢？</p> 
<p id="ua5421ae5">顺着这个思路，react 就改造为了 fiber 架构。 <strong>这个架构一坨，不看了</strong></p> 
<h3 id="gVd2e">React渲染</h3> 
<h4 id="XvrXC">铺垫</h4> 
<p id="u56946e0a"><br>  </p> 
<p id="u849ef526"></p> 
<p class="img-center"><img alt="" height="234" id="u169e2ed9" src="https://images2.imgbox.com/5a/e2/f6CU5M2A_o.png" width="548"></p> 
<p id="uf4bbecfa">tupian</p> 
<p id="u4dffdaaf"><br>  </p> 
<p id="ud343ffbf">首先回想一下，如果不用任何框架，用原生js创建这样一颗dom树应该怎么处理。 为了减少dom操作，我们会先创建最底层的元素存放到变量中，然后依次创建其父元素，直至创建到最顶层的div，最后将顶层的div插入到dom中即可，这样避免了多次的dom插入。 React其实也是这样， 先来看一下我们常用的入口写法</p> 
<p id="ue2b207f3"></p> 
<pre id="QUZDV"><code>ReactDOM.render(&lt;App /&gt;, document.getElementById("root"));</code></pre> 
<p id="u105b6f60">在React 17及之前版本，我们都是通过以上方式将React组件注册到视图中。作为高级动物的我们是能一眼看出来哪个是最底层的元素(叶子节点)，然后一层层向上创建父元素直至顶层元素(根节点)。但是对于一个程序来说，最开始是没办法知道哪个是叶子节点，所以只能通过入口提供的根节点向下遍历, 直到找到叶子节点然后创建对应的元素。 所以对于React框架来说， 是有两个方向的流程的， 自上而下查找子元素、自下而上创建dom元素，分别对应两个遍历流程beginWork、completeWork 后面会详分析两个流程，这里先大概了解。在进入这两个流程之前先看下render函数中做了哪些处理。</p> 
<h4 id="qL6DM">准备工作</h4> 
<p id="u09510836">我认为在进入beginWork、completeWork流程之前，先做些准备工作为这俩流程做铺垫。</p> 
<p id="u9df3e252">(为了方便描述，暂且称React的顶层组件为根组件，需要挂在到的dom元素称为根元素即上文代码的div#root)</p> 
<p id="u591f4dc1">如果要遍历App组件，必须得标记一个起点，方便在后续创建到根节点时执行插入dom的操作。那么起点怎么标记呢？有的同学就说，App就是呀! 试想一下，如果根组件命名不是App而是Root或者别的名字，只认识App那就不行了。所以React内部加了一个"组件"HostRoot用来标示组件的开始(HostRoot并不是一个组件，只是特殊的值, 在创建根组件Fiber时, 作为tag使用)</p> 
<p id="u232f77ea">(Fiber是个Class类型， 每个组件节点后续都会创建为fiber对象, 大概结构如下)</p> 
<p id="ud1f6d06d"><br>  </p> 
<p id="u97d62b35"></p> 
<p class="img-center"><img alt="" height="1090" id="u28203c5b" src="https://images2.imgbox.com/2d/e1/jL90WvMk_o.png" width="416"></p> 
<p id="u6537cf97">tupian</p> 
<p id="udb9651b9">记录了根组件HostRoot还要记录根元素div#root，因为组件dom创建完后要插入到div#root下，并不是body下。</p> 
<p id="u1381c315">同时在这里还注册了事件，为啥要注册事件呢？对于dom事件，在jquery时代我们就知道，不要在每个元素上绑定事件，尽量通过代理绑定的形式绑定到父元素上。 没错React也一样，在17版本之前，所有的事件都是绑定到document上， 17之后都是绑定到挂载的根元素上即这里的div#root。我们在写代码时，虽然在React组件上绑定了像onClick、onFocus、onScroll等事件，最终都是通过代理的形式触发事件的执行的。React的事件系统也很精彩后面单独抽出一篇文章来分析。 这里只需知道也是在开始遍历之前，先把事件在根组件上注册了。</p> 
<p id="u886c54f3">整个过程的主要函数调用流程为</p> 
<p id="ua95f4017"><br>  </p> 
<p id="u6e2f26b9"></p> 
<p class="img-center"><img alt="" height="112" id="u9d89e51a" src="https://images2.imgbox.com/d4/b2/xduD9EDg_o.png" width="720"></p> 
<p id="ud8dfc60d">tupian</p> 
<p id="u74ba9d34"><br>  </p> 
<p id="u0e643861">在实例化ReactDomBlockingRoot时又创建了根组件对应的fiber对象即上面所说tag为HostRoot的Fiber我们称为RootFiber, 同时为了维护RootFiber和div#root的关系创建了一个对象叫FiberRoot。 此外对于div#root、FiberRoot、RootFiber三个对象上都有字段指向彼此，这样在不同的场景下，都能很容易根据一方找到另外两个。实例化的主要函数流程调用如下图，可以看到通过调用listenToAllSupportedEvents在div#root上注册了事件</p> 
<p id="ufe428edd"><br>  </p> 
<p id="ua4e9ff00"></p> 
<p class="img-center"><img alt="" height="164" id="u68bb59d8" src="https://images2.imgbox.com/60/14/1r29R69O_o.png" width="720"></p> 
<p id="u6795a07e">tupian</p> 
<p id="u598c78d4">三者之间的关系如下</p> 
<p id="u97a1e747"><br>  </p> 
<p id="u2d03db64"></p> 
<p class="img-center"><img alt="" height="171" id="u2de8b0fd" src="https://images2.imgbox.com/e1/5a/Rkkacov2_o.png" width="720"></p> 
<p id="u063bc7d6">mage.png</p> 
<p id="u7c710e14"></p> 
<p id="u5f80c5be">准备工作做完开从根组件向下遍历查找子组件了</p> 
<h4 id="BhYit">自上而下、自下而上遍历执行</h4> 
<p id="u28bd2e75">在没遍历执行beginWork之前，react也不知道后续的组件结构会是啥样，所以在beginWork时每遇到一个组件时都要记录下来，同时要记录父组件和子组件、组件与组件间的关系，这样才能保证后续创建出来的dom树不会错乱掉。react内部对于每个组件都会创建成Fiber对象，通过Fiber记录组件间的关系，最后构成一个Fiber链表结构。 父组件parentFiber.child指向第一个子组件对应的fiber，子组件的fiber.return指向父组件，同时子组件的fiber.sibling指向其右边的相邻兄弟节点的fiber, 构成一个fiber树。如下图</p> 
<p id="ud780f317"><br>  </p> 
<p id="u8d4bf0d1"></p> 
<p class="img-center"><img alt="" height="336" id="u77428649" src="https://images2.imgbox.com/37/c0/1CTeaHq5_o.png" width="720"></p> 
<p id="u89a90436">image.png</p> 
<p id="u36b39250">还需要说明的是， beginWork的遍历并不是先查找完某一层所有的子元素再进行下一层的查找， 而是只查父元素的第一个子元素， 然后继续查找下一层的子元素， 如果没有子元素才会查找兄弟元素，兄弟元素查找完再查找父元素的兄弟元素， 类似于二叉树的前序遍历。所以对于上图的结构， 遍历顺序如下: App-&gt;Comp1-&gt;Comp3-&gt;div1-&gt;div2-&gt;div3-&gt;div4-&gt;Comp2-&gt;div5</p> 
<h4 id="nzxXM">beginWork</h4> 
<p id="u33627a07">beginWork主要的功能就是遍历查找子组件，建立关系树。 那么怎么查找子组件呢，我们只分析class组件和函数式组件。 对于函数式组件，会执行组件对应的函数，注册hooks，同时拿到函数return的结果，即为该组件的child；对于class组件，会先实例化class，在这个阶段也会调用class的静态方法getDerivedStateFromProps以及实例的componentWillMount方法最后执行render方法拿到对应的child。 在mount阶段和update阶段， beginWork的执行逻辑也有区别的。 我们都知道为了减少重排和重绘，react帮助我们找出那些有变化的节点，只做这些节点的更新。 在mount阶段，因为在这之前没有创建节点，所以每个节点的fiber都是新建的；在update阶段， 会通过diff算法判断当前节点是否需要变更，如果需要变更会重新创建新的fiber对象并复用部分老的fiber对象属性，如果不需要变更则直接clone老的fiber对象；如果diff对比后老的fiber存在，新的fiber不存在，则会给fiber打上Deletion标签标示该元素需要删除； 如果老的fiber不存在，新的fiber存在说明是新创建的元素，则给fiber打上Placement标签。 beginWork大概流程如下</p> 
<p id="u037de4d6"><br>  </p> 
<p id="u70b31233"></p> 
<p class="img-center"><img alt="" height="360" id="u91b37c33" src="https://images2.imgbox.com/c3/60/x7rhQSUL_o.png" width="720"></p> 
<p id="ucefe0903">tupian</p> 
<h4 id="N9zm4">completeWork</h4> 
<p id="u529365cc">completeWork阶段主要执行dom节点的创建或者标记变更。在mount阶段时，对于自定义组件比如class组件、函数式组件，其实不做什么特殊处理; 对于div、p、span(这种组件在react内部定义为HostComponent)，就会调用document.createElement方法创建dom元素存放到该节点fiber对象的stateNode字段上；对于父元素是HostComponent的情况，先创建父元素的dom节点parentInstance， 然后调用parentInstance.appendChild(child)方法将子元素挂在该节点上。 在update阶段，如果老的fiber存在则不会重新创建dom元素，而是给该元素打上Update标签；如果是新的元素和mount阶段一样创建新的dom元素。 大概流程如下</p> 
<p id="ufadc6274"><br>  </p> 
<p id="u9c952b48"></p> 
<p class="img-center"><img alt="" height="346" id="u82db1eed" src="https://images2.imgbox.com/73/3f/EXuuVLHr_o.png" width="720"></p> 
<p id="ua4cbf04c">image.png</p> 
<p id="uec9a319b">此外在react内部， beginWork和completeWork是交替进行，这是为什么呢？ 试想一下， 如果不交替运行，beginWork执行完之后只记录了关系， 然后再想通过completeWork创建dom元素，是不是又得从根组件开始遍历一遍，这样就至少需要遍历两遍。react通过合适的时机切换执行beginWork、completeWork只需遍历一遍就可以完成所有操作了。那么在什么时机切换呢？还记得我们一开始说，用原生js创建dom时先创建最底层的元素， react也是，在遍历执行beginWork到最底层元素时即下图的div1，该元素已经没有子元素了， 开始执行completeWork创建dom节点, 执行完div1的completeWork又切换成执行div2的beginWork，div2也没有子节点，所以进而执行div2的completeWork； div3也同样先执行beginWork再执行completeWork, 和div1、div2不同的是， div3已经没有右边的兄弟元素了， 转向执行父元素Comp3的completeWork, 然后再执行div4的beginWork。所以beginWork和completeWork的执行顺序是动态切换的<br>  </p> 
<p id="udbf52c58"></p> 
<p class="img-center"><img alt="" height="438" id="u1663be78" src="https://images2.imgbox.com/ee/54/5QA7okwf_o.png" width="720"></p> 
<p id="uf4ce45be">图片</p> 
<p id="u3e132faa">在beginWork和completeWork时， 分别维护了一个指针workInProgress、completeWork指向当前正在执行的work的节点， 执行完当前节点指针执行下一个节点， 通过判断workInProgress是否为null进行beginWork =&gt; completeWork的切换， 通过判断fiber.sibling是否为null进行completeWork =&gt; beginWork的切换。</p> 
<p id="ud4195546">整个遍历流程的主要函数调用如下</p> 
<p id="u03be66fe"><br>  </p> 
<p id="ub80db49c"></p> 
<p class="img-center"><img alt="" height="697" id="ud8f075d2" src="https://images2.imgbox.com/99/cd/UVyJTnUC_o.png" width="720"></p> 
<p id="u40bfc2b8">图片</p> 
<p id="u77a1db40"><br>  </p> 
<p id="u916b134f">经过beginWork、completeWork， 每个组件节点的dom元素都创建完成或是被打上了对应的标签。在mount阶段，根组件下已经挂载了所有子元素节点的dom， 那么只需要将根组件dom节点插入到div#app下即可；update阶段组件fiber都被打上了标记，哪个元素需要删除，哪个需要更新都在下个阶段这些；这些操作在commit流程中进行。</p> 
<h4 id="b8r1p">Commit阶段</h4> 
<p id="u31f6b956">上面说了对于dom元素挂在到根标签div#root上以及一些元素的删除、更新等都是在commit阶段进行。 此外我们声明的一些useLayoutEffect、useEffect等hooks，以及组件的生命周期也会在该阶段运行。 commit又分为3个阶段分别为commitBeforeMutationEffects、commitMutationEffects、commitLayoutEffects</p> 
<h5 id="yPY71">1. commitBeforeMutationEffects</h5> 
<p id="u793ec5f6">个人认为该阶段主要是为后面两个阶段做一些准备工作</p> 
<p id="u29611074">对于不同组件，处理逻辑不同。 对于HostRoot根组件，在mount时会清除根节点div#root已有的子元素，为了插入App的dom做准备; 对于函数式组件，在这个阶段会通过react-scheduler以普通优先级调用useEffect但是不会立刻执行，可简单认为在这里加了一个延时器执行useEffect; 对于class组件会调用静态方法getSnapshotBeforeUpdate, 即组件被提交到dom之前的方法</p> 
<h5 id="VA9Qu">2. commitMutationEffects</h5> 
<p id="ud16df511">在这个阶段，主要是根据组件上打的对应标签，执行不同的逻辑； 比如mount阶段，App组件对应的dom节点就会挂在到div#root上了，此时页面就可以看到对应的元素了；在update时，会根据被打的标签执行对应的Update、Deletion、Placement等； 同时在该阶段，如果存在useLayoutEffect的回调即组件被销毁的函数也会在该阶段执行</p> 
<h5 id="uHO8Z">3. commitLayoutEffects</h5> 
<p id="u7640f555">因为上个阶段已经把组件的dom元素挂在到页面中去了， 这个阶段主要是执行组件的mount生命周期函数，比如函数组件的useLayoutEffect、componentDidMount；</p> 
<p id="uf49bff22">以上三个阶段执行完，如果没有更高优先级的任务(比如在didMount生命周期里有调用setState)， 则第一阶段延迟执行的函数会调用useEffect； 如果有则会进入update阶段，重新执行beginWork、completeWork、commit。 其实可以发现useEffect和componentDidMount的执行时机还是有区别的。</p> 
<p id="ua4a28bec">整个commit的主要函数调用流程如下</p> 
<p id="ua281d643"><br>  </p> 
<p id="u205a3099"></p> 
<p class="img-center"><img alt="" height="583" id="u616c2836" src="https://images2.imgbox.com/d4/2a/1YdEAaH8_o.png" width="720"></p> 
<p id="u80b6040b">tupian</p> 
<p id="u76299dc5"><br>  </p> 
<p id="u3e773d17">这样整个react的渲染和更新流程基本结束</p> 
<h3 id="EcyMO">总结</h3> 
<ol><li id="u26c5f33c">个人感官，用起来是相当的爽，特别是return出一个东西来，这就是组件的力量。</li><li id="u7ddbeefb">原理知道大体的意思就行，出了问题知道朝着哪个方向去找，react 官方的入门教程，有时间多读几遍价值很大的， <a href="https://zh-hans.react.dev/learn" rel="nofollow" title="快速入门 – React 中文文档">快速入门 – React 中文文档</a></li><li id="ucd2c8705">可能还有比较长的路要走，如果有可能，尽量还是用React吧，Vue立刻觉得不香了，哈哈，虽然，vue也不熟，就怕货比货，饱暖思淫欲，得客服。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05f7d2f1f2d0460518eff73e5d63d1f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">javaee——进程调度的基本过程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6438961c0dc61a54164542ff85b8e17a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MoviePy：超强的 视频处理Python 库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>