<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux编译过程 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/9843b8f4b37e780de463e6f9748b82d9/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Linux编译过程">
  <meta property="og:description" content="1.安装gcc,g&#43;&#43; 在终端输入以下命令：
sudo apt install gcc
sudo apt install g&#43;&#43;
就本质而言，gcc和g&#43;&#43;并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件类型，调用对应的GUN编译而已。
更准确的说法：gcc调用了C编译器，而g&#43;&#43;调用了C&#43;&#43;编译器。
gcc和g&#43;&#43;的主要区别
1）对于 *.c和*.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）；
2） 对于 *.c和*.cpp文件，g&#43;&#43;则统一当做cpp文件编译；
3）使用g&#43;&#43;编译文件时，g&#43;&#43;会自动链接标准库STL，而gcc不会自动链接STL；
4）gcc在编译C文件时，可使用的预定义宏是比较少的；
5）gcc在编译cpp文件时或者g&#43;&#43;在编译c文件和cpp文件时（这时候gcc和g&#43;&#43;调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：
#define __GXX_WEAK__ 1
#define __cplusplus 1
#define __DEPRECATED 1
#define __GNUG__ 4
#define __EXCEPTIONS 1
#define __private_extern__ extern
6）在用gcc编译c&#43;&#43;文件时，为了能够使用STL，需要加参数 –lstdc&#43;&#43; ，但这并不代表 gcc –lstdc&#43;&#43; 和 g&#43;&#43;等价，它们的区别不仅仅是这个，主要参数：
-g - turn on debugging (so GDB gives morefriendly output)
-Wall - turns on most warnings
-O or -O2 - turn on optimizations">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-05-07T11:41:14+08:00">
    <meta property="article:modified_time" content="2022-05-07T11:41:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux编译过程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1.安装gcc,g++</h3> 
<p>在终端输入以下命令：</p> 
<p>sudo apt install gcc</p> 
<p>sudo apt install g++</p> 
<p>就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件类型，调用对应的GUN编译而已。</p> 
<p>更准确的说法：gcc调用了C编译器，而g++调用了C++编译器。</p> 
<blockquote> 
 <p><strong>gcc和g++的主要区别</strong><br>     1）对于 *.c和*.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）；<br>     2） 对于 *.c和*.cpp文件，g++则统一当做cpp文件编译；<br>     3）使用g++编译文件时，g++会自动链接标准库STL，而gcc不会自动链接STL；<br>     4）gcc在编译C文件时，可使用的预定义宏是比较少的；<br>     5）gcc在编译cpp文件时或者g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：<br>     #define __GXX_WEAK__ 1<br>     #define __cplusplus 1<br>     #define __DEPRECATED 1<br>     #define __GNUG__ 4<br>     #define __EXCEPTIONS 1<br>     #define __private_extern__ extern<br>     6）在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个，主要参数：<br>     -g - turn on debugging (so GDB gives morefriendly output)<br>     -Wall - turns on most warnings<br>     -O or -O2 - turn on optimizations<br>     -o - name of the output file<br>     -c - output an object file (.o)<br>     -I - specify an includedirectory<br>     -L - specify a libdirectory<br>     -l - link with librarylib.a</p> 
</blockquote> 
<p>注意：gcc可以编译c++文件</p> 
<p>gcc -o mainc++ mainc++.cpp -lstdc++(指明用c++的标准库)</p> 
<h3>2.编译链接的四步</h3> 
<p>启动进程：路径+可执行文件名</p> 
<p>可以把可执行文件放到 /usr/bin 就可以省略路径了</p> 
<h4>（1）预编译:</h4> 
<p>gcc -E main.c -o main.i</p> 
<h4>（2）编译</h4> 
<p>gcc -S main.i -o main.s</p> 
<h4>（3）汇编</h4> 
<p>gcc -c main.s -o main.o</p> 
<h4>（4）链接</h4> 
<p>gcc main.o -o main</p> 
<p>执行: ./main</p> 
<p>或者:全路径/main</p> 
<h4>（5）一步执行，省略中间过程</h4> 
<p><span style="color:#0d0016;">1）三步合为一步</span></p> 
<p><span style="color:#0d0016;">即不经过预编译,编译,汇编三步,直接一步生成.o文件</span></p> 
<p><span style="color:#0d0016;"> gcc -c main.c -o main.o</span></p> 
<p><span style="color:#0d0016;">gcc -o main main.o</span></p> 
<p><span style="color:#0d0016;">2）四步合一步</span></p> 
<p><span style="color:#0d0016;">跳过中间部分从main.c到main语句：</span></p> 
<p><span style="color:#fe2c24;">gcc -o main main.c</span></p> 
<h4>（6）多个源文件执行</h4> 
<p>1）两步两步:</p> 
<p>gcc -c main.c</p> 
<p>gcc -c add.c</p> 
<p>gcc -c max.</p> 
<p>gcc -o main main.o add.o max.o</p> 
<p>2）一步完成</p> 
<p><span style="color:#fe2c24;">gcc -o main main.c add.c max.c</span></p> 
<h3>3.编译链接过程</h3> 
<p><img alt="" height="193" src="https://images2.imgbox.com/35/d0/oXerMYKM_o.png" width="504"></p> 
<p>main.c 通过预编译 生成main.i文件</p> 
<p>main.i 通过编译生成main.s 文件</p> 
<p>main.s 通过汇编生成main.o 文件</p> 
<p>链接阶段:将所有的.o .a(静态库文件) .lib(库文件) .obj文件链接起来,生成.out文件 ELF格式的可执行文件 .out文件(Windows生成的是.ext文件)</p> 
<h3>4.各阶段执行过程</h3> 
<h4>（1）预编译阶段:</h4> 
<p>1）删除所有的"#define",并且展开所有的宏定义;</p> 
<p>2）处理所有的条件预编译指令,"#if","#ifdef","#endif"等;</p> 
<p>3）处理"#include"预编译指令,将被包含的文件插入到该预编译指令的位置;</p> 
<p>4）删除所有的注释;</p> 
<p>5）添加行号和文件名标识,以便于编译器产生调试用的符号信息及编译时产生编译错 误和警告时显示行号;</p> 
<p>6）保留所有的#pragma编译器指令,因为编译器需要使用它们;</p> 
<h4>（2）编译阶段</h4> 
<p>词法分析,语法分析,语意分析,代码优化,汇总符号;</p> 
<h4>（3）汇编阶段</h4> 
<p>将汇编指令翻译成二进制格式,生成各个section,生成符号表</p> 
<h4>（4）链接阶段</h4> 
<p>1）合并各个section,调整section的起始位置和段大小,合并符号表,进行符号解析,给符 号分配虚拟地址;</p> 
<p>2）符号重定位,即在使用符号的地方全部替换成符号的虚拟地址;</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8594453ded237e70cf5e3fc9c69cb535/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TypeError:‘tuple‘ object is not callable</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c19bb9bb6f28128cdbe08041f2ae652/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Dubbo学习之自动配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>