<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>osg如何能在程序中改变视点的位置？如何不改变相机的位置来切换操作器 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/c4666bb62788f91e53be7c894b63e8dd/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="osg如何能在程序中改变视点的位置？如何不改变相机的位置来切换操作器">
  <meta property="og:description" content="这个问题一直困扰可很久，因为没有认真去看osg源码导致的。
1.在网上收集的资料很多都是 利用osg::carmea 的void setViewMatrixAsLookAt(const osg::Vec3d&amp;amp; eye,const osg::Vec3d&amp;amp; center,const osg::Vec3d&amp;amp; up);这样做能够做到，但是前提是不能使用viewer-》run（）。因为viwer-&amp;gt;run();会判断场景是否存在操作器，米有的话会自动添加操作器，从而抵消setViewMatrixAsLookAt（）函数的操作。
2.还可以利用 cameraManipulator-&amp;gt;setHomePosition(m_vPosEye, location, vUp); 但是etHomePosition(m_vPosEye, location, vUp);使用过程中会出现很多问题，因为这个函数原本的目的是为了home（）使用的，有时调到所需的视点位置后，鼠标和键盘不能移动了，在osgChina上Array大神给一位网友解释的很清除，有需要的可以在osgchina（）的论坛上搜索
3.利用cameraManipulator-&amp;gt;setmatrix();通过王锐大神的启发，使用这个函数可以调整视点位置，但是需要计算矩阵，比较头突疼，就没往下做
4.最近看源码发现了一个方法，setTransformation();这个函数凡是继承osgGA::StandardManipulator()都可以使用，原型为 virtual void setTransformation( const osg::Vec3d&amp;amp; eye, const osg::Vec3d&amp;amp; center, const osg::Vec3d&amp;amp; up );官方解释如下： /** Sets manipulator by eye position, center of rotation, and up vector.*/，通过设置三个视线向量来设置操作器的位置，这个好像正是需要找的那个函数，，这样只需在事件里填写自己需要的视线方向即可实现相机的视点的移动，
问题二：
另外当需要在同一视点下切换操作器时，及操作器切换的时候会自动根据绑定的node节点和相机的视线范围来自动的调整摄像机的初始位置，也即是切换操作器的时候视点会直接发生跳跃调整到操作器自适应的初始位置，若想不回到初始位置我想了一个办法：
1.事件中通过viewer-&amp;gt;getCamera()-&amp;gt;getViewMatrixAsLookAt(vPosEye, vCenter, vUp);来获取视点信息，同时vPosEye, vCenter需要调整，因为他们之间的距离被限定为1，因为这个函数原函数是
void getViewMatrixAsLookAt(osg::Vec3f&amp;amp; eye,osg::Vec3f&amp;amp; center,osg::Vec3f&amp;amp; up,float lookDistance=1.0f) const;，可以通过调整第四个参数来调整两者之间的距离到合适的大小，
2.利用setTransformation()和求得的视点信息来设置操作器，将设置完成的操作器加入viewer中。
osg::ref_ptr trac = new osgGA::TrackballManipulator(); trac-&amp;gt;setTransformation(m_vPosEye, location, vUp); viewer-&amp;gt;setCameraManipulator(trac);">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-04-16T22:22:47+08:00">
    <meta property="article:modified_time" content="2019-04-16T22:22:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">osg如何能在程序中改变视点的位置？如何不改变相机的位置来切换操作器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>这个问题一直困扰可很久，因为没有认真去看osg源码导致的。<br> 1.在网上收集的资料很多都是 利用osg::carmea 的void setViewMatrixAsLookAt(const osg::Vec3d&amp; eye,const osg::Vec3d&amp; center,const osg::Vec3d&amp; up);这样做能够做到，但是前提是不能使用viewer-》run（）。因为viwer-&gt;run();会判断场景是否存在操作器，米有的话会自动添加操作器，从而抵消setViewMatrixAsLookAt（）函数的操作。<br> 2.还可以利用    cameraManipulator-&gt;setHomePosition(m_vPosEye, location, vUp); 但是etHomePosition(m_vPosEye, location, vUp);使用过程中会出现很多问题，因为这个函数原本的目的是为了home（）使用的，有时调到所需的视点位置后，鼠标和键盘不能移动了，在osgChina上Array大神给一位网友解释的很清除，有需要的可以在osgchina（）的论坛上搜索<br> 3.利用cameraManipulator-&gt;setmatrix();通过王锐大神的启发，使用这个函数可以调整视点位置，但是需要计算矩阵，比较头突疼，就没往下做<br> 4.最近看源码发现了一个方法，setTransformation();这个函数凡是继承osgGA::StandardManipulator()都可以使用，原型为  virtual void setTransformation( const osg::Vec3d&amp; eye, const osg::Vec3d&amp; center, const osg::Vec3d&amp; up );官方解释如下：  /** Sets manipulator by eye position, center of rotation, and up vector.*/，通过设置三个视线向量来设置操作器的位置，这个好像正是需要找的那个函数，，这样只需在事件里填写自己需要的视线方向即可实现相机的视点的移动，<br> 问题二：<br> 另外当需要在同一视点下切换操作器时，及操作器切换的时候会自动根据绑定的node节点和相机的视线范围来自动的调整摄像机的初始位置，也即是切换操作器的时候视点会直接发生跳跃调整到操作器自适应的初始位置，若想不回到初始位置我想了一个办法：<br> 1.事件中通过viewer-&gt;getCamera()-&gt;getViewMatrixAsLookAt(vPosEye, vCenter, vUp);来获取视点信息，同时vPosEye, vCenter需要调整，因为他们之间的距离被限定为1，因为这个函数原函数是<br> void getViewMatrixAsLookAt(osg::Vec3f&amp; eye,osg::Vec3f&amp; center,osg::Vec3f&amp; up,float lookDistance=1.0f) const;，可以通过调整第四个参数来调整两者之间的距离到合适的大小，<br> 2.利用setTransformation()和求得的视点信息来设置操作器，将设置完成的操作器加入viewer中。<br>  osg::ref_ptr trac = new osgGA::TrackballManipulator();             <br>    trac-&gt;setTransformation(m_vPosEye, location, vUp);         <br>         viewer-&gt;setCameraManipulator(trac);</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b22ca3a0889c76696447852ee0f0407/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">org.springframework.jdbc.support.SQLErrorCodesFactory - SQLErrorCodes loaded: [DB2, Derby, H2, HSQL,</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c6888b7b49b4aa45c4286deb75ebcd5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Virtual Box实现ubuntu虚拟机和windows双向拖拽</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>