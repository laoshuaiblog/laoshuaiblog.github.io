<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>直流编码电机双闭环（速度&#43;角度）控制 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/9dc23c8c970915a28850ae014d9fe1a9/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="直流编码电机双闭环（速度&#43;角度）控制">
  <meta property="og:description" content="目录
1、PID框图
2、pid控制器的表达式
3、传感器数据获取
4、硬件设计
5、工程配置
6、软件部分程序配置
7、调参过程记录
本文已更新，加上曲线调试，更好效果，更多内容，详情：
编码电机PID调试（速度环|位置环|跟随）_桃成蹊2.0的博客-CSDN博客_编码器pid
串级控制系统介绍：
串级控制系统是改善控制质量的有效方法之一，在过程控制中得到了广泛的应用。所谓串级控制，就是采用两个控制器串联工作，外环控制器的输出作为内环控制器的设定值，由内环控制器的输出去操纵控制阀，从而对外环被控量具有更好的控制效果。这样的控制系统被称为串级系统。PID串级控制就是串级控制中的两个控制器均为PID控制器。
限于时间和篇幅，这篇仅记录用通用的pid方式进行感觉性的调参，等回家了有时间在把改进pid加上去试试效果
先把原理贴一遍
PID控制，就是对偏差进行比例、积分和微分的控制。PID由3个单元组成，分别是比例（P）单元、积分（I）单元、微分（D）单位。在工程实践中，一般P是必须的，所以衍生出许多组合的PID控制器，如PD、PI、PID等。
因为单片机是通过软件实现其控制算法的，所以必须对模拟调节器进行离散化处理，这样它只需根据釆样时刻的偏差值计算控制量。因此，我们需要使用离散的差分方程代替连续的微分方程。
通俗理解，用比例积分微分运算来消除误差，但是这个过程是连续的，周期性（一般是ms级的）的一次次计算来消除误差。
1、PID框图 速度环pid
位置环pid
2、pid控制器的表达式 经典的PID计算式如下所示：
将上述公式离散化，结果如下：
在使用ki和kd来代替积分就是下面的我们最常用的公式了（这个是比较常用的位置式pid版本）
之后我们再修改一种版本，如下所示（这种称为增量式pid）
可以看出这种仅统计当前误差和上一次误差，而上面的位置式统计了自起始以来所有的误差项，而上面的位置式版本输出后直接作为控制器输出值，而增量式则作为增加量叠加进入控制器的输出中。
3、传感器数据获取 霍尔码盘结构图：
编码电机上如下：
怎么读数据看下面这个，一张图一张表，对应着读取就知道了
这里注意：stm32用硬件编码器模式，这个读取的过程他是自动进行的，只要进行配置编码器模式就行了，但是其他没有硬件编码器模式的需要软件上模拟实现类似的功能，怎么模拟-就是按照下面的那个表，使用gpio中断加上if条件判读即可。
对应的上下信号说明如下所示：
读不懂就看口诀，立马懂：
CNT计数&#43;：
A上升沿，B逻辑低B上升沿，A逻辑高B下降沿，A逻辑低A下降沿，B逻辑高 CNT计数-：
A下降沿，B逻辑低B下降沿，A逻辑高B上升沿，A逻辑低A上升沿，B逻辑高 4、硬件设计 硬件其实没什么要求，画了块板子只是为了使用方便，这块板子接口上是直接兼容编码电机的，市面上几款我都试过了，基本不需要改线，直接插上就可以使用。
关注一下这个电机部分的接口吧，毕竟就这个有点用了
5、工程配置 可能有些没用的，主要看电机的pwm接口，编码器捕获接口，还有电机方向的接口把
定时器8 1 3 2采用编码器模式，配置如下
pwm设置，这里一个定时器就够了，重装载设置为7199，那pwm最大就是7200了，这就这样OK
基本时间配置，这里我没有采用操作系统的写法，直接用一个定时器中断了（毕竟是老工程了，拿过来直接用比较方便），使用定时器6，可以看出定时时间为1ms一次。
综上：资源配置如下
接口类型外设资源模式编码器口TIM8 TIM1 TIM3 TIM2编码器模式(T12)电机接口M11 M12 M21 M22 M31 M32 M41 M42看原理图PWM口TIM4 （CH1 ~ 4）变化范围0-7200基本定时TIM61ms一次 6、软件部分程序配置 1、电机配置，这里把每一个电机封装成一个函数，内函限幅，电机换向，PWM设置，是比较方便的，墙裂推荐hhh
void AAC_MotorFL_Run(int16_t speed) { if(speed &amp;gt; 0) {GPIOE-&amp;gt;BRR = m11_Pin;GPIOE-&amp;gt;BSRR = m12_Pin;} else {speed = -speed;GPIOE-&amp;gt;BSRR = m11_Pin;GPIOE-&amp;gt;BRR = m12_Pin;} if(speed &amp;gt; 7100) speed = 7100; __HAL_TIM_SetCompare(&amp;amp;htim4,TIM_CHANNEL_1,speed); } void AAC_MotorFR_Run(int16_t speed) { if(speed &amp;gt; 0) {GPIOE-&amp;gt;BRR = m21_Pin;GPIOE-&amp;gt;BSRR = m22_Pin;} else {speed = -speed;GPIOE-&amp;gt;BSRR = m21_Pin;GPIOE-&amp;gt;BRR = m22_Pin;} if(speed &amp;gt; 7100) speed = 7100; __HAL_TIM_SetCompare(&amp;amp;htim4,TIM_CHANNEL_2,speed); } void AAC_MotorBL_Run(int16_t speed) { if(speed &amp;gt; 0) {GPIOC-&amp;gt;BRR = m31_Pin;GPIOC-&amp;gt;BSRR = m32_Pin;} else {speed = -speed;GPIOC-&amp;gt;BSRR = m31_Pin;GPIOC-&amp;gt;BRR = m32_Pin;} if(speed &amp;gt; 7100) speed = 7100; __HAL_TIM_SetCompare(&amp;amp;htim4,TIM_CHANNEL_3,speed); } void AAC_MotorBR_Run(int16_t speed) { if(speed &amp;gt; 0) {GPIOC-&amp;gt;BRR = m41_Pin;GPIOC-&amp;gt;BSRR = m42_Pin;} else {speed = -speed;GPIOC-&amp;gt;BSRR = m41_Pin;GPIOC-&amp;gt;BRR = m42_Pin;} if(speed &amp;gt; 7100) speed = 7100; __HAL_TIM_SetCompare(&amp;amp;htim4,TIM_CHANNEL_4,speed); } 2、编码器测速，定时器的编码器模式是特殊的计数模式，测量值还是保存在cnt中的，因此只要读取cnt的值就可以获取编码器当前的计数值了。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-07-03T13:54:47+08:00">
    <meta property="article:modified_time" content="2022-07-03T13:54:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">直流编码电机双闭环（速度&#43;角度）控制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E5%9B%A0%E6%AD%A4PID%E5%A4%A7%E6%A6%82%E6%A1%86%E5%9B%BE-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%9B%A0%E6%AD%A4PID%E5%A4%A7%E6%A6%82%E6%A1%86%E5%9B%BE" rel="nofollow">1、PID框图</a></p> 
<p id="%C2%A02%E3%80%81pid%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA-toc" style="margin-left:40px;"><a href="#%C2%A02%E3%80%81pid%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA" rel="nofollow">2、pid控制器的表达式</a></p> 
<p id="3%E3%80%81%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96" rel="nofollow">3、传感器数据获取</a></p> 
<p id="4%E3%80%81%E9%87%87%E7%94%A8%E7%A1%AC%E4%BB%B6%E5%A6%82%E4%B8%8B%EF%BC%88%E5%B7%B2%E7%BB%8F%E5%9C%A8%E7%AB%8B%E5%88%9B%E5%BC%80%E6%BA%90%EF%BC%89-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E9%87%87%E7%94%A8%E7%A1%AC%E4%BB%B6%E5%A6%82%E4%B8%8B%EF%BC%88%E5%B7%B2%E7%BB%8F%E5%9C%A8%E7%AB%8B%E5%88%9B%E5%BC%80%E6%BA%90%EF%BC%89" rel="nofollow">4、硬件设计</a></p> 
<p id="%C2%A05%E3%80%81%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%C2%A05%E3%80%81%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE" rel="nofollow">5、工程配置</a></p> 
<p id="%C2%A06%E3%80%81%E8%BD%AF%E4%BB%B6%E9%83%A8%E5%88%86%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%C2%A06%E3%80%81%E8%BD%AF%E4%BB%B6%E9%83%A8%E5%88%86%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE" rel="nofollow">6、软件部分程序配置</a></p> 
<p id="7%E3%80%81%E8%B0%83%E5%8F%82%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E8%B0%83%E5%8F%82%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95" rel="nofollow">7、调参过程记录</a></p> 
<hr id="hr-toc"> 
<p>本文已更新，加上曲线调试，更好效果，更多内容，详情：</p> 
<p><a href="https://blog.csdn.net/m0_51220742/article/details/124337228?spm=1001.2014.3001.5501" title="编码电机PID调试（速度环|位置环|跟随）_桃成蹊2.0的博客-CSDN博客_编码器pid">编码电机PID调试（速度环|位置环|跟随）_桃成蹊2.0的博客-CSDN博客_编码器pid</a></p> 
<blockquote> 
 <p> 串级控制系统介绍：</p> 
</blockquote> 
<p><a href="https://baike.baidu.com/item/%E4%B8%B2%E7%BA%A7%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/7462562" rel="nofollow" title="       串级控制系统">       串级控制系统</a>是改善控制质量的有效方法之一，在过程控制中得到了广泛的应用。所谓<a href="https://baike.baidu.com/item/%E4%B8%B2%E7%BA%A7%E6%8E%A7%E5%88%B6/5459307" rel="nofollow" title="串级控制">串级控制</a>，就是采用两个控制器串联工作，外环控制器的输出作为内环控制器的设定值，由内环控制器的输出去操纵控制阀，从而对外环被控量具有更好的控制效果。这样的控制系统被称为串级系统。PID串级控制就是串级控制中的两个控制器均为<a href="https://baike.baidu.com/item/PID%E6%8E%A7%E5%88%B6%E5%99%A8" rel="nofollow" title="PID控制器">PID控制器</a>。</p> 
<p><strong>        限于时间和篇幅，这篇仅记录用通用的pid方式进行感觉性的调参，等回家了有时间在把改进pid加上去试试效果</strong></p> 
<p style="text-align:center;"><img alt="" height="185" src="https://images2.imgbox.com/4d/bd/EloBbzrS_o.png" width="189"></p> 
<p></p> 
<blockquote> 
 <p>先把原理贴一遍</p> 
</blockquote> 
<p>        PID控制，就是<strong>对偏差进行比例、积分和微分的控制</strong>。PID由3个单元组成，分别是比例（P）单元、积分（I）单元、微分（D）单位。在工程实践中，一般P是必须的，所以衍生出许多组合的PID控制器，如PD、PI、PID等。<br>         因为单片机是通过软件实现其控制算法的，所以必须对模拟调节器进行离散化处理，这样它只需根据釆样时刻的偏差值计算控制量。因此，我们需要<strong>使用离散的差分方程代替连续的微分方程</strong>。</p> 
<p></p> 
<p><strong><span style="background-color:#ffd900;">通俗理解，用比例积分微分运算来消除误差，但是这个过程是连续的，周期性（一般是ms级的）的一次次计算来消除误差。</span></strong></p> 
<p></p> 
<h3 id="1%E3%80%81%E5%9B%A0%E6%AD%A4PID%E5%A4%A7%E6%A6%82%E6%A1%86%E5%9B%BE">1、PID框图</h3> 
<blockquote> 
 <p>速度环pid</p> 
</blockquote> 
<p><img alt="" height="312" src="https://images2.imgbox.com/1c/79/b99b2vYK_o.png" width="838"></p> 
<blockquote> 
 <p> 位置环pid</p> 
</blockquote> 
<p><img alt="" height="372" src="https://images2.imgbox.com/73/79/Ed7BboE5_o.png" width="860"></p> 
<h3 id="%C2%A02%E3%80%81pid%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA">2、pid控制器的表达式</h3> 
<p>经典的PID计算式如下所示：</p> 
<p style="text-align:center;"><img alt="" height="105" src="https://images2.imgbox.com/c7/91/ZPgBBjle_o.png" width="830"></p> 
<p><span style="background-color:#ff9900;"> 将上述公式离散化，结果如下：</span></p> 
<p><img alt="" height="95" src="https://images2.imgbox.com/9a/04/J4K5qMjI_o.png" width="854"></p> 
<p><span style="background-color:#ff9900;"> 在使用ki和kd来代替积分就是下面的我们最常用的公式了（这个是比较常用的位置式pid版本）</span></p> 
<p><img alt="" height="70" src="https://images2.imgbox.com/3f/09/G8ieJFhQ_o.png" width="842"></p> 
<p><span style="background-color:#ff9900;"> 之后我们再修改一种版本，如下所示（这种称为增量式pid）</span></p> 
<p><img alt="" height="47" src="https://images2.imgbox.com/5a/48/OUlluh7w_o.png" width="865"></p> 
<p><strong>可以看出这种仅统计当前误差和上一次误差，而上面的位置式统计了自起始以来所有的误差项，而上面的位置式版本输出后直接作为控制器输出值，而增量式则作为增加量叠加进入控制器的输出中。</strong></p> 
<p></p> 
<h3 id="3%E3%80%81%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96">3、传感器数据获取</h3> 
<p>霍尔码盘结构图：</p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/d8/17/qvVXKVzs_o.png" width="977"></p> 
<p> 编码电机上如下：</p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/db/d6/GYwDVpGo_o.png" width="1161"></p> 
<p> 怎么读数据看下面这个，一张图一张表，对应着读取就知道了</p> 
<p><span style="background-color:#ff9900;">这里注意：stm32用硬件编码器模式，这个读取的过程他是自动进行的，只要进行配置编码器模式就行了，但是其他没有硬件编码器模式的需要软件上模拟实现类似的功能，怎么模拟-就是按照下面的那个表，使用gpio中断加上if条件判读即可。</span></p> 
<p><img alt="" height="444" src="https://images2.imgbox.com/6a/04/ePI0Ke2z_o.png" width="1026"></p> 
<p>对应的上下信号说明如下所示：</p> 
<p><img alt="" height="329" src="https://images2.imgbox.com/ee/84/ar2CgEGJ_o.png" width="965"></p> 
<blockquote> 
 <p>读不懂就看口诀，立马懂：</p> 
</blockquote> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;"><strong>CNT</strong></span><span style="color:#000000;"><strong>计数</strong></span><span style="color:#000000;"><strong>+</strong></span><span style="color:#000000;"><strong>：</strong></span></p> 
<ul><li style="margin-left:0in;text-align:left;"><span style="color:#000000;">A</span><span style="color:#000000;">上升沿，</span><span style="color:#000000;">B</span><span style="color:#000000;">逻辑低</span></li><li style="margin-left:0in;text-align:left;"><span style="color:#000000;">B</span><span style="color:#000000;">上升沿，</span><span style="color:#000000;">A</span><span style="color:#000000;">逻辑高</span></li><li style="margin-left:0in;text-align:left;"><span style="color:#000000;">B</span><span style="color:#000000;">下降沿，</span><span style="color:#000000;">A</span><span style="color:#000000;">逻辑低</span></li><li style="margin-left:0in;text-align:left;"><span style="color:#000000;">A</span><span style="color:#000000;">下降沿，</span><span style="color:#000000;">B</span><span style="color:#000000;">逻辑高</span></li></ul> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;"><strong>CNT</strong></span><span style="color:#000000;"><strong>计数</strong></span><span style="color:#000000;"><strong>-</strong></span><span style="color:#000000;"><strong>：</strong></span></p> 
<ul><li style="margin-left:0in;text-align:left;"><span style="color:#000000;">A</span><span style="color:#000000;">下降沿，</span><span style="color:#000000;">B</span><span style="color:#000000;">逻辑低</span></li><li style="margin-left:0in;text-align:left;"><span style="color:#000000;">B</span><span style="color:#000000;">下降沿，</span><span style="color:#000000;">A</span><span style="color:#000000;">逻辑高</span></li><li style="margin-left:0in;text-align:left;"><span style="color:#000000;">B</span><span style="color:#000000;">上升沿，</span><span style="color:#000000;">A</span><span style="color:#000000;">逻辑低</span></li><li style="margin-left:0in;text-align:left;"><span style="color:#000000;">A</span><span style="color:#000000;">上升沿，</span><span style="color:#000000;">B</span><span style="color:#000000;">逻辑高</span></li></ul> 
<h3 id="4%E3%80%81%E9%87%87%E7%94%A8%E7%A1%AC%E4%BB%B6%E5%A6%82%E4%B8%8B%EF%BC%88%E5%B7%B2%E7%BB%8F%E5%9C%A8%E7%AB%8B%E5%88%9B%E5%BC%80%E6%BA%90%EF%BC%89"><strong>4、硬件设计</strong></h3> 
<p>硬件其实没什么要求，画了块板子只是为了使用方便，这块板子接口上是直接兼容编码电机的，市面上几款我都试过了，基本不需要改线，直接插上就可以使用。</p> 
<p><img alt="" height="609" src="https://images2.imgbox.com/f5/26/WwPCrDE0_o.png" width="754"> 关注一下这个电机部分的接口吧，毕竟就这个有点用了</p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/88/6d/peVRocMf_o.png" width="760"></p> 
<h3 id="%C2%A05%E3%80%81%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE">5、工程配置</h3> 
<p><strong>可能有些没用的，主要看电机的pwm接口，编码器捕获接口，还有电机方向的接口把</strong></p> 
<p><img alt="" height="725" src="https://images2.imgbox.com/ae/47/3nkaph1L_o.png" width="744"></p> 
<p> 定时器8 1 3 2采用编码器模式，配置如下</p> 
<p><img alt="" height="839" src="https://images2.imgbox.com/bc/eb/fwzoUXgL_o.png" width="768"></p> 
<p> pwm设置，这里一个定时器就够了，重装载设置为7199，那pwm最大就是7200了，这就这样OK</p> 
<p><img alt="" height="819" src="https://images2.imgbox.com/36/e0/S8OMl5Vv_o.png" width="760"></p> 
<p> 基本时间配置，这里我没有采用操作系统的写法，直接用一个定时器中断了（毕竟是老工程了，拿过来直接用比较方便），使用定时器6，可以看出定时时间为1ms一次。</p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/2c/e2/umGtEc2x_o.png" width="987"></p> 
<p> 综上：资源配置如下</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:97px;">接口类型</td><td style="width:322px;">外设资源</td><td>模式</td></tr><tr><td style="width:97px;">编码器口</td><td style="width:322px;">TIM8 TIM1 TIM3 TIM2</td><td>编码器模式(T12)</td></tr><tr><td style="width:97px;">电机接口</td><td style="width:322px;">M11 M12 M21 M22 M31 M32 M41 M42</td><td>看原理图</td></tr><tr><td style="width:97px;">PWM口</td><td style="width:322px;">TIM4 （CH1 ~ 4）</td><td>变化范围0-7200</td></tr><tr><td style="width:97px;">基本定时</td><td style="width:322px;">TIM6</td><td>1ms一次</td></tr></tbody></table> 
<h3 id="%C2%A06%E3%80%81%E8%BD%AF%E4%BB%B6%E9%83%A8%E5%88%86%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE">6、软件部分程序配置</h3> 
<p><strong>1、电机配置，这里把每一个电机封装成一个函数，内函限幅，电机换向，PWM设置，是比较方便的，墙裂推荐hhh</strong></p> 
<pre><code>void AAC_MotorFL_Run(int16_t speed)
{
	if(speed &gt; 0)  	{GPIOE-&gt;BRR = m11_Pin;GPIOE-&gt;BSRR = m12_Pin;}
	else            {speed = -speed;GPIOE-&gt;BSRR = m11_Pin;GPIOE-&gt;BRR = m12_Pin;}
	if(speed &gt; 7100) speed = 7100;
	__HAL_TIM_SetCompare(&amp;htim4,TIM_CHANNEL_1,speed);
}
void AAC_MotorFR_Run(int16_t speed)
{
	if(speed &gt; 0)  	{GPIOE-&gt;BRR = m21_Pin;GPIOE-&gt;BSRR = m22_Pin;}
	else            {speed = -speed;GPIOE-&gt;BSRR = m21_Pin;GPIOE-&gt;BRR = m22_Pin;}
	if(speed &gt; 7100) speed = 7100;
	__HAL_TIM_SetCompare(&amp;htim4,TIM_CHANNEL_2,speed);
}
void AAC_MotorBL_Run(int16_t speed)
{
	if(speed &gt; 0)  	{GPIOC-&gt;BRR = m31_Pin;GPIOC-&gt;BSRR = m32_Pin;}
	else            {speed = -speed;GPIOC-&gt;BSRR = m31_Pin;GPIOC-&gt;BRR = m32_Pin;}
	if(speed &gt; 7100) speed = 7100;
	__HAL_TIM_SetCompare(&amp;htim4,TIM_CHANNEL_3,speed);
}
void AAC_MotorBR_Run(int16_t speed)
{
	if(speed &gt; 0)  	{GPIOC-&gt;BRR = m41_Pin;GPIOC-&gt;BSRR = m42_Pin;}
	else            {speed = -speed;GPIOC-&gt;BSRR = m41_Pin;GPIOC-&gt;BRR = m42_Pin;}
	if(speed &gt; 7100) speed = 7100;
	__HAL_TIM_SetCompare(&amp;htim4,TIM_CHANNEL_4,speed);
}</code></pre> 
<p><strong> 2、编码器测速，定时器的编码器模式是特殊的计数模式，测量值还是保存在cnt中的，因此只要读取cnt的值就可以获取编码器当前的计数值了。</strong></p> 
<pre><code>int Read_Encoder(uint8_t TIMX)
{
	int Encoder_TIM;
	switch(TIMX)
	{
	   case 2:  Encoder_TIM = (short)TIM2 -&gt; CNT;  TIM2 -&gt; CNT=0;break;
		 case 3:  Encoder_TIM = (short)TIM3 -&gt; CNT;  TIM3 -&gt; CNT=0;break;	
		 case 1:  Encoder_TIM = (short)TIM1 -&gt; CNT;  TIM1 -&gt; CNT=0;break;	
		 case 8:  Encoder_TIM = (short)TIM8 -&gt; CNT;  TIM8 -&gt; CNT=0;break;
		 default:  Encoder_TIM = 0;
	}
	return Encoder_TIM;
}</code></pre> 
<p><strong>3、测量值大小问题 市面上常用的编码电机有两种，由电机+减速箱+编码器组成，电机为最内部的主体，前端套筒为减速箱，最尾部的为编码器，捕获到的值由编码器和减速箱共同决定。</strong></p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/0a/5f/neCzbfCL_o.png" width="885"></p> 
<p>减速比可由电机上的贴纸或者型号获取，比如贴了10F，就是减速比为10：1的意思</p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/4b/5f/Zbm6VxbG_o.png" width="793"></p> 
<p> 下面说明了常见霍尔编码器和光电编码器的编码器线束</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/3a/e4/RaG3iHIr_o.png" width="906"></p> 
<p> 可以看出关电编码器的线数是远大于霍尔编码器的，这使得光电编码器更适合高精度的应用，那么最终公式为</p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong><span style="background-color:#ff9900;">主动轴一圈=减速比*编码器线数</span></strong></span></p> 
<p style="text-align:center;"></p> 
<p><strong>4、定时器创建任务周期，前面已经创建了1ms一次的定时器中断，这里在中断服务函数中加入判断，这里根据经验判断如下（为啥呢，这样取得值比较合理，大概pwm满载的时候速度最大100多）：</strong></p> 
<ul><li><span style="color:#fe2c24;">光电编码器：2ms读取一次数据</span></li><li><span style="color:#fe2c24;">霍尔编码器：10ms读取一次数据</span></li></ul> 
<pre><code>//定时器任务周期
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  static int time;
  if(htim-&gt;Instance == htim6.Instance)
  {
		if(time % 10 == 0)
		{
            //10ms执行一次
		}
		if(time &gt;= 1000)
		{
			time = 0;
			HAL_GPIO_TogglePin(GPIOD, led_Pin);
		}
  }
}</code></pre> 
<p></p> 
<p><strong>5、pid公式</strong></p> 
<ul><li><strong>这是直接根据离散公式还原来的</strong></li></ul> 
<pre><code>typedef struct
{
	float Kp, Ki, Kd;
	float P, I, D;
	float Error_Last;	
}PositionPID_t;
// pid计算
int Position_PID( PositionPID_t *pid, float set_value, float now_value )
{
	pid-&gt;P = set_value - now_value;
	pid-&gt;I += pid-&gt;P;
	pid-&gt;D = pid-&gt;P - pid-&gt;Error_Last;
	pid-&gt;Error_Last = pid-&gt;P;
	pid-&gt;I=pid-&gt;I&gt;10000?10000:(pid-&gt;I&lt;(-10000)?(-10000):pid-&gt;I);
	if( set_value == 0 )			pid-&gt;I = 0;
	
	return( pid-&gt;Kp*pid-&gt;P  +  pid-&gt;Ki*pid-&gt;I  +  pid-&gt;Kd*pid-&gt;D );
}</code></pre> 
<ul><li> 平衡小车之家抄来的</li></ul> 
<pre><code>//位置式PID控制器
int Position_PI (int Encoder, int Target)
{
  //   float Kp=0.02,Ki=0.0002;
  static int Bias, Pwm;
  static long Integral_bias;
  Bias = Encoder - Target;            //计算偏差
  Integral_bias += Bias;	             //求出偏差的积分
  if(Integral_bias &gt; 1500000)  Integral_bias = 1500000; //积分限幅
  if(Integral_bias &lt; -1500000)  Integral_bias = -1500000; //积分限幅
  Pwm = Position_Kp * Bias + Position_Ki * Integral_bias; //位置式PI控制器
  return Pwm;                         //增量输出
}
//增量PI控制器
int Incremental_PI (int Encoder, int Target)
{
  //   float Kp=20,Ki=30;
  static int Bias, Pwm, Last_bias;
  Bias = Encoder - Target;            //计算偏差
  Pwm += Incremental_Kp * (Bias - Last_bias) + Incremental_Ki * Bias; //增量式PI控制器
  Last_bias = Bias;	                 //保存上一次偏差
  return Pwm;                         //增量输出
}</code></pre> 
<ul><li>大疆robomaster官方例程 </li></ul> 
<p>pid.c</p> 
<pre><code>#include "pid.h"
#include "main.h"

#define LimitMax(input, max)   \
    {                          \
        if (input &gt; max)       \
        {                      \
            input = max;       \
        }                      \
        else if (input &lt; -max) \
        {                      \
            input = -max;      \
        }                      \
    }

void PID_init(pid_type_def *pid, uint8_t mode, const fp32 PID[3], fp32 max_out, fp32 max_iout)
{
  if (pid == NULL || PID == NULL)
  {
    return;
  }
  pid-&gt;mode = mode;
  pid-&gt;Kp = PID[0];
  pid-&gt;Ki = PID[1];
  pid-&gt;Kd = PID[2];
  pid-&gt;max_out = max_out;
  pid-&gt;max_iout = max_iout;
  pid-&gt;Dbuf[0] = pid-&gt;Dbuf[1] = pid-&gt;Dbuf[2] = 0.0f;
  pid-&gt;error[0] = pid-&gt;error[1] = pid-&gt;error[2] = pid-&gt;Pout = pid-&gt;Iout = pid-&gt;Dout = pid-&gt;out = 0.0f;
}

fp32 PID_calc(pid_type_def *pid, fp32 ref, fp32 set)
{
  if (pid == NULL)
  {
    return 0.0f;
  }
  pid-&gt;error[2] = pid-&gt;error[1];
  pid-&gt;error[1] = pid-&gt;error[0];
  pid-&gt;set = set;
  pid-&gt;fdb = ref;
  pid-&gt;error[0] = set - ref;
  if (pid-&gt;mode == PID_POSITION)
  {
    pid-&gt;Pout = pid-&gt;Kp * pid-&gt;error[0];
    pid-&gt;Iout += pid-&gt;Ki * pid-&gt;error[0];
    pid-&gt;Dbuf[2] = pid-&gt;Dbuf[1];
    pid-&gt;Dbuf[1] = pid-&gt;Dbuf[0];
    pid-&gt;Dbuf[0] = (pid-&gt;error[0] - pid-&gt;error[1]);
    pid-&gt;Dout = pid-&gt;Kd * pid-&gt;Dbuf[0];
    LimitMax(pid-&gt;Iout, pid-&gt;max_iout);
    pid-&gt;out = pid-&gt;Pout + pid-&gt;Iout + pid-&gt;Dout;
    LimitMax(pid-&gt;out, pid-&gt;max_out);
  }
  else if (pid-&gt;mode == PID_DELTA)
  {
    pid-&gt;Pout = pid-&gt;Kp * (pid-&gt;error[0] - pid-&gt;error[1]);
    pid-&gt;Iout = pid-&gt;Ki * pid-&gt;error[0];
    pid-&gt;Dbuf[2] = pid-&gt;Dbuf[1];
    pid-&gt;Dbuf[1] = pid-&gt;Dbuf[0];
    pid-&gt;Dbuf[0] = (pid-&gt;error[0] - 2.0f * pid-&gt;error[1] + pid-&gt;error[2]);
    pid-&gt;Dout = pid-&gt;Kd * pid-&gt;Dbuf[0];
    pid-&gt;out += pid-&gt;Pout + pid-&gt;Iout + pid-&gt;Dout;
    LimitMax(pid-&gt;out, pid-&gt;max_out);
  }
  return pid-&gt;out;
}

void PID_clear(pid_type_def *pid)
{
  if (pid == NULL)
  {
    return;
  }
  pid-&gt;error[0] = pid-&gt;error[1] = pid-&gt;error[2] = 0.0f;
  pid-&gt;Dbuf[0] = pid-&gt;Dbuf[1] = pid-&gt;Dbuf[2] = 0.0f;
  pid-&gt;out = pid-&gt;Pout = pid-&gt;Iout = pid-&gt;Dout = 0.0f;
  pid-&gt;fdb = pid-&gt;set = 0.0f;
}
</code></pre> 
<p>pid.h</p> 
<pre><code>
#ifndef PID_H
#define PID_H
#include "struct_typedef.h"
enum PID_MODE
{
  PID_POSITION = 0,
  PID_DELTA
};

typedef struct
{
  uint8_t mode;
  //PID 三参数
  fp32 Kp;
  fp32 Ki;
  fp32 Kd;

  fp32 max_out;  //最大输出
  fp32 max_iout; //最大积分输出

  fp32 set;
  fp32 fdb;

  fp32 out;
  fp32 Pout;
  fp32 Iout;
  fp32 Dout;
  fp32 Dbuf[3];  //微分项 0最新 1上一次 2上上次
  fp32 error[3]; //误差项 0最新 1上一次 2上上次

} pid_type_def;

extern void PID_init(pid_type_def *pid, uint8_t mode, const fp32 PID[3], fp32 max_out, fp32 max_iout);
extern fp32 PID_calc(pid_type_def *pid, fp32 ref, fp32 set);
extern void PID_clear(pid_type_def *pid);

#endif
</code></pre> 
<p>大疆官例写的比较直观，有面向对象的感觉了，用起来舒服，但是也是直接套公式，没有加入一些优化pid的方法，下一版本我将用完善版本的。 </p> 
<p></p> 
<h3 id="7%E3%80%81%E8%B0%83%E5%8F%82%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95">7、调参过程记录</h3> 
<p>先放经典图，参数的作用看图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3e/8d/Xm1Zrp7x_o.gif"></p> 
<p></p> 
<p><span style="background-color:#ff9900;">速度单环：周期中代码如下</span></p> 
<pre><code>			enc = Read_Encoder(8);
			pwm = PID_calc(&amp;motor_speed_pid,enc,target);//速度环
			AAC_MotorFL_Run(pwm);</code></pre> 
<p style="text-align:center;"><img alt="" height="198" src="https://images2.imgbox.com/1a/8c/Lk7TDpRT_o.gif" width="200"></p> 
<p><span style="background-color:#ff9900;"> 位置单环：周期中代码如下</span></p> 
<pre><code>			enc += Read_Encoder(8);
			pwm = PID_calc(&amp;motor_angle_pid,enc,target);//位置环
			AAC_MotorFL_Run(pwm);</code></pre> 
<p style="text-align:center;"><img alt="" height="192" src="https://images2.imgbox.com/fa/6e/91qI5QkW_o.gif" width="200"></p> 
<p><span style="background-color:#ff9900;">位置速度双环：周期中代码如下</span></p> 
<pre><code>			enc += Read_Encoder(8);
			pwm = PID_calc(&amp;motor_angle_pid,enc,target);//位置环
			pwm = PID_calc(&amp;motor_speed_pid,Read_Encoder(8),pwm);//速度环
			AAC_MotorFL_Run(pwm);</code></pre> 
<p>角度控制效果 ，调的不是很好，下次一定hhh</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4a/05/RH8OZ50o_o.gif"></p> 
<p></p> 
<p><span style="background-color:#ff9900;">说明：做角度控制其实单独使用位置环已经有一定效果了，但是没有串起来效果好，也没有串起来稳定，所以建议还是双闭环，角度仅仅作为一个调参练习即可。 </span></p> 
<p>源码我已上传到csdn，链接如下 </p> 
<p><a href="https://download.csdn.net/download/m0_51220742/77132310" title="直流编码电机速度位置双闭环-制造文档类资源-CSDN文库">直流编码电机速度位置双闭环-制造文档类资源-CSDN文库</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d86e877e7a3d5ef1cc97f607313ed1b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【微信小程序】使用webstorm进行开发，支持代码提示高亮等</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/93af355438049ec9a248dffadc62e57c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">react基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>