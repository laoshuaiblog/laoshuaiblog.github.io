<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux-编译工具 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/ecb4aeb70f6b76d89bd491fd38129424/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Linux-编译工具">
  <meta property="og:description" content="一、gcc 1.1 一步到位 gcc 最简单的用法
gcc c_name.c	# 会产生一个 a.out 的可执行文件 这样会生成一个叫做 a.out 的可执行文件。
如果想要指定生成文件的名字，可以采用 -o 选项，也就是 output。比如下面的指令
gcc -o hello hello.c 这个 -o 参数可以跟在后面讲的所有指令后面，也就是说，可以给所有生成的中间文件进行命名。
如果想要最佳化执行速度，可以使用下面的命令：
gcc -O c_name.c 可以根据操作环境最佳化执行速度
如果想要显示警告信息，可以用 -Wall 参数，如下
gcc -o hello hello.c -Wall 这样一步到位，似乎只能适用于比较低端的情况，如果想要更细致的操作，需要了解整个编译的流程，即图：
1.2 预处理 ​ 在这个过程就是展开宏定义和include文件，可以使用如下命令
gcc -E c_name.c ​ 但是直接使用这条命令，不会生成一个 .i 文件，而是将展开结果直接输出到终端，所以得指定一个名字
gcc -E c_name.c -o i_name.i ​ 生成完的文件会特别丑，大概这样：
​ 在这里，我们还有一个问题，就是头文件在哪里，我们系统一般会把头文件存在 /usr/include 下（ /usr 不是user的缩写,其实usr是Unix Software Resource的缩写, 也就是Unix操作系统软件资源所放置的目录,而不是用户的数据;所有系统默认的软件都会放置到 /usr），这个文件夹长这样，里面有我们常用的头文件
当然我们也可以使用指令来指定我们的头文件：
gcc c_name.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-04-05T08:43:58+08:00">
    <meta property="article:modified_time" content="2023-04-05T08:43:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux-编译工具</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="gcc_2"></a>一、gcc</h3> 
<h4><a id="11__4"></a>1.1 一步到位</h4> 
<p>gcc 最简单的用法</p> 
<pre><code class="prism language-bash">gcc c_name.c						<span class="token comment"># 会产生一个 a.out 的可执行文件</span>
</code></pre> 
<p>这样会生成一个叫做 <code>a.out</code> 的可执行文件。</p> 
<p>如果想要指定生成文件的名字，可以采用 <code>-o</code> 选项，也就是 <code>output</code>。比如下面的指令</p> 
<pre><code class="prism language-bash">gcc -o hello hello.c
</code></pre> 
<p><img src="https://images2.imgbox.com/f6/a3/vYjtLbld_o.png" alt="在这里插入图片描述"></p> 
<p>这个 <code>-o</code> 参数可以跟在后面讲的所有指令后面，也就是说，可以给所有生成的中间文件进行命名。</p> 
<p>如果想要最佳化执行速度，可以使用下面的命令：</p> 
<pre><code class="prism language-bash">gcc -O c_name.c
</code></pre> 
<p>可以根据操作环境最佳化执行速度</p> 
<p>如果想要显示警告信息，可以用 <code>-Wall</code> 参数，如下</p> 
<pre><code class="prism language-bash">gcc -o hello hello.c -Wall
</code></pre> 
<p>这样一步到位，似乎只能适用于比较低端的情况，如果想要更细致的操作，需要了解整个编译的流程，即图：</p> 
<p><img src="https://images2.imgbox.com/26/44/2ghU54JY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="12__44"></a>1.2 预处理</h4> 
<p>​ 在这个过程就是展开宏定义和include文件，可以使用如下命令</p> 
<pre><code>gcc -E c_name.c
</code></pre> 
<p>​ 但是直接使用这条命令，不会生成一个 <code>.i</code> 文件，而是将展开结果直接输出到终端，所以得指定一个名字</p> 
<pre><code>gcc -E c_name.c -o i_name.i
</code></pre> 
<p><img src="https://images2.imgbox.com/4f/3f/0AOdTmjj_o.png" alt="在这里插入图片描述"></p> 
<p>​ 生成完的文件会特别丑，大概这样：</p> 
<p><img src="https://images2.imgbox.com/34/63/UEZNBR7h_o.png" alt="在这里插入图片描述"></p> 
<p>​ 在这里，我们还有一个问题，就是<strong>头文件</strong>在哪里，我们系统一般会把头文件存在 <code>/usr/include</code> 下（ <code>/usr</code> 不是user的缩写,其实usr是<strong>Unix Software Resource</strong>的缩写, 也就是Unix操作系统软件资源所放置的目录,而不是用户的数据;所有系统默认的软件都会放置到 <code>/usr</code>），这个文件夹长这样，里面有我们常用的头文件</p> 
<p><img src="https://images2.imgbox.com/cd/5b/y3aLsMG2_o.png" alt="在这里插入图片描述"></p> 
<p>当然我们也可以使用指令来指定我们的头文件：</p> 
<pre><code class="prism language-bash">gcc c_name.c -I head_path
</code></pre> 
<p>为了演示这个功能，我们在我们的工作目录下创建是三个文件，一个文件夹，如图</p> 
<p><img src="https://images2.imgbox.com/75/a2/R0f5tyJ8_o.png" alt="在这里插入图片描述"></p> 
<p>其中 <code>hello_2.c</code> 中内容如下</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;say.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>say.c</code> 中内容如下</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>say.h</code> 中内容如下</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">SAY_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SAY_H</span></span>

<span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>​ 如果直接编译，会发现会报错</p> 
<p><img src="https://images2.imgbox.com/ae/30/zO6PatFd_o.png" alt="在这里插入图片描述"></p> 
<p>​ 这是因为没有找到头文件，所以我们需要用 <code>-I</code> 参数来选择我们自己的头文件</p> 
<p><img src="https://images2.imgbox.com/ae/ca/DPiXj6TH_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="13__128"></a>1.3 编译</h4> 
<p>编译就是将高级语言生成汇编代码的过程，有如下命令</p> 
<pre><code class="prism language-bash">gcc -S c_name.c
</code></pre> 
<p><img src="https://images2.imgbox.com/a0/e7/6nMtPrls_o.png" alt="在这里插入图片描述"></p> 
<p>汇编代码长这样：</p> 
<p><img src="https://images2.imgbox.com/ea/c5/BJMbQUtG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="14__144"></a>1.4 汇编</h4> 
<p>进行汇编可以生成<strong>ELF格式</strong>目标文件，命令为</p> 
<pre><code class="prism language-bash">gcc -c c_name.c
</code></pre> 
<p>这条命令后会生成 <code>c_name.o</code> ，此时已经是<strong>二进制文件</strong>了，所以不能用 vim 查看，而改成用 <code>od</code> 命令进行查看，如图</p> 
<p><img src="https://images2.imgbox.com/a4/68/PnDMGM2z_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="15__157"></a>1.5 链接</h4> 
<p>链接是将多个目标文件和库链接到一起，生成可执行文件的过程，由下图可以看到，目标文件不具有可执行权限（就是没有 x ）</p> 
<p><img src="https://images2.imgbox.com/c4/f9/H0UII7Na_o.png" alt="在这里插入图片描述"></p> 
<p>这里我们还是用 <code>hello_2</code> 来举例，因为它是一个多文件项目，我们编译出目标文件</p> 
<p><img src="https://images2.imgbox.com/44/44/MC6t8bBw_o.png" alt="在这里插入图片描述"></p> 
<p>然后进行链接</p> 
<p><img src="https://images2.imgbox.com/24/cc/0SRodW8p_o.png" alt="在这里插入图片描述"></p> 
<p>​ 链接的时候会用到库文件，系统默认的库文件是在 <code>/lib</code> ，库文件分为<strong>静态库</strong>和<strong>动态库</strong>，静态库和动态库的区别体现在程序的链接阶段：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。后缀与库文件对应关系</p> 
<table><thead><tr><th>类型</th><th>Linux</th><th>Windows</th></tr></thead><tbody><tr><td>静态库</td><td><code>.a</code></td><td><code>.lib</code></td></tr><tr><td>动态库</td><td><code>.so</code></td><td><code>.dll</code></td></tr></tbody></table> 
<p>​ 库文件目录大概长这样</p> 
<p><img src="https://images2.imgbox.com/90/f2/1F3Q0S6z_o.png" alt="在这里插入图片描述"></p> 
<p>库文件同样是二进制文件，大概长这样</p> 
<p><img src="https://images2.imgbox.com/03/fd/98tCkDJE_o.png" alt="在这里插入图片描述"></p> 
<p>我们同样可以指定查找库的目录和特定的库，但是因为我不会写库文件，所以就没有示例了</p> 
<pre><code class="prism language-bash">gcc sin.c -lm -L/lib 		<span class="token comment"># 调用 libm.so 或者 libm.a，库的索引目录是/lib</span>
</code></pre> 
<p>​ 其中 <code>-L</code> 说明了库文件的索引目录，<code>-l</code> 说明了调用的库。</p> 
<p>​ 说道最后，介绍一下标准操作格式：</p> 
<pre><code class="prism language-bash">gcc -o ELF_name object1.o object2.o
</code></pre> 
<h4><a id="16__204"></a>1.6 反汇编</h4> 
<p>​ <strong>objdump</strong>是用查看目标文件或者可执行的目标文件的构成的 gcc 工具。有如下参数</p> 
<pre><code class="prism language-bash">--archive-headers 
-a 
显示档案库的成员信息,类似ls -l将lib*.a的信息列出。 

-b bfdname 
--target<span class="token operator">=</span>bfdname 
指定目标码格式。这不是必须的，objdump能自动识别许多格式，比如： 

objdump -b oasys -m vax -h fu.o 
显示fu.o的头部摘要信息，明确指出该文件是Vax系统下用Oasys编译器生成的目标文件。objdump -i将给出这里可以指定的目标码格式列表。 

-C 
--demangle 
将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得C++函数名以可理解的方式显示出来。 

--debugging 
-g 
显示调试信息。企图解析保存在文件中的调试信息并以C语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持。 

-e 
--debugging-tags 
类似-g选项，但是生成的信息是和ctags工具相兼容的格式。 

--disassemble 
-d 
从objfile中反汇编那些特定指令机器码的section。

-D 
--disassemble-all 
与 -d 类似，但反汇编所有section.

-EB 
-EL 
--endian<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>big<span class="token operator">|</span>little<span class="token punctuation">}</span> 
指定目标文件的小端。这个项将影响反汇编出来的指令。在反汇编的文件没描述小端信息的时候用。例如S-records. 


-f 
--file-headers 
显示objfile中每个文件的整体头部摘要信息。

-h 
--section-headers 
--headers 
显示目标文件各个section的头部摘要信息。  

-H 
--help 
简短的帮助信息。 

-i 
--info 
显示对于 -b 或者 -m 选项可用的架构和目标格式列表。 

-j name
--section<span class="token operator">=</span>name 
仅仅显示指定名称为name的section的信息 

-l
--line-numbers 
用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。 

-m machine 
--architecture<span class="token operator">=</span>machine 
指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候<span class="token punctuation">(</span>比如S-records<span class="token punctuation">)</span>，这个选项很有用。可以用-i选项列出这里能够指定的架构. 

--reloc 
-r 
显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。 

--dynamic-reloc 
-R 
显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库。 

-s 
--full-contents 
显示指定section的完整内容。默认所有的非空section都会被显示。

-S 
--source 
尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。 

--show-raw-insn 
反汇编的时候，显示每条汇编指令对应的机器码，如不指定--prefix-addresses，这将是缺省选项。 

--no-show-raw-insn 
反汇编时，不显示汇编指令的机器码，如不指定--prefix-addresses，这将是缺省选项。 

--start-address<span class="token operator">=</span>address 
从指定地址开始显示数据，该选项影响-d、-r和-s选项的输出。 

--stop-address<span class="token operator">=</span>address 
显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出。 

-t 
--syms 
显示文件的符号表入口。类似于nm -s提供的信息 


-T 
--dynamic-syms 
显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D<span class="token operator">|</span>--dynamic 显示的信息。 

-V 
--version 
版本信息 

--all-headers 
-x 
显示所可用的头信息，包括符号表、重定位入口。-x 等价于-a -f -h -r -t 同时指定。 

-z 
--disassemble-zeroes 
一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编。

@file 可以将选项集中到一个文件中，然后使用这个@file选项载入。
</code></pre> 
<hr> 
<h3><a id="make_333"></a>二、make</h3> 
<h4><a id="21__335"></a>2.1 基本原理</h4> 
<p>​ 代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做<strong>构建</strong>。<code>Make</code> 就是一个帮助我们进行构建的<strong>程序</strong>。这个程序需要以一个叫做 <code>Makefile</code> 的文件作为输入。</p> 
<p>​ 关于具体的工作流程，我觉得应该是 <code>Makefile</code> 起到一个类似与脚本（与 bash 的语法很像）的作用，而 <code>Make</code> 作为一个脚本解释器，可以去执行 <code>Makefile</code> 中的命令。</p> 
<p>​ 那么为什么不直接写脚本呢，这是因为 make 的优势在于，他并不是每次都执行所有的命令（对于只修改了一个源文件的项目，将整个项目都编译一遍，过于大费周章）。而是只会编译相对于前面项目有改变的文件。</p> 
<h4><a id="22__343"></a>2.2 基本格式</h4> 
<pre><code class="prism language-makefile">&lt;target1&gt; : &lt;prerequisites1&gt; 
[tab]  &lt;commands1&gt;

&lt;target2&gt; : &lt;prerequisites2&gt; 
[tab]  &lt;commands2&gt;
</code></pre> 
<h4><a id="23__353"></a>2.3 目标</h4> 
<p>​ 其实 <code>Makefile</code> 更像是一种脚本的集合，每个目标其实可以看做是一个脚本，当我们使用命令</p> 
<pre><code class="prism language-bash"><span class="token function">make</span> someTarget
</code></pre> 
<p>的时候，其实就类似于调用了 target 对应的脚本。</p> 
<p>​ 此外，如果直接输入命令</p> 
<pre><code class="prism language-bash"><span class="token function">make</span>
</code></pre> 
<p>那么就执行第一个目标。</p> 
<h4><a id="24__371"></a>2.4 依赖</h4> 
<p>​ <strong>依赖</strong>，即 prerequisites。我们在 2.1 提到的<strong>编译变动</strong>的功能，是通过<strong>依赖</strong>来实现的，make 某个目标前，make 会检验该目标对应依赖的时间戳，如果发现距离上一次编译有改动，那么就重新编译。所以依赖不是真的依赖，而是一个检验记号，比如说这样的写法</p> 
<p><img src="https://images2.imgbox.com/f5/c5/Lpelax2n_o.png" alt="在这里插入图片描述"></p> 
<p>​ 尽管我理论上需要依赖 <code>hello_2.c, say.c, ./include/</code> 文件，但是我不写，它照样能跑。</p> 
<h4><a id="25__380"></a>2.5 命令</h4> 
<p>​ 正是因为 <code>make</code> 的大部分语法与脚本相像，所以<strong>注释，通配符，变量赋值</strong>就不写了，我在其他博客里写了。在这里主要讲一下<strong>自动变量（Automatic Variables）</strong></p> 
<pre><code class="prism language-makefile">$@ 		# 即当前的 target

$&lt;		# 指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1
$(&lt;D) 	# 指向 $&lt; 的目录名
$(&lt;F) 	# 指向 $&lt; 的文件名

$^ 		# 指代所有前置条件，之间以空格分隔
$?		# 指代比目标更新的所有前置条件，之间以空格分隔。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df34053a81afeca55248dc5ca928d1aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux下编译LibreOffice在线编辑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4dac9391f465c055b5fb1ea4ff84bb27/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">八大排序算法之归并排序(递归实现&#43;非递归实现)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>