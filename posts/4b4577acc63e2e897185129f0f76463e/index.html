<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在MySQL中，如何设计一张分表以提高查询性能？ - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/4b4577acc63e2e897185129f0f76463e/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="在MySQL中，如何设计一张分表以提高查询性能？">
  <meta property="og:description" content="在MySQL中设计分表的主要目的是为了应对大数据量下的查询性能瓶颈，主要分为两大类方法：垂直分表和水平分表。
### 垂直分表（Vertical Partitioning） 原理 垂直分表是指将原来一张表中的列按照业务逻辑分成多个表，通常是将不常用的列或者大字段（如文本、Blob等占用空间较大的列）转移到另外的表中，使得每个表包含较少的列，从而减少单表数据量，提升查询效率。例如，用户表可以分为用户基本信息表（如username, email等）和用户附加信息表（如个人简介、头像图片等大字段）。
实施步骤 1. 根据字段的访问频率和大小，将原表划分为几个具有较少列的小表。
2. 对于那些经常一起查询的字段，保持在同一张表内；不常一起使用的字段则分到不同的表中。
3. 在应用层根据需要关联查询这些分开的表。
### 水平分表（Horizontal Partitioning） 原理 水平分表则是将数据行按照某种规则切分到不同的表中，每个表的结构完全一致，只是存储的数据范围不同。通常有以下几种方式：
- 范围分区基于某个连续的数值字段（如时间戳或ID）进行区间划分。 - 哈希分区使用哈希函数将数据均匀分散到多个表中。 - 列表分区根据枚举值将数据分配到不同的表中。 - 键值分区类似于列表分区，但支持多个键值对的组合分区。 实施步骤 1. 根据分表策略，创建一系列具有相同结构的表，比如按时间范围分表，可以创建year_2020, year_2021这样的表。
2. 在插入数据时，通过某种规则（如年份、用户ID取模等）决定数据应该存入哪张表。
3. 查询时，根据查询条件动态路由到对应的表进行查询，或者在应用程序中明确指定查询哪些分表。
查询优化 - 使用分表后，查询性能的提高依赖于正确的数据分布和索引策略，确保热点数据集中且易于访问。
- 需要建立额外的机制来管理分表间的查询，如数据库中间件（如Mycat）、分区表功能（MySQL支持的分区表也是一种水平分区的形式，但管理起来相对自动）。
总的来说，分表设计需要结合具体的应用场景、数据增长趋势以及查询模式来综合考虑，同时也需要注意事务处理、数据一致性等问题。在MySQL中，除了物理层面的分表之外，还可以利用分区表、索引优化、缓存技术等手段共同提升查询性能。当然，让我们换一个更生动的场景来解释MySQL查询优化器的工作原理：
想象一下，光头强和熊二在图书馆管理一本巨大的食谱大全（数据库表）。熊大想要知道所有制作时间少于一小时且评分超过四星的甜品食谱。
查询优化器就好比是光头强的智慧大脑，它有几种方式来查找这些食谱：
- 方法A（使用索引）光头强记得馆内有一本按制作时间和评分排序的目录（索引），他可以直接翻阅这本目录，从高评分开始快速定位到符合要求的食谱。 - 方法B（全表扫描）如果不借助目录，光头强只能一页一页地查看整本食谱大全，逐条检查每一道菜谱是否满足条件。 查询优化器会基于已知的信息（比如索引的存在与否、索引的更新频率、食谱总数、预计符合条件的食谱数量等）来估算两种方法的“代价”。在这个例子中，“代价”可以类比成光头强查找食谱所需的时间和精力。
如果查询优化器判断通过索引查找的代价较低（比如索引很高效，且符合条件的食谱相对较少），它会选择方法A；反之，若认为全表扫描更快（比如索引很久未更新，实际数据分布与索引信息不匹配），则可能选择方法B。
最终，查询优化器会为熊大的请求选择一个执行效率最高的方案来获取答案。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-24T00:01:02+08:00">
    <meta property="article:modified_time" content="2024-03-24T00:01:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在MySQL中，如何设计一张分表以提高查询性能？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在MySQL中设计分表的主要目的是为了应对大数据量下的查询性能瓶颈，主要分为两大类方法：垂直分表和水平分表。</p> 
<p>### </p> 
<h3>垂直分表（Vertical Partitioning）</h3> 
<h3> </h3> 
<p></p> 
<h3>原理</h3> 
<p>垂直分表是指将原来一张表中的列按照业务逻辑分成多个表，通常是将不常用的列或者大字段（如文本、Blob等占用空间较大的列）转移到另外的表中，使得每个表包含较少的列，从而减少单表数据量，提升查询效率。例如，用户表可以分为用户基本信息表（如username, email等）和用户附加信息表（如个人简介、头像图片等大字段）。</p> 
<p></p> 
<h3>实施步骤</h3> 
<p>1. 根据字段的访问频率和大小，将原表划分为几个具有较少列的小表。</p> 
<p>2. 对于那些经常一起查询的字段，保持在同一张表内；不常一起使用的字段则分到不同的表中。</p> 
<p>3. 在应用层根据需要关联查询这些分开的表。</p> 
<p>### </p> 
<h3>水平分表（Horizontal Partitioning）</h3> 
<h3> </h3> 
<p></p> 
<h3>原理</h3> 
<p>水平分表则是将数据行按照某种规则切分到不同的表中，每个表的结构完全一致，只是存储的数据范围不同。通常有以下几种方式：</p> 
<p> - </p> 
<h3>范围分区</h3>基于某个连续的数值字段（如时间戳或ID）进行区间划分。 
<p> - </p> 
<h3>哈希分区</h3>使用哈希函数将数据均匀分散到多个表中。 
<p> - </p> 
<h3>列表分区</h3>根据枚举值将数据分配到不同的表中。 
<p> - </p> 
<h3>键值分区</h3>类似于列表分区，但支持多个键值对的组合分区。 
<p></p> 
<h3>实施步骤</h3> 
<p>1. 根据分表策略，创建一系列具有相同结构的表，比如按时间范围分表，可以创建year_2020, year_2021这样的表。</p> 
<p>2. 在插入数据时，通过某种规则（如年份、用户ID取模等）决定数据应该存入哪张表。</p> 
<p>3. 查询时，根据查询条件动态路由到对应的表进行查询，或者在应用程序中明确指定查询哪些分表。</p> 
<p></p> 
<h3>查询优化</h3> 
<p>- 使用分表后，查询性能的提高依赖于正确的数据分布和索引策略，确保热点数据集中且易于访问。</p> 
<p>- 需要建立额外的机制来管理分表间的查询，如数据库中间件（如Mycat）、分区表功能（MySQL支持的分区表也是一种水平分区的形式，但管理起来相对自动）。</p> 
<p>总的来说，分表设计需要结合具体的应用场景、数据增长趋势以及查询模式来综合考虑，同时也需要注意事务处理、数据一致性等问题。在MySQL中，除了物理层面的分表之外，还可以利用分区表、索引优化、缓存技术等手段共同提升查询性能。当然，让我们换一个更生动的场景来解释MySQL查询优化器的工作原理：</p> 
<p>想象一下，光头强和熊二在图书馆管理一本巨大的食谱大全（数据库表）。熊大想要知道所有制作时间少于一小时且评分超过四星的甜品食谱。</p> 
<p>查询优化器就好比是光头强的智慧大脑，它有几种方式来查找这些食谱：</p> 
<p>- </p> 
<h3>方法A（使用索引）</h3>光头强记得馆内有一本按制作时间和评分排序的目录（索引），他可以直接翻阅这本目录，从高评分开始快速定位到符合要求的食谱。 
<p>- </p> 
<h3>方法B（全表扫描）</h3>如果不借助目录，光头强只能一页一页地查看整本食谱大全，逐条检查每一道菜谱是否满足条件。 
<p>查询优化器会基于已知的信息（比如索引的存在与否、索引的更新频率、食谱总数、预计符合条件的食谱数量等）来估算两种方法的“代价”。在这个例子中，“代价”可以类比成光头强查找食谱所需的时间和精力。</p> 
<p>如果查询优化器判断通过索引查找的代价较低（比如索引很高效，且符合条件的食谱相对较少），它会选择方法A；反之，若认为全表扫描更快（比如索引很久未更新，实际数据分布与索引信息不匹配），则可能选择方法B。</p> 
<p>最终，查询优化器会为熊大的请求选择一个执行效率最高的方案来获取答案。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fc58ecb26b2458367308fb83965e6f98/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Collection与数据结构 数据结构预备知识(二):包装类与泛型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4eb0efdb5e9c86288cb6ed211a2a1d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">H5实现Web ECharts教程：轻松创建动态数据图表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>