<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;stack,queue底层实现以及deque的详细介绍 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/155b22c88a5ca4d2771b137f94b394ce/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="C&#43;&#43;stack,queue底层实现以及deque的详细介绍">
  <meta property="og:description" content="文章目录 前言一、容器适配器二、stack的实现三、queue的实现四、deque的介绍总结 前言 在本篇文章中，我们将会学到stack,queue的底层实现，我们通过本篇的学习，我们会发现，栈和队列的实现和vector,list等容器的实现会有很大差异。我们实现栈和队列是通过一种叫容器适配器的东西实现的。我们还将会学到deque,这是一种将list和vector结合的一种容器。我们来详细看一看吧！！！🌟🌟🌟
一、容器适配器 在介绍容器适配器之前，我们来想一下stack应该如何实现呢？？
我们很清楚，栈是一种后进先出的结构，只能在一端进行数据的插入删除。
在c语言我们学习过，stack既可以用顺序表来实现，又可以用链表实现。
那么我们在C&#43;&#43;中依然可以采用相同的方式来实现链式栈和顺序栈。
但是，我们发现在实现stack的接口中，很多都与顺序表的实现结构相似。
那麽我们把vector的一些接口进行封装，修改修改不就是我们stack的结构吗？？
在C&#43;&#43;官方库中，确实就是采用这种方法进行实现的。我们把这个叫做容器适配器
stack是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出
队列作为容器适配器实现，容器适配器即将特定容器类封装作为其底层容器类，queue提供一组特定的成员函数来访问其元素。元素从队尾入队列，从队头出队列。
容器适配器是C&#43;&#43;标准库中的一种数据结构，它可以将不同类型的容器（如vector、list、deque等）转换为另一种类型的容器。本质上，容器适配器是一种机制，能使某种容器的行为看起来像另外一种容器。这种转换提供了一种简单的方式来重新组织和访问数据，同时隐藏了底层容器的实现细节。容器适配器通常用于解决特定的问题或满足特定的需求。
二、stack的实现 我们现在已经知道实现stack采用容器适配器来实现，我们想实现一个链式栈，就采用list进行适配，我们想实现一个顺序栈，就采用vector进行适配。
vector适配缺点：容易造成空间浪费
list适配缺点：内存命中率较低
有没有一种两者兼有的结构呢？？
我们来看一下stack库里的是如何实现的！！！
我们发现在进行适配时，默认采用了deque这个容器。
这其实是一个双端队列。尾插尾删效率很高，对于空间的浪费也没有那麽大，内存命中率也可以。我们先用这个实现一下，在后面我们再来详细看一下
template&amp;lt;class T,class con=deque&amp;lt;T&amp;gt;&amp;gt; class stack { public: void push(const T&amp;amp;val) { _con.push_back(val); } void pop() { _con.pop_back(); } size_t size() { return _con.size(); } T&amp;amp; top() { return _con.back(); } bool empty() { return _con.empty(); } private: con _con; }; 三、queue的实现 对于queue的实现我们想一下是否可以用vector和list实现
queue是先进先出，尾插头删，对于vector我们在库里面并没有头删的操作。
我们也可以用自己模拟实现的vector实现一个头删，但是我们知道对于头删，效率太低了
⭐️⭐️注意一下：适配器并不是一定要适配库里的，也可以适配自己模拟实现的，只要可以实现对应的需求就可以
对于list我们就可以了，但是list也有对应的缺陷，我们看一下库里的实现">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-23T17:14:26+08:00">
    <meta property="article:modified_time" content="2024-03-23T17:14:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;stack,queue底层实现以及deque的详细介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_6" rel="nofollow">前言</a></li><li><a href="#_8" rel="nofollow">一、容器适配器</a></li><li><a href="#stack_31" rel="nofollow">二、stack的实现</a></li><li><a href="#queue_77" rel="nofollow">三、queue的实现</a></li><li><a href="#deque_126" rel="nofollow">四、deque的介绍</a></li><li><a href="#_193" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_6"></a>前言</h2> 
<p>在本篇文章中，我们将会学到stack,queue的底层实现，我们通过本篇的学习，我们会发现，栈和队列的实现和vector,list等容器的实现会有很大差异。我们实现栈和队列是通过一种叫容器适配器的东西实现的。我们还将会学到deque,这是一种将list和vector结合的一种容器。我们来详细看一看吧！！！🌟🌟🌟</p> 
<h2><a id="_8"></a>一、容器适配器</h2> 
<p>在介绍容器适配器之前，我们来想一下stack应该如何实现呢？？</p> 
<blockquote> 
 <p>我们很清楚，栈是一种后进先出的结构，只能在一端进行数据的插入删除。<br> 在c语言我们学习过，stack既可以用顺序表来实现，又可以用链表实现。<br> 那么我们在C++中依然可以采用相同的方式来实现链式栈和顺序栈。</p> 
</blockquote> 
<p>但是，我们发现在实现stack的接口中，很多都与顺序表的实现结构相似。<br> 那麽我们把vector的一些接口进行封装，修改修改不就是我们stack的结构吗？？</p> 
<blockquote> 
 <p>在C++官方库中，确实就是采用这种方法进行实现的。我们把这个叫做容器适配器</p> 
</blockquote> 
<blockquote> 
 <p>stack是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出</p> 
</blockquote> 
<blockquote> 
 <p>队列作为容器适配器实现，容器适配器即将特定容器类封装作为其底层容器类，queue提供一组特定的成员函数来访问其元素。元素从队尾入队列，从队头出队列。</p> 
</blockquote> 
<p>容器适配器是C++标准库中的一种数据结构，它可以将不同类型的容器（如vector、list、deque等）转换为另一种类型的容器。本质上，容器适配器是一种机制，能使某种容器的行为看起来像另外一种容器。这种转换提供了一种简单的方式来重新组织和访问数据，同时隐藏了底层容器的实现细节。容器适配器通常用于解决特定的问题或满足特定的需求。</p> 
<h2><a id="stack_31"></a>二、stack的实现</h2> 
<p>我们现在已经知道实现stack采用容器适配器来实现，我们想实现一个链式栈，就采用list进行适配，我们想实现一个顺序栈，就采用vector进行适配。</p> 
<blockquote> 
 <p>vector适配缺点：容易造成空间浪费<br> list适配缺点：内存命中率较低</p> 
</blockquote> 
<p>有没有一种两者兼有的结构呢？？<br> 我们来看一下stack库里的是如何实现的！！！<br> <img src="https://images2.imgbox.com/a9/61/LvsvRgDx_o.png" alt="在这里插入图片描述"><br> 我们发现在进行适配时，默认采用了deque这个容器。</p> 
<p>这其实是一个双端队列。尾插尾删效率很高，对于空间的浪费也没有那麽大，内存命中率也可以。我们先用这个实现一下，在后面我们再来详细看一下</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">con</span><span class="token operator">=</span>deque<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">stack</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span>val<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_con<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_con<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	T<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	con _con<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> 
<h2><a id="queue_77"></a>三、queue的实现</h2> 
<p>对于queue的实现我们想一下是否可以用vector和list实现</p> 
<blockquote> 
 <p>queue是先进先出，尾插头删，对于vector我们在库里面并没有头删的操作。<br> 我们也可以用自己模拟实现的vector实现一个头删，但是我们知道对于头删，效率太低了<br> <img src="https://images2.imgbox.com/6c/fd/741GP142_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>⭐️⭐️注意一下：适配器并不是一定要适配库里的，也可以适配自己模拟实现的，只要可以实现对应的需求就可以<br> 对于list我们就可以了，但是list也有对应的缺陷，我们看一下库里的实现</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/42/ff/niQBI0a9_o.png" alt="在这里插入图片描述"><br> 我们发现依然默认采用deque的方式，我们同样的先用这个实现以下</p> 
<pre><code class="prism language-cpp">	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">con</span> <span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">queue</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_con<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_con<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		T<span class="token operator">&amp;</span> <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		T<span class="token operator">&amp;</span> <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		con _con<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>


</code></pre> 
<h2><a id="deque_126"></a>四、deque的介绍</h2> 
<p>stack和queue都是默认采用deque实现的，我们接下来看一下这个容器为什么比vector和list更适合适配。</p> 
<blockquote> 
 <p>deque是一个双端队列：两端开口，都可以进行插入删除，时间复杂度为O（1）。</p> 
</blockquote> 
<p>我们来看一下它的底层</p> 
<p><img src="https://images2.imgbox.com/8a/83/WVKWlApb_o.png" alt="在这里插入图片描述"></p> 
<p>deque整个的物理空间并不是连续的，而是由一段段连续的物理空间结合而成，类似于一个二维数组。<br> 我么给这一段段空间编号，方便接下来叙述。</p> 
<blockquote> 
 <p>我们来看一下头部插入和尾部插入</p> 
</blockquote> 
<p>🔱🔱头插<br> ✨ ✨ ✨ ✨ 如果一号空间不满，我们就直接在前面进行插入，假设我们插入1<br> <img src="https://images2.imgbox.com/3d/ae/LItIrOBP_o.png" alt="在这里插入图片描述"></p> 
<p>✨ ✨ ✨ ✨ 如果一号空间已经满了，我们需要再开一块空间，把这块空间起始位置放在中控位置，再在新开的这块空间进行插入。<br> 如果中控的位置也满了，就扩大中控位置，拷贝指针。<br> <img src="https://images2.imgbox.com/1f/3b/aqnqdgv0_o.png" alt="在这里插入图片描述"></p> 
<p>🔱🔱尾插<br> ✨ ✨ ✨ ✨ 尾插也是同样的道理，尾部元素不满，继续插入。满了就再开一块空间继续插入</p> 
<blockquote> 
 <p>双端队列底层是一段假想的连续空间，实际是分段连续的，为了维护整体连续以及随机访问的假象，落在了deque迭代器上，迭代器设计就很复杂了</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/9c/d0/yPHkgooi_o.png" alt="在这里插入图片描述"><br> 其中对于每段空间来说：<br> 💗💗cur指向buff的某个位置<br> 💗💗first指向buff的开始位置<br> 💗💗last指向buff的结束位置<br> 💗💗node指向存储buff中控位置</p> 
<p>对于中控：<br> 💗💗start指向第一个buff，cur指向这个buff第一个位置元素<br> 💗💗finish指向最后一个buff，cur指向这个buff最后一个位置元素的下一个位置</p> 
<blockquote> 
 <p>我们可以看到deque有很多优势，头部插入删除，不需要挪动数据，弥补了vector的缺陷。同时底层空间是连续的，弥补了list的缺点，缓存利用率高。</p> 
</blockquote> 
<blockquote> 
 <p>那我们是不是可以考虑废除vector和list,z之后的学习都采用deque的结构呢？？<br> 显然是不行的，我们在数据结构已经学过了，就说明有存在的道理</p> 
</blockquote> 
<blockquote> 
 <p>deque有没有什么缺点呢？？</p> 
</blockquote> 
<p>🎁🎁下标的随机访问<br> 既然deque兼备vector和list的特性，肯定具有下标的随机访问。<br> 我们如果想要在deque中进行下标的随机访问，怎末做呢？？<br> 例如：deque中一共有100个元素，假设每个空间大小固定，都是10。我们想要访问第55个元素的位置。我们可以先用55/10，得到结果5，我们就知道我们要找的在第5块空间中，再用55%10，得到结果5，我们就可以找到这个位置进行访问了。<br> 🎁🎁任意位置的插入删除<br> 我们来看一这种场景，deque中有100个元素，我们想要在地55个元素的位置进行插入操作，我们如果每个空间大小固定，移动起来数据就相当麻烦。<br> 那如果我们在这个空间的基础上进行扩大，不固定空间大小不就行了，这样确实可以实现，但是我们的下标随机访问就会收到影响。</p> 
<p>我们只能空间时间选择一个，这就像鱼和熊掌不可兼得。<br> 因此在实践中，deque的应用场景并不多，目前我们能看到的一个应用就是，STL用它作为stack和queue的底层数据结构。</p> 
<blockquote> 
 <p>既然deque有这麽大的缺点，我们为什么还要让它当作stack和queue的默认容器呢？</p> 
</blockquote> 
<p>stack是一种后进先出的特殊线性数据结构，我们只要保证有尾插和尾删的相关操作就可以，比如vector，list都可以实现。queue是一种先进先出的特殊线性数据结构，只要保证有头删，尾插的相关操作就可以，比如list.</p> 
<p>但是我们选择deque作为默认的容器：因为stack和queue完美的避开了这两大缺陷<br> 🌝🌝stack和queue不需要随机访问，只能访问固定位置的数据。</p> 
<p>🌝🌝stack在扩容时，deque比vector效率高，不需要挪动大量数据。queue元素增长时，deque效率高，内存使用率高。</p> 
<h2><a id="_193"></a>总结</h2> 
<p>以上就是今天要讲的内容，本文仅仅详细介绍了C++stack和queue的模拟实现,以及deque的相关实现。希望对大家的学习有所帮助，仅供参考 如有错误请大佬指点我会尽快去改正 欢迎大家来评论~~ 😘 😘 😘</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cdd30d64ed5511ef72864068be958bae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AJAX介绍&amp;使用&amp;案例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a83a3a99bbe73dd8eafed4d005ec547/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络分类简述与数据链路层协议（PPP）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>