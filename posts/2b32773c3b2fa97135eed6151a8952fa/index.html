<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;中using的用法 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/2b32773c3b2fa97135eed6151a8952fa/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="c&#43;&#43;中using的用法">
  <meta property="og:description" content="1、概述 我们用到的库函数基本上都属于命名空间std的，在程序使用的过程中要显示的将这一点标示出来，如std::cout。这个方法比较烦琐，而我们都知道使用using声明则更方便更安全。
这个我们程序员肯定都知道了，今天突发奇想就想对using整理一下。
2、命令空间的using声明 我们在书写模块功能时，为了防止命名冲突会对模块取命名空间，这样子在使用时就需要指定是哪个命名空间，使用using声明，则后面使用就无须前缀了。例如：
using std::cin;	//using声明，当我们使用cin时，从命名空间std中获取它 int main() { int i; cin &amp;gt;&amp;gt; i;	//正确：cin和std::cin含义相同 cout &amp;lt;&amp;lt; i;	//错误：没有对应的using声明，必须使用完整的名字 return 0; } 需要注意的是每个名字需要独立的using声明。例如：
using std::cin;	//必须每一个都有独立的using声明 using std::cout; using std::endl;	//写在同一行也需要独立声明 位于头文件的代码一般来说不应该使用using声明。因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明，有可能产生名字冲突。
3、在子类中引用基类成员 在子类中对基类成员进行声明，可恢复基类的防控级别。有三点规则：
在基类中的private成员，不能在派生类中任何地方用using声明。在基类中的protected成员，可以在派生类中任何地方用using声明。当在public下声明时，在类定义体外部，可以用派生类对象访问该成员，但不能用基类对象访问该成员；当在protected下声明时，该成员可以被继续派生下去；当在private下声明时，对派生类定义体外部来说，该成员是派生类的私有成员。在基类中的public成员，可以在派生类中任何地方用using声明。具体声明后的效果同基类中的protected成员。 例如：
class Base { protected: void test1() { cout &amp;lt;&amp;lt; &#34;test1&#34; &amp;lt;&amp;lt; endl; } void test1(int a) {cout &amp;lt;&amp;lt; &#34;test2&#34; &amp;lt;&amp;lt; endl; } int value = 55; }; class Derived : Base //使用默认继承 { public: //using Base::test1;	//using只是声明，不参与形参的指定 //using Base::value; void test2() { cout &amp;lt;&amp;lt; &#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2018-11-29T23:05:47+08:00">
    <meta property="article:modified_time" content="2018-11-29T23:05:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;中using的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1、概述</h2> 
<p>我们用到的库函数基本上都属于命名空间std的，在程序使用的过程中要显示的将这一点标示出来，如std::cout。这个方法比较烦琐，而我们都知道使用using声明则更方便更安全。</p> 
<p>这个我们程序员肯定都知道了，今天突发奇想就想对using整理一下。</p> 
<h2><a id="2using_6"></a>2、命令空间的using声明</h2> 
<p>我们在书写模块功能时，为了<strong>防止命名冲突会对模块取命名空间</strong>，这样子在使用时就需要指定是哪个命名空间，使用using声明，则后面使用就无须前缀了。例如：</p> 
<pre><code>using std::cin;	//using声明，当我们使用cin时，从命名空间std中获取它
int main()
{
	int i;
	cin &gt;&gt; i;	//正确：cin和std::cin含义相同
	cout &lt;&lt; i;	//错误：没有对应的using声明，必须使用完整的名字
	return 0;
}
</code></pre> 
<p><strong>需要注意的是每个名字需要独立的using声明。例如：</strong></p> 
<pre><code>using std::cin;	//必须每一个都有独立的using声明
using std::cout;  using std::endl;	//写在同一行也需要独立声明
</code></pre> 
<p>位于头文件的代码一般来说不应该使用using声明。因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明，有可能产生名字冲突。</p> 
<h2><a id="3_26"></a>3、在子类中引用基类成员</h2> 
<p>在子类中对基类成员进行声明，可<strong>恢复</strong>基类的防控级别。有三点规则：</p> 
<ol><li>在基类中的private成员，不能在派生类中任何地方用using声明。</li><li>在基类中的protected成员，可以在派生类中任何地方用using声明。当在public下声明时，在类定义体外部，可以用派生类对象访问该成员，但不能用基类对象访问该成员；当在protected下声明时，该成员可以被继续派生下去；当在private下声明时，对派生类定义体外部来说，该成员是派生类的私有成员。</li><li>在基类中的public成员，可以在派生类中任何地方用using声明。具体声明后的效果同基类中的protected成员。</li></ol> 
<p>例如：</p> 
<pre><code>class Base 
{
protected:
    void test1() { cout &lt;&lt; "test1" &lt;&lt; endl; }
    void test1(int a) {cout &lt;&lt; "test2" &lt;&lt; endl; }

    int value = 55;
};
 
class Derived : Base 	//使用默认继承
{
public:
    //using Base::test1;	//using只是声明，不参与形参的指定
    //using Base::value;
    void test2() { cout &lt;&lt; "value is " &lt;&lt; value &lt;&lt; endl; }
};
</code></pre> 
<p>我们知道class的默认继承是private，这样子类中是无法访问基类成员的，即test2会编译出错。但是如果我们把上面注释的声明给放开，则没有问题。</p> 
<p><strong>注意：using::test1只是声明，不需要形参指定，所以test1的两个重载版本在子类中都可使用</strong>。<br> 但是在往下派生，则只能使用无参函数，具体什么原因就不知道了…</p> 
<h2><a id="4using_60"></a>4、使用using起别名</h2> 
<p>相当于传统的typedef起别名。</p> 
<pre><code>typedef 	std::vector&lt;int&gt; intvec;
using 	intvec	= std::vector&lt;int&gt;;	//这两个写法是等价的
</code></pre> 
<p>这个还不是很明显的优势，在来看一个列子：</p> 
<pre><code>typedef void (*FP) (int, const std::string&amp;);
</code></pre> 
<p>若不是特别熟悉函数指针与typedef，第一眼还是很难指出FP其实是一个别名，代表着的是一个函数指针，而指向的这个函数返回类型是void，接受参数是int, const std::string&amp;。</p> 
<pre><code>using FP = void (*) (int, const std::string&amp;);
</code></pre> 
<p>这样就很明显了，一看FP就是一个别名。using的写法把别名的名字强制分离到了左边，而把别名指向的放在了右边，比较清晰，可读性比较好。比如：</p> 
<pre><code>typedef std::string (* fooMemFnPtr) (const std::string&amp;);
    
using fooMemFnPtr = std::string (*) (const std::string&amp;);
</code></pre> 
<p><strong>来看一下模板别名</strong>。</p> 
<pre><code>template &lt;typename T&gt;
using Vec = MyVector&lt;T, MyAlloc&lt;T&gt;&gt;;
 
// usage
Vec&lt;int&gt; vec;
</code></pre> 
<p>若使用typedef</p> 
<pre><code>template &lt;typename T&gt;
typedef MyVector&lt;T, MyAlloc&lt;T&gt;&gt; Vec;
 
// usage
Vec&lt;int&gt; vec;
</code></pre> 
<p>当进行编译的时候，编译器会给出error: a typedef cannot be a template的错误信息。</p> 
<p>那么，如果我们想要用typedef做到这一点，需要进行包装一层，如:</p> 
<pre><code>template &lt;typename T&gt;
struct Vec
{
  typedef MyVector&lt;T, MyAlloc&lt;T&gt;&gt; type;
};

// usage
Vec&lt;int&gt;::type vec;
</code></pre> 
<p>正如你所看到的，这样是非常不漂亮的。而更糟糕的是，如果你想要把这样的类型用在模板类或者进行参数传递的时候，你需要使用typename强制指定这样的成员为类型，而不是说这样的::type是一个静态成员亦或者其它情况可以满足这样的语法，如：</p> 
<pre><code>template &lt;typename T&gt;
class Widget
{
  typename Vec&lt;T&gt;::type vec;
};
</code></pre> 
<p>然而，如果是使用using语法的模板别名，你则完全避免了因为::type引起的问题，也就完全不需要typename来指定了。</p> 
<pre><code>template &lt;typename T&gt;
class Widget
{
  Vec&lt;T&gt; vec;
};
</code></pre> 
<p>一切都会非常的自然，所以于此，模板起别名时推荐using，而非typedef。</p> 
<p><strong>感谢大家，我是假装很努力的YoungYangD（小羊）。</strong></p> 
<p>参考资料：<br> https://zhuanlan.zhihu.com/p/21264013<br> https://blog.csdn.net/shift_wwx/article/details/78742459</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b90399af02bd2efa94960a5dc0da7cf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">两段锁(2PL)理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/221532b4472b2df3df9703843e7945fb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于Android ndk的全局变量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>