<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Verilog实现常见电路（二） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/da55bf6c4a27f401b9edc4dbef16542b/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Verilog实现常见电路（二）">
  <meta property="og:description" content="常见电路系列连接
https://blog.csdn.net/weixin_40634481/article/details/122940873?spm=1001.2014.3001.5501https://blog.csdn.net/weixin_40634481/article/details/122940873?spm=1001.2014.3001.5501
目录：
一、边沿检测
二、串并转换
三、分频器
四、异步复位同步释放
五、序列信号产生器
六、序列检测器
四、异步复位同步释放
上来先来三个问题
问题一：为什么要用异步复位同步释放？
答：这个问题要从同步复位和异步复位优缺点来解释，异步复位的缺点是其可能会引起亚稳态，同步复位的缺点是需要消耗较多的资源优点是降低了亚稳态出现的概率，而异步复位同步释放即保留了异步复位的功能，又避免了异步复位释放时所面临的recovery或者removal违例的问题。
问题二：异步复位同步释放是怎么工作的？
答：
我的理解就是单比特数据通过打拍的方式来降低亚稳态发生的概率，当rst_async_n信号有效时第二个触发器的输出为低电平，复位有效，如果rst_async_n信号释放时刚好在clk上升沿，则第一个触发器的输出可能是亚稳态，通过打一拍的方式可以降低亚稳态的概率（关于亚稳态的问题计划到后面会详细总结一篇文章）
问题三：为什么触发器的输入端直接给1&#39;b1而不是复位信号？
答：这样也是为了节省资源，减少了一个反相器。
always@(posedge clk or negedge rst_async_n) if(~rst_n)begin rst_n_d1 &amp;lt;= 1&#39;b0; rst_n_d2 &amp;lt;= 1&#39;b0; end else begin rst_n_d1 &amp;lt;= 1&#39;b1; rst_n_d2 &amp;lt;= rst_n_d1; end assign rst_sync_n=rst_n_d2; 五、序列信号产生器
module sequence_gen( input clk, input rst_n, output reg dout ); localparam [4:0] s0=5&#39;b00001, s1=5&#39;b00010, s2=5&#39;b00100, s3=5&#39;b01000, s4=5&#39;b10000; reg [4:0] state,next_state; always@(posedge clk or negedge rst_n) if(~rst_n) state&amp;lt;=s0; else state&amp;lt;=next_state; always@(*) case(state) s0:next_state=s1; s1:next_state=s2; s2:next_state=s3; s3:next_state=s4; s4:next_state=s0; default:next_state=s0; endcase always@(posedge clk or negedge rst_n) if(~rst_n) dout&amp;lt;=1&#39;b0; else case(next_state) s0:dout=1&#39;b0; s1:dout=1&#39;b0; s2:dout=1&#39;b1; s3:dout=1&#39;b0; s4:dout=1&#39;b1; endcase endmodule 仿真代码">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-02-17T20:17:22+08:00">
    <meta property="article:modified_time" content="2022-02-17T20:17:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Verilog实现常见电路（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>常见电路系列连接</p> 
<p><a class="link-info has-card" href="https://blog.csdn.net/weixin_40634481/article/details/122940873?spm=1001.2014.3001.5501" title="https://blog.csdn.net/weixin_40634481/article/details/122940873?spm=1001.2014.3001.5501"><span class="link-card-box"><span class="link-title">https://blog.csdn.net/weixin_40634481/article/details/122940873?spm=1001.2014.3001.5501</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/5f/0a/mQryRftw_o.png" alt="icon-default.png?t=M1H3">https://blog.csdn.net/weixin_40634481/article/details/122940873?spm=1001.2014.3001.5501</span></span></a></p> 
<p>目录：</p> 
<p>一、边沿检测</p> 
<p>二、串并转换</p> 
<p>三、分频器</p> 
<p>四、异步复位同步释放</p> 
<p>五、序列信号产生器</p> 
<p>六、序列检测器</p> 
<p></p> 
<p>四、异步复位同步释放</p> 
<p>上来先来三个问题</p> 
<p>问题一：为什么要用异步复位同步释放？</p> 
<p>答：这个问题要从同步复位和异步复位优缺点来解释，异步复位的缺点是其可能会引起亚稳态，同步复位的缺点是需要消耗较多的资源优点是降低了亚稳态出现的概率，而异步复位同步释放即保留了异步复位的功能，又避免了异步复位释放时所面临的recovery或者removal违例的问题。</p> 
<p>问题二：异步复位同步释放是怎么工作的？</p> 
<p>答：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/06/d0/A5Wj514S_o.png"></p> 
<p>我的理解就是单比特数据通过打拍的方式来降低亚稳态发生的概率，当rst_async_n信号有效时第二个触发器的输出为低电平，复位有效，如果rst_async_n信号释放时刚好在clk上升沿，则第一个触发器的输出可能是亚稳态，通过打一拍的方式可以降低亚稳态的概率（关于亚稳态的问题计划到后面会详细总结一篇文章）</p> 
<p>问题三：为什么触发器的输入端直接给1'b1而不是复位信号？</p> 
<p>答：这样也是为了节省资源，减少了一个反相器。</p> 
<pre><code>always@(posedge clk or negedge rst_async_n)
    if(~rst_n)begin
        rst_n_d1 &lt;= 1'b0;
        rst_n_d2 &lt;= 1'b0;
    end
    else begin
        rst_n_d1 &lt;= 1'b1;
        rst_n_d2 &lt;= rst_n_d1;
    end
assign rst_sync_n=rst_n_d2;
</code></pre> 
<p>五、序列信号产生器</p> 
<pre><code>module sequence_gen(
    input clk,
    input rst_n,

    output reg dout
);
localparam [4:0] s0=5'b00001,
                 s1=5'b00010,
                 s2=5'b00100,
                 s3=5'b01000,
                 s4=5'b10000;
reg [4:0] state,next_state;

always@(posedge clk or negedge rst_n)
    if(~rst_n)
        state&lt;=s0;
    else
        state&lt;=next_state;

always@(*)
    case(state)
        s0:next_state=s1;
        s1:next_state=s2;
        s2:next_state=s3;
        s3:next_state=s4;
        s4:next_state=s0;
        default:next_state=s0;
    endcase

always@(posedge clk or negedge rst_n)
    if(~rst_n)
        dout&lt;=1'b0;
    else
        case(next_state)
            s0:dout=1'b0;
            s1:dout=1'b0;
            s2:dout=1'b1;
            s3:dout=1'b0;
            s4:dout=1'b1;
        endcase


endmodule
</code></pre> 
<p>仿真代码</p> 
<pre><code>`timescale 1ns/1ns
module tb_sequence();
parameter PERIOD=10;
bit clk;
reg rst_n;
wire dout;

always #(PERIOD/2) clk=~clk;

initial begin
    rst_n=0;
    #PERIOD;
    rst_n=1;
end 

sequence_gen u_sequence_gen(
    .clk   (clk   ),
    .rst_n (rst_n ),
    .dout  (dout  )
);
endmodule
</code></pre> 
<p>波形图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2d/a2/gw6Uo0yj_o.png"></p> 
<p>六、序列发生器</p> 
<p>有”1101“序列输入时输出1否则输出0</p> 
<p>先画状态机</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/7a/QEDODYqq_o.png"></p> 
<pre><code>module seqdetection(
    input clk,
    input rst_n,
    input data_i,

    output flag
);
localparam IDLE=5'b00001,
           s0=5'b00010,
           s1=5'b00100,
           s2=5'b01000,
           s3=5'b10000;
reg [4:0] state,next_state;

always@(posedge clk or negedge rst_n)
    if(~rst_n)
        state&lt;=IDLE;
    else
        state&lt;=next_state;

always@(*)
    case(state)
        IDLE:if(data_i)
                next_state=s0;
            else
                next_state=IDLE;
        s0:if(data_i)
                next_state=s1;
            else
                next_state=IDLE; 
        s1:if(data_i)
                next_state=s1;
            else
                next_state=s2;   
        s2:if(data_i)
                next_state=s3;
            else
                next_state=IDLE;    
        s3:if(data_i)
                next_state=s1;
            else
                next_state=IDLE;
    endcase
           
assign flag=(state==s3)?1'b1:1'b0;
endmodule 
</code></pre> 
<p>仿真代码</p> 
<pre><code>`timescale 1ns/1ps
module tb_seqdetection ();
    
parameter PERIOD=10;
bit clk;
reg rst_n;
reg data_i;
wire flag;

always #(PERIOD/2) clk=~clk;

initial begin
    rst_n=0;
    #PERIOD;
    rst_n = 1;
    repeat(2) seq_gen();
    data_i=1;
    #PERIOD;
    data_i=0;
    #PERIOD;
    data_i=0;
    seq_gen();
end

task seq_gen;
begin
    data_i=1;
    #PERIOD;
    data_i=1;
    #PERIOD;
    data_i=0;
    #PERIOD;
    data_i=1;
    #PERIOD;
end
endtask

seqdetection u_seqdetection(
    .clk    (clk    ),
    .rst_n  (rst_n  ),
    .data_i (data_i ),
    .flag   (flag   )
);

endmodule
</code></pre> 
<p>波形图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/27/76/qzTtISW4_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e1ba3385898ab5b841075d2b750d4e50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring AOP基础组件 AbstractAutoProxyCreator</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/744d20f4886f5777cd205fee8fa8d14c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pycharm使用ssh连接服务器（ubuntu）跑代码报错：“sudo&#43;ssh: ……bash: line 0: cd: xxx/code: No such file or directory”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>