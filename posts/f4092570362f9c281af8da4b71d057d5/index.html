<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kotlin实现ajax,Kotlin 中调用 JavaScript - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/f4092570362f9c281af8da4b71d057d5/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="kotlin实现ajax,Kotlin 中调用 JavaScript">
  <meta property="og:description" content="改进翻译
Kotlin 中调用 JavaScript
Kotlin 最初被设计为能够与 Java 平台轻松互操作。它将 Java 类视为 Kotlin 类，并且 Java 也将 Kotlin 类视为 Java 类。
但是，JavaScript 是一种动态类型语言，这意味着它不会在编译期检测类型。可以通过动态类型在 Kotlin 中自由地与 JavaScript 交流。如果想要使用 Kotlin 类型系统的全部威力，可以为 JavaScript 库创建 Kotlin 编译器与周边工具可理解的外部声明。
An experimental tool to automatically create Kotlin external declarations for npm dependencies which provide type definitions (TypeScript / d.ts) called Dukat is also available.
内联 JavaScript
你可以使用 js(&#34;……&#34;) 函数将一些 JavaScript 代码嵌入到 Kotlin 代码中。
例如：
fun jsTypeOf(o: Any): String {">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-08-06T22:55:34+08:00">
    <meta property="article:modified_time" content="2021-08-06T22:55:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kotlin实现ajax,Kotlin 中调用 JavaScript</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>改进翻译</p> 
 <p>Kotlin 中调用 JavaScript</p> 
 <p>Kotlin 最初被设计为能够与 Java 平台轻松互操作。它将 Java 类视为 Kotlin 类，并且 Java 也将 Kotlin 类视为 Java 类。</p> 
 <p>但是，JavaScript 是一种动态类型语言，这意味着它不会在编译期检测类型。可以通过动态类型在 Kotlin 中自由地与 JavaScript 交流。如果想要使用 Kotlin 类型系统的全部威力，可以为 JavaScript 库创建 Kotlin 编译器与周边工具可理解的外部声明。</p> 
 <p>An experimental tool to automatically create Kotlin external declarations for npm dependencies which provide type definitions (TypeScript / d.ts) called Dukat is also available.</p> 
 <p>内联 JavaScript</p> 
 <p>你可以使用 js("……") 函数将一些 JavaScript 代码嵌入到 Kotlin 代码中。</p> 
 <p>例如：</p> 
 <p>fun jsTypeOf(o: Any): String {<!-- --></p> 
 <p>return js("typeof o")</p> 
 <p>}</p> 
 <p>因为 js 的参数是在编译期解析并且按原样翻译成 JavaScript 代码的，因此它必须是字符串常量。因此，以下代码是不正确的：</p> 
 <p>fun jsTypeOf(o: Any): String {<!-- --></p> 
 <p>return js(getTypeof() + " o") // 此处报错</p> 
 <p>}</p> 
 <p>fun getTypeof() = "typeof"</p> 
 <p>Note that invoking js() returns a result of type dynamic, which provides no type safety at compile time.</p> 
 <p>external 修饰符</p> 
 <p>要告诉 Kotlin 某个声明是用纯 JavaScript 编写的，你应该用 external 修饰符来标记它。</p> 
 <p>当编译器看到这样的声明时，它假定相应类、函数或属性的实现是由外部提供的(由开发人员或者通过 npm 依赖项)，因此不会尝试从声明中生成任何 JavaScript 代码。This is also why external declarations can't have a body。例如：</p> 
 <p>external fun alert(message: Any?): Unit</p> 
 <p>external class Node {<!-- --></p> 
 <p>val firstChild: Node</p> 
 <p>fun append(child: Node): Node</p> 
 <p>fun removeChild(child: Node): Node</p> 
 <p>// 等等</p> 
 <p>}</p> 
 <p>external val window: Window</p> 
 <p>请注意，嵌套的声明会继承 external 修饰符，这也是 Node 类中成员函数和属性之前不需要加 external 修饰符的原因。</p> 
 <p>external 修饰符只允许在包级声明中使用。 你不能声明一个非 external 类的 external 成员。</p> 
 <p>声明类的(静态)成员</p> 
 <p>在 JavaScript 中，你可以在原型或者类本身上定义成员：</p> 
 <p>function MyClass() { …… }</p> 
 <p>MyClass.sharedMember = function() { /* 实现 */ };</p> 
 <p>MyClass.prototype.ownMember = function() { /* 实现 */ };</p> 
 <p>Kotlin 中没有这样的语法。然而，在 Kotlin 中我们有伴生(companion)对象。Kotlin 以特殊的方式处理</p> 
 <p>external 类的伴生对象：替代期待一个对象的是，它假定伴生对象的成员就是该类自身的成员。可以这样描述来自上例中的 MyClass：</p> 
 <p>external class MyClass {<!-- --></p> 
 <p>companion object {<!-- --></p> 
 <p>fun sharedMember()</p> 
 <p>}</p> 
 <p>fun ownMember()</p> 
 <p>}</p> 
 <p>声明可选参数</p> 
 <p>If you are writing an external declaration for a JavaScript function which has an optional parameter, use definedExternally. This delegates the generation of the default values to the JavaScript function itself:</p> 
 <p>external fun myFunWithOptionalArgs(</p> 
 <p>x: Int,</p> 
 <p>y: String = definedExternally,</p> 
 <p>z: String = definedExternally</p> 
 <p>)</p> 
 <p>With this external declaration, you can call myFunWithOptionalArgs with one required argument and two optional arguments, where the default values are calculated by the JavaScript implementation of myFunWithOptionalArgs.</p> 
 <p>扩展 JavaScript 类</p> 
 <p>你可以轻松扩展 JavaScript 类，因为它们是 Kotlin 类。只需定义一个 external open 类并用非 external 类扩展它。例如：</p> 
 <p>open external class Foo {<!-- --></p> 
 <p>open fun run()</p> 
 <p>fun stop()</p> 
 <p>}</p> 
 <p>class Bar: Foo() {<!-- --></p> 
 <p>override fun run() {<!-- --></p> 
 <p>window.alert("Running!")</p> 
 <p>}</p> 
 <p>fun restart() {<!-- --></p> 
 <p>window.alert("Restarting")</p> 
 <p>}</p> 
 <p>}</p> 
 <p>有一些限制：</p> 
 <p>当一个外部基类的函数被签名重载时，不能在派生类中覆盖它。</p> 
 <p>不能覆盖一个使用默认参数的函数。</p> 
 <p>不能用外部类扩展非外部类。</p> 
 <p>external 接口</p> 
 <p>JavaScript 没有接口的概念。当函数期望其参数支持 foo</p> 
 <p>和 bar 两个方法时，只需传入实际具有这些方法的对象。</p> 
 <p>在静态类型的 Kotlin 中，你可以使用接口来表达这一概念：</p> 
 <p>external interface HasFooAndBar {<!-- --></p> 
 <p>fun foo()</p> 
 <p>fun bar()</p> 
 <p>}</p> 
 <p>external fun myFunction(p: HasFooAndBar)</p> 
 <p>外部接口的典型使用场景是描述设置对象。例如：</p> 
 <p>external interface JQueryAjaxSettings {<!-- --></p> 
 <p>var async: Boolean</p> 
 <p>var cache: Boolean</p> 
 <p>var complete: (JQueryXHR, String) -&gt; Unit</p> 
 <p>// 等等</p> 
 <p>}</p> 
 <p>fun JQueryAjaxSettings(): JQueryAjaxSettings = js("{}")</p> 
 <p>external class JQuery {<!-- --></p> 
 <p>companion object {<!-- --></p> 
 <p>fun get(settings: JQueryAjaxSettings): JQueryXHR</p> 
 <p>}</p> 
 <p>}</p> 
 <p>fun sendQuery() {<!-- --></p> 
 <p>JQuery.get(JQueryAjaxSettings().apply {<!-- --></p> 
 <p>complete = { (xhr, data) -&gt;</p> 
 <p>window.alert("Request complete")</p> 
 <p>}</p> 
 <p>})</p> 
 <p>}</p> 
 <p>外部接口有一些限制：</p> 
 <p>它们不能在 is 检测的右侧使用。</p> 
 <p>它们不能作为具体化类型参数传递。</p> 
 <p>它们不能用在类的字面值表达式(例如 I::class)中。</p> 
 <p>as 转换为外部接口总是成功。</p> 
 <p>Casting to external interfaces produces the "Unchecked cast to external interface" compile time warning. The warning can be suppressed with the @Suppress("UNCHECKED_CAST_TO_EXTERNAL_INTERFACE") annotation.</p> 
 <p>IntelliJ IDEA can also automatically generate the @Suppress annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the "Unchecked cast to external interface" inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</p> 
 <p>Casting</p> 
 <p>In addition to the "unsafe" cast operator as, which throws a ClassCastException in case a cast is not possible, Kotlin/JS also provides unsafeCast(). When using unsafeCast, no type checking is done at all during runtime. For example, consider the following two methods:</p> 
 <p>fun usingUnsafeCast(s: Any) = s.unsafeCast()</p> 
 <p>fun usingAsOperator(s: Any) = s as String</p> 
 <p>They will be compiled accordingly:</p> 
 <p>function usingUnsafeCast(s) {<!-- --></p> 
 <p>return s;</p> 
 <p>}</p> 
 <p>function usingAsOperator(s) {<!-- --></p> 
 <p>var tmp$;</p> 
 <p>return typeof (tmp$ = s) === 'string' ? tmp$ : throwCCE();</p> 
 <p>}</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94d6f7bbacc0c32a7d6d854522345847/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">kotlin实现ajax,Kotlin调用JavaScript</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f00b8ec042a5c2d1a7628d105d3ff02a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">睿停车系统车场服务器,睿停车后台管理中心系统-用户手册-前台版本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>