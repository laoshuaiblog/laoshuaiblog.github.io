<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自学Linux 5—Linux 环境下的编译器之 GCC 编译器工具集详细知识点以及静态库与动态库的使用 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/967befe6ab602581e2657c87ed53d57a/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="自学Linux 5—Linux 环境下的编译器之 GCC 编译器工具集详细知识点以及静态库与动态库的使用">
  <meta property="og:description" content="一、Linux 下的 GCC 编译器工具集 在 Linux 环境下的编译器之 Vim 安装与基本操作使用 中介绍了如何使用 Linux 环境下的编译器编写程序，并编写了一个 hello.c 的程序。要使编写的程序能够运行，需要进行程序的编译。 Linux 环境下采用的编译器 GCC 来进行对程序的编译。
1. GCC 简介 GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写，包含 gcc、g&#43;&#43; 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar、nm 等。
gcc -o(output) -o 是指定输出的文件叫什么 gcc -v / --v / --version 查看 gcc 版本号 gcc -I&amp;lt;dir&amp;gt;	指定头文件目录，注意 -I 和指定目录之间没有空格 例：gcc -I./dir/dir test.c dict.c -o app (test.c 中的头文件 &amp;lt;dict.c&amp;gt; 的在 ./dir/dir 目录下，可以理解为间接使 dict.c 成为了系统目录下的文件) gcc -c	只编译，生成 .o 文件，不进行链接 gcc -g	包含调试信息，生成的程序里面包含调试信息，可以用 Debug 工具进行调试。例：gcc test.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-03-25T14:26:25+08:00">
    <meta property="article:modified_time" content="2020-03-25T14:26:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自学Linux 5—Linux 环境下的编译器之 GCC 编译器工具集详细知识点以及静态库与动态库的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Linux__GCC__0"></a>一、Linux 下的 GCC 编译器工具集</h3> 
<p>  在 <a href="https://blog.csdn.net/Change_Improve/article/details/105042555">Linux 环境下的编译器之 Vim 安装与基本操作使用</a> 中介绍了如何使用 <strong>Linux</strong> 环境下的编译器编写程序，并编写了一个 <strong>hello.c</strong> 的程序。要使编写的程序能够运行，需要进行程序的编译。 <strong>Linux</strong> 环境下采用的编译器 <strong>GCC</strong> 来进行对程序的编译。</p> 
<h4><a id="1_GCC__2"></a>1. GCC 简介</h4> 
<p>  <strong>GCC</strong> 是 <strong>Linux</strong> 下的编译工具集，是 <strong>GNU Compiler Collection</strong> 的缩写，包含 <strong>gcc</strong>、<strong>g++</strong> 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 <strong>ar</strong>、<strong>nm</strong> 等。</p> 
<pre><code class="prism language-bash">gcc -o<span class="token punctuation">(</span>output<span class="token punctuation">)</span>  -o 是指定输出的文件叫什么
gcc -v / --v / --version 查看 gcc 版本号
gcc -I<span class="token operator">&lt;</span>dir<span class="token operator">&gt;</span>	指定头文件目录，注意 -I 和指定目录之间没有空格 例：gcc -I./dir/dir test.c dict.c -o app <span class="token punctuation">(</span>test.c 中的头文件 <span class="token operator">&lt;</span>dict.c<span class="token operator">&gt;</span> 的在 ./dir/dir 目录下，可以理解为间接使 dict.c 成为了系统目录下的文件<span class="token punctuation">)</span>
gcc -c		只编译，生成 .o 文件，不进行链接
gcc -g		包含调试信息，生成的程序里面包含调试信息，可以用 Debug 工具进行调试。例：gcc test.c -g -o app
gcc -On 	n<span class="token operator">=</span>0〜3 编译优化，n 越大优化得越多
gcc -Wall	提示更多警告信息，更加严格去编译你的程序，但凡有一点地方不符合语法的地方就给你对应的警告
gcc -D<span class="token operator">&lt;</span>DEF<span class="token operator">&gt;</span>	编译时定义宏，注意 -D 和指定的宏之间没有空格 例：gcc test.c -DDEBUG -o app <span class="token punctuation">(</span>DEBUG 定义的宏<span class="token punctuation">)</span>
gcc -E		生成预处理文件 例：gcc test.c -E -o test.c
gcc -M		生成 .c 文件与头文件依赖关系以用于 Makefile，包括系统库的头文件
gcc -MM		生成 .c 文件与头文件依赖关系以用于 Makefile，不包括系统库的头文件
</code></pre> 
<p>  <strong>GCC</strong> 工具集不仅能编译 <strong>C/C++</strong> 语言，其他例如 <strong>Objective-C</strong>、<strong>Pascal</strong>、<strong>Fortran</strong>、<strong>Java</strong>、<strong>Ada</strong> 等语言均能进行编译。</p> 
<p>  <strong>GCC</strong> 在可以根据不同的硬件平台进行编译，即能进行交叉编译， 在 <strong>A</strong> 平台上编译 <strong>B</strong> 平台的程序，支持常见的 <strong>X86</strong> 、<strong>ARM</strong>、<strong>PowerPC</strong>、<strong>mips</strong>等，以及 <strong>Linux</strong>、<strong>Windows</strong> 等软件平台。</p> 
<p>  <strong>GCC</strong> 在各种平台下都被广泛地采用，特别是嵌入式平台下，这得益于它的目标机定义规则。当对目标机的硬件进行了合适的定义后，可以生成目标机能够正确解析的文件格式。 另外，<strong>GCC</strong> 的强大前端是定义新语言的好方法，例如可以重新定义语法解析规则，定义自己使用的专有编程语言。査看 <strong>www.gnu.org</strong> 上关于 <strong>GCC</strong> 介绍的 <strong>gcc internel</strong> 可以得到更多更详细的信息。</p> 
<p>  <strong>GCC</strong> 的 <strong>C</strong> 编译器是 <strong>gcc</strong> ，其命令格式为：</p> 
<pre><code class="prism language-powershell">Usage: gcc <span class="token namespace">[options]</span> file<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>  <strong>GCC</strong> 支持默认扩展名策略，下表是 <strong>GCC</strong> 下<strong>默认文件扩展名的含义</strong>。</p> 
<table><thead><tr><th align="left">文件扩展名</th><th align="left"><strong>GCC</strong> 所理解的含义</th></tr></thead><tbody><tr><td align="left">*.c</td><td align="left">该类文件为 <strong>C</strong> 语言的源文件</td></tr><tr><td align="left">*.h</td><td align="left">该类文件为 <strong>C</strong> 语言的头文件</td></tr><tr><td align="left">*.i</td><td align="left">该类文件为预处理后的 <strong>C</strong> 文件</td></tr><tr><td align="left">*.C</td><td align="left">该类文件为 <strong>C++</strong> 语言的源文件</td></tr><tr><td align="left">*.cc</td><td align="left">该类文件为 <strong>C++</strong> 语言的源文件</td></tr><tr><td align="left">*.cxx</td><td align="left">该类文件为 <strong>C++</strong> 语言的源文件</td></tr><tr><td align="left">*.m</td><td align="left">该类文件为 <strong>Objective-C</strong> 语言的源文件</td></tr><tr><td align="left">*.s</td><td align="left">该类文件为汇编语言的源文件</td></tr><tr><td align="left">*.o</td><td align="left">该类文件为汇编后的目标文件</td></tr><tr><td align="left">*.a</td><td align="left">该类文件为静态库</td></tr><tr><td align="left">*.so</td><td align="left">该类文件为共享库</td></tr><tr><td align="left">a.out</td><td align="left">该类文件为链接后的输出文件</td></tr></tbody></table> 
<p>  <strong>GCC</strong> 下有很多编译器，可以支持 <strong>C</strong> 语言、<strong>C++</strong> 语言等多种语言，下表是常用的几个编译器。</p> 
<table><thead><tr><th align="left">GCC 编译器命令</th><th align="left">含 义</th></tr></thead><tbody><tr><td align="left">cc</td><td align="left">指的是 C 语言编译器</td></tr><tr><td align="left">gcc</td><td align="left">指的是 C 语言编译器</td></tr><tr><td align="left">cpp</td><td align="left">指的是预处理编译器</td></tr><tr><td align="left">g++</td><td align="left">指的是 C++ 语言编译器</td></tr></tbody></table> 
<p>  进行程序编译的时候，头文件路径和库文件路径是编译器默认查找的地方，参见下表（默认路径）：</p> 
<table><thead><tr><th>类型</th><th align="left">存放路径</th></tr></thead><tbody><tr><td>头文件</td><td align="left">按照先后顺序査找如下目录： <br> /usr/local/include <br> /usr/lib/gcc/i686-Linux-gnu/4.6.3/include <br> /usr/include</td></tr><tr><td>库文件</td><td align="left">按照先后顺序查找如下路径：<br> /usr/lib/gcc/i686-Linux-gnu/4.6.3/ <br> /usr/lib/gcc/i686-Linux-gnu/4.6.3/ <br> /usr/lib/gcc/i686-Linux-gnu/4.6.3/…/…/…/i686-Linux-gnu/lib/i686-Linux-gnu/4.6.3/ <br> /usr/lib/gcc/i686-Linux-gnu/4.6.3/…/…/…/i686-Linux-gnu/lib/ <br> /usr/lib/gcc/i686-Linux-gnu/4.6.3/…/…/…/i686-Linux-gnu/4.6.3/ <br> /usr/lib/gcc/i686-Linux-gnu/4.6.3/…/…/…/ <br> /lib/i686-Linux-gnu/4.6.3/ <br> /lib/ <br> /usr/lib/i686-Linux-gnu/4.6.3/ <br> /usr/lib/</td></tr></tbody></table> 
<h5><a id="__60"></a>㊨ 注意：</h5> 
<p>  <strong>gcc 和 GCC 是两个不同的东西</strong>。</p> 
<p>  <strong>GCC</strong>：<strong>GNU Compiler Collection</strong>（<strong>GUN</strong> 编译器集合)，它可以编译 <strong>C</strong>、<strong>C++</strong>、<strong>JAV</strong>、<strong>Fortran</strong>、<strong>Pascal</strong>、<strong>Object-C</strong>、<strong>Ada</strong> 等语言。</p> 
<p>  <strong>gcc</strong> 是 <strong>GCC</strong> 中的 <strong>GUN C Compiler</strong>（<strong>C 编译器</strong>）。</p> 
<p>  <strong>g++</strong> 是 <strong>GCC</strong> 中的 <strong>GUN C++ Compiler</strong>（<strong>C++ 编译器</strong>）。</p> 
<p>  一个有趣的事实就是，就本质而言，<strong>gcc 和g ++ 并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已</strong>。</p> 
<p>  由于编译器是可以更换的，所以 <strong>gcc 不仅仅可以编译 C 文件</strong>。所以，更准确的说法是：<strong>gcc 调用了 C compiler，而 g++ 调用了 C++ compiler</strong>。</p> 
<h5><a id="gcc__g__73"></a>gcc 和 g++ 的主要区别</h5> 
<ol><li> <p>对于 <strong>*.c</strong> 和 <strong>*.cpp</strong> 文件，<strong>gcc</strong> 分别当做 <strong>c</strong> 和 <strong>cpp</strong> 文件编译（<strong>c</strong> 和 <strong>cpp</strong> 的语法强度是不一样的）</p> </li><li> <p>对于 <strong>*.c</strong> 和 <strong>*.cpp</strong> 文件，<strong>g++</strong> 则统一当做 <strong>cpp</strong> 文件编译</p> </li><li> <p>使用 <strong>g++</strong> 编译文件时，<strong>g++</strong> 会自动链接标准库 <strong>STL</strong>，而 <strong>gcc</strong> 不会自动链接 <strong>STL</strong></p> </li><li> <p><strong>gcc</strong> 在编译 <strong>C</strong> 文件时，可使用的预定义宏是比较少的</p> </li><li> <p><strong>gcc</strong> 在编译 <strong>cpp</strong> 文件时 <strong>/ g++</strong> 在编译 <strong>c</strong> 文件和 <strong>cpp</strong> 文件时（这时候 <strong>gcc</strong> 和 <strong>g++</strong> 调用的都是 <strong>cpp</strong> 文件的编译器），会加入一些额外的宏。</p> </li><li> <p>在用 <strong>gcc</strong> 编译 <strong>c++</strong> 文件时，为了能够使用 <strong>STL</strong>，需要加参数 <strong>-lstdc++</strong> ，但这<strong>并不代表 gcc -lstdc++ 和 g++ 等价</strong>，它们的区别不仅仅是这个。</p> </li></ol> 
<h4><a id="2__87"></a>2. 编译程序的基本知识</h4> 
<p>  <strong>GCC</strong> 编译器对程序的编译过程如下图所示，分为 <strong>4</strong> 个阶段：<strong>预编译、编译和优化、汇编、链接</strong>。<br> <img src="https://images2.imgbox.com/64/10/skKDYiqd_o.png" alt="GCC 对程序的编译过程"><br>   <strong>源文件</strong>、<strong>目标文件</strong>和<strong>可执行文件</strong>是编译过程中经常用到的名词。</p> 
<p>  <strong>源文件通常指存放可编辑代码的文件，如存放 C、C++ 和汇编语言的文件</strong>。</p> 
<p>  <strong>目标文件是指经过编译器的编译生成的 CPU 可识别的二进制代码，但是目标文件一般不能执行，因为其中的一些函数过程没有相关的指示和说明</strong>。</p> 
<p>  <strong>可执行文件就是目标文件与相关的库链接后的文件，它是可以执行的。</strong></p> 
<p>  <strong>预编译过程</strong>将程序中引用的头文件包含进源代码中，并对一些宏进行替换。</p> 
<p>  <strong>编译过程</strong>将用户可识别的语言翻译成一组处理器可识别的操作码，生成目标文件，通常翻译成汇编语言，而汇编语言通常和机器操作码之间是一种一对一的关系。<strong>GNU</strong> 中有 <strong>C/C++</strong> 编译器 <strong>GCC</strong> 和汇编器 <strong>as</strong> 。</p> 
<p>  所有的目标文件必须用某种方式组合起来才能运行，这就是<strong>链接</strong>的作用。目标文件中通常仅解析了文件内部的变量和函数，对于引用的函数和变量还没有解析，这需要将其他已经编写好的目标文件引用进来，将没有解析的变量和函数进行解析，通常引用的目标是库。链接完成后会生成<strong>可执行文件</strong>。</p> 
<h4><a id="3__104"></a>3. 单个文件编译成执行文件</h4> 
<p>  在 <strong>Linux</strong> 下使用 <strong>GCC</strong> 编译器编译单个文件十分简单，直接使用 <strong>gcc</strong> 命令后面加上要编译的 <strong>C</strong> 语言的源文件，<strong>GCC</strong> 会自动生成文件名为 <strong>a.out</strong> 的可执行文件。</p> 
<p>  <strong>自动编译</strong>的过程包括<strong>头文件扩展</strong>、<strong>目标文件编译</strong>，以及<strong>链接默认的系统库生成可执行文件</strong>，最后生成<strong>系统默认的可执行程序 a.out</strong>。</p> 
<p>  下面是一个程序的源代码，代码的作用是在控制台输出“ <strong>Hello World!</strong> ”字符串。</p> 
<pre><code class="prism language-c"><span class="token comment">/* hello.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span>					</span><span class="token comment">/* 头文件包含 */</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	printf <span class="token punctuation">(</span><span class="token string">"Hello World! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">/* 打印"Hello World! " */</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  将代码存入 <strong>hello.c</strong> 文件中，运行如下命令将代码直接编译成可以执行文件：</p> 
<pre><code class="prism language-bash">$ gcc hello.c
</code></pre> 
<p>  在前面中列出了 <strong>GCC</strong> 编译器可以识别的默认文件扩展名，通过检査 <strong>hello.c</strong> 文件的扩展名，<strong>GCC</strong> 知道这是一个 <strong>C</strong> 文件。</p> 
<p>  使用上面的编译命令进行编译的时候，<strong>GCC</strong> 先进行扩展名判断，选择编译器。由于 <strong>hello.c</strong> 的扩展名为 <strong>.c</strong> ，<strong>GCC</strong> 认为这是一个 <strong>C</strong> 文件，会选择 <strong>gcc</strong> 编译器来编译 <strong>hello.c</strong> 文件。</p> 
<p>  <strong>GCC 将采取默认步骤，先将 C 文件编译成目标文件，然后将目标文件链接成可执行文件，最后删除目标文件</strong>。上述命令没有指定生成执行文件的名称，<strong>GCC</strong> 将生成默认的文件名 <strong>a.out</strong> 。运行结果如下：</p> 
<pre><code class="prism language-bash">$ ./a.out	<span class="token punctuation">(</span>执行 a.out 可执行文件）
Hello World<span class="token operator">!</span>
</code></pre> 
<p>  如果希望生成指定的可执行文件名，选项 <strong>-o</strong> 可以使编译程序生成指定文件名，例如将上述程序编译输出一个名称为 <strong>test</strong> 的执行程序：</p> 
<pre><code class="prism language-bash">$ gcc -o <span class="token function">test</span> hello.c
</code></pre> 
<p>  上述命令把 <strong>hello.c</strong> 源文件编译成可执行文件 <strong>test</strong> 。运行可执行文件 <strong>test</strong>，向终端输出“ <strong>Hello World!</strong> ”字符串。运行结果如下：</p> 
<pre><code class="prism language-bash">$ ./test 
Hello World<span class="token operator">!</span>
</code></pre> 
<h4><a id="4__149"></a>4. 编译生成目标文件</h4> 
<p>  <strong>目标文件是指经过编译器的编译生成的 CPU 可识别的二进制代码，因为其中一些函数过程没有相关的指示和说明，目标文件不能执行</strong>。</p> 
<p>  在前面介绍了直接生成可执行文件的编译方法，在这种编译方法中，中间文件作为临时文件存在，在可执行文件生成后，会删除中间文件。<strong>在很多情况下需要生成中间的目标文件，用于不同的编译目标</strong>。</p> 
<p>  <strong>GCC</strong> 的 <strong>-c</strong> 选项用于生成目标文件，这一选项将源文件生成目标文件，而不是生成可执行文件。默认情况下生成的目标文件的文件名和源文件的名称一样，只是扩展名为 <strong>.o</strong> 。例如，下面的命令会生成一个名字为 <strong>hello.o</strong> 的目标文件：</p> 
<pre><code class="prism language-bash">$ gcc -c hello.c
</code></pre> 
<p>  如果需要生成指定的文件名，可以使用 <strong>-o</strong> 选项。下面的命令将源文件 <strong>hello.c</strong> 编译成目标文件，文件名为 <strong>test.o</strong> ：</p> 
<pre><code class="prism language-bash">$ gcc -c -o test.o hello.c
</code></pre> 
<p>  可以用一条命令编译多个源文件，生成目标文件，这通常用于编写库文件或者一个项目中包含多个源文件。例如一个项目包含 <strong>file1.c</strong>、<strong>file2.c</strong> 和 <strong>file3.c</strong>，下面的命令可以将源文件生成 <strong>3</strong> 个目标文件：<strong>file1.o</strong>、<strong>file2.o</strong> 和 <strong>file3.o</strong> ：</p> 
<pre><code class="prism language-bash">$ gcc -c file1.c file2.c file3.c
</code></pre> 
<h4><a id="5__171"></a>5. 多文件编译</h4> 
<p>  <strong>GCC 可以自动编译链接多个文件，不管是目标文件还是源文件，都可以使用同一个命令编译到一个可执行文件中</strong>。</p> 
<p>  例如一个项目包含两个文件，文件 <strong>string.c</strong> 中有一个函数 <strong>StrLen</strong> 用于计算字符串的长度，而在 <strong>main.c</strong> 中调用这个函数将计算的结果显示出来。</p> 
<h6><a id="1_stringc_176"></a>1. 源文件string.c</h6> 
<p>  文件 <strong>string.c</strong> 的内容如下。文件中主要包含了用于计算字符串长度的函数 <strong>StrLen()</strong> 。 <strong>StrLen()</strong> 函数的作用是计算字符串的长度，输入参数为字符串的指针，输出数值为计算字符串长度的计算结果。<strong>StrLen()</strong> 函数将字符串中的字符与 ’ <strong>\0</strong> ’ 进行比较并进行字符长度计数， 获得字符串的长度。</p> 
<pre><code class="prism language-c"><span class="token comment">/* string.c */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> ENDSTRING '\0' 						</span><span class="token comment">/* 定义字符串 */</span>
<span class="token keyword">int</span> <span class="token function">StrLen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>string<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>string<span class="token operator">++</span> <span class="token operator">!=</span> ENDSTRING<span class="token punctuation">)</span> 		<span class="token comment">/* 当 *string 的值为' \0 '时，停止计算 */</span>
	<span class="token punctuation">{<!-- --></span>
		len<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	 <span class="token keyword">return</span> len<span class="token punctuation">;</span>											<span class="token comment">/* 返回此值 */</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="2__mainc_192"></a>2. 源文件 main.c</h6> 
<p>  在文件 <strong>main.c</strong> 中是 <strong>main()</strong> 函数的代码，如下代码所示。<strong>main()</strong> 函数调用 <strong>Strlen()</strong> 函数计算字符串 <strong>Hello Dymatic</strong> 的长度，并将字符串的长度打印出来。</p> 
<pre><code class="prism language-c"><span class="token comment">/* main.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">StrLen</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>								<span class="token comment">/* 声明 Strlen 函数 */</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> src<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Hello Dymatic"</span><span class="token punctuation">;</span>								<span class="token comment">/* 字符串 */</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"string length is:%d\n"</span><span class="token punctuation">,</span><span class="token function">StrLen</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">/* 计算 src 的长度，将结果打印出来 */</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="3__206"></a>3. 编译运行</h6> 
<p>  下面的命令将两个源文件中的程序编译成一个执行文件，文件名为 <strong>test</strong> 。</p> 
<pre><code class="prism language-bash">$ gcc -o <span class="token function">test</span> string.c main.c
</code></pre> 
<p>  执行编译出来的可执行文件 <strong>test</strong> ，程序的运行结果如下：</p> 
<pre><code class="prism language-bash">$ ./test
String length is:13
</code></pre> 
<p>  当然可以先将源文件编成目标文件，然后进行链接。例如，下面的过程先将 <strong>String.c</strong> 和 <strong>main.c</strong> 源文件编译成目标文件 <strong>string.o</strong> 和 <strong>main.o</strong> ，然后将 <strong>string.o</strong> 和 <strong>main.o</strong> 链接生成 <strong>test</strong>：</p> 
<pre><code class="prism language-bash">$ gcc -c string.c main.c 
$ gcc -o <span class="token function">test</span> string.o main.o
</code></pre> 
<h4><a id="6__226"></a>6. 预处理</h4> 
<p>  在 <strong>C</strong> 语言程序中，通常需要包含头文件并会定义一些宏。预处理过程将源文件中的头文件包含进源文件中，并且将文件中定义的宏进行扩展。</p> 
<p>  编译程序时选项 <strong>-E</strong> 告诉编译器进行预编译操作。例如如下命令将文件 <strong>string.c</strong> 的预处理结果显示在计算机屏幕上：</p> 
<pre><code class="prism language-bash">$ gcc -E string.c
</code></pre> 
<p>  如果需要指定源文件预编译后生成的中间结果文件名，需要使用选项 <strong>-o</strong> 。例如，下面的代码将文件 <strong>string.c</strong> 进行预编译，生成文件 <strong>string.i</strong>。<strong>string.i</strong> 内容如下：</p> 
<pre><code class="prism language-bash">$ gcc -o string.i -E string.c
<span class="token comment">#	1 "string.c"</span>
<span class="token comment"># 	1 "&lt;built-in&gt;"</span>
<span class="token comment">#	1 "&lt;命令行&gt; "</span>
<span class="token comment">#	1 "string.c"</span>


int StrLen<span class="token punctuation">(</span>char *string<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	int len <span class="token operator">=</span> 0<span class="token punctuation">;</span>
	while<span class="token punctuation">(</span>*string++ <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		len++<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> len<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  可以发现之前定义的宏 <strong>ENDSTRING</strong> ，已经被替换成了 “ <strong>\0</strong> ”。</p> 
<h4><a id="7__258"></a>7. 编译成汇编语言</h4> 
<p>  编译过程将用户可识别的语言翻译成一组处理器可识别的操作码，通常翻译成汇编语言。汇编语言通常和机器操作码之间是一对一的关系。<br>   生成汇编语言的 <strong>GCC</strong> 选项是 <strong>-S</strong> ，默认情况下生成的文件名和源文件一致，扩展名为 <strong>.s</strong>。 例如，下面的命令将 <strong>C</strong> 语言源文件 <strong>string.c</strong> 编译成汇编语言，文件名为 <strong>string.s</strong></p> 
<pre><code class="prism language-bash">$ gcc -S string.c
</code></pre> 
<p>  下面是编译后的汇编语言文件 <strong>string.s</strong> 的内容。其中，第 <strong>1</strong> 行内容是 <strong>C</strong> 语言的文件名， 第 <strong>3</strong> 行和第 <strong>4</strong> 行是文件中的函数描述，标签 <strong>StrLen</strong> 之后的代码用于实现字符串长度的计算。</p> 
<pre><code class="prism language-bash">	.file	<span class="token string">"string.c"</span> 
	.text
	.globl StrLen 
	.type  StrLen, @function 
StrLen:
.LFB0:
	.cfi_startproc 
	pushl %ebp 
	.cfi_def_cfa_offset 8 
	.cfi_offset 5, -8 
	movl %esp, %ebp 
	.cfi_def_cfa_register 5
	subl	<span class="token variable">$16</span>, %esp
	movl	<span class="token variable">$0</span>,	 -4<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>
	jmp 	.L2 
L3:	
	addl	<span class="token variable">$1</span>, -4<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>
L2:	
	movl	8 <span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>, 	%eax
	movzbl	<span class="token punctuation">(</span>%eax<span class="token punctuation">)</span>, 	%eax
	testb	%al, %al
	setne	%al
	addl	<span class="token variable">$1</span>, 8<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>
	testb	%al, %al
	jne	    .L3	
	movl	-4<span class="token punctuation">(</span>%ebp<span class="token punctuation">)</span>, %eax
	leave	
	.cfi_restore 5 
	.cfi_def_cfa 4, 4 
	ret
	.cfi_endproc 
.LFE0：
	.size StrLen, 
	.-StrLen
	.ident <span class="token string">"GCC: (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3"</span> 
	.section 	.note.GNU-stack,<span class="token string">""</span>,@progbits
</code></pre> 
<h4><a id="8__306"></a>8. 生成和使用静态链接库</h4> 
<p>  <strong>静态库是 obj 文件的一个集合，通常静态库以“ .a ”为后缀</strong>。静态库由程序 <strong>ar</strong> 生成， 现在静态库己经不像之前那么普遍了，这主要是由于<strong>程序都在使用动态库</strong>。</p> 
<p>  <strong>静态库的优点是可以在不用重新编译程序库代码的情况下，进行程序的重新链接，这种方法节省了编译过程的时间（在编译大型程序的时候，需要花费很长时间）</strong>。</p> 
<p>  但是由于现在系统的强大，编译的时间已经不是问题。<strong>静态库的另一个优势是开发者可以提供库文件给使用的人员，不用开放源代码，这是库函数提供者经常采用的手段。如果其他开发人员要使用你的程序，而你又不想给其源码，提供静态库是一种选择。当然这也是程序模块化开发的一种手段，使每个软件开发人员的精力集中在自己的部分</strong>。<strong>在理论上，静态库的执行速度比共享库和动态库要快（1%〜5%），但实际上可能并非如此。由此看来，除了使用方便外，静态库可能并非一种好的选择。</strong>。</p> 
<p>静态库：是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分；共享库：是在执行程序启动时加载到执行程序中，可以被多个执行程序共享使用。</p> 
<p>然而，它们又各有优点。建议库开发人员创建共享库，比较明显的优势在于库是独立的，便于维护和更新；而静态库的更新比较麻烦，一般不做推荐。</p> 
<p><strong>静态库可以认为是一些目标代码的集合</strong>。按照习惯，一般以 “ <strong>.a</strong> ” 做为文件后缀名。使用 ar（archiver）命令可以创建静态库。因为共享库有着更大的优势，静态库已经不经常使用。但静态库使用简单，仍有使用的余地，并会一直存在。有些 Unix 系统，如 Solaris 10，已经基本废弃了静态库。</p> 
<h6><a id="1%09_319"></a>1. 生成静态链接库</h6> 
<p>  生成静态库，或者将一个 <strong>obj</strong> 文件加到已经存在的静态库的命令为 “ <strong>ar 库文件 obj 文件 1 obj 文件 2</strong> ”。创建静态库的最基本步骤是<strong>生成目标文件</strong>，这点前面己经介绍过。然后使用工具 <strong>ar</strong> 对目标文件进行归档。工具 <strong>ar</strong> 的 <strong>-r</strong> 选项，可以创建库，并把目标文件插入到指定库中。例如，将 <strong>string.o</strong> 打包为库文件 <strong>libstr.a</strong> 的命令为：</p> 
<pre><code class="prism language-bash">$ ar -rcs libstr.a string.o
</code></pre> 
<h6><a id="2%09_326"></a>2. 使用静态链接库</h6> 
<p>  在编译程序的时候经常需要使用函数库，例如经常使用的 <strong>C</strong> 标准库等。<strong>GCC</strong> 链接时使用库函数和一般的 <strong>obj</strong> 文件的形式是一致的，例如对 <strong>main.c</strong> 进行链接的时候，需要使用之前己经编译好的静态链接库 <strong>libstr.a</strong> ，命令格式如下：</p> 
<pre><code class="prism language-bash">$ gcc -o <span class="token function">test</span> main.c libstr.a
</code></pre> 
<p>  也可以使用命令“ <strong>-l 库名</strong> ”进行，<strong>库名是不包含函数库和扩展名的字符串</strong>。例如编译 <strong>main.c</strong> 链接静态库 <strong>libstr.a</strong> 的命令可以修改为：</p> 
<pre><code class="prism language-bash">$ gcc -o <span class="token function">test</span> main.c -lstr
</code></pre> 
<p>  上面的命令将在系统默认的路径下查找 <strong>str</strong> 函数库，并把它链接到要生成的目标程序上，可能系统会提示无法找到库文件 <strong>str</strong>，这是由于 <strong>str</strong> 库函数没有在系统默认的查找路径下，需要显示指定库函数的路径，例如库文件和当前编译文件在同一目录下：</p> 
<pre><code class="prism language-bash">$ gcc -o <span class="token function">test</span> main.c -L./ -lstr
</code></pre> 
<p>  ㊨ 注意：在使用 <strong>-l</strong> 选项时，<strong>-o</strong> 选项的目的名称要在 <strong>-l</strong> 链接的库名称之前，否则 <strong>gcc</strong> 会认为 <strong>-I</strong> 是生成的目标而出错。</p> 
<h4><a id="9__345"></a>9. 生成动态链接库</h4> 
<p>  <strong>动态链接库是程序运行时加载的库，当动态链接库正确安装后，所有的程序都可以使用动态库来运行程序。</strong><br>   <strong>动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。</strong><br>   <strong>库中函数和变量的地址是相对地址，不是绝对地址，其真实地址在调用动态库的程序加载时形成。</strong></p> 
<p>  <strong>动态链接库的名称有别名（ soname ）、真名（ realname ）和链接名（ linkername ）</strong>。<br>   <strong>别名由一个前缀 lib，然后是库的名字，再加上个后缀“ .so ”构成</strong>。<br>   <strong>真名是动态链接库的真实名称，一般总是在别名的基础上加上一个小版本号、发布版本等构成</strong>。<br>   除此之外，还有一个<strong>链接名，即程序链接时使用的库的名字</strong>。<br>   在动态链接库安装的时候，总是复制库文件到某个目录下，然后用个软链接生成别名，在库文件进行更新的时候，仅仅更新软链接即可。</p> 
<h6><a id="1__355"></a>1. 生成动态链接库</h6> 
<p>  生成动态链接库的命令很简单，使用 <strong>-fPIC</strong> 选项或者选项 <strong>-fpic</strong> 和选项的作用是使得 <strong>gcc</strong> 生成的代码是位置无关的，例如下面的命令将 <strong>string.c</strong> 编译生成动态链接库：</p> 
<pre><code class="prism language-bash">$ gcc -shared -Wl,-soname,libstr.so -o libstr.so.1 string.c
</code></pre> 
<p>  其中，选项“ <strong>-soname,jibstr.so</strong> ”表示生成动态库时的别名是 <strong>libstr.so</strong> ; “ <strong>-o libstr.so.1</strong> ” 选项则表示是生成名字为 <strong>libstr.so.1</strong> 的实际动态链接库文件；<strong>-shared</strong> 告诉编译器生成一个动态链接库。</p> 
<p>  生成动态链接库之后一个很重要的问题就是安装，一般情况下将生成的动态链接库复制到系统默认的动态链接库的搜索路径下，通常有 <strong>/lib</strong>、<strong>/usr/lib</strong>、<strong>/usr/local/lib</strong>，放到以上任何一个目录下都可以。</p> 
<h6><a id="2__366"></a>2. 动态链接库的配置</h6> 
<p>  <strong>动态链接库不能随意使用，要在运行的程序中使用动态链接库，需要指定系统的动态链接库搜索的路径，让系统找到运行所需的动态链接库才可以</strong>。<br>   <strong>系统中的配置文件 /etc/ld.so.conf 是动态链接库的搜索路径配置文件</strong>。在这个文件内，存放着可被 <strong>Linux</strong> 共享的动态链接库所在目录的名字（系统目录 <strong>/lib</strong>、<strong>/usr/lib</strong> 除外），多个目录名间以空白字符（空格、换行等）或冒号或逗号分隔。查看系统中的动态链接库配置文件的内容：</p> 
<pre><code class="prism language-bash">$ <span class="token function">cat</span> /etc/ld.so.conf
include /etc/ld.so.conf.d/*.conf
</code></pre> 
<p>  <strong>Ubuntu</strong> 的配置文件将目录 <strong>/etc/ld.so.conf.d</strong> 中的配置文件包含进来，对这个目录下的文件进行査看：</p> 
<pre><code class="prism language-bash">$ <span class="token function">ls</span> /etc/ld.so.conf.d/ 
i386-linux-gnu_GL.conf libc.conf
i686-linux-gnu.conf vmware-tools-libraries.conf 
$ <span class="token function">cat</span> /etc/ld.so.conf.d/i686-linux-gnu.conf		<span class="token comment"># 査看配置文件 i486-linux-gnu.conf</span>
<span class="token comment"># Multiarch support </span>
/lib/i386-linux-gnu 
/usr/lib/i386-linux-gnu 
/lib/i686-linux-gnu 
/usr/lib/i686-linux-gnu
</code></pre> 
<p>  从上面的配置文件可以看出，在系统的动态链接库配置中，包含了该动态库 <strong>/Iib/i386-linux-gnu</strong>、<strong>/usr/lib/i386-linux-gnu</strong> 和 <strong>/lib/i686-linux-gnu</strong>、<strong>/usr/lib/i686-linux-gnu</strong> 四个目录。</p> 
<h6><a id="3__389"></a>3. 动态链接库管理命令</h6> 
<p>  为了让新增加的动态链接库能够被系统共享，需要运行动态链接库的管理命令 <strong>ldconfig</strong> 。<strong>ldconfig</strong> 命令的作用是在系统的默认搜索路径，和动态链接库配置文件中所列出的目录里搜索动态链接库，创建动态链接装入程序需要的链接和缓存文件。搜索完毕后， 将结果写入缓存文件 <strong>/etc/ldsoxache</strong> 中，文件中保存的是己经排好序的动态链接库名字列表。<strong>ldconfig</strong> 命令行的用法如下，其中选项的含义参见下表（<strong>ldconfig</strong> 的选项含义）</p> 
<pre><code class="prism language-bash">ldconfig <span class="token punctuation">[</span>-V <span class="token operator">|</span>--verbose<span class="token punctuation">]</span> <span class="token punctuation">[</span>-n<span class="token punctuation">]</span> <span class="token punctuation">[</span>-N<span class="token punctuation">]</span> <span class="token punctuation">[</span>-X<span class="token punctuation">]</span> <span class="token punctuation">[</span>-f CONF<span class="token punctuation">]</span> <span class="token punctuation">[</span>-C CACHE<span class="token punctuation">]</span> <span class="token punctuation">[</span>-r ROOT<span class="token punctuation">]</span> <span class="token punctuation">[</span>-l<span class="token punctuation">]</span> 
<span class="token punctuation">[</span>-p<span class="token operator">|</span>--print-cache<span class="token punctuation">]</span> <span class="token punctuation">[</span>-c FORMAT<span class="token punctuation">]</span> <span class="token punctuation">[</span>--format<span class="token operator">=</span>FORMAT<span class="token punctuation">]</span> <span class="token punctuation">[</span>-V<span class="token punctuation">]</span> <span class="token punctuation">[</span>-?<span class="token operator">|</span>--help<span class="token operator">|</span>--usage<span class="token punctuation">]</span> path …
</code></pre> 
<table><thead><tr><th align="left">选项</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-v</td><td align="left">此选项打印 <strong>ldconfig</strong> 的当前版本号，显示所扫描的每一个目录和动态链接库</td></tr><tr><td align="left">-n</td><td align="left">此选项处理命令行指定的目录，不对系统的默认目录 <strong>/lib</strong>、<strong>/usr/lib</strong> 进行扫描，也不对配置文件 <strong>/etc/ld.so.conf</strong> 中所指定的目录进行扫描</td></tr><tr><td align="left">-N</td><td align="left">此选项 <strong>ldconfig</strong> 不会重建缓存文件</td></tr><tr><td align="left">-X</td><td align="left">此选项 <strong>ldconfig</strong> 不更新链接</td></tr><tr><td align="left">-fCONF</td><td align="left">此选项使用用户指定的配置文件代替默认文件 <strong>/etc/ld.so.conf</strong></td></tr><tr><td align="left">-C CACHE</td><td align="left">此选项使用用户指定的缓存文件代替系统默认的缓存文件 <strong>/etc/ld.so.cache</strong></td></tr><tr><td align="left">-r ROOT</td><td align="left">此选项改变当前应用程序的根目录</td></tr><tr><td align="left">-l</td><td align="left">此选项用于手动链接单个动态链接库</td></tr><tr><td align="left">-p 或 --print-cache</td><td align="left">此选项用于打印出缓存文件中共享库的名字</td></tr></tbody></table> 
<p>  如果想知道系统中有哪些动态链接库，可以使用 <strong>ldconfig</strong> 的 <strong>-p</strong> 选项来列出缓存文件中的动态链接库列表。下面的命令中表明在系统缓存中共有 <strong>682</strong> 个动态链接库。</p> 
<pre><code class="prism language-bash">$ ldconfig -p		<span class="token punctuation">(</span>列出当前系统中的动态链接库<span class="token punctuation">)</span>
在缓冲区<span class="token string">"/etc/ld.so.cache"</span>中找到809个库	<span class="token punctuation">(</span>缓存中的动态链接库的数目<span class="token punctuation">)</span> 
libzephyr.so.4 <span class="token punctuation">(</span>libc6<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> /usr/lib/libzephyr.so.4 
libzeitgeist-1.0.so.1 <span class="token punctuation">(</span>libc6<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> /usr/lib/libzeitgeist-1.0.so.1 
libz.so.l <span class="token punctuation">(</span>libc6<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> /lib/i386-linux-gnu/libz.so.1 
libyelp.so.O <span class="token punctuation">(</span>libc6<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> /usr/lib/libyelp.so.0 
libyajl.so.1 <span class="token punctuation">(</span>libc6<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> /usr/lib/i386-linux-gnu/libyaj1.so.1
</code></pre> 
<p>  使用 <strong>ldconfig</strong> 命令，默认情况下并不将扫描的结果输出。使用 <strong>-v</strong> 选项会将 <strong>ldconfig</strong> 在运行过程中扫描到的目录和共享库信息输出到终端，用户可以看到运行的结果和中间的信息。在执行 <strong>ldconfig</strong> 后，将刷新缓存文件 <strong>/etc/ld.so.cache</strong> 。</p> 
<pre><code class="prism language-bash">$ ldconfig -v 
/usr/lib:	<span class="token punctuation">(</span>扫描 /usr/lib 目录中的动态链接库<span class="token punctuation">)</span>
libdb-4.3.so -<span class="token operator">&gt;</span> libdb-4.3.so 
libXcursor.so.1 -<span class="token operator">&gt;</span> libXcursor.so.1.0.2
/usr/lib/i686: 	<span class="token punctuation">(</span>hwcap: 0x2000000000000<span class="token punctuation">)</span>	<span class="token punctuation">(</span>扫描 /usr/lib/i486 目录中的动态链接库<span class="token punctuation">)</span>
libssl.so.0.9.8 -<span class="token operator">&gt;</span> libssl.so.0.9.8 
libcrypto.so.0.9.8 -<span class="token operator">&gt;</span> libcrypto.so.0.9.8
<span class="token punctuation">..</span>.
</code></pre> 
<p>  当用户的目录并不在系统动态链接库配置文件 <strong>/etc/ld.so.conf</strong> 中指定的时候，可以使用 <strong>ldconfig</strong> 命令显示指定要扫描的目录，将用户指定目录中的动态链接库放入系统中进行共享。命令格式的形式为：</p> 
<pre><code class="prism language-bash">ldconfig	目录名
</code></pre> 
<p>  这个命令将 <strong>ldconfig</strong> 指定的目录名中的动态链接库放入系统的缓存 <strong>/etc/ld.so.cache</strong> 中， 从而可以被系统共享使用。下面的代码将扫描当前用户的 <strong>lib</strong> 目录，将其中的动态链接库加入系统：</p> 
<pre><code class="prism language-bash">$ ldconfig ~/lib
</code></pre> 
<p>  ㊨ 注意：如果在运行上述命令后，再次运行 <strong>ldconfig</strong> 而没有加参数，系统会将 <strong>/lib</strong>、<strong>/usr/lib</strong> 及 <strong>/etc/ld.so.conf</strong> 中指定目录中的动态库加入缓存，这时候上述代码中的动态链接库可能不被系统共享了。</p> 
<h6><a id="4__445"></a>4. 使用动态链接库</h6> 
<p>  在编译程序时，使用动态链接库和静态链接库是一致的，使用“ <strong>-l 库名</strong> ”的方式，在生成可执行文件的时候会链接库文件。例如下面的命令将源文件 main.c 编译成可执行文件 <strong>test</strong>，并链接库文件 <strong>libstr.a</strong> 或者 <strong>libstr.so</strong> ：</p> 
<pre><code class="prism language-bash">$ gcc -o <span class="token function">test</span> main.c -L./ -lstr
</code></pre> 
<p>  <strong>-L 指定链接动态链接库的路径，-Istr 链接库函数 str</strong>。<br>   但是运行 <strong>test</strong> 一般会出现如下问题：</p> 
<pre><code class="prism language-bash">./test: error <span class="token keyword">while</span> loading shared libraries: libstr.so: cannot <span class="token function">open</span> shared 
object file: No such <span class="token function">file</span> or directory
</code></pre> 
<p>  这是由于程序运行时没有找到动态链接库造成的。程序编译时链接动态裢接库和运行时使用动态链接库的概念是不同的，在运行时，程序链接的动态链接库需要在系统目录下才行。有以下几种办法可以解决此问题。</p> 
<p>  █ 将动态链接库的目录放到程序搜索路径中，可以将库的路径加到环境变量 <strong>LD_LIBRARY_PATH</strong> 中实现，例如：</p> 
<pre><code class="prism language-bash">$ <span class="token function">export</span> LD_LIBRARY_PATH<span class="token operator">=</span>/example/ex02:  $ LD_LIBRARY_PATH
</code></pre> 
<p>  将存放库文件 <strong>libstnso</strong> 的路径 <strong>/example/ex02</strong> 加入到搜索路径中，再运行程序就没有之前的警告了。</p> 
<p>  █ 另一种方法是使用 <strong>ld-Linux.so.2</strong> 来加载程序，命令格式为：</p> 
<pre><code class="prism language-bash">/lib/ld-Linux.so.2 --library-path 路径 程序名 
</code></pre> 
<p>  加载 <strong>test</strong> 程序的命令为：</p> 
<pre><code class="prism language-bash">/lib/ld-Linux.so.2 --library-path /example/ex02 <span class="token function">test</span>
</code></pre> 
<p>  ㊨ 注意：如果系统的搜索路径下同时存在静态链接库和动态链接库，默认情况下会链接动态链接库。如果需要强制链接静态链接库，需要加上“ <strong>-static</strong> ”选项，即上述的编译方法改为如下的方式：</p> 
<pre><code class="prism language-bash">$ gcc -o <span class="token function">test</span> main.c -static -lstr
</code></pre> 
<h4><a id="10__487"></a>10. 动态加载库</h4> 
<p>  <strong>动态加载库和一般的动态链接库所不同的是，一般动态链接库在程序启动的时候就要寻找动态库，找到库函数；而动态加载库可以用程序的方法来控制什么时候加载。动态加载库主要有函数 dlopen()、dlerror()、dlsym() 和 dlclose()</strong>。</p> 
<h6><a id="1__dlopen__489"></a>1. 打开动态库 dlopen() 函数</h6> 
<p>  函数 <strong>dlopen()</strong> 按照用户指定的方式打开动态链接库，其中参数 <strong>filename</strong> 为动态链接库的文件名，<strong>flag</strong> 为打开方式，一般为 <strong>RTLD_LASY</strong>，函数的返回值为库的指针。其函数原型如下：</p> 
<pre><code class="prism language-bash">void * dlopen<span class="token punctuation">(</span>const char *filename, int flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  例如，下面的代码使用 <strong>dlopen</strong> 打开当前目录下的动态库 <strong>libstr.so</strong> 。</p> 
<pre><code class="prism language-bash">void *phandle <span class="token operator">=</span> dlopen <span class="token punctuation">(</span><span class="token string">"./libstr. so"</span>, RTLD_LAZY<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="2__dlsym_502"></a>2. 获得函数指针 dlsym()</h6> 
<p>  使用动态链接库的目的是调用其中的函数，完成特定的功能。函数 <strong>dlsym()</strong> 可以获得动态链接库中指定函数的指针，然后可以使用这个函数指针进行操作。函数 <strong>dlsym()</strong> 的原型如下：</p> 
<pre><code class="prism language-bash">void * dlsym<span class="token punctuation">(</span>void *handle, char *symbol<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  其中参数 <strong>handle</strong> 为 <strong>dlopen()</strong> 打开动态库后返回的句柄，参数 <strong>symbol</strong> 为函数的名称，返回值为函数指针。</p> 
<h6><a id="3__510"></a>3. 使用动态加载库的一个例子</h6> 
<p>  下面是一个动态加载库使用的例子。首先使用函数 <strong>dlopen()</strong> 来打开动态链接库，判断是否正常打开，可以使用函数 <strong>dlerror()</strong> 判断错误。如果上面的过程正常，使用函数 <strong>dlsym()</strong> 来获得动态链接库中的某个函数，可以使用这个函数来完成某些功能。其代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/* 动态加载库示例 */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h&gt;</span>	</span><span class="token comment">/* 动态加载库库头 */</span> 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> src<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Hello Dymatic"</span><span class="token punctuation">;</span> 				<span class="token comment">/* 要计算的字符串 */</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pStrLenFun<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">/* 函数指针 */</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>phandle <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> 						<span class="token comment">/* 库句柄 */</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>perr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>							<span class="token comment">/* 错误信息指针 */</span>
	phandle <span class="token operator">=</span> <span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token string">"./libstr.so"</span><span class="token punctuation">,</span> RTLD_LAZY<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">/* 打开 libstr.so 动态链接库 */</span>
	<span class="token comment">/* 判断是否正确打开 */</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>phandle<span class="token punctuation">)</span>							<span class="token comment">/* 打开错误 */</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Failed Load library!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">/* 打印库不能加载信息 */</span>
	<span class="token punctuation">}</span>
	perr <span class="token operator">=</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">/* 读取错误值 */</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>perr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>				<span class="token comment">/* 存在错误 */</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>perr<span class="token punctuation">)</span><span class="token punctuation">;</span> 		
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>					<span class="token comment">/* 正常返回 */</span>
	<span class="token punctuation">}</span>
	pStrLenFun <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>phandle<span class="token punctuation">,</span> <span class="token string">"StrLen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">/* 获得函数 strLen 的地址 */</span>
	perr <span class="token operator">=</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">/* 读取错误信息 */</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>perr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>	<span class="token comment">/* 存在错误 */</span>
	<span class="token punctuation">{<!-- --></span> 
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"％s\n"</span><span class="token punctuation">,</span>perr<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">/* 打印错误函数获得的错误信息 */</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 				<span class="token comment">/*返回*/</span>
	<span class="token punctuation">}</span>	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the string length is: %d\n"</span><span class="token punctuation">,</span><span class="token function">pStrLenFun</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 调用函数 pStrLenFunc 计算字符串的长度 */</span>
	<span class="token function">dlclose</span><span class="token punctuation">(</span>phandle<span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">/* 关闭动态加载库 */</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token punctuation">}</span>
</code></pre> 
<p>  编译上述文件的时候需要链接动态库 <strong>libdl.so</strong>，使用如下的命令将上述代码编译成可执行文件 <strong>testdl</strong>。命令将 <strong>main.c</strong> 编译成可执行文件 <strong>testdl</strong>，并链接动态链接库 <strong>libdl.so</strong>。</p> 
<pre><code class="prism language-bash">$ gcc -o testdl main.c libstr.so -ldl 
</code></pre> 
<p>  执行文件 <strong>testdl</strong> 的结果为:</p> 
<pre><code class="prism language-bash">$ ./testdl
string length is:13
</code></pre> 
<p>  使用动态加载库和动态链接库的结果是一致的。</p> 
<h4><a id="11_GCC__560"></a>11. GCC 常用选项</h4> 
<p>  除了之前介绍的基本功能外，<strong>GCC</strong> 的选项配置是编译时很重要的选择，例如头文件路径、加载库路径、警告信息及调试等。接下来对常用的选项进行介绍。</p> 
<h6><a id="1_DMACRO__562"></a>1. -DMACRO 选项</h6> 
<p>  定义一个宏，在多种预定义的程序中会经常使用。如下代码根据系统是否定义 <strong>Linux</strong> 宏来执行不同的代码。使用 <strong>-D</strong> 选项可以选择不同的代码段，例如 <strong>-DOS_LINUX</strong> 选项将执行代码段 <strong>①</strong>。</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">ifdef</span> OS_LINUX </span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>代码段 ①
<span class="token macro property">#<span class="token directive keyword">else</span> </span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>代码段 ② 
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> 
<p>  █ <strong>-Idir</strong>：将头文件的搜索路径扩大，包含 <strong>dir</strong> 目录。<br>   █ <strong>-Ldir</strong>：将链接时使用的链接库搜索路径扩大，包含 <strong>dir</strong> 目录。<strong>gcc</strong> 都会优先使用共享程序库。<br>   █ <strong>-static</strong>：仅选用静态程序库进行链接，如果一个目录中静态库和动态库都存在，则仅选用静态库。<br>   █ <strong>-g</strong>：包括调试信息。<br>   █ <strong>-On</strong>：优化程序，程序优化后执行速度会更快，程序的占用空间会更小。通常 <strong>gcc</strong> 会进行很小的优化，优化的级别可以选择，即 <strong>n</strong>。最常用的优化级别是 <strong>2</strong>。<br>   █ <strong>-Wall</strong>：打开所有 <strong>gcc</strong> 能够提供的、常用的警告信息。</p> 
<h6><a id="2_GCC__578"></a>2. GCC 的常用选项及含义</h6> 
<p>  下表（常用的编译选项及含义）中是 <strong>GCC</strong> 的常用选项和含义，主要列出了警告选项、代码检查、<strong>ANSI</strong> 兼容等。 可以在编译程序的时候对 <strong>GCC</strong> 的选项进行设置，编写质量高的代码。<br> <img src="https://images2.imgbox.com/ed/c3/1qSUfuCd_o.jpg" alt="常用的编译选项及含义">  ㊨ 注意：在编写代码的时候，不好的习惯会造成程序执行过程中发生错误。在一个比较大的项目中，当程序运行起来后再查找这些错误是很困难的。因此一种好的习惯是使用编译选项将代码的警告信息显示出来，并对代码进行改正。例如，打开编译选项 <strong>-Wall</strong> 和 <strong>-W</strong> 来显示所有的警告信息，甚至更严格一些，打开 <strong>-Werror</strong> 将编译时的警告信息作为错误信息来处理，中断编译。</p> 
<h4><a id="12__581"></a>12. 编译环境的搭建</h4> 
<p>  在安装 <strong>Ubuntu</strong> 的时候，默认情况下会安装 <strong>GCC</strong>。可以使用 <strong>which</strong> 命令来查看系统中是否已经安装了 <strong>GCC</strong>：</p> 
<pre><code class="prism language-bash">$ <span class="token function">which</span> gcc
</code></pre> 
<p>  如果不存在，使用 <strong>apt</strong> 进行升级，获得 <strong>gcc</strong> 包并且安装：</p> 
<pre><code class="prism language-bash">$ <span class="token function">apt-get</span> <span class="token function">install</span> gcc
</code></pre> 
<p>  如果对 <strong>C++</strong> 感兴趣可以安装 <strong>g++</strong>。在编译器安装完毕后，可以使用 <strong>GCC</strong> 进行程序的编译。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/28cde0499ad669536d6b55d7b7804f3c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MATLAB 求任意一个数的所有因子</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0184fef03907cf754f79e21c45359208/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python3报错: takes 1 positional argument but 2 were given 问题解决。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>