<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot集成WebSocket进行前后端通信 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/dac850909fe5a72f10f0d3cc988557c4/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="SpringBoot集成WebSocket进行前后端通信">
  <meta property="og:description" content="项目场景： SpringBoot集成WebSocket进行前后端通信
实现步骤： 1.引入Maven依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-websocket&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 2.配置WebSocket 创建配置类启用WebSocket支持,用@Configuration和@Bean纳入spring
package com.test.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.server.standard.ServerEndpointExporter; @Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 3.核心业务代码 因为WebSocket是类似客户端服务端的形式(采用ws协议)，那么这里的WebSocketServer其实就相当于一个ws协议的Controller
package com.test.service; import java.io.IOException; import java.util.concurrent.CopyOnWriteArraySet; import javax.websocket.OnClose; import javax.websocket.OnError; import javax.websocket.OnMessage; import javax.websocket.OnOpen; import javax.websocket.Session; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import org.springframework.stereotype.Component; import org.springframework.stereotype.Service; import lombok.extern.slf4j.Slf4j; /** * @ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端, * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端 */ @Component @Slf4j @Service @ServerEndpoint(&#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-04-10T11:19:48+08:00">
    <meta property="article:modified_time" content="2023-04-10T11:19:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot集成WebSocket进行前后端通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a id="_0"></a>项目场景：</h2> 
<p> </p> 
<p><code>SpringBoot集成WebSocket进行前后端通信</code></p> 
<hr> 
<h2><a id="_7"></a>实现步骤：</h2> 
<h4>1.引入Maven依赖</h4> 
<pre><code class="language-c">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
<hr> 
<h4><a id="_23"></a>2.配置WebSocket</h4> 
<blockquote> 
 <p>创建配置类启用WebSocket支持,用@Configuration和@Bean纳入spring</p> 
</blockquote> 
<pre><code class="language-java">package com.test.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

@Configuration
public class WebSocketConfig {
	@Bean
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }
}
</code></pre> 
<hr> 
<h4><a id="_30"></a>3.核心业务代码</h4> 
<blockquote> 
 <p>因为WebSocket是类似客户端服务端的形式(采用ws协议)，那么这里的WebSocketServer其实就相当于一个ws协议的Controller</p> 
</blockquote> 
<pre><code class="language-java">package com.test.service;

import java.io.IOException;
import java.util.concurrent.CopyOnWriteArraySet;

import javax.websocket.OnClose;
import javax.websocket.OnError;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.PathParam;
import javax.websocket.server.ServerEndpoint;

import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import lombok.extern.slf4j.Slf4j;

/**
 * @ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,
 * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端
 */
@Component
@Slf4j
@Service
@ServerEndpoint("/websocket/{sid}")
public class WebSocketServer {
	//静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。
    private static int onlineCount = 0;
    //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。
    private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;();

    //与某个客户端的连接会话，需要通过它来给客户端发送数据
    private Session session;

    //接收sid
    private String sid = "";

    /**
     * 连接建立成功调用的方法
     */
    @OnOpen
    public void onOpen(Session session, @PathParam("sid") String sid) {
        this.session = session;
        webSocketSet.add(this); //加入set中
        this.sid = sid;
        addOnlineCount(); //在线数加1
        try {
            sendMessage("conn_success");
            log.info("有新窗口开始监听:" + sid + ",当前在线人数为:" + getOnlineCount());
        } catch (IOException e) {
            log.error("websocket IO Exception");
        }
    }

    /**
     * 连接关闭调用的方法
     */
    @OnClose
    public void onClose() {
        webSocketSet.remove(this); //从set中删除
        subOnlineCount(); //在线数减1
        //断开连接情况下，更新主板占用情况为释放
        log.info("释放的sid为："+sid);
        //这里写你 释放的时候，要处理的业务
        log.info("有一连接关闭！当前在线人数为" + getOnlineCount());

    }

    /**
     * 收到客户端消息后调用的方法
     * @ Param message 客户端发送过来的消息
     */
    @OnMessage
    public void onMessage(String message, Session session) {
        log.info("收到来自窗口" + sid + "的信息:" + message);
        //群发消息
        for (WebSocketServer item : webSocketSet) {
            try {
                item.sendMessage(message);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * @ Param session
     * @ Param error
     */
    @OnError
    public void onError(Session session, Throwable error) {
        log.error("发生错误");
        error.printStackTrace();
    }

    /**
     * 实现服务器主动推送
     */
    public void sendMessage(String message) throws IOException {
        this.session.getBasicRemote().sendText(message);
    }

    /**
     * 群发自定义消息
     */
    public static void sendInfo(String message, @PathParam("sid") String sid) throws IOException {
        log.info("推送消息到窗口" + sid + "，推送内容:" + message);

        for (WebSocketServer item : webSocketSet) {
            try {
                //这里可以设定只推送给这个sid的，为null则全部推送
                if (sid == null) {
// item.sendMessage(message);
                } else if (item.sid.equals(sid)) {
                    item.sendMessage(message);
                }
            } catch (IOException e) {
                continue;
            }
        }
    }

    public static synchronized int getOnlineCount() {
        return onlineCount;
    }

    public static synchronized void addOnlineCount() {
        WebSocketServer.onlineCount++;
    }

    public static synchronized void subOnlineCount() {
        WebSocketServer.onlineCount--;
    }

    public static CopyOnWriteArraySet&lt;WebSocketServer&gt; getWebSocketSet() {
        return webSocketSet;
    }
}
</code></pre> 
<h4>4.测试Controller</h4> 
<pre><code class="language-java">package com.test.controller;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.test.service.WebSocketServer;

import io.swagger.annotations.Api;

@RestController
@RequestMapping("/test")
@Api(tags = { "测试" })
public class TestController {

    //推送数据接口
    @PostMapping("/socket/push/{sid}")
    public Map pushToWeb(@PathVariable String sid, String message) {
        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();
        try {
            WebSocketServer.sendInfo(message, sid);
            result.put("code", sid);
            result.put("msg", message);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return result;
    }
    
}
</code></pre> 
<h4>5.测试页面</h4> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;websocket使用&lt;/title&gt;
&lt;/head&gt;
&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;
&lt;script&gt;
	var socket;
	function openSocket() {
		if (typeof (WebSocket) == "undefined") {
			console.log("您的浏览器不支持WebSocket");
		} else {
			console.log("您的浏览器支持WebSocket");
			//指定要连接的服务器地址与端口
			var socketUrl = "ws://127.0.0.1:8080/websocket/localId";
			console.log(socketUrl);
			if (socket != null) {
				socket.close();
				socket = null;
			}
			// 实例化WebSocket对象，建立连接
			socket = new WebSocket(socketUrl);
			//打开事件
			socket.onopen = function() {
				console.log("websocket已打开");
				setMessageInnerHTML("websocket已打开");
			};
			//获得消息事件
			socket.onmessage = function(msg) {
				console.log(msg.data);
				//消息进入后的处理逻辑
				setMessageInnerHTML("服务端回应: "+msg.data);
			};
			//关闭事件
			socket.onclose = function() {
				console.log("websocket已关闭");
				setMessageInnerHTML("websocket已关闭");
			};
			//发生了错误事件
			socket.onerror = function() {
				console.log("websocket发生了错误");
			}
		}
	}
	function sendMessage() {
		if (typeof (WebSocket) == "undefined") {
			console.log("您的浏览器不支持WebSocket");
		} else {
			console.log("您的浏览器支持WebSocket");
			
			var message = $('#text').val();
			socket.send(message);
			
			setMessageInnerHTML(message);
		}
	}
	
	//将消息显示在网页上
	function setMessageInnerHTML(innerHTML) {
		$("#message").append(innerHTML + '&lt;br/&gt;');
	}
	
	//关闭WebSocket连接
	function closeWebSocket() {
		socket.close();
	}
	
	//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
	window.onbeforeunload = function() {
		closeWebSocket();
	}
&lt;/script&gt;
&lt;body&gt;
	&lt;div  id="main"  style="width: 1200px;height:800px;"&gt;&lt;/div&gt;
	Welcome
	&lt;br /&gt;
	&lt;input id = "text" value="这是一条测试消息"/&gt;
	&lt;button onclick="sendMessage()"&gt;发送消息&lt;/button&gt;
	&lt;hr /&gt;
	&lt;button onclick="openSocket()"&gt;连接socket&lt;/button&gt;
	&lt;button onclick="closeWebSocket()"&gt;关闭WebSocket连接&lt;/button&gt;
	&lt;hr /&gt;
	&lt;div id="message"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h2>效果截图：</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/17/82/Gjfg6ow1_o.png"></p> 
<h2>在线测试：</h2> 
<h3 id="3.4%E3%80%81%E6%B5%8B%E8%AF%95webSocket%EF%BC%88http%3A%2F%2Fwww.jsons.cn%2Fwebsocket%2F%EF%BC%89"><a href="http://www.jsons.cn/websocket/" rel="nofollow" title="http://www.jsons.cn/websocket/">http://www.jsons.cn/websocket/</a></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9c/22/qwez8hGO_o.png"></p> 
<p></p> 
<p>源码地址：<a href="https://download.csdn.net/download/u011974797/87671789" title="https://download.csdn.net/download/u011974797/87671789">https://download.csdn.net/download/u011974797/87671789</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e349248105df3672e2136f446b47d015/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Webots调用MATLAB引擎进行数据处理和绘图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53a36cf51ac06c8601fe265c69acd3a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何把开发的javaweb程序让用户在网上访问使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>