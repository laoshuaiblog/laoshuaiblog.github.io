<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>this 深度解析 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/a160726b5cf3dcc57c367318e591563c/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="this 深度解析">
  <meta property="og:description" content="this 深度解析 这是《你不知道的JavaScript》第三节，深入了解 this 的含义，以及如何判断 this 的指向。
this 是什么 首先我们要知道 this 到底是什么。我认为，this 更像是一个关键字，他最终可能会指向某个对象（也有可能指向undefined）。在函数中，this 只在函数调用的时候才确定其最终指向的对象，当我们在函数中对 this 进行操作的时候，实际是操作 this 指向的变量。
这里会有一些误区：
误区1：this 指向函数本身，这种想法是错的，虽然从 this 的字面含义的确有这层意思。
误区2：this 指函数的作用域，这是初学者比较容易弄混 this 和作用域的概念。诚然在某种情况下，this 可能会指向作用域，但这不代表 this 是函数的作用域。
用简单的示例你就能明白
function a() { let name = &#39;this&#39; console.log(this.name) this.age = 20 console.log(a.age) } a() // log: // undefined // undefined 如果 this 指向函数，那么 this.age = 20 中 age 最终应该会挂载到 a.age 中。如果 this 指向函数作用域，那么 this.name 应该可以访问到作用域中定义的 name 值。但实际都无法获取到。
this 指向 那么 this 实际指向谁，只需遵循下面几个原则，你就能很快判断 this 指向谁">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-07-14T10:52:04+08:00">
    <meta property="article:modified_time" content="2021-07-14T10:52:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">this 深度解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="this__0"></a>this 深度解析</h2> 
<p>这是《你不知道的JavaScript》第三节，深入了解 this 的含义，以及如何判断 this 的指向。</p> 
<h3><a id="this__3"></a>this 是什么</h3> 
<p>首先我们要知道 this 到底是什么。我认为，this 更像是一个关键字，他最终可能会指向某个对象（也有可能指向undefined）。在函数中，this 只在函数调用的时候才确定其最终指向的对象，当我们在函数中对 this 进行操作的时候，实际是操作 this 指向的变量。</p> 
<p>这里会有一些误区：<br> 误区1：this 指向函数本身，这种想法是错的，虽然从 this 的字面含义的确有这层意思。<br> 误区2：this 指函数的作用域，这是初学者比较容易弄混 this 和作用域的概念。诚然在某种情况下，this 可能会指向作用域，但这不代表 this 是函数的作用域。<br> 用简单的示例你就能明白</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">'this'</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// log:</span>
<span class="token comment">// undefined</span>
<span class="token comment">// undefined</span>
</code></pre> 
<p>如果 this 指向函数，那么 <code>this.age = 20</code> 中 <code>age</code> 最终应该会挂载到 <code>a.age</code> 中。如果 this 指向函数作用域，那么 <code>this.name</code> 应该可以访问到作用域中定义的 <code>name</code> 值。但实际都无法获取到。</p> 
<h3><a id="this__25"></a>this 指向</h3> 
<p>那么 this 实际指向谁，只需遵循下面几个原则，你就能很快判断 this 指向谁</p> 
<ul><li>隐式绑定</li><li>显式绑定</li><li>new</li><li>都没有，则是默认绑定</li></ul> 
<p>一般情况下，如果不满足前三种绑定，那么就是默认绑定，我们一个个来说。</p> 
<h4><a id="_35"></a>隐式绑定</h4> 
<p>隐式绑定最简单的判断就是是否有调用者，如：<code>obj.log()</code>；其中 log 是执行的函数，obj 是log的调用者。这种情况下，log 函数执行时 this 指向 obj</p> 
<p>这里你需要注意，不一定非要将 log 函数定义在 obj 内。只要满足 log 的调用者是 obj 即可。这是我们可能会忽略的地方。如：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	name<span class="token operator">:</span> <span class="token string">'bbbb'</span><span class="token punctuation">,</span>
	<span class="token function-variable function">log</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	name<span class="token operator">:</span> <span class="token string">'aaaa'</span><span class="token punctuation">,</span>
	log<span class="token operator">:</span> _log
<span class="token punctuation">}</span>

obj<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// aaaa</span>
</code></pre> 
<p>你不需要太过注重函数定义的位置（一般情况下），因为决定 log 函数中 this 指向的是他实际的调用者。</p> 
<h4><a id="_56"></a>显式调用</h4> 
<p>显式调用是指使用<code>call</code>，<code>apply</code>，<code>bind</code>等方法强制改变函数执行时 this 的指向。这里简单演示一下</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	name<span class="token operator">:</span> <span class="token string">'a'</span>
<span class="token punctuation">}</span>
<span class="token function">log</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// a 直接执行，第二个参数后接收变量，作为参数传入log</span>
<span class="token function">log</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// a 直接执行，第二个参数是一个数组，数组最终会展开传入log</span>
<span class="token function">log</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//a 返回一个新的函数，第二个参数后接收变量，作为参数传入log</span>
</code></pre> 
<p>这里不详细讨论这些方法的用法，这不是我们的重点。</p> 
<p>如何隐式和显式一起调用，那么最终 this 指向谁呢？</p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	name<span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span>
	<span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>name<span class="token operator">:</span> <span class="token string">'b'</span><span class="token punctuation">}</span>
a<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// ?</span>

<span class="token comment">// 实际最终打印 b</span>
</code></pre> 
<p>显式调用的优先级高于隐式调用</p> 
<h4><a id="new_88"></a>new</h4> 
<p>在我们使用构造函数 new 一个对象的时候，函数最终会返回一个对象，而函数内对 this 的操作会最终执行到这个对象。<br> 这实际是因为，构造函数在 new 的时候，会新建一个空的对象，并将函数的 this 指向这个新建的对象，所以函数内对 this 的操作，实际就是对这个新的对象的操作。构造函数在执行的时候实际可以指定需要指向的对象，但一般用的不多，这里不做讨论。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>

<span class="token comment">// {name: 'foo'}</span>
</code></pre> 
<h4><a id="_100"></a>默认绑定</h4> 
<p>如果不满足上面三种情况，那么函数中 <code>this</code> 会进行默认绑定到 <code>window</code>（非严格模式下），如果是严格模式下，会绑定 <code>undefined</code>。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Window</span>

<span class="token comment">// 严格模式</span>
<span class="token string">'use strict'</span>
<span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>
</code></pre> 
<h3><a id="_116"></a>箭头函数</h3> 
<p>对于箭头函数，他内部的this指向，他并不适用于用上面四种情况来判断。因为严格意义来说箭头函数内部并没有this。若在箭头函数内调用 <code>this</code> ，<code>this</code> 最终指向其定义该箭头函数时父级作用域的 <code>this</code>。类似词法作用域，所以箭头函数的 <code>this</code> 在定义该箭头函数的时候就已经确定，且无法改变。所以在使用箭头函数的时候需要注意其 <code>this</code> 的指向。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> log <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">far</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function-variable function">log</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 箭头函数 this 指向父级 this</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">far</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当 far 执行的时候定义了log箭头函数，且此时 far 函数 this 指向 obj</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// log 是一个箭头函数，其 this 指向父级函数的this，也就是 obj</span>
</code></pre> 
<p>箭头函数的 <code>this</code> 这种继承的效果，可以让我们更好的处理某些函数中需要使用特定 <code>this</code> 对象的情况。但这同时也会引发一些问题，如 <code>this</code> 强制绑定，这是需要注意的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a9d1658c1b8104a566e82b3df9bcc89c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue 中 key 值的作用？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78ee7d5f35a46c3203152e51334d2a15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Tornado部署Flask项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>