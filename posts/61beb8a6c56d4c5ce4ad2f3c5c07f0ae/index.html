<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java数据结构前置知识以及认识泛型 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/61beb8a6c56d4c5ce4ad2f3c5c07f0ae/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="java数据结构前置知识以及认识泛型">
  <meta property="og:description" content="目录
什么是集合框架
容器
时间复杂度
空间复杂度
包装类
装箱
拆箱
引出泛型
泛型类的使用
类型推导
泛型如何编译的
泛型的上界
泛型方法静态泛型方法以及泛型上界
什么是集合框架 Java 集合框架 Java Collection Framework ，又被称为容器 container ，是定义在 java.util 包下的一组接口 interfaces和其实现类 classes 。
如何理解这张图？
所有的这些从某种意义上说都实现了Iterable这个接口，然后collection继承extends了它也可以说拓展了它这个接口相当于collection这个接口具备了Iterable这个接口的功能，相当于这个接口定义的类型可以引用下面具体的对象，例如List list=new ArrayList()暂且这样写，后面同样一个道理
这张图描述了java当中 类与类 类与接口之间的关系
说明：java的集合类和关系不一定只有上图，上图只是描述了部分重要的常见的类
容器 每个容器其实都是对某种特定数据结构的封装
1. Collection ： 是一个接口，包含了大部分容器常用的一些方法 2. List ： 是一个接口，规范了 ArrayList 和 LinkedList 中要实现的方法 ArrayList ： 实现了 List 接口，底层为动态类型顺序表 LinkedList ：实现了 List 接口，底层为双向链表 3. Stack ：底层是栈，栈是一种特殊的顺序表 4. Queue ：底层是队列，队列是一种特殊的顺序表 5. Deque ：是一个接口 6. Set ：集合，是一个接口，里面放置的是 K 模型 HashSet ：底层为哈希桶，查询的时间复杂度为 O(1) TreeSet ：底层为红黑树，查询的时间复杂度为 O(Log2N ),关于 key 有序的 7.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-14T12:04:09+08:00">
    <meta property="article:modified_time" content="2024-02-14T12:04:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java数据结构前置知识以及认识泛型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6" rel="nofollow">什么是集合框架</a></p> 
<p id="%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%AE%B9%E5%99%A8" rel="nofollow">容器</a></p> 
<p id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">时间复杂度</a></p> 
<p id="%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">空间复杂度</a></p> 
<p id="%E5%8C%85%E8%A3%85%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E5%8C%85%E8%A3%85%E7%B1%BB" rel="nofollow">包装类</a></p> 
<p id="%E8%A3%85%E7%AE%B1-toc" style="margin-left:40px;"><a href="#%E8%A3%85%E7%AE%B1" rel="nofollow">装箱</a></p> 
<p id="%E6%8B%86%E7%AE%B1-toc" style="margin-left:40px;"><a href="#%E6%8B%86%E7%AE%B1" rel="nofollow">拆箱</a></p> 
<p id="%E5%BC%95%E5%87%BA%E6%B3%9B%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E5%BC%95%E5%87%BA%E6%B3%9B%E5%9E%8B" rel="nofollow">引出泛型</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">泛型类的使用</a></p> 
<p id="%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC-toc" style="margin-left:120px;"><a href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC" rel="nofollow">类型推导</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E7%9A%84-toc" style="margin-left:40px;"><a href="#%E6%B3%9B%E5%9E%8B%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E7%9A%84" rel="nofollow">泛型如何编译的</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C-toc" style="margin-left:40px;"><a href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C" rel="nofollow">泛型的上界</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E9%9D%99%E6%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E4%B8%8A%E7%95%8C-toc" style="margin-left:40px;"><a href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E9%9D%99%E6%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E4%B8%8A%E7%95%8C" rel="nofollow">泛型方法静态泛型方法以及泛型上界</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6">什么是集合框架</h3> 
<p>Java 集合框架 Java Collection Framework ，又被称为容器 container ，是定义在 java.util 包下的一组接口 interfaces和其实现类 classes 。</p> 
<p><strong>如何理解这张图？</strong></p> 
<p><img alt="" height="884" src="https://images2.imgbox.com/45/f2/Zc8abIBE_o.png" width="1200"></p> 
<p></p> 
<p><strong>所有的这些从某种意义上说都实现了Iterable这个接口，然后collection继承extends了它也可以说拓展了它这个接口相当于collection这个接口具备了Iterable这个接口的功能，相当于这个接口定义的类型可以引用下面具体的对象，例如List list=new ArrayList()暂且这样写，后面同样一个道理</strong></p> 
<p><strong>这张图描述了java当中 类与类 类与接口之间的关系</strong></p> 
<p><strong>说明：java的集合类和关系不一定只有上图，上图只是描述了部分重要的常见的类</strong></p> 
<hr> 
<h3 id="%E5%AE%B9%E5%99%A8" style="background-color:transparent;">容器</h3> 
<p>每个容器其实都是对某种特定数据结构的封装</p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;"><strong>Collection</strong></span> 
  <span style="color:#333333;"><strong>：</strong></span> 
  <span style="color:#333333;">是一个接口，包含了大部分容器常用的一些方法 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">2. </span> 
  <span style="color:#333333;"><strong>List</strong></span> 
  <span style="color:#333333;"><strong>：</strong></span> 
  <span style="color:#333333;">是一个接口，规范了</span> 
  <span style="color:#333333;">ArrayList </span> 
  <span style="color:#333333;">和</span> 
  <span style="color:#333333;"> LinkedList</span> 
  <span style="color:#333333;">中要实现的方法 </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>ArrayList</strong></span> 
  <span style="color:#333333;"><strong>：</strong></span> 
  <span style="color:#333333;">实现了</span> 
  <span style="color:#333333;">List</span> 
  <span style="color:#333333;">接口，底层为动态类型顺序表 </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>LinkedList</strong></span> 
  <span style="color:#333333;">：实现了</span> 
  <span style="color:#333333;">List</span> 
  <span style="color:#333333;">接口，底层为双向链表 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">3. </span> 
  <span style="color:#333333;"><strong>Stack</strong></span> 
  <span style="color:#333333;">：底层是栈，栈是一种特殊的顺序表 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">4. </span> 
  <span style="color:#333333;"><strong>Queue</strong></span> 
  <span style="color:#333333;">：底层是队列，队列是一种特殊的顺序表 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">5. </span> 
  <span style="color:#333333;"><strong>Deque</strong></span> 
  <span style="color:#333333;">：是一个接口 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">6. </span> 
  <span style="color:#333333;"><strong>Set</strong></span> 
  <span style="color:#333333;">：集合，是一个接口，里面放置的是</span> 
  <span style="color:#333333;">K</span> 
  <span style="color:#333333;">模型 </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>HashSet</strong></span> 
  <span style="color:#333333;">：底层为哈希桶，查询的时间复杂度为</span> 
  <span style="color:#333333;">O(1) </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>TreeSet</strong></span> 
  <span style="color:#333333;">：底层为红黑树，查询的时间复杂度为</span> 
  <span style="color:#333333;">O(Log2N ),关于</span> 
  <span style="color:#333333;">key</span> 
  <span style="color:#333333;">有序的 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">7. </span> 
  <span style="color:#333333;"><strong>Map</strong></span> 
  <span style="color:#333333;">：映射，里面存储的是</span> 
  <span style="color:#333333;">K-V</span> 
  <span style="color:#333333;">模型的键值对 </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>HashMap</strong></span> 
  <span style="color:#333333;">：底层为哈希桶，查询时间复杂度为</span> 
  <span style="color:#333333;">O(1) </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>TreeMap</strong></span> 
  <span style="color:#333333;">：底层为红黑树，查询的时间复杂度为O(Log2N )，关于key</span> 
  <span style="color:#333333;">有序</span> 
 </div> 
</blockquote> 
<p></p> 
<hr> 
<h3 id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</h3> 
<p>时间效率被称为时间复杂度，算法中的基本操作的执行次数一般找执行语句最多的，为算法的时间复杂度</p> 
<p>大O的渐进表示法：</p> 
<p>用法例子：</p> 
<pre><code>// 请计算一下func1基本操作执行了多少次？
    void func1(int N){
    int count = 0;
    for (int i = 0; i &lt; N ; i++) {
    for (int j = 0; j &lt; N ; j++) {
    count++;
}
}
    for (int k = 0; k &lt; 2 * N ; k++) {
    count++;
}
    int M = 10;
    while ((M--) &gt; 0) {
    count++;
}
    System.out.println(count);
}</code></pre> 
<p>只需要大概执行次数，那么这里我们使用大O的渐进表示法</p> 
<p><strong>满足三点：</strong></p> 
<p><strong>1、用常数1取代运行时间中的所有加法常数</strong></p> 
<p><strong>2、在修改后的运行次数函数中，只保留最高阶项</strong></p> 
<p><strong>3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶</strong></p> 
<p><strong>在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)</strong></p> 
<p></p> 
<hr> 
<p></p> 
<h3 id="%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">空间复杂度</h3> 
<p>而空间效率被称作空间复杂度</p> 
<div> 
 <span style="color:#333333;">空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 </span> 
 <span style="color:#333333;">。空间复杂度不是程序占用了多少</span> 
 <span style="color:#333333;">bytes</span> 
 <span style="color:#333333;">的空 间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟时间复杂度类似，也 使用大</span> 
 <span style="color:#333333;">O</span> 
 <span style="color:#333333;">渐进表示法。</span> 
</div> 
<div></div> 
<div>
  用法例子： 
</div> 
<div></div> 
<div> 
 <pre><code>/ 计算bubbleSort的空间复杂度？
void bubbleSort(int[] array) {
    for (int end = array.length; end &gt; 0; end--) {
    boolean sorted = true;
    for (int i = 1; i &lt; end; i++) {
    if (array[i - 1] &gt; array[i]) {
    Swap(array, i - 1, i);
    sorted = false;
}
}
    if (sorted == true) {
    break;
}
}
}</code></pre> 
</div> 
<p><strong>注意</strong></p> 
<p>如果算法中使用了固定数量的额外变量或数组，不随输入规模的增加而变化，则空间复杂度是O(1)。</p> 
<p>如果算法使用了和输入规模相关的额外空间，比如创建了一个大小与输入规模相等的数组来存储结果，那么空间复杂度通常是 O(N)。</p> 
<p>对于递归算法，需要考虑递归调用所使用的栈空间。</p> 
<p>每次递归调用都会占用一定的栈空间，因此递归算法的空间复杂度通常是 O(N) 或者 O(log N)，取决于递归调用的深度</p> 
<p></p> 
<hr> 
<h3 id="%E5%8C%85%E8%A3%85%E7%B1%BB"><span style="color:#333333;">包装类 </span></h3> 
<p></p> 
<div> 
 <span style="color:#333333;">在</span> 
 <span style="color:#333333;">Java</span> 
 <span style="color:#333333;">中，由于基本类型不是继承自</span> 
 <span style="color:#333333;">Object</span> 
 <span style="color:#333333;">，为了在泛型代码中可以支持基本类型，</span> 
 <span style="color:#333333;">Java</span> 
 <span style="color:#333333;">给每个基本类型都对应了 一个包装类型</span> 
</div> 
<div></div> 
<pre><code>基本数据类型 包装类
byte       Byte
short      Short
int        Integer
long       Long
float      Float
double     Double
char       Character
boolean    Boolean</code></pre> 
<hr> 
<h3 id="%E8%A3%85%E7%AE%B1"><span style="color:#333333;">装箱</span></h3> 
<div> 
 <pre><code>public static void main1(String[] args) {
        //装箱/装包:把一个 基本数据类型 转变为 包装类型
        Integer a = 10;// 隐式装箱/自动装箱
        int i = 99;
        Integer b = i;
        System.out.println(b);

        Integer aa = Integer.valueOf(10);//显示装箱
        System.out.println(aa);
    }
}</code></pre> 
 <p></p> 
</div> 
<h3 id="%E6%8B%86%E7%AE%B1"><span style="color:#333333;"><strong>拆箱 </strong></span></h3> 
<pre><code>  public static void main2(String[] args) {
        //拆箱/拆包:把一个 包装类型 转变为 基本数据类型
        Integer a = 66;
        int b = a;//自动拆箱
        System.out.println(b);

        int aa = a.intValue();//显示拆箱

        double d = a.doubleValue();//拆成double类型
    }</code></pre> 
<p></p> 
<hr> 
<div> 
 <strong><span style="color:#333333;">下列代码输出什么，为什么？ </span></strong> 
</div> 
<div></div> 
<pre><code>public class Test {
    public static void main(String[] args) {
        Integer a = 100;
        Integer b = 100;
        System.out.println(a == b);

        Integer a1 = 200;
        Integer b1 = 200;
        System.out.println(a1 == b1);

    }</code></pre> 
<p><strong>解释如下：</strong></p> 
<p>Java 中的 Integer 类在范围为 [-128, 127] 内的整数上具有缓存功能，即当创建一个范围内的 Integer 对象时，会从缓存中获取已经存在的对象而不是新创建一个对象。这是因为在此范围内的整数被频繁使用，因此缓存可以提高性能和节省内存。</p> 
<p>但是，当整数超出范围 [-128, 127] 时，每次创建的 Integer 对象都会是一个新的对象，因此这些对象的地址不同，即使它们的值相同。因此，对于超出范围的整数，使用 == 比较两个 Integer 对象时，结果通常会是 false。</p> 
<p><strong>结果：</strong></p> 
<p>a 和 b 的值都在范围内，因此它们的地址相同，a == b 返回 true。<br> c 和 d 的值超出范围，因此它们的地址不同，c == d 返回 false。</p> 
<hr> 
<h3 id="%E5%BC%95%E5%87%BA%E6%B3%9B%E5%9E%8B"><span style="color:#333333;"><strong>引出泛型</strong></span></h3> 
<p></p> 
<div> 
 <span style="color:#333333;">实现一个类，类中包含一个数组成员，使得数组中可以存放任何类型的数据，也可以根据成员方法</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">返回数组中某个 下标的值？ </span> 
</div> 
<div></div> 
<div> 
 <strong>泛型语法例子：</strong> 
</div> 
<pre><code>/**
 * @param &lt;T&gt; 代表当前类 是一个 泛型类，&lt;T&gt;是一个占位符
 */
class MyArray&lt;T&gt; {
    //public T[] array = (T[]) new Object[10];
    public Object[] array = new Object[10];

    public void setValue(int pos, T val) {
        this.array[pos] = val;
    }

    public T getValue(int pos) {
        return (T) array[pos];//把返回类型 强转为指定类型
    }

}

public class Test2 {
    public static void main(String[] args) {
        //泛型其实就是将 类型 进行 传递
        MyArray&lt;Integer&gt; myArray = new MyArray&lt;&gt;();
        myArray.setValue(1, 10);
        System.out.println(myArray.getValue(1));

        MyArray&lt;String&gt; myArray1 = new MyArray&lt;&gt;();
        myArray1.setValue(0, "hello");
        System.out.println(myArray1.getValue(0));
    }
}</code></pre> 
<div> 
 <span style="color:#333333;">以上代码实现后 发现 任何类型数据都可以存放 </span> 
</div> 
<div></div> 
<div> 
 <div> 
  <strong><span style="color:#333333;">1. </span><span style="color:#333333;">类名后的 </span><span style="color:#333333;">&lt;T&gt; </span><span style="color:#333333;">代表占位符，表示当前类是一个泛型类 </span></strong> 
 </div> 
 <div></div> 
 <div> 
  <strong><span style="color:#333333;">注意</span><span style="color:#333333;">【规范】类型形参一般使用一个大写字母表示，常用的名称有： </span></strong> 
 </div> 
 <div></div> 
 <div> 
  <strong><span style="color:#333333;">2.</span><span style="color:#333333;">不能</span><span style="color:#333333;">new</span><span style="color:#333333;">泛型类型的数组</span></strong> 
 </div> 
</div> 
<div></div> 
<div> 
 <strong><span style="color:#333333;">虽然在这种情况下，当前数组任何数据都可以存放，但是，更多情况下，我们还是希望他只能够持有一种数据类 型。而不是同时持有这么多类型。所以，泛型的主要目的：就是指定当前的容器，要持有什么类型的对象。让编译 </span><span style="color:#333333;">器去做检查。</span><span style="color:#333333;">此时，就需要把类型，作为参数传递。需要什么类型，就传入什么类型</span></strong> 
</div> 
<div></div> 
<div></div> 
<div> 
 <hr> 
 <h3 id="%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span style="color:#333333;"><strong>泛型类的使用 </strong></span></h3> 
</div> 
<div>
  例子： 
</div> 
<div></div> 
<div> 
 <pre><code>MyArray&lt;Integer&gt; list = new MyArray&lt;Integer&gt;();</code></pre> 
 <div> 
  <span style="color:#333333;"><strong>注意：泛型只能接受类，所有的基本数据类型必须使用包装类！</strong></span> 
 </div> 
 <div></div> 
 <div> 
  <h5 id="%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span style="color:#333333;"><strong>类型推导</strong></span></h5> 
  <div> 
   <span style="color:#333333;">例子：</span> 
  </div> 
  <div></div> 
  <div> 
   <pre><code>MyArray&lt;Integer&gt; list = new MyArray&lt;&gt;(); // 可以推导出实例化需要的类型实参为 Integer</code></pre> 
   <div> 
    <strong><span style="color:#333333;">小结： </span></strong> 
   </div> 
   <div> 
    <strong><span style="color:#333333;">1. </span><span style="color:#333333;">泛型是将数据类型参数化，进行传递 </span></strong> 
   </div> 
   <div></div> 
   <div> 
    <strong><span style="color:#333333;">2. </span><span style="color:#333333;">使用 </span><span style="color:#333333;">&lt;T&gt; </span><span style="color:#333333;">表示当前类是一个泛型类。 </span></strong> 
   </div> 
   <div></div> 
   <div> 
    <strong><span style="color:#333333;">3. </span><span style="color:#333333;">泛型目前为止的优点：数据类型参数化，编译时自动进行类型检查和转换 </span></strong> 
   </div> 
  </div> 
 </div> 
</div> 
<div></div> 
<div></div> 
<div> 
 <hr> 
 <h3 id="%E6%B3%9B%E5%9E%8B%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E7%9A%84"><span style="color:#333333;"><strong>泛型如何编译的</strong></span></h3> 
 <p><strong><span style="color:#333333;">擦除机制 </span></strong></p> 
 <p><span style="color:#333333;">通过命令：</span><span style="color:#333333;">javap -c </span><span style="color:#333333;">查看字节码文件，所有的</span><span style="color:#333333;">T</span><span style="color:#333333;">都是</span><span style="color:#333333;">Object</span></p> 
 <p><img alt="" height="789" src="https://images2.imgbox.com/f1/95/WFqJ7wFk_o.png" width="1179"></p> 
 <div> 
  <span style="color:#333333;">在编译的过程当中，将所有的</span> 
  <span style="color:#333333;">T</span> 
  <span style="color:#333333;">替换为</span> 
  <span style="color:#333333;">Object</span> 
  <span style="color:#333333;">这种机制，我们称为：</span> 
  <span style="color:#333333;"><strong>擦除机制</strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">Java</span> 
  <span style="color:#333333;">的泛型机制是在编译级别实现的。编译器生成的字节码在运行期间并不包含泛型的类型信息</span> 
 </div> 
 <div></div> 
 <div> 
  <hr> 
  <h3 id="%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C"><span style="color:#333333;"><strong>泛型的上界</strong></span></h3> 
 </div> 
</div> 
<div>
  语法： 
</div> 
<div></div> 
<div> 
 <pre><code>class 泛型类名称&lt;类型形参 extends 类型边界&gt; {
...
}</code></pre> 
 <p>例子：</p> 
 <pre><code>public class MyArray&lt;E extends Number&gt; {
...
}</code></pre> 
 <div> 
  <span style="color:#333333;">上述例子表示只接受</span> 
  <span style="color:#333333;"> Number </span> 
  <span style="color:#333333;">的子类型作为</span> 
  <span style="color:#333333;"> E </span> 
  <span style="color:#333333;">的类型实参</span> 
 </div> 
</div> 
<div></div> 
<div> 
 <pre><code>MyArray&lt;Integer&gt; l1; // 正常，因为 Integer 是 Number 的子类型
MyArray&lt;String&gt; l2; // 编译错误，因为 String 不是 Number 的子类型</code></pre> 
 <hr> 
 <h3 id="%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E9%9D%99%E6%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E4%B8%8A%E7%95%8C"><span style="color:#333333;"><strong>泛型方法静态泛型方法以及泛型上界</strong></span></h3> 
 <p><span style="color:#333333;">定义语法：</span></p> 
 <pre><code>方法限定符 &lt;类型形参列表&gt; 返回值类型 方法名称(形参列表) { ... }</code></pre> 
 <div>
   例子： 
 </div> 
 <div></div> 
 <div> 
  <pre><code>class Person1 implements Comparable&lt;Person1&gt; {
    @Override
    public int compareTo(Person1 o) {
        return 0;
    }
}

//泛型类
//T一定是实现了Comparable这个接口
class A&lt;T extends Comparable&lt;T&gt;&gt; {//将来你指定这个A泛型类传入的类型参数一定是实现了Comparable这个接口

    public T findMax(T[] array) {
        T max = array[0];
        for (int i = 1; i &lt; array.length; i++) {
            if (max.compareTo(array[i]) &lt; 0) {
                max = array[i];
            }
        }
        return max;
    }
}

//泛型方法
class B {
    public &lt;T extends Comparable&lt;T&gt;&gt; T findMax(T[] array) {
        T max = array[0];
        for (int i = 1; i &lt; array.length; i++) {
            if (max.compareTo(array[i]) &lt; 0) {
                max = array[i];
            }
        }
        return max;
    }
}

//静态泛型方法
class B1 {
    public static &lt;T extends Comparable&lt;T&gt;&gt; T findMax(T[] array) {
        T max = array[0];
        for (int i = 1; i &lt; array.length; i++) {
            if (max.compareTo(array[i]) &lt; 0) {
                max = array[i];
            }
        }
        return max;
    }
}

public class Test4 {
    public static void main(String[] args) {
        //静态泛型方法
        Integer[] integers2 = {1, 2, 3, 4};
        Integer integer3 = B1.findMax(integers2);
        System.out.println(integer3);

        //泛型方法
        B b = new B();
        Integer[] integers1 = {1, 2, 3, 4};
        //类型推导：根据实参传值 来推导 此时的类型
        Integer integer1 = b.findMax(integers1);//两种写法
        Integer integer2 = b.&lt;Integer&gt;findMax(integers1);//两种写法,这个全一点，可以省略
        System.out.println(integer1);

        //泛型类
        A&lt;Integer&gt; a = new A&lt;&gt;();
        Integer[] integers = {1, 2, 3, 4};
        Integer integer = a.findMax(integers);
        System.out.println(integer);

        A&lt;Person1&gt; a1 = new A&lt;&gt;();
    }
}</code></pre> 
  <p></p> 
 </div> 
</div> 
<div></div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b4a99409f87f113a00ab58e00382b82f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言：写一个函数求字符串长度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/467bef8832e6306c04404d42399e0473/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">加权平均算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>