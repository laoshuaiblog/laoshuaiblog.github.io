<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【零基础C语言】动态内存管理 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/b8a6cb72ba4ac4c77960dcc9169e4005/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【零基础C语言】动态内存管理">
  <meta property="og:description" content="目录
1.动态内存分配的意义
2. malloc 函数
3. free 函数
4.calloc 函数
5.realloc 函数
6.常见的动态内存错误
6.1 对NULL指针的解引⽤操作
6.2 对动态开辟空间的越界访问
6.3 对非动态开辟内存使⽤free释放
6.4 使⽤free释放⼀块动态开辟内存的⼀部分
6.5 对同⼀块动态内存多次释放
6.6 动态开辟内存忘记释放（内存泄漏）
7. 动态内存笔试题
8. 柔性数组
8.1 什么是柔性数组
8.2 柔性数组的特点
8.3 柔性数组的使用
1.动态内存分配的意义 在C语言中我们常常写到这样的代码
int arr[10] = { 0 }; int a = 10; 这样开辟空间的大小是固定的，并且数组一旦声明后，必须指定长度
这意味着数组的空间大小一旦确定就无法更改
为了解决这个问题，C语言中引入了动态内存管理，它可以让我们自由的分配和释放空间。
2. malloc 函数 头文件 - stdlib.h
作用：C语言中一个可以开辟动态内存的函数
函数原型：
void* malloc(size_t size);
size_t size - 需要开辟空间的大小
void* - 返回指向开辟空间的指针 开辟成功，返回指向开辟空间的指针 开辟失败，返回NULL指针">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-27T16:54:07+08:00">
    <meta property="article:modified_time" content="2024-03-27T16:54:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【零基础C语言】动态内存管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%84%8F%E4%B9%89-toc" style="margin-left:0px;"><a href="#1.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%84%8F%E4%B9%89" rel="nofollow">1.动态内存分配的意义</a></p> 
<p id="%C2%A02.%20malloc%20%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%C2%A02.%20malloc%20%E5%87%BD%E6%95%B0" rel="nofollow"> 2. malloc 函数</a></p> 
<p id="%C2%A03.%20free%20%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%C2%A03.%20free%20%E5%87%BD%E6%95%B0" rel="nofollow"> 3. free 函数</a></p> 
<p id="%C2%A04.calloc%20%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%C2%A04.calloc%20%E5%87%BD%E6%95%B0" rel="nofollow"> 4.calloc 函数</a></p> 
<p id="%C2%A05.realloc%20%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%C2%A05.realloc%20%E5%87%BD%E6%95%B0" rel="nofollow"> 5.realloc 函数</a></p> 
<p id="%C2%A06.%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF-toc" style="margin-left:0px;"><a href="#%C2%A06.%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF" rel="nofollow"> 6.常见的动态内存错误</a></p> 
<p id="%C2%A06.1%20%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E2%BD%A4%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%C2%A06.1%20%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E2%BD%A4%E6%93%8D%E4%BD%9C" rel="nofollow"> 6.1 对NULL指针的解引⽤操作</a></p> 
<p id="6.2%20%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#6.2%20%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE" rel="nofollow">6.2 对动态开辟空间的越界访问</a></p> 
<p id="6.3%20%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE-toc" style="margin-left:40px;"><a href="#6.3%20%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE" rel="nofollow">6.3 对非动态开辟内存使⽤free释放</a></p> 
<p id="%C2%A06.4%20%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E2%BC%80%E9%83%A8%E5%88%86-toc" style="margin-left:40px;"><a href="#%C2%A06.4%20%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E2%BC%80%E9%83%A8%E5%88%86" rel="nofollow"> 6.4 使⽤free释放⼀块动态开辟内存的⼀部分</a></p> 
<p id="%C2%A06.5%20%E5%AF%B9%E5%90%8C%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE-toc" style="margin-left:40px;"><a href="#%C2%A06.5%20%E5%AF%B9%E5%90%8C%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE" rel="nofollow"> 6.5 对同⼀块动态内存多次释放</a></p> 
<p id="6.6%20%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89-toc" style="margin-left:40px;"><a href="#6.6%20%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89" rel="nofollow">6.6 动态开辟内存忘记释放（内存泄漏）</a></p> 
<p id="7.%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AC%94%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#7.%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AC%94%E8%AF%95%E9%A2%98" rel="nofollow">7. 动态内存笔试题</a></p> 
<p id="%C2%A08.%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#%C2%A08.%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84" rel="nofollow"> 8. 柔性数组</a></p> 
<p id="%C2%A08.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#%C2%A08.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84" rel="nofollow"> 8.1 什么是柔性数组</a></p> 
<p id="8.2%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#8.2%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">8.2 柔性数组的特点</a></p> 
<p id="8.3%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#8.3%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">8.3 柔性数组的使用</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%84%8F%E4%B9%89"><span style="color:#ff9900;"><strong>1.动态内存分配的意义</strong></span></h2> 
<p><strong><span style="color:#0d0016;"> 在C语言中我们常常写到这样的代码</span></strong></p> 
<pre><code class="language-cpp">int arr[10] = { 0 };
int a = 10;</code></pre> 
<p><span style="color:#1c7331;"><strong>这样开辟空间的大小是固定的，并且数组一旦声明后，必须指定长度<br> 这意味着数组的空间大小一旦确定就无法更改</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>为了解决这个问题，C语言中引入了动态内存管理，它可以让我们自由的分配和释放空间。</strong></span></p> 
<h2 id="%C2%A02.%20malloc%20%E5%87%BD%E6%95%B0"><span style="color:#ff9900;"><strong> 2. malloc 函数</strong></span></h2> 
<p><span style="color:#a2e043;"><strong>头文件 - stdlib.h<br> 作用：C语言中一个可以开辟动态内存的函数</strong></span></p> 
<p><span style="color:#a2e043;"><strong>函数原型：<br> void* malloc(size_t size);</strong></span></p> 
<p><span style="color:#a2e043;"><strong>size_t size - 需要开辟空间的大小<br> void*       - 返回指向开辟空间的指针 </strong></span></p> 
<p><span style="color:#a2e043;"><strong>开辟成功，返回指向开辟空间的指针 <br> 开辟失败，返回NULL指针</strong></span></p> 
<h2 id="%C2%A03.%20free%20%E5%87%BD%E6%95%B0"><span style="color:#ff9900;"><strong> 3. free 函数</strong></span></h2> 
<p><span style="color:#a2e043;"><strong> 头文件 - stdlib.h<br>  作用：专门用来给动态内存释放和回收的</strong></span></p> 
<p><span style="color:#a2e043;"><strong> 函数原型：<br>  void free (void* ptr);</strong></span></p> 
<p><span style="color:#a2e043;"><strong> void* ptr - 传入指向需要释放的动态空间的指针</strong></span></p> 
<p><span style="color:#a2e043;"><strong> 如果参数 ptr 指向的空间不是动态开辟的，那free函数的⾏为是未定义的。<br>  如果参数 ptr 是NULL指针，则函数什么事都不做。</strong></span></p> 
<p> <span style="color:#9c8ec1;"><strong>使用：</strong></span></p> 
<pre><code class="language-cpp">#include &lt;stdlib.h&gt;
int main()
{
	int num = 0;
	scanf("%d", &amp;num);
	int arr[num] = { 0 };
	int* ptr = (int*)malloc(num * sizeof(int));
	if (NULL != ptr)
	{
		int i = 0;
		for (i = 0; i &lt; num; i++)
		{
			*(ptr + i) = 0;
		}
	}
	free(ptr);
	ptr = NULL;
	return 0;
}
int main()
{
	int arr[5] = { 0 };
	int* ptr = (int*)malloc(5 * sizeof(int));
	if (NULL != ptr)
	{
		int i = 0;
		for (i = 0; i &lt; 5; i++)
		{
			*(ptr + i) = i + 1;
		}

		for (int j = 0; j &lt; 5; j++)
		{
			printf("%d ", arr[j]);
		}
	}
	free(ptr);
	ptr = NULL;
	return 0;
}</code></pre> 
<h2 id="%C2%A04.calloc%20%E5%87%BD%E6%95%B0"><span style="color:#ff9900;"><strong> 4.calloc 函数</strong></span></h2> 
<p><span style="color:#a2e043;"><strong> 头文件 - stdlib.h<br>  作用：初始化并且开辟空间</strong></span></p> 
<p><span style="color:#a2e043;"><strong> 函数原型：<br>  void* calloc (size_t num, size_t size);</strong></span></p> 
<p><span style="color:#a2e043;"><strong> size_t num - 要分配的元素个数<br>  size_t size - 要分配的元素大小</strong></span></p> 
<pre><code class="language-cpp">int main()
{
	int* p = (int*)calloc(10, sizeof(int));
	if (NULL != p)
	{
		int i = 0;
		for (i = 0; i &lt; 10; i++)
		{
			printf("%d ", *(p + i));
		}
	}
	
	free(p);
	p = NULL;
	return 0;
}</code></pre> 
<h2 id="%C2%A05.realloc%20%E5%87%BD%E6%95%B0"><span style="color:#ff9900;"><strong> 5.realloc 函数</strong></span></h2> 
<p> <span style="color:#a2e043;"><strong>头文件 - stdlib.h<br> 作用：realloc 函数就可以做到对动态开辟内存⼤⼩的调整。</strong></span></p> 
<p><span style="color:#a2e043;"><strong> 函数原型<br>  void* realloc(void* ptr, size_t size);</strong></span></p> 
<p><span style="color:#a2e043;"><strong> void* ptr - 指向需要调整的地址<br>  size_t size - 调整后的大小<br> 返回值为调整之后的内存起始位置。<br>  这个函数调整原内存空间⼤⼩的基础上，还会将原来内存中的数据移动到新的空间。<br>  realloc在调整内存空间的是存在两种情况：<br> 情况1：原有空间之后有⾜够⼤的空间<br> 情况2：原有空间之后没有⾜够⼤的空间</strong></span></p> 
<p><span style="color:#ffd900;"><strong>情况1<br> 当是情况1的时候，要扩展内存就直接原有内存之后直接追加空间，原来空间的数据不发⽣变化。<br> 情况2<br> 当是情况2的时候，原有空间之后没有⾜够多的空间时，扩展的⽅法是：在堆空间上另找⼀个合适⼤⼩的连续空间来使⽤。这样函数返回的是⼀个新的内存地址</strong></span></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
	int* ptr = (int*)malloc(100);
	if (NULL != ptr)
	{
		// .....
	}
	else
	{
		return 1;
	}

	//扩容
	int* p = realloc(ptr, 1000);
	if (NULL != p)
	{
		ptr = p;
	}

	free(ptr);
	ptr = NULL;
	p = NULL;
	return 0;
}</code></pre> 
<h2 id="%C2%A06.%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF"><span style="color:#ff9900;"><strong> 6.常见的动态内存错误</strong></span></h2> 
<h3 id="%C2%A06.1%20%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E2%BD%A4%E6%93%8D%E4%BD%9C"><span style="color:#be191c;"><strong> 6.1 对NULL指针的解引⽤操作</strong></span></h3> 
<pre><code class="language-cpp">void test()
{
	int* p = (int*)malloc(INT_MAX / 4);
	*p = 20;//如果p的值是NULL，就会有问题
	free(p);
}</code></pre> 
<h3 id="6.2%20%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE"><span style="color:#be191c;"><strong>6.2 对动态开辟空间的越界访问</strong></span></h3> 
<pre><code class="language-cpp">void test()
{
	int i = 0;
	int* p = (int*)malloc(10 * sizeof(int));
	if (NULL == p)
	{
		exit(EXIT_FAILURE);
	}
	for (i = 0; i &lt;= 10; i++)
	{
		*(p + i) = i;//当i是10的时候越界访问
	}
	free(p);
	p = NULL;
}</code></pre> 
<h3 id="6.3%20%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE"><span style="color:#be191c;"><strong>6.3 对非动态开辟内存使⽤free释放</strong></span></h3> 
<pre><code class="language-cpp">void test()
{
	int a = 10;
	int* p = &amp;a;
	free(p);
}</code></pre> 
<h3 id="%C2%A06.4%20%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E2%BC%80%E9%83%A8%E5%88%86"><span style="color:#be191c;"><strong> 6.4 使⽤free释放⼀块动态开辟内存的⼀部分</strong></span></h3> 
<pre><code class="language-cpp">void test()
{
	int* p = (int*)malloc(100);
	p++;
	free(p);//p不再指向动态内存的起始位置
}
</code></pre> 
<h3 id="%C2%A06.5%20%E5%AF%B9%E5%90%8C%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE"><span style="color:#be191c;"><strong> 6.5 对同⼀块动态内存多次释放</strong></span></h3> 
<pre><code class="language-cpp">void test()
{
	int* p = (int*)malloc(100);
	free(p);
	free(p);//重复释放
}</code></pre> 
<h3 id="6.6%20%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89"><span style="color:#be191c;"><strong>6.6 动态开辟内存忘记释放（内存泄漏）</strong></span></h3> 
<pre><code class="language-cpp">void test()
{
	int* p = (int*)malloc(100);
	if (NULL != p)
	{
		*p = 20;
}
}
int main()
{
	test();
	while (1);
}</code></pre> 
<h2 id="7.%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AC%94%E8%AF%95%E9%A2%98"><span style="color:#ff9900;">7. 动态内存笔试题</span></h2> 
<pre><code class="language-cpp">// 题⽬1：

void GetMemory(char* p) 
{
	p = (char*)malloc(100); // p 将会在出GetMemory后销毁，生命周期结束
}
void Test(void)
{
	char* str = NULL;
	GetMemory(str); // 传值调用，无法对str进行修改，str还是指向NULL
	strcpy(str, "hello world");
	printf(str);
}

int main()
{
	GetMemory();
	return 0;
}


//题⽬2：
char* GetMemory(void)
{
	char p[] = "hello world";
	return p; // p是一个指针，指向p[]的首元素地址，但是p[]在出了函数会销毁
}
void Test(void)
{
	char* str = NULL;
	str = GetMemory(); // str 接受的 p指针是一个野指针
	printf(str);
}


//题⽬3：
void GetMemory(char** p, int num) //char** - 接收 char*
{
	*p = (char*)malloc(num);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(&amp;str, 100); // 传址调用
	strcpy(str, "hello"); //整个代码逻辑没有问题，缺点是会出现内存泄漏，需要补上
	printf(str);

	//补上：
	free(str);
	str = NULL;
}

//题⽬4：
void Test(void)
{
	char* str = (char*)malloc(100);
	strcpy(str, "hello");
	free(str); // 这里释放str，后面的调用就失效了
	if (str != NULL)
	{
		strcpy(str, "world");
		printf(str);
	}
}</code></pre> 
<h2 id="%C2%A08.%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84"><span style="color:#ff9900;"><strong> 8. 柔性数组</strong></span></h2> 
<h3 id="%C2%A08.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84"><span style="color:#be191c;"><strong> 8.1 什么是柔性数组</strong></span></h3> 
<pre><code class="language-cpp">typedef struct S
{
	int i;
	int a[0];// 柔性数组
}s;
// 柔性数组 - 指的就是结构体中最后一个成员是未知大小的数组</code></pre> 
<h3 id="8.2%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span style="color:#be191c;"><strong>8.2 柔性数组的特点</strong></span></h3> 
<p><span style="color:#0d0016;"><strong> 1.结构中的柔性数组成员前⾯必须⾄少⼀个其他成员。<br> 2.sizeof返回的这种结构⼤⼩不包括柔性数组的内存。<br> 3.包含柔性数组成员的结构⽤malloc()函数进⾏内存的动态分配，并且分配的内存应该⼤于结构的⼤⼩，以适应柔性数组的预期⼤⼩。</strong></span></p> 
<pre><code class="language-cpp">typedef struct S
{
	int i;
	int a[0];// 柔性数组
}s;

int main()
{
	printf("%zd\n", sizeof(s));
	return 0;
}</code></pre> 
<h3 id="8.3%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span style="color:#be191c;"><strong>8.3 柔性数组的使用</strong></span></h3> 
<pre><code class="language-cpp">typedef struct S
{
	int i;
	int a[0];// 柔性数组
}s;

int main()
{
	int i = 0;
	s* p = (s*)malloc(sizeof(s) + 100 * sizeof(int));

	p-&gt;i = 100;
	for (i = 0; i &lt; 100; i++)
	{
		p-&gt;a[i] = i;
	}
	free(p);
	p = NULL;
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3dbca272156a4712b0e2626e867368d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ES6-模块化介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/efa8a46ad27961862ad3c2c1932bc2ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">k8s入门到实战（十一）—— DaemonSet详细介绍及使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>