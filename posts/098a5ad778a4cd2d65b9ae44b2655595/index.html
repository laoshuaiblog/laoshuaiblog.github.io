<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis中RDB操作 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/098a5ad778a4cd2d65b9ae44b2655595/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Redis中RDB操作">
  <meta property="og:description" content="概念 RDB=RedisDateBase,Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一但服务器进程退出，服务器中的数据库状态也会消失。所以需要用到持久化功能！RDB持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当Redis重新启动时，可以读取快照文件恢复数据。RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。一般Redis默认启动RDB 具体原理 Redis单独创建（fork）一个子进程进行持久化，会先将数据写入到一个临时的文件中，待持久化过程都结束了，在用这个临时文件替换上次持久化好的文件。整个过程中，主进程食不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，拿RDB方式要比AOF方式更加高效。RDB的缺点是最后一次持久化后的数据可能会丢失。
RDB配置详解： 在配置文件redis.conf全局搜索SNAPSHOTTING
RDB配置 1.通过搜索SNAPSHOTTING找到配置，并且配置触发条件
那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行
服务器在900秒之内，对数据库进行了至少1次修改
服务器在300秒之内，对数据库进行了至少10次修改　服务器在60秒之内，对数据库进行了至少10000次修改。
我这里配置了60秒之内，对数据库进行了至少5次修改就触发RDB。其他的被我注掉了。
2.开启保存出错停止写入功能（默认开启）
如果RDB快照持久化操作被激活（至少一个条件被激活）并且持久化操作失败，Redis则会停止接受更新操作。
3.数据压缩（默认开启）
4.RDB文件校验（默认开启）
这会让格式更加耐攻击，但是当存储或者加载rbd文件的时候会有一个10%左右的性能下降
指定本地数据库文件名，一般采用默认的 dump.rdb
6.rdb文件是否删除同步锁（默认不开启）。
生成文件的工作目录
################################ 快照 ################################# # Save the DB on disk:保存数据库到磁盘 # save &amp;lt;秒&amp;gt; &amp;lt;更新&amp;gt; # 如果指定的秒数和数据库写操作次数都满足了就将数据库保存。 # 下面是保存操作的实例： # 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） # 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） # 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化） # 注释：注释掉“save”这一行配置项就可以让保存数据库功能失效。 # 你也可以通过增加一个只有一个空字符串的配置项（如下面的实例）来去掉前面的“save”配置。 # save &#34;&#34; save 900 1 save 300 10 save 60 10000 #在默认情况下，如果RDB快照持久化操作被激活（至少一个条件被激活）并且持久化操作失败，Redis则会停止接受更新操作。 #这样会让用户了解到数据没有被正确的存储到磁盘上。否则没人会注意到这个问题，可能会造成灾难。 #如果后台存储（持久化）操作进程再次工作，Redis会自动允许更新操作。 #然而，如果你已经恰当的配置了对Redis服务器的监视和备份，你也许想关掉这项功能。 #如此一来即使后台保存操作出错,redis也仍然可以继续像平常一样工作。 stop-writes-on-bgsave-error yes #是否在导出.rdb数据库文件的时候采用LZF压缩字符串和对象？ #默认情况下总是设置成‘yes’， 他看起来是一把双刃剑。 #如果你想在存储的子进程中节省一些CPU就设置成&#39;no&#39;， #但是这样如果你的kye/value是可压缩的，你的到处数据接就会很大。 rdbcompression yes #从版本RDB版本5开始，一个CRC64的校验就被放在了文件末尾。 #这会让格式更加耐攻击，但是当存储或者加载rbd文件的时候会有一个10%左右的性能下降， #所以，为了达到性能的最大化，你可以关掉这个配置项。 #没有校验的RDB文件会有一个0校验位，来告诉加载代码跳过校验检查。 rdbchecksum yes # 导出数据库的文件名称 dbfilename dump.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-04-27T00:33:46+08:00">
    <meta property="article:modified_time" content="2021-04-27T00:33:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis中RDB操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <h3><a id="_0"></a>概念</h3> 
</blockquote> 
<blockquote> 
 <ul><li>RDB=RedisDateBase,Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一但服务器进程退出，服务器中的数据库状态也会消失。所以需要用到持久化功能！</li><li>RDB持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当Redis重新启动时，可以读取快照文件恢复数据。</li><li>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</li><li>一般Redis默认启动RDB</li></ul> 
</blockquote> 
<blockquote> 
 <h3><a id="_7"></a>具体原理</h3> 
</blockquote> 
<p><img src="https://images2.imgbox.com/cf/ae/zgHRZ4ko_o.png" alt="在这里插入图片描述"><br> Redis单独创建（fork）一个子进程进行持久化，会先将数据写入到一个临时的文件中，待持久化过程都结束了，在用这个临时文件替换上次持久化好的文件。整个过程中，主进程食不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，拿RDB方式要比AOF方式更加高效。RDB的缺点是最后一次持久化后的数据可能会丢失。</p> 
<blockquote> 
 <h3><a id="RDB_12"></a>RDB配置详解：</h3> 
</blockquote> 
<p>在配置文件redis.conf全局搜索SNAPSHOTTING</p> 
<p><img src="https://images2.imgbox.com/a0/ce/JtAnnSZL_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <h3><a id="RDB_18"></a>RDB配置</h3> 
</blockquote> 
<p>1.通过搜索SNAPSHOTTING找到配置，并且配置触发条件<br> <img src="https://images2.imgbox.com/a8/4b/qGLLTdQK_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行<br> 服务器在900秒之内，对数据库进行了至少1次修改<br> 服务器在300秒之内，对数据库进行了至少10次修改　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<br> 服务器在60秒之内，对数据库进行了至少10000次修改。<br> 我这里配置了60秒之内，对数据库进行了至少5次修改就触发RDB。其他的被我注掉了。</p> 
</blockquote> 
<p>2.开启保存出错停止写入功能（默认开启）<br> <img src="https://images2.imgbox.com/ab/be/O3dM9SGL_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>如果RDB快照持久化操作被激活（至少一个条件被激活）并且持久化操作失败，Redis则会停止接受更新操作。</p> 
</blockquote> 
<p>3.数据压缩（默认开启）<br> <img src="https://images2.imgbox.com/71/25/7E2AE9wt_o.png" alt="在这里插入图片描述"><br> 4.RDB文件校验（默认开启）</p> 
<p><img src="https://images2.imgbox.com/5d/f9/JrXat7HA_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这会让格式更加耐攻击，但是当存储或者加载rbd文件的时候会有一个10%左右的性能下降</p> 
</blockquote> 
<ol start="5"><li>指定本地数据库文件名，一般采用默认的 dump.rdb<br> <img src="https://images2.imgbox.com/d0/cf/JS2nIdAB_o.png" alt="在这里插入图片描述"><br> 6.rdb文件是否删除同步锁（默认不开启）。<br> <img src="https://images2.imgbox.com/cc/f9/TCB3kJ4r_o.png" alt="在这里插入图片描述"></li><li>生成文件的工作目录<br> <img src="https://images2.imgbox.com/a4/20/VbsECiBT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/76/77/RD2UeYYT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0f/6f/VmyD5QZS_o.png" alt="在这里插入图片描述"></li></ol> 
<pre><code class="prism language-java">################################ 快照  #################################  
# Save the DB on disk<span class="token operator">:</span>保存数据库到磁盘  
#   save <span class="token operator">&lt;</span>秒<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>更新<span class="token operator">&gt;</span>   
#   如果指定的秒数和数据库写操作次数都满足了就将数据库保存。  
#   下面是保存操作的实例：  
#   <span class="token number">900</span>秒（<span class="token number">15</span>分钟）内至少<span class="token number">1</span>个key值改变（则进行数据库保存<span class="token operator">--</span>持久化）  
#   <span class="token number">300</span>秒（<span class="token number">5</span>分钟）内至少<span class="token number">10</span>个key值改变（则进行数据库保存<span class="token operator">--</span>持久化）  
#   <span class="token number">60</span>秒（<span class="token number">1</span>分钟）内至少<span class="token number">10000</span>个key值改变（则进行数据库保存<span class="token operator">--</span>持久化）    
#   注释：注释掉“save”这一行配置项就可以让保存数据库功能失效。   
#   你也可以通过增加一个只有一个空字符串的配置项（如下面的实例）来去掉前面的“save”配置。  
#   save <span class="token string">""</span>  
  
save <span class="token number">900</span> <span class="token number">1</span>  
save <span class="token number">300</span> <span class="token number">10</span>  
save <span class="token number">60</span> <span class="token number">10000</span>  
  
#在默认情况下，如果RDB快照持久化操作被激活（至少一个条件被激活）并且持久化操作失败，Redis则会停止接受更新操作。  
#这样会让用户了解到数据没有被正确的存储到磁盘上。否则没人会注意到这个问题，可能会造成灾难。  
#如果后台存储（持久化）操作进程再次工作，Redis会自动允许更新操作。  
#然而，如果你已经恰当的配置了对Redis服务器的监视和备份，你也许想关掉这项功能。  
#如此一来即使后台保存操作出错<span class="token punctuation">,</span>redis也仍然可以继续像平常一样工作。  
stop<span class="token operator">-</span>writes<span class="token operator">-</span>on<span class="token operator">-</span>bgsave<span class="token operator">-</span>error yes  
  
#是否在导出<span class="token punctuation">.</span>rdb数据库文件的时候采用LZF压缩字符串和对象？  
#默认情况下总是设置成‘yes’， 他看起来是一把双刃剑。  
#如果你想在存储的子进程中节省一些CPU就设置成<span class="token string">'no'</span>，  
#但是这样如果你的kye<span class="token operator">/</span>value是可压缩的，你的到处数据接就会很大。  
rdbcompression yes  
  
#从版本RDB版本<span class="token number">5</span>开始，一个CRC64的校验就被放在了文件末尾。  
#这会让格式更加耐攻击，但是当存储或者加载rbd文件的时候会有一个<span class="token number">10</span><span class="token operator">%</span>左右的性能下降，  
#所以，为了达到性能的最大化，你可以关掉这个配置项。   
#没有校验的RDB文件会有一个<span class="token number">0</span>校验位，来告诉加载代码跳过校验检查。  
rdbchecksum yes  
  
# 导出数据库的文件名称  
dbfilename dump<span class="token punctuation">.</span>rdb  

#rdb文件是否删除同步锁
rdb<span class="token operator">-</span>del<span class="token operator">-</span>sync<span class="token operator">-</span>files no
  
# 工作目录  
# 导出的数据库会被写入这个目录，文件名就是上面<span class="token string">'dbfilename'</span>配置项指定的文件名。   
# 新增的文件也会在这个目录创建    
# 注意你一定要在这个配置一个工作目录，而不是文件名称。  
dir <span class="token punctuation">.</span>/  

</code></pre> 
<blockquote> 
 <h3><a id="RDB_104"></a>测试RDB机制：</h3> 
</blockquote> 
<p>1.登录客户端查看RDB文件生成目录</p> 
<pre><code class="prism language-java">config get dir
</code></pre> 
<p><img src="https://images2.imgbox.com/a4/83/5qxFDefN_o.png" alt="在这里插入图片描述"></p> 
<p>2.删除原来的RDB文件</p> 
<pre><code class="prism language-java">rm <span class="token operator">-</span>rf dump<span class="token punctuation">.</span>rdb 
</code></pre> 
<p><img src="https://images2.imgbox.com/2b/d8/ogBwGOWC_o.png" alt="在这里插入图片描述"><br> 3.登录客户端，设置五个值<br> <img src="https://images2.imgbox.com/f0/ac/DMCuv4Iz_o.png" alt="在这里插入图片描述"><br> 4.查看生成目录（60秒内新增5个key，所以生成了dump.rdb文件）<br> <img src="https://images2.imgbox.com/37/10/QmInEfif_o.png" alt="在这里插入图片描述"><br> 5.结束redis的进程（如果没有RDB，数据应该会丢失）<br> <img src="https://images2.imgbox.com/21/be/ghgtq6Gn_o.png" alt="在这里插入图片描述"><br> 确认进程已经结束</p> 
<pre><code class="prism language-java">ps <span class="token operator">-</span>ef<span class="token operator">|</span>grep redis
</code></pre> 
<p><img src="https://images2.imgbox.com/f5/38/ph3RCjo8_o.png" alt="在这里插入图片描述"><br> 6.重新开启redis服务</p> 
<pre><code class="prism language-java"><span class="token punctuation">.</span>/bin<span class="token operator">/</span>redis<span class="token operator">-</span>server <span class="token punctuation">.</span>/redis<span class="token punctuation">.</span>conf
</code></pre> 
<p><img src="https://images2.imgbox.com/74/9d/mTuyMDjx_o.png" alt="在这里插入图片描述"><br> 7.重新启动客户端，获取k1的值，发现可以获取到，证明持久化起到作用了。<br> <img src="https://images2.imgbox.com/01/64/KaaPfC57_o.png" alt="在这里插入图片描述"><br> 8.再测试下，直接清空数据库，看是否也会触发持久化<br> <img src="https://images2.imgbox.com/cf/b9/ZGwAsAAj_o.png" alt="在这里插入图片描述"><br> 在客户端执行flushall<br> <img src="https://images2.imgbox.com/9e/6c/fZgfufTh_o.png" alt="在这里插入图片描述"><br> 发现也生成了rdb文件<br> <img src="https://images2.imgbox.com/46/28/eolVFOcm_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <h3><a id="_150"></a>总结：</h3> 
</blockquote> 
<p>1.save规制满足情况下，会自动触发rdb规则，生成文件<br> 2.执行flushall命令，也会触发rdb规则，生成文件<br> 3.退出redis，也会触发rdb规则，生成文件<br> 4.重启redis的时候，会自动读取dir目录下的rdb文件，自行恢复数据</p> 
<p>优点：<br> 1、适合大规模数据恢复<br> 2、对数据完整性要求不高<br> 缺点：<br> 1、需要一定时间间隔进行操作,如果redis意外宕机了，最后一次修改数据就没有了！<br> 2、备份时占用内存，因为Redis 在备份时会独立创建一个fork进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。<br> 所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7bfcae220a0e4a5f45daaded982f5b3a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">es6学习：模块化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5e5c9ef39aa0def2238a270a6639c73/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AHK脚本-碎片解决问题记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>