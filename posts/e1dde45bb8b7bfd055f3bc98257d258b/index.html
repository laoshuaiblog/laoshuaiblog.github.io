<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-＞手把手教入门栈与列队（基础） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/e1dde45bb8b7bfd055f3bc98257d258b/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="数据结构-＞手把手教入门栈与列队（基础）">
  <meta property="og:description" content="✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉
🍎个人主页：橘橙黄又青-CSDN博客
1.什么是栈 1.1栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除 操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out） 的原则。 压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 出栈：栈的删除操作叫做出栈。出数据也在栈顶。
这种结构类似于弹夹：遵守后进先出的原则
1.2栈的实现 栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上 插入数据的代价比较小。
2.栈的实现 这里我们讲解数组（顺序表）实现
2.1栈的初始化和销毁 这里顺序表一样，a是数组，free是释放一块连续的空间。
2.2栈的节点创建 这里注意的是创建后，记得top&#43;&#43;；
2.3出栈和返回栈顶元素 2.4返回栈的数据个数和判断栈为空 2.5测试代码： 这里我们讲一个点，我们只创建一个栈Stack s，如果要创建两个栈，最好使用结构体包装起来，比如说：
这样就可以直接创建两个顺序表了。
3.什么是列队 3.1队列的概念及结构 列队列队其实可以理解为排队
队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先 进先出FIFO(First In First Out) 入队列：进行插入操作的一端称为队尾 出队列：进行删除操作的一 端称为队头。
4.列队的实现 队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构， 出队列在数组头上出数据，效率会比较低。
所以我们选择链表实现。
4.1列队初始化和销毁 4.2入队列 4.3出队列 出队列是链表的头删操作。
4.4找到列队头尾 4.5列队判断为空和数据个数 5.代码 5.1列队代码： Queue.h
#pragma once #include&amp;lt;stdlib.h&amp;gt; #include&amp;lt;stdbool.h&amp;gt; #include&amp;lt;assert.h&amp;gt; typedef int QDataType; typedef struct QueueNode { int val; struct QueueNode* next; }QNode; 入队列 //void QueuePush(QNode** pphead, QNode** pptail); 出队列 //void QueuePop(QNode** pphead, QNode** pptail); typedef struct Queue { QNode* phead; QNode* ptail; int size; }Queue; //初始化 void QueueInit(Queue* pq); //列队销毁 void QueueDestroy(Queue* pq); // 入队列 void QueuePush(Queue* pq, QDataType x); // 出队列 void QueuePop(Queue* pq); //列队前 QDataType QueueFront(Queue* pq); //列队尾 QDataType QueueBack(Queue* pq); //判断是否为空 bool QueueEmpty(Queue* pq); //数据个数 int QueueSize(Queue* pq); Queue.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-23T20:45:34+08:00">
    <meta property="article:modified_time" content="2024-03-23T20:45:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-＞手把手教入门栈与列队（基础）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1200" src="https://images2.imgbox.com/dc/f2/IXESi1VJ_o.png" width="1200"></p> 
<p>✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉</p> 
<p>🍎个人主页：<a href="https://blog.csdn.net/chendemingxxx?spm=1011.2266.3001.5343" title="橘橙黄又青-CSDN博客">橘橙黄又青-CSDN博客</a></p> 
<h2>1.什么是栈</h2> 
<h3>1.1栈的概念及结构</h3> 
<p><strong>栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除 操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守<span style="color:#fe2c24;">后进先出</span>LIFO（Last In First Out） 的原则。 </strong></p> 
<p><strong>压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 </strong></p> 
<p><strong>出栈：栈的删除操作叫做出栈。出数据也在栈顶。</strong></p> 
<p><strong>这种结构类似于弹夹：遵守<span style="color:#fe2c24;">后进先出</span><span style="color:#0d0016;">的原则</span></strong></p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/ca/83/rjzGJ38X_o.png" width="348"></p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/95/90/r3S0rKht_o.png" width="300"><img alt="" height="229" src="https://images2.imgbox.com/df/44/MT2a73gE_o.png" width="357"></p> 
<h3> 1.2栈的实现</h3> 
<p>栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上 插入数据的代价比较小。</p> 
<p></p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/89/ee/qbhZW4JK_o.png" width="1200"> </p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/6f/39/UFEWV8ot_o.png" width="1029"></p> 
<p><img alt="" height="340" src="https://images2.imgbox.com/b0/8d/ZMN9S6gn_o.png" width="841"></p> 
<h2 style="background-color:transparent;">2.栈的实现</h2> 
<p>这里我们讲解数组（顺序表）实现</p> 
<h3>2.1栈的初始化和销毁</h3> 
<p><img alt="" height="573" src="https://images2.imgbox.com/96/03/o8zVy5Tf_o.png" width="579"></p> 
<p>这里顺序表一样，a是数组，free是释放一块连续的空间。</p> 
<h3>2.2栈的节点创建</h3> 
<p><img alt="" height="703" src="https://images2.imgbox.com/53/10/KG9DqNQq_o.png" width="1200"></p> 
<p>这里注意的是创建后，记得top++；</p> 
<h3>2.3出栈和返回栈顶元素</h3> 
<p><img alt="" height="498" src="https://images2.imgbox.com/be/c5/9cDYcNCl_o.png" width="708"></p> 
<h3>2.4返回栈的数据个数和判断栈为空</h3> 
<p><img alt="" height="473" src="https://images2.imgbox.com/24/38/xpRcvc8Y_o.png" width="575"></p> 
<h3>2.5测试代码：</h3> 
<p><img alt="" height="1046" src="https://images2.imgbox.com/16/56/5ZjsViIJ_o.png" width="568"></p> 
<p></p> 
<p>这里我们讲一个点，我们只创建一个栈Stack s，如果要创建两个栈，最好使用结构体包装起来，比如说：</p> 
<p><img alt="" height="209" src="https://images2.imgbox.com/f4/ee/SiBHtxBJ_o.png" width="622"></p> 
<p>这样就可以直接创建两个顺序表了。</p> 
<h2>3.什么是列队</h2> 
<h3 style="background-color:transparent;">3.1队列的概念及结构</h3> 
<p>列队列队其实可以理解为排队</p> 
<p>队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，<span style="color:#fe2c24;"><strong>队列具有先 进先出</strong></span>FIFO(First In First Out) 入队列：进行插入操作的一端称为队尾 出队列：进行删除操作的一 端称为队头。</p> 
<p><img alt="" height="344" src="https://images2.imgbox.com/75/14/XQHjKlJl_o.png" width="1200"></p> 
<h2 style="background-color:transparent;">4.列队的实现</h2> 
<p>队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构， 出队列在数组头上出数据，效率会比较低。</p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/c3/97/q56glN3Q_o.png" width="1200"></p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/2b/11/U7M9v2xM_o.png" width="1200"></p> 
<p>所以我们选择链表实现。</p> 
<h3>4.1列队初始化和销毁</h3> 
<p><img alt="" height="835" src="https://images2.imgbox.com/8e/c0/Is1f9mtB_o.png" width="900"></p> 
<h3>4.2入队列</h3> 
<p><img alt="" height="833" src="https://images2.imgbox.com/11/59/QCcR0AZf_o.png" width="768"></p> 
<h3>4.3出队列</h3> 
<p><img alt="" height="933" src="https://images2.imgbox.com/61/82/h3HSHMxN_o.png" width="806"> 出队列是链表的头删操作。</p> 
<h3>4.4找到列队头尾</h3> 
<p><img alt="" height="649" src="https://images2.imgbox.com/bc/cc/1Dw76An6_o.png" width="654"></p> 
<h3>4.5列队判断为空和数据个数</h3> 
<p><img alt="" height="457" src="https://images2.imgbox.com/7f/81/0Y2731ez_o.png" width="527"> </p> 
<h2>5.代码</h2> 
<h3 style="background-color:transparent;">5.1列队代码：</h3> 
<p>Queue.h</p> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;


typedef int QDataType;
typedef struct QueueNode
{
	int val;
	struct QueueNode* next;
}QNode;

 入队列
//void QueuePush(QNode** pphead, QNode** pptail);

 出队列
//void QueuePop(QNode** pphead, QNode** pptail);

typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;
//初始化
void QueueInit(Queue* pq);
//列队销毁
void QueueDestroy(Queue* pq);

// 入队列
void QueuePush(Queue* pq, QDataType x);
// 出队列
void QueuePop(Queue* pq);
//列队前
QDataType QueueFront(Queue* pq);
//列队尾
QDataType QueueBack(Queue* pq);
//判断是否为空
bool QueueEmpty(Queue* pq);
//数据个数
int QueueSize(Queue* pq);


</code></pre> 
<p>Queue.c</p> 
<pre><code class="language-cpp">#include"Queue.h"
//初始化
void QueueInit(Queue* pq)
{
	assert(pq);

	pq-&gt;phead = NULL;
	pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}

void QueueDestroy(Queue* pq)
{
	assert(pq);

	QNode* cur = pq-&gt;phead;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);

		cur = next;
	}

	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}

// 入队列
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}

	newnode-&gt;val = x;
	newnode-&gt;next = NULL;

	if (pq-&gt;ptail)
	{
		pq-&gt;ptail-&gt;next = newnode;
		pq-&gt;ptail = newnode;
	}
	else
	{
		pq-&gt;phead = pq-&gt;ptail = newnode;
	}

	pq-&gt;size++;
}

// 出队列
void QueuePop(Queue* pq)
{
	assert(pq);

	// 0个节点
	// 温柔检查
	//if (pq-&gt;phead == NULL)
	//	return;

	// 暴力检查 
	assert(pq-&gt;phead != NULL);

	// 一个节点
	// 多个节点
	if (pq-&gt;phead-&gt;next == NULL)
	{
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}
	else
	{
		QNode* next = pq-&gt;phead-&gt;next;
		free(pq-&gt;phead);
		pq-&gt;phead = next;
	}

	pq-&gt;size--;
}
//返回队列头
QDataType QueueFront(Queue* pq)
{
	assert(pq);

	// 暴力检查 
	assert(pq-&gt;phead != NULL);

	return pq-&gt;phead-&gt;val;
}
//返回队列尾
QDataType QueueBack(Queue* pq)
{
	assert(pq);

	// 暴力检查 
	assert(pq-&gt;ptail != NULL);

	return pq-&gt;ptail-&gt;val;
}

bool QueueEmpty(Queue* pq)
{
	assert(pq);

	return pq-&gt;size == 0;
}

int QueueSize(Queue* pq)
{
	assert(pq);

	return pq-&gt;size;
}
</code></pre> 
<p>Test.c</p> 
<pre><code class="language-cpp">//队列，链表实现
#include"Queue.h"

int main()
{
	Queue q;
	QueueInit(&amp;q);
	QueuePush(&amp;q, 1);
	QueuePush(&amp;q, 2);

	printf("%d ", QueueFront(&amp;q));
	QueuePop(&amp;q);

	QueuePush(&amp;q, 3);
	QueuePush(&amp;q, 4);

	while (!QueueEmpty(&amp;q))
	{
		printf("%d ", QueueFront(&amp;q));
		QueuePop(&amp;q);
	}

	QueueDestroy(&amp;q);

	return 0;
}</code></pre> 
<h3>5.1栈代码：</h3> 
<p>Stack.h</p> 
<pre><code class="language-cpp">#pragma once

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;

//方便以后改数据类型
typedef int STDataType;
//顺序表
typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}Stack;

//初始化
void STInit(Stack* ps);

//栈销毁
void STDestroy(Stack* ps);

//进栈
void STPush(Stack* ps, STDataType x);

//出栈
void STPop(Stack* ps);

//出栈顶元素
STDataType STTop(Stack* ps);

//链表数据个数
int STSize(Stack* ps);

//判断链表为不为空
bool STEmpty(Stack* ps);
</code></pre> 
<p>Stack.c</p> 
<pre><code class="language-cpp">#include"Stack.h"

void STInit(Stack* ps)
{
	assert(ps);

	ps-&gt;a = NULL;
	ps-&gt;top = 0;
	ps-&gt;capacity = 0;
}

void STDestroy(Stack* ps)
{
	assert(ps);

	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;top = ps-&gt;capacity = 0;
}


void STPush(Stack* ps, STDataType x)
{
	assert(ps);

	if (ps-&gt;top == ps-&gt;capacity)
	{
		int newcapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2;
		STDataType* tmp = (STDataType*)realloc(ps-&gt;a, newcapacity * sizeof(STDataType));
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}

		ps-&gt;a = tmp;
		ps-&gt;capacity = newcapacity;
	}

	ps-&gt;a[ps-&gt;top] = x;
	ps-&gt;top++;
}

void STPop(Stack* ps)
{
	assert(ps);
	assert(!STEmpty(ps));

	ps-&gt;top--;
}

STDataType STTop(Stack* ps)
{
	assert(ps);
	assert(!STEmpty(ps));

	return ps-&gt;a[ps-&gt;top - 1];
}

int STSize(Stack* ps)
{
	assert(ps);

	return ps-&gt;top;
}

bool STEmpty(Stack* ps)
{
	assert(ps);

	return ps-&gt;top == 0;
}</code></pre> 
<p>Test.c</p> 
<pre><code class="language-cpp">//栈，顺序表实现

#include"Stack.h"

int main()
{
	Stack s;
	STInit(&amp;s);
	STPush(&amp;s, 1);
	STPush(&amp;s, 2);
	STPush(&amp;s, 3);

	int top = STTop(&amp;s);
	printf("%d ", top);
	STPop(&amp;s);

	top = STTop(&amp;s);
	printf("%d ", top);
	STPop(&amp;s);

	STPush(&amp;s, 4);
	STPush(&amp;s, 5);

	while (!STEmpty(&amp;s))
	{
		int top = STTop(&amp;s);
		printf("%d ", top);
		STPop(&amp;s);
	}

	STDestroy(&amp;s);

	return 0;
}</code></pre> 
<p>今天的分享就到这里了，点个赞，谢谢。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/477cad924d8f5de0bd9c5163031d0a4a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">apache2.4设置完一个VirtualHost后，所有的域名和IP地址都变成访问这个VirtualHost的解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2f98545a8d195bf6296b27f5d1417c29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【力扣】409.最长回文串</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>