<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Can驱动芯片MCP2515如何实现位定时功能详解（使用的为8Mhz的晶振，波特率为什么不能达到1Mhz） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/4351baea916f3eaeb42a9f7f4a9fbaaa/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Can驱动芯片MCP2515如何实现位定时功能详解（使用的为8Mhz的晶振，波特率为什么不能达到1Mhz）">
  <meta property="og:description" content="在最近的一次项目中，使用到了SPI转CAN芯片MCP2515，此芯片通过SPI转CAN的接收与发送功能。初期看DataSheet时真是一脸懵逼，经过在网上看了一下教学视频，以及慢慢的研究最后才算搞清楚基本的用法以及理解里面各个寄存器的作用。 如果有同学不怎么会使用MCP2515却又不想看那么多页的DataSheet的，可以看以下的教学视频，你就可以了解大概怎么操作的。这个是众想科技出品的视频，里面有相关的MCP2515的驱动视频，您可查看http://www.zxkjmcu.com/。 我在百度传课也看过他们关于STM32部分的CAN视频。https://chuanke.baidu.com/v3322640-160883-676747.html
说了这么多，那就进入今天的主题吧！ 一下内容都是是针对MCP2515芯片的。
1.位定时 CAN总线上的所有节点都必须具有相同的标称比特率。CAN 协议采用不归零（ Non Return to Zero， NRZ）编码方式，在数据流中不对时钟信号进行编码。因此，接收时钟信号必须由接收节点恢复并与发送器的时钟同步。由于不同节点的振荡器频率和传输时间不同，接收器应具有某种能与数据传输边沿同步的锁相环（ Phase LockLoop， PLL）来同步时钟并保持这种同步。鉴于数据采用 NRZ 编码，有必要进行位填充以确保至少每 6 位时间发生一次边沿，使数字锁相环 （ Digital Phase LockLoop， DPLL）同步。MCP2515 通过 DPLL 实现位定时。 DPLL 被配置成同输入数据同步，并为发送数据提供标称定时。 DPLL 将每一 个 位 时 间 分 割 为 由 最 小 单 位 为 时 间 份 额 （ TimeQuanta， TQ）所组成的多个时间段。在位时间帧中执行的总线定时功能，例如与本地振荡器同步、网络传输延迟补偿和采样点定位等，都是由DPLL 的可编程位定时逻辑来规定的。 2. CAN 位时间 CAN 总线上的所有器件都必须使用相同的比特率。然而，并非所有器件都要求具有相同的主振荡器时钟频率。对于采用不同时钟频率的器件，应通过适当设置波特率预分频比以及每一时间段中的时间份额的数量来对比特率进行调整。CAN位时间由互不重叠的时间段组成。 每个时间段又由时间份额 （TQ）组成，在本数据手册的后面部分将对此进行解释。在 CAN 规范中，标称比特率 （NominalBit Rate， NBR）定义为在不需要再同步的情况下，理想发送器每秒发送的位数，它可用下面的公式来表示：
标称位时间： 标称位时间 （Nominal Bit Time， NBT）（ tbit）由互不重叠的段时间段组成（图-2） 。因此 NBT 为下列时间 段之和： 以上一个标称位时间，你可以理解为一个一定频率高电平或者一个低电平，它们里面分了如下几段，是为了能够精准的采样到总线上的数据，这个应该是硬件支持的，咱们不多做研究。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2018-08-23T20:27:08+08:00">
    <meta property="article:modified_time" content="2018-08-23T20:27:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Can驱动芯片MCP2515如何实现位定时功能详解（使用的为8Mhz的晶振，波特率为什么不能达到1Mhz）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在最近的一次项目中，使用到了SPI转CAN芯片MCP2515，此芯片通过SPI转CAN的接收与发送功能。初期看DataSheet时真是一脸懵逼，经过在网上看了一下教学视频，以及慢慢的研究最后才算搞清楚基本的用法以及理解里面各个寄存器的作用。 <br> 如果有同学不怎么会使用MCP2515却又不想看那么多页的DataSheet的，可以看以下的教学视频，你就可以了解大概怎么操作的。这个是众想科技出品的视频，里面有相关的MCP2515的驱动视频，您可查看<a href="http://www.zxkjmcu.com/" rel="nofollow">http://www.zxkjmcu.com/</a>。 <br> 我在百度传课也看过他们关于STM32部分的CAN视频。<a href="https://chuanke.baidu.com/v3322640-160883-676747.html" rel="nofollow">https://chuanke.baidu.com/v3322640-160883-676747.html</a></p> 
<p>说了这么多，那就进入今天的主题吧！ <br> 一下内容都是是针对MCP2515芯片的。</p> 
<p>1.位定时 <br> CAN总线上的所有节点都必须具有相同的标称比特率。CAN 协议采用不归零（ Non Return to Zero， NRZ）编码方式，在数据流中不对时钟信号进行编码。因此，接收时钟信号必须由接收节点恢复并与发送器的时钟同步。由于不同节点的振荡器频率和传输时间不同，接收器应具有某种能与数据传输边沿同步的锁相环（ Phase LockLoop， PLL）来同步时钟并保持这种同步。鉴于数据采用 NRZ 编码，有必要进行位填充以确保至少每 6 位时间发生一次边沿，使数字锁相环 （ Digital Phase LockLoop， DPLL）同步。MCP2515 通过 DPLL 实现位定时。 DPLL 被配置成同输入数据同步，并为发送数据提供标称定时。 DPLL 将每一 个 位 时 间 分 割 为 由 最 小 单 位 为 时 间 份 额 （ TimeQuanta， TQ）所组成的多个时间段。在位时间帧中执行的总线定时功能，例如与本地振荡器同步、网络传输延迟补偿和采样点定位等，都是由DPLL 的可编程位定时逻辑来规定的。 <br> 2. CAN 位时间 <br> CAN 总线上的所有器件都必须使用相同的比特率。然而，并非所有器件都要求具有相同的主振荡器时钟频率。对于采用不同时钟频率的器件，应通过适当设置波特率预分频比以及每一时间段中的时间份额的数量来对比特率进行调整。CAN位时间由互不重叠的时间段组成。 每个时间段又由时间份额 （TQ）组成，在本数据手册的后面部分将对此进行解释。在 CAN 规范中，标称比特率 （NominalBit Rate， NBR）定义为在不需要再同步的情况下，理想发送器每秒发送的位数，它可用下面的公式来表示：</p> 
<p><img src="https://images2.imgbox.com/6c/eb/cSeefqP3_o.png" alt="这里写图片描述" title=""></p> 
<p>标称位时间： <br> 标称位时间 （Nominal Bit Time， NBT）（ tbit）由互不重叠的段时间段组成（图-2） 。因此 NBT 为下列时间 <br> 段之和： <br> <img src="https://images2.imgbox.com/d5/e5/E134PfIe_o.png" alt="这里写图片描述" title=""></p> 
<p><img src="https://images2.imgbox.com/6a/94/JN7aEFEC_o.png" alt="这里写图片描述" title=""></p> 
<p>以上一个标称位时间，你可以理解为一个一定频率高电平或者一个低电平，它们里面分了如下几段，是为了能够精准的采样到总线上的数据，这个应该是硬件支持的，咱们不多做研究。</p> 
<p>同步段：同步段 （SyncSeg）为 NBT 中的首段，用于同步 CAN总线上的各个节点。输入信号的跳变沿就发生在同步段，该段持续时间为 1 TQ。 <br> 传播段：传播段 （ PropSeg）用于补偿各节点之间的物理传输延迟时间。传输延迟时间为信号在总线上传播时间的两倍，包括总线驱动器延迟时间。传播段的长度可编程设定为 1 – 8 TQ。</p> 
<p>相位缓冲段 1 （ PS1）和相位缓冲段 2 （ PS2）：两个相位缓冲段 PS1 和 PS2 用于补偿总线上的边沿相位误差。通过再同步，可以延长 PS1 （或缩短 PS2） 。PS1 可编程设定为 1 – 8 TQ， 而 PS2 可编程设定为 2 –8 TQ。</p> 
<p>采样点：采样点是位时间内的一个时间点。在该时间点，读取总线电平并进行分析。采样点位于相位缓冲段 PS1 的终点。但当采样模式设置为每位采样 3 次时例外。这种情况下，在 PS1 的终点仍然对某一位进行采样时，前两次的采样时间间隔为TQ/2,而该位的值将根据三个采样值中至少两次采样的相同值决定。</p> 
<p>信息处理时间：信息处理时间 （ IPT）是确定采样点的位电平值所需要的时间。 IPT 从采样点开始，以 TQ 计量， MicrochipCAN 模块将该时间长度定义为 2 TQ。 PS2 同样开始于采样点，且为位时间的最后一个时间段，因此 PS2 的最小值不能小于 IPT。 <br> PS2min = IPT =2TQ</p> 
<p>同步跳转宽度：同步跳转宽度（ SJW）可通过编程设定为 1 – 4 TQ，它可对位时钟进行必要的调整来保持与发送报文同步。 <br> 3.时间份额 <br> 组成位时间的每个段都由时间份额 （ TQ）组成。每个时间份额的长度取决于振荡器周期 （tOSC）。通常 TQ为两个振荡器周期。图 3显示了如何从 TOSC 和 TQ推导出位周期。 TQ 的长度等于一个 TQ 时钟周期（ tBRPCLK），利用称为波特率预分频器（ BRP）的可编程预分频器对它进行编程设置。以下公式对此进行了阐述： <br> <img src="https://images2.imgbox.com/f1/dd/Pj1aYdrc_o.png" alt="这里写图片描述" title=""> <br> 实际的计算按照寄存器里面BPR需要加1来计算。</p> 
<p><img src="https://images2.imgbox.com/b3/34/sEtkzK6O_o.png" alt="这里写图片描述" title=""> <br> 4. 同步 <br> 为补偿总线上各节点振荡器频率之间的相移， 每个 CAN控制器必须能够与输入信号的相关信号沿同步。同步过 <br> 程是实现 DPLL 功能的过程。当检测到发送数据中的跳变沿，逻辑电路将跳变沿的位置与所期望的时间段 （同步段）进行比较，随后电路将对相位缓冲段 PS1 和相位缓冲段 PS2 的值进行必要的调整。</p> 
<p>以上如果第一次看不懂也没关系，了解各个参数的函数即可，即了解一个标称位时间里面包含的各个段含义。 <br> 下面讲解对时间段的编程： <br> 对时间段的编程设定必须满足以下要求： <br> • 传播段 + 相位缓冲段 PS1 &gt;= 相位缓冲段 PS2 <br> • 传播段 + 相位缓冲段 PS1 &gt;= TDELAY <br> • 相位缓冲段 PS2 &gt; 同步跳转宽度 SJW <br> 例如，假设 FOSC = 20 MHz 时欲实现 125 kHz 的 CAN <br> 波特率： <br> TOSC = 50 ns， 选择 BRP&lt;5:0&gt; = 04h， 则 TQ = 500 ns。欲达到 125 kHz，位时间应为 16 TQ。位的采样时刻取决于系统参数，通常应发生在位时间的60-70% 处。同时， TDELAY 典型值为 1-2 TQ。同步段 = 1 TQ，传播段 = 2 TQ，这种情况下设置相位缓冲段 PS1 = 7 TQ，将会在跳变之后的 10 TQ 时进行采样。此时相位缓冲段 PS2 长度为 6 TQ。由于相位缓冲段 PS2 长度为 6 TQ，根据规则， SJW 最大值为 4 TQ。然而通常状况下，只有当不同节点的时钟发生不够精确或不稳定 （如采用陶瓷谐振器）时，才需要较大的 SJW。一般情况下， SJW 取值 1 TQ 即可满足要求。 <br> 咱来理一理以上的内容： <br> 首先晶振是20Mhz，那它的周期就为1/20MHz=50ns，如果BPR=4，则TQ=2*（4+1）*50ns=500ns，那要实现125kHz也就是周期等于8us的一个标称位，那么就需要16TQ=8us/500ns。这16TQ需要按照编程要求对它们进行分布，首先同步段得1TQ，位采样时间要位于位的60%-70%处，那么这样算下来，采样的点也就PS1与PS2交点，PS1按照60%算的话也得9.6，即同步段1TQ，传播段2TQ，相位缓冲段PS1为7TQ，剩下PS2就剩6TQ。这样算下来是比较合适的。比较符合以上的要求。 <br> 那如果假设 FOSC = 8 MHz 时欲实现 1M 的 CAN的波特率： <br> TOSC = 0.125us， 选择 BRP&lt;5:0&gt; = 04h， 则 TQ =1.25us。欲达到 1MHz，位时间应为不到1 TQ。 <br> 晶振为8MHz，周期就为0.125us，如果BPR为4的话，则TQ=2*（4+1）*0.125us=1.25us，那要实现1Mhz的也就是周期为1us的标称位，只有不到1TQ的为时间，显然不可行。即使BPR为0，TQ=0.25us。所以1M的波特率需要4TQ，也不能实现。实现800Khz的1.25us，需要5TQ，显然也不适合。 <br> 对于要实现500Khz是，当BPR为0时，TQ=2*(0+1)*0.125us=0.25us，要实现500KHz的波特率需要8TQ。这样来说还是可以满足时间段的要求的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/109e8119ad58fc4e7790ad7872fa2308/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">yum无法安装软件包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51508c1196b24402f615b5b42c859628/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">［深入理解Redis］读取RDB文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>