<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[数据结构初阶]二叉树 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/11a6f458e5837a9a20887bdeb28d5c4d/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="[数据结构初阶]二叉树">
  <meta property="og:description" content="各位读者老爷好，鼠鼠我现在浅浅介绍一些关于二叉树的知识点，在各位老爷茶余饭后的闲暇时光不妨看看，鼠鼠很希望得到各位老爷的指正捏！
开始介绍之前，给各位老爷看一张风景照，有读者老爷知道在哪里吗？
第一个在评论区答出正确答案的老爷鼠鼠会联系你，有惊喜捏！ 目录
1.树
1.1.树的概念 1.2.树的相关概念
2.二叉树
2.1.二叉树的概念
2.2.特殊的二叉树
2.3.二叉树的存储结构
3.堆
3.1.堆的概念及分类
3.2.堆的顺序存储的实现（二叉树的顺序存储的实现） 3.2.1.堆（大堆）总览
3.2.2. 定义堆
3.2.3.堆的初始化
3.2.4.堆的插入
3.2.5.堆的删除 3.2.6.获取堆顶的数据
3.2.7.堆的数据个数
3.2.8.堆的判空
3.2.9.堆的销毁
4.运行结构分析
好的，我们在介绍二叉树之前需要了解树的概念！
1.树 1.1.树的概念 树是一种非线性的数据结构，它是由n（n&amp;gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
画个图给各位老爷看看：
我们可以看到：
1.有一个特殊的结点（A节点），称为根结点，根节点没有前驱结点。
2.除根节点外，其余结点被分成M(M&amp;gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&amp;lt;= i&amp;lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继。
3.因此，树是递归定义的。
注意：树形结构中，子树之间不能有交集，否则就不是树形结构。
树形结构除了根节点外，每个节点有且只有一个父节点。如图就不是一个树形结构。
1.2.树的相关概念 介绍下面相关概念鼠鼠以下面树形结构举例：
1.节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A节点的度为3，B节点的度为2。
2.叶节点或终端节点：度为0的节点称为叶节点； 如上图：G、H、I、J、K和L节点为叶节点。
3.非终端节点或分支节点：度不为0的节点； 如上图：B、C、D、E和F节点为分支节点。
4.双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点，也是C的父节点，也是D的父节点。
5.孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B、C和D都是A的孩子节点。
6.兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：J、K和L互为兄弟节点。
7.树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为3。
8.节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。
9.树的高度或深度：树中节点的最大层次； 如上图：树的高度为4。
10.堂兄弟节点：双亲节点在同一层的节点互为堂兄弟节点；如上图：F和G互为堂兄弟节点。
11.节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先。
12.子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙。
13.森林：由m（m&amp;gt;0）棵互不相交的树的集合称为森林。
有了以上铺垫，我们来了解二叉树的概念！
2.二叉树 2.1.二叉树的概念 一棵二叉树是结点的一个有限集合，该集合:
1. 或者为空。
2. 由一个根节点加上两棵别称为左子树和右子树的二叉树组成。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-24T10:56:27+08:00">
    <meta property="article:modified_time" content="2024-03-24T10:56:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[数据结构初阶]二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>各位读者老爷好，鼠鼠我现在浅浅介绍一些关于二叉树的知识点，在各位老爷茶余饭后的闲暇时光不妨看看，鼠鼠很希望得到各位老爷的指正捏！</p> 
<blockquote> 
 <p>开始介绍之前，给各位老爷看一张风景照，有读者老爷知道在哪里吗？</p> 
 <p class="img-center"><img alt="" height="199" src="https://images2.imgbox.com/55/35/fZ2k90lh_o.jpg" width="354"></p> 
 <p>第一个在评论区答出正确答案的老爷鼠鼠会联系你，有惊喜捏！ </p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%A0%91-toc" style="margin-left:40px;"><a href="#1.%E6%A0%91" rel="nofollow">1.树</a></p> 
<p id="1.1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0-toc" style="margin-left:80px;"><a href="#1.1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0" rel="nofollow">1.1.树的概念 </a></p> 
<p id="1.2.%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1.2.%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">1.2.树的相关概念</a></p> 
<p id="2.%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#2.%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">2.二叉树</a></p> 
<p id="2.1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#2.1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">2.1.二叉树的概念</a></p> 
<p id="2.2.%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#2.2.%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">2.2.特殊的二叉树</a></p> 
<p id="2.3.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#2.3.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" rel="nofollow">2.3.二叉树的存储结构</a></p> 
<p id="3.%E5%A0%86-toc" style="margin-left:40px;"><a href="#3.%E5%A0%86" rel="nofollow">3.堆</a></p> 
<p id="3.1.%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#3.1.%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%88%86%E7%B1%BB" rel="nofollow">3.1.堆的概念及分类</a></p> 
<p id="3.2.%E5%A0%86%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89%C2%A0-toc" style="margin-left:80px;"><a href="#3.2.%E5%A0%86%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89%C2%A0" rel="nofollow">3.2.堆的顺序存储的实现（二叉树的顺序存储的实现） </a></p> 
<p id="3.2.1.%E5%A0%86%EF%BC%88%E5%A4%A7%E5%A0%86%EF%BC%89%E6%80%BB%E8%A7%88-toc" style="margin-left:120px;"><a href="#3.2.1.%E5%A0%86%EF%BC%88%E5%A4%A7%E5%A0%86%EF%BC%89%E6%80%BB%E8%A7%88" rel="nofollow">3.2.1.堆（大堆）总览</a></p> 
<p id="3.2.2.%20%E5%AE%9A%E4%B9%89%E5%A0%86-toc" style="margin-left:120px;"><a href="#3.2.2.%20%E5%AE%9A%E4%B9%89%E5%A0%86" rel="nofollow">3.2.2. 定义堆</a></p> 
<p id="3.2.3.%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:120px;"><a href="#3.2.3.%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">3.2.3.堆的初始化</a></p> 
<p id="3.2.4.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:120px;"><a href="#3.2.4.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">3.2.4.堆的插入</a></p> 
<p id="3.2.5.%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:120px;"><a href="#3.2.5.%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">3.2.5.堆的删除 </a></p> 
<p id="3.2.6.%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#3.2.6.%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow">3.2.6.获取堆顶的数据</a></p> 
<p id="3.2.7.%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0-toc" style="margin-left:120px;"><a href="#3.2.7.%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0" rel="nofollow">3.2.7.堆的数据个数</a></p> 
<p id="3.2.8.%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA-toc" style="margin-left:120px;"><a href="#3.2.8.%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA" rel="nofollow">3.2.8.堆的判空</a></p> 
<p id="3.2.9.%E5%A0%86%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:120px;"><a href="#3.2.9.%E5%A0%86%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">3.2.9.堆的销毁</a></p> 
<p id="4.%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#4.%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90" rel="nofollow">4.运行结构分析</a></p> 
<blockquote> 
 <p>好的，我们在介绍二叉树之前需要了解树的概念！</p> 
</blockquote> 
<h3 id="1.%E6%A0%91">1.树</h3> 
<h4 id="1.1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0">1.1.树的概念 </h4> 
<p>树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p> 
<blockquote> 
 <p>画个图给各位老爷看看：</p> 
 <p class="img-center"><img alt="" height="213" src="https://images2.imgbox.com/5f/ce/F54OowJL_o.png" width="386"></p> 
</blockquote> 
<blockquote> 
 <p>我们可以看到：</p> 
 <p>1.有一个特殊的结点（A节点），称为根结点，根节点没有前驱结点。</p> 
 <p>2.除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i&lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继。</p> 
 <p>3.因此，树是递归定义的。</p> 
</blockquote> 
<p>注意：树形结构中，子树之间不能有交集，否则就不是树形结构。</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" class="right" height="228" src="https://images2.imgbox.com/ec/a7/mFNaJD8v_o.png" width="396"><br> 树形结构除了根节点外，每个节点有且只有一个父节点。如图就不是一个树形结构。</p> 
</blockquote> 
<h4 id="1.2.%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">1.2.树的相关概念</h4> 
<blockquote> 
 <p>介绍下面相关概念鼠鼠以下面树形结构举例：</p> 
 <p style="text-align:center;"><img alt="" height="216" src="https://images2.imgbox.com/ac/f1/AIwVCD1B_o.png" width="393"></p> 
</blockquote> 
<p>1.节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A节点的度为3，B节点的度为2。</p> 
<p>2.叶节点或终端节点：度为0的节点称为叶节点； 如上图：G、H、I、J、K和L节点为叶节点。</p> 
<p>3.非终端节点或分支节点：度不为0的节点； 如上图：B、C、D、E和F节点为分支节点。</p> 
<p>4.双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点，也是C的父节点，也是D的父节点。</p> 
<p>5.孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B、C和D都是A的孩子节点。</p> 
<p>6.兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：J、K和L互为兄弟节点。</p> 
<p>7.树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为3。</p> 
<p>8.节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。</p> 
<p>9.树的高度或深度：树中节点的最大层次； 如上图：树的高度为4。</p> 
<p>10.堂兄弟节点：双亲节点在同一层的节点互为堂兄弟节点；如上图：F和G互为堂兄弟节点。</p> 
<p>11.节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先。</p> 
<p>12.子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙。</p> 
<p>13.森林：由m（m&gt;0）棵互不相交的树的集合称为森林。</p> 
<blockquote> 
 <p>有了以上铺垫，我们来了解二叉树的概念！</p> 
</blockquote> 
<h3 id="2.%E4%BA%8C%E5%8F%89%E6%A0%91">2.二叉树</h3> 
<h4 id="2.1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">2.1.二叉树的概念</h4> 
<blockquote> 
 <p>一棵二叉树是结点的一个有限集合，该集合:<br> 1. 或者为空。<br> 2. 由一个根节点加上两棵别称为左子树和右子树的二叉树组成。</p> 
</blockquote> 
<p>说简单点呢，二叉树是一颗特殊的树，这颗树的度最大为2，就像是对这颗树的节点进行了计划生育，最多只能生两个节点宝宝。 </p> 
<blockquote> 
 <p class="img-center"><img alt="" height="241" src="https://images2.imgbox.com/82/b4/X9mDVZhP_o.png" width="274"></p> 
 <p>从图可以看出：</p> 
 <p>1. 二叉树不存在度大于2的结点。<br> 2. 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树。</p> 
 <p>3.二叉树的子树也都是二叉树，既然是二叉树就可以为空树。</p> 
</blockquote> 
<p>注意：对于任意的二叉树都是由以下几种情况复合而成的：</p> 
<blockquote> 
 <p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/6b/43/OJG28GF6_o.png" width="472"></p> 
</blockquote> 
<h4 id="2.2.%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91">2.2.特殊的二叉树</h4> 
<p>1. 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" height="150" src="https://images2.imgbox.com/09/6e/StkL6RE6_o.png" width="326"></p> 
</blockquote> 
<p>很容易知道，满二叉树各层的节点个数构成一个以1为首项，以2为公比的等比数列。如果一个二叉树的层数为K，用等比数列的求和公式或者错位相减法就能得到满二叉树节点的和为2^K-1。</p> 
<p>那么反过来，如果知道了满二叉树的节点个数为N，那么它的层数就为log2（N+1），约等log2(N)。</p> 
<hr> 
<p>2.完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。</p> 
<p>说简单易懂的话呢，就是说完全二叉树如果有K层，那么前K-1层的节点数都达到最大值，第K层的节点数不一定达到最大值，但是最后一层的节点从左到右必须连续。</p> 
<blockquote> 
 <p><img alt="" class="left" height="164" src="https://images2.imgbox.com/ac/ec/XIsLF7Sa_o.png" width="280"><img alt="" height="161" src="https://images2.imgbox.com/c2/ca/eQGIJuJs_o.png" width="321"></p> 
</blockquote> 
<p>跟上面分析的一样，我们知道完全二叉树的前K-1层的节点数总和为2^(K-1)-1 。最后一层（第K层）的节点个数最少为1个，最多为2^(K-1)个。那么完全二叉树的节点总数范围就是2^(K-1)到2^K-1。</p> 
<p>相同的，我们如果知道完全二叉树的节点个数为N，那么它的层数也大概是log2(N)。</p> 
<h4 id="2.3.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">2.3.二叉树的存储结构</h4> 
<p>二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。</p> 
<hr> 
<p>1. 顺序存储<br> 顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储，至于堆是什么鼠鼠下面会讲的捏！二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。</p> 
<blockquote> 
 <p>也许各位老爷不明白为啥可以将二叉树存储到一个数组中呢？</p> 
 <p style="text-align:center;"><img alt="" class="right" height="97" src="https://images2.imgbox.com/84/e8/EN3y5ppr_o.gif" width="121"></p> 
</blockquote> 
<p>其实我们将二叉树在逻辑上想象成一颗二叉树，在逻辑上我们将二叉树的节点一层一层按顺序存储到数组中。我们通过以下规律可以控制二叉树捏：</p> 
<blockquote> 
 <p>1.左孩子节点下标=父节点下标*2+1；</p> 
 <p>2.右孩子节点下标=父节点下标*2+1；</p> 
 <p>3.父节点下标=(左孩子节点下标-1)/2=(右孩子节点下标-1)/2； </p> 
 <p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/6f/84/DchQ11WI_o.png" width="496"></p> 
</blockquote> 
<p>那么为什么只有完全二叉树适合用顺序存储捏？</p> 
<blockquote> 
 <p>因为用顺序存储（就是用数组存储）的话我们要保证父节点下标和孩子节点下标满足上面三条规律才能控制好二叉树。而非完全二叉树要想满足上面三条规律的话，我们会有空间浪费，如下图：</p> 
 <p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/77/1a/SIZjp6QB_o.png" width="496"></p> 
 <p>如果根据错误对应来存储二叉树节点的话，就不符合上面的三条规律了！ 所以顺序存储适合完全二叉树，非完全二叉树也可以存储但不适合！</p> 
</blockquote> 
<hr> 
<p> 2. 链式存储<br> 二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法（二叉链）是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。</p> 
<p>本篇博客不细讲二叉树的链式存储，我们主要搞定顺序存储，链式存储后面博客再介绍！</p> 
<hr> 
<p>既然介绍二叉树的顺序存储，而现实中使用中只有堆才会使用数组来存储，鼠鼠就要介绍堆这个概念并实现堆（也就是实现二叉树的顺序存储）捏 ！</p> 
<h3 id="3.%E5%A0%86">3.堆</h3> 
<p>堆就是一颗二叉树，堆一般是将数组数据看做一颗完全二叉树。现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统虚拟进程地址空间中的堆是两回事，本篇博客讲的堆一个是数据结构，另外一个是操作系统中管理内存的一块区域分段。</p> 
<h4 id="3.1.%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%88%86%E7%B1%BB">3.1.堆的概念及分类</h4> 
<blockquote> 
 <p>简单讲，堆就是一颗二叉树，不过这颗二叉树对数据摆放有要求：</p> 
 <p>大堆：任意一个父节点数据要大于或等于它的任意孩子节点数据；</p> 
 <p>小堆：任意一个父节点数据要小于或等于它的任意孩子节点数据；</p> 
 <p class="img-center"><img alt="" height="155" src="https://images2.imgbox.com/ef/de/7dsiM3Oc_o.png" width="423"></p> 
 <p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/56/6a/qk1adyqC_o.png" width="423"></p> 
</blockquote> 
<p>堆只有大堆和小堆之分，没有中堆这个说法！我们来看一道题，方便理解：</p> 
<blockquote> 
 <p>1.下列关键字序列为堆的是：（）<br> A 100,60,70,50,32,65<br> B 60,70,65,50,32,100<br> C 65,100,70,32,50,60<br> D 70,65,100,32,50,60<br> E 32,50,100,70,65,60<br> F 50,100,70,65,60,32</p> 
</blockquote> 
<p>答案选A，为什么A是堆，其他不是捏？我们来看：</p> 
<blockquote> 
 <p>A选项：</p> 
 <p><img alt="" class="left" height="167" src="https://images2.imgbox.com/f0/87/I1QlW3XS_o.png" width="432"></p> 
 <p> 还原成逻辑结构的完全二叉树的话，很明显是一个大堆！</p> 
 <p>B选项：</p> 
 <p style="text-align:center;"><img alt="" class="left" height="159" src="https://images2.imgbox.com/fe/12/NZ1I3Inr_o.png" width="434"></p> 
 <p> 还原成逻辑结构的完全二叉树的话，很明显不是大堆也不是小堆，比如说60&lt;65，符合小堆要求；但是70&gt;32，又符合大堆要求；所以不是堆！</p> 
 <p></p> 
 <p>其他选项分析相同，鼠鼠就不解释了！</p> 
</blockquote> 
<h4 id="3.2.%E5%A0%86%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89%C2%A0">3.2.堆的顺序存储的实现（二叉树的顺序存储的实现） </h4> 
<p>也许有读者老爷不明白为啥用堆的顺序存储的实现代表二叉树的顺序存储的实现？因为堆的顺序存储的实现是有意义的，它能很好的管理数据而并非单纯的存储数据。如果单纯存储数据我们大可不必用二叉树来存储！至于堆能实现什么功能，再下面的讲解中鼠鼠会浅谈。</p> 
<p>因为堆有大堆和小堆之分，鼠鼠我实现<span style="color:#fe2c24;">大堆</span>的顺序存储为例，小堆的实现相信老爷们可以举一反三自己搞定！</p> 
<h5 id="3.2.1.%E5%A0%86%EF%BC%88%E5%A4%A7%E5%A0%86%EF%BC%89%E6%80%BB%E8%A7%88">3.2.1.堆（<span style="color:#fe2c24;">大堆</span>）总览</h5> 
<p>我们先总体看堆的顺序存储实现完的三个文件，有兴趣的老爷可以放到一个工程下面玩玩：</p> 
<p>1.heap.h</p> 
<pre><code class="language-cs">#pragma once
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;

//大堆


typedef int HeapDataType;

typedef struct Heap
{
	HeapDataType* a;
	int size;
	int capacity;
}Heap;

//堆的初始化
void HeapInit(Heap* HP);

//堆的插入
void HeapPush(Heap* HP, HeapDataType x);

//堆的删除
void HeapPop(Heap* Hp);

//取堆顶的数据
HeapDataType HeapTop(Heap* HP);

//堆的数据个数
int HeapSize(Heap* hp);

// 堆的判空
bool HeapEmpty(Heap* hp);

//堆的销毁
void HeapDestroy(Heap* HP);</code></pre> 
<p>2.heap.c </p> 
<pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS
#include"heap.h"

void HeapInit(Heap* HP)
{
	assert(HP);
	HP-&gt;a = NULL;
	HP-&gt;capacity = HP-&gt;size = 0;
}

void swap(HeapDataType* parent, HeapDataType* child)
{
	HeapDataType tmp = *parent;
	*parent = *child;
	*child = tmp;
}

void AdjustUp(HeapDataType* a, int childcoordinate)
{
	int parentcoordinate = (childcoordinate - 1) / 2;
	while (childcoordinate &gt; 0)
	{
		if (a[parentcoordinate] &lt; a[childcoordinate])
		{
			swap(&amp;a[parentcoordinate], &amp;a[childcoordinate]);
			childcoordinate = parentcoordinate;
			parentcoordinate = (parentcoordinate - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

void HeapPush(Heap* HP, HeapDataType x)
{
	assert(HP);

	//扩容
	if (HP-&gt;capacity == HP-&gt;size)
	{
		int newcapacity = HP-&gt;capacity == 0 ? 4 : HP-&gt;capacity * 2;
		HeapDataType* tmp = (HeapDataType*)realloc(HP-&gt;a, sizeof(HeapDataType) * newcapacity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(-1);
		}
		HP-&gt;a = tmp;
		HP-&gt;capacity = newcapacity;
	}
	HP-&gt;a[HP-&gt;size++] = x;

	//向上调整
	AdjustUp(HP-&gt;a, HP-&gt;size - 1);
}

void AdjustDown(HeapDataType* a, int size, int parentcoordinate)
{
	int childcoordinate = parentcoordinate * 2 + 1;
	
	while (childcoordinate &lt; size)
	{
		if (a[childcoordinate] &lt; a[childcoordinate + 1]&amp;&amp;childcoordinate+1&lt;size)
		{
			childcoordinate++;
		}
		if (a[childcoordinate] &gt; a[parentcoordinate])
		{
			swap(&amp;a[childcoordinate], &amp;a[parentcoordinate]);
			parentcoordinate = childcoordinate;
			childcoordinate = childcoordinate * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

void HeapPop(Heap* HP)
{
	assert(HP);
	assert(HP-&gt;size &gt; 0);
	swap(&amp;HP-&gt;a[0], &amp;HP-&gt;a[HP-&gt;size - 1]);
	HP-&gt;size--;

	//向下调整
	AdjustDown(HP-&gt;a, HP-&gt;size,0);
}

HeapDataType HeapTop(Heap* HP)
{
	assert(HP-&gt;size &gt; 0);
	return HP-&gt;a[0];
}

int HeapSize(Heap* HP)
{
	return HP-&gt;size;
}

bool HeapEmpty(Heap* HP)
{
	return HP-&gt;size == 0;
}

void HeapDestroy(Heap* HP)
{
	free(HP-&gt;a);
	HP-&gt;a = NULL;
	HP-&gt;capacity = HP-&gt;size = 0;
}
</code></pre> 
<p>3.test.c</p> 
<pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS
#include"heap.h"

int main()
{
	int a[] = { 100,90,80,110,75,3 };
	Heap p;
	HeapInit(&amp;p);
	for (int i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++)
	{
		HeapPush(&amp;p, a[i]);
	}
	for(int i=0;i&lt;p.size;i++)
	{
		printf("%d ", p.a[i]);
	}
	printf("\n");
	while (!HeapEmpty(&amp;p))
	{
		printf("%d ", HeapTop(&amp;p));
		HeapPop(&amp;p);
	}
	return 0;
}</code></pre> 
<p>4.运行结果 </p> 
<blockquote> 
 <p class="img-center"><img alt="" height="332" src="https://images2.imgbox.com/56/91/TrmKJTvR_o.png" width="414"></p> 
 <p>运行结果为啥是这样的，我们一会分析！ </p> 
</blockquote> 
<h5 id="3.2.2.%20%E5%AE%9A%E4%B9%89%E5%A0%86">3.2.2. 定义堆</h5> 
<pre><code class="language-cs">typedef int HeapDataType;

typedef struct Heap
{
	HeapDataType* a;
	int size;
	int capacity;
}Heap;</code></pre> 
<blockquote> 
 <p>这里重命名int为HeapDataType，大大方便后续代码的维护！用a指向后来动态开辟的连续内存，该连续内存用来存储堆的数据，size用来记录堆的数据个数或者指向堆最后一个数据的下一个，capacity用来记录连续内存可放入数据的容量。</p> 
 <p style="text-align:center;"><img alt="" height="239" src="https://images2.imgbox.com/e0/c1/vl6HoULf_o.png" width="244"></p> 
</blockquote> 
<p>这里用一个结构体来定义堆如代码所示，定义的跟顺序表一样，但是我们这里表示的堆对数据的摆放要求是大堆或者小堆，而顺序表就没有这个要求！ </p> 
<h5 id="3.2.3.%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">3.2.3.堆的初始化</h5> 
<pre><code class="language-cs">void HeapInit(Heap* HP)
{
	assert(HP);
	HP-&gt;a = NULL;
	HP-&gt;capacity = HP-&gt;size = 0;
}</code></pre> 
<p>断言防止传入结构体变量地址为空（下面这点不在赘述。） 不妨将a置空，将capacity和size置0。</p> 
<h5 id="3.2.4.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5">3.2.4.堆的插入</h5> 
<pre><code class="language-cs">void swap(HeapDataType* parent, HeapDataType* child)
{
	HeapDataType tmp = *parent;
	*parent = *child;
	*child = tmp;
}

void AdjustUp(HeapDataType* a, int childcoordinate)
{
	int parentcoordinate = (childcoordinate - 1) / 2;
	while (childcoordinate &gt; 0)
	{
		if (a[parentcoordinate] &lt; a[childcoordinate])
		{
			swap(&amp;a[parentcoordinate], &amp;a[childcoordinate]);
			childcoordinate = parentcoordinate;
			parentcoordinate = (parentcoordinate - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

void HeapPush(Heap* HP, HeapDataType x)
{
	assert(HP);

	//扩容
	if (HP-&gt;capacity == HP-&gt;size)
	{
		int newcapacity = HP-&gt;capacity == 0 ? 4 : HP-&gt;capacity * 2;
		HeapDataType* tmp = (HeapDataType*)realloc(HP-&gt;a, sizeof(HeapDataType) * newcapacity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(-1);
		}
		HP-&gt;a = tmp;
		HP-&gt;capacity = newcapacity;
	}
	HP-&gt;a[HP-&gt;size++] = x;

	//向上调整
	AdjustUp(HP-&gt;a, HP-&gt;size - 1);
}
</code></pre> 
<p>堆的插入我们表面上是在数组中（动态开辟的空间）尾插，但我们逻辑上要想象成数据插入在树的底层，并调整数据使其符合大堆要求。 这里的精髓是调整数据，也就是代码中的向上调整函数。关于向上调整函数，鼠鼠画一个图方便理解吧：</p> 
<blockquote> 
 <img alt="" src="https://images2.imgbox.com/8f/27/Dzj14QZl_o.png"> 
</blockquote> 
<p>我们可以看到堆的插入代码中主要的时间消耗在向上调整函数上，而向上调整函数最多调整层数-1次，完全二叉树的层数前面算过大概是log2(N)，结合堆的插入代码分析，堆的插入时间复杂度是O(logN)。</p> 
<h5 id="3.2.5.%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%C2%A0">3.2.5.堆的删除 </h5> 
<pre><code class="language-cs">void swap(HeapDataType* parent, HeapDataType* child)
{
	HeapDataType tmp = *parent;
	*parent = *child;
	*child = tmp;
}

void AdjustDown(HeapDataType* a, int size, int parentcoordinate)
{
	int childcoordinate = parentcoordinate * 2 + 1;
	
	while (childcoordinate &lt; size)
	{
		if (a[childcoordinate] &lt; a[childcoordinate + 1]&amp;&amp;childcoordinate+1&lt;size)
		{
			childcoordinate++;
		}
		if (a[childcoordinate] &gt; a[parentcoordinate])
		{
			swap(&amp;a[childcoordinate], &amp;a[parentcoordinate]);
			parentcoordinate = childcoordinate;
			childcoordinate = childcoordinate * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

void HeapPop(Heap* HP)
{
	assert(HP);
	assert(HP-&gt;size &gt; 0);
	swap(&amp;HP-&gt;a[0], &amp;HP-&gt;a[HP-&gt;size - 1]);
	HP-&gt;size--;

	//向下调整
	AdjustDown(HP-&gt;a, HP-&gt;size,0);
}</code></pre> 
<p> 对于堆的删除来说，数据结构规定删除的是堆顶的数据（根节点数据），当然删除完堆顶数据后，我们必须将剩余数据再构成大堆。</p> 
<p>为啥删除的是堆顶的数据捏？因为堆顶的数据是堆中所有数据中最大的，删除完堆顶数据后新的堆顶就是“次大的”，这样的话我们可以做到选数的功能，后面可以更好体会。</p> 
<p>完成堆的删除，我们采取将堆顶的数据根最后一个数据一换，然后删除数组最后一个数据，再进行向下调整算法。堆的删除过程画图理解如下：</p> 
<blockquote> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/7f/1c/b3JlajWY_o.png"></p> 
</blockquote> 
<p>同样堆的删除主要的时间消耗在向下调整函数上，而向下调整函数最多也是调整层数-1次，那么堆的删除时间复杂度也是O(logN)。</p> 
<p>完成堆的删除，我们为什么不采用跟顺序表头删一样的挪动覆盖方法呢？因为如果采用了挪动覆盖之后剩余的数据下标关系全乱了，不成堆了；且挪动覆盖的时间复杂度是O(N)。</p> 
<h5 id="3.2.6.%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E7%9A%84%E6%95%B0%E6%8D%AE">3.2.6.获取堆顶的数据</h5> 
<pre><code class="language-cs">HeapDataType HeapTop(Heap* HP)
{
	assert(HP-&gt;size &gt; 0);
	return HP-&gt;a[0];
}</code></pre> 
<p>简单，返回a[0]即可。</p> 
<h5 id="3.2.7.%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0">3.2.7.堆的数据个数</h5> 
<pre><code class="language-cs">int HeapSize(Heap* HP)
{
	return HP-&gt;size;
}</code></pre> 
<p>根据设定，返回size即可。</p> 
<h5 id="3.2.8.%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA">3.2.8.堆的判空</h5> 
<pre><code class="language-cs">bool HeapEmpty(Heap* HP)
{
	return HP-&gt;size == 0;
}</code></pre> 
<p>当堆为空返回真，堆不为空返回假，所以容知上面代码逻辑可以实现逻辑自恰 。</p> 
<h5 id="3.2.9.%E5%A0%86%E7%9A%84%E9%94%80%E6%AF%81">3.2.9.堆的销毁</h5> 
<pre><code class="language-cs">void HeapDestroy(Heap* HP)
{
	free(HP-&gt;a);
	HP-&gt;a = NULL;
	HP-&gt;capacity = HP-&gt;size = 0;
}</code></pre> 
<p>销毁动态开辟的空间并将a置成NULL，将capacity和size置成0即可。</p> 
<h3 id="4.%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90" style="background-color:transparent;">4.运行结构分析</h3> 
<blockquote> 
 <p>各位老爷先看结果如下：</p> 
 <p class="img-center"><img alt="" height="426" src="https://images2.imgbox.com/5b/49/y7rWEtZo_o.png" width="530"></p> 
</blockquote> 
<p>第一条语句：定义一组数组a，元素为100、90、80、110、75和3。</p> 
<p>第二条语句：定义一个结构体变量p（创建堆p）。</p> 
<p>第三条语句：调用HeapInit函数初始化p。</p> 
<p>接下来for循环语句：取数组a成员依次入堆。由HeapPush函数可知，执行完这个for循环语句后，a元素构成大堆！</p> 
<p>接下来for循环语句：打印大堆，得出110 100 80 90 75 3。可以看出这样存储确实是大堆。</p> 
<p>接下来while循环：当堆不为空时，打印堆顶数据并删除堆顶数据！得出结果为110 100 90 80 75 3，是递减的。</p> 
<blockquote> 
 <p>从这里我们可以看出一点堆的管理数据的能力：</p> 
 <p>删除堆顶数据就是删除了（大）堆中最大的数据并将剩下的数据再成（大）堆，这样新的（大）堆的新的堆顶数据就是“次大的”，再删除堆顶数据再成（大）堆…………这样出来的数据就是递减的（小堆同理成递增）。</p> 
</blockquote> 
<p>感谢阅读，如有不足，恳请指正，谢谢！ </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f41743cdd4d109da9ea89d17df6aceee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS及javascript</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b4c992c05a5367aac53a699028a714ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于SSM&#43;Jsp&#43;Mysql的学生信息管理系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>