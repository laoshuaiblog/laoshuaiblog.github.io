<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java的内存分配机制(初步整理) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/25cd98a7b06d3a3fe846ae024fa50ce5/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Java的内存分配机制(初步整理)">
  <meta property="og:description" content="Java程序是运行在Java虚拟机(Java Virtual Machine，JVM)上的，可以把JVM理解为Java程序和操作系统之间的桥梁，JVM实现了Java的跨平台，Java内存分配原理一切都是在JVM中进行的，JVM是内存分配原理的基础与前提。
一个完整的Java程序运行过程会涉及以下内存区域：
寄存器：JVM内部虚拟寄存器，存取速度非常快，程序不可控制。
栈内存：保存局部变量的值。在函数中定义的一些基本数据类型的变量和对象的引用变量都是在函数的栈内存中分配，当一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后（比如：在函数A中调用函数B，在函数B中定义变量a，变量a的作用域只是函数B，在函数B运行完以后，变量a会自动被销毁，分配给它的内存会被收回），Java会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。
堆内存：用来存放Java世界中几乎所有的对象实例(如new创建的对象和数组，注意：创建出来的对象只包含属于各自的成员变量，不包括成员方法，因为同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是它们共享该类的方法，并不是每创建一个对象就把成员方法复制一次)，在堆中分配内存，由Java虚拟机的自动垃圾回收器(GC)来管理。在堆中产生了一个对象或数组后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或是对象在堆内存中的首地址，栈中的这个变量就成了对象或数组的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的对象或数组，引用变量就相当于为对象或数组取的一个名称。引用变量是普通变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而对象或数组本身在堆中分配，即使程序运行到使用new产生对象或数组的语句所在的代码块之外，对象或数组本身所占据的内存不会被释放，对象和数组在没有引用变量指向它的时候才变为垃圾，不能再被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器(GC)收走。这也是Java比较占内存的原因，实际上，栈中的变量指向堆内存中变量就是Java中的指针。
常量池：JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用(*)。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。常量池存在于堆中。
代码段：用来存放从硬盘上读取的源程序代码。
数据段：用来存放static定义的静态成员，一直占用内存。
内存表示图：
预备知识：
1、一个Java文件，只要有main入口方法，我们就认为这是一个Java程序，可以单独编译运行。
2、无论是普通类型的变量还是引用类型的变量(俗称实例)，都可以作为局部变量，他们都可以出现在栈中。只不过普通类型的变量在栈中直接保存它所对应的值，而引用类型的变量保存的是一个指向堆区的指针，通过这个指针，就可以找到这个实例在堆区对应的对象。因此普通类型变量只在栈区占用一块内存，而引用类型变量要在栈区和堆区各占一块内存。
示例：
1)、JVM自动寻找main方法，执行第一句代码，创建一个Test类的实例，在栈中分配一块内存，存放一个指向堆区对象的指针110925。
2)、创建一个int型的变量date，由于是基本类型，直接在栈中存放date对应的值9。
3)、创建两个BirthDate类的实例d1和d2，在栈中分别存放了对应的指针指向各自的对象，他们在实例化时调用了有参数的构造方法，因此对象中有自定义初始值。
调用test对象的change1方法，并且以date为参数。JVM读到这段代码时，检测到 i 是局部变量，因此会把 i 放到栈中，并且把date的值赋给 i 。
把1234赋给 i 。很简单的一步。
change1方法执行完毕，立即释放局部变量 i 所占用的栈空间。
调用test对象的change2方法，以实例d1为参数，JVM检测到change2方法中的b参数为局部变量，立即加入到栈中，由于是引用类型的变量，所以b中保存的是d1中的指针，此时b和d1指向同一个堆中的对象。在b和d1之间传递是指针。
change2方法中又实例化了一个BirthDate对象，并且赋给b。在内部的执行过程是：在堆区new了一个对象，并且把该对象的指针保存在栈中的b对应空间，此时实例b不再指向实例d1所指向的对象，但是实例d1所指向的对象并无变化，这样无法对d1造成任何影响。
change2方法执行完毕，立即释放局部引用变量b所占的栈空间，注意只是释放了栈空间，堆空间要等到自动回收。
调用test实例的change3方法，以实例d2为参数，同理，JVM会在栈中为局部引用变量b分配空间，并且把d2中的指针存放在b中，此时d2和b指向同一个对象。再调用实例b的setDay方法，其实就是调用d2指向的对象的setDay方法。
调用实例b的setDay方法会影响d2，因为二者指向的是同一个对象。
change3方法执行完毕，立即释放局部引用变量b。
以上就是Java程序运行时内存分配的大致情况，就是两种类型的变量：基本类型和引用类型。二者作为局部变量，都放在栈中，基本类型直接在栈中保存值，引用类型只保存一个指向堆区的指针，真正的对象在堆里。作为参数时基本类型就直接传值，引用类型传指针。
小结：
1、分清楚什么是实例什么是对象。
Class a = new Class();此时a叫实例，而不能说是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。
2、栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量立即销毁，但是堆中的对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。
3、每一个应用程序都对应唯一的一个JVM实例，每一个JVM实例都有自己的内存区域，互不影响。并且这些内存区域是所有线程共享的。这里提到的栈和堆都是整体上的概念，这些堆栈还可以细分。以上的堆、栈、代码段、数据段等都是相对于应用程序而言的。
4、类的成员变量在位于数据段中一直占用内存。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。
常量池的补充：
预备知识：基本类型和基本类型的包装类。基本类型有：byte、short、char、int、long、boolean。基本类型的包装类：Byte、Short、Character、Integer、Long、Boolean。注意区分大小写。二者的区别是：基本类型体现在程序中是普通变量，基本类型的包装类是类，体现在程序中是引用变量。因此二者在内存中的存储位置不同：基本类型存储在栈中，而基本类型的包装类存储在堆中。上面的这些包装类都实现了常量池的技术，另外两种浮点数类型的包装类则没有实现。另外，String类型也实现了常量池技术。
常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了类、方法、接口等中的常量，也包括字符串常量，如String s=&#34;java&#34;这种申明方式，当然也可以扩充，执行器产生的常量也会放入常量池，因此认为常量池是JVM的一块特殊的内存空间。
常量池中除了包含代码中所定义的各种基本类型(如int、long等)和对象型(如String及数组)的常量值外，还包含一些以文本形式出现的符号引用(*),比如类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。
所以，与Java语言中的所谓的“常量”不同，class文件中的“常量”内容很丰富，这些常量集中在class中的一个区域存放，一个紧接一个，称为“常量池”。
示例：
结果：
结果分析：
1、i和i0均是普通类型(int)的变量，所以数据直接存储在栈中，而栈有一个很重要的特性：栈中的数据可以分享。当我们定义了int i = 40;，再定义int i0 = 40;，这时候会自动检查栈中是否有40这个数据，如果有，i0会直接指向i的40，不会再添加一个新的40。
2、i1和i2均是引用类型，在栈中存储指针，因为Integer是包装类。由于Integer包装类实现了常量池技术，因此i1、i2的40均是从常量池中获取的，均指向同一个地址，因此i1=i2。
3、很明显这是一个加法运算，Java的数学运算都是在栈中进行的，Java会自动对i1、i2进行拆箱操作转化成整形，因此i1在数值上等于i2&#43;i3。
4、i4和i5均是引用类型，在栈中存储指针，因为Integer是包装类。但是由于他们各自都是new出来的，因此不再从常量池寻找数据，而是从堆中各自new一个对象，然后各自保存指向对象的指针，所以i4和i5不相等，因为他们所存指针不同，所指向对象不同。
5、这是一个加法运算，和3同理。
6、d1和d2均是引用类型，在栈中存储指针，因为Double是包装类。但Double包装类没有实现常量池技术，因此Double d1 = 1.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2017-03-01T08:07:35+08:00">
    <meta property="article:modified_time" content="2017-03-01T08:07:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java的内存分配机制(初步整理)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><br> </p> 
<p>    <span style="font-family:FangSong_GB2312; font-size:14px">Java程序是运行在Java虚拟机(Java Virtual Machine，JVM)上的，可以把JVM理解为Java程序和操作系统之间的桥梁，JVM实现了Java的跨平台，Java内存分配原理一切都是在JVM中进行的，JVM是内存分配原理的基础与前提。</span></p> 
<p>   </p> 
<p>    <span style="font-family:FangSong_GB2312; font-size:18px"><strong>一个完整的Java程序运行过程会涉及以下内存区域：</strong></span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"><strong><br> </strong></span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"><strong> 寄存器：</strong></span><span style="font-family:FangSong_GB2312; font-size:12px">JVM内部虚拟寄存器，存取速度非常快，程序不可控制。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> </span><strong style="font-family:FangSong_GB2312; font-size:12px">栈</strong><span style="font-family:FangSong_GB2312; font-size:12px"><strong>内存：</strong></span><span style="font-family:FangSong_GB2312; font-size:12px">保存</span><span style="font-family:FangSong_GB2312; font-size:12px">局部变量的值。在函数中定义的一些基本数据类型的变量和对象的引用变量都是在函数的栈内存中分配，当一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后（比如：在函数A中调用函数B，在函数B中定义变量a，变量a的作用域只是函数B，在函数B运行完以后，变量a会自动被销毁，分配给它的内存会被收回），Java会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> </span><span style="font-family:FangSong_GB2312; font-size:12px"><strong>堆内存：</strong></span><span style="font-family:FangSong_GB2312; font-size:12px">用来存放Java世界中几乎所有的对象实例(如new创建的对象和数组，注意：创建出来的对象只包含属于各自的成员变量，不包括成员方法，因为同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是它们共享该类的方法，并不是每创建一个对象就把成员方法复制一次)，在堆中分配内存，由Java虚拟机的自动垃圾回收器(GC)来管理。在堆中产生了一个对象或数组后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或是对象在堆内存中的首地址，栈中的这个变量就成了对象或数组的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的对象或数组，引用变量就相当于为对象或数组取的一个名称。引用变量是普通变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而对象或数组本身在堆中分配，即使程序运行到使用new产生对象或数组的语句所在的代码块之外，对象或数组本身所占据的内存不会被释放，对象和数组在没有引用变量指向它的时候才变为垃圾，不能再被使用，但仍然占据内存空间不放，在随后的一个不</span><span style="font-family:FangSong_GB2312; font-size:12px">确定的时间被垃圾回收器(</span><span style="font-family:FangSong_GB2312; font-size:12px">GC)收走。这也是Java比较占内存的原因，实际上，栈中的变量指向堆内存中变量就是Java中的指针。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> </span><span style="font-family:FangSong_GB2312; font-size:12px"><strong>常量池：</strong></span><span style="font-family:FangSong_GB2312; font-size:12px">JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的</span><span style="font-family:FangSong_GB2312; font-size:12px; color:rgb(255,0,0)">符号引用(*)</span><span style="font-family:FangSong_GB2312; font-size:12px">。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。常量池存在于堆中。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> </span><span style="font-family:FangSong_GB2312; font-size:12px"><strong>代码段：</strong></span><span style="font-family:FangSong_GB2312; font-size:12px">用来存放从硬盘上读取的源程序代码。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> </span><span style="font-family:FangSong_GB2312; font-size:12px"><strong>数据段：</strong></span><span style="font-family:FangSong_GB2312; font-size:12px">用来存放static定义的静态成员，一直占用内存。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"><br> </span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 内存表示图：</span></p> 
<p><img src="https://images2.imgbox.com/a7/4e/4OIXxSjk_o.jpg" alt=""><br> </p> 
<p>    <strong><span style="font-family:FangSong_GB2312; font-size:14px">预备知识：</span></strong></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 1、一个Java文件，只要有main入口方法，我们就认为这是一个Java程序，可以单独编译运行。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 2、无论是普通类型的变量还是引用类型的变量(俗称实例)，都可以作为局部变量，他们都可以出现在栈中。只不过普通类型的变量在栈中直接保存它所对应的值，而引用类型的变量保存的是一个指向堆区的指针，通过这个指针，就可以找到这个实例在堆区对应的对象。因此普通类型变量只在栈区占用一块内存，而引用类型变量要在栈区和堆区各占一块内存。</span></p> 
<p><span style="font-weight:bold; font-family:FangSong_GB2312; font-size:12px"><br> </span></p> 
<p><span style="font-weight:bold; font-family:FangSong_GB2312; font-size:12px"> </span><span style="font-weight:bold"><span style="font-family:FangSong_GB2312; font-size:14px">示例：</span></span></p> 
<p><br> </p> 
<p><img src="https://images2.imgbox.com/51/85/uxOu7f6c_o.jpg" alt=""></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 1)、JVM自动寻找main方法，执行第一句代码，创建一个Test类的实例，在栈中分配一块内存，存放一个指向堆区对象的指针110925。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 2)、创建一个int型的变量date，由于是基本类型，直接在栈中存放date对应的值9。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 3)、创建两个BirthDate类的实例d1和d2，在栈中分别存放了对应的指针指向各自的对象，他们在实例化时调用了有参数的构造方法，因此对象中有自定义初始值。</span></p> 
<p><br> </p> 
<p><img src="https://images2.imgbox.com/7f/9d/lIyvE2Ia_o.jpg" alt=""></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 调用test对象的change1方法，并且以date为参数。JVM读到这段代码时，检测到 i 是局部变量，因此会把 i 放到栈中，并且把date的值赋给 i 。</span></p> 
<p><br> </p> 
<p><img src="https://images2.imgbox.com/66/7f/Cbj7pjCD_o.jpg" alt=""></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 把1234赋给 i 。很简单的一步。</span></p> 
<p><br> </p> 
<p><img src="https://images2.imgbox.com/b8/6b/c7M09DQS_o.jpg" alt=""></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> change1方法执行完毕，立即释放局部变量 i 所占用的栈空间。</span></p> 
<p><br> </p> 
<p><img src="https://images2.imgbox.com/17/97/8PLfJy0G_o.jpg" alt=""></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 调用test对象的change2方法，以实例d1为参数，JVM检测到change2方法中的b参数为局部变量，立即加入到栈中，由于是引用类型的变量，所以b中保存的是d1中的指针，此时b和d1指向同一个堆中的对象。在b和d1之间传递是指针。</span></p> 
<p><br> </p> 
<p><img src="https://images2.imgbox.com/54/60/nXAQm2Q5_o.jpg" alt=""></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> change2方法中又实例化了一个BirthDate对象，并且赋给b。在内部的执行过程是：在堆区new了一个对象，并且把该对象的指针保存在栈中的b对应空间，此时实例b不再指向实例d1所指向的对象，但是实例d1所指向的对象并无变化，这样无法对d1造成任何影响。</span></p> 
<p><br> </p> 
<p><img src="https://images2.imgbox.com/1f/2a/c56ln8uO_o.jpg" alt=""></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> change2方法执行完毕，立即释放局部引用变量b所占的栈空间，注意只是释放了栈空间，堆空间要等到自动回收。</span></p> 
<p><br> </p> 
<p><img src="https://images2.imgbox.com/b1/d0/EXR69V7E_o.jpg" alt=""></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 调用test实例的change3方法，以实例d2为参数，同理，JVM会在栈中为局部引用变量b分配空间，并且把d2中的指针存放在b中，此时d2和b指向同一个对象。再调用实例b的setDay方法，其实就是调用d2指向的对象的setDay方法。</span></p> 
<p><br> </p> 
<p><img src="https://images2.imgbox.com/38/55/Eux0rcNJ_o.jpg" alt=""></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> </span><span style="font-family:FangSong_GB2312; font-size:12px">调用实例b的setDay方法会影响d2，因为二者指向的是同一个对象。</span></p> 
<p><br> </p> 
<p><img src="https://images2.imgbox.com/4f/f9/xswzf9iP_o.jpg" alt=""></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> change3方法执行完毕，立即释放局部引用变量b。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"><br> </span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 以上就是Java程序运行时内存分配的大致情况，就是两种类型的变量：基本类型和引用类型。二者作为局部变量，都放在栈中，基本类型直接在栈中保存值，引用类型只保存一个指向堆区的指针，真正的对象在堆里。作为参数时基本类型就直接传值，引用类型传指针。</span></p> 
<p><br> </p> 
<p>    <span style="font-family:FangSong_GB2312; font-size:14px"><strong>小结：</strong></span></p> 
<p><span style="font-family:FangSong_GB2312"><span style="font-size:14px"><strong> </strong></span></span><span style="font-family:FangSong_GB2312; font-size:12px">1、分清楚什么是实例什么是对象。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> Class a = new Class();此时a叫实例，而不能说是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 2、栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量立即销毁，但是堆中的对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 3、每一个应用程序都对应唯一的一个JVM实例，每一个JVM实例都有自己的内存区域，互不影响。并且这些内存区域是所有线程共享的。这里提到的栈和堆都是整体上的概念，这些堆栈还可以细分。以上的堆、栈、代码段、数据段等都是相对于应用程序而言的。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 4、类的成员变量在位于数据段中一直占用内存。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。</span></p> 
<p><br> </p> 
<p>    <strong><span style="color:rgb(255,0,0)"><span style="font-family:FangSong_GB2312; font-size:18px">常量池的补充：</span></span></strong></p> 
<p><span style="font-family:FangSong_GB2312"><strong><span style="font-size:18px; color:#ff0000"> </span></strong></span><span style="font-family:FangSong_GB2312; font-size:12px"><strong>预备知识：</strong></span><span style="font-family:FangSong_GB2312; font-size:12px">基本类型和基本类型的包装类。基本类型有：byte、short、char、int、long、boolean。基本类型的包装类：Byte、Short、Character、Integer、Long、Boolean。注意区分大小写。二者的区别是：基本类型体现在程序中是普通变量，基本类型的包装类是类，体现在程序中是引用变量。因此二者在内存中的存储位置不同：基本类型存储在栈中，而基本类型的包装类存储在堆中。上面的这些包装类都实现了常量池的技术，另外两种浮点数类型的包装类则没有实现。另外，String类型也实现了常量池技术。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了类、方法、接口等中的常量，也包括字符串常量，如String s="java"这种申明方式，当然也可以扩充，执行器产生的常量也会放入常量池，因此认为常量池是JVM的一块特殊的内存空间。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 常量池中除了包含代码中所定义的各种基本类型(如int、long等)和对象型(如String及数组)的常量值外，还包含一些以文本形式出现的符号引用(*),比如类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 所以，与Java语言中的所谓的“常量”不同，class文件中的“常量”内容很丰富，这些常量集中在class中的一个区域存放，一个紧接一个，称为“常量池”。</span></p> 
<p><span style="font-family:SimSun"><br> </span></p> 
<p><span style="font-family:SimSun; font-size:12px; color:rgb(51,51,51)"> </span><span style="font-family:FangSong_GB2312; font-size:14px"><strong>示例：</strong></span></p> 
<p><span style="color:#333333"><span style="font-family:SimSun"><span style="font-size:12px"><img src="https://images2.imgbox.com/ce/ae/UCb4bz9o_o.jpg" alt=""><br> </span></span></span></p> 
<div> 
 <span style="color:#333333"><span style="font-family:SimSun"><span style="font-size:12px">   </span></span></span> 
</div> 
<p><span style="font-size:12px">   </span> <strong><span style="font-family:FangSong_GB2312; font-size:14px">结果：</span></strong></p> 
<p><img src="https://images2.imgbox.com/26/61/3JM9UUGK_o.jpg" alt=""><br> </p> 
<p><br> </p> 
<p>    <strong><span style="font-family:FangSong_GB2312; font-size:14px">结果分析：</span></strong></p> 
<p><span style="font-family:FangSong_GB2312"><span style="font-size:14px"><strong> </strong></span></span><span style="font-family:FangSong_GB2312; font-size:12px">1、i和i0均是普通类型(int)的变量，所以数据直接存储在栈中，而栈有一个很重要的特性：</span><span style="font-family:FangSong_GB2312; font-size:12px"><strong><span style="color:#ff0000">栈中的数据可以分享</span></strong></span><span style="font-family:FangSong_GB2312; font-size:12px">。当我们定义了int i = 40;，再定义int i0 = 40;，这时候会自动检查栈中是否有40这个数据，如果有，i0会直接指向i的40，不会再添加一个新的40。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 2、i1和i2均是引用类型，在栈中存储指针，因为Integer是包装类。由于Integer包装类实现了常量池技术，因此i1、i2的40均是从常量池中获取的，均指向同一个地址，因此i1=i2。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 3、很明显这是一个加法运算，</span><span style="font-family:FangSong_GB2312; font-size:12px"><strong><span style="color:#ff0000">Java的数学运算都是在栈中进行的，Java会自动对i1、i2进行拆箱操作转化成整形</span></strong></span><span style="font-family:FangSong_GB2312; font-size:12px">，因此i1在数值上等于i2+i3。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 4、i4和i5均是引用类型，在栈中存储指针，因为Integer是包装类。但是由于他们各自都是new出来的，因此不再从常量池寻找数据，而是从堆中各自new一个对象，然后各自保存指向对象的指针，所以i4和i5不相等，因为他们所存指针不同，所指向对象不同。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 5、这是一个加法运算，和3同理。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 6、d1和d2均是引用类型，在栈中存储指针，因为Double是包装类。但Double包装类没有实现常量池技术，因此Double d1 = 1.0; 相当于Double d1 = new </span><span style="font-family:FangSong_GB2312; font-size:12px">Double(1.0);，是从堆new一个对象，d2同理。因此d1和d2存放的指针不同，指向的对象不同，所以不相等。</span></p> 
<p><br> </p> 
<p>    <strong><span style="font-family:FangSong_GB2312; font-size:14px">示例：</span></strong></p> 
<p><span style="font-family:SimSun; font-size:14px"><strong><img src="https://images2.imgbox.com/79/18/LyLabafw_o.jpg" alt=""><br> </strong></span></p> 
<p><strong><span style="font-size:14px">    </span><span style="font-family:FangSong_GB2312; font-size:14px">结果分析：</span></strong></p> 
<p><span style="font-family:FangSong_GB2312"><span style="font-size:14px"><strong> </strong></span></span><span style="font-family:FangSong_GB2312; font-size:12px">用new String() 创建的字符串不是常量，不能在编译器就能确定，所以new String()创建的字符串不放入常量池中，他们有自己的地址空间。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> String对象(内存)的不变性机制会使修改String字符串时，产生大量的对象，因为每次改变字符串，都会生成一个新的String。Java为了更有效的使用内存，常量池在编译期遇见String字符串时，它会检查该池内是否已经存在相同的String字符串，如果找到，就把新变量的引用指向现有的字符串对象，不创建任何新的String常量对象，没找到再创建新的。所以对一个字符串对象的任何修改，都会产生一个新的字符串对象，原来的依然存在，等待垃圾回收。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> String a = "test";</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> String b = "test";</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> String b = b + "java";</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> a、b同时指向常量池中的常量值”test“，</span><span style="font-family:FangSong_GB2312; font-size:12px">b = b + "java"之后，b原先指向一个常量，内容为"test"，通过对b进行+"java"操作后，b之前所指向的那个值没有改变，但此时b不指向原来那个变量值了，而指向了另一个String变量，内容为”test java“。原来那个变量还存在于内存之中，只是b这个变量不再指向它了。</span></p> 
<p><br> </p> 
<p>    <strong><span style="font-family:FangSong_GB2312; font-size:14px">示例：</span></strong></p> 
<p><span style="font-family:FangSong_GB2312"><span style="font-size:14px"><strong> </strong></span></span><span style="font-family:FangSong_GB2312; font-size:12px">在值小于127时可以使用常量池</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  Integer i1 = 127；</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  Integer i2 = 127；</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  System.out.println(i1==i2); // true</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  值大于127时，不会从常量池中取对象</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  Integer i3 = 128；</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  Integer i4 = 128；</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  System.out.println(i3==i4); // false</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  Boolean类也实现了常量池技术</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  Boolean b1 = true；</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  Boolean b2 = true；</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  System.out.println(b1==b2); // true</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  浮点类型的包装类没有实现常量池技术</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  Double d1 = 1.0；</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  Double d2 = 1.0；</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px">  System.out.println(d1==d2); // false</span></p> 
<p><br> </p> 
<p>    <strong><span style="font-family:FangSong_GB2312; font-size:14px">小结：</span></strong></p> 
<p><span style="font-family:FangSong_GB2312"><span style="font-size:14px"><strong> </strong></span></span><span style="font-family:FangSong_GB2312; font-size:12px">1、常量池维护的常量仅仅是【-128至127】这个范围内的常量，如果常量值超过这个范围，就会从堆中创建对象，不再从常量池中取。如：Integer i1 = 400；Integer i2 = 400；很明显超过了127，无法从常量池中获取常量，就用从堆中new新的Integer对象，这是i1和i2就不相等了。</span></p> 
<p><span style="font-family:FangSong_GB2312; font-size:12px"> 2、String类型也实现了常量池技术，但是稍微有点不同，String型是先检测常量池中有没有对应字符串，如果有，则取出来，如果没有，则把当前的添加进去。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0be749e215a4f1a9b6cc94a17780b9e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据库操作之同时一条sql删除两个表格中的数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/64e7ca26da117e98b41ff5f1cccc9ee1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java的反射机制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>