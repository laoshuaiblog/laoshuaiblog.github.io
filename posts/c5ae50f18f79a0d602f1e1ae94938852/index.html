<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【十二】数据结构之树、二叉树、二叉查找树、平衡二叉查找树AVL、红黑树、B树、B&#43;树简介 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/c5ae50f18f79a0d602f1e1ae94938852/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【十二】数据结构之树、二叉树、二叉查找树、平衡二叉查找树AVL、红黑树、B树、B&#43;树简介">
  <meta property="og:description" content="一、树 1.只有一个特殊节点，它没有父节点，它就是根节点
2.每一个非根节点有且只有一个父节点
3.每个节点包含多个指针指向其子节点
4.该例子有3层，40那一层，130那一层，10那一层，故该数的深度为3。
5.没有子节点的叫叶子节点。
6.拥有相同父节点的叫兄弟节点。
二、二叉树 在树的基础上多了些限制条件：
1.每个节点最多只能有2个子节点。
2.节点的子节点，分为左孩子节点和右孩子节点。
2.1 完全二叉树 在二叉树的基础上多了一个限制：
除最后一层外，若其余层都是满的，并且最后一层要么是满的，要么是在右边缺少连续若干节点
2.2 满二叉树 在二叉树的基础上多了两个限制：
所有分支结点都存在左子树和右子树。
所有叶子结点都在同一层上。
三、二叉查找树 在二叉树的基础上多了些限制条件
1.任何一个节点，如果它的左子树不为空，则左子树上所有节点的值都比它小
2.任何一个节点，如果它的右子树不为空，则右子树上所有节点的值都比它大
3.对于任意一个子树：左&amp;lt;根&amp;lt;右
查找效率与树的高度成反比。
二叉查找树（其实这是二叉树的遍历）的遍历分为： 1.深度优先遍历(Depth First Search) 对于一颗二叉树，深度优先搜索是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
1.前序遍历： 根节点----左子树----右子树 以上图为例，结果是：80，40，10，50，115，90，95，130
2.中序变量： 左子树----根节点----右子树 在二叉查找树中使用序遍历并且打印的时候，最后打印出的结果会是从小到大的
以上图为例，结果是：10，40，50，80，90，95，115，130
3.后序遍历： 左子树----右子树----根节点
以上图为例，结果是：10，50，40，95，90，130，115，80
2.广度优先遍历（Breadth-First Search） 从树的root开始，从上到下从从左到右遍历整个树的节点
1.层次遍历：按层次遍历 以上图为例，结果是：80，40，115，10，50，90，130，95
3.删除节点 1.删除叶子节点。直接删。不会破坏BST的结构
2.删除带有一个子节点的的节点。将待删除节点的左/右子树 赋值给 待删除节点的父节点的左/右子树
3.删除带两个子节点的节点
首先需要找到待删除节点的后继节点和该后继节点的父节点，（一个节点的后继节点是指，这个节点在中序遍历序列中的下一个节点，相应的，前驱节点是指这个节点在中序遍历序列中的上一个节点）。
由于二叉查找树的性质，如果将当前节点替换为左子树中最大的或者右子树中最小的一定不会破坏二叉查找树的结构。
下图是删除5号节点
四、平衡二叉查找树（AVL） 平衡二叉查找树：
在二叉查找树的基础上多了些限制：
1.所有叶子的深度趋于平衡
2.每个节点的左子树和右子树的深度差的绝对值不超过1
平衡二叉树是在二叉查找树上引入是为了解决二叉排序树的不平衡性导致时间复杂度大大下降 不平衡的二叉查找树可能会出现极端情况编程链表：
针对上面不平衡的二叉查找树调整成平衡树，主要是通过旋转最小失衡子树来完成。
1、平衡因子：左子树的高度减去右子树的高度。
2、失衡：每个结点的左右子树的高度之差的绝对值超过1
3、最小失衡子树：离新插入的节点最近的，平衡因子最小的子树称为最小失衡子树。
旋转： 左旋和右旋：
左旋：把“最小失衡根结点”的右孩子节点A“提上去”，使得原来的“最小失衡根结点”成为节点A的左孩子节点。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-01-11T20:57:17+08:00">
    <meta property="article:modified_time" content="2023-01-11T20:57:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【十二】数据结构之树、二叉树、二叉查找树、平衡二叉查找树AVL、红黑树、B树、B&#43;树简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、树</h2> 
<p><img alt="" class="has" height="415" src="https://images2.imgbox.com/ed/00/CR8mWbE0_o.png" width="867"></p> 
<blockquote> 
 <p>1.只有一个特殊节点，它没有父节点，它就是根节点</p> 
 <p>2.每一个非根节点有且只有一个父节点</p> 
 <p>3.每个节点包含多个指针指向其子节点</p> 
 <p>4.该例子有3层，40那一层，130那一层，10那一层，故该数的深度为3。</p> 
 <p>5.没有子节点的叫叶子节点。</p> 
 <p>6.拥有相同父节点的叫兄弟节点。</p> 
</blockquote> 
<h2>二、二叉树</h2> 
<p><img alt="" class="has" height="355" src="https://images2.imgbox.com/36/c9/SmpNPomE_o.png" width="524"></p> 
<p><strong>在树的基础上多了些限制条件：</strong></p> 
<blockquote> 
 <p>1.每个节点最多只能有2个子节点。</p> 
 <p>2.节点的子节点，分为左孩子节点和右孩子节点。</p> 
</blockquote> 
<h3>2.1 完全二叉树</h3> 
<p><img alt="" class="has" height="350" src="https://images2.imgbox.com/a8/1a/8CN8KJb5_o.png" width="535"></p> 
<p><strong>在二叉树的基础上多了一个限制：</strong></p> 
<blockquote> 
 <p>除最后一层外，若其余层都是满的，并且最后一层要么是满的，要么是在<strong><span style="color:#f33b45;">右边缺少</span></strong>连续若干节点</p> 
</blockquote> 
<h3>2.2 满二叉树</h3> 
<p><img alt="" class="has" height="268" src="https://images2.imgbox.com/27/f2/1rZuI23Y_o.png" width="492"></p> 
<p><strong>在二叉树的基础上多了两个限制：</strong></p> 
<blockquote> 
 <p>所有分支结点都存在左子树和右子树。</p> 
 <p>所有叶子结点都在同一层上。</p> 
</blockquote> 
<h2> 三、二叉查找树</h2> 
<p><img alt="" class="has" height="351" src="https://images2.imgbox.com/15/1f/wahas3P4_o.png" width="472"></p> 
<p><strong>在二叉树的基础上多了些限制条件</strong></p> 
<blockquote> 
 <p>1.任何一个节点，如果它的左子树不为空，则左子树上所有节点的值都比它小</p> 
 <p>2.任何一个节点，如果它的右子树不为空，则右子树上所有节点的值都比它大</p> 
 <p>3.对于任意一个子树：左&lt;根&lt;右</p> 
</blockquote> 
<p> 查找效率与树的高度成反比。</p> 
<h3><strong>二叉查找树（其实这是二叉树的遍历）的遍历分为：</strong></h3> 
<h4><strong>1.深度优先遍历</strong>(Depth First Search)</h4> 
<p>对于一颗二叉树，深度优先搜索是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p> 
<blockquote> 
 <p>1.前序遍历： 根节点----左子树----右子树  </p> 
 <p>以上图为例，结果是：80，40，10，50，115，90，95，130</p> 
 <p>2.中序变量： 左子树----根节点----右子树 <strong><span style="color:#f33b45;">在二叉查找树中使用序遍历并且打印的时候，最后打印出的结果会是从小到大的</span></strong></p> 
 <p>以上图为例，结果是：10，40，50，80，90，95，115，130</p> 
 <p>3.后序遍历： 左子树----右子树----根节点</p> 
 <p>以上图为例，结果是：10，50，40，95，90，130，115，80</p> 
</blockquote> 
<h4>2.广度优先遍历（Breadth-First Search）</h4> 
<p>从树的root开始，从上到下从从左到右遍历整个树的节点</p> 
<blockquote> 
 <p> 1.层次遍历：按层次遍历    </p> 
 <p>以上图为例，结果是：80，40，115，10，50，90，130，95</p> 
</blockquote> 
<h4><span style="color:#0d0016;">3.删除节点</span></h4> 
<blockquote> 
 <p>1.删除叶子节点。直接删。不会破坏BST的结构</p> 
 <p><img alt="" height="223" src="https://images2.imgbox.com/66/91/sM91jLCg_o.png" width="594"></p> 
 <p>2.删除带有一个子节点的的节点。将待删除节点的左/右子树 赋值给 待删除节点的父节点的左/右子树</p> 
 <p><img alt="" height="216" src="https://images2.imgbox.com/f7/56/y4w71Jtd_o.png" width="596"></p> 
 <p> 3.删除带两个子节点的节点</p> 
 <p>首先需要找到待删除节点的<strong>后继节点</strong>和该<strong>后继节点的父节点</strong>，（一个节点的后继节点是指，这个节点在中序遍历序列中的下一个节点，相应的，前驱节点是指这个节点在中序遍历序列中的上一个节点）。</p> 
 <p>由于二叉查找树的性质，如果将当前节点替换为左子树中最大的或者右子树中最小的一定不会破坏二叉查找树的结构。</p> 
 <p>下图是删除5号节点</p> 
 <p><img alt="" height="149" src="https://images2.imgbox.com/26/6b/R0mt9sXP_o.png" width="600"></p> 
 <p></p> 
</blockquote> 
<h2>四、平衡二叉查找树（AVL）</h2> 
<p><strong>平衡二叉查找树：</strong></p> 
<p><img alt="" class="has" height="187" src="https://images2.imgbox.com/53/e8/RtvzqRr2_o.png" width="360"></p> 
<p><strong>在二叉查找树的基础上多了些限制：</strong></p> 
<blockquote> 
 <p>1.所有叶子的深度趋于平衡</p> 
 <p>2.每个节点的左子树和右子树的深度差的绝对值不超过1</p> 
</blockquote> 
<p><strong><span style="color:#f33b45;">平衡二叉树是在二叉查找树上引入是为了解决二叉排序树的不平衡性导致时间复杂度大大下降 </span></strong></p> 
<p><strong>不平衡的二叉查找树可能会出现极端情况编程链表：</strong></p> 
<p><img alt="" class="has" height="380" src="https://images2.imgbox.com/1b/90/AEx2zIbi_o.png" width="412"></p> 
<p>针对上面不平衡的二叉查找树调整成平衡树，主要是通过旋转最小失衡子树来完成。</p> 
<blockquote> 
 <p>1、<strong>平衡因子</strong>：左子树的高度减去右子树的高度。</p> 
 <p><img alt="" height="295" src="https://images2.imgbox.com/c7/89/wKLWuDgy_o.png" width="672"><br> 2、<strong>失衡</strong>：每个结点的左右子树的<strong>高度之差的绝对值</strong>超过1</p> 
 <p>3、<strong>最小失衡子树</strong>：离新插入的节点最近的，平衡因子最小的子树称为最小失衡子树。</p> 
 <p></p> 
</blockquote> 
<p><strong>旋转：</strong> </p> 
<blockquote> 
 <p><strong>左旋和右旋</strong>：</p> 
 <p>左旋：把“最小失衡根结点”的右孩子节点A“提上去”，使得原来的“最小失衡根结点”成为节点A的左孩子节点。</p> 
 <p><img alt="" height="480" src="https://images2.imgbox.com/5c/0a/PHJRdNW3_o.png" width="702"></p> 
 <p></p> 
 <p>右旋：把“最小失衡根结点”的左孩子节点A“提上去”，使得原来的“最小失衡根结点”成为节点A的右孩子节点。</p> 
 <p><img alt="" height="450" src="https://images2.imgbox.com/bb/e9/kKXsGyM2_o.png" width="590"></p> 
 <p></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>插入节点</strong></span>时分四种情况，四种情况对应的旋转方法是不同的：</p> 
<p>例如对于被破坏平衡的节点 a 来说：</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:179px;">插入方式</td><td style="width:416px;">描述</td><td style="width:254px;">旋转方式</td></tr><tr><td style="width:179px;">LL型</td><td style="width:416px;"> <p>在a的<strong>左子树</strong>根节点的<strong>左子树</strong>上插入节点而破坏平衡</p> <p><img alt="" height="235" src="https://images2.imgbox.com/24/97/FmGiN9yt_o.png" width="286"></p> <p></p> </td><td style="width:254px;"> <p>右旋</p> <p></p> <p>LL型旋转的对象是“最小失衡根结点”，也就是结点5。</p> <p></p> <p>个人理解1：就是把“最小失衡根结点”的左子节点“提上去”。</p> <p></p> <p><img alt="" height="183" src="https://images2.imgbox.com/6b/0b/A4bUgSuJ_o.png" width="169"></p> <p></p> </td></tr><tr><td style="width:179px;">RR型</td><td style="width:416px;"> <p>在a的<strong>右子树</strong>根节点的<strong>右子树</strong>上插入节点而破坏平衡</p> <p><img alt="" height="235" src="https://images2.imgbox.com/97/7c/OrXjHhe1_o.png" width="299"></p> <p></p> </td><td style="width:254px;"> <p>左旋</p> <p></p> <p>RR型旋转的对象是“最小失衡根结点”，也就是结点2。</p> <p></p> <p>个人理解：所谓右旋转就是把“最小失衡根结点”的右子节点“提上去”。</p> <p><img alt="" height="166" src="https://images2.imgbox.com/88/9d/Facj9Sqf_o.png" width="164"></p> <p></p> </td></tr><tr><td style="width:179px;">LR型</td><td style="width:416px;"> <p>在a的<strong>左子树</strong>根节点的<strong>右子树</strong>上插入节点而破坏平衡</p> <p><img alt="" height="222" src="https://images2.imgbox.com/31/f9/E3p9yLpx_o.png" width="248"></p> <p></p> </td><td style="width:254px;"> <p>先RR旋转，再LL旋转。</p> <p></p> <p>第一步旋转对象是“最小失衡根结点”的左子节点，也就是结点2，对它进行RR型旋转。</p> <p>即是把2节点的右节点提上去。</p> <p><img alt="" height="210" src="https://images2.imgbox.com/ac/32/ftDsJspe_o.png" width="194"></p> <p></p> <p></p> <p>第二步旋转对象是“最小失衡根结点”，也就是结点5，对它进行LL型旋转。</p> <p>即是把节点5的左子节点提上去</p> <p><img alt="" height="163" src="https://images2.imgbox.com/7c/09/YCQYUPVz_o.png" width="145"></p> <p></p> </td></tr><tr><td style="width:179px;">RL型</td><td style="width:416px;"> <p>在a的<strong>右子树</strong>根节点的<strong>左子树</strong>上插入节点而破坏平衡</p> <p><img alt="" height="228" src="https://images2.imgbox.com/f5/cf/IQxcHkod_o.png" width="274"></p> <p></p> </td><td style="width:254px;"> <p>先LL旋转，再RR旋转。</p> <p></p> <p>第一步旋转对象是“最小失衡根结点”的右子节点，也就是结点5，对它进行LL型旋转。</p> <p>即是把5节点的左节点提上去。</p> <p><img alt="" height="198" src="https://images2.imgbox.com/5c/a7/UVGkAbn3_o.png" width="175"></p> <p></p> <p></p> <p>第二步旋转对象是“最小失衡根结点”，也就是结点2，对它进行RR型旋转。</p> <p>即是把节点2的右子节点提上去</p> <p><img alt="" height="145" src="https://images2.imgbox.com/a0/1c/kD5P5FeD_o.png" width="130"></p> <p></p> </td></tr></tbody></table> 
<p>以上面那个不平衡的二叉查找树为例：</p> 
<p>在有10和11时，再插入12</p> 
<p>本来二叉查找树是这样：</p> 
<p><img alt="" class="has" height="234" src="https://images2.imgbox.com/3d/e0/ouPfpLcm_o.png" width="248"></p> 
<p><strong>调整逻辑：</strong></p> 
<blockquote> 
 <p>这是在节点10的右子树根节点11的右子树上插入节点12，属于RR型，则此时，以10为根节点，将10的右子节点11提上去：</p> 
</blockquote> 
<p><img alt="" class="has" height="132" src="https://images2.imgbox.com/4d/a0/d9UzcQWM_o.png" width="201"></p> 
<p>然后插入13，并未导致失衡</p> 
<p><img alt="" class="has" height="191" src="https://images2.imgbox.com/ff/f8/bJ7MpdM4_o.png" width="271"></p> 
<p>然后插入14，变成了下图这样，导致失衡，需要旋转来调整</p> 
<p><img alt="" class="has" height="249" src="https://images2.imgbox.com/f9/36/GzD85dfv_o.png" width="319"></p> 
<p><strong> 调整逻辑：</strong></p> 
<blockquote> 
 <p>1.找离新插入的节点最近的平衡因子最小的失衡子树，即是12-&gt;13-&gt;14。</p> 
 <p>这里说一下是怎么找的，11的失衡因子是-2，12的失衡因子是-2，13的失衡因子是-1。所以最小失衡因子是-2，</p> 
 <p>由于12离新插入的节点最近，所以，最终选出来的离新插入的节点最近的平衡因子最小的失衡子树是12-&gt;13-&gt;14，是一个RR型。</p> 
 <p>2.以12为中心，将12的右子节点（即13）提上去：</p> 
</blockquote> 
<p><img alt="" class="has" height="195" src="https://images2.imgbox.com/c6/df/iepJUFmn_o.png" width="254"></p> 
<p> 最后插入15，又会导致失衡</p> 
<p><img alt="" class="has" height="270" src="https://images2.imgbox.com/2a/a0/bRXmfAa7_o.png" width="332"></p> 
<p><strong>调整逻辑：</strong> </p> 
<blockquote> 
 <p>1.找离新插入的节点最近的平衡因子最小的失衡子树，即是11-&gt;13-&gt;14-&gt;15。</p> 
 <p>这里说一下是怎么找的，11的失衡因子是-2，13的失衡因子是-1，14的失衡因子是-1。所以最小失衡因子是-2，</p> 
 <p>最终选出来的离新插入的节点最近的平衡因子最小的失衡子树是11-&gt;13-&gt;14-&gt;15。</p> 
 <p>是RR型</p> 
 <p>2.以11为中心，把11的右子节点13提上去</p> 
</blockquote> 
<p><img alt="" class="has" height="187" src="https://images2.imgbox.com/68/52/5PFwoWRE_o.png" width="360"></p> 
<p><strong><span style="color:#fe2c24;">删除节点时</span></strong></p> 
<p>删除节点的分类场景跟二叉查找树一样，删了以后如果破环了平衡，则做相应的旋转。</p> 
<p>例子可参考这篇<a href="https://blog.csdn.net/qq_21388535/article/details/105601270" title="AVL树删除，详细图解_Adsh的博客-CSDN博客_avl树删除">AVL树删除，详细图解_Adsh的博客-CSDN博客_avl树删除</a></p> 
<h2>五、2-3树 </h2> 
<p>一个节点下有2条链（2个孩子节点），叫2-节点（2-node），比如下图的R</p> 
<p>一个节点下有3条链（3个孩子节点），叫3-节点（3-node），比如下图的EJ</p> 
<p>节点的左链比节点小，节点的右链比节点大，节点的中链大小在该节点内的两个值之间</p> 
<p><img alt="" src="https://images2.imgbox.com/20/4c/6RkOKQNg_o.png"></p> 
<p> 2-3查找树的性质：</p> 
<blockquote> 
 <p>　　1）如果中序遍历2-3查找树，就可以得到排好序的序列；</p> 
 <p>　　2）<span style="color:#fe2c24;"><strong>在一个完全平衡的2-3查找树中</strong></span>，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）</p> 
</blockquote> 
<p>性质2）如下图所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/ad/66/myKWDvY3_o.png"></p> 
<p> 复杂度分析：</p> 
<p>　　2-3树的查找效率与树的高度是息息相关的。</p> 
<blockquote> 
 <p>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN<br> 在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN</p> 
</blockquote> 
<p>    距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。</p> 
<p>　　对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。</p> 
<p><strong>插入操作</strong></p> 
<p><img alt="" height="536" src="https://images2.imgbox.com/60/68/2A6fr6AD_o.png" width="621"></p> 
<p> 局部变换</p> 
<p> <img alt="" height="287" src="https://images2.imgbox.com/31/3e/iHVUMO83_o.png" width="746"></p> 
<p></p> 
<h2>六、红黑树</h2> 
<p></p> 
<p><a href="https://www.bilibili.com/video/BV1Q24y1y7pP/?spm_id_from=333.999.0.0" rel="nofollow" title="数据结构：用2-3树来理解红黑树_哔哩哔哩_bilibili">数据结构：用2-3树来理解红黑树_哔哩哔哩_bilibili</a></p> 
<p>直接实现2-3树比较复杂和麻烦，由此2-3树转变为红黑树</p> 
<p><img alt="" height="435" src="https://images2.imgbox.com/22/1d/peXPV2aZ_o.png" width="1086"></p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/4f/00/7BZmPHMf_o.png" width="1158"></p> 
<p>红棍指向的节点就是红色节点  </p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/bc/b5/WhVUOWWG_o.png" width="1048">红黑树定义</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/7b/22/pk2hhD6l_o.png" width="900"></p> 
<p> </p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/bc/1f/TjAoNRMu_o.png" width="731"></p> 
<p> </p> 
<p><strong><span style="color:#fe2c24;"> 红黑树旋转</span></strong></p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/1a/25/fYQh7P88_o.png" width="559"></p> 
<p><strong><span style="color:#fe2c24;">插入引发旋转</span></strong></p> 
<p>红色节点如果在右边则要通过左旋转给转到左边，红色节点只能在左边</p> 
<p><img alt="" height="375" src="https://images2.imgbox.com/a6/1e/5LVkRgtA_o.png" width="878"> </p> 
<p>新插入的节点只能是红色。</p> 
<p>如果一个节点A的两个孩子节点B.C都是红色，则变色：两个孩子节点B.C变为黑色，A变为红色</p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/56/9b/Kx7kOUZs_o.png" width="1070"></p> 
<p> <img alt="" height="241" src="https://images2.imgbox.com/bf/f4/byt1utE1_o.png" width="842"></p> 
<p><img alt="" height="688" src="https://images2.imgbox.com/72/1f/hagBR3C8_o.png" width="1091">  </p> 
<p>一个整体的例子</p> 
<p>插入4</p> 
<p><img alt="" height="655" src="https://images2.imgbox.com/4c/bb/QSclBxCU_o.png" width="1200"> </p> 
<p> </p> 
<h2>六、B树（B-Tree、<strong>Balance Tree</strong>）</h2> 
<p>B-树就是B树，不是读什么B减树。</p> 
<p><strong><span style="color:#f33b45;">平衡多叉查找树</span></strong></p> 
<p>B树的阶数表示一个节点最多可以有多少个孩子节点。比如3阶B树，那一个节点最多可以有3个孩子节点。2阶B树相当于平衡二叉查找树。</p> 
<p><strong>图示3阶B树</strong></p> 
<p><img alt="" class="has" height="474" src="https://images2.imgbox.com/f4/08/LTCZ5NFp_o.png" width="1055"></p> 
<blockquote> 
 <p>一个M阶的B树符合以下条件：</p> 
 <p>1.根节点至少有2个孩子节点</p> 
 <p>2.每个中间节点都包含<strong><span style="color:#f33b45;">k-1个元素</span></strong>和<strong><span style="color:#f33b45;">k个孩子</span></strong>，其中 m/2 &lt;= k &lt;= m</p> 
 <p>3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</p> 
 <p>4.所有的叶子结点都位于同一层。</p> 
 <p>5.每个<strong><span style="color:#f33b45;">节点</span></strong>中的<strong><span style="color:#f33b45;">元素</span></strong>从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</p> 
</blockquote> 
<p><strong>B树插入：</strong></p> 
<p> 比如以上方图示例子为例，插入一个25</p> 
<p>第三排第二个节点，已经有了2个元素，23和36了，不能再放元素进去了（3阶B树，每个节点内最多只能是3-1=2个元素）</p> 
<p>向上找，它的父节点，第二排第一个节点，也有两个元素20和40了，不能再放元素进去了。</p> 
<p>再向上找，它的父节点就是根节点，第一排第一个节点，里面只有一个元素，还能再放一个元素进去，把新增的25插入根节点，拆分节点23.36和节点20.40.使其符合（左边大于右边）最后变成：</p> 
<p><img alt="" class="has" height="325" src="https://images2.imgbox.com/10/36/XVlDnmgX_o.png" width="975"></p> 
<h2>七、B+树</h2> 
<p>MySQL的Innodb的BTree索引就是用B+树实现的</p> 
<p><strong><span style="color:#f33b45;">这里标红高亮：之前去一家公司面试，第一轮面试官死活给我说Java8的ConcurrentHashMap就用CAS就能实现线程安全</span></strong></p> 
<p><strong><span style="color:#f33b45;">第二轮，CTO给我说MySQL的Innodb的索引是用红黑树实现的。我有点怀疑人生。</span></strong></p> 
<p><strong>不用红黑树的原因：</strong></p> 
<blockquote> 
 <p>1.红黑树之类的这种平衡、近似平衡的二叉查找树，查找的效率跟树的高度相关。</p> 
 <p>2.数据库的索引是存在磁盘上的，需要考虑磁盘开销。用索引查找的时候不是把整个索引加到内存中，而是逐个加载磁盘页。<strong><span style="color:#f33b45;">一个磁盘页对应着索引树上的一个节点</span></strong>。</p> 
 <p>故：<strong><span style="color:#f33b45;">最坏的情况下，如果树高度为N，那么我们可以就要做N次磁盘IO开销。</span></strong></p> 
 <p>3.当B+树节点中元素的数量多的时候，虽然查询是比较次数比二叉查找树、红黑树多，但是和磁盘IO速度相比，内存多耗时这点点是可以忽略的。</p> 
</blockquote> 
<p> <img alt="" class="has" height="395" src="https://images2.imgbox.com/28/a6/Ecfei1yQ_o.png" width="873"></p> 
<p><strong>在B树的基础上：</strong></p> 
<blockquote> 
 <p>1.B+树包含2种类型的结点：<strong><span style="color:#f33b45;">内部结点</span></strong>（也称索引结点）和<strong><span style="color:#f33b45;">叶子结点</span></strong>。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。</p> 
 <p>2.B+树与B树最大的不同是<strong><span style="color:#f33b45;">内部结点不保存数据，只用于索引</span></strong>，MySQL的<strong><span style="color:#f33b45;">数据</span></strong>（或者说记录）都保存在<strong><span style="color:#f33b45;">叶子结点</span></strong>中。</p> 
 <p>3.<strong><span style="color:#f33b45;">每个叶子结点都存有相邻叶子结点的指针</span></strong>，叶子结点本身依<span style="color:#f33b45;"><strong>关键字（MySQL表中建索引的那一列的值）</strong></span>的大小形成一个顺序链接。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/feea0bba0c683020a981ea1db4df413b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">嵌入式系统——ARM架构及分类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0bea0da7ddb14a397ddfe3e25af1451/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python报错 SettingWithCopyWarning:  A value is trying to be set on a copy of a slice from a DataFrame ...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>