<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】顺序表和链表详解&amp;&amp;顺序表和链表的实现 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/a3f880ff977628a44a9906f3664779e9/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【数据结构】顺序表和链表详解&amp;&amp;顺序表和链表的实现">
  <meta property="og:description" content="主页：醋溜马桶圈-CSDN博客
专栏：数据结构_醋溜马桶圈的博客-CSDN博客
gitee：mnxcc (mnxcc) - Gitee.com
目录
1.线性表
1.1 顺序表
1.1.1 概念及结构
1.1.2 静态顺序表
1.1.3 动态顺序表
1.2 链表
1.2.1 链表的概念及结构
1.2.2 链表的分类 1.2.2.1 单向或者双向
1.2.2.2 带头或者不带头
1.2.2.3 循环或者非循环
1.3 顺序表和链表的区别
2.顺序表的实现
2.1 创建顺序表
2.2 基本的增删查改接口
2.2.1 顺序表初始化
2.2.2 顺序表的销毁
2.2.3 检查顺序表的容量
2.2.4 打印顺序表 2.2.5 顺序表的尾插
2.2.6 顺序表的头插
2.2.7 顺序表的尾删
2.2.8 顺序表的头删
2.2.9 任意位置的插入
2.2.10 任意位置的删除
2.2.11 顺序表的查找
2.3实现代码
2.3.1 SeqList.h
2.3.2 SeqList.c
3.单链表的实现
3.1 认识单链表
3.2 创建单链表
3.3 单链表的操作">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-20T10:50:11+08:00">
    <meta property="article:modified_time" content="2024-03-20T10:50:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】顺序表和链表详解&amp;&amp;顺序表和链表的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#38d8f0;"><strong>主页：</strong></span><a href="https://blog.csdn.net/m0_74722801?spm=1011.2415.3001.5343" title="醋溜马桶圈-CSDN博客">醋溜马桶圈-CSDN博客</a></p> 
 <p><span style="color:#ff9900;"><strong>专栏：</strong></span><a href="https://blog.csdn.net/m0_74722801/category_12495754.html" title="数据结构_醋溜马桶圈的博客-CSDN博客">数据结构_醋溜马桶圈的博客-CSDN博客</a></p> 
 <p><span style="color:#fe2c24;"><strong>gitee：</strong></span><a href="https://gitee.com/mnxcc" rel="nofollow" title="mnxcc (mnxcc) - Gitee.com">mnxcc (mnxcc) - Gitee.com</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E7%BA%BF%E6%80%A7%E8%A1%A8-toc" style="margin-left:0px;"><a href="#1.%E7%BA%BF%E6%80%A7%E8%A1%A8" rel="nofollow">1.线性表</a></p> 
<p id="1.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:40px;"><a href="#1.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">1.1 顺序表</a></p> 
<p id="1.1.1%20%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.1.1%20%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">1.1.1 概念及结构</a></p> 
<p id="1.1.2%C2%A0%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:80px;"><a href="#1.1.2%C2%A0%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">1.1.2 静态顺序表</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%911.1.3%20%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%911.1.3%20%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">1.1.3 动态顺序表</a></p> 
<p id="1.2%20%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#1.2%20%E9%93%BE%E8%A1%A8" rel="nofollow">1.2 链表</a></p> 
<p id="1.2.1%20%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.2.1%20%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">1.2.1 链表的概念及结构</a></p> 
<p id="1.2.2%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB%C2%A0-toc" style="margin-left:80px;"><a href="#1.2.2%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB%C2%A0" rel="nofollow">1.2.2 链表的分类 </a></p> 
<p id="1.2.2.1%20%E5%8D%95%E5%90%91%E6%88%96%E8%80%85%E5%8F%8C%E5%90%91-toc" style="margin-left:120px;"><a href="#1.2.2.1%20%E5%8D%95%E5%90%91%E6%88%96%E8%80%85%E5%8F%8C%E5%90%91" rel="nofollow">1.2.2.1 单向或者双向</a></p> 
<p id="1.2.2.2%20%E5%B8%A6%E5%A4%B4%E6%88%96%E8%80%85%E4%B8%8D%E5%B8%A6%E5%A4%B4-toc" style="margin-left:120px;"><a href="#1.2.2.2%20%E5%B8%A6%E5%A4%B4%E6%88%96%E8%80%85%E4%B8%8D%E5%B8%A6%E5%A4%B4" rel="nofollow">1.2.2.2 带头或者不带头</a></p> 
<p id="1.2.2.3%20%E5%BE%AA%E7%8E%AF%E6%88%96%E8%80%85%E9%9D%9E%E5%BE%AA%E7%8E%AF-toc" style="margin-left:120px;"><a href="#1.2.2.3%20%E5%BE%AA%E7%8E%AF%E6%88%96%E8%80%85%E9%9D%9E%E5%BE%AA%E7%8E%AF" rel="nofollow">1.2.2.3 循环或者非循环</a></p> 
<p id="1.3%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#1.3%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">1.3 顺序表和链表的区别</a></p> 
<p id="2.%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#2.%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2.顺序表的实现</a></p> 
<p id="2.1%20%E5%88%9B%E5%BB%BA%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.1%20%E5%88%9B%E5%BB%BA%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">2.1 创建顺序表</a></p> 
<p id="2.2%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#2.2%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E6%8E%A5%E5%8F%A3" rel="nofollow">2.2 基本的增删查改接口</a></p> 
<p id="2.2.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#2.2.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2.2.1 顺序表初始化</a></p> 
<p id="2.2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#2.2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">2.2.2 顺序表的销毁</a></p> 
<p id="2.2.3%20%E6%A3%80%E6%9F%A5%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%B9%E9%87%8F-toc" style="margin-left:80px;"><a href="#2.2.3%20%E6%A3%80%E6%9F%A5%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%B9%E9%87%8F" rel="nofollow">2.2.3 检查顺序表的容量</a></p> 
<p id="2.2.4%20%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8%C2%A0-toc" style="margin-left:80px;"><a href="#2.2.4%20%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8%C2%A0" rel="nofollow">2.2.4 打印顺序表 </a></p> 
<p id="2.2.5%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B0%BE%E6%8F%92-toc" style="margin-left:80px;"><a href="#2.2.5%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B0%BE%E6%8F%92" rel="nofollow">2.2.5 顺序表的尾插</a></p> 
<p id="2.2.6%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92-toc" style="margin-left:80px;"><a href="#2.2.6%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92" rel="nofollow">2.2.6 顺序表的头插</a></p> 
<p id="2.2.7%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B0%BE%E5%88%A0-toc" style="margin-left:80px;"><a href="#2.2.7%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B0%BE%E5%88%A0" rel="nofollow">2.2.7 顺序表的尾删</a></p> 
<p id="2.2.8%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A4%B4%E5%88%A0-toc" style="margin-left:80px;"><a href="#2.2.8%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A4%B4%E5%88%A0" rel="nofollow">2.2.8 顺序表的头删</a></p> 
<p id="2.2.9%20%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#2.2.9%20%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">2.2.9 任意位置的插入</a></p> 
<p id="2.2.10%20%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#2.2.10%20%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">2.2.10 任意位置的删除</a></p> 
<p id="2.2.11%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#2.2.11%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">2.2.11 顺序表的查找</a></p> 
<p id="2.3%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#2.3%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81" rel="nofollow">2.3实现代码</a></p> 
<p id="2.3.1%20SeqList.h-toc" style="margin-left:80px;"><a href="#2.3.1%20SeqList.h" rel="nofollow">2.3.1 SeqList.h</a></p> 
<p id="2.3.2%20SeqList.c-toc" style="margin-left:80px;"><a href="#2.3.2%20SeqList.c" rel="nofollow">2.3.2 SeqList.c</a></p> 
<p id="3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">3.单链表的实现</a></p> 
<p id="1.%E8%AE%A4%E8%AF%86%E5%8D%95%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#1.%E8%AE%A4%E8%AF%86%E5%8D%95%E9%93%BE%E8%A1%A8" rel="nofollow">3.1 认识单链表</a></p> 
<p id="2.%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8" rel="nofollow">3.2 创建单链表</a></p> 
<p id="3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C" rel="nofollow">3.3 单链表的操作</a></p> 
<p id="3.1%E6%89%93%E5%8D%B0%E5%8D%95%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#3.1%E6%89%93%E5%8D%B0%E5%8D%95%E9%93%BE%E8%A1%A8" rel="nofollow">3.3.1 打印单链表</a></p> 
<p id="3.2%E5%BC%80%E8%BE%9F%E6%96%B0%E7%A9%BA%E9%97%B4-toc" style="margin-left:80px;"><a href="#3.2%E5%BC%80%E8%BE%9F%E6%96%B0%E7%A9%BA%E9%97%B4" rel="nofollow">3.3.2 开辟新空间</a></p> 
<p id="3.3%E5%B0%BE%E6%8F%92-toc" style="margin-left:80px;"><a href="#3.3%E5%B0%BE%E6%8F%92" rel="nofollow">3.3.3 尾插</a></p> 
<p id="3.4%E5%A4%B4%E6%8F%92-toc" style="margin-left:80px;"><a href="#3.4%E5%A4%B4%E6%8F%92" rel="nofollow">3.3.4 头插</a></p> 
<p id="3.5%E5%B0%BE%E5%88%A0-toc" style="margin-left:80px;"><a href="#3.5%E5%B0%BE%E5%88%A0" rel="nofollow">3.3.5 尾删</a></p> 
<p id="3.6%E5%A4%B4%E5%88%A0-toc" style="margin-left:80px;"><a href="#3.6%E5%A4%B4%E5%88%A0" rel="nofollow">3.3.6 头删</a></p> 
<p id="3.7%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#3.7%E6%9F%A5%E6%89%BE" rel="nofollow">3.3.7 查找</a></p> 
<p id="3.8%E5%9C%A8pos%E5%89%8D%E9%9D%A2%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#3.8%E5%9C%A8pos%E5%89%8D%E9%9D%A2%E6%8F%92%E5%85%A5" rel="nofollow">3.3.8 在pos前面插入</a></p> 
<p id="3.9%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#3.9%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE" rel="nofollow">3.3.9 删除pos位置</a></p> 
<p id="3.10%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#3.10%E9%94%80%E6%AF%81" rel="nofollow">3.3.10 销毁</a></p> 
<p id="3.11%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#3.11%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5" rel="nofollow">3.3.11 在pos位置之后插入</a></p> 
<p id="%C2%A03.12%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E7%9A%84%E5%80%BC-toc" style="margin-left:80px;"><a href="#%C2%A03.12%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E7%9A%84%E5%80%BC" rel="nofollow">3.3.12 删除pos位置之后的值</a></p> 
<p id="4.%E6%80%BB%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#4.%E6%80%BB%E4%BB%A3%E7%A0%81" rel="nofollow">3.4 实现代码</a></p> 
<p id="SList.h-toc" style="margin-left:80px;"><a href="#SList.h" rel="nofollow">3.4.1 SList.h</a></p> 
<p id="SList.c-toc" style="margin-left:80px;"><a href="#SList.c" rel="nofollow">3.4.2 SList.c</a></p> 
<p id="4.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#4.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">4.带头双向循环链表的实现</a></p> 
<p id="4.1%20%E8%AE%A4%E8%AF%86%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#4.1%20%E8%AE%A4%E8%AF%86%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" rel="nofollow">4.1 认识带头双向循环链表</a></p> 
<p id="4.1.1%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#4.1.1%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" rel="nofollow">4.1.1 双向链表</a></p> 
<p id="%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" rel="nofollow">4.1.2 循环链表</a></p> 
<p id="%E5%B8%A6%E5%A4%B4%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E5%B8%A6%E5%A4%B4%E9%93%BE%E8%A1%A8" rel="nofollow">4.1.3 带头链表</a></p> 
<p id="%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" rel="nofollow">4.1.4 带头双向循环链表</a></p> 
<p id="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E4%B8%8D%E8%B6%B3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E4%B8%8D%E8%B6%B3%EF%BC%9A" rel="nofollow">4.1.5 双向链表的优势和不足</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E4%B8%8D%E8%B6%B3%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E4%B8%8D%E8%B6%B3%EF%BC%9A%C2%A0" rel="nofollow">4.1.6 顺序表的优势和不足</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" rel="nofollow">4.2 实现带头双向循环链表</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BA%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" rel="nofollow">4.2.1 创建带头双向循环链表</a></p> 
<p id="%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">4.2.2 初始化</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BA%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9" rel="nofollow">4.2.3 创建返回链表的头结点</a></p> 
<p id="%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8" rel="nofollow">4.2.4 打印链表</a></p> 
<p id="%C2%A0%E5%B0%BE%E6%8F%92-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%B0%BE%E6%8F%92" rel="nofollow">4.2.5 尾插</a></p> 
<p id="%E5%B0%BE%E5%88%A0-toc" style="margin-left:80px;"><a href="#%E5%B0%BE%E5%88%A0" rel="nofollow">4.2.6 尾删</a></p> 
<p id="%E5%A4%B4%E6%8F%92-toc" style="margin-left:80px;"><a href="#%E5%A4%B4%E6%8F%92" rel="nofollow">4.2.7 头插</a></p> 
<p id="%E5%A4%B4%E5%88%A0-toc" style="margin-left:80px;"><a href="#%E5%A4%B4%E5%88%A0" rel="nofollow">4.2.8 头删</a></p> 
<p id="%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#%E6%9F%A5%E6%89%BE" rel="nofollow">4.2.9 查找</a></p> 
<p id="%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E5%89%8D%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E5%89%8D%E6%8F%92%E5%85%A5" rel="nofollow">4.2.10 在pos位置前插入</a></p> 
<p id="%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE" rel="nofollow">4.2.11 删除pos位置</a></p> 
<p id="%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#%E9%94%80%E6%AF%81" rel="nofollow">4.2.12 销毁</a></p> 
<p id="%E6%80%BB%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E4%BB%A3%E7%A0%81" rel="nofollow">4.3 实现代码</a></p> 
<p id="ListNode.h-toc" style="margin-left:80px;"><a href="#ListNode.h" rel="nofollow">4.3.1 ListNode.h</a></p> 
<p id="ListNode.c-toc" style="margin-left:80px;"><a href="#ListNode.c" rel="nofollow">4.3.2 ListNode.c</a></p> 
<p id="test.c-toc" style="margin-left:0px;"><a href="#test.c" rel="nofollow">5.数组下标为什么从0开始</a></p> 
<p id="5.1%20%E5%8E%9F%E5%9B%A0-toc" style="margin-left:40px;"><a href="#5.1%20%E5%8E%9F%E5%9B%A0" rel="nofollow">5.1 原因</a></p> 
<p id="5.2%20%E6%8B%93%E5%B1%95-toc" style="margin-left:40px;"><a href="#5.2%20%E6%8B%93%E5%B1%95" rel="nofollow">5.2 拓展</a></p> 
<p id="6.%E7%8E%AF%E5%9E%8B%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#6.%E7%8E%AF%E5%9E%8B%E9%93%BE%E8%A1%A8" rel="nofollow">6.环型链表</a></p> 
<p id="6.1%20%E7%8E%AF%E5%9E%8B%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#6.1%20%E7%8E%AF%E5%9E%8B%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">6.1 环型链表是什么</a></p> 
<p id="6.2%20%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%88%A4%E6%96%AD%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#6.2%20%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%88%A4%E6%96%AD%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8" rel="nofollow">6.2 快慢指针判断环形链表</a></p> 
<p id="6.2.1%20%E6%80%9D%E8%80%83-toc" style="margin-left:80px;"><a href="#6.2.1%20%E6%80%9D%E8%80%83" rel="nofollow">6.2.1 思考</a></p> 
<p id="6.2.2%20%E6%8E%A8%E5%AF%BC%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#6.2.2%20%E6%8E%A8%E5%AF%BC%E6%80%9D%E8%B7%AF" rel="nofollow">6.2.2 推导思路</a></p> 
<p id="6.2.3%20%E7%BB%93%E8%AE%BA-toc" style="margin-left:80px;"><a href="#6.2.3%20%E7%BB%93%E8%AE%BA" rel="nofollow">6.2.3 结论</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E7%BA%BF%E6%80%A7%E8%A1%A8">1.线性表</h2> 
<p>线性表（linear list）是<strong>n个具有相同特性的数据元素</strong>的有限序列</p> 
<p>线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串..</p> 
<p>线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储：</p> 
<p><img alt="" height="459" src="https://images2.imgbox.com/3c/77/yVT1ROi4_o.png" width="1170"></p> 
<h3 id="1.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8">1.1 顺序表</h3> 
<h4 id="1.1.1%20%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">1.1.1 概念及结构</h4> 
<p>顺序表是用一段<strong>物理地址连续</strong>的存储单元依次存储数据元素的线性结构</p> 
<p>一般情况下<strong>采用数组存储</strong>，在数组上完成数据的增删查改</p> 
<p>顺序表一般可以分为：</p> 
<h4 id="1.1.2%C2%A0%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8">1.1.2 静态顺序表</h4> 
<p><strong>静态顺序表：使用定长数组存储元素</strong></p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%911.1.3%20%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8"><img alt="" height="602" src="https://images2.imgbox.com/5b/8e/7K30vTjA_o.png" width="738"><br><br> 1.1.3 动态顺序表</h4> 
<p><strong>动态顺序表：使用动态开辟的数组存储</strong></p> 
<p><img alt="" height="575" src="https://images2.imgbox.com/59/9b/OQQhu77z_o.png" width="706"></p> 
<h3 id="1.2%20%E9%93%BE%E8%A1%A8">1.2 链表</h3> 
<h4 id="1.2.1%20%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">1.2.1 链表的概念及结构</h4> 
<p>概念：链表是一种<strong>物理存储结构上非连续、非顺序</strong>的存储结构，数据元素的逻辑顺序是通过链表中的<strong>指针</strong>链接次序实现的</p> 
<p><strong>现实中</strong></p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/e3/84/rnwnpw79_o.png" width="695"></p> 
<p><strong>数据结构中</strong></p> 
<p><img alt="" height="182" src="https://images2.imgbox.com/05/74/ukBVnYsp_o.png" width="1124"></p> 
<p><strong>注意：</strong></p> 
<ol><li>从上图可以看出，链式结构在逻辑上是连续的，但在物理上不一定连续</li><li>现实中的结点一般都是从堆上申请出来的 </li><li>从堆上申请的空间，是按照一定的策略来分配的，两次申请的空间可能连续，也可能不连续</li></ol> 
<h4 id="1.2.2%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB%C2%A0">1.2.2 链表的分类 </h4> 
<p>实际中链表的结构非常多样，以下情况组合起来就有8种链表结构：</p> 
<h5 id="1.2.2.1%20%E5%8D%95%E5%90%91%E6%88%96%E8%80%85%E5%8F%8C%E5%90%91">1.2.2.1 单向或者双向</h5> 
<p><img alt="" height="182" src="https://images2.imgbox.com/28/2a/QVF50KBe_o.png" width="641"></p> 
<h5 id="1.2.2.2%20%E5%B8%A6%E5%A4%B4%E6%88%96%E8%80%85%E4%B8%8D%E5%B8%A6%E5%A4%B4">1.2.2.2 带头或者不带头</h5> 
<p><img alt="" height="182" src="https://images2.imgbox.com/d5/ef/Ep2DlfGz_o.png" width="641"></p> 
<h5 id="1.2.2.3%20%E5%BE%AA%E7%8E%AF%E6%88%96%E8%80%85%E9%9D%9E%E5%BE%AA%E7%8E%AF">1.2.2.3 循环或者非循环</h5> 
<p><img alt="" height="197" src="https://images2.imgbox.com/69/2a/qHAn6hLN_o.png" width="489"></p> 
<p><strong>虽然有这么多的链表的结构，但是我们实际中最常用还是两种结构： </strong></p> 
<p><strong>无头单向非循环链表</strong>：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。</p> 
<p><img alt="" height="135" src="https://images2.imgbox.com/a3/3e/jS2rwxyg_o.png" width="816"></p> 
<p><strong>带头双向循环链表</strong>：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向 循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了。</p> 
<p><img alt="" height="201" src="https://images2.imgbox.com/02/93/Xio9pmIy_o.png" width="1095"></p> 
<h3 id="1.3%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB">1.3 顺序表和链表的区别</h3> 
<p><img alt="" height="637" src="https://images2.imgbox.com/75/2c/R4ttwnyC_o.png" width="1015"></p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/d5/16/sNAF2cxi_o.png" width="945"></p> 
<p><a href="https://coolshell.cn/articles/20793.html" rel="nofollow" title="与程序员相关的CPU缓存知识 | 酷 壳 - CoolShell">与程序员相关的CPU缓存知识 | 酷 壳 - CoolShell</a></p> 
<h2 id="2.%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">2.顺序表的实现</h2> 
<h3 id="2.1%20%E5%88%9B%E5%BB%BA%E9%A1%BA%E5%BA%8F%E8%A1%A8"><strong>2.1 创建顺序表</strong></h3> 
<p><img alt="" height="294" src="https://images2.imgbox.com/47/5e/pjMIN6g2_o.png" width="623">​</p> 
<h3 id="2.2%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E6%8E%A5%E5%8F%A3">2.2 基本的增删查改接口</h3> 
<h4 id="2.2.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96">2.2.1 顺序表初始化</h4> 
<p>顺序表的初始化我们只需要讲指针置为空指针<br> 然后将当前数据元素个数和最大数据元素个数置为0<br> 到插入时我们便会动态开辟空间给指针a</p> 
<div> 
 <pre><code class="language-cs">//顺序表的初始化
void SLInit(SL* ps)
{
	ps-&gt;a = NULL;//置为空指针
	ps-&gt;size = 0;//数据个数为0
	ps-&gt;capacity = 0;//空间大小置为0
}</code></pre> 
</div> 
<h4 id="2.2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81">2.2.2 顺序表的销毁</h4> 
<div> 
 <pre><code class="language-cs">//顺序表的销毁
void SLDestroy(SL* ps)
{
	if (ps-&gt;a != NULL)
	{
		free(ps-&gt;a);
		ps-&gt;a = NULL;
		ps-&gt;size = 0;
		ps-&gt;capacity = 0;
	}
}</code></pre> 
</div> 
<h4 id="2.2.3%20%E6%A3%80%E6%9F%A5%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%B9%E9%87%8F">2.2.3 检查顺序表的容量</h4> 
<div> 
 <pre><code class="language-cs">//检查顺序表的容量
void SLCheckCapacity(SL* ps)
{
	if (ps-&gt;size == ps-&gt;capacity)
	{
		int newCapacity = ps-&gt;capacity = 0 ? 4 : ps-&gt;capacity * 2;
		SLDataType* tmp = realloc(ps-&gt;a, sizeof(SLDataType) * newCapacity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}
		ps-&gt;a = tmp;
		ps-&gt;capacity = newCapacity;
	}
}</code></pre> 
</div> 
<h4 id="2.2.4%20%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8%C2%A0">2.2.4 打印顺序表 </h4> 
<div> 
 <pre><code class="language-cs">//打印顺序表
void SLPrint(SL* ps)
{
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;a[i]);
	}
	printf("\n");
}</code></pre> 
</div> 
<h4 id="2.2.5%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B0%BE%E6%8F%92">2.2.5 顺序表的尾插</h4> 
<div> 
 <pre><code class="language-cs">//顺序表的尾插
void SLPushBack(SL* ps, SLDataType x)
{
	SLCheckCapacity(ps);
	ps-&gt;a[ps-&gt;size] = x;
	ps-&gt;size++;
}</code></pre> 
</div> 
<h4 id="2.2.6%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92">2.2.6 顺序表的头插</h4> 
<div> 
 <pre><code class="language-cs">//顺序表的头插
void SLPushFront(SL* ps, SLDataType x)
{
	SLCheckCapacity(ps);
	int end = ps-&gt;size - 1;
	while (end &gt;= 0)
	{
		ps-&gt;a[end + 1] = ps-&gt;a[end];
	}
	ps-&gt;a[0] = x;
	ps-&gt;size++;
}</code></pre> 
</div> 
<h4 id="2.2.7%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B0%BE%E5%88%A0">2.2.7 顺序表的尾删</h4> 
<div> 
 <pre><code class="language-cs">//顺序表的尾删
void SLPopBack(SL* ps)
{
	assert(ps-&gt;size &gt; 0);
	//ps-&gt;a[ps-&gt;size - 1] = -1;
	ps-&gt;size--;
}</code></pre> 
</div> 
<h4 id="2.2.8%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%A4%B4%E5%88%A0">2.2.8 顺序表的头删</h4> 
<div> 
 <pre><code class="language-cs">//顺序表的头删
void SLPopFront(SL* ps)
{
	//for (int i = 0; i &lt; ps-&gt;size; i++)
	//{
	//	ps-&gt;a[i] = ps-&gt;a[i + 1];
	//}
	//ps-&gt;size--;
	assert(ps);
	assert(ps-&gt;size &gt; 0);
	int begin = 1;
	while (begin &lt; ps-&gt;size)
	{
		ps-&gt;a[begin - 1] = ps-&gt;a[begin];
		++begin;
	}
	ps-&gt;size--;
}</code></pre> 
</div> 
<h4 id="2.2.9%20%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%8F%92%E5%85%A5">2.2.9 任意位置的插入</h4> 
<div> 
 <pre><code class="language-cs">//任意位置的插入
void SLInsert(SL* ps, int pos, SLDataType x)
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);
    SLCheckCapacity(ps);
	int end = ps-&gt;size - 1;
	while (end &gt;= pos)
	{
		ps-&gt;a[end + 1] = ps-&gt;a[end];
		--end;
	}
	ps-&gt;a[pos] = x;
	ps-&gt;size++;
}</code></pre> 
</div> 
<h4 id="2.2.10%20%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%88%A0%E9%99%A4">2.2.10 任意位置的删除</h4> 
<div> 
 <pre><code class="language-cs">//任意位置的删除
void SLErase(SL* ps, int pos)
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);
	int begin = pos;
	while (begin &lt; ps-&gt;size)
	{
		ps-&gt;a[begin] = ps-&gt;a[begin+1];
		++begin;
	}
	ps-&gt;size--;
}</code></pre> 
</div> 
<h4 id="2.2.11%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE">2.2.11 顺序表的查找</h4> 
<div> 
 <pre><code class="language-cs">//顺序表的查找
//找到返回下标，找不到返回-1
int SLFind(SL* ps, SLDataType x)
{
	assert(ps);
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		if (ps-&gt;a[i] == x)
		{
			return i;
		}
	}
	return -1;
}</code></pre> 
</div> 
<h3 id="2.3%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81">2.3实现代码</h3> 
<h4 id="2.3.1%20SeqList.h">2.3.1 SeqList.h</h4> 
<div> 
 <pre><code class="language-cs">#pragma once
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
typedef int SLDataType;
//顺序表的动态存储
typedef struct SeqList
{
	SLDataType* a;     //指向动态开辟的数组
	int size;           //有效元素个数
	int capacity;       //容量空间的大小
}SL;

//顺序表的初始化
void SLInit(SL* ps);
//顺序表的销毁
void SLDestroy(SL* ps);

//检查顺序表的容量
void SLCheckCapacity(SL* ps);
//打印顺序表
void SLPrint(SL* ps);


//顺序表的尾插
void SLPushBack(SL* ps, SLDataType x);
//顺序表的头插
void SLPushFront(SL* ps, SLDataType x);
//顺序表的尾删
void SLPopBack(SL* ps);
//顺序表的头删  
void SLPopFront(SL* ps);

//任意位置的插入
void SLInsert(SL* ps, int pos, SLDataType x);
//任意位置的删除
void SLErase(SL* ps, int pos);

//顺序表的查找
//找到返回下标，找不到返回-1
int SLFind(SL* ps, SLDataType x);
</code></pre> 
</div> 
<h4 id="2.3.2%20SeqList.c">2.3.2 SeqList.c</h4> 
<div> 
 <pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS 1
#include "SeqList.h"

//顺序表的初始化
void SLInit(SL* ps)
{
	ps-&gt;a = NULL;//置为空指针
	ps-&gt;size = 0;//数据个数为0
	ps-&gt;capacity = 0;//空间大小置为0
}
//顺序表的销毁
void SLDestroy(SL* ps)
{
	if (ps-&gt;a != NULL)
	{
		free(ps-&gt;a);
		ps-&gt;a = NULL;
		ps-&gt;size = 0;
		ps-&gt;capacity = 0;
	}
}
//检查顺序表的容量
void SLCheckCapacity(SL* ps)
{
	if (ps-&gt;size == ps-&gt;capacity)
	{
		int newCapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2;
		SLDataType* tmp = realloc(ps-&gt;a, sizeof(SLDataType) * newCapacity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}
		ps-&gt;a = tmp;
		ps-&gt;capacity = newCapacity;
	}
}
//打印顺序表
void SLPrint(SL* ps)
{
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;a[i]);
	}
	printf("\n");
}
//顺序表的尾插
void SLPushBack(SL* ps, SLDataType x)
{
	SLCheckCapacity(ps);
	ps-&gt;a[ps-&gt;size] = x;
	ps-&gt;size++;
}
//顺序表的头插
void SLPushFront(SL* ps, SLDataType x)
{
	SLCheckCapacity(ps);
	int end = ps-&gt;size - 1;
	while (end &gt;= 0)
	{
		ps-&gt;a[end + 1] = ps-&gt;a[end];
		--end;
	}
	ps-&gt;a[0] = x;
	ps-&gt;size++;
}
//顺序表的尾删
void SLPopBack(SL* ps)
{
	assert(ps-&gt;size &gt; 0);
	//ps-&gt;a[ps-&gt;size - 1] = -1;
	ps-&gt;size--;
}
//顺序表的头删
void SLPopFront(SL* ps)
{
	//for (int i = 0; i &lt; ps-&gt;size; i++)
	//{
	//	ps-&gt;a[i] = ps-&gt;a[i + 1];
	//}
	//ps-&gt;size--;
	assert(ps);
	assert(ps-&gt;size &gt; 0);
	int begin = 1;
	while (begin &lt; ps-&gt;size)
	{
		ps-&gt;a[begin - 1] = ps-&gt;a[begin];
		++begin;
	}
	ps-&gt;size--;
}
//任意位置的插入
void SLInsert(SL* ps, int pos, SLDataType x)
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);
	SLCheckCapacity(ps);
	int end = ps-&gt;size - 1;
	while (end &gt;= pos)
	{
		ps-&gt;a[end + 1] = ps-&gt;a[end];
		--end;
	}
	ps-&gt;a[pos] = x;
	ps-&gt;size++;
}
//任意位置的删除
void SLErase(SL* ps, int pos)
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);
	int begin = pos;
	while (begin &lt; ps-&gt;size)
	{
		ps-&gt;a[begin] = ps-&gt;a[begin+1];
		++begin;
	}
	ps-&gt;size--;
}
//顺序表的查找
//找到返回下标，找不到返回-1
int SLFind(SL* ps, SLDataType x)
{
	assert(ps);
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		if (ps-&gt;a[i] == x)
		{
			return i;
		}
	}
	return -1;
}</code></pre> 
</div> 
<h2 id="3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">3.单链表的实现</h2> 
<p><strong>顺序表存在下面的问题：</strong></p> 
<blockquote> 
 <ul><li><strong>尾插效率还不错，头插或中间插入删除，需要挪动数据，效率低</strong></li><li><strong>满了以后只能扩容，扩容是有一定的消耗的，扩容一般存在一定的空间浪费</strong></li></ul> 
</blockquote> 
<h3 id="1.%E8%AE%A4%E8%AF%86%E5%8D%95%E9%93%BE%E8%A1%A8">3.1 认识单链表</h3> 
<p><img alt="" height="484" src="https://images2.imgbox.com/16/b4/MEGrg11Y_o.png" width="895">​</p> 
<p>如果想要插入一个结点，就不需要挪动数据了，改指针的指向就可以了</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/24/da/Wd9zOZc9_o.png" width="492">​</p> 
<p>同样我们删除结点，直接将前一个结点的指针指向后一个结点就可以了</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/77/aa/BVN8CpJt_o.png" width="890">​</p> 
<p>首先我们还是从工程的角度去考虑，创建<strong>SList.h SList.c test.c</strong>三个文件</p> 
<p><img alt="" height="157" src="https://images2.imgbox.com/f2/54/PXjleNfg_o.png" width="209">​</p> 
<p><strong>SList.h放置函数的声明</strong></p> 
<p><strong>SList.c放置函数的定义</strong></p> 
<p><strong>test.c进行测试 </strong></p> 
<h3 id="2.%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8">3.2 创建单链表</h3> 
<p><img alt="" height="202" src="https://images2.imgbox.com/1c/46/WYpVFlIg_o.png" width="515">​</p> 
<h3 id="3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C">3.3 单链表的操作</h3> 
<h4 id="3.1%E6%89%93%E5%8D%B0%E5%8D%95%E9%93%BE%E8%A1%A8">3.3.1 打印单链表</h4> 
<div> 
 <pre><code class="language-cs">//打印单链表
//尽量不要动phead
void SLTPrint(SLNode* phead)
{
	SLNode* cur = phead;
	while (cur != NULL)
	{
		printf("%d-&gt;", cur-&gt;val);
		cur = cur-&gt;next;
	}
	printf("NULL\n");
}</code></pre> 
</div> 
<h4 id="3.2%E5%BC%80%E8%BE%9F%E6%96%B0%E7%A9%BA%E9%97%B4">3.3.2 开辟新空间</h4> 
<div> 
 <pre><code class="language-cs">//开辟新空间
SLNode* CreateNode(SLNDataType x)
{
	SLNode* newnode = (SLNode*)malloc(sizeof(SLNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		exit(-1);
	}
	newnode-&gt;val = x;
	newnode-&gt;next = NULL;
	return newnode;
}</code></pre> 
</div> 
<h4 id="3.3%E5%B0%BE%E6%8F%92">3.3.3 尾插</h4> 
<div> 
 <pre><code class="language-cs">//尾插
void SLTPushBack(SLNode** pphead, SLNDataType x)
{
	SLNode* newnode = CreateNode(x);
	if (*pphead == NULL)
	{
		*pphead = newnode;
	}
	else
	{
		SLNode* tail = *pphead;
		while (tail-&gt;next != NULL)
		{
			tail = tail-&gt;next;
		}
		tail-&gt;next = newnode;
	}
}</code></pre> 
</div> 
<h4 id="3.4%E5%A4%B4%E6%8F%92">3.3.4 头插</h4> 
<div> 
 <pre><code class="language-cs">//头插
void SLTPushFront(SLNode** pphead, SLNDataType x)
{
	SLNode* newnode = CreateNode(x);
	newnode-&gt;next = *pphead;
	*pphead = newnode;
}</code></pre> 
</div> 
<h4 id="3.5%E5%B0%BE%E5%88%A0">3.3.5 尾删</h4> 
<div> 
 <pre><code class="language-cs">//尾删
void SLTPopBack(SLNode** pphead)
{
	assert(*pphead);
	if ((*pphead)-&gt;next == NULL)
	{
		free(*pphead);
		*pphead = NULL;
	}
	else
	{
		SLNode* prev = NULL;
		SLNode* tail = *pphead;
		while (tail-&gt;next != NULL)
		{
			prev = tail;
			tail = tail-&gt;next;
		}
		free(tail);
		prev-&gt;next = NULL;
	}
}</code></pre> 
</div> 
<h4 id="3.6%E5%A4%B4%E5%88%A0">3.3.6 头删</h4> 
<div> 
 <pre><code class="language-cs">//头删
void SLTPopFront(SLNode** pphead)
{
	assert(*pphead)
		;
	SLNode* tmp = *pphead;
	*pphead = (*pphead)-&gt;next;
	free(tmp);
}</code></pre> 
</div> 
<h4 id="3.7%E6%9F%A5%E6%89%BE">3.3.7 查找</h4> 
<div> 
 <pre><code class="language-cs">//查找
SLNode* SLTFind(SLNode* phead, SLNDataType x)
{
	SLNode* cur = phead;
	while (cur)
	{
		if (cur-&gt;val == x)
		{
			return cur;
		}
		else
		{
			cur = cur-&gt;next;
		}
	}
	return NULL;
}</code></pre> 
</div> 
<h4 id="3.8%E5%9C%A8pos%E5%89%8D%E9%9D%A2%E6%8F%92%E5%85%A5">3.3.8 在pos前面插入</h4> 
<div> 
 <pre><code class="language-cs">//在pos前面插入
void SLTInsert(SLNode** pphead, SLNode* pos, SLNDataType x)
{
	assert(pphead);
	assert(pos);
	assert(*pphead);
	//assert((!pos &amp;&amp; !(*pphead)) || (pos &amp;&amp; (*pphead)));
	if (*pphead == pos)
	{
		SLTPushFront(pphead, x);
	}
	else
	{
		SLNode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		SLNode* newnode = CreateNode(x);
		prev-&gt;next = newnode;
		newnode-&gt;next = pos;
	}
}</code></pre> 
</div> 
<h4 id="3.9%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE">3.3.9 删除pos位置</h4> 
<div> 
 <pre><code class="language-cs">//删除pos位置
void SLTErase(SLNode** pphead, SLNode* pos)
{
	assert(pphead);
	assert(pos);
	assert(*pphead);
	if (*pphead == pos)
	{
		SLTPopFront(pphead);
	}
	else
	{
		SLNode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		prev-&gt;next = pos-&gt;next;
		free(pos);
		pos = NULL;
	}
}</code></pre> 
</div> 
<h4 id="3.10%E9%94%80%E6%AF%81">3.3.10 销毁</h4> 
<div> 
 <pre><code class="language-cs">//销毁
void SLTDestroy(SLNode** pphead)
{
	assert(pphead);
	SLNode* cur = *pphead;
	while (cur-&gt;next != NULL)
	{
		SLNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	*pphead = NULL;
}</code></pre> 
</div> 
<h4 id="3.11%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5">3.3.11 在pos位置之后插入</h4> 
<div> 
 <pre><code class="language-cs">// 单链表在pos位置之后插入x
void SLTInsertAfter(SLNode* pos, SLNDataType x)
{
	SLNode* newnode = CreateNode(x);
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
}</code></pre> 
</div> 
<h4 id="%C2%A03.12%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E7%9A%84%E5%80%BC">3.3.12 删除pos位置之后的值</h4> 
<div> 
 <pre><code class="language-cs">// 单链表删除pos位置之后的值
void SLTEraseAfter(SLNode* pos)
{
	assert(pos-&gt;next != NULL);
	pos-&gt;next = pos-&gt;next-&gt;next;
	free(pos-&gt;next);
	pos-&gt;next = NULL;
}</code></pre> 
</div> 
<h3 id="4.%E6%80%BB%E4%BB%A3%E7%A0%81">3.4 实现代码</h3> 
<h4 id="SList.h">3.4.1 SList.h</h4> 
<div> 
 <pre><code class="language-cs">#pragma once
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
//创建单链表
typedef int SLNDataType;
typedef struct SLNode
{
	SLNDataType val;
	struct SLNode* next;
}SLNode;

//打印单链表
//尽量不要动phead
void SLTPrint(SLNode* phead);
//开辟新空间
SLNode* CreateNode(SLNDataType x);

//尾插
void SLTPushBack(SLNode** pphead, SLNDataType x);
//头插
void SLTPushFront(SLNode** pphead, SLNDataType x);
//尾删
void SLTPopBack(SLNode** pphead);
//头删
void SLTPopFront(SLNode** pphead);

//查找
SLNode* SLTFind(SLNode* phead, SLNDataType x);
//在pos前面插入
void SLTInsert(SLNode** pphead, SLNode* pos, SLNDataType x);
//删除pos位置
void SLTErase(SLNode** pphead, SLNode* pos); 

// 单链表在pos位置之后插入x
void SLTInsertAfter(SLNode* pos, SLNDataType x);
// 单链表删除pos位置之后的值
void SLTEraseAfter(SLNode* pos);

//销毁
void SLTDestroy(SLNode** pphead);
</code></pre> 
</div> 
<h4 id="SList.c">3.4.2 SList.c</h4> 
<div> 
 <pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS 1
#include"SList.h"
//打印单链表
//尽量不要动phead
void SLTPrint(SLNode* phead)
{
	SLNode* cur = phead;
	while (cur != NULL)
	{
		printf("%d-&gt;", cur-&gt;val);
		cur = cur-&gt;next;
	}
	printf("NULL\n");
}
//开辟新空间
SLNode* CreateNode(SLNDataType x)
{
	SLNode* newnode = (SLNode*)malloc(sizeof(SLNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		exit(-1);
	}
	newnode-&gt;val = x;
	newnode-&gt;next = NULL;
	return newnode;
}
//尾插
void SLTPushBack(SLNode** pphead, SLNDataType x)
{
	SLNode* newnode = CreateNode(x);
	if (*pphead == NULL)
	{
		*pphead = newnode;
	}
	else
	{
		SLNode* tail = *pphead;
		while (tail-&gt;next != NULL)
		{
			tail = tail-&gt;next;
		}
		tail-&gt;next = newnode;
	}
}
//头插
void SLTPushFront(SLNode** pphead, SLNDataType x)
{
	SLNode* newnode = CreateNode(x);
	newnode-&gt;next = *pphead;
	*pphead = newnode;
}
//尾删
void SLTPopBack(SLNode** pphead)
{
	assert(*pphead);
	if ((*pphead)-&gt;next == NULL)
	{
		free(*pphead);
		*pphead = NULL;
	}
	else
	{
		SLNode* prev = NULL;
		SLNode* tail = *pphead;
		while (tail-&gt;next != NULL)
		{
			prev = tail;
			tail = tail-&gt;next;
		}
		free(tail);
		prev-&gt;next = NULL;
	}
}
//头删
void SLTPopFront(SLNode** pphead)
{
	assert(*pphead)
		;
	SLNode* tmp = *pphead;
	*pphead = (*pphead)-&gt;next;
	free(tmp);
}
//查找
SLNode* SLTFind(SLNode* phead, SLNDataType x)
{
	SLNode* cur = phead;
	while (cur)
	{
		if (cur-&gt;val == x)
		{
			return cur;
		}
		else
		{
			cur = cur-&gt;next;
		}
	}
	return NULL;
}
//在pos前面插入
void SLTInsert(SLNode** pphead, SLNode* pos, SLNDataType x)
{
	assert(pphead);
	assert(pos);
	assert(*pphead);
	//assert((!pos &amp;&amp; !(*pphead)) || (pos &amp;&amp; (*pphead)));
	if (*pphead == pos)
	{
		SLTPushFront(pphead, x);
	}
	else
	{
		SLNode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		SLNode* newnode = CreateNode(x);
		prev-&gt;next = newnode;
		newnode-&gt;next = pos;
	}
}
//删除pos位置
void SLTErase(SLNode** pphead, SLNode* pos)
{
	assert(pphead);
	assert(pos);
	assert(*pphead);
	if (*pphead == pos)
	{
		SLTPopFront(pphead);
	}
	else
	{
		SLNode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		prev-&gt;next = pos-&gt;next;
		free(pos);
		pos = NULL;
	}
}
// 单链表在pos位置之后插入x
void SLTInsertAfter(SLNode* pos, SLNDataType x)
{
	SLNode* newnode = CreateNode(x);
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
}
// 单链表删除pos位置之后的值
void SLTEraseAfter(SLNode* pos)
{
	assert(pos-&gt;next != NULL);
	pos-&gt;next = pos-&gt;next-&gt;next;
	free(pos-&gt;next);
	pos-&gt;next = NULL;
}
//销毁
void SLTDestroy(SLNode** pphead)
{
	assert(pphead);
	SLNode* cur = *pphead;
	while (cur-&gt;next != NULL)
	{
		SLNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	*pphead = NULL;
}
</code></pre> 
</div> 
<h2 id="4.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">4.带头双向循环链表的实现</h2> 
<h3 id="4.1%20%E8%AE%A4%E8%AF%86%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">4.1 认识带头双向循环链表</h3> 
<h4 id="4.1.1%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">4.1.1 双向链表</h4> 
<p><img alt="" height="161" src="https://images2.imgbox.com/51/2b/G0e4gHkT_o.png" width="734">​</p> 
<p>我们之前认学习的单链表，是包含一个next指针指向下一个结点，而双向链表既有next指针，又有一个前指针指向前一个结点</p> 
<h4 id="%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">4.1.2 循环链表</h4> 
<p><img alt="" height="137" src="https://images2.imgbox.com/5b/3a/OGCvhe53_o.png" width="665">​</p> 
<p>循环链表就是最后一个结点的next不指向NULL，指向第一个结点</p> 
<h4 id="%E5%B8%A6%E5%A4%B4%E9%93%BE%E8%A1%A8">4.1.3 带头链表</h4> 
<p>带头链表就是带哨兵位的头结点head，头结点不存数据</p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/9a/5a/5ts86gST_o.png" width="636">​</p> 
<h4 id="%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">4.1.4 带头双向循环链表</h4> 
<blockquote> 
 <ol><li><strong>无头单向非循环链表</strong>：<strong>结构简单</strong>，一般不会单独用来存数据。实际中更多是作为<strong>其他数据结构的子结构</strong>，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。</li><li><strong>带头双向循环链表</strong>：<strong>结构最复杂</strong>，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单</li></ol> 
</blockquote> 
<p><img alt="" height="210" src="https://images2.imgbox.com/ed/f0/zH8dh2Xn_o.png" width="731">​</p> 
<h4 id="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E4%B8%8D%E8%B6%B3%EF%BC%9A">4.1.5 双向链表的优势和不足</h4> 
<blockquote> 
 <p><strong>双向链表的优势</strong>：</p> 
 <ul><li>任意位置插入删除都是O(1)</li><li>按需申请释放，合理利用空间，不存在浪费</li></ul> 
 <p><strong>问题</strong>：</p> 
 <ul><li>下标的随机访问不方便O(N)</li></ul> 
</blockquote> 
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E4%B8%8D%E8%B6%B3%EF%BC%9A%C2%A0">4.1.6 顺序表的优势和不足</h4> 
<blockquote> 
 <p><strong>顺序表的优势</strong>：</p> 
 <ul><li>支持下标的随机访问O(1)</li></ul> 
 <p><strong>问题</strong>：</p> 
 <ul><li>头插或中间插入的效率低O(N)</li><li>空间不够需要扩容，有一定的消耗，且可能存在一定的空间浪费</li><li>只适合尾插尾删</li></ul> 
</blockquote> 
<h3 id="%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">4.2 实现带头双向循环链表</h3> 
<p>同样我们创建三个文件来实现：</p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/67/f5/KDZT5yq6_o.png" width="184">​</p> 
<h4 id="%E5%88%9B%E5%BB%BA%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">4.2.1 创建带头双向循环链表</h4> 
<p>我们在结构体中定义val存数据，prev指向前一个结点，next指向下一个结点</p> 
<p><img alt="" height="211" src="https://images2.imgbox.com/9c/6d/poNKJrIz_o.png" width="391">​</p> 
<h4 id="%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96">4.2.2 初始化</h4> 
<p>让phead-&gt;next和phead-&gt;prev都指向phead，给phead-&gt;val赋值为-1，最后返回phead</p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/48/36/pzfnx3G5_o.png" width="462">​</p> 
<h4 id="%E5%88%9B%E5%BB%BA%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9">4.2.3 创建返回链表的头结点</h4> 
<p><img alt="" height="407" src="https://images2.imgbox.com/5c/c3/RfT3GvcS_o.png" width="826">​</p> 
<h4 id="%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">4.2.4 打印链表</h4> 
<p><img alt="" height="361" src="https://images2.imgbox.com/49/44/9f8qg5SO_o.png" width="550">​</p> 
<h4 id="%C2%A0%E5%B0%BE%E6%8F%92">4.2.5 尾插</h4> 
<p><img alt="" height="339" src="https://images2.imgbox.com/bc/d6/FYNOOJei_o.png" width="636">​</p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/4b/da/ggt29KEK_o.png" width="602">​</p> 
<h4 id="%E5%B0%BE%E5%88%A0">4.2.6 尾删</h4> 
<p><img alt="" height="214" src="https://images2.imgbox.com/4f/c8/Uwk1xJa8_o.png" width="705">​</p> 
<p><img alt="" height="295" src="https://images2.imgbox.com/2a/fa/SHf0FES0_o.png" width="516">​</p> 
<h4 id="%E5%A4%B4%E6%8F%92">4.2.7 头插</h4> 
<p><img alt="" height="305" src="https://images2.imgbox.com/76/df/pKjjrzQO_o.png" width="606">​</p> 
<p><img alt="" height="396" src="https://images2.imgbox.com/21/66/8ASpzvKt_o.png" width="851">​</p> 
<h4 id="%E5%A4%B4%E5%88%A0">4.2.8 头删</h4> 
<p><img alt="" height="197" src="https://images2.imgbox.com/ff/3f/62xsudjT_o.png" width="510">​</p> 
<p>头结点不能删！！！</p> 
<p>所以我们要assert(phead-&gt;next != phead)</p> 
<p><img alt="" height="426" src="https://images2.imgbox.com/7e/8c/ahlGIs76_o.png" width="711">​</p> 
<h4 id="%E6%9F%A5%E6%89%BE">4.2.9 查找</h4> 
<p><img alt="" height="482" src="https://images2.imgbox.com/86/67/uRUln3g8_o.png" width="737">​</p> 
<h4 id="%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E5%89%8D%E6%8F%92%E5%85%A5">4.2.10 在pos位置前插入</h4> 
<p><img alt="" height="232" src="https://images2.imgbox.com/f7/fe/iWnDDjLr_o.png" width="544">​</p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/55/76/NEsQ98FW_o.png" width="689">​</p> 
<blockquote> 
 <p>特殊情况：</p> 
 <ul><li>LTInsert(phead-&gt;next,x)就是头插</li><li>LTInsert(phead,x)就是尾插</li></ul> 
</blockquote> 
<p><img alt="" height="217" src="https://images2.imgbox.com/30/b8/sJMr15bc_o.png" width="501">​</p> 
<p><img alt="" height="201" src="https://images2.imgbox.com/f3/f2/xsvimUk5_o.png" width="580">​</p> 
<h4 id="%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE">4.2.11 删除pos位置</h4> 
<p><img alt="" height="154" src="https://images2.imgbox.com/28/e3/FZzYoPyb_o.png" width="541">​</p> 
<p><img alt="" height="295" src="https://images2.imgbox.com/4f/9c/TkZJwyog_o.png" width="480">​</p> 
<blockquote> 
 <p>特殊情况：</p> 
 <ul><li>LTErase(phead-&gt;next)就是头删</li><li>LTErase(phead-&gt;prev)就是尾删</li></ul> 
</blockquote> 
<p><img alt="" height="207" src="https://images2.imgbox.com/70/9b/5pQNaRzW_o.png" width="565">​</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/4e/63/FJdaHLMK_o.png" width="555">​</p> 
<h4 id="%E9%94%80%E6%AF%81">4.2.12 销毁</h4> 
<p><img alt="" height="376" src="https://images2.imgbox.com/80/ce/LUxtnURW_o.png" width="540">​</p> 
<h3 id="%E6%80%BB%E4%BB%A3%E7%A0%81">4.3 实现代码</h3> 
<h4 id="ListNode.h">4.3.1 ListNode.h</h4> 
<div> 
 <pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
typedef int LTDataType;
typedef struct ListNode
{
	LTDataType val;
	struct ListNode* prev;
	struct ListNode* next;
}LTNode;

//初始化
LTNode* LTInit();
//创建返回链表的头结点.
LTNode* CreateLTNode(LTDataType x);
//打印
void LTPrint(LTNode* phead);

//尾插
void LTPushBack(LTNode* phead, LTDataType x);
//尾删
void LTPopBack(LTNode* phead);
//头插
void LTPushFront(LTNode* phead, LTDataType x);
//头删
void LTPopFront(LTNode* phead);
//查找
LTNode* LTFind(LTNode* phead, LTDataType x);
//在pos位置前插入
void LTInsert(LTNode* pos, LTDataType x);
//删除pos位置
void LTErase(LTNode* pos);
//销毁
void LTDestroy(LTNode* phead);</code></pre> 
</div> 
<h4 id="ListNode.c">4.3.2 ListNode.c</h4> 
<div> 
 <pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"ListNode.h"
//初始化
LTNode* LTInit()
{
	LTNode* phead = CreateLTNode(-1);
	phead-&gt;next = phead;
	phead-&gt;prev = phead;
	return phead;
}
//创建返回链表的头结点.
LTNode* CreateLTNode(LTDataType x)
{
	LTNode* newnode = (LTNode*)malloc(sizeof(LTNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		exit(-1);
	}
	newnode-&gt;val = x;
	newnode-&gt;next = NULL;
	newnode-&gt;prev = NULL;
	return newnode;
}
//打印
void LTPrint(LTNode* phead)
{
	assert(phead);
	LTNode* cur = phead-&gt;next;
	printf("哨兵位");
	while (cur != phead)
	{
		printf("%d&lt;=&gt;", cur-&gt;val);
		cur = cur-&gt;next;
	}
	printf("哨兵位\n");
}
//尾插
void LTPushBack(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* tail = phead-&gt;prev;
	LTNode* newnode = CreateLTNode(x);
	tail-&gt;next = newnode;
	newnode-&gt;prev = tail;
	phead-&gt;prev = newnode;
	newnode-&gt;next = phead;
}
//尾删
void LTPopBack(LTNode* phead)
{
	assert(phead);
	assert(phead-&gt;next != phead);
	LTNode* tail = phead-&gt;prev;
	LTNode* tailPrev = tail-&gt;prev;
	free(tail);
	tailPrev-&gt;next = phead;
	phead-&gt;prev = tailPrev;
}
//头插
void LTPushFront(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* newnode = CreateLTNode(x);
	LTNode* first = phead-&gt;next;
	newnode-&gt;next = first;
	first-&gt;prev = newnode;
	phead-&gt;next = newnode;
	newnode-&gt;prev = phead;
}
//头删
void LTPopFront(LTNode* phead)
{
	assert(phead);
	assert(phead-&gt;next != phead);
	LTNode* first = phead-&gt;next;
	LTNode* second = first-&gt;next;
	phead-&gt;next = second;
	second-&gt;prev = phead;
	free(first);
	first = NULL;
}
//查找
LTNode* LTFind(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* cur = phead-&gt;next;
	while (cur != phead)
	{
		if (cur-&gt;val == x)
		{
			return cur;
		}
		cur = cur-&gt;next;
	}
	return NULL;
}
//在pos位置前插入
void LTInsert(LTNode* pos, LTDataType x)
{
	assert(pos);
	LTNode* newnode = CreateLTNode(x);
	LTNode* posprev = pos-&gt;prev;
	posprev-&gt;next = newnode;
	newnode-&gt;prev = posprev;
	newnode-&gt;next = pos;
	pos-&gt;prev = newnode;
}
//删除pos位置
void LTErase(LTNode* pos)
{
	assert(pos);
	LTNode* posprev = pos-&gt;prev;
	LTNode* posnext = pos-&gt;next;
	posprev-&gt;next = posnext;
	posnext-&gt;prev = posprev;
	free(pos);
	pos = NULL;
}
//销毁
void LTDestroy(LTNode* phead)
{
	assert(phead);
	LTNode* cur = phead-&gt;next;
	while (cur != phead)
	{
		LTNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	free(phead);
	phead = NULL;
}</code></pre> 
</div> 
<h2 id="test.c">5.数组下标为什么从0开始</h2> 
<p> 我们在学习数组时会有这个疑问：</p> 
<p>数组元素的下标<strong>为什么从0开始而不从1开始呢？</strong></p> 
<p>从1开始更符合我们的日常习惯，比如生活中我们通常说第1个，而不是第0个</p> 
<h3 id="5.1%20%E5%8E%9F%E5%9B%A0">5.1 原因</h3> 
<p>对于数组元素的访问<strong>在操作系统层</strong>其实就是对<strong>特定内存偏移量</strong>的数据的访问</p> 
<p>换而言之即如果想要访问一个数组的某一个元素的值那么首先就要计算它的地址偏移量</p> 
<p>其大概的公式为:</p> 
<pre><code class="language-cpp">a[k]_adress = base_address + k*type_size ;</code></pre> 
<p>倘若数组下标是从1开始那么地址计算公式即会转变为:</p> 
<pre><code class="language-cpp">a[k]_adress = base_address + (k-1)*type_size ;</code></pre> 
<p> 这对于CPU来说多了一次减法操作</p> 
<blockquote> 
 <p>简单一句话: <strong>就是为了方便 计算出每个元素的具体内存地址</strong></p> 
</blockquote> 
<p>因为<a href="http://www.qingzhouquanzi.com/277.html" rel="nofollow" title="数组">数组</a>变量 <strong>实际上在内存上储存的是这个数组变量中第一个元素的的首地址</strong>,而系统在取数组中某个元素的值时,必须要得到具体的那个元素的地址才能获取到对应的值</p> 
<p><strong>具体每个元素的内存地址 = 数组变量首地址 + 下标 x 每个元素占用的字节数</strong></p> 
<p>比如:</p> 
<blockquote> 
 <p><strong> int a[5]={10,11,12,13,14}</strong></p> 
</blockquote> 
<p>因为 int每个元素占用<strong>4</strong>个字节,所以 数组中每个相邻的元素内存地址都相差4,</p> 
<p>那么每个元素的地址就等于<strong>前一个元素的地址 </strong>+ 4</p> 
<ul><li>a[0] 的内存地址    =    a的地址 + 0 * 4  (第一个元素的地址计算结果  跟数组的首地址一样)</li><li>a[1] 的内存地址    =    a的地址 + 1 * 4     (下标是1,内存地址就就是首地址 偏移 4字节)</li><li>a[2] 的内存地址    =    a的地址 + 2 * 4    (下标是2,内存地址就首地址 偏移 8字节)</li><li>..........</li><li>a[5]的内存地址    =    a的地址 + 5 * 4   (下标是5  内存地址就是首地址 偏移 20字节)</li></ul> 
<p><strong>如果从1开始 就要减去1,多一步运算,效率自然不让直接点高</strong></p> 
<p>所以<a href="http://www.qingzhouquanzi.com/277.html" rel="nofollow" title="数组的索引">数组的索引</a>(下标)从0开始是为了<strong>方便计算每个元素的地址</strong></p> 
<p>如果从1开始的话，运算起来没有从0开始方便</p> 
<p>所以，大部分编程语言数组索引都是从0开始</p> 
<h3 id="5.2%20%E6%8B%93%E5%B1%95" style="background-color:transparent;">5.2 拓展</h3> 
<p><a href="https://www.zhihu.com/question/594856209/answer/3267801958" rel="nofollow" title="为什么计算机语言中的下标都是从0开始的？ - 知乎 (zhihu.com)">为什么计算机语言中的下标都是从0开始的？ - 知乎 (zhihu.com)</a></p> 
<h2 id="6.%E7%8E%AF%E5%9E%8B%E9%93%BE%E8%A1%A8" style="background-color:transparent;">6.环型链表</h2> 
<h3 id="6.1%20%E7%8E%AF%E5%9E%8B%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88">6.1 环型链表是什么</h3> 
<p> 尾结点不指向NULL，指向头就是循环链表</p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/54/86/sRGy8Etv_o.png" width="591"></p> 
<p>那么带环链表就意味着尾结点的next可以指向链表的任意一个结点，甚至可以指向他自己</p> 
<p><img alt="" height="306" src="https://images2.imgbox.com/66/94/JkjVvWVc_o.png" width="460"></p> 
<p>这里我们的算法思路唯一靠谱的还是快慢指针</p> 
<p>slow一次走一步，fast一次走两步，当slow走到中间的时候，fast一定入环了，如果fast指向NULL，则该链表无环</p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/f3/83/ww2TXy6A_o.png" width="555"></p> 
<p>当slow再走一半也就入环了，这个时候，由于slow走的慢，fast走的快，所以fast和slow最终会相遇的</p> 
<p><img alt="" height="422" src="https://images2.imgbox.com/36/d1/ChToSMeK_o.png" width="491"></p> 
<h3 id="6.2%20%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%88%A4%E6%96%AD%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8" style="background-color:transparent;">6.2 快慢指针判断环形链表</h3> 
<p>我们在前面文章中写过用快慢指针判断链表是否带环：</p> 
<p><a href="https://blog.csdn.net/m0_74722801/article/details/134524029?spm=1001.2014.3001.5501" title="leetcode：环形链表-CSDN博客">leetcode：环形链表-CSDN博客</a></p> 
<p>我们用的是slow指针一次走一步，fast指针一次走两步，当slow入环后开始了追击，每走一次距离缩短1，最终就会相遇</p> 
<h4 id="6.2.1%20%E6%80%9D%E8%80%83">6.2.1 思考</h4> 
<p>但是我们思考一个问题：<strong>如果slow一次走一步，fast一次走三步，会不会相遇呢？</strong></p> 
<p>思考这个问题我们可以做一个假设：</p> 
<p>假设环的长度是C，假设slow进环时，fast与slow之间的距离为N</p> 
<h4 id="6.2.2%20%E6%8E%A8%E5%AF%BC%E6%80%9D%E8%B7%AF">6.2.2 推导思路</h4> 
<p>接着我们可以推一下：</p> 
<p>如果slow一次走一步，fast一次走三步，每次追击距离缩小2</p> 
<p><img alt="" height="589" src="https://images2.imgbox.com/39/cf/6Y3RxyiI_o.png" width="682"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p>所以我们可以得出初步的结论：</p> 
<ol><li><strong>如果</strong>N是偶数，就直接追上了</li><li><strong>如果</strong>N是奇数，C是奇数，第一轮错过了，第二轮就追上了</li><li><strong>如果</strong>N是奇数，C是偶数，就永远追不上</li></ol> 
<p>结论的第三条其实条件是不成立的，我们画图推一下：</p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/22/03/2ZufmFwr_o.png" width="834"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p>所以这里我们就能得到一个结论</p> 
<p>如果N是奇数，C是偶数，这个等式的条件是不成立的，所以不可能出第三种情况</p> 
<h4 id="6.2.3%20%E7%BB%93%E8%AE%BA">6.2.3 结论</h4> 
<p>所以我们可以得出最终的结论：</p> 
<blockquote> 
 <ol><li>如果N是偶数，就直接追上了</li><li>如果N是奇数，C是奇数，第一轮错过了，第二轮就追上了</li><li>不可能出现N是奇数，C是偶数的情况</li></ol> 
</blockquote> 
<p>所以<strong>如果slow一次走一步，fast一次走三步，一定能追上</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e213e50204718b19b2fc2ced3d53c3a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">啥是大语言模型LLM</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/015b3bd000d6eb1bdf5f00c14702178f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp通过script引入外部sdk的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>