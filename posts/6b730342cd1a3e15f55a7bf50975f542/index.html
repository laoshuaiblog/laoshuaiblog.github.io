<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>go mod常用命令 以及 常见问题 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/6b730342cd1a3e15f55a7bf50975f542/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="go mod常用命令 以及 常见问题">
  <meta property="og:description" content="最近接触到go mod，网上查了查资料，这里记录一下。 1 介绍 1.1、go mod是什么 go mod 是Golang 1.11 版本引入的官方包（package）依赖管理工具，用于解决之前没有地方记录依赖包具体版本的问题，方便依赖包的管理。
之前Golang 主要依靠vendor和GOPATH来管理依赖库，vendor相对主流，但现在官方更提倡go mod。
1.2、go mod初始化及使用 下载官方包1.11(及其以上版本将会自动支持gomod) 默认GO111MODULE=auto(auto是指如果在gopath下不启用mod)
Golang 提供一个环境变量 GO111MODULE 来设置是否使用mod，它有3个可选值，分别是off, on, auto（默认值），具体含义如下：
off: GOPATH mode，查找vendor和GOPATH目录on：module-aware mode，使用 go module，忽略GOPATH目录auto：如果当前目录不在$GOPATH 并且 当前目录（或者父目录）下有go.mod文件，则使用 GO111MODULE， 否则仍旧使用 GOPATH mode。 修改 GO111MODULE 的值的语句是：set GO111MODULE=on 。
在使用模块的时候， GOPATH 是无意义的，不过它还是会把下载的依赖储存在 GOPATH/src/mod 中，也会把 go install 的结果放在 GOPATH/bin（如果 GOBIN 不存在的话）
go mod download 下载模块到本地缓存，缓存路径是 $GOPATH/pkg/mod/cachego mod edit 是提供了命令版编辑 go.mod 的功能，例如 go mod edit -fmt go.mod 会格式化 go.modgo mod graph 把模块之间的依赖图显示出来go mod init 初始化模块（例如把原本dep管理的依赖关系转换过来）go mod tidy 增加缺失的包，移除没用的包go mod vendor 把依赖拷贝到 vendor/ 目录下go mod verify 确认依赖关系go mod why 解释为什么需要包和模块 注意有几个坑的地方：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-07-25T11:15:30+08:00">
    <meta property="article:modified_time" content="2019-07-25T11:15:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">go mod常用命令 以及 常见问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>最近接触到go mod，网上查了查资料，这里记录一下。</h2> 
<p> </p> 
<h2>1 介绍</h2> 
<h3>1.1、go mod是什么</h3> 
<p>      go mod 是Golang 1.11 版本引入的官方包（package）依赖管理工具，用于解决之前没有地方记录依赖包具体版本的问题，方便依赖包的管理。</p> 
<p>      之前Golang 主要依靠vendor和GOPATH来管理依赖库，vendor相对主流，但现在官方更提倡go mod。</p> 
<h3>1.2、go mod初始化及使用</h3> 
<p>下载官方包1.11(及其以上版本将会自动支持gomod) 默认GO111MODULE=auto(auto是指如果在gopath下不启用mod)</p> 
<p>Golang 提供一个环境变量 GO111MODULE 来设置是否使用mod，它有3个可选值，分别是off, on, <span style="color:#f33b45;"><strong>auto（默认值）</strong></span>，具体含义如下：</p> 
<ol><li>off: GOPATH mode，查找vendor和GOPATH目录</li><li>on：module-aware mode，使用 go module，忽略GOPATH目录</li><li>auto：如果当前目录不在$GOPATH 并且 当前目录（或者父目录）<span style="color:#f33b45;"><strong>下有go.mod文件，则使用 GO111MODULE</strong></span>， 否则仍旧使用 GOPATH mode。</li></ol> 
<p>修改 GO111MODULE 的值的语句是：set GO111MODULE=on 。</p> 
<p>在使用模块的时候， <code>GOPATH</code> 是无意义的，不过它还是会把下载的依赖储存在 <code>GOPATH/src/mod</code> 中，也会把 <code>go install</code> 的结果放在 <code>GOPATH/bin</code>（如果 <code>GOBIN</code> 不存在的话）</p> 
<ul><li><code>go mod download</code> 下载模块到本地缓存，缓存路径是 <code>$GOPATH/pkg/mod/cache</code></li><li><code>go mod edit</code> 是提供了命令版编辑 <code>go.mod</code> 的功能，例如 <code>go mod edit -fmt go.mod</code> 会格式化 <code>go.mod</code></li><li><code>go mod graph</code> 把模块之间的依赖图显示出来</li><li><code>go mod init</code> 初始化模块（例如把原本dep管理的依赖关系转换过来）</li><li><code>go mod tidy</code> 增加缺失的包，移除没用的包</li><li><code>go mod vendor</code> 把依赖拷贝到 <code>vendor/</code> 目录下</li><li><code>go mod verify</code> 确认依赖关系</li><li><code>go mod why</code> 解释为什么需要包和模块</li></ul> 
<p>注意有几个坑的地方：</p> 
<ul><li> <p><code>go mod</code> 命令在 <code>$GOPATH</code> 里默认是执行不了的，因为 <code>GO111MODULE</code> 的默认值是 <code>auto</code>。默认在<code>$GOPATH</code> 里是不会执行， 如果一定要强制执行，就设置环境变量为 <code>on</code>。</p> </li><li> <p><code>go mod init</code> 在没有接module名字的时候是执行不了的，会报错 <code>go: cannot determine module path for source directory</code>。可以这样执行：</p> <pre><code class="language-html">$ go mod init github.com/jiajunhuang/hello
</code></pre> <p>否则就要在 <code>main.go</code> 里加上导入声明，例如：</p> <pre><code class="language-html">$ cat main.go
package main

func main() {
    println("Hello world")
}
$ go mod init
go: cannot determine module path for source directory /Users/jiajun/hello (outside GOPATH, no import comments)
$ vim go.mod
$ cat go.mod
module github.com/jiajunhuang/hello
$ go mod init
go mod init: go.mod already exists
$ rm go.mod
$ vim main.go
$ cat main.go
package main // import "github.com/jiajunhuang/hello"

func main() {
    println("Hello world")
}
$ go mod init
go: creating new go.mod: module github.com/jiajunhuang/hello
$ ls
go.mod  main.go
$ cat go.mod
module github.com/jiajunhuang/hello
</code></pre> <p>当然，如果在已有代码的仓库里执行是不存在这个问题的。</p> </li></ul> 
<p> </p> 
<h3>2 命令</h3> 
<h3>2.1 指定module的根目录并生成go.mod文件</h3> 
<pre class="has"><code>go mod init example.com/hello</code></pre> 
<h3>2.2 下载并添加依赖到go.mod文件中</h3> 
<pre class="has"><code>go build, go test</code></pre> 
<h3>2.3 查看module下的所有依赖</h3> 
<pre class="has"><code>go list -m all</code></pre> 
<h3>2.4 更新稳定版依赖</h3> 
<pre class="has"><code>go get rsc.io/sampler</code></pre> 
<h3>2.5 更新为指定版本依赖</h3> 
<pre class="has"><code>go list -m -versions rsc.io/sampler

rsc.io/sampler v1.0.0 v1.2.0 v1.2.1 v1.3.0 v1.3.1 v1.99.99

go get rsc.io/sampler@v1.3.1</code></pre> 
<h3>2.6 清理无用的依赖</h3> 
<pre class="has"><code>go mod tidy</code></pre> 
<h3>2.7 将依赖复制到项目路径的vendor文件夹中</h3> 
<pre class="has"><code>go mod vendor</code></pre> 
<h3>2.8 忽略cache里的包，只使用vendor目录里的依赖进行编译</h3> 
<pre class="has"><code>go build -mod=vendor</code></pre> 
<p>2.9 校验依赖并查看是否有修改</p> 
<pre class="has"><code>go mod verify</code></pre> 
<p> </p> 
<h2>3 问题</h2> 
<h3>3.1 go: modules disabled inside GOPATH/src by GO111MODULE=auto; see 'go help modules'</h3> 
<p>go mod init</p> 
<p>go: modules disabled inside GOPATH/src by GO111MODULE=auto; see 'go help modules'</p> 
<p>开启go module：</p> 
<ol><li> <p><code>set GO111MODULE=on //windows</code></p> </li><li> <p><code>export GO111MODULE=on //linux</code></p> </li></ol> 
<h3>3.2 $GOPATH/go.mod exists but should not</h3> 
<p>GO 1.11或之后模块遇到这个问题：</p> 
<pre class="has"><code>$GOPATH/go.mod exists but should not
</code></pre> 
<p>    开启模块支持后（set GO111MODULE=on），并不能与$GOPATH共存，所以把$GOPATH从env中移出即可（unset GOPATH），可运行“unset GOPATH &amp;&amp; make”。</p> 
<p> </p> 
<h2>4 例子</h2> 
<h3>4.1 例子1</h3> 
<p>go mod初始化：在$GOPATH外建一个文件夹，把个人代码放进去，我的测试代码路径：https://github.com/kevinhao8/go-mod-example。</p> 
<p>首先main入口代码所在文件夹创建mod</p> 
<p>创建语句  go mod init [module name]</p> 
<p>比如我的测试代码 redisTest.go，创建语句就是  go mod init redisTest，成功创建时返回  go: creating new go.mod: module redisTest</p> 
<p>此时文件夹下出现 go.mod文件，打开发现只有2行如下，并没有记录依赖库。</p> 
<p>module redisTest</p> 
<p>go 1.12</p> 
<p>此时需要输入go test语句，根据需要的依赖自动生成require，也就是依赖包，此时go.mod多了如下内容（红字是我写的注释，文件里面没有）</p> 
<p>require (<br>       github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3 // indirect（有indirect注释的代表间接依赖，没有的代表直接依赖）<br>       github.com/gin-gonic/gin v1.3.0  <br>       github.com/golang/protobuf v1.3.1 // indirect<br>       github.com/mattn/go-isatty v0.0.7 // indirect<br>       github.com/ugorji/go/codec v0.0.0-20190316192920-e2bddce071ad // indirect（这里是版本号+时间戳+hash）<br>       gopkg.in/go-playground/validator.v8 v8.18.2 // indirect<br>       gopkg.in/yaml.v2 v2.2.2 // indirect<br> )</p> 
<p>此时会有如下失败提示，此处为我踩得第一个坑！！！花了挺长时间才解决</p> 
<p>build redisTest: cannot load dbredis: cannot find module providing package dbredis</p> 
<p>dbredis是我写的私有包，代码是没有问题的，为什么找不到呢？从网上查了一圈，<span style="color:#f33b45;"><strong>发现私有包如果不想发布到网上，需要手动添加require ，然后replace 进行替换，将私有包指向本地module所在的绝对或相对路径。一般用相对路径更通用。</strong></span></p> 
<p>此时手动将go.mod改为如下，红字为新加</p> 
<p>require (<br>       <span style="color:#f33b45;"><strong>dbredis v0.0.0</strong></span><br>       github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3 // indirect<br>       github.com/gin-gonic/gin v1.3.0<br>       github.com/golang/protobuf v1.3.1 // indirect<br>       github.com/mattn/go-isatty v0.0.7 // indirect<br>       github.com/ugorji/go/codec v0.0.0-20190316192920-e2bddce071ad // indirect<br>       gopkg.in/go-playground/validator.v8 v8.18.2 // indirect<br>       gopkg.in/yaml.v2 v2.2.2 // indirect<br> )</p> 
<p>replace dbredis v0.0.0 =&gt; ./dbredis</p> 
<p>再度运行go test  命令，发现仍有失败提示如下，找不到dbredis文件夹下的go.mod文件。</p> 
<p>go: parsing dbredis\go.mod: open E:\code\go-mod-example\dbredis\go.mod: The system cannot find the file specified.<br> go: error loading module requirements</p> 
<p>从网上查资料发现，这种情况下需要给私有包也生成mod，这样整个工程的依赖才能完整。故运行如下命令：</p> 
<p>cd dbredis</p> 
<p>go mod init dbredis（此处我写的mod名跟package名一致，不知道不一致行不行）</p> 
<p>go test</p> 
<p>三条命令依次运行通过，dbredis文件夹下的go.mod文件如下：</p> 
<p>module dbredis</p> 
<p>go 1.12</p> 
<p>require github.com/go-redis/redis v6.15.2+incompatible</p> 
<p>此时再运行如下命令：</p> 
<p>cd ..（回到上层文件夹）</p> 
<p>go test</p> 
<p>运行通过，不再有报错。运行命令 go build redisTest.go 也能够正常生成redisTest.exe</p> 
<p>至此通过mod来管理依赖包基本实现，我们的程序能基本脱离$GOPATH编译。<br>  </p> 
<h2>5 go mod 和 dep 比较</h2> 
<ul><li><code>go mod</code> 支持代理，以后就可以使用私有镜像源了~，具体请搜索 <code>GOPROXY</code></li><li><code>go mod</code> 速度比 <code>dep</code> 快很多</li><li><code>go.mod</code> 中列出了所有的依赖，这一点其实我不是很喜欢，因为当项目一大，历史一久，只要升级其中一个依赖，很可能整个依赖 就挂了。我还是比较喜欢只要列出顶级依赖，由程序处理子依赖的情况。</li></ul> 
<h3>一个生成的 <code>go.mod</code> 的示例</h3> 
<pre><code class="language-html">module github.com/my/module/v3  // 这是你的包的声明

// require 里是依赖。需要带上路径和版本。
require (
    github.com/some/dependency v1.2.3
    github.com/another/dependency v0.1.0
    github.com/additional/dependency/v4 v4.0.0
)
</code></pre> 
<hr> 
<ul><li><a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a></li></ul> 
<p> </p> 
<h2>其他</h2> 
<p>windows下的尝试:</p> 
<p>gomod初尝试<br> 下载官方包1.11(及其以上版本将会自动支持gomod) 默认GO111MODULE=auto(auto是指如果在gopath下不启用mod)<br> go mod help查看帮助<br> go mod init&lt;项目模块名称&gt;初始化模块，会在项目根目录下生成 go.mod文件。</p> 
<p>go mod tidy根据go.mod文件来处理依赖关系。</p> 
<p>go mod vendor将依赖包复制到项目下的 vendor目录。建议一些使用了被墙包的话可以这么处理，方便用户快速使用命令go build -mod=vendor编译</p> 
<p>go list -m all显示依赖关系。go list -m -json all显示详细依赖关系。</p> 
<p>go mod download &lt;path@version&gt;下载依赖。参数&lt;path@version&gt;是非必写的，path是包的路径，version是包的版本。</p> 
<p>在gopath外新建一个项目，单独开一个cmd设置set GO111MODULE=on(习惯性的和git初始化一样)go mod init然后报错了。 正解如下：go mod init xxx（module名称可与文件名不同）</p> 
<p>在项目目录下执行go mod tidy下载完成后项目路径下会生成go.mod和go.sum</p> 
<p>go.mod文件必须要提交到git仓库，但go.sum文件可以不用提交到git仓库(git忽略文件.gitignore中设置一下)。</p> 
<p>go模块版本控制的下载文件及信息会存储到GOPATH的pkg/mod文件夹里。</p> 
<p> </p> 
<p>--------------------分割线---------------------------------------------------------</p> 
<p>gopath 与go mod的区别</p> 
<pre class="has"><code>环境变量GOPATH不再用于解析imports包路径，即原有的GOPATH/src/下的包，通过import是找不到了。
Go Module功能开启后，下载的包将存放与$GOPATH/pkg/mod路径
$GOPATH/bin路径的功能依旧保持</code></pre> 
<p><br> go get 流程的变化</p> 
<pre class="has"><code>老的go get取包过程类似：git clone + go install , 开启Go Module功能后go get就只有 git clone 或者 download过程了。
新老实现还有一个不同是，两者存包的位置不同。前者，存放在$GOPATH/src目录下；后者，存放在$GOPATH/pkg/mod目录下。
老的go get取完主包后，会对其repo下的submodule进行循环拉取。新的go get不再支持submodule子模块拉取。</code></pre> 
<p><br><br> 依赖包的变化</p> 
<pre class="has"><code>三方远程包:
检查远程仓库最新的tag版本，有就取得该版本
远程仓库没有tag版本时，直接获取master分支的HEAD版本
如果在go.mod文件中指定了具体版本，go get直接获取该指定版本
go.mod中除了可以指定具体版本号以外，还支持分支名

本地包:
通过replace()进行替换</code></pre> 
<p><br> 私有仓库权限和私有vcs非标准路径取包问题</p> 
<pre class="has"><code>权限问题
windows10下:
    控制面板&gt;用户账户&gt;凭据管理手动添加普通凭据即可
linux下:
增加 $HOME/.gitconfig 配置:
[url "ssh://git@github.com/MYORGANIZATION/"]
insteadOf = https://github.com/MYORGANIZA...

增加 $HOME/.netrc:
machine github.com login YOU password APIKEY
将其中的 APIKEY 换成自己的登录KEY。

非标准路径问题(https://private.vcs.com:20000)
搭建一个中间服务：https://private.vcs.com 能够通过go get的包路径匹配查询正确的仓库地址。</code></pre> 
<p><br>  </p> 
<h2>参考：</h2> 
<p><a href="https://blog.csdn.net/Lazybones_3/article/details/89355133">https://blog.csdn.net/Lazybones_3/article/details/89355133</a></p> 
<p><a href="https://blog.csdn.net/kevinh531/article/details/88691870">https://blog.csdn.net/kevinh531/article/details/88691870</a></p> 
<p><a href="https://jiajunhuang.com/articles/2018_09_03-go_module.md.html" rel="nofollow">https://jiajunhuang.com/articles/2018_09_03-go_module.md.html</a></p> 
<p>https://blog.csdn.net/qq_33296108/article/details/88184060 </p> 
<p> </p> 
<h2>请我喝咖啡</h2> 
<p><strong>如果觉得文章写得不错，能对你有帮助，可以扫描我的微信二维码请我喝咖啡哦～~哈哈~~</strong></p> 
<p style="text-align:center;"><img alt="" height="363" src="https://images2.imgbox.com/bd/68/3JufIZD3_o.jpg" width="367"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d9d377e2c872084064064653e65c80ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">对np.shape()的一点理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/695f767623f1e1bd2bdc605b10a47537/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32F0 硬件I2C驱动调试</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>