<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】顺序表 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/4596344fb17ee8910082a1674dea872f/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【数据结构】顺序表">
  <meta property="og:description" content="👑个人主页：啊Q闻 🎇收录专栏：《C语言》 🎉道阻且长，行则将至
前言 顺序表是我们后续实现通讯录的一个关键技术，今天我们就来学习一下顺序表。 一.顺序表的概念及结构 顺序表是线性表的一种。什么是线性表呢？
线性表是n个具有相同特性的数据元素的有限序列。线性表是一种在实际中广泛使用的数据结构，常见的线性表有：顺序表，链表，栈，队列，字符串……
线性表在逻辑结构上是线性结构，在物理结构上不一定是连续的。
线性表在物理上存储时，通常以数组和链式结构的形式存储。
1.对于顺序表，顺序表在逻辑结构上是线性的，物理结构上是连续的。
2.顺序表的底层结构是数组，对数组进行封装，实现常用的增删查改等接口。有点类似与苍蝇馆子包装成五星级酒店。
二.顺序表的分类 顺序表分为静态顺序表和动态顺序表
1.静态顺序表 概念：使用定长数组存储元素
​
正是因为静态顺序表是使用定长数组存储元素，所以其空间给少了不够用，给多了又会造成空间浪费。 2.动态顺序表 动态顺序表可以自己开辟空间，相较于静态顺序表更加灵活。 显然，动态顺序表更加灵活好用，我们来完成一下动态顺序表的实现。 三.动态顺序表的实现 动态顺序表的实现要有的基本功能是增删查改，所以我们要实现的功能为顺序表的初始化和销毁，以及基本功能增删查改。 我们创建三个文件：
一个头文件SeqList.h用于定义顺序表的结构，顺序表要实现的接口。
一个源文件SeqList.c用于具体实现顺序表里定义的接口。
一个源文件test.c用于测试顺序表。
SeqList.h
#pragma once #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; #include&amp;lt;assert.h&amp;gt; typedef int SLDataType; typedef struct Seqlist { SLDataType* arr; int size; int capacity; }SL; void Init(SL* ps);//初始化 void SLPlusCapacity(SL* ps);//扩容 void SLPushFront(SL* ps,SLDataType num);//前插 void SLPushBack(SL* ps, SLDataType num);//后插 void SLDeFront(SL* ps);//头删 void SLDeBack(SL* ps);//尾删 void SLInsert(SL* ps, SLDataType num, int pos);//指定位置插入 void SLDelete(SL* ps, int pos);//指定位置删除 int SLFind(SL* ps, SLDataType num);//查找 void SLChange(SL* ps, SLDataType num,int a);//修改 void SLPrint(SL*ps);//打印 void SLDestory(SL* ps);//销毁 详解：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-19T16:46:27+08:00">
    <meta property="article:modified_time" content="2024-03-19T16:46:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】顺序表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/df/fb/ZlBaegD6_o.png"></p> 
<blockquote> 
 <p>👑<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：啊Q闻       </p> 
 <p>🎇收录专栏：《C语言》           </p> 
 <p> 🎉道阻且长，行则将至</p> 
</blockquote> 
<h2>前言</h2> 
<blockquote> 
 <p>顺序表是我们后续实现通讯录的一个关键技术，今天我们就来学习一下顺序表。 </p> 
</blockquote> 
<h2> 一.顺序表的概念及结构</h2> 
<p>顺序表是线性表的一种。什么是线性表呢？</p> 
<blockquote> 
 <p><strong>线性表是n个具有相同特性的数据元素的有限序列。</strong>线性表是一种在实际中广泛使用的数据结构，<strong>常见的线性表有：顺序表，链表，栈，队列，字符串……</strong></p> 
 <p><strong>线性表在逻辑结构上是线性结构，在物理结构上不一定是连续的。</strong></p> 
 <p><strong>线性表在物理上存储时，通常以数组和链式结构的形式存储。</strong></p> 
</blockquote> 
<blockquote> 
 <p>1.对于顺序表，<strong>顺序表在逻辑结构上是线性的，物理结构上是连续的。</strong></p> 
 <p>2.<strong>顺序表的底层结构是数组，对数组进行封装，实现常用的增删查改等接口。</strong>有点类似与苍蝇馆子包装成五星级酒店。</p> 
</blockquote> 
<h2>二.顺序表的分类 </h2> 
<p>顺序表分为静态顺序表和动态顺序表</p> 
<h3><strong>1.静态顺序表</strong></h3> 
<p><strong>概念：使用定长数组存储元素</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/ab/55/z16gj1Zw_o.png">​</strong></p> 
<blockquote> 
 <p>正是因为静态顺序表是使用定长数组存储元素，所以其空间给少了不够用，给多了又会造成空间浪费。 </p> 
</blockquote> 
<h3>2.动态顺序表 </h3> 
<p><strong>动态顺序表可以自己开辟空间，相较于静态顺序表更加灵活。 </strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2e/2e/Qp10gdHh_o.png"></p> 
<p>显然，动态顺序表更加灵活好用，我们来完成一下动态顺序表的实现。 </p> 
<h2>三.动态顺序表的实现 </h2> 
<blockquote> 
 <p>动态顺序表的实现要有的基本功能是增删查改，<span style="color:#be191c;"><strong>所以我们要实现的功能为顺序表的初始化和销毁，以及基本功能增删查改。 </strong></span></p> 
</blockquote> 
<blockquote> 
 <p><strong>我们创建三个文件：</strong></p> 
 <p><strong>一个头文件SeqList.h用于定义顺序表的结构，顺序表要实现的接口。</strong></p> 
 <p><strong>一个源文件SeqList.c用于具体实现顺序表里定义的接口。</strong></p> 
 <p><strong>一个源文件test.c用于测试顺序表。</strong></p> 
</blockquote> 
<p>SeqList.h</p> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
typedef int SLDataType;
typedef struct Seqlist
{
	SLDataType* arr;
	int size;
	int capacity;
}SL;
void Init(SL* ps);//初始化
void SLPlusCapacity(SL* ps);//扩容
void SLPushFront(SL* ps,SLDataType num);//前插
void SLPushBack(SL* ps, SLDataType num);//后插
void SLDeFront(SL* ps);//头删
void SLDeBack(SL* ps);//尾删
void SLInsert(SL* ps, SLDataType num, int pos);//指定位置插入
void SLDelete(SL* ps, int pos);//指定位置删除
int  SLFind(SL* ps, SLDataType num);//查找
void SLChange(SL* ps, SLDataType num,int a);//修改
void SLPrint(SL*ps);//打印
void SLDestory(SL* ps);//销毁</code></pre> 
<blockquote> 
 <p>详解：</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/73/00/rMf1T4EE_o.png"> </p> 
</blockquote> 
<hr> 
<p><strong> SeqList.c</strong></p> 
<pre><code class="language-cpp">#include "SLlist.h"
void Init(SL* ps)
{
	ps-&gt;arr = NULL;
	ps-&gt;size = 0;
	ps-&gt;capacity = 0;
}//对每个值初始化
void SLPlusCapacity(SL* ps)//扩容
{
	assert(ps);
	if (ps-&gt;size == ps-&gt;capacity)
	{
		int newcapacity = 0;
		newcapacity = ps-&gt;capacity == 0 ? 4 : 2 * (ps-&gt;capacity);//三目表达式
		SLDataType* tmp = (SLDataType*)realloc(ps-&gt;arr, newcapacity *sizeof(SLDataType));
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(1);
		}
		ps-&gt;arr = tmp;
		ps-&gt;capacity = newcapacity;
	}
}
void SLPushFront(SL* ps, SLDataType num)//前插
{
	assert(ps);
	SLPlusCapacity( ps);
	int i = 0;
	for (i=ps-&gt;size;i&gt;0;i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];
	}
	ps-&gt;arr[0] = num;
	ps-&gt;size++;
}
void SLPushBack(SL* ps, SLDataType num)//后插
{
	assert(ps);
	SLPlusCapacity(ps);
	ps-&gt;arr[ps-&gt;size++] = num;
}
void SLDeFront(SL* ps)//前删
{
	assert(ps);
	assert(ps-&gt;size);
	int i = 0;
	for (i = 0; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];
	}
	ps-&gt;size--;
}
void SLDeBack(SL* ps)//后删
{
	assert(ps);
	assert(ps-&gt;size);
	ps-&gt;size--;
}
void SLInsert(SL* ps, SLDataType num, int pos)//指定位置插入
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);
	SLPlusCapacity(ps);
	int i = 0;
	for (i=ps-&gt;size;i&gt;pos;i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];
	}
	ps-&gt;arr[pos] = num;
	ps-&gt;size++;
}
void SLDelete(SL* ps, int pos)//指定位置删除
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);
	int i = 0;
	for (i=pos;i&lt;ps-&gt;size-1;i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i+1];
	}
	ps-&gt;size--;
}
 int  SLFind(SL* ps, SLDataType num)//查找
{
	assert(ps);
	int i = 0;
	for (i = 0; i &lt; ps-&gt;size; i++)
	{
		if (ps-&gt;arr[i] == num)
		{
			return i;
		}
	}
	return -1;
}
 void SLChange(SL* ps, SLDataType num,int a)//修改
 {
	 assert(ps);
	 ps-&gt;arr[a] = num;
 }

void SLPrint(SL* ps)//打印
{
	int i = 0;
	for (i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;arr[i]);
	}
	printf("\n");
}
 void SLDestory(SL* ps)//销毁
 {
	 assert(ps);
	 if (ps-&gt;arr)
	 {
		 free(ps-&gt;arr);
	 }
	 ps-&gt;arr=NULL;
	 ps-&gt;size = ps-&gt;capacity = 0;

 }</code></pre> 
<blockquote> 
 <p>详解：</p> 
 <p><img alt="" src="https://images2.imgbox.com/af/e8/6IuKjHkF_o.png"><img alt="" src="https://images2.imgbox.com/df/91/RZdvPmBt_o.png"> </p> 
 <p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/a6/49/C34ikUlf_o.png"></p> 
 <p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/be/84/VYqZ55bO_o.png"><img alt="" src="https://images2.imgbox.com/a4/af/1hbIVKnS_o.png"> <img alt="" src="https://images2.imgbox.com/f1/68/9hhmrIJO_o.png"><img alt="" src="https://images2.imgbox.com/8a/77/rERKfydJ_o.png"><img alt="" src="https://images2.imgbox.com/57/29/57Cl9Ni1_o.png"> </p> 
</blockquote> 
<p>test.c </p> 
<pre><code class="language-cpp">#include "SLlist.h"
void SLTest01()
{
	SL s1;//创建变量
	Init(&amp;s1);
	SLPushFront(&amp;s1, 1);
	SLPushFront(&amp;s1, 2);
	SLPushFront(&amp;s1, 3);
	SLPushFront(&amp;s1, 4);
	//SLPrint(&amp;s1);
    SLPushBack(&amp;s1, 5);
	SLPushBack(&amp;s1, 6);
	SLPrint(&amp;s1);
	/*SLDeFront(&amp;s1);
	SLPrint(&amp;s1);
	SLDeBack(&amp;s1);
	SLPrint(&amp;s1);*/
	//SLInsert(&amp;s1, 8, 3);
	//SLPrint(&amp;s1);
	/*SLDelete(&amp;s1, 3);
	SLPrint(&amp;s1);*/
    /*int ret=SLFind(&amp;s1, 2);
	if (ret &lt; 0)
	{
		printf("要查找的数字不存在\n");
	}
	else
	{
		printf("找到了，数字在%d位置\n", ret);
	}*/

	SLChange(&amp;s1, 9, 1);
	SLPrint(&amp;s1);
	SLDestory(&amp;s1);
}
int main()
{
	SLTest01();
	return 0;
}</code></pre> 
<blockquote> 
 <p>感谢大家阅读，下篇博客将会分享利用顺序表实现通讯录，如果对你有帮助的话，三连支持一下吧</p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f2ac07d13e0400b2c4137c287ef223e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软件工程-第9章 软件工程项目管理概述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc932f623a456a9529374659e84eb8ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一个好用的前端工具包 - 百涂工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>