<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】栈与队列 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/ef7c0dae14826824fa74d2525c4ea738/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【数据结构】栈与队列">
  <meta property="og:description" content="一、栈 1.基本概念 栈是只能在一段进行插入或者删除的线性表
出栈进栈 只能在栈顶进行
三个术语：栈底，空栈，栈顶 字面理解即可 栈的基本操作：
创 销 增 删 查
2.顺序栈的实现 （1）初始化
#define max 10 typedef struct { int data[max]; int top; //记录数组下标 }sqstack; //初始化 void inite(sqstack&amp;amp; s) { s.top = -1; } 2.入栈
//入栈 bool push(sqstack&amp;amp; s, int x) { if (s.top == max - 1) //栈满 报错 return false; s.top = s.top &#43; 1; //指针加一 s.data[s.top] = x; return true; } 3.出栈
//出栈 bool pop(sqstack&amp;amp; s, int&amp;amp; x) { if (s.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-18T20:45:35+08:00">
    <meta property="article:modified_time" content="2024-03-18T20:45:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】栈与队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、栈</h2> 
<h3>1.基本概念</h3> 
<p><strong>栈是只能在一段进行插入或者删除的线性表</strong></p> 
<p><span style="color:#fe2c24;"><strong>出栈进栈 只能在栈顶进行</strong></span></p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/04/c5/d5RLvHN8_o.png" width="797"></p> 
<p>三个术语：栈底，空栈，栈顶   字面理解即可 </p> 
<p>栈的基本操作：</p> 
<p><strong>创 销 增 删 查</strong></p> 
<h3><strong>2.顺序栈的实现</strong></h3> 
<p><strong>（1）初始化</strong></p> 
<pre><code>#define max 10
typedef struct 
{
	int data[max];
	int top;  //记录数组下标
}sqstack;
//初始化
void inite(sqstack&amp; s)
{
	s.top = -1;
}  </code></pre> 
<p>2.入栈</p> 
<pre><code>//入栈
bool push(sqstack&amp; s, int x)
{
	if (s.top == max - 1)  //栈满 报错
		return false;
	s.top = s.top + 1;  //指针加一
	s.data[s.top] = x;
	return true;
}</code></pre> 
<p>3.出栈</p> 
<pre><code>//出栈
bool pop(sqstack&amp; s, int&amp; x)
{
	if (s.top == -1)
		return false;
	x = s.data[s.top]; //栈顶元素先出栈
	s.top = s.top - 1;
	return true;
}</code></pre> 
<p>4.读取栈顶元素</p> 
<pre><code>//读取栈顶元素
bool getpop(sqstack&amp; s, int&amp; x)
{
	if (s.top == -1)
		return false;
	x = s.data[s.top];
	return true;
}</code></pre> 
<p><a href="https://blog.csdn.net/GalaxyerKw/article/details/113546250" title="【数据结构】栈的链式实现和操作（创建栈，入栈，出栈，获取栈顶元素）_任务分析:链式栈的入栈操作先创建新结点node,再将新结点node指向栈顶指针,最-CSDN博客">【数据结构】栈的链式实现和操作（创建栈，入栈，出栈，获取栈顶元素）_任务分析:链式栈的入栈操作先创建新结点node,再将新结点node指向栈顶指针,最-CSDN博客</a></p> 
<pre><code class="hljs">s.empty();         //如果栈为空则返回true, 否则返回false;
s.size();          //返回栈中元素的个数
s.top();           //返回栈顶元素, 但不删除该元素
s.pop();           //弹出栈顶元素, 但不返回其值
s.push();          //将元素压入栈顶</code></pre> 
<p>针对这题</p> 
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p> 
<p>有效字符串需满足：</p> 
<ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>s = "()"
<strong>输出：</strong>true
</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>s = "()[]{}"
<strong>输出：</strong>true
</pre> 
<p><strong>示例 3：</strong></p> 
<pre><strong>输入：</strong>s = "(]"
<strong>输出：</strong>false
</pre> 
<pre><code>class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; buffer;
        for (int i=0;i&lt;s.size();i++)
        {
            if (buffer.empty())
            {
                buffer.push(s[i]);
                continue;
            }
            char top=buffer.top();
            if (s[i]=='}'&amp;&amp;top=='{')
            {
                buffer.pop();
                continue;
            }
            else if (s[i]==']'&amp;&amp;top=='[')
            {
                buffer.pop();
                continue;
            }
            else if (s[i]==')'&amp;&amp;top=='(')
            {
                buffer.pop();
                continue;
            }
            buffer.push(s[i]);
        }
        return (buffer.empty());

    }
};</code></pre> 
<p></p> 
<h2>二、队列 </h2> 
<p><strong>队列是前段插入，后端删除的线性表</strong></p> 
<p><strong>看成一种循环线性表</strong></p> 
<p><img alt="" height="506" src="https://images2.imgbox.com/cc/f3/5C50vAsh_o.png" width="556"></p> 
<p>判断元素个数：<br> (rear+max-front)%max </p> 
<p>1.初始化</p> 
<pre><code>#define max 10
typedef struct
{
	int data[max];
	int front; int rear;
}sq;</code></pre> 
<p>2.入队</p> 
<pre><code>//入队
bool enq(sq&amp; q, int x)
{
	if ((q.rear + 1) % max == q.front)  //队列已满
		return false;
	q.data[q.rear] = x;
	q.rear = (q.rear + 1)%max;
	return true;
}</code></pre> 
<p>3.出队</p> 
<pre><code>//出队
bool deq(sq&amp; q, int &amp;x)
{
	if (q.rear=q.front)  //队列为空
		return false;
	x = q.data[q.front];
	q.front = (q.front + 1) % max;  //队头指针向后移一位
	return true;
}</code></pre> 
<p>4.查</p> 
<pre><code>//查 获取队头元素的值
bool get(sq&amp; q, int&amp; x)
{
	if (q.rear = q.front)  //队列为空
		return false;
	x = q.data[q.front];
	return true;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60e34bcb57c6483148ab647655301a3f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">我们篇002-【自律达人】俱乐部会议2-目标复盘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df168dff9eecdda9afde635b978c4743/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">程序人生——Java使用关于性能和效率的建议</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>