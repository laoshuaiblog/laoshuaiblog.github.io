<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言的结构体、联合和枚举 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/4b93905ced15cc369edc367b321530ac/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="C语言的结构体、联合和枚举">
  <meta property="og:description" content="结构体是C语言中一种非常重要的数据结构。与数组不同，结构体类型的变量的成员变量（数组称元素）可以具有不同的类型，并通过成员变量的名称获取指定成员。联合和结构体相似，但联合类型的变量的所有成员都共享同一存储空间，每次只能存储一个成员。枚举类型是一组命名了的整数值。结构体、联合、枚举和数组都是用于创建多种多样的、与基本数据类型同样的用户自定义的数据类型。
结构体 结构体类型的声明 结构体类型的声明格式如下：
struct { 类型 成员变量1; 类型 成员变量2； ... } 变量1, 变量2; 变量1和变量2都是该结构体类型的变量，结构体类型的变量的成员变量按声明的顺序在内存中依序存储。结构体为其所有成员设置了单独的命名空间，因此可以在结构体外存在与结构体内成员同名的变量。
结构体类型变量的成员可以是数组类型的变量，数组变量的元素也可以是结构体类型的。
结构体类型的变量的初始化 结构体类型的变量的初始化是依次列出结构体类型的变量各成员的值，用,隔开，并用大括号扩起来，形式如下
struct { 类型 成员变量1; 类型 成员变量2； ... } 变量1 = {成员变量1的初始值, 成员变量2的初始化值，...}, 变量2 = {成员变量1的初始值, 成员变量2的初始化值，...}; 注意：初始化式中的初始化值必须按结构成员的声明顺序给出，且初始化式中的表达式必须是常量表达式。
结构体类型的变量的操作 结构体类型的变量通过成员名称访问其内部的成员，其访问格式为：
结构体类型变量.成员变量 .是C语言的一个运算符，优先级和&#43;&#43;和--相同，几乎高于所有其他的运算符。
结构体类型变量的成员是一个左值，可以看作一个变量使用。类型一致的结构体类型变量之间可以使用赋值运算符相互赋值。
使用结构体类型作为函数的参数和返回值时，实际上使用的都是结构体类型的变量的副本。这样结构比较大的时候，会产生大量的开销，所以一般都使用结构体类型的变量的指针。
结构体类型 按照声明结构体类型时定义变量的方式要求变量必须在一个地方完全声明，否则当在新的地方用同样的方式定义变量时，不仅造成代码的结构臃肿，更重要的是C语言会将这些变量看成是不同的类型。为了解决这个问题，C语言利用结构标记来标识特定结构体类型的名字，这样就可以在别的地方使用结构标记来声明属于同样结构体类型的变量了。结构标记的声明格式如下：
struct 结构标记 { 类型 成员变量1; 类型 成员变量2； ... } 变量1, 变量2; struct 结构标记 变量3; struct 结构标记 变量4; 注意：使用结构标记时，不能省略标记前面的struct单词。
除了使用结构标记，还可以使用typedef来为定义结构体类型的别名，其使用形式为：
typedef struct { 类型 成员变量1; 类型 成员变量2； .">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2015-08-20T09:47:44+08:00">
    <meta property="article:modified_time" content="2015-08-20T09:47:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言的结构体、联合和枚举</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>结构体是C语言中一种非常重要的数据结构。与数组不同，结构体类型的变量的成员变量（数组称元素）可以具有不同的类型，并通过成员变量的名称获取指定成员。联合和结构体相似，但联合类型的变量的所有成员都共享同一存储空间，每次只能存储一个成员。枚举类型是一组命名了的整数值。结构体、联合、枚举和数组都是用于创建多种多样的、与基本数据类型同样的用户自定义的数据类型。</p> 
<h4 id="结构体">结构体</h4> 
<h5 id="结构体类型的声明">结构体类型的声明</h5> 
<p>结构体类型的声明格式如下：</p> 
<pre><code>struct
{
    类型 成员变量1;
    类型 成员变量2；
    ...
} 变量1, 变量2;
</code></pre> 
<p>变量1和变量2都是该结构体类型的变量，结构体类型的变量的成员变量按声明的顺序在内存中依序存储。结构体为其所有成员设置了单独的命名空间，因此可以在结构体外存在与结构体内成员同名的变量。</p> 
<p>结构体类型变量的成员可以是数组类型的变量，数组变量的元素也可以是结构体类型的。</p> 
<h5 id="结构体类型的变量的初始化">结构体类型的变量的初始化</h5> 
<p>结构体类型的变量的初始化是依次列出结构体类型的变量各成员的值，用<code>,</code>隔开，并用大括号扩起来，形式如下</p> 
<pre><code>struct
{
    类型 成员变量1;
    类型 成员变量2；
    ...
} 变量1 = {成员变量1的初始值, 成员变量2的初始化值，...},
  变量2 = {成员变量1的初始值, 成员变量2的初始化值，...};
</code></pre> 
<p><strong>注意：初始化式中的初始化值必须按结构成员的声明顺序给出，且初始化式中的表达式必须是常量表达式。</strong></p> 
<h5 id="结构体类型的变量的操作">结构体类型的变量的操作</h5> 
<p>结构体类型的变量通过成员名称访问其内部的成员，其访问格式为：</p> 
<pre><code>结构体类型变量.成员变量
</code></pre> 
<p><code>.</code>是C语言的一个运算符，优先级和<code>++</code>和<code>--</code>相同，几乎高于所有其他的运算符。</p> 
<p>结构体类型变量的成员是一个左值，可以看作一个变量使用。类型一致的结构体类型变量之间可以使用赋值运算符相互赋值。</p> 
<p>使用结构体类型作为函数的参数和返回值时，实际上使用的都是结构体类型的变量的副本。这样结构比较大的时候，会产生大量的开销，所以一般都使用结构体类型的变量的指针。</p> 
<h5 id="结构体类型">结构体类型</h5> 
<p>按照声明结构体类型时定义变量的方式要求变量必须在一个地方完全声明，否则当在新的地方用同样的方式定义变量时，不仅造成代码的结构臃肿，更重要的是C语言会将这些变量看成是不同的类型。为了解决这个问题，C语言利用结构标记来标识特定结构体类型的名字，这样就可以在别的地方使用结构标记来声明属于同样结构体类型的变量了。结构标记的声明格式如下：</p> 
<pre><code>struct 结构标记
{
    类型 成员变量1;
    类型 成员变量2；
    ...
} 变量1, 变量2;
struct 结构标记 变量3;
struct 结构标记 变量4;
</code></pre> 
<p><strong>注意：使用结构标记时，不能省略标记前面的<code>struct</code>单词。</strong></p> 
<p>除了使用结构标记，还可以使用<code>typedef</code>来为定义结构体类型的别名，其使用形式为：</p> 
<pre><code>typedef struct
{
    类型 成员变量1;
    类型 成员变量2；
    ...
} 结构体类型;
结构体类型 变量1;
结构体类型 变量2;
</code></pre> 
<p><strong>注意：当命名结构体类型时，通常两者都可以使用，但用于链表时必须强制声明结构标记。</strong></p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment">/**************************************
 * struct_declare.c                   *
 *                                    *
 * C语言的结构体声明、定义和使用        *
 **************************************/</span>

<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>

<span class="hljs-preprocessor">#define NAME_LEN 30</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> EmployedPerson
{
  <span class="hljs-keyword">char</span> name[NAME_LEN + <span class="hljs-number">1</span>];
  <span class="hljs-keyword">int</span> number;
  <span class="hljs-keyword">char</span> sex;
} Employee;

<span class="hljs-keyword">int</span> main()
{
  <span class="hljs-keyword">struct</span>
  {
    <span class="hljs-keyword">int</span> number;
    <span class="hljs-keyword">char</span> name[NAME_LEN+<span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> on_hand;
  }part1 = {<!-- --><span class="hljs-number">10</span>, <span class="hljs-string">"Jonh"</span>, <span class="hljs-number">5</span>},
   part2, part3;

   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"part1的number: %d, name: %s, on_hand: %d\n"</span>, part1.number, part1.name, part1.on_hand);

   part2.number = <span class="hljs-number">20</span>;
   <span class="hljs-built_in">strcpy</span>(part2.name, <span class="hljs-string">"Tom"</span>);
   part2.on_hand = <span class="hljs-number">15</span>;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"part2的number: %d, name: %s, on_hand: %d\n"</span>, part2.number, part2.name, part2.on_hand);

   part3 = part2;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"part3的number: %d, name: %s, on_hand: %d\n"</span>, part3.number, part3.name, part3.on_hand);


   <span class="hljs-keyword">struct</span> EmployedPerson employee1 = {<!-- --><span class="hljs-string">"Tim"</span>, <span class="hljs-number">10</span>, <span class="hljs-string">'M'</span>};
   Employee employee2 = {<!-- --><span class="hljs-string">"Smith"</span>, <span class="hljs-number">50</span>, <span class="hljs-string">'W'</span>};
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"employee1的name: %s, number: %d, sex: %c\n"</span>, employee1.name, employee1.number, employee1.sex);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"employee2的name: %s, number: %d, sex: %c\n"</span>, employee2.name, employee2.number, employee2.sex);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p><img src="https://images2.imgbox.com/17/4c/OIEMFVY1_o.png" alt="结构体" title=""></p> 
<h4 id="联合">联合</h4> 
<p>联合和结构体一样，联合类型的变量可以由具有不同类型的一个或多个成员变量构成。但编译器只为联合类型的变量分配最大的成员变量需要的内存空间。联合类型的变量的所有成员变量共用这段内存空间，因此给一个成员赋予新值就会修改其他成员的值。</p> 
<p>联合类型的声明方式和结构体类型的声明方式一样：</p> 
<pre><code>union
{
  类型 成员变量1;
  类型 成员变量2;
} 联合变量;
</code></pre> 
<p>访问联合类型变量的成员的方法和访问结构体类型变量的成员的方法相同，且联合类型的变量的成员也是左值可以像变量一样使用。同时可以类似于结构体类型为其声明联合标记和类型定义。联合类型的变量也可以使用赋值运算符执行赋值操作，也可作为参数和返回值在函数中使用。</p> 
<p>联合类型的变量初始化时，只有第一个成员可以获得初始值，其初始化的一般形式为：</p> 
<pre><code>union
{
  类型 成员变量1;
  类型 成员变量2;
} 变量 = {成员变量1的值};
</code></pre> 
<p><strong>注意：初始化式两边的大括号是不可以省略的。</strong></p> 
<p>联合主要包括以下常见的应用，一是通过在结构体类型中使用联合节省空间，二是使用联合类型的变量作为数组元素构建含有不同类型的混合的数据结构。</p> 
<p>为了解决无法知道联合类型的变量当前存放的是哪个成员的问题，可以把联合类型的变量作为结构体类型变量的成员，且结构体类型提供另一个成员变量作为标记来提示当前存储在联合类型变量中的是哪个成员。而这个标记成员使用枚举类型是非常合适的。</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment">/**************************************
 * using_union.c                      *
 *                                    *
 * C语言中的联合类型                  *
 **************************************/</span>

<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> Number
{
  <span class="hljs-keyword">int</span> i;
  <span class="hljs-keyword">float</span> f;
} Number;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>
{
  <span class="hljs-keyword">int</span> kind;
  Number number;
} TagedNumber;

<span class="hljs-preprocessor">#define INT_KIND 0</span>
<span class="hljs-preprocessor">#define FLOAT_KIND 1</span>

<span class="hljs-keyword">int</span> main()
{
  TagedNumber number1 = {INT_KIND};
  number1.number.i = <span class="hljs-number">10</span>;

  TagedNumber number2;
  number2.kind = FLOAT_KIND;
  number2.number.f = <span class="hljs-number">15.0f</span>;

  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"number1的值为: %d\n"</span>, number1.number.i);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"number2的值为: %f\n"</span>, number2.number.f);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p><img src="https://images2.imgbox.com/a2/da/7IU80rdZ_o.png" alt="使用联合体" title=""></p> 
<h4 id="枚举">枚举</h4> 
<p>枚举类型是C语言为具有少量可能值的变量设计的特殊类型。枚举类型的声明方式为：</p> 
<pre><code>enum
{
    枚举常量1,
    枚举常量2,
    ...
    枚举常量n
 } 枚举变量1, 枚举变量2;
</code></pre> 
<p>同结构体和联合类似，可以使用标记和<code>typedef</code>定义枚举类型。</p> 
<p>C语言将枚举类型的变量和常量作为整数处理，在声明枚举类型时，如果没有为某枚举常量指定值时，则该枚举变量的值比前一个常量的值加1。如果第一个枚举常量为指定值，则其值默认为0。<strong>注意：枚举的值作为整数使用，但不要把整数作为枚举的值。</strong></p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-comment">/**************************************
 * using_enum.c                       *
 *                                    *
 * C语言中的枚举类型                  *
 **************************************/</span>

<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> Number
{
  <span class="hljs-keyword">int</span> i;
  <span class="hljs-keyword">float</span> f;
} Number;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>{INT_KIND, FLOAT_KIND} Type;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>
{
  Type kind;
  Number number;
} TagedNumber;

<span class="hljs-preprocessor">#define INT_KIND 0</span>
<span class="hljs-preprocessor">#define FLOAT_KIND 1</span>

<span class="hljs-keyword">int</span> main()
{
  TagedNumber number1 = {INT_KIND};
  number1.number.i = <span class="hljs-number">10</span>;

  TagedNumber number2;
  number2.kind = FLOAT_KIND;
  number2.number.f = <span class="hljs-number">15.0f</span>;

  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"number1的值为: %d\n"</span>, number1.number.i);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"number2的值为: %f\n"</span>, number2.number.f);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p><img src="https://images2.imgbox.com/1a/75/712ozD1J_o.png" alt="使用枚举" title=""></p> 
<h4 id="参考文献">参考文献</h4> 
<ol><li>K.N. King 著，吕秀峰 译. C语言程序设计-现代方法. 人民邮电出版社</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/656c8b4dbb098415b0d8c1e40db5a6ba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PHP中const和define()定义常量的细节区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/181e59a42c49fc6992cf88a3bf1bffd6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">友情序言 to 《Learning Spark: Lightning-fast big data analytics》</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>