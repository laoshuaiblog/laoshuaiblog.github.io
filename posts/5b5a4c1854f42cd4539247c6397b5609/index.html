<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用 node.js 开发前端跨域代理服务 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/5b5a4c1854f42cd4539247c6397b5609/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="使用 node.js 开发前端跨域代理服务">
  <meta property="og:description" content="什么是跨域？当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。
为什么会出现跨域问题？出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。
打开 cmd 窗口，切换到 D:\proxyServer 目录
npm install express
npm install http-proxy-middleware
npm init -y 在proxyServer文件夹，新建 proxyServer.js，内容如下：
const express = require(&#34;express&#34;);
const { createProxyMiddleware } = require(&#34;http-proxy-middleware&#34;);
const app = express();
//设置跨域访问
app.all(&#34;*&#34;, function (req, res, next) {
//设置允许跨域的域名，*代表允许任意域名跨域
res.header(&#34;Access-Control-Allow-Origin&#34;, &#34;*&#34;);
//允许的header类型
res.header(&#34;Access-Control-Allow-Headers&#34;, &#34;Content-Type,Authorization&#34;); //content-type
//跨域允许的请求方式
res.header(&#34;Access-Control-Allow-Methods&#34;, &#34;DELETE,PUT,POST,GET,OPTIONS&#34;);
if (req.method.toLowerCase() == &#34;options&#34;) res.send(200);
//让options尝试请求快速结束
else next();
});
//这个链接是 福州市电子信息 企业二级节点
app.use(
&#34;/api&#34;,
createProxyMiddleware({
target: &#34;https://www.fzcitln.cn&#34;,
changeOrigin: true,
pathRewrite: {">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-20T14:22:13+08:00">
    <meta property="article:modified_time" content="2024-03-20T14:22:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用 node.js 开发前端跨域代理服务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>什么是跨域？当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。</p> 
<p>为什么会出现跨域问题？出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。</p> 
<p>打开 cmd 窗口，切换到 D:\proxyServer 目录</p> 
<p>npm install express</p> 
<p>npm install http-proxy-middleware</p> 
<p>npm init -y </p> 
<p>在proxyServer文件夹，新建 proxyServer.js，内容如下：</p> 
<p>const express = require("express");<br> const { createProxyMiddleware } = require("http-proxy-middleware");<br>  <br> const app = express();<br> //设置跨域访问<br> app.all("*", function (req, res, next) {<!-- --><br>   //设置允许跨域的域名，*代表允许任意域名跨域<br>   res.header("Access-Control-Allow-Origin", "*");<br>   //允许的header类型<br>   res.header("Access-Control-Allow-Headers", "Content-Type,Authorization");        //content-type<br>   //跨域允许的请求方式<br>   res.header("Access-Control-Allow-Methods", "DELETE,PUT,POST,GET,OPTIONS");<br>   if (req.method.toLowerCase() == "options") res.send(200);<br>   //让options尝试请求快速结束<br>   else next();<br> });</p> 
<p>//这个链接是 福州市电子信息 企业二级节点<br> app.use(<br>   "/api",<br>   createProxyMiddleware({<!-- --><br>     target: "https://www.fzcitln.cn",<br>     changeOrigin: true,<br>     pathRewrite: {<!-- --><br>       "^/api": "",     //rewrite path<br>     },<br>   })<br> );</p> 
<p>//这个端口号就是proxy运行的端口号<br> app.listen(3000, () =&gt; {<!-- --><br>   console.log(`启动代理服务器=&gt; http://127.0.0.1:3000`);<br> }); </p> 
<p></p> 
<p>新建 run_proxy_server.bat 启动脚本，内容如下：</p> 
<p>title=启动proxyServer代理服务</p> 
<p>@echo off<br> cd /d %~dp0<br> node proxyServer.js<br> echo over</p> 
<p>保存文件，运行 bat 脚本，前端跨域代理服务就启动成功了。</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa4fd2ef4507997644faa88d48b85f16/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker实践教程，nginx中使用数据卷映射修改前端网页（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a6031b04b7d53615ef5b52fcb6655f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kafka 集群</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>