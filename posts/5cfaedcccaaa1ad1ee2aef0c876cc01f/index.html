<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[转]session listener的配置和使用 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/5cfaedcccaaa1ad1ee2aef0c876cc01f/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="[转]session listener的配置和使用">
  <meta property="og:description" content="在web.xml中增加listener的配置信息 &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt; com.SessionListener(实现session监听器接口的类的名字，包也要写上) &amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt; com.AnotherSessionListener(有多个session监听器的时候，加多个&amp;lt;listener&amp;gt;) &amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt;
在JDK1.5和1.6的javax.servlet.http包中，可以看到session的监听器接口有4个，
分别是： HttpSessionListener
HttpSessionAttributeListener
HttpSessionBindingListener
HttpSessionActivationListener
要使用这些session的监听器，必须建立一个实现这些监听器接口的类，并在web.xml中配置这个类或者在会捆绑到session中的对象中实现监听器接口。
1. HttpSessionListener ：在WEB应用中，当一个session被创建或销毁时启用这个监听器。
HttpSessionListener接口定义了两个方法：void sessionCreated(HttpSessionEvent se)和void sessionDestroyed(HttpSessionEvent se)，每个方法都接受一个HttpSessionEvent对象作为参数。（实现类要提供一个无参数的构造函数）
官方英文说明：Implementations of this interface are notified of changes to the list of active sessions in a web application. To receive notification events, the implementation class must be configured in the deployment descriptor for the web application.
package com;
public class SessionListener implements HttpSessionListenter {">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2014-02-28T17:29:00+08:00">
    <meta property="article:modified_time" content="2014-02-28T17:29:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[转]session listener的配置和使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>在web.xml中增加listener的配置信息         </p> 
 <p>&lt;listener&gt;        </p> 
 <p>&lt;listener-class&gt;            </p> 
 <p>com.SessionListener(实现session监听器接口的类的名字，包也要写上)        </p> 
 <p>&lt;/listener-class&gt;    </p> 
 <p>&lt;/listener&gt;     </p> 
 <p>&lt;listener&gt;        </p> 
 <p>&lt;listener-class&gt;            </p> 
 <p>com.AnotherSessionListener(有多个session监听器的时候，加多个&lt;listener&gt;)        </p> 
 <p>&lt;/listener-class&gt;    </p> 
 <p>&lt;/listener&gt;</p> 
 <p>在JDK1.5和1.6的javax.servlet.http包中，可以看到session的监听器接口有4个，</p> 
 <p>分别是：    <a title="interface in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionListener.html" rel="nofollow">HttpSessionListener</a></p> 
 <p>              <a title="interface in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionAttributeListener.html" rel="nofollow">HttpSessionAttributeListener</a></p> 
 <p>              <a title="interface in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionBindingListener.html" rel="nofollow">HttpSessionBindingListener</a></p> 
 <p>              <a title="interface in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionActivationListener.html" rel="nofollow">HttpSessionActivationListener</a></p> 
 <p> </p> 
 <p>要使用这些session的监听器，必须建立一个实现这些监听器接口的类，并在web.xml中配置这个类或者在会捆绑到session中的对象中实现监听器接口。</p> 
 <p> </p> 
 <p>1.   HttpSessionListener ：<span style="text-decoration:underline;">在WEB应用中，当一个session被创建或销毁时启用这个监听器。</span></p> 
 <p>       HttpSessionListener接口定义了两个方法：void <a href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionListener.html#sessionCreated%28javax.servlet.http.HttpSessionEvent%29" rel="nofollow">sessionCreated</a>(<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionEvent.html" rel="nofollow">HttpSessionEvent</a> se)和void <a href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionListener.html#sessionDestroyed%28javax.servlet.http.HttpSessionEvent%29" rel="nofollow">sessionDestroyed</a>(<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionEvent.html" rel="nofollow">HttpSessionEvent</a> se)，每个方法都接受一个HttpSessionEvent对象作为参数。（实现类要提供一个无参数的构造函数）</p> 
 <p>       官方英文说明：Implementations of this interface are notified of changes to the list of active sessions in a web application. To receive notification events, the implementation class must be configured in the deployment descriptor for the web application.</p> 
 <p>package com;</p> 
 <p>public class SessionListener  implements HttpSessionListenter {<!-- --></p> 
 <p>           public SessionListener() { }; //无参构造方法</p> 
 <p>           //当session被创建时执行这个方法</p> 
 <p>            public void sessionCreated(HttpSessionEvent event) {<!-- --></p> 
 <p>                 //代码  </p> 
 <p>             } </p> 
 <p>            //当session被销毁时执行这个方法</p> 
 <p>            public void sessionDestoryed(HttpSessionEvent event) {<!-- --></p> 
 <p>                 //代码  </p> 
 <p>            } </p> 
 <p>            .....................................................</p> 
 <p>}</p> 
 <p> </p> 
 <p>2.   HttpSessionAttributeListener :在当前的WEB应用中，当session的attribute被增加、移除或替换后启用这个监听器。</p> 
 <p>       HttpSessionAttributeListener接口定义了三个方法：void <a href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionAttributeListener.html#attributeAdded%28javax.servlet.http.HttpSessionBindingEvent%29" rel="nofollow">attributeAdded</a>(<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionBindingEvent.html" rel="nofollow">HttpSessionBindingEvent</a> se) 、void<a href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionAttributeListener.html#attributeRemoved%28javax.servlet.http.HttpSessionBindingEvent%29" rel="nofollow">attributeRemoved</a>(<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionBindingEvent.html" rel="nofollow">HttpSessionBindingEvent</a> se) 和 void <a href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionAttributeListener.html#attributeReplaced%28javax.servlet.http.HttpSessionBindingEvent%29" rel="nofollow">attributeReplaced</a>(<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionBindingEvent.html" rel="nofollow">HttpSessionBindingEvent</a> se) ,每个方法都接受一个HttpSessionBindingEvent对象作为参数。</p> 
 <p>       官方英文说明：This listener interface can be implemented in order to get notifications of changes to the attribute lists of sessions within this web application.</p> 
 <p>       具体的实现类定义跟上边的差不多，这里就只写明接口定义的方法在什么情况下将会执行，后面也将是这样带过。</p> 
 <p>       void attributeAdded(HttpSessionBindingEvent se) ; //当一个attribute被增加到session后执行这个方法</p> 
 <p>       void attributeRemoved(HttpSessionBindingEvent se);//当一个attribute被从session中移除后执行这个方法</p> 
 <p>       void attributeReplaced(HttpSessionBindingEvent se);//当一个attribute中的值被替换后执行这个方法</p> 
 <p>注意上面两个必须在web.xml中配置, 这是为了比较第三个监听器，因为你想使用第三个监听器，那你必须把它布置到准备捆绑到session中的对象，这个对象必须是implements HttpSessionBindingListener</p> 
 <p> </p> 
 <p>3.    HttpSessionBindingListener：当一个实现了该接口的对象被捆绑到session或从session中被解放的时候启用这个监听器。（不明白的可以查考 类<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionBindingEvent.html" rel="nofollow">HttpSessionBindingEvent</a>的说明 和<a href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSession.html#setAttribute%28java.lang.String,%20java.lang.Object%29" rel="nofollow">HttpSession.setAttribute</a>方法）</p> 
 <p>       HttpSessionBingdingListener接口定义了两个方法：void <a href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionBindingListener.html#valueBound%28javax.servlet.http.HttpSessionBindingEvent%29" rel="nofollow">valueBound</a>(<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionBindingEvent.html" rel="nofollow">HttpSessionBindingEvent</a> event)   和 void <a href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionBindingListener.html#valueUnbound%28javax.servlet.http.HttpSessionBindingEvent%29" rel="nofollow">valueUnbound</a>(<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionBindingEvent.html" rel="nofollow">HttpSessionBindingEvent</a> event)，每个方法都接受一个HttpSessionBindingEvent对象作为参数。</p> 
 <p>       官方英文说明：Causes an object to be notified when it is bound to or unbound from a session. The object is notified by an<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionBindingEvent.html" rel="nofollow">HttpSessionBindingEvent</a> object. This may be as a result of a servlet programmer explicitly unbinding an attribute from a session, due to a session being invalidated, or due to a session timing out.</p> 
 <p>       //当对象被捆绑到session中时执行这个方法，像HttpSession.setAttribute("Aname",this_Object);这个方法执行后，将调用下面的方法，并启用HttpSessionAttributeListener 监听器        void valueBound( HttpSessionBindingEvent arg2 )</p> 
 <p>       //当对象从session中被解放时执行这个方法，像HttpSession.setAttribute("Aname",this_Object);执行后，再执行HttpSession.setAttribute("Aname",another_Object);方法 或者HttpSession.setAttribute("Aname",“ ”);方法或者removeAttribute("Aname")后，将调用下面的方法，并启用HttpSessionAttributeListener 监听器        void valueUnbound( HttpSessionBindingEvent arg1 ) </p> 
 <p> </p> 
 <p>4.    HttpSessionActivationListener ：用于分布式服务中，当会话被激活时调用相应的事件。</p> 
 <p>       HttpSessionActivationListener接口定义了两个方法：void sessionWillPassivate(<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionEvent.html" rel="nofollow">HttpSessionEvent</a> se) 和 void sessionDidActivate(<a title="class in javax.servlet.http" href="http://java.sun.com/webservices/docs/1.5/api/javax/servlet/http/HttpSessionEvent.html" rel="nofollow">HttpSessionEvent</a> se)，每个方法都接受一个HttpSessionEvent对象作为参数。</p> 
 <p>       官方英文说明：Objects that are bound to a session may listen to container events notifying them that sessions will be passivated and that session will be activated. A container that migrates session between VMs or persists sessions is required to notify all attributes bound to sessions implementing HttpSessionActivationListener. （说实话，这个我看不懂, 当对象所捆绑着的session将被阻塞或激活的时候，捆绑着这个session的对象可能听从通知它的容器事件。当session在虚拟机之间、或在持久存储设备中移动时，它就会被阻塞或者激活，容器被要求去通知所有捆绑着session并实现HttpSessionActivationListener接口的attribute对象。我是这样翻译的啦，看了的朋友如果觉得有问题，不吝指教）    </p> 
 <p>       //当session即将被阻塞时执行这个方法</p> 
 <p>       void sessionWillPassivate(HttpSessionEvent se)</p> 
 <p>       //当session刚被激活时执行这个方法</p> 
 <p>       void sessionDidActivate(HttpSessionEvent se)</p> 
 <p> </p> 
 <p> </p> 
 <p> </p> 
 <hr> 
 <p> </p> 
 <p>下面是HttpSessionEvent类的方法</p> 
 <p>public HttpSession getSession()</p> 
 <p>HttpSessionBindingEvent类的方法</p> 
 <p>public HttpSession getSession()</p> 
 <p>public java.lang.String getName();</p> 
 <p>public java.lang.Object getValue()</p> 
 <p>下面是两个类都有的通过继承得到的方法</p> 
 <table border="1" cellspacing="0" cellpadding="3"><tbody><tr class="TableSubHeadingColor" bgcolor="#eeeeff"><td><strong>Methods inherited from class java.util.EventObject</strong></td></tr><tr class="TableRowColor" bgcolor="#ffffff"><td><code>getSource, toString</code></td></tr></tbody></table> 
 <p style="text-align:left;"> </p> 
 <table border="1" cellspacing="0" cellpadding="3"><tbody><tr class="TableSubHeadingColor" bgcolor="#eeeeff"><td><strong>Methods inherited from class java.lang.Object</strong></td></tr><tr class="TableRowColor" bgcolor="#ffffff"><td><code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></td></tr></tbody></table> 
 <p> </p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;">JavaWeb中的Session </p> 
 <p style="text-align:left;">Session的创建（代表会话周期的开始）：第一次调用request.getSession()方法时，会创建一个session对象。 <br>Session的销毁（代表会话周期的结束）：在某个请求周期内调用了Session.invalidate()方法，此请求周期结束后，session被销毁；或者是session超时后自动销毁。 <br>对于JSP，如果指定了&lt;%@ page session="false"%&gt;，则在JSP中无法直接访问内置的session变量，同时也不会主动创建session，因为此时JSP未自动执行request.getSession()操作获取session。 <br>在session对象刚创建的第一个请求周期内，调用session.isNew()方法将得到true。 <br>可以在web.xml文件中配置session默认的超时时间（分钟）： <br>&lt;session-config&gt; <br>    &lt;session-timeout&gt;10&lt;/session-timeout&gt; <br>&lt;/session-config&gt;也可以调用session. setMaxInactiveInterval()方法设置session超时时间（分钟） <br>SessionListener <br><br>通过SessionListenr可以监听session的创建和销毁，步骤： <br>1.写一个类MySessionListener，实现javax.servlet.http.HttpSessionListener接口及其sessionCreated()、sessionDestroyed()方法 <br>2.在web.xml中配置SessionListener： <br>&lt;listener&gt; <br>    &lt;listener-class&gt;MySessionListener类全名&lt;/listener-class&gt; <br>&lt;/listener&gt; <br>当session被创建和销毁时，容器会分别调用SessionListener的sessionCreated()方法和sessionDestroyed()方法，这两个方法中传入了一个参数对象HttpSessionEvent，可以通过此对象的getSession()方法获取session对象。 <br>应用：在线人数统计 <br><br>import java.util.HashSet; <br>import javax.servlet.ServletContext; <br>import javax.servlet.http.HttpSession; <br>import javax.servlet.http.HttpSessionEvent; <br>import javax.servlet.http.HttpSessionListener; <br><br>public class MySessionListener implements HttpSessionListener { <br><br>       public void sessionCreated(HttpSessionEvent event) { <br>              HttpSession session = event.getSession(); <br>              ServletContext application = session.getServletContext(); <br>              <br>              // 在application范围由一个HashSet集保存所有的session <br>              HashSet sessions = (HashSet) application.getAttribute("sessions"); <br>              if (sessions == null) { <br>                     sessions = new HashSet(); <br>                     application.setAttribute("sessions", sessions); <br>              } <br>              <br>              // 新创建的session均添加到HashSet集中 <br>              sessions.add(session); <br>              // 可以在别处从application范围中取出sessions集合 <br>              // 然后使用sessions.size()获取当前活动的session数，即为“在线人数” <br>       } <br><br>       public void sessionDestroyed(HttpSessionEvent event) { <br>              HttpSession session = event.getSession(); <br>              ServletContext application = session.getServletContext(); <br>              HashSet sessions = (HashSet) application.getAttribute("sessions"); <br>              <br>              // 销毁的session均从HashSet集中移除 <br>              sessions.remove(session); <br>       } <br>} </p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;">blog:<a href="http://www.blogjava.net/wealupa/archive/2008/05/20/201588.html" rel="nofollow">http://www.blogjava.net/wealupa/archive/2008/05/20/201588.html</a></p> 
 <p style="text-align:left;"><a href="http://5aijava.iteye.com/blog/163694" rel="nofollow">http://5aijava.iteye.com/blog/163694</a></p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;"> </p> 
 <p style="text-align:left;"> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/kentyouyou/p/3574027.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2d3490d3707e6e0ed2aaa5b6323c2849/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">内核调试方法 三</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/55a7c3f3bd5c887d8a2bedd175fbc029/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BerkeleyDB同名key值（Duplicate Key）的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>