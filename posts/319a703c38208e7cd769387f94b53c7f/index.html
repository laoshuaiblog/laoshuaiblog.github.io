<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>六大原则与设计模式 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/319a703c38208e7cd769387f94b53c7f/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="六大原则与设计模式">
  <meta property="og:description" content="1. 六大原则 1.1 单一原则（SRP） 应该有且仅有一个原因引起类的变更
1. 复杂性降低，可读性高，可维护性提高
2. 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。
class a{ public function info(){ echo &#34;第一条消息&#34;; } } class b{ public function text(){ echo &#34;第二条消息&#34;; } } class c { public function run(){ $a = new a(); $a-&amp;gt;info(); $b = new b(); $b-&amp;gt;text(); } } $c = new c(); $c-&amp;gt;run(); 1.2 开闭原则 类应该对扩展开放，对修改关闭
interface A{ public function boot(); } class B implements A{ public function boot(){ return rand(1,100); } } class cli{ public function run(){ $b= new B(); return $b-&amp;gt;boot(); } } $cli = new cli(); echo $cli-&amp;gt;run(); 1.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-27T22:00:00+08:00">
    <meta property="article:modified_time" content="2024-03-27T22:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">六大原则与设计模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1. 六大原则</h4> 
<h5>1.1 单一原则（SRP）</h5> 
<p>应该有且仅有一个原因引起类的变更</p> 
<p>1. 复杂性降低，可读性高，可维护性提高</p> 
<p>2. 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</p> 
<pre><code class="language-php">class a{
    public function info(){
        echo "第一条消息";
    }
}
class b{
    public function text(){
        echo "第二条消息";
    }
}
class c {
    public function run(){
        $a = new a();
        $a-&gt;info();
        $b = new b();
        $b-&gt;text();
    }
}
$c = new c();
$c-&gt;run();</code></pre> 
<h5>1.2 开闭原则</h5> 
<p>类应该对扩展开放，对修改关闭</p> 
<pre><code class="language-php">interface A{
    public function boot();
}

class B implements A{
    public function boot(){
      return rand(1,100);
    }
}

class cli{
    public function run(){
        $b= new B();
        return $b-&gt;boot();
    }
}
$cli = new cli();
echo $cli-&gt;run();</code></pre> 
<h5>1.3 里氏替换原则</h5> 
<p>子类必须能够替换掉它们的基类</p> 
<pre><code class="language-php">class A{
    public function a(){
        return "电子产品";
    }
}
class B extends A{
    public function a()
    {
        return "手机";
    }
}
class client
{
    public function run()
    {
        $b = new B();
        echo $b-&gt;a();

    }
}
$client = new client();
$client-&gt;run();</code></pre> 
<h5>1.4 依赖倒置原则</h5> 
<p>高层模块不应该依赖于低层模块，它们都应该依赖于抽象。</p> 
<pre><code class="language-php">interface A{
    public function str();
}

class B implements A{
    public function str()
    {
        return rand(1,100);
    }
}
class C implements A{
    public function str()
    {
        return "123";
    }
}</code></pre> 
<h5>1.5 接口隔离原则 (ISP)   </h5> 
<p>类不应该依赖于它不需要的接口</p> 
<pre><code class="language-php">interface A{
    public function a();
    public function b();
}
class B implements A{
    public function a()
    {
        return "a";
    }
    public function b()
    {
        return "b";
    }
}</code></pre> 
<p></p> 
<h5>1.6 迪米特法则</h5> 
<p>优先使用对象组合而不是类继承</p> 
<pre>class a{
    protected  $user;
    public  function __construct(\think\App $app)
    {
        $this-&gt;user=$app;
    }

    public function index($id){
        return $this-&gt;user-&gt;index($id);
    }
}</pre> 
<p></p> 
<p>这些原则有助于写出高内聚、低耦合的代码，使得代码更易于维护和扩展。</p> 
<p></p> 
<h4>2. 设计模式</h4> 
<h5>2.1 结构型模式</h5> 
<h6>2.1.1 装饰器模式</h6> 
<p>装饰器模式用于动态地将新的行为添加到对象上，对于需要扩展功能的类来说是一种更加灵活的设计方案。在PHP中，可以使用装饰器模式来为已有的对象添加新的行为，不需要修改已有类的代码。</p> 
<p>装饰器的优点:</p> 
<p>1. 不改变代码的情况下对原代码的功能职责进行扩展,遵守了开闭原则</p> 
<p>2. 每个类都有属于自己的功能职责</p> 
<pre><code class="language-php">interface MobileCase
{
    public function boot();
}

class Mobile implements MobileCase
{
    public function boot()
    {
        echo "无色无图案手机壳".PHP_EOL;
    }
}

abstract class MobileDecorator implements MobileCase
{
    protected $mobileCase;

    public function __construct(MobileCase $mobileCase)
    {
        $this-&gt;mobileCase = $mobileCase;
    }

    public function boot()
    {
        $this-&gt;mobileCase-&gt;boot();
    }
}

class HedMobileCase extends MobileDecorator
{
    private $name = "红色手机壳";

    private function add()
    {
        echo $this-&gt;name.PHP_EOL;
    }

    public function boot()
    {
        $this-&gt;mobileCase-&gt;boot();
        $this-&gt;add();
    }
}

class GreenMobileCase extends MobileDecorator
{
    private $name = "黄色手机壳";

    private function add()
    {
        echo $this-&gt;name.PHP_EOL;
    }

    public function boot()
    {
        $this-&gt;mobileCase-&gt;boot();
        $this-&gt;add();
    }
}

class client
{
    public function run()
    {
        $MobileCase = new Mobile();
        $HedMobileCase = new HedMobileCase($MobileCase);
        $HedMobileCase-&gt;boot();
    }
}

$client = new client();
$client-&gt;run();</code></pre> 
<h6>2.1.2 facade门面模式</h6> 
<p>又称为外观模式,为子系统中的一组接口提供一个统一的高层接口， 使得子系统更容易使用</p> 
<p>门面模式的组成:</p> 
<p>1. 外观角色 ：模式的核心，被客户 Client 调用，知道各个子系统的概念。</p> 
<p>2. 子系统角色 ：实现子系统的功能。</p> 
<p>3. 客户角色 ：调用 Facade 角色获取相应的功能。</p> 
<p>门面模式的优缺点:</p> 
<p>1. 降低系统的复杂程度 2. 低耦合 3. 使用简单 4. 可能违背开闭原则</p> 
<pre><code class="language-php">class Connection
{
    private function conn()
    {
        try {
            $connection = new PDO('mysql:host=127.0.0.1;dbname=starsky','root','root');
            return $connection;
        }catch (PDOException $exception){
            echo $exception-&gt;getMessage();
        }
    }

    public function run()
    {
        return $this-&gt;conn();
    }
}
class DBQuery
{
    public function query(Connection $connection,$sql)
    {
        try {
            $pdo = $connection-&gt;run();
            $restful = $pdo-&gt;query($sql)-&gt;fetchAll();
            return $restful;
        }catch (PDOException $exception){
            echo $exception-&gt;getMessage();
        }
    }
}
class facade
{
    private $query;

    private $conn;

    public function __construct()
    {
        $this-&gt;query = new DBQuery();
        $this-&gt;conn = new Connection();
    }

    public function select($sql)
    {
        return $this-&gt;query-&gt;query($this-&gt;conn,$sql);
    }
}
class DB
{
    private static $query;

    public static function select($sql)
    {
        static::$query = new facade();
        return self::$query-&gt;select($sql);
    }
}
var_dump(DB::select('select * from `user`'));</code></pre> 
<h6>2.1.3 注册树模式</h6> 
<p>通过将对象实例注册到一棵全局的对象树上，需要的时候从对 象树上采摘的模式设计方法</p> 
<p>1. Laravel框架的服务容器          2. Thinkphp框架</p> 
<pre><code class="language-php">
class Container
{
   private $bindings = [];

   public function bind($abstract, $concrete = null, $shared = false)
   {
       $this-&gt;bindings[$abstract]['concrete'] = $concrete;
       $this-&gt;bindings[$abstract]['shared'] = $shared;
   }

   public function make($abstract,$parameters = [])
   {
       $object = $this-&gt;bindings[$abstract]['concrete'];

       if ($object instanceof \Closure){
           return $object();
       }

       if (!is_object($object)){
           $object = new $object(...$parameters);
       }

       return  $object;
   }

   public function delete($abstract)
   {
       unset($this-&gt;bindings[$abstract]);
   }
}
class A
{
   public function run()
   {
       echo "这里是A类的run方法";
   }
}

$container = new Container();
$container-&gt;bind('a',new A());
$container-&gt;make('a')-&gt;run();

class Container
{
   //用于存储实例化的对象或者类的命名空间
   private $bindings = [];

   //注册对象到$bindings数组里面,进行存储
   public function bind($abstract, $concrete = null)
   {
       $this-&gt;bindings[$abstract] = $concrete;
   }
}
class A{

}
$container = new Container();
$container-&gt;bind('A',new A());
interface I
{
    public function boot();
}
/**
 * Class A php项目生成的数据 =&gt; 给java语言接口
 */
class A implements I
{
    public function boot()
    {
        $data = ["id" =&gt;1,"name" =&gt; "starsky"];
        return json_encode($data);
    }
}

/**
 * Class B java生成的数据 =&gt;php语言接口
 */
class B implements I
{
    public function boot()
    {
        $data = ["id" =&gt;1,"name" =&gt; "starsky"];
        return serialize($data);
    }
}

interface I_Apadtor
{
    public function boot(I $i);
}

class Apadtor implements I_Apadtor
{
    public function boot(I $i)
    {
        if (!is_null($string = json_decode($i-&gt;boot()))){
            return serialize($string);
        }else{
            $string = unserialize($i-&gt;boot());
            return json_encode($string);
        }
    }
}
$Apadtor = new Apadtor();
//java端调用php端数据
var_dump("java调用php的数据:".$Apadtor-&gt;boot(new A()));
//php端调用java端数据
var_dump("php调用java的数据:".$Apadtor-&gt;boot(new B()));</code></pre> 
<p></p> 
<h6>2.1.4 适配器模式</h6> 
<p>将一个类的接口，转换成客户期望的另一个类的接口。适配器让原 本接口不兼容的类可以合作无间。</p> 
<p></p> 
<pre><code class="language-php">interface I
{
   public function boot();
}

class A implements I
{
   public function boot()
   {
       $data = ["name" =&gt; "starsky","age" =&gt; 100,"sex" =&gt; 1];
       return serialize($data);
   }
}

class B implements I
{
   public function boot()
   {
       $data = ["name" =&gt; "starsky","age" =&gt; 100,"sex" =&gt; 1];
       return json_encode($data);
   }
}

interface I_Adaptor
{
   public function boot(I $i);
}

class Adaptor implements I_Adaptor
{
   public function boot(I $in)
   {
       if (!is_null($string = json_decode($in-&gt;boot()))){
           return serialize($string);
       }else{
           $string = unserialize($in-&gt;boot());
           return  json_encode($string);
       }
   }
}

$Adaptor = new Adaptor();
var_dump(json_decode($Adaptor-&gt;boot((new A()))));
var_dump(unserialize($Adaptor-&gt;boot((new B ()))));
</code></pre> 
<h6>2.1.5 Pipeline模式</h6> 
<p><img alt="" height="142" src="https://images2.imgbox.com/e5/ab/uE7QU59l_o.png" width="664"></p> 
<p>应用场景： 1.订单生成 2.Laravel中中间件的执行</p> 
<pre><code class="language-php">class A
{
    public static function handle($request)
    {
        echo "这里A类的Boot方法".PHP_EOL;
    }
}
class B
{
    public static function handle($request)
    {
        echo "这里是B类的Boot方法".PHP_EOL;
    }
}
class C
{
    public static function handle($request)
    {
        echo "这里是C类的Index方法".PHP_EOL;
    }
}
class D
{
    public function index()
    {
        echo "这里是D类的index方法";
    }
}
interface PipelineInterface
{
    public function pipe($middleware);
    public function then();
}
class Pipeline implements PipelineInterface
{
    protected $Middleware = [];

    protected $request;

    public function __construct($object,$method,$argv = [])
    {
        $this-&gt;request['object'] = $object;
        $this-&gt;request['method'] = $method;
        $this-&gt;request['argv'] = $argv;
    }

    public function pipe($middleware)
    {
        $this-&gt;Middleware = $middleware;
        return $this;
    }

    public function then()
    {
        foreach ($this-&gt;Middleware as $value){
            call_user_func([$value,'handle'],$this-&gt;request);
        }
        return $this;
    }

    public function send()
    {
        $method = $this-&gt;request['method'];
        return $this-&gt;request['object']-&gt;$method(...$this-&gt;request['argv']);
    }
}
class Kernel
{
    protected $Middleware = [];

    public function handle(Pipeline $pipeline)
    {
        return $pipeline-&gt;pipe($this-&gt;Middleware)
            -&gt;then()
            -&gt;send();
    }
}
class Http extends Kernel
{
    protected $Middleware=[
        A::class,
        B::class,
        C::class
    ];
}
$httpKernel = (new Http())-&gt;handle(new Pipeline(new D(),'index'));</code></pre> 
<p></p> 
<h6 style="background-color:transparent;">2.1.6 代理模式</h6> 
<p>给某一个对象提供一个代理，并由代理对象控制对原对象的引用</p> 
<pre><code class="language-php">interface I
{
    public function boot();

    public function handle();
}

class A implements I
{
    public function boot()
    {
        echo "A类的boot方法".PHP_EOL;
    }

    public function handle()
    {
        echo "A类的handle方法".PHP_EOL;
    }
}

class Proxy implements I
{
    protected $A;

    public function __construct(I $i)
    {
        $this-&gt;A = $i;
    }

    public function boot()
    {
        $this-&gt;A-&gt;boot();
    }

    public function handle()
    {
        $this-&gt;A-&gt;handle();
    }
}

$Proxy = new Proxy(new A());
$Proxy-&gt;boot();
$Proxy-&gt;handle();</code></pre> 
<h5>2.2 创建型模式</h5> 
<h6 style="background-color:transparent;">2.2.1 简单工厂模式</h6> 
<p>简单工厂的作用是实例化对象，而不需要客户了解这个对象属于哪个具体的子类。</p> 
<pre><code class="language-php">//mysql报错日志
class MysqlLog
{
}
//Redis报错日志
class RedisLog
{
}
//用户操作错误日志
class UserLog
{
}
//代码错诶日志
class ErrorLog
{
}

class Product
{
    protected $Log;

    public function __construct(array $modules)
    {
        $factory = new LogFactory();
        foreach ($modules as $module){
            $this-&gt;Log[$module] = $factory-&gt;make($module);
        }
    }

    public function getLog()
    {
        return $this-&gt;Log;
    }
}

class LogFactory
{
    public function make($abstract)
    {
        switch ($abstract){
            case 'mysql':
                return new MysqlLog();
            case 'redis':
                return new RedisLog();
            case 'user':
                return new UserLog();
            case 'error':
                return new ErrorLog();
        }
    }
}

$Product = new Product(array(
    'mysql',
    'redis',
    'user',
    'error'
));
var_dump($Product-&gt;getLog());</code></pre> 
<h6>2.2.2 Factory工厂模式</h6> 
<p>简单工厂模式的延伸,是在简单工厂的优点上去解决它的缺陷 </p> 
<p>方法工厂模式的优点: 1.拥有良好的封装性，代码结构清晰 2. 拥有良好的扩展性 3. 屏蔽产品类</p> 
<p>使用场景: 1. 日志记录 2. 多接口支付 3. 数据库连接封装</p> 
<pre><code class="language-php">interface LogInterface
{
    public function log();
}
//mysql报错日志
class MysqlLog implements LogInterface
{
    public function log()
    {
        // TODO: Implement log() method.
    }
}
//Redis报错日志
class RedisLog implements LogInterface
{
    public function log()
    {
        // TODO: Implement log() method.
    }
}
//用户操作错误日志
class UserLog implements LogInterface
{
    public function log()
    {
        // TODO: Implement log() method.
    }
}
//代码错诶日志
class ErrorLog implements LogInterface
{
    public function log()
    {
        // TODO: Implement log() method.
    }
}

class Product
{
    protected $Log;

    public function __construct()
    {
        $this-&gt;Log = array(
            (new MysqlLogFactory())-&gt;make(),
            (new RedisLogFactory())-&gt;make(),
            (new UserLogFactory())-&gt;make(),
            (new ErrorLogFactory())-&gt;make()
        );
    }

    public function getLog()
    {
        return $this-&gt;Log;
    }
}

interface LogFactory
{
    public function make();
}

class MysqlLogFactory implements LogFactory
{
    public function make()
    {
        return new MysqlLog();
    }
}
class RedisLogFactory implements LogFactory
{
    public function make()
    {
        return new RedisLog();
    }
}
class UserLogFactory implements LogFactory
{
    public function make()
    {
        return new UserLog();
    }
}

class ErrorLogFactory implements LogFactory
{
    public function make()
    {
        return new ErrorLog();
    }
}
$product = new Product();
var_dump($product-&gt;getLog());</code></pre> 
<h6>2.2.3 抽象工厂模式</h6> 
<p>给客户端提供一个接口，可以创建多个产品族中的产品对象 </p> 
<p>抽象工厂模式的优缺点: 1. 分离了具体的实现类 2. 增加替换工厂类目变的方便 3. 有利于统一同一类型的类目</p> 
<pre><code class="language-php">interface PayInterface
{
    public function pay();
}

class AliPay implements PayInterface
{
    public function pay()
    {
        return "支付宝支付";
    }
}

class TenPay implements PayInterface
{
    public function pay()
    {
        return "微信支付";
    }
}

interface LogInterface
{
    public function log();
}

class MysqlLog implements LogInterface
{
    public function log()
    {
        return "记录mysql日志";
    }
}

class RedisLog implements LogInterface
{
    public function log()
    {
        return "记录Redis日志";
    }
}

interface PayFactoryInterface
{
    public function AliPayMake();

    public function TenPayMake();
}

interface LogFactoryInterface
{
    public function MysqlLogMake();

    public function RedisLogMake();
}

class PayFactory implements PayFactoryInterface
{
    public function AliPayMake()
    {
        return new AliPay();
    }

    public function TenPayMake()
    {
        return new TenPay();
    }
}

class LogFactory implements LogFactoryInterface
{
    public function MysqlLogMake()
    {
        return new MysqlLog();
    }

    public function RedisLogMake()
    {
        return new RedisLog();
    }
}

class Order
{
    protected $log;

    protected $pay;

    public function __construct()
    {
        $LogFactory = new LogFactory();
        $PayFactory = new PayFactory();
        $this-&gt;log = array(
            'mysql' =&gt; $LogFactory-&gt;MysqlLogMake(),
            'redis' =&gt; $LogFactory-&gt;RedisLogMake()
        );
        $this-&gt;pay = array(
            'Ali' =&gt; $PayFactory-&gt;AliPayMake(),
            'Ten' =&gt; $PayFactory-&gt;TenPayMake()
        );
    }

    public function getLog()
    {
        return $this-&gt;log;
    }

    public function getPay()
    {
        return $this-&gt;pay;
    }
}

$order = new Order();
var_dump($order-&gt;getLog());
var_dump($order-&gt;getPay());</code></pre> 
<h6>2.2.4 Single单例模式</h6> 
<p>保证一个类只有一个实例，并提供一个访问它的全局访问点</p> 
<p>使用场景: 1. 数据库连接 2. 日志操作类 3. 请求管理类 4. 配置管理类</p> 
<pre><code class="language-php">class Request
{
   private static $request;
   protected $method;
   protected $uriPath;
   private function __construct(){}
   private function __clone(){}
   public static function getRequest()
   {
       if (self::$request == null){
           self::$request = new Request();
       }
       self::$request-&gt;method = $_SERVER['REQUEST_METHOD'];
       self::$request-&gt;uriPath= $_SERVER['REQUEST_URI'];
       return self::$request;
   }
   public function getMethod()
   {
       return $this-&gt;method;
   }
   public function getUriPath()
   {
       return $this-&gt;uriPath;
   }
   public function isMethod($method):bool
   {
       return $this-&gt;method === strtoupper($method);
   }
}
$request = Request::getRequest();
var_dump($request-&gt;isMethod('get'));</code></pre> 
<h5>2.3 行为型模式</h5> 
<h6>2.3.1 策略模式</h6> 
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换</p> 
<p>策略模式使用的业务场景: 1. 短语发送 2. 多支付接口 3. 日志记录  </p> 
<pre><code class="language-php">interface PayInterface
{
    public function pay();
}
class AliPay implements PayInterface
{
    public function pay()
    {
        echo "支付宝支付";
    }
}
class TenPay implements PayInterface
{
    public function pay()
    {
        echo "微信支付";
    }
}
class Pay
{
    protected $pay;
    public function __construct(PayInterface $pay)
    {
        $this-&gt;pay = $pay;
    }
    public function getPay()
    {
        return $this-&gt;pay;
    }
}
$pay = new Pay(new AliPay());
$pay-&gt;getPay()-&gt;pay();</code></pre> 
<h6>2.3.2 Observe观察者模式</h6> 
<p>多个对象间存在一对多的依赖关系，当一个对象的状态 发生改变时，所有依赖于它的对象都得到通知并被自动更新</p> 
<p>观察者模式的使用场景: 1. 订单支付场景 2. 发布订阅类型的功能</p> 
<p>观察者模式的优点: 1. 观察者与被观察者依赖于抽象 2. 观察者符合开闭原则,只要符合接口,就能够进行扩展</p> 
<p>观察者模式的缺点: 1. 依赖于接口的关系,具备一定的局限性 2. 过多的观察者,代码运行消耗可能会很大</p> 
<pre><code class="language-php">interface OrderPayInterface
{
    public function PayEvent($OrderId = null);
}

class OrderPay implements OrderPayInterface
{
    public function PayEvent($OrderId = null)
    {
        echo "订单ID为:{$OrderId}的订单状态为已支付".PHP_EOL;
    }
}
abstract class OrderEventAbstract
{
    private $Observer;

    public function register(OrderPayInterface $pay)
    {
        $this-&gt;Observer = $pay;
    }

    public function notify($OrderId)
    {
        $this-&gt;Observer-&gt;PayEvent($OrderId);
    }
}
class Order extends OrderEventAbstract
{
    public function pay($OrderId)
    {
        echo "支付成功".PHP_EOL;
        $this-&gt;notify($OrderId);
    }
}
$order = new Order();
$order-&gt;register(new OrderPay());
$order-&gt;pay(1);</code></pre> 
<h6>2.3.3 命令链模式</h6> 
<p>以松散耦合主题为基础，发送消息、命令和请求，或通过一组处理 程序发送任意内容</p> 
<p>命令链模式的应用场景: 1. 登录注册不同角色的业务操作 2. 直播间不同等级会员业务 3. 订单支付状态</p> 
<pre><code class="language-php">interface CommandInterface
{
    public function runCommand($name,$argv);
}
class CreateControllerCommand implements CommandInterface
{
    public function runCommand($name, $argv)
    {
        echo "创建控制器".PHP_EOL;
    }
}
class CreateModelCommand implements CommandInterface
{
    public function runCommand($name, $argv)
    {
        echo "创建模型".PHP_EOL;
    }
}
class Command
{
    private $command = [];
    public function register(array $command)
    {
        $this-&gt;command = $command;
    }
    public function run($name,$argv)
    {
        foreach ($this-&gt;command as $key=&gt;$value){
            if ($name == $key){
                return $value-&gt;runCommand($name,$argv);
            }
        }
    }
}
$command = new Command();
$command-&gt;register(array(
    'controller' =&gt; new CreateControllerCommand(),
    'model' =&gt; new CreateModelCommand()
));
$command-&gt;run('model',1);
interface RoleLoginInterface
{
    public function handle($name);
}

class bronze implements RoleLoginInterface
{
    public function handle($name)
    {
        echo "欢迎{$name}进入直播间".PHP_EOL;
    }
}

class silver implements RoleLoginInterface
{
    public function handle($name)
    {
        echo "欢迎白银会员{$name}进入直播间".PHP_EOL;
    }
}

class gold implements RoleLoginInterface
{
    public function handle($name)
    {
        echo "欢迎黄金大神{$name}进入直播间,此时有掌声与音乐".PHP_EOL;
    }
}

class Role
{
    private $role = [];
    public function register(array $role)
    {
        $this-&gt;role = $role;
    }
    public function LoginEvent($name,$role)
    {
        foreach ($this-&gt;role as $key =&gt; $value){
            if ($role == $key){
                return $value-&gt;handle($name);
            }
        }
    }
}
$role = new Role();
$role-&gt;register(array(
    'bronze' =&gt; new bronze(),
    'silver' =&gt; new silver(),
    'gold'   =&gt; new gold()
));
$role-&gt;LoginEvent('harry','bronze');
$role-&gt;LoginEvent('xx','gold');
$role-&gt;LoginEvent('lori','silver');</code></pre> 
<h6>2.3.4 迭代器模式</h6> 
<p>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该 对象的内部显示</p> 
<p>迭代器模式的角色: 1. 迭代器:迭代器定义访问和遍历元素的接口 2. 具体迭代器: 实现迭代器接口,对该聚合遍历时跟踪当前位置 3. 聚合: 聚合实现创建相应迭代器的接口,这个操作是返回具体迭代器的实例</p> 
<p>迭代器的优点: 1.多种遍历方式 2.简化聚合类 3.为不同的集合提供统一的接口</p> 
<p>迭代器的缺点: 迭代器模式将存储数据和遍历数据的职责分离增加新的集合对象时需要增加 对应的迭代器类，类的个数成对增加，在一定程度上增加系统复杂度</p> 
<p>使用场景： 1.访问一个聚合对象的内容而无需暴露它的内部表示 2.支持对聚合对象的多种遍历 3.为遍历不同的聚合结构提供一个统一的接口</p> 
<pre><code class="language-php">class CycleIterator implements Iterator
{
    private $array = [];
    private $currentIndex = 0;
    public function __construct($array)
    {
        $this-&gt;array = $array;
    }
    public function current()
    {
        return $this-&gt;array[$this-&gt;currentIndex];
    }
    public function setCurrentIndex($currentIndex)
    {
        $this-&gt;currentIndex = $currentIndex;
    }
    public function setArray($array)
    {
        $this-&gt;array = $array;
    }
    public function getCurrentIndex()
    {
        return $this-&gt;currentIndex;
    }
    public function getArray()
    {
        return $this-&gt;array;
    }
    public function key()
    {
        return $this-&gt;currentIndex;
    }
    public function next()
    {
        ++$this-&gt;currentIndex;
    }
    public function rewind()
    {
        $this-&gt;currentIndex = 0;
    }
    public function valid()
    {
        return isset($this-&gt;array[$this-&gt;currentIndex]);
    }
}

class Cycle implements IteratorAggregate
{
    protected $array;
    public function __construct($array)
    {
        $this-&gt;array = $array;
    }
    public function getIterator()
    {
        return new CycleIterator($this-&gt;array);
    }
}
$list = [1,2,3,4,5,6,7,8,9];
$cycle= new CycleIterator($list);
foreach ($cycle as $value){
    echo $value.PHP_EOL;
}</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4a27f83dc474cebfb4d008fbd85f03b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">畅谈近年来网络安全发展趋势以及薪资情况</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c80b312984e413f1a530994650e8d14c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">探索BPMN：业务流程模型与表示法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>