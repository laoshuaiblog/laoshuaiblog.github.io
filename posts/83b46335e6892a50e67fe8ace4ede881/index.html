<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序算法：【选择排序] - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/83b46335e6892a50e67fe8ace4ede881/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="排序算法：【选择排序]">
  <meta property="og:description" content="一、选择排序——时间复杂度 定义：第一趟排序，从整个序列中找到最小的数，把它放到序列的第一个位置上，第二趟排序，再从无序区找到最小的数，把它放到序列的第二个位置上，以此类推。
也就是说，首先从序列中找到最小的元素，放到有序区的第一个位置上，然后再从剩下的无序区中，继续找最小的元素，放到有序区的末尾。
1、容易想到的方法——不推荐 新建一个空列表，然后每遍历一次老列表时候，就把一个最小值，放到新列表里，同时再把这个值从老列表里删除掉。
但这种方法有两个缺点：
（1）额外占内存。因为新建了一个空列表 l1，所以就会多占用一个内存空间。
（2）时间复杂度高，排序效率慢。
列表的增加和删除方法，时间复杂度都是O(n)。
原因：把最小值加到新列表里，首先要先找到最小值，而找最小值的过程，其实就是把所有值都遍历一遍，所以，增加的操作，时间复杂度式O(n)。
同理，对于删除操作也一样，你要删掉最小值，首先得找到，而找最小值的过程就是要把列表全部遍历一遍，时间复杂度也是O(n)。
所以，法1中，增加和删除操作，它俩时间复杂度其实也就是O(n)&#43;O(n)，因为他俩是并行运行的，不是嵌套运行，所以结果还是O(n)。外面还有一个for循环，所以法1代码，复杂度就是。
# 法1 def select_sort_simple(li): l1 = [] for i in range(len(li)): # 时间复杂度o(n) l1.append(min(li)) li.remove(min(li)) return l1 result = select_sort_simple([5, 3, 7, 2, 4]) print(result) # 结果： [2, 3, 4, 5, 7] 或许你会说，把最小值，赋值给一个变量，比如，a=min(li)，然后每次增加删除这个值，结果还一样吗？答案是肯定一样的，因为，你即使把它赋值给一个变量，但前提，你也得先找到这个最小值，而找最小值的过程就是把列表所有值都遍历一遍，此时它的复杂度就已经是了，再加上外面的for循环，代码整体复杂度还是。
# 法2 最小值，赋值给一个变量 def select_sort_simple(li): l1 = [] for i in range(len(li)): # 时间复杂度 O(n) a=min(li) # 时间复杂度 O(n) l1.append(a) li.remove(a) return l1 result = select_sort_simple([5, 3, 7, 2, 4]) print(result) # 结果同上 2、使用切片的方式控制无序区——推荐 使用切片的方式控制无序区，每一趟排序后，都将无序区中的最小值，放到无序区的第一个位置，也就是说，把无序区的最小值跟无序区的第一个元素进行交换，此时，这个最小值也就自然放到了有序区的末尾。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-11T19:18:31+08:00">
    <meta property="article:modified_time" content="2023-12-11T19:18:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序算法：【选择排序]</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#ff9900;"><strong>一、选择排序——时间复杂度<img alt="O(n^{2})" class="mathcode" src="https://images2.imgbox.com/f6/08/zcqrHBX2_o.png"></strong></span></h2> 
<p><strong>定义：</strong>第一趟排序，从整个序列中找到最小的数，把它放到序列的第一个位置上，第二趟排序，再从无序区找到最小的数，把它放到序列的第二个位置上，以此类推。</p> 
<p>        也就是说，首先从序列中找到最小的元素，放到有序区的第一个位置上，然后再从剩下的无序区中，继续找最小的元素，放到有序区的末尾。</p> 
<h3><span style="color:#ff9900;"><strong>1、容易想到的方法——不推荐</strong></span></h3> 
<p>        新建一个空列表，然后每遍历一次老列表时候，就把一个最小值，放到新列表里，同时再把这个值从老列表里删除掉。</p> 
<p><strong>但这种方法有两个缺点：</strong></p> 
<p>（1）额外占内存。因为新建了一个空列表 l1，所以就会多占用一个内存空间。</p> 
<p>（2）时间复杂度高，排序效率慢。</p> 
<p><strong>        列表的增加和删除方法，时间复杂度都是O(n)。</strong></p> 
<p>        原因：把最小值加到新列表里，首先要先找到最小值，而找最小值的过程，其实就是把所有值都遍历一遍，所以，增加的操作，时间复杂度式O(n)。</p> 
<p>        同理，对于删除操作也一样，你要删掉最小值，首先得找到，而找最小值的过程就是要把列表全部遍历一遍，时间复杂度也是O(n)。</p> 
<p>        所以，法1中，增加和删除操作，它俩时间复杂度其实也就是O(n)+O(n)，因为他俩是并行运行的，不是嵌套运行，所以结果还是O(n)。外面还有一个for循环，所以法1代码，复杂度就是<img alt="O(n^{2})" class="mathcode" src="https://images2.imgbox.com/44/74/euUsHk6a_o.png">。</p> 
<pre><code class="language-python"># 法1
def select_sort_simple(li):  
    l1 = []
    for i in range(len(li)):  # 时间复杂度o(n)
        l1.append(min(li))   
        li.remove(min(li)) 

    return l1

result = select_sort_simple([5, 3, 7, 2, 4])
print(result)

# 结果：
[2, 3, 4, 5, 7]</code></pre> 
<p>        或许你会说，把最小值，赋值给一个变量，比如，a=min(li)，然后每次增加删除这个值，结果还一样吗？答案是肯定一样的，因为，你即使把它赋值给一个变量，但前提，你也得先找到这个最小值，而找最小值的过程就是把列表所有值都遍历一遍，此时它的复杂度就已经是<img alt="O(n)" class="mathcode" src="https://images2.imgbox.com/4a/2a/OhaRTSb4_o.png">了，再加上外面的for循环，代码整体复杂度还是<img alt="O(n^{2})" class="mathcode" src="https://images2.imgbox.com/25/99/wQvgVnNc_o.png">。</p> 
<pre><code class="language-python"># 法2 最小值，赋值给一个变量
def select_sort_simple(li):  
    l1 = []
    for i in range(len(li)):  # 时间复杂度 O(n)
        a=min(li)   # 时间复杂度 O(n)
        l1.append(a)   
        li.remove(a)  

    return l1

result = select_sort_simple([5, 3, 7, 2, 4])
print(result)
# 结果同上</code></pre> 
<h3><span style="color:#ff9900;"><strong>2、使用切片的方式控制无序区——推荐</strong></span></h3> 
<p>        使用切片的方式控制无序区，每一趟排序后，都将无序区中的最小值，放到无序区的第一个位置，也就是说，<strong><span style="background-color:#fbd4d0;">把无序区的最小值跟无序区的第一个元素进行交换</span></strong>，此时，这个最小值也就自然放到了有序区的末尾。</p> 
<p>跟上面方法相比，虽然时间复杂度一样，但是不用新建空列表。</p> 
<pre><code class="language-python"># 推荐！！！
def select_sort(li): 
    for i in range(len(li) - 1):  # 总共要排n-1趟
        min_val = min(li[i:])  # !!! 每遍历一次，无序区就会少一个数
        a = li.index(min_val)  # 找到最小值的下标
        li[i], li[a] = li[a], li[i]  # 每趟遍历，就把最小值与这趟对应位置上的数进行交换
                           # 或者说，就是把无序区的最小值与无序区第一个数进行交换
    return li


result = select_sort([5, 1, 2, 4])
print(result)
# 结果：
[1, 2, 4, 5]</code></pre> 
<p>效果图： </p> 
<p><img alt="" height="640" src="https://images2.imgbox.com/f7/14/TQ1F5Y97_o.png" width="339"></p> 
<p>当然也可以输出每趟排序的结果，结果跟上图也是一样的：</p> 
<pre><code class="language-python">def select_sort(li):
    for i in range(len(li) - 1):  # 总共要排n-1趟
        min_val = min(li[i:])  
        a = li.index(min_val)  # 找到最小值的下标
        li[i], li[a] = li[a], li[i] 
        print(li)  # ！！每趟排序后的结果
    return li


result = select_sort([5, 1, 2, 4])
print("最终排序结果", result)

# 结果：
[1, 5, 2, 4]
[1, 2, 5, 4]
[1, 2, 4, 5]
最终排序结果 [1, 2, 4, 5]</code></pre> 
<p>上<strong>面方法中，使用的是切片来控制无序区的大小，（或者叫范围），然后再从这个范围里找最小值，这里呢，我们也可以使用 for 循环的形式来控制无序区的范围。</strong>代码如下：</p> 
<p>这个跟上面方法类似，但利用切片方式控制无序区范围，相比for循环会更加简洁明了，所以推荐切片的方法。</p> 
<pre><code class="language-python">def select_sort(li):
    for i in range(len(li) - 1):  # 总共要排n-1趟
        min_loc = i  # 假设无序区的第一个数是最小数
        for j in range(i+1, len(li)):  # 遍历无序区
            if li[j] &lt; li[min_loc]:  # 如果无序区中，有个数比无序区第一个数小
                min_loc = j  # 改变最小值的下标
        li[i], li[min_loc] = li[min_loc], li[i]  # 将无序区第一个数与最小数进行交换
        print(li)  # 每趟排序后的结果
    return li


# result = select_sort([3, 4, 2, 1, 5, 6, 8, 7, 9])
result = select_sort([5, 1, 2, 4])
print("最终排序结果", result)

# 结果：
[1, 5, 2, 4]
[1, 2, 5, 4]
[1, 2, 4, 5]
最终排序结果 [1, 2, 4, 5]</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2419a4c9375c90b610c6bb493d2189a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">n皇后问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9348a5fe8ea31435d11157bb0a933ba8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python中【random】函数用法、randint(a, b)、random( )、uniform(a, b)、shuffle(序列)、sample( )</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>