<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>J2EE基础知识学习（更新ing） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/12685954d05319ac7b5b20a9c3041639/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="J2EE基础知识学习（更新ing）">
  <meta property="og:description" content="封装： 1如何从现实世界中抽象出类？ ​ 现实世界：结合软件工程学的开发模式：瀑布模式 （先有需求分析）
​ 根据需求分析抽象出类
​ 类： 属性 &#43; 变量（类型 长度 最大值 最小值）
​ 行为 &#43; 功能 &#43; 方法 （方法名 参数列表 返回值类型 方法体业务功能等）
一个类可以包含以下类型变量：
局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。 2构造方法的特点和作用是什么？ ​ 构造方法特点：
​ 1：构造方法名和类名保持一致
​ 2：没有返回值类型（void都没有）
​ 3：构造方法可以带参可以不带参 （具有重载的特征）
​ 4：如果定义有带参的构造方法，默认（编辑器生成的）的无参构造方法自动隐藏不做使用
​ 5：构造方法不能继承
​ 6：不能直接手动调用
​ 作用：
​ 1：创建类的实例 （new Object）
​ 2：创建对象的同时进行初始化处理
3什么是默认的构造方法？ ​ 如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。
​ 如果定义了一个构造方法，那么会让默认的无参构造方法失效。（但是如果手动定义一个无参构造方法，无参构造方法还可以使用）
4什么是方法重载？（仅仅与参数列表有关：参数的个数或者类型不同） ​ 一个类的两个方法，相同的名字，有不同的参数列表。
​ 重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。
5如何快速实现POJO类的封装？ ​ POJO
​ 1：属性">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-06-28T11:50:10+08:00">
    <meta property="article:modified_time" content="2021-06-28T11:50:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">J2EE基础知识学习（更新ing）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>封装：</h3> 
<h5><a id="1_2"></a>1<strong>如何从现实世界中抽象出类？</strong></h5> 
<p>​ 现实世界：结合软件工程学的开发模式：瀑布模式 （先有需求分析）</p> 
<p>​ 根据需求分析抽象出类</p> 
<p>​ 类： 属性 + 变量（类型 长度 最大值 最小值）</p> 
<p>​ 行为 + 功能 + 方法 （方法名 参数列表 返回值类型 方法体业务功能等）</p> 
<p>一个类可以包含以下类型变量：</p> 
<ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul> 
<h5><a id="2_18"></a>2<strong>构造方法的特点和作用是什么？</strong></h5> 
<p>​ 构造方法特点：</p> 
<p>​ 1：构造方法名和类名保持一致</p> 
<p>​ 2：没有返回值类型（void都没有）</p> 
<p>​ 3：构造方法可以带参可以不带参 （具有重载的特征）</p> 
<p>​ 4：如果定义有带参的构造方法，默认（编辑器生成的）的无参构造方法自动隐藏不做使用</p> 
<p>​ 5：构造方法不能继承</p> 
<p>​ 6：不能直接手动调用</p> 
<p>​ 作用：</p> 
<p>​ 1：创建类的实例 （new Object）</p> 
<p>​ 2：创建对象的同时进行初始化处理</p> 
<h5><a id="3_40"></a>3<strong>什么是默认的构造方法？</strong></h5> 
<p>​ 如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。</p> 
<p>​ 如果定义了一个构造方法，那么会让默认的无参构造方法失效。（但是如果手动定义一个无参构造方法，无参构造方法还可以使用）</p> 
<h5><a id="4_46"></a>4<strong>什么是方法重载？</strong>（仅仅与参数列表有关：参数的个数或者类型不同）</h5> 
<p>​ 一个类的两个方法，相同的名字，有不同的参数列表。</p> 
<p>​ <strong>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</strong></p> 
<h5><a id="5POJO_52"></a>5<strong>如何快速实现POJO类的封装？</strong></h5> 
<p>​ POJO</p> 
<p>​ 1：属性</p> 
<p>​ 2：构造方法</p> 
<p>​ 3：getter setter方法</p> 
<p>​ 4：简单的方法</p> 
<p>​ 5：实现序列化接口 implement Serializable</p> 
<p>​ 序列化 和 反序列化{<!-- --></p> 
<p>​ 序列化：对象转化为字节序列</p> 
<p>​ 反序列：字节序列还原成对象</p> 
<p>​ 作用：通过RPC(远程过程调用) 网络传输或者对内容的对象进行持久化的时候（字节序列传输）</p> 
<pre><code>	  		 应用场景：把对象持久化到磁盘（数据库）
</code></pre> 
<p>​ }</p> 
<p>lombox插件 快速生成pojo （众多的get和set方法）</p> 
<p>​</p> 
<h5><a id="6_82"></a>6<strong>封装的好处是什么？</strong></h5> 
<p>封装（Encapsulation）是面向对象方法的重要原则，就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节：</p> 
<ul><li>将类的某些信息隐藏在类的内部，不允许外部程序进行直接的访问调用。</li><li>通过该类提供的方法来实现对隐藏信息的操作和访问。</li><li>隐藏对象的信息。</li><li>留出访问的对外接口。</li></ul> 
<p>封装作用：</p> 
<ul><li>对成员变量实行更准确的控制。</li><li>封装可以隐藏内部程序实现的细节。</li><li>良好的封装能够减少代码之间的耦合度。</li><li>外部成员无法修改已封装好的程序代码。</li><li>方便数据检查，有利于保护对象信息的完整性，同时也提高程序的安全性。</li><li>便于修改，体高代码的可维护性。</li></ul> 
<p>封装好处：</p> 
<p>​ 隐藏内部实现细节</p> 
<p>​ 数据与操作分离</p> 
<p>​ 提高复用和维护性</p> 
<p>​ 降低数据与操作的耦合</p> 
<h5><a id="7_110"></a>7<strong>什么是类方法？什么是类属性？</strong></h5> 
<p>​ 类方法（静态方法）使用static修饰的方法</p> 
<p>​ 类属性静态属性 使用static修饰的属性</p> 
<h5><a id="8static_116"></a>8<strong>请说出关于static修饰符的相关知识点？</strong></h5> 
<p>修饰内部类</p> 
<p>修饰方法</p> 
<p>修饰代码块 （static（）随着类加载只执行一次，优先级高 （类加载： 装载-》链接-》初始化 ）</p> 
<p>可以使用类名直接调用静态方法</p> 
<p>可以使用类名直接调用静态方法或属性</p> 
<p>静态方法中不能访问非静态方法或者属性（因为静态方法和属性都是类级别的 比对象级别高 ）</p> 
<p>非静态方法可以访问静态方法或属性</p> 
<p>static不能修饰局部变量</p> 
<h5><a id="9this_134"></a>9<strong>请说出关于this修饰符的相关知识点？</strong></h5> 
<p>​ this指向的当前对象的引用</p> 
<p>​ this.成员变量</p> 
<p>​ this()访问本类构造方法</p> 
<p>​ this(xx xx)调用对应构造方法 必须是构造方法的第一有效语句</p> 
<p><strong>this关键字用法：</strong><br> ​1，本类成员方法中，访问本类的成员变量。</p> 
<p>2，本类成员方法中，访问本类的另一个成员方法。</p> 
<p>3，本类的构造方法中，访问本类的另一个构造方法。</p> 
<p>注意：</p> 
<ul><li>this关键字同super一样，必须在构造方法的第一个语句，且是唯一的。</li><li>this与super不能同时存在。</li></ul> 
<h5><a id="10java_156"></a>10<strong>请说出java中四个常用的访问权限修饰符？</strong></h5> 
<p><img src="https://images2.imgbox.com/2f/07/YBzt4NVZ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>public：</strong> 所修饰的类、变量、方法，在内外包均具有访问权限；</p> 
<p><strong>protected：</strong> 这种权限是为继承而设计的，protected所修饰的成员，对所有子类是可访问的，但只对同包的类是可访问的，对外包的非子类是不可以访问；</p> 
<p><strong>包访问权限（default）：</strong> 只对同包的类具有访问的权限，外包的所有类都不能访问；</p> 
<p><strong>private：</strong> 私有的权限，只对本类的方法可以使用；</p> 
<p><strong>注意：</strong> 要区分开 protected 权限、包访问权限，正确使用它们；</p> 
<ul><li>当某个成员能被所有的子类继承，但不能被外包的非子类访问，就是用protected；</li><li>当某个成员的访问权限只对同包的类开放，包括不能让外包的类继承这个成员，就用包访问权限；</li></ul> 
<h3><a id="_174"></a>继承：</h3> 
<h5><a id="1java_176"></a>1<strong>请说出java中关于继承的相关知识点？</strong></h5> 
<p>​ 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p> 
<p>​ 如果在父类中拥有私有属性(private修饰)，则子类是不能被继承的。</p> 
<p>​ 只支持单继承，即一个子类只允许有一个父类，但是可以实现多级继承，及子类拥有唯一的父类，而父类还可以再继承。</p> 
<p>​ 子类可以继承父类的方法和属性</p> 
<p>​ 好处：实现代码复用 减少代码量 易于软件扩展</p> 
<p>​ 使用：extends</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FU</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Zi</span> <span class="token keyword">extends</span> <span class="token class-name">FU</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2Object_197"></a>2<strong>Object类的相关知识点？</strong></h5> 
<p>​ Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，<strong>子类可以使用 Object 的所有方法</strong>。</p> 
<p>​ 物理包在：rt.jar包 （逻辑包：java.lang//不需要导入，默认导入）</p> 
<p>​ <strong>Java native</strong>关键字的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的， java只能调用，Java不直接操作底层，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了。表示用通过JVM用的其他语言控制。</p> 
<p><img src="https://images2.imgbox.com/de/d6/OWLT7FMj_o.png" alt=""></p> 
<h5><a id="3super_208"></a>3<strong>关于super修饰符的相关知识点？</strong></h5> 
<p><strong>super()关键字的用法</strong></p> 
<p>super.父类的属性</p> 
<p>super.父类的方法</p> 
<p>super（）;调用父类默认的构造方法</p> 
<p>super（xx xx）调用父类对应带参构造方法</p> 
<p>注意：</p> 
<ul><li>this关键字同super一样，必须在构造方法的第一个语句，且是唯一的。</li><li>this与super不能同时存在。</li></ul> 
<p>1，子类的成员方法中，访问父类的成员变量。</p> 
<p>2，子类的成员方法中，访问父类的成员方法。</p> 
<p>3，子类的构造方法中，访问父类的构造方法。</p> 
<h5><a id="4_231"></a>4<strong>方法重写必须满足的要求是什么？</strong></h5> 
<p>子类可以重写父类的方法</p> 
<p>要求{<!-- --></p> 
<p>​ 方法名相同</p> 
<p>​ 参数列表相同</p> 
<p>​ 返回类型相同或是其子类</p> 
<p>​ 不能缩小重写方法的权限</p> 
<p>​ 重写方法不能抛出新异常</p> 
<p>}</p> 
<h5><a id="5_249"></a>5<strong>子类不能继承父类的哪些”财产”？</strong></h5> 
<p>​ private修饰的东西</p> 
<p>​ 父类的构造方法不能继承</p> 
<h5><a id="6_255"></a>6<strong>抽象类和抽象方法的特点是什么？</strong></h5> 
<p>​ 抽象类：abstract修饰类</p> 
<p>​ 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p> 
<p>​ 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</p> 
<p>​ 抽象类中不一定有抽象方法</p> 
<p>​ 抽象类不能实例化</p> 
<p>​ 抽象方法：abstract修饰方法</p> 
<p>​ 如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方 法为抽象方法。</p> 
<p>​ 抽象方法存在于抽象类中或者接口中</p> 
<p>​ 抽象方法与抽象类的现实意义</p> 
<p>​ 声明抽象方法会造成以下两个结果：</p> 
<ul><li>如果一个类包含抽象方法，那么该类必须是抽象类。</li><li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li></ul> 
<p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p> 
<p>抽象类总结规定</p> 
<ul><li>\1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li><li>\2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>\3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li><li>\4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li><li>\5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li></ul> 
<h5><a id="7abstract_290"></a>7<strong>abstract关键字可以修饰什么？不能修饰什么？</strong></h5> 
<p>​ 修饰类、方法</p> 
<p>​ 不能修饰属性和构造方法、类方法</p> 
<p>​ 作用：抽象类是用来捕捉子类的通用特性的，是被用来创建继承层级里子类的模板。现实中有些父类中的方法确实没有必要写，因为各个子类中的这个方法肯定会有不同；而写成抽象类，这样看代码时，就知道这是抽象方法，而知道这个方法是在子类中实现的，所以有提示作用。</p> 
<h5><a id="8_final_298"></a>8 <strong>final关键字可以修饰什么？不能修饰什么？</strong></h5> 
<p>​ 修饰类：不可继承</p> 
<p>​ 修饰属性：必须将变量赋值（变为常量），不可修改</p> 
<pre><code class="prism language-java"><span class="token keyword">final</span> <span class="token keyword">double</span> PI<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span>
</code></pre> 
<p>​ 修饰方法：该方法不能被重写</p> 
<p>​ 不能修饰构造方法</p> 
<h5><a id="9_312"></a>9<strong>继承条件下构造方法的调用规则是什么？</strong></h5> 
<p>​ super 显式调用父类的构造方法的规则优先</p> 
<p>​ 如果没有super显式去调用构造方法，使用默认的构造方法</p> 
<p>​ 多级继承条件下：每次找更高一级父类的构造方法，直到Object类的默认构造方法，然后再从上到下执行。</p> 
<h5><a id="10_320"></a>10<strong>请说出方法重载与方法重写的区别？</strong></h5> 
<p><img src="https://images2.imgbox.com/d6/c1/ZOoudUN6_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dN0jSO4b-1624852152294)(C:\Users\wyx\AppData\Roaming\Typora\typora-user-images\image-20210628114457053.png)]"></p> 
<p><strong>1、方法重写（Override）</strong></p> 
<p>概念：<br> 重写是子类对父类的允许访问的方法的实现过程进行重新编写, <strong>返回值和形参都不能改变</strong>。即外壳不变，核心重写！</p> 
<p>好处：<br> 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p> 
<p>注意：<br> 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。</p> 
<p>在面向对象原则里，重写意味着可以重写任何现有方法。</p> 
<p><strong>重写规则：</strong><br> 参数列表必须完全与被重写方法的相同；<br> 返回类型必须完全与被重写方法的返回类型相同；<br> 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。<br> 父类的成员方法只能被它的子类重写。<br> 声明为final的方法不能被重写。<br> 声明为static的方法不能被重写，但是能够被再次声明。<br> 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。<br> 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。<br> 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。<br> 构造方法不能被重写。<br> 如果不能继承一个方法，则不能重写这个方法。</p> 
<p><strong>2、方法重载（Overload）</strong><br> 概念：<br> 重载(overloading) 是在一个类里面，<strong>方法名字相同，而参数不同。返回类型可以相同也可以不同。</strong></p> 
<p>注意<br> <strong>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</strong>（意思就是必须修改参数列表）</p> 
<p>最常用的地方就是构造器的重载。</p> 
<p><strong>重载规则：</strong><br> 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；<br> 被重载的方法可以改变返回类型；<br> 被重载的方法可以改变访问修饰符；<br> 被重载的方法可以声明新的或更广的检查异常；<br> 方法能够在同一个类中或者在一个子类中被重载。<br> 无法以返回值类型作为重载函数的区分标准。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7c3aca52470b169ddd7860f607bd07c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机多窗口显示桌面,怎么同时电脑桌面打开多个excel窗口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ef38553f56b59b045e7cba7c2b969943/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机网络上有个红叉没无线,电脑无线网络连接不上显示红叉</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>