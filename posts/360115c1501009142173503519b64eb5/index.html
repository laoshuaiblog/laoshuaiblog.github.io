<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文读懂Java垃圾回收机制及算法原理万字详解 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/360115c1501009142173503519b64eb5/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="一文读懂Java垃圾回收机制及算法原理万字详解">
  <meta property="og:description" content="Java垃圾回收机制及算法 文章目录 Java垃圾回收机制及算法垃圾回收概述垃圾回收-对象是否已死判断对象是否存活 - 引用计数算法判断对象是否存活-可达性分析算法可达性分析算法JVM之判断对象是否存活再谈引用 垃圾收集算法分代收集理论标记-清除算法什么是标记-清除算法?标记-复制算法标记-整理算法 垃圾收集器垃圾收集器概述串行垃圾回收（Serial）并行垃圾回收（Parallel）并发垃圾回收（CMS）G1垃圾回收 Serial收集器ParNew 收集器Parallel Scavenge收集器Serial Old收集器Parallel Old收集器CMS 收集器CMS垃圾回收器CMS垃圾收集过程并发可达性分析 CMS收集器三个缺点 G1收集器G1垃圾收集器简介G1收集器特点Region区域G1 GC过程G1 YoungGCG1 Mix GC G1常用参数 垃圾回收概述 什么是垃圾回收
说起垃圾收集（Garbage Collection， 下文简称GC） ， 有不少人把这项技术当作Java语言的伴生产物。 事实上，垃圾收集的历史远远比Java久远， 在1960年诞生于麻省理工学院的Lisp是第一门开始使 用内存动态分配和垃圾收集技术的语言。垃圾收集需要完成的三件事情：
哪些内存需要回收？
什么时候回收？
如何回收？
java垃圾回收的优缺点:
优点:
不需要考虑内存管理可以有效的防止内存泄漏，有效的利用可使用的内存由于有垃圾回收机制，Java中的对象不再有&#34;作用域&#34;的概念，只有对象的引用才有&#34;作用域&#34; 缺点:
java开发人员不了解自动内存管理, 内存管理就像一个黑匣子,过度依赖就会降低我们解决内存溢出/内存泄漏等问题的能力。 垃圾回收-对象是否已死 判断对象是否存活 - 引用计数算法 引用计数算法可以这样实现：给每个创建的对象添加一个引用计数器，每当此对象被某个地方引用时，计数值&#43;1，引用失效时-1，所以当计数值为0时表示对象已经不能被使用。 引用计数算法大多数情况下是个比较不错的算法，简单直接，也有一些著名的应用案例。但是对于Java虚拟机来说，并不是一个好的选择，因为它很难解决对象直接相互循环引用的问题。
优点：
实现简单，执行效率高，很好的和程序交织。 缺点：
无法检测出循环引用。 譬如有A和B两个对象，他们都互相引用，除此之外都没有任何对外的引用，那么理论上A和B都可以被作为垃圾回收掉，但实际如果采用引用计数算法，则A、B的引用计数都是1，并不满足被回收的条件，如果A和B之间的引用一直存在，那么就永远无法被回收了
public class App { public static void main(String[] args) { Test object1 = new Test(); Test object2 = new Test(); object1.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-01-08T22:45:51+08:00">
    <meta property="article:modified_time" content="2023-01-08T22:45:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文读懂Java垃圾回收机制及算法原理万字详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Java_0"></a>Java垃圾回收机制及算法</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Java_0" rel="nofollow">Java垃圾回收机制及算法</a></li><li><ul><li><a href="#_2" rel="nofollow">垃圾回收概述</a></li><li><a href="#_28" rel="nofollow">垃圾回收-对象是否已死</a></li><li><ul><li><a href="#___30" rel="nofollow">判断对象是否存活 - 引用计数算法</a></li><li><a href="#_67" rel="nofollow">判断对象是否存活-可达性分析算法</a></li><li><ul><li><a href="#_69" rel="nofollow">可达性分析算法</a></li><li><a href="#JVM_97" rel="nofollow">JVM之判断对象是否存活</a></li><li><a href="#_170" rel="nofollow">再谈引用</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_206" rel="nofollow">垃圾收集算法</a></li><li><ul><li><a href="#_208" rel="nofollow">分代收集理论</a></li><li><a href="#_230" rel="nofollow">标记-清除算法</a></li><li><ul><li><a href="#_232" rel="nofollow">什么是标记-清除算法?</a></li><li><a href="#_248" rel="nofollow">标记-复制算法</a></li><li><a href="#_281" rel="nofollow">标记-整理算法</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_300" rel="nofollow">垃圾收集器</a></li><li><ul><li><a href="#_302" rel="nofollow">垃圾收集器概述</a></li><li><ul><li><a href="#Serial_315" rel="nofollow">串行垃圾回收（Serial）</a></li><li><a href="#Parallel_322" rel="nofollow">并行垃圾回收（Parallel）</a></li><li><a href="#CMS_329" rel="nofollow">并发垃圾回收（CMS）</a></li><li><a href="#G1_336" rel="nofollow">G1垃圾回收</a></li></ul> 
    </li><li><a href="#Serial_383" rel="nofollow">Serial收集器</a></li><li><a href="#ParNew__400" rel="nofollow">ParNew 收集器</a></li><li><a href="#Parallel_Scavenge_419" rel="nofollow">Parallel Scavenge收集器</a></li><li><a href="#Serial_Old_461" rel="nofollow">Serial Old收集器</a></li><li><a href="#Parallel_Old_491" rel="nofollow">Parallel Old收集器</a></li><li><a href="#CMS__512" rel="nofollow">CMS 收集器</a></li><li><ul><li><a href="#CMS_514" rel="nofollow">CMS垃圾回收器</a></li><li><a href="#CMS_520" rel="nofollow">CMS垃圾收集过程</a></li><li><a href="#_543" rel="nofollow">并发可达性分析</a></li></ul> 
    </li><li><a href="#CMS_630" rel="nofollow">CMS收集器三个缺点</a></li></ul> 
   </li><li><a href="#G1_654" rel="nofollow">G1收集器</a></li><li><ul><li><a href="#G1_656" rel="nofollow">G1垃圾收集器简介</a></li><li><a href="#G1_660" rel="nofollow">G1收集器特点</a></li><li><a href="#Region_669" rel="nofollow">Region区域</a></li><li><a href="#G1_GC_685" rel="nofollow">G1 GC过程</a></li><li><ul><li><a href="#G1_YoungGC_704" rel="nofollow">G1 YoungGC</a></li><li><a href="#G1_Mix_GC_737" rel="nofollow">G1 Mix GC</a></li></ul> 
    </li><li><a href="#G1_791" rel="nofollow">G1常用参数</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>垃圾回收概述</h3> 
<blockquote> 
 <p>什么是垃圾回收</p> 
</blockquote> 
<p>说起垃圾收集（Garbage Collection， 下文简称GC） ， 有不少人把这项技术当作Java语言的伴生产物。 事实上，垃圾收集的历史远远比Java久远， 在1960年诞生于麻省理工学院的Lisp是第一门开始使 用内存动态分配和垃圾收集技术的语言。垃圾收集需要完成的三件事情：</p> 
<p>哪些内存需要回收？</p> 
<p>什么时候回收？</p> 
<p>如何回收？</p> 
<blockquote> 
 <p>java垃圾回收的优缺点:</p> 
</blockquote> 
<p>优点:</p> 
<ul><li>不需要考虑内存管理</li><li>可以有效的防止内存泄漏，有效的利用可使用的内存</li><li>由于有垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"</li></ul> 
<p>缺点:</p> 
<ul><li>java开发人员不了解自动内存管理, 内存管理就像一个黑匣子,过度依赖就会降低我们解决内存溢出/内存泄漏等问题的能力。</li></ul> 
<h3><a id="_28"></a>垃圾回收-对象是否已死</h3> 
<h4><a id="___30"></a>判断对象是否存活 - 引用计数算法</h4> 
<p>引用计数算法可以这样实现：<strong>给每个创建的对象添加一个引用计数器，每当此对象被某个地方引用时，计数值+1，引用失效时-1，所以当计数值为0时表示对象已经不能被使用。</strong> 引用计数算法大多数情况下是个比较不错的算法，简单直接，也有一些著名的应用案例。但是对于Java虚拟机来说，并不是一个好的选择，<strong>因为它很难解决对象直接相互循环引用的问题。</strong></p> 
<p>优点：</p> 
<ul><li>实现简单，执行效率高，很好的和程序交织。</li></ul> 
<p>缺点：</p> 
<ul><li>无法检测出循环引用。</li></ul> 
<p>譬如有A和B两个对象，他们都互相引用，除此之外都没有任何对外的引用，那么理论上A和B都可以被作为垃圾回收掉，但实际如果采用引用计数算法，则A、B的引用计数都是1，并不满足被回收的条件，如果A和B之间的引用一直存在，那么就永远无法被回收了</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Test</span> object1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Test</span> object2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		object1<span class="token punctuation">.</span>object <span class="token operator">=</span> object2<span class="token punctuation">;</span>
		object2<span class="token punctuation">.</span>object <span class="token operator">=</span> object1<span class="token punctuation">;</span>
		object1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		object2 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token class-name">Test</span> object <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这两个对象再无任何引用， 实际上这两个对象已 经不可能再被访问， 但是它们因为互相引用着对方， 导致它们的引用计数都不为零， 引用计数算法也就无法回收它们 。</p> 
<p><strong>但是在java程序中这两个对象仍然会被回收，因为java中并没有使用引用计数算法。</strong></p> 
<h4><a id="_67"></a>判断对象是否存活-可达性分析算法</h4> 
<h5><a id="_69"></a>可达性分析算法</h5> 
<p>在主流的商用程序语言如Java、C#等的主流实现中，都是通过<strong>可达性分析</strong>(Reachability Analysis)来判断对象是否存活的。<strong>此算法的基本思路就是通过一系列的“GC Roots”的对象作为起始点，从起始点开始向下搜索到对象的路径</strong>。搜索所经过的路径称为<strong>引用链</strong>(Reference Chain)，当一个对象到任何GC Roots都没有引用链时，则表明对象“<strong>不可达</strong>”，即该对象是不可用的。</p> 
<p><img src="https://images2.imgbox.com/2f/13/omyBlXGH_o.png" alt="在这里插入图片描述"></p> 
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p> 
<ul><li>栈帧中的局部变量表中的reference引用所引用的对象</li><li>方法区中static静态引用的对象</li><li>方法区中final常量引用的对象</li><li>本地方法栈中JNI(Native方法)引用的对象</li><li>Java虚拟机内部的引用， 如基本数据类型对应的Class对象， 一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError） 等， 还有系统类加载器。</li><li>所有被同步锁（synchronized关键字） 持有的对象。</li><li>反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、 本地代码缓存等。</li></ul> 
<p><img src="https://images2.imgbox.com/ef/fd/iiQBILDJ_o.png" alt="在这里插入图片描述"></p> 
<p>从上图中，reference1、reference2、reference3都是GC root，可以看出：</p> 
<ul><li>reference1 -&gt; 对象实例1</li><li>reference2 -&gt; 对象实例2</li><li>reference3 -&gt; 对象实例4</li><li>reference3 -&gt; 对象实例4 -&gt; 对象实例6</li><li></ul> 
<h5><a id="JVM_97"></a>JVM之判断对象是否存活</h5> 
<p><strong>finalize()方法最终判定对象是否存活:</strong></p> 
<p>即使在可达性分析算法中判定为不可达的对象， 也不是“非死不可”的， 这时候它们暂时还处于“缓 刑”阶段， 要真正宣告一个对象死亡， 至少要经历两次标记过程：</p> 
<p><strong>第一次标记:</strong></p> 
<p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记， 随后进行一次筛选， <strong>筛选的条件是此对象是否有必要执行finalize()方法。</strong></p> 
<p><strong>没有必要:</strong></p> 
<p>假如对象没有覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用过， 那么虚拟机将这两种情况都视为“没有必要执行”。</p> 
<p><strong>有必要:</strong></p> 
<p>如果这个对象被判定为确有必要执行finalize()方法， 那么该对象将会被放置在一个名为F-Queue的队列之中， 并在稍后由一条由虚拟机自动建立的、 低调度优先级的Finalizer线程去执行它们的finalize() 方法。 <strong>finalize()方法是对象逃脱死亡命运的最后一次机会</strong>， 稍后收集器将对F-Queue中的对象进行<strong>第二次小规模的标记</strong>， <strong>如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可</strong>， 譬如把自己 （this关键字） 赋值给某个类变量或者对象的成员变量， 那在第二次标记时它将被移出“即将回收”的集合。 如果对象这时候还没有逃脱， 那基本上它就真的要被回收了。</p> 
<p><img src="https://images2.imgbox.com/54/56/DWtaVysl_o.png" alt="在这里插入图片描述"></p> 
<p>一次对象自我拯救的演示</p> 
<pre><code class="prism language-java"><span class="token comment">/**
* 此代码演示了两点：
* 1.对象可以在被GC时自我拯救。
* 2.这种自救的机会只有一次， 因为一个对象的finalize()方法最多只会被系统自动调用一次
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalizeEscapeGC</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">FinalizeEscapeGC</span> <span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"yes, i am still alive :)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 
    
    <span class="token annotation punctuation">@Override</span>
	<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finalize method executed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">FinalizeEscapeGC</span><span class="token punctuation">.</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
		<span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalizeEscapeGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//对象第一次成功拯救自己</span>
		<span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 因为Finalizer方法优先级很低， 暂停0.5秒， 以等待它</span>
		<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token constant">SAVE_HOOK</span><span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"no, i am dead :("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        
        <span class="token comment">//下面这段代码与上面的完全相同，但是这次自救却失败了</span>
		<span class="token constant">SAVE_HOOK</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 因为Finalizer方法优先级很低， 暂停0.5秒， 以等待它</span>
		<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SAVE_HOOK</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token constant">SAVE_HOOK</span><span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"no, i am dead :("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意:</p> 
<p>Finalizer线程去执行它们的finalize() 方法, 这里所说的“执行”是指虚拟机会触发这个方法开始运行， 但并不承诺一定会等待它运行结束。 这样做的原因是， 如果某个对象的finalize()方法执行缓慢， 或者更极端地发生了死循环， 将很可能导 致F-Queue队列中的其他对象永久处于等待， 甚至导致整个内存回收子系统的崩溃。</p> 
<h5><a id="_170"></a>再谈引用</h5> 
<p>在JDK1.2以前，<strong>Java中引用的定义很传统: 如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用</strong>。这种定义有些狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态。 我们希望能描述这一类对象: 当内存空间还足够时，则能保存在内存中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。很多系统中的缓存对象都符合这样的场景。 <strong>在JDK1.2之后，Java对引用的概念做了扩充，将引用分为强引用(Strong Reference) 、 软引用(Soft Reference) 、 弱引用(Weak Reference) 和 虚引用(Phantom Reference) 四种</strong>，这四种引用的强度依次递减。</p> 
<blockquote> 
 <p>强引用（StrongReference）</p> 
</blockquote> 
<p>强引用是使用最普遍的引用。<strong>如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题</strong>。</p> 
<p><strong>ps：强引用其实也就是我们平时A a = new A()这个意思。</strong></p> 
<blockquote> 
 <p>软引用（SoxReference）</p> 
</blockquote> 
<p><strong>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p> 
<blockquote> 
 <p>弱引用（WeakReference）</p> 
</blockquote> 
<p>用来描述那些非必须对象， 但是它的强度比软引用更弱一些， <strong>被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。 <strong>当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象</strong>。 在JDK 1.2版之后提供了WeakReference类来实现弱引用。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p> 
<p><strong>弱引用与软引用的区别在于：</strong></p> 
<ol><li>更短暂的生命周期</li><li>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ol> 
<blockquote> 
 <p>虚引用（PhantomReference）</p> 
</blockquote> 
<p>“虚引用”顾名思义，它是最弱的一种引用关系。如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p> 
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong></p> 
<ol><li>虚引用必须和引用队列 （ReferenceQueue）联合使用。</li><li>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</li></ol> 
<h3><a id="_206"></a>垃圾收集算法</h3> 
<h4><a id="_208"></a>分代收集理论</h4> 
<p>思想也很简单，<strong>就是根据对象的生命周期将内存划分，然后进行分区管理</strong>。 当前商业虚拟机的垃圾收集器， 大多数都遵循了“分代收集”（Generational Collection）的理论进 行设计， 分代收集名为理论， 实质是一套符合大多数程序运行实际情况的经验法则， 它建立在两个分代假说之上：</p> 
<ul><li>弱分代假说（Weak Generational Hypothesis） ： 绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis） ： 熬过越多次垃圾收集过程的对象就越难以消亡。</li></ul> 
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的<strong>设计原则</strong>： <strong>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数） 分配到不同的区域之中存储。</strong> 显而易见， 如果一个区域中大多数对象都是朝生夕灭， 难以熬过垃圾收集过程的话， 那 么把它们集中放在一起， <strong>每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象</strong>， 就能以较低代价回收到大量的空间； 如果剩下的都是难以消亡的对象， 那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域， 这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p> 
<p>在Java堆划分出不同的区域之后， 垃圾收集器才可以每次只回收其中某一个或者某些部分的区域 ——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分； <strong>也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。</strong></p> 
<p>针对不同分代的类似名词， 为避免产生混淆， 在这里统一定义 :</p> 
<ul><li> <p>部分收集（Partial GC） ： 指目标不是完整收集整个Java堆的垃圾收集， 其中又分为 ：</p> 
  <ul><li>新生代收集（Minor GC/Young GC）： 指目标只是新生代的垃圾收集。</li><li>老年代收集（Major GC/Old GC）： 指目标只是老年代的垃圾收集，目前只有CMS收集器会有单 独收集老年代的行为。</li><li>混合收集（Mixed GC）： 指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。</li></ul> </li><li> <p>整堆收集（Full GC） ： 收集整个Java堆和方法区的垃圾收集</p> </li></ul> 
<h4><a id="_230"></a>标记-清除算法</h4> 
<h5><a id="_232"></a>什么是标记-清除算法?</h5> 
<p>最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep） 算法， 在1960年由Lisp之父 John McCarthy所提出。 <strong>如它的名字一样， 算法分为“标记”和“清除”两个阶段： 首先标记出所有需要回收的对象， 在标记完成后，统一回收掉所有被标记的对象， 也可以反过来， 标记存活的对象， 统一回收所有未被标记的对象。</strong></p> 
<p>标记过程就是对象是否属于垃圾的判定过程， 这在前一节讲述垃圾对象标记判定算法时其实已经介绍过了。 之所以说它是最基础的收集算法， 是因为后续的收集算法大多都是以标记-清除算法为基础， 对其缺点进行改进而得到的。</p> 
<p><img src="https://images2.imgbox.com/fe/68/Nhc4Dkid_o.png" alt="在这里插入图片描述"></p> 
<p>标记-清除算法有两个不足之处：</p> 
<ul><li>第一个是执行效率不稳定， 如果Java堆中包含大量对 象， 而且其中大部分是需要被回收的， 这时必须进行大量标记和清除的动作， 导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li>第二个是内存空间的碎片化问题， 标记、 清除之后会产生大量不连续的内存碎片， 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找 到足够的连续内存而不得不提前触发另一次垃圾收。</li></ul> 
<h5><a id="_248"></a>标记-复制算法</h5> 
<blockquote> 
 <p>什么是标记-复制算法</p> 
</blockquote> 
<p>标记-复制算法常被简称为复制算法。</p> 
<p><strong>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题</strong>， 1969年Fenichel提出了一种称为“半区复制”（Semispace Copying） 的垃圾收集算法， <strong>它将可用内存按容量划分为大小相等的两块， 每次只使用其中的一块。 当这一块的内存用完了， 就将还存活着的对象复制到另外一块上面， 然后再把已使用过的内存空间一次清理掉</strong>。 如果内存中多数对象都是存活的， 这种算法将会产生大量的内存间复制的开销， 但对于多数对象都是可回收的情况， 算法需要复制的就是占少数的存活对象， 而且每次都是针对整个半区进行内存回收， 分配内存时也就不用考虑有空间碎片的复杂情况， 只要移动堆顶指针， 按顺序分配即可.</p> 
<p><img src="https://images2.imgbox.com/53/67/L2Qz6ZEW_o.png" alt="在这里插入图片描述"></p> 
<p>但是这种算法也有缺点：</p> 
<ul><li>需要提前预留一半的内存区域用来存放存活的对象（经过垃圾收集后还存活的对象），<strong>这样导致可用的对象区域减小一半，总体的GC更加频繁了</strong></li><li><strong>如果出现存活对象数量比较多的时候，需要复制较多的对象，成本上升，效率降低</strong></li><li>如果99%的对象都是存活的（老年代），那么老年代是无法使用这种算法的。</li></ul> 
<p><strong>注意事项：</strong></p> 
<p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代， IBM公司曾有一项专门研 究对新生代“朝生夕灭”的特点做了更量化的诠释——<strong>新生代中的对象有98%熬不过第一轮收集。</strong> 因此 并不需要按照1∶1的比例来划分新生代的内存空间。<strong>Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的 Survivor空间， 每次分配内存只使用Eden和其中一块Survivor。 发生垃圾搜集时， 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上， 然后直接清理掉Eden和已用过的那块Survivor空 间。</strong> <strong>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1， 也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%） ， 只有一个Survivor空间， 即10%的新生代是会 被“浪费”的。</strong></p> 
<blockquote> 
 <p>为什么需要两个Survivor空间</p> 
</blockquote> 
<p>当只有一个Survivor空间时，当Eden区满的时候，发生一个minor gc，如果有存活对象，将存活对象转移到survivor中，那么下次Eden区再满的时候，再次minor gc，这时Eden区和Survivor都有存活的对象（都部分被清空）此时空间是不连续的。</p> 
<p>如果存在两个survivor区，当Eden区满的时候，发生minor gc，有存活对象，将对象转移到Survivor0中，当下次再发生minor gc的时候，将Eden区和S0区的存活对象复制到S1中（这种复制算法可以保证S1中来自Eden和S0中对象的地址是连续的），清空Eden区和S0的空间，然后交换S0和S1的角色，之后发生minor gc时，循环往复。直到存活对象old enough，升入老年代。<br> 这种情况下我们可以保证始终有一个Survivor的空间是没有碎片的,而另外一个Survivor是空着的。</p> 
<h5><a id="_281"></a>标记-整理算法</h5> 
<p>标记-复制算法在对象存活率较高时就要进行较多的复制操作， 效率将会降低。 更关键的是， 如果不想浪费50%的空间， 就需要有额外的空间进行分配担保， 以应对被使用的内存中所有对象都100%存活的极端情况， <strong>所以在老年代一般不能直接选用这种算法。</strong></p> 
<p>针对老年代对象的存亡特征， 1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact） 算法， 其中的标记过程仍然与“标记-清除”算法一样， <strong>但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内存 。</strong></p> 
<p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法， 而后者是移动式的。 是否移动回收后的存活对象是一项优缺点并存的风险决策：</p> 
<p><img src="https://images2.imgbox.com/e6/8c/5icmtsfP_o.png" alt="在这里插入图片描述"></p> 
<p>从图中可以看出，这种算法的优势之一是避免了标记-清除算法中在清除可回收对象后导致的内存碎片化问题，通过将存活对象进行移动，保证了未使用内存区域的连续。</p> 
<p>但是，这两种算法对比来看，是否移动对象都存在弊端： <strong>移动则内存回收时会更复杂， 不移动则内存分配时会更复杂</strong>。 从垃圾收集的停顿时间来看， 不移动对象停顿时间会更短， 甚至可以不需要停顿， <strong>但是从整个程序的吞吐量来看， 移动对象会更划算</strong>。</p> 
<h3><a id="_300"></a>垃圾收集器</h3> 
<h4><a id="_302"></a>垃圾收集器概述</h4> 
<blockquote> 
 <p>垃圾回收器与垃圾回收算法</p> 
</blockquote> 
<p>垃圾回收算法分为两类，<strong>第一类算法判断对象生死算法</strong>，如引用计数法、可达性分析算法；<strong>第二类收集死亡对象</strong>方法有四种,如标记-清除算法、标记-复制算法、标记-整理算法。<strong>一般的实现采用分代回收算法，根据不同代的特点应用不同的算法</strong>。垃圾回收算法是内存回收的方法论。<strong>垃圾收集器是算法的落地实现</strong>。和回收算法一样，目前还没有出现完美的收集器，而是要根据具体的应用场景选择最合适的收集器，进行分代收集。</p> 
<p><strong>垃圾收集器是实现了上述垃圾回收算法的具体应用</strong></p> 
<blockquote> 
 <p>垃圾收集器分类</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/20/89/tss8v5Pg_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Serial_315"></a>串行垃圾回收（Serial）</h5> 
<p>串行垃圾回收是为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，不适合交互性强的服务器环境</p> 
<p><img src="https://images2.imgbox.com/eb/84/fM58QEZg_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Parallel_322"></a>并行垃圾回收（Parallel）</h5> 
<p>多个垃圾收集器线程并行工作，<strong>同样会暂停用户线程</strong>，<strong>适用于科学计算、大数据后台处理等多交互场景。</strong></p> 
<p><img src="https://images2.imgbox.com/73/81/oCr0jcGb_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="CMS_329"></a>并发垃圾回收（CMS）</h5> 
<p><strong>用户线程和垃圾回收线程同时执行</strong>，不一定是并行的，可能是交替执行，可能一边垃圾回收，一边运行应用线程，<strong>不需要停顿用户线程</strong>，互联网应用程序中经常使用，适用对响应时间有要求的场景。</p> 
<p><img src="https://images2.imgbox.com/3c/cf/S6ewLME2_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="G1_336"></a>G1垃圾回收</h5> 
<p>G1垃圾回收器<strong>将堆内存分割成不同的区域然后并发地对其进行垃圾回收。</strong></p> 
<p>后面会更详细的对几种垃圾分类器的原理进行分析介绍。</p> 
<blockquote> 
 <p>七种垃圾收集器及其组合关系</p> 
</blockquote> 
<p>根据分代思想，我们有7种主流的垃圾回收器</p> 
<p><img src="https://images2.imgbox.com/44/b2/f8YOCnvI_o.png" alt="在这里插入图片描述"></p> 
<ul><li>新生代垃圾收集器：Serial 、 ParNew 、Parallel Scavenge</li><li>老年代垃圾收集器：Serial Old 、 Parallel Old 、CMS</li><li>整理收集器：G1</li></ul> 
<p><strong>垃圾收集器的组合关系</strong></p> 
<p><img src="https://images2.imgbox.com/3b/a3/bjovw6Q8_o.png" alt="在这里插入图片描述"></p> 
<p><strong>JDK8中默认使用组合是: Parallel Scavenge GC 、ParallelOld GC</strong></p> 
<p>DK9默认是用G1为垃圾收集器</p> 
<p>JDK14 弃用了: Parallel Scavenge GC 、Parallel OldGC</p> 
<p>JDK14 移除了 CMS GC</p> 
<blockquote> 
 <p>GC性能指标</p> 
</blockquote> 
<ul><li><strong>吞吐量</strong>：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )）。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</li><li><strong>暂停时间</strong>：执行垃圾回收时，程序的工作线程被暂停的时间</li><li><strong>内存占用</strong>：java堆所占内存的大小</li><li><strong>收集频率</strong>：垃圾收集的频次</li></ul> 
<h4><a id="Serial_383"></a>Serial收集器</h4> 
<p><strong>单线程收集器，“单线程”的意义不仅仅说明它只会使用一个CPU或一个收集线程去完成垃圾收集工作；更重要的是它在垃圾收集的时候，必须暂停其他工作线程，直到垃圾收集完毕</strong>。 “Stop The World”这个词语也许听起来很酷， 但这项工作是由虚拟机在后台自动发起和自动完成的， 在用户不可知、 不可控的情况下把用户的正常工作的线程全部停掉， 这对很多应用来说都是不能接受的。</p> 
<p>下图示意了Serial/Serial Old收 集器的运行过程</p> 
<p><img src="https://images2.imgbox.com/db/e5/pJ5Ahyye_o.png" alt="在这里插入图片描述"></p> 
<p>Serial收集器也并不是只有缺点。Serial收集器由于简单并且高效。</p> 
<p>对于单CPU环境来说，由于Serial收集器没有线程间的交互，专心做垃圾收集自然可以做获得最高的垃圾收集效率</p> 
<p><strong>使用方式：-XX:+UseSerialGC</strong></p> 
<h4><a id="ParNew__400"></a>ParNew 收集器</h4> 
<p><strong>ParNew收集器实质上是Serial收集器的多线程并行版本</strong>， 除了同时使用多条线程进行垃圾收集之 外， 其余的行为包括Serial收集器可用的所有控制参数 、 收集算法、 Stop The World、 对象分配规则、 回收策略等都与Serial收集器完全一致， 在实现上这两种收集器也共用了相当多的代码.</p> 
<p>ParNew收集器的工作过程</p> 
<p><img src="https://images2.imgbox.com/fe/98/0A8a0k5e_o.png" alt="在这里插入图片描述"></p> 
<p>ParNew收集器在单CPU服务器上的垃圾收集效率绝对不会比Serial收集器高。</p> 
<p>但是在多CPU服务器上，效果会明显比Serial好</p> 
<p>使用方式：-XX:+UseParNewGC</p> 
<p>设置线程数: XX:ParllGCThreads</p> 
<h4><a id="Parallel_Scavenge_419"></a>Parallel Scavenge收集器</h4> 
<p><strong>什么是Parallel Scanvenge</strong></p> 
<p>又称为吞吐量优先收集器，和ParNew收集器类似，是一个<strong>新生代收集器</strong>。<strong>使用复制算法的并行多线程收集器</strong>。<strong>Parallel Scavenge是Java1.8默认的收集器，特点是并行的多线程回收，以吞吐量优先。</strong></p> 
<p><strong>特点</strong></p> 
<ul><li> <p>Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）；</p> <p>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p> <p>(虚拟机总共运行100分钟，垃圾收集时间为1分钟，那么吞吐量就是99%)</p> </li><li> <p>自适应调节策略, 自动指定年轻代、Eden、Suvisor区的比例。</p> </li></ul> 
<p><strong>适用场景</strong></p> 
<p>适合后台运算，交互不多的任务，如批量处理，订单处理，科学计算等。</p> 
<p><strong>参数</strong></p> 
<ul><li> <p>使用方式：-XX:+UseParallelGC</p> </li><li> <p>分别是控制:最大垃圾收集停顿时间-XX:MaxGCPauseMillis</p> </li><li> <p>-XX： MaxGCPauseMillis参数允许的值是一个大于0的毫秒数， 收集器将尽力保证内存回收花费的时间不超过用户设定值。 不过大家不要异想天开地认为如果把这个参数的值设置得更小一点就能使得系统的垃圾收集速度变得更快， <strong>垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的：系统把新生代调得小一些， 收集300MB新生代肯定比收集500MB快， 但这也直接导致垃圾收集发生得更频繁， 原来10秒收集一次、 每次停顿100毫秒， 现在变成5秒收集一次、 每次停顿70毫秒。 停顿时间的确在下降， 但吞吐量也降下来了。</strong></p> </li><li> <p>吞吐量大小-XX:GCTimeRatio</p> <p>-XX： GCTimeRatio参数的值则应当是一个大于0小于100的整数， <strong>也就是垃圾收集时间占总时间的比率</strong>， 相当于吞吐量的倒数。 假设GCTimeRatio的值为n，那么系统将花费不超过1/(1+n)的时间用于垃圾收集。譬如把此参数设置为19， 那允许的最大垃圾收集时间就占总时间的5%（即1/(1+19)） ， 默认值为99， 即允许最大1%（即1/(1+99)） 的垃圾收集时间</p> </li><li> <p>设置年轻代线程数 XX:ParllGCThreads</p> <p>当cpu核数小于等于8,默认cpu核数相同。当cpu核数超过8, ParllGCThreads设置为 3+(5*CPU_COUNT)/8</p> </li><li> <p>与Parallel Scavenge收集器有关的还有一个参数：-XX:+UseAdaptiveSizePolicy(有了这个参数之后，就不要手工指定年轻代、Eden、Suvisor区的比例，晋升老年代的对象年龄等，因为<strong>虚拟机会根据系统运行情况进行自适应调节</strong>)</p> </li></ul> 
<h4><a id="Serial_Old_461"></a>Serial Old收集器</h4> 
<p>Serial Old是Serial收集器的老年代版本， <strong>它同样是一个单线程收集器， 使用标记-整理算法。</strong> 这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。</p> 
<p><strong>特点</strong></p> 
<ul><li>针对老年代</li><li>采用"标记-整理"算法</li><li>单线程收集；</li></ul> 
<p><strong>执行流程</strong></p> 
<p><img src="https://images2.imgbox.com/26/f1/nWqx8iHT_o.png" alt="在这里插入图片描述"></p> 
<p><strong>应用场景</strong></p> 
<p>主要用于Client模式</p> 
<ol><li>在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配）</li><li>作为 CMS收集器的后备预案 ，在并发收集发生Concurrent Mode Failure时使用</li></ol> 
<p><strong>参数设置</strong></p> 
<p>使用方式：-XX:+UseSerialGC</p> 
<p><strong>注意事项</strong></p> 
<p>需要说明一下， Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集， 并非直接调用Serial Old收集器， 但是这个PS MarkSweep收集器与Serial Old的实现几乎是一样的， 所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解.</p> 
<h4><a id="Parallel_Old_491"></a>Parallel Old收集器</h4> 
<p><strong>Parallel Old是Parallel Scavenge收集器的老年代版本， 支持多线程并发收集， 基于标记-整理算法实现</strong>。 这个收集器是直到JDK 6时才开始提供的， 在此之前， 新生代的Parallel Scavenge收集器一直处于相 当尴尬的状态， 原因是如果新生代选择了Parallel Scavenge收集器， 老年代除了Serial Old（PS MarkSweep） 收集器以外别无选择， 其他表现良好的老年代收集器， 如CMS无法与它配合工作。</p> 
<p><strong>Parallel Old收集器的工作过程</strong></p> 
<p><img src="https://images2.imgbox.com/71/66/yxo4OiCd_o.png" alt="在这里插入图片描述"></p> 
<p><strong>应用场景</strong></p> 
<p>JDK1.6及之后用来代替老年代的Serial Old收集器</p> 
<p>特别是在Server模式，多CPU的情况下</p> 
<p>这样在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge加Parallel Old收集器的"给力"应用组合</p> 
<p><strong>设置参数</strong></p> 
<p>“-XX:+UseParallelOldGC”：指定使用Parallel Old收集器</p> 
<h4><a id="CMS__512"></a>CMS 收集器</h4> 
<h5><a id="CMS_514"></a>CMS垃圾回收器</h5> 
<p><strong>CMS（concurrent mark sweep）是以获取最短垃圾收集停顿时间为目标的收集器</strong>，<strong>CMS收集器的关注点尽可能缩短垃圾收集时用户线程的停顿时间</strong>,停顿时间越短就越适合与用户交互的程序,目前很大一部分的java应用部署在互联网的B/S系统服务器上，这类应用尤其注重服务器的响应速度，系统停顿时间最短，给用户带来良好的体验，<strong>CMS收集器使用的算法是标记-清除算法实现的</strong>；</p> 
<h5><a id="CMS_520"></a>CMS垃圾收集过程</h5> 
<ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul> 
<p>其中 <strong>初始标记</strong> 和 <strong>重新标记</strong> 都需要stopTheWorld</p> 
<p><img src="https://images2.imgbox.com/ca/64/Ssqrs60E_o.png" alt="在这里插入图片描述"></p> 
<p>CMS整个过程比之前的收集器要复杂,<strong>整个过程分为4个阶段即、初始标记 并发标记 、重新标记、并发清除</strong></p> 
<ul><li><strong>初始标记（Initial-Mark）阶段</strong>：这个阶段程序所有的工作线程都将会因为"Stop-the-Wold"机制而出现短暂的的暂停,这个阶段的主要任务标记处GC Roots 能够关联到的对象.一旦标记完成后就恢复之前被暂停的的所有应用。 由于直接关联对象比较小，所以这里的操作速度非常快。</li><li><strong>并发标记（Concurrent-Mark）阶段</strong>：从GC Roots的直接关联对象开始遍历整个对象图的过程,这个过程耗时较长,但是不需要暂停用户线程, 用户线程可以与垃圾回收器一起运行。</li><li><strong>重新标记（Remark）阶段</strong>：由于并发标记阶段，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此，<strong>为了修正并发标记期间因为用户继续运行而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常比初始标记阶段长一些，但也远比并发标记阶段时间短。</li><li><strong>清除并发（Concurrent-Sweep）阶段</strong>: 此阶段清理删除掉标记判断已经死亡的对象,并释放内存空间。由于不需要移动存活对象，所以这个阶段可以与用户线程同时并发运行。</li></ul> 
<p><strong>由于最消耗事件的并发标记与并发清除阶段都不需要暂停工作，因为整个回收阶段是低停顿（低延迟）的。</strong></p> 
<h5><a id="_543"></a>并发可达性分析</h5> 
<p><strong>当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的</strong>， <strong>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析</strong></p> 
<p>垃圾回收器的工作流程大体如下：</p> 
<ol><li><strong>标记</strong>出哪些对象是存活的，哪些是垃圾（可回收）；</li><li>进行<strong>回收</strong>（清除/复制/整理），<strong>如果有移动过对象（复制/整理），还需要更新引用。</strong></li></ol> 
<blockquote> 
 <p>三色标记</p> 
</blockquote> 
<p>三色标记（Tri-color Marking）作为工具来辅助推导， <strong>把遍历对象图过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</strong></p> 
<p>要找出存活对象，根据可达性分析，从GC Roots开始进行遍历访问，可达的则为存活对象：</p> 
<p><img src="https://images2.imgbox.com/b2/78/cCVeoZfs_o.png" alt="在这里插入图片描述"></p> 
<p>我们把遍历对象图<strong>过程</strong>中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：</p> 
<ul><li><strong>白色：</strong> 尚未访问过。</li><li><strong>黑色：</strong> 本对象已访问过，而且本对象引用到的其他对象 也全部访问过了。</li><li><strong>灰色：</strong> 本对象已访问过，但是本对象引用到的其他对象尚未全部访问完。全部访问后，会转换为黑色。</li></ul> 
<p><img src="https://images2.imgbox.com/ff/69/faKzkUff_o.png" alt="在这里插入图片描述"></p> 
<p>假设现在有白、灰、黑三个集合（表示当前对象的颜色），其遍历访问过程为：</p> 
<ol><li>初始时，所有对象都在 【白色集合】中；</li><li>将GC Roots 直接引用到的对象 挪到 【灰色集合】中；</li><li>从灰色集合中获取对象： 
  <ol><li>将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；</li><li>将本对象 挪到 【黑色集合】里面。</li></ol> </li><li>重复步骤3，直至【灰色集合】为空时结束。</li><li>结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。</li></ol> 
<p><strong>注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。</strong></p> 
<p>当Stop The World （以下简称 STW）时，对象间的引用是不会发生变化的，可以轻松完成标记。 而当需要支持并发标记时，即标记期间应用线程还在继续跑，<strong>对象间的引用可能发生变化</strong>，<strong>多标</strong>和<strong>漏标</strong>的情况就有可能发发生。</p> 
<blockquote> 
 <p>多标-浮动垃圾</p> 
</blockquote> 
<p>假设已经遍历到E（变为灰色了），此时应用执行了 objD.fieldE = null（对象E的引用置为空，此时对象E应该被回收）：</p> 
<p><img src="https://images2.imgbox.com/67/bb/I4IT7doZ_o.png" alt="在这里插入图片描述"></p> 
<p>此刻之后，对象E/F/G是“应该”被回收的。然而因为E<strong>已经变为灰色</strong>了，其仍会被<strong>当作存活对象</strong>继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即<strong>本轮</strong>GC<strong>不会回收这部分内存</strong>。</p> 
<p>这部分本应该回收 但是 没有回收到的内存，被称之为“<strong>浮动垃圾</strong>”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。</p> 
<blockquote> 
 <p>漏标</p> 
</blockquote> 
<p>假设GC线程已经遍历到E（变为灰色了），此时应用线程先执行了：</p> 
<pre><code class="prism language-java"><span class="token keyword">var</span> <span class="token class-name">G</span> <span class="token operator">=</span> objE<span class="token punctuation">.</span>fieldG<span class="token punctuation">;</span>
objE<span class="token punctuation">.</span>fieldG <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 灰色E 断开引用 白色G</span>
objD<span class="token punctuation">.</span>fieldG <span class="token operator">=</span> <span class="token class-name">G</span><span class="token punctuation">;</span> <span class="token comment">// 黑色D 引用 白色G</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/95/3d/LciM9z78_o.png" alt="在这里插入图片描述"></p> 
<p>此时切回GC线程继续跑，因为E<strong>已经没有对</strong>G<strong>的引用了，所以不会将</strong>G<strong>放到灰色集合</strong>；尽管因为D重新引用了G，但因为D<strong>已经是黑色</strong>了，不会再重新做遍历处理。 最终导致的结果是：G会一直停留在白色集合中，<strong>最后被当作垃圾进行清除</strong>。这直接<strong>影响到了应用程序的正确性</strong>，是不可接受的</p> 
<p>从<strong>代码的角度</strong>看</p> 
<pre><code class="prism language-java"><span class="token keyword">var</span> <span class="token class-name">G</span> <span class="token operator">=</span> objE<span class="token punctuation">.</span>fieldG<span class="token punctuation">;</span> <span class="token comment">// 1.读</span>
objE<span class="token punctuation">.</span>fieldG <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 2.写</span>
objD<span class="token punctuation">.</span>fieldG <span class="token operator">=</span> <span class="token class-name">G</span><span class="token punctuation">;</span> <span class="token comment">// 3.写</span>
</code></pre> 
<ol><li>读取 对象E的成员变量fieldG的引用值，即对象G；</li><li>对象E 往其成员变量fieldG，写入 null值。</li><li>对象D 往其成员变量fieldG，写入 对象G ；</li></ol> 
<p>我们只要在上面这三步中的任意一步中做一些“手脚”，<strong>将对象</strong>G<strong>记录起来，然后作为灰色对象再进行遍历</strong>即可。比如放到一个特定的集合，等初始的GC Roots遍历完（并发标记），该集合的对象 遍历即可（重新标记）。</p> 
<blockquote> 
 <p>重新标记是需要STW的，因为应用程序一直在跑的话，该集合可能会一直增加新的对象，导致永远都跑不完。当然，并发标记期间也可以将该集合中的大部分先跑了，从而缩短重新标记STW的时间，这个是优化问题了</p> 
</blockquote> 
<h4><a id="CMS_630"></a>CMS收集器三个缺点</h4> 
<blockquote> 
 <p>CMS收集器对CPU资源非常敏感。</p> 
</blockquote> 
<p>其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（处理器核心数量 +3） /4，也就是说， 如果处理器核心数在四个或以上， 并发回收时垃圾收集线程只占用不超过25%的 处理器运算资源， 并且会随着处理器核心数量的增加而下降。 但是当处理器核心数量不足四个时， CMS对用户程序的影响就可能变得很大。 如果应用本来的处理器负载就很高， 还要分出一半的运算能 力去执行收集器线程， 就可能导致用户程序的执行速度忽然大幅降低</p> 
<blockquote> 
 <p>CMS收集器无法处理浮动垃圾，可能出现"Concurrent Mode Failure"失败而导致另一次Full GC的产生。</p> 
</blockquote> 
<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为"浮动垃圾"。同样也是由于在垃圾收集阶段用户线程还需要持续运 行， 那就还需要预留足够内存空间提供给用户线程使用， 因此CMS收集器不能像其他收集器那样等待 到老年代几乎完全被填满了再进行收集， 必须预留一部分空间供并发收集时的程序运作使用。</p> 
<p>在JDK 5的默认设置下， CMS收集器当老年代使用了68%的空间后就会被激活， 这是一个偏保守的设置， 如果 在实际应用中老年代增长并不是太快， 可以适当调高参数-XX： CMSInitiatingOccu-pancyFraction的值 来提高CMS的触发百分比， 降低内存回收频率， 获取更好的性能。 到了JDK 6时， CMS收集器的启动 阈值就已经默认提升至92%。但这又会更容易面临另一种风险： 要是CMS运行期间预留的内存无法满 足程序分配新对象的需要， 就会出现一 次“并发失败”（Concurrent Mode Failure） ， 这时候虚拟机将不 得不启动后备预案： 冻结用户线程的执行， 临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。</p> 
<blockquote> 
 <p>空间碎片:CMS是一款基于标记-清除算法实现的收集器，所有会有空间碎片的现象</p> 
</blockquote> 
<p>当空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p> 
<p>为了解决这个问题， CMS收集器提供了一个-XX： +UseCMS-CompactAtFullCollection开关参数（默认是开启的， 此参数从 JDK 9开始废弃） ， 用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程， 由于这个 内存整理必须移动存活对象， 是无法并发的。 这样空间碎片问题是解 决了， 但停顿时间又会变长， 因此虚拟机设计者们还提供了另外一个参数-XX： CMSFullGCsBeforeCompaction（此参数从JDK 9开始废弃） ， 这个参数的作用是要求CMS收集器在执行过若干次（数量 由参数值决定） 不整理空间的Full GC之后， 下一次进入Full GC前会先进行碎片整理（默认值为0， 表 示每次进入Full GC时都进行碎片整理）。</p> 
<h3><a id="G1_654"></a>G1收集器</h3> 
<h4><a id="G1_656"></a>G1垃圾收集器简介</h4> 
<p>Garbage First是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p> 
<h4><a id="G1_660"></a>G1收集器特点</h4> 
<ol><li>G1把内存划分为多个独立的区域Region</li><li>G1仍然保留分代思想,<strong>保留了新生代和老年代,但他们不再是物理隔离,而是一部分Region的集合</strong></li><li>G1能够充分利用多CPU、多核环境硬件优势，尽量缩短STW</li><li><strong>G1整体采用标记整理算法,局部是采用复制算法,不会产生内存碎片</strong></li><li>G1的停顿可预测,<strong>能够明确指定在一个时间段内,消耗在垃圾收集上的时间不超过设置时间</strong></li><li>G1跟踪各个Region里面垃圾的价值大小,会维护一个优先列表,每次根据允许的时间来回收价值最大的区域,从而保证在有限事件内高效的收集垃圾</li></ol> 
<h4><a id="Region_669"></a>Region区域</h4> 
<p><strong>G1不再坚持固定大小以及固定数量的分代区域划分， 而是把连续的Java堆划分为多个独立区域（Region） ， 每一个Region都可以根据需要， 扮演新生代的Eden空间、 Survivor空间， 或者老年代空间。</strong></p> 
<p><img src="https://images2.imgbox.com/3a/d1/gNU7AusW_o.png" alt="在这里插入图片描述"></p> 
<ol><li>将整个堆空间细分为若干个小的区域。</li><li>使用G1收集器时，<strong>它将整个Java堆划分成约2048个大小相同的独立Region块</strong>，每个Region块大小根据堆空间的实际大小而定，为2的N次幂，即1MB, 2MB, 4MB, 8MB, 16MB,32MB</li><li>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了,<strong>它们都是一部分Region (不需要连续)的集合</strong>。通过Region的动态分配方式实现逻辑上的连续。</li><li>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。<strong>主要用于存储大对象，如果超过1 .5个region,就放到H。一般被视为老年代.</strong></li></ol> 
<h4><a id="G1_GC_685"></a>G1 GC过程</h4> 
<p>G1提供了两种GC模式，Young GC和Mixed GC，两种均是完全Stop The World的。</p> 
<ul><li>Young GC：选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。</li><li>Mixed GC：选定所有年轻代里的Region，<strong>外加根据global concurrent marking统计得出收集收益高的若干老年代Region</strong>。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。</li></ul> 
<p><strong>在G1 GC垃圾回收的过程一个有四个阶段:</strong></p> 
<ul><li><strong>初始标记 :</strong> 和CMS一样只标记GC Roots直接关联的对象</li><li><strong>并发标记 :</strong> 进行GC Roots Traceing过程</li><li><strong>最终标记 :</strong> 修正并发标记期间,因程序运行导致发生变化的那一部分对象</li><li><strong>筛选回收 :</strong> 根据时间来进行价值最大化收集</li></ul> 
<p>下面是G1收集的示意图</p> 
<p><img src="https://images2.imgbox.com/26/b5/SWDDwqxc_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="G1_YoungGC_704"></a>G1 YoungGC</h5> 
<blockquote> 
 <p>YoungGC执行前</p> 
</blockquote> 
<p>堆分为大约2000个区域。最小大小为1Mb，最大大小为32Mb。蓝色区域保存老年代对象，绿色区域保存年轻对象。</p> 
<p><img src="https://images2.imgbox.com/76/6d/B8qySaeX_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>执行YoungGC</p> 
</blockquote> 
<p>将存活的对象（即复制或移动）到一个或多个幸存者区域（仍然执行的是复制过程）。如果满足老化阈值，则某些对象将被提升到老年代区域。</p> 
<p><img src="https://images2.imgbox.com/1d/bc/LY588E9o_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>G1的年轻GC结束</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/80/75/DoLdYphc_o.png" alt="在这里插入图片描述"></p> 
<p>最近升级的对象以深蓝色显示。幸存者区域为绿色。</p> 
<p>总而言之，关于G1的年轻一代，可以说以下几点：</p> 
<ul><li><strong>堆是单个内存空间，分为多个区域。</strong></li><li><strong>年轻代内存由一组非连续区域组成。</strong></li><li><strong>年轻一代的垃圾收集器或年轻的GC出现STW。将停止所有应用程序线程以进行操作。</strong></li><li><strong>年轻的GC使用多个线程并行完成。</strong></li><li><strong>将存活对象复制到新的幸存者或老年代的地区。</strong></li></ul> 
<h5><a id="G1_Mix_GC_737"></a>G1 Mix GC</h5> 
<p><strong>初始标记阶段（initial mark，STW）</strong></p> 
<p>存活的对象的初始标记背负在年轻的垃圾收集器上。在日志中，此标记为 GC pause (young)(inital-mark)</p> 
<p><img src="https://images2.imgbox.com/a4/6c/VUuSUz0u_o.png" alt="在这里插入图片描述"></p> 
<p><strong>并发标记阶段（Concurrent Marking）</strong></p> 
<p>如果找到空白区域（如“ X”所示），则在Remark阶段将其立即删除。另外，计算确定活跃度的信息。</p> 
<p><img src="https://images2.imgbox.com/6b/20/Ts6p5zOl_o.png" alt="在这里插入图片描述"></p> 
<p><strong>最终标记阶段（Remark，STW）</strong></p> 
<p>空区域将被删除并回收。现在可以计算所有区域的区域活跃度。</p> 
<p><img src="https://images2.imgbox.com/1a/6a/TN8CGUkt_o.png" alt="在这里插入图片描述"></p> 
<p><strong>筛选回收阶段/复制清理阶段（Cleanup，STW）</strong></p> 
<p><strong>G1选择“活度”最低的区域，这些区域可以被最快地收集。然后与年轻的GC同时收集这些区域</strong>。这在日志中表示为[GC pause (mixed)] 。因此，<strong>年轻代和老年代都是同时收集的。</strong></p> 
<p><img src="https://images2.imgbox.com/85/82/3fXonMUs_o.png" alt="在这里插入图片描述"></p> 
<p><strong>筛选回收阶段-(复制/清理)阶段之后</strong></p> 
<p>选定的区域已被收集并压缩为图中所示的深蓝色区域和深绿色区域</p> 
<p><img src="https://images2.imgbox.com/7f/d8/o1N5JexE_o.png" alt="在这里插入图片描述"></p> 
<p><strong>总结:</strong></p> 
<ul><li>并发标记阶段 
  <ul><li>活动信息是在应用程序运行时同时计算的。</li><li>该活动信息标识在疏散暂停期间最适合回收的区域。</li><li>像CMS中没有清扫阶段。</li></ul> </li><li>最终标记阶段 
  <ul><li>使用开始快照（SATB）算法，该算法比CMS使用的算法快得多。</li><li>完全回收空区域。</li></ul> </li><li>筛选回收阶段 
  <ul><li>同时回收年轻一代和老一代。</li><li>老年代地区是根据其活跃度来选择的。</li></ul> </li></ul> 
<h4><a id="G1_791"></a>G1常用参数</h4> 
<table><thead><tr><th>参数/默认值</th><th>含义</th></tr></thead><tbody><tr><td>-XX:+UseG1GC</td><td>使用 G1 垃圾收集器</td></tr><tr><td>-XX:MaxGCPauseMillis=200</td><td>设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保 证达到）</td></tr><tr><td>- X X:InitiatingHeapOccupancyPercent=45</td><td>mixed gc中也有一个阈值参数 ，当老年代大小占整个堆大小百分 比达到该阈值时，会触发一次mixed gc. 默认值为 45.</td></tr><tr><td>-XX:NewRatio=n</td><td>新生代与老生代(new/old generation)的大小比例(Ratio). 默认值为 2.</td></tr><tr><td>-XX:SurvivorRatio=n</td><td>eden/survivor 空间大小的比例(Ratio). 默认值为 8.</td></tr><tr><td>-XX:MaxTenuringThreshold=n</td><td>提升年老代的最大临界值(tenuring threshold). 默认值为 15.</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平 台不同而不同.</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>并发垃圾收集器使用的线程数量. 默认值随JVM运行的平台不同而 不同.</td></tr><tr><td>-XX:G1ReservePercent=n</td><td>设置堆内存保留为假天花板的总量,以降低提升失败的可能性. 默认 值是 10.</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f64855621d7e97a322d1ffe000bfc12c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一篇彻底解决:Fatal error compiling: 无效的目标发行版: 11 -＞ [Help 1]</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c17f7c2f33f4092d8cc5a0090bf05196/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">流水灯电路设计实验--VHDL</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>