<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构初阶--带头双向循环链表 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/fbf6df95cfbc8c0bb10d25dbadf19302/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="数据结构初阶--带头双向循环链表">
  <meta property="og:description" content="目录
一.带头双向循环链表的定义
二.带头双向循环链表的功能实现
2.1.带头双向循环链表的定义
2.2.带头双向循环链表的结点创建
2.3.带头双向循环链表的初始化
2.4.带头双向循环链表的打印
2.5.带头双向循环链表的判空
2.6.带头双向循环链表的尾插
2.7.带头双向循环链表的头插
2.8.带头双向循环链表的尾删
2.9.带头双向循环链表的头删
2.10.带头双向循环链表的在pos位置之前插入
2.11.带头双向循环链表的删除pos位置的结点
2.12.带头双向循环链表的求链表长度
2.13.带头双向循环链表的销毁
2.14.完整程序
List.h
List.c
test.c
三. 顺序表和链表的比较
逻辑结构
存储结构
基本操作
创建
销毁
增加与删除
查找
一.带头双向循环链表的定义 循环单链表虽然能够实现从任一结点出发沿着链能找到其前驱结点，但时间耗费是O(n)。如果希望从表中快速确定某一个结点的前驱，另一个解决方法就是在单链表的每个结点里再增加一个指向其前驱的指针域prior。这样形成的链表中就有两条方向不同的链，称之为双(向)链表。
与单链表类似，双链表也可增加头结点使双链表的某些运算变得方便。同时双向链表也可以有循环表，称为双向循环链表。
由于在双向链表中既有前向链又有后向链，寻找任一结点的直接前驱结点与直接后继结点都变得非常方便了。
二.带头双向循环链表的功能实现 2.1.带头双向循环链表的定义 //定义 typedef int LTDataType; typedef struct ListNode { struct ListNode* next; struct ListNode* pre; LTDataType data; }LTNode; 与单链表的定义不同，带头双向循环链表要定义两个指针：前驱指针pre和后继指针next。前驱指针pre用于指向当前结点的上一个结点，后继指针next用于指向当前结点的下一个结点。
2.2.带头双向循环链表的结点创建 LTNode* BuyListNode(LTDataType x) { //动态开辟一个结点node LTNode* node = (LTNode*)malloc(sizeof(LTNode)); //判空 if (node == NULL) { perror(&#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-25T12:44:33+08:00">
    <meta property="article:modified_time" content="2023-08-25T12:44:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构初阶--带头双向循环链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">一.带头双向循环链表的定义</a></p> 
<p id="%E4%BA%8C.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0" rel="nofollow">二.带头双向循环链表的功能实现</a></p> 
<p id="2.1.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#2.1.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">2.1.带头双向循环链表的定义</a></p> 
<p id="2.2.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#2.2.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9%E5%88%9B%E5%BB%BA" rel="nofollow">2.2.带头双向循环链表的结点创建</a></p> 
<p id="2.3.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.3.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2.3.带头双向循环链表的初始化</a></p> 
<p id="2.4.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0-toc" style="margin-left:40px;"><a href="#2.4.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0" rel="nofollow">2.4.带头双向循环链表的打印</a></p> 
<p id="2.5.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A4%E7%A9%BA-toc" style="margin-left:40px;"><a href="#2.5.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A4%E7%A9%BA" rel="nofollow">2.5.带头双向循环链表的判空</a></p> 
<p id="2.6.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E6%8F%92-toc" style="margin-left:40px;"><a href="#2.6.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E6%8F%92" rel="nofollow">2.6.带头双向循环链表的尾插</a></p> 
<p id="2.7.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92-toc" style="margin-left:40px;"><a href="#2.7.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92" rel="nofollow">2.7.带头双向循环链表的头插</a></p> 
<p id="2.8.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E5%88%A0-toc" style="margin-left:40px;"><a href="#2.8.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E5%88%A0" rel="nofollow">2.8.带头双向循环链表的尾删</a></p> 
<p id="2.9.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E5%88%A0-toc" style="margin-left:40px;"><a href="#2.9.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E5%88%A0" rel="nofollow">2.9.带头双向循环链表的头删</a></p> 
<p id="2.10.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5-toc" style="margin-left:40px;"><a href="#2.10.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5" rel="nofollow">2.10.带头双向循环链表的在pos位置之前插入</a></p> 
<p id="2.11.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%BB%93%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.11.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%BB%93%E7%82%B9" rel="nofollow">2.11.带头双向循环链表的删除pos位置的结点</a></p> 
<p id="2.12.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B1%82%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6-toc" style="margin-left:40px;"><a href="#2.12.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B1%82%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6" rel="nofollow">2.12.带头双向循环链表的求链表长度</a></p> 
<p id="2.13.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:40px;"><a href="#2.13.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">2.13.带头双向循环链表的销毁</a></p> 
<p id="2.14.%E5%AE%8C%E6%95%B4%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2.14.%E5%AE%8C%E6%95%B4%E7%A8%8B%E5%BA%8F" rel="nofollow">2.14.完整程序</a></p> 
<p id="List.h-toc" style="margin-left:80px;"><a href="#List.h" rel="nofollow">List.h</a></p> 
<p id="List.c-toc" style="margin-left:80px;"><a href="#List.c" rel="nofollow">List.c</a></p> 
<p id="test.c-toc" style="margin-left:80px;"><a href="#test.c" rel="nofollow">test.c</a></p> 
<p id="%E4%B8%89.%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">三. 顺序表和链表的比较</a></p> 
<p id="%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84" rel="nofollow">逻辑结构</a></p> 
<p id="%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" rel="nofollow">存储结构</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">基本操作</a></p> 
<p id="%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BA" rel="nofollow">创建</a></p> 
<p id="%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#%E9%94%80%E6%AF%81" rel="nofollow">销毁</a></p> 
<p id="%E5%A2%9E%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%E5%A2%9E%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4" rel="nofollow">增加与删除</a></p> 
<p id="%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#%E6%9F%A5%E6%89%BE" rel="nofollow">查找</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89">一.带头双向循环链表的定义</h2> 
<p>循环单链表虽然能够实现从任一结点出发沿着链能找到其前驱结点，但时间耗费是O(n)。如果希望从表中快速确定某一个结点的前驱，另一个解决方法就是在单链表的每个结点里再增加一个指向其前驱的指针域prior。这样形成的链表中就有两条方向不同的链，称之为双(向)链表。</p> 
<p>与单链表类似，双链表也可增加头结点使双链表的某些运算变得方便。同时双向链表也可以有循环表，称为双向循环链表。</p> 
<p class="img-center"><img alt="" height="106" src="https://images2.imgbox.com/fe/a2/WzJyXbsS_o.png" width="811"></p> 
<p>由于在双向链表中既有前向链又有后向链，寻找任一结点的直接前驱结点与直接后继结点都变得非常方便了。</p> 
<p><img alt="" height="179" src="https://images2.imgbox.com/80/de/4OiEfVJA_o.png" width="800"></p> 
<h2 id="%E4%BA%8C.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">二.带头双向循环链表的功能实现</h2> 
<h3 id="2.1.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89">2.1.带头双向循环链表的定义</h3> 
<pre><code class="language-cpp">//定义
typedef int LTDataType;

typedef struct ListNode
{
	struct ListNode* next;
	struct ListNode* pre;
	LTDataType data;
}LTNode;</code></pre> 
<p> 与单链表的定义不同，带头双向循环链表要定义两个指针：前驱指针pre和后继指针next。前驱指针pre用于指向当前结点的上一个结点，后继指针next用于指向当前结点的下一个结点。</p> 
<h3 id="2.2.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9%E5%88%9B%E5%BB%BA">2.2.带头双向循环链表的结点创建</h3> 
<pre><code class="language-cpp">LTNode* BuyListNode(LTDataType x)
{
	//动态开辟一个结点node
	LTNode* node = (LTNode*)malloc(sizeof(LTNode));

	//判空
	if (node == NULL)
	{
		perror("malloc fail!");
		exit(-1);
	}

	//前驱与后继结点均置为空
	node-&gt;data = x;
	node-&gt;next = NULL;
	node-&gt;pre = NULL;

	return node;
}</code></pre> 
<p>结点的创建主要是通过调用malloc函数来实现，初始化时要将前驱指针和后继指针都置为NULL。</p> 
<h3 id="2.3.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">2.3.带头双向循环链表的初始化</h3> 
<p><strong>版本一：</strong></p> 
<pre><code class="language-cpp">void ListInit(LTNode** phead)
{
	//这里需要传入二级指针，即传地址，才能实现对链表的修改

	//判空
	assert(phead);
	
	//创建头结点
	*phead = BuyListNode(-1);

	//将头结点的前驱指针和后继指针均指向自身
	(*phead)-&gt;next = *phead;
	(*phead)-&gt;pre = *phead;
}</code></pre> 
<p><strong>版本二：</strong></p> 
<pre><code class="language-cpp">LTNode* ListInit()
{
	//创建头结点
	LTNode* phead = BuyListNode(-1);

	//将头结点的前驱指针和后继指针均指向自身
	phead-&gt;next = phead;
	phead-&gt;pre = phead;

	//返回头结点
	return phead;
}</code></pre> 
<p>链表的初始化采用了两种方式：传二级指针和设置返回值。</p> 
<p><strong>总结：</strong></p> 
<p><span style="color:#fe2c24;"><strong>如果要改变头指针，就要传二级指针。不需要改变头指针的话，则传入一级指针。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>在使用带头结点的单链表时：</strong></span></p> 
<ol><li><span style="color:#fe2c24;"><strong>初始化链表头指针需要传二级指针；</strong></span></li><li><span style="color:#fe2c24;"><strong>销毁链表需要传二级指针；</strong></span></li><li><span style="color:#fe2c24;"><strong>插入、删除、遍历、清空结点用一级指针即可。</strong></span></li></ol> 
<p><span style="color:#fe2c24;"><strong>不带头结点的单链表，除了初始化和销毁，插入、删除和清空结点也需要二级指针。</strong></span></p> 
<p><strong>调试分析：</strong></p> 
<p class="img-center"><img alt="" height="285" src="https://images2.imgbox.com/28/6e/KFAzDfNI_o.png" width="619"></p> 
<h3 id="2.4.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0">2.4.带头双向循环链表的打印</h3> 
<pre><code class="language-cpp">void ListPrint(LTNode* phead)
{
	//判空
	assert(phead);

	//cur指向链表的第一个结点
	LTNode* cur = phead-&gt;next;

	//cur依次向后遍历，直到cur重新回到头结点
	while (cur != phead)
	{
		printf("%d ", cur-&gt;data);
		cur = cur-&gt;next;
	}

	printf("\n");
}</code></pre> 
<p>设置一个临时变量cur，指向当前链表的第一个结点(非头结点)，然后依次向后遍历该链表，直到cur重新回到头结点phead的位置。</p> 
<h3 id="2.5.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A4%E7%A9%BA">2.5.带头双向循环链表的判空</h3> 
<pre><code class="language-cpp">bool ListEmpty(LTNode* phead)
{
	//判空
	assert(phead);

	//如果phead-&gt;next等于phead，则链表为空，返回true
	//如果phead-&gt;next不等于phead，则链表不为空，返回false
	return phead-&gt;next == phead;
}</code></pre> 
<p>如果phead-&gt;next等于phead，则链表为空，返回true；如果phead-&gt;next不等于phead，则链表不为空，返回false。</p> 
<h3 id="2.6.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E6%8F%92">2.6.带头双向循环链表的尾插</h3> 
<pre><code class="language-cpp">void ListPushBack(LTNode* phead, LTDataType x)
{
	//判空
	assert(phead);

	//创建新结点
	LTNode* newnode = BuyListNode(x);

	//查找尾结点
	LTNode* tail = phead-&gt;pre;

	//尾插
	//原尾和新尾相互链接
	tail-&gt;next = newnode;
	newnode-&gt;pre = tail;
	//头结点和新尾相互链接
	newnode-&gt;next = phead;
	phead-&gt;pre = newnode;
}</code></pre> 
<p>相较于单链表的尾插，带头双向循环链表的尾插不需要从头结点开始依次向后遍历，因为头结点的前驱结点便指向尾结点tail。在找到尾结点tail之后，便可将新结点newnode插入到尾结点tail的后面。此时newnode变为新的尾结点。</p> 
<p><strong>调试分析：</strong></p> 
<p class="img-center"><img alt="" height="401" src="https://images2.imgbox.com/d3/77/KLb09j81_o.png" width="643"></p> 
<p><strong>运行结果：</strong></p> 
<p class="img-center"><img alt="" height="33" src="https://images2.imgbox.com/bd/85/AI6hEDTd_o.png" width="410"></p> 
<h3 id="2.7.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92">2.7.带头双向循环链表的头插</h3> 
<pre><code class="language-cpp">void ListPushFront(LTNode* phead, LTDataType x)
{
	//判空
	assert(phead);

	//创建新结点
	LTNode* newnode = BuyListNode(x);

	//头插
	//phead newnode next：三者不分先后顺序
	//法一：
	LTNode* next = phead-&gt;next;
	phead-&gt;next = newnode;
	newnode-&gt;pre = phead;
	newnode-&gt;next = next;
	next-&gt;pre = newnode;

	//phead newnode phead-&gt;next：先处理后两个，再处理前两个
    //法二：
	//phead-&gt;next-&gt;pre = newnode;
	//newnode-&gt;next = phead-&gt;next;
	//phead-&gt;next = newnode;
	//newnode-&gt;pre = phead;
}</code></pre> 
<p>在进行头插时，要注意结点之间插入的先后顺序，这里主要介绍两种方式。方式一：创建一个临时变量next，然后将头结点的下一个结点保存在next当中。首先调用BuyListNode(x)创建一个新结点newnode，然后将phead，newnode和next三个结点进行链接。三个结点不分先后顺序，直接进行链接即可。该方式最为简单，也最不容易出错；方式二：不创建临时变量next。首先调用BuyListNode(x)创建一个新结点newnode，然后将phead，newnode和phead-&gt;next三个结点进行链接。链接是关键：要先将后两个结点进行链接，然后再将前两个结点进行链接。三个结点一定要注意先后顺序，不可随意链接。</p> 
<p><strong>调试分析：</strong></p> 
<p class="img-center"><img alt="" height="424" src="https://images2.imgbox.com/22/6b/8Rthw2SZ_o.png" width="645"></p> 
<p><strong>运行结果：</strong></p> 
<p class="img-center"><img alt="" height="33" src="https://images2.imgbox.com/55/8f/MVpEQV6y_o.png" width="375"></p> 
<h3 id="2.8.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E5%88%A0">2.8.带头双向循环链表的尾删</h3> 
<pre><code class="language-cpp">void ListPopBack(LTNode* phead)
{
	//判空
	assert(phead);

	//判断链表是否为空
	assert(phead-&gt;next != phead);
	//assert(!ListEmpty(phead));

	//找尾结点
	LTNode* tail = phead-&gt;pre;

	//找尾结点的前一结点
	LTNode* tailPre = tail-&gt;pre;

	//释放尾结点
	free(tail);

	tailPre-&gt;next = phead;
	phead-&gt;pre = tailPre;
}</code></pre> 
<p>在进行尾删之前，首先要判断链表是否为空，可以通过phead-&gt;next != phead进行判断，也可以调用ListEmpty(phead)函数进行判断；然后找到链表的尾结点tail，以及链表尾结点的前一个结点tailPre；接着调用free函数释放尾结点tail，并将tailPre作为新的尾结点；最后再将新的尾结点与头结点phead进行相连即可。</p> 
<p><strong>调试分析：</strong></p> 
<p class="img-center"><img alt="" height="436" src="https://images2.imgbox.com/d1/00/vL4SHC04_o.png" width="649"></p> 
<p><strong>运行结果：</strong></p> 
<p class="img-center"><img alt="" height="49" src="https://images2.imgbox.com/5c/2b/Z2i1vXbx_o.png" width="359"></p> 
<h3 id="2.9.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E5%88%A0">2.9.带头双向循环链表的头删</h3> 
<pre><code class="language-cpp">void ListPopFront(LTNode* phead)
{
	//判空
	assert(phead);

	//判断链表是否为空
	assert(phead-&gt;next != phead);
	//assert(!ListEmpty(phead));

	//tail记录第一个结点之后的下一个结点
	LTNode* tail = phead-&gt;next-&gt;next;
	
	//释放第一个结点
	free(phead-&gt;next);

	//将头结点和tail相链接
	phead-&gt;next = tail;
	tail-&gt;pre = phead;
}</code></pre> 
<p>在进行头删之前，首先要判断链表是否为空，可以通过phead-&gt;next != phead进行判断，也可以调用ListEmpty(phead)函数进行判断；然后找到链表的第二个有效结点tail；接着调用free函数释放掉第一个有效结点，并将tail作为新的第一个有效结点；最后再将新的第一个结点tail与头结点phead进行相连即可。</p> 
<p><strong>调试分析：</strong></p> 
<p class="img-center"><img alt="" height="349" src="https://images2.imgbox.com/94/80/lZAcYdla_o.png" width="638"></p> 
<p><strong>运行结果：</strong></p> 
<p class="img-center"><img alt="" height="44" src="https://images2.imgbox.com/46/61/FTQSlktP_o.png" width="408"></p> 
<h3 id="2.10.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9C%A8pos%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5">2.10.带头双向循环链表的在pos位置之前插入</h3> 
<pre><code class="language-cpp">void ListInsert(LTNode* pos, LTDataType x)
{
	//判空
	assert(pos);

	//查找pos的前一个结点
	LTNode* pre = pos-&gt;pre;

	//创建新结点
	LTNode* newnode = BuyListNode(x);

	//pre newnode pos
	pre-&gt;next = newnode;
	newnode-&gt;pre = pre;
	newnode-&gt;next = pos;
	pos-&gt;pre = newnode;
}</code></pre> 
<p>给定一个结点pos，如果是带头双向循环链表，那么pos之前的结点和pos之后的结点都是可知的。要在pos位置之前插入，首先要找到pos的前一结点pre，然后调用BuyListNode(x)创建一个新结点newnode，接着将pre，newnode和pos三个结点进行链接即可。此时pos位置的结点将由pos变为newnode。</p> 
<p><strong>调试分析：</strong></p> 
<p class="img-center"><img alt="" height="411" src="https://images2.imgbox.com/f4/d5/cYyf8WBG_o.png" width="642"></p> 
<p><strong>运行结果：</strong></p> 
<p class="img-center"><img alt="" height="48" src="https://images2.imgbox.com/e7/1c/MNRJ5N0g_o.png" width="385"></p> 
<h3 id="2.11.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%BB%93%E7%82%B9">2.11.带头双向循环链表的删除pos位置的结点</h3> 
<pre><code class="language-cpp">void ListErase(LTNode* pos)
{
	//判空
	assert(pos);

	//查找pos的前一个结点
	LTNode* pre = pos-&gt;pre;
	
	//查找pos的后一个结点
	LTNode* next = pos-&gt;next;

	//将前一个结点pre与后一个结点next相链接
	pre-&gt;next = next;
	next-&gt;pre = pre;

	//释放pos结点
	free(pos);
}</code></pre> 
<p>在删除pos位置的结点之前，首先要找到pos位置的前一个结点pre，然后找到pos位置的后一个结点next，接着将结点pre与next相链接，最后再调用free函数释放掉pos结点即可。</p> 
<p><strong>调试分析：</strong></p> 
<p class="img-center"><img alt="" height="419" src="https://images2.imgbox.com/13/1e/LZiLvR8G_o.png" width="636"></p> 
<p><strong>运行结果：</strong></p> 
<p class="img-center"><img alt="" height="48" src="https://images2.imgbox.com/34/44/muvjAJWn_o.png" width="394"></p> 
<h3 id="2.12.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B1%82%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6">2.12.带头双向循环链表的求链表长度</h3> 
<pre><code class="language-cpp">int ListSize(LTNode* phead)
{
	//判空
	assert(phead);

	//cur指向当前链表的第一个结点
	LTNode* cur = phead-&gt;next;
	
	//用于记录遍历过的结点数
	int size = 0;

	//从第一个结点开始依次向后遍历，直到遍历到头结点
	while (cur != phead)
	{
		++size;
		cur = cur-&gt;next;
	}

	return size;
}</code></pre> 
<p><strong>调试分析：</strong></p> 
<p class="img-center"><img alt="" height="422" src="https://images2.imgbox.com/c1/8b/TNksWDPU_o.png" width="635"></p> 
<p><strong>运行结果：</strong></p> 
<p class="img-center"><img alt="" height="46" src="https://images2.imgbox.com/12/61/GXchI2n4_o.png" width="517"></p> 
<h3 id="2.13.%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81">2.13.带头双向循环链表的销毁</h3> 
<pre><code class="language-cpp">void ListDestory(LTNode* phead)
{
	//判空
	assert(phead);

	//cur指向当前第一个结点
	LTNode* cur = phead-&gt;next;

	while (cur != phead)
	{
		//保存cur的下一个结点
		LTNode* next = cur-&gt;next;

		//删除cur
		ListErase(cur);

		//更新cur
		cur = next;
	}

	//释放头结点
	free(phead);
}</code></pre> 
<p><strong>调试分析：</strong></p> 
<p class="img-center"><img alt="" height="422" src="https://images2.imgbox.com/70/d8/zH35GJx7_o.png" width="641"></p> 
<p><strong>运行结果：</strong></p> 
<p class="img-center"><img alt="" height="32" src="https://images2.imgbox.com/3f/e1/ZuQTvAD9_o.png" width="328"></p> 
<h3 id="2.14.%E5%AE%8C%E6%95%B4%E7%A8%8B%E5%BA%8F">2.14.完整程序</h3> 
<h4 id="List.h">List.h</h4> 
<pre><code class="language-cpp">#pragma once

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

//带头双向循环链表

//定义
typedef int LTDataType;

typedef struct ListNode
{
	struct ListNode* next;
	struct ListNode* pre;
	LTDataType data;
}LTNode;

//创建结点
LTNode* BuyListNode(LTDataType x);

//初始化：版本一
//void ListInit(LTNode** phead);

//初始化：版本二
LTNode* ListInit();

//打印
void ListPrint(LTNode* phead);

//判空
bool ListEmpty(LTNode* phead);

//尾插
//不用二级指针的原因：尾插时不会改变phead，因为它带哨兵位，尾插时不会对哨兵位进行修改
void ListPushBack(LTNode* phead, LTDataType x);

//头插
void ListPushFront(LTNode* phead, LTDataType x);

//尾删
void ListPopBack(LTNode* phead);

//头删
void ListPopFront(LTNode* phead);

//在pos位置之前插入
void ListInsert(LTNode* pos, LTDataType x);

//删除pos位置的结点
void ListErase(LTNode* pos);

//链表长度
int ListSize(LTNode* phead);

//销毁
void ListDestory(LTNode* phead);</code></pre> 
<h4 id="List.c">List.c</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1


#include"List.h"


//创建结点
LTNode* BuyListNode(LTDataType x)
{
	//动态开辟一个结点node
	LTNode* node = (LTNode*)malloc(sizeof(LTNode));

	//判空
	if (node == NULL)
	{
		perror("malloc fail!");
		exit(-1);
	}

	//前驱与后继结点均置为空
	node-&gt;data = x;
	node-&gt;next = NULL;
	node-&gt;pre = NULL;

	return node;
}


//初始化
/*
void ListInit(LTNode** phead)
{
	//这里需要传入二级指针，即传地址，才能实现对链表的修改

	//判空
	assert(phead);
	
	//创建头结点
	*phead = BuyListNode(-1);

	//将头结点的前驱指针和后继指针均指向自身
	(*phead)-&gt;next = *phead;
	(*phead)-&gt;pre = *phead;
}
*/


//初始化
LTNode* ListInit()
{
	//创建头结点
	LTNode* phead = BuyListNode(-1);

	//将头结点的前驱指针和后继指针均指向自身
	phead-&gt;next = phead;
	phead-&gt;pre = phead;

	//返回头结点
	return phead;
}


//打印
void ListPrint(LTNode* phead)
{
	//判空
	assert(phead);

	//cur指向链表的第一个结点
	LTNode* cur = phead-&gt;next;

	//cur依次向后遍历，直到cur重新回到头结点
	while (cur != phead)
	{
		printf("%d ", cur-&gt;data);
		cur = cur-&gt;next;
	}

	printf("\n");
}


//判空
bool ListEmpty(LTNode* phead)
{
	//判空
	assert(phead);

	//如果phead-&gt;next等于phead，则链表为空，返回true
	//如果phead-&gt;next不等于phead，则链表不为空，返回false
	return phead-&gt;next == phead;
}


//尾插
void ListPushBack(LTNode* phead, LTDataType x)
{
	//判空
	assert(phead);

	/*
	//创建新结点
	LTNode* newnode = BuyListNode(x);

	//查找尾结点
	LTNode* tail = phead-&gt;pre;

	//尾插
	//原尾和新尾相互链接
	tail-&gt;next = newnode;
	newnode-&gt;pre = tail;
	//头结点和新尾相互链接
	newnode-&gt;next = phead;
	phead-&gt;pre = newnode;
	*/

	//尾插
	ListInsert(phead, x);//是phead而不是phead-&gt;pre
}


//头插
void ListPushFront(LTNode* phead, LTDataType x)
{
	//判空
	assert(phead);

	/*
	//创建新结点
	LTNode* newnode = BuyListNode(x);

	//头插
	//phead newnode next：三者不分先后顺序
	//法一：
	LTNode* next = phead-&gt;next;
	phead-&gt;next = newnode;
	newnode-&gt;pre = phead;
	newnode-&gt;next = next;
	next-&gt;pre = newnode;

	//phead newnode phead-&gt;next：先处理后两个，再处理前两个
    //法二：
	//phead-&gt;next-&gt;pre = newnode;
	//newnode-&gt;next = phead-&gt;next;
	//phead-&gt;next = newnode;
	//newnode-&gt;pre = phead;
	*/

	//头插
	ListInsert(phead-&gt;next, x);
}


//尾删
void ListPopBack(LTNode* phead)
{
	//判空
	assert(phead);

	//判断链表是否为空
	assert(phead-&gt;next != phead);
	//assert(!ListEmpty(phead));

	/*
	//找尾结点
	LTNode* tail = phead-&gt;pre;

	//找尾结点的前一结点
	LTNode* tailPre = tail-&gt;pre;

	//释放尾结点
	free(tail);

	tailPre-&gt;next = phead;
	phead-&gt;pre = tailPre;
	*/

	//尾删
	ListErase(phead-&gt;pre);
}


//头删
void ListPopFront(LTNode* phead)
{
	//判空
	assert(phead);

	//判断链表是否为空
	assert(phead-&gt;next != phead);
	//assert(!ListEmpty(phead));

	/*
	//tail记录第一个结点之后的下一个结点
	LTNode* tail = phead-&gt;next-&gt;next;
	
	//释放第一个结点
	free(phead-&gt;next);

	//将头结点和tail相链接
	phead-&gt;next = tail;
	tail-&gt;pre = phead;
	*/

	//头删
	ListErase(phead-&gt;next);
}


//在pos位置之前插入x
void ListInsert(LTNode* pos, LTDataType x)
{
	//判空
	assert(pos);

	//查找pos的前一个结点
	LTNode* pre = pos-&gt;pre;

	//创建新结点
	LTNode* newnode = BuyListNode(x);

	//pre newnode pos
	pre-&gt;next = newnode;
	newnode-&gt;pre = pre;
	newnode-&gt;next = pos;
	pos-&gt;pre = newnode;
}


//删除pos位置的结点
void ListErase(LTNode* pos)
{
	//判空
	assert(pos);

	//查找pos的前一个结点
	LTNode* pre = pos-&gt;pre;
	
	//查找pos的后一个结点
	LTNode* next = pos-&gt;next;

	//将前一个结点pre与后一个结点next相链接
	pre-&gt;next = next;
	next-&gt;pre = pre;

	//释放pos结点
	free(pos);
}


//链表长度
int ListSize(LTNode* phead)
{
	//判空
	assert(phead);

	//cur指向当前链表的第一个结点
	LTNode* cur = phead-&gt;next;
	
	//用于记录遍历过的结点数
	int size = 0;

	//从第一个结点开始依次向后遍历，直到遍历到头结点
	while (cur != phead)
	{
		++size;
		cur = cur-&gt;next;
	}

	return size;
}


//销毁
void ListDestory(LTNode* phead)
{
	//判空
	assert(phead);

	//cur指向当前第一个结点
	LTNode* cur = phead-&gt;next;

	while (cur != phead)
	{
		//保存cur的下一个结点
		LTNode* next = cur-&gt;next;

		//法一：删除cur
		//ListErase(cur);
		
		//法二：删除cur
		free(cur);

		//更新cur
		cur = next;
	}

	//释放头结点
	free(phead);
}</code></pre> 
<h4 id="test.c">test.c</h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

#include"List.h"

void test()
{
	LTNode* plist = NULL;

	//初始化
	plist = ListInit();

	//头插
	ListPushFront(plist, 1);
	ListPushFront(plist, 2);
	ListPushFront(plist, 3);
	ListPushFront(plist, 4);
	ListPushFront(plist, 5);
	ListPrint(plist);

	ListDestory(plist);
	ListPrint(plist);
}

int main()
{
	test();

	return 0;
}</code></pre> 
<h2 id="%E4%B8%89.%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83">三. 顺序表和链表的比较</h2> 
<p>下面分别从逻辑结构，存储结构，基本操作的角度对顺序表和链表进行比较。</p> 
<h3 id="%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">逻辑结构</h3> 
<p>都属于线性表，都是线性结构。</p> 
<h3 id="%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">存储结构</h3> 
<p class="img-center"><img alt="" height="316" src="https://images2.imgbox.com/4c/b9/T6YcAUBq_o.png" width="677"></p> 
<h3 id="%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">基本操作</h3> 
<p>对于任何一个数据结构，基本操作基本都能归纳为创销，增删改查。其中改建立在查的基础上。</p> 
<h4 id="%E5%88%9B%E5%BB%BA">创建</h4> 
<p class="img-center"><img alt="" height="238" src="https://images2.imgbox.com/99/fb/RXGAsr3W_o.png" width="500"></p> 
<h4 id="%E9%94%80%E6%AF%81">销毁</h4> 
<p class="img-center"><img alt="" height="247" src="https://images2.imgbox.com/30/d6/YTNojXTE_o.png" width="500"></p> 
<h4 id="%E5%A2%9E%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4">增加与删除</h4> 
<p class="img-center"><img alt="" height="209" src="https://images2.imgbox.com/64/a3/HxaKsSS2_o.png" width="500"></p> 
<h4 id="%E6%9F%A5%E6%89%BE">查找</h4> 
<p class="img-center"><img alt="" height="213" src="https://images2.imgbox.com/13/df/VcNCvFLc_o.png" width="500"></p> 
<p><strong>用链表还是顺序表</strong></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:407px;"><tbody><tr><td style="width:118px;"></td><td style="width:156px;"><strong>          顺序表</strong></td><td style="width:130px;"><strong>          链表</strong></td></tr><tr><td style="width:118px;"><strong>弹性（可扩容）</strong></td><td style="width:156px;">             ×</td><td style="width:130px;">           √</td></tr><tr><td style="width:118px;"><strong>     增，删</strong></td><td style="width:156px;">             ×</td><td style="width:130px;">           √</td></tr><tr><td style="width:118px;"><strong>        改</strong></td><td style="width:156px;">             √</td><td style="width:130px;">           ×</td></tr></tbody></table> 
<p>表长难以预估，经常需要增加/删除元素--链表</p> 
<p>表长可预估，查询（搜索）操作较多--顺序表</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1ef0d4477b2ffaeb9c508a84d15234fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">azure data studio SQL扩展插件开发笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59e3004a280ef869d5190c2b85bdc2ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python&#43;pyecharts&#43;flask&#43;爬虫实现实时天气查询可视化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>