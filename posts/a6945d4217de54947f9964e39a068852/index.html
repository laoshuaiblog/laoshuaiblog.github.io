<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于C语言的哈夫曼树的实现(包含完整代码) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/a6945d4217de54947f9964e39a068852/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="基于C语言的哈夫曼树的实现(包含完整代码)">
  <meta property="og:description" content="一.哈夫曼树的定义: 在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。从树的根到任意结点的路径长度(经过的边数)与该结点上权值的乘积，称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度.
在含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树。 例如，下图的3棵二叉树都有4个叶子结点a,b, c,d,分别带权7,5,2,4, 它们的带权路径长度分别为 (a)WPL = 7*2&#43;5*2&#43;2*2&#43;4*2=36 (b)WPL = 4*2&#43;7*3&#43;5*3&#43;2*1=46 (c)WPL = 7*1&#43;5*2&#43;2*3&#43;4*3=35 (c)树的WPL最小.可以验证,它恰好是哈夫曼树. 二.哈夫曼树的构造: 给定n个权值分别为w1, w2,.., W{,的结点，构造哈夫曼树的算法描述如下: 1)将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。
2)构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且
将新结点的权值置为左、右子树上根结点的权值之和。
3)从F中删除刚才选出的两棵树，同时将新得到的树加入F中。
4)重复步骤2)和3),直至F中只剩下一棵树为止。
从上述构造过程中可以看出哈夫曼树具有如下特点: 1)每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。
2)构造过程中共新建了n-1个结点(双分支结点)，因此哈夫曼树的结点总数为2n-1。
3)每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。
例如，权值(7,5,2,4)的哈夫曼树的构造过程如下图 : 三.代码实现: 1. 树中结点的结构体 typedef struct TreeNode { int weight;//权值 int parent;//父结点 int lchild;//左孩子 int rchild;//右孩子 }TreeNode; 2.哈夫曼树的结构体 typedef struct HFTree { TreeNode *data;//数据域 int length;//长度(结点个数) }HFTree; 3.初始化哈夫曼树 HFTree *initTree(int *weight,int length) {/*参数一:权值数组 参数二:数组长度*/ HFTree *T = (HFTree *)malloc(sizeof(HFTree));//申请一颗树的空间 T-&amp;gt;data = (TreeNode *)malloc(sizeof(TreeNode)*(2*length-1));//申请一个结点的空间,长度由数组长度确定 T-&amp;gt;length = length;//长度写入 int i; for(i=0;i&amp;lt;length;i&#43;&#43;) {/*按序一次写入权值,父结点初始为0,左右孩子初始为-1*/ T-&amp;gt;data[i].">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-24T18:57:40+08:00">
    <meta property="article:modified_time" content="2023-05-24T18:57:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于C语言的哈夫曼树的实现(包含完整代码)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.哈夫曼树的定义:</h2> 
<h4>在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。从树的根到任意结点的路径长度(经过的边数)与该结点上权值的乘积，称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度.<br> 在含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树。</h4> 
<h4>例如，下图的3棵二叉树都有4个叶子结点a,b, c,d,分别带权7,5,2,4, 它们的带权路径长度分别为</h4> 
<p> <img alt="" height="308" src="https://images2.imgbox.com/c4/c3/vSDvTbXQ_o.png" width="956"></p> 
<h4> (a)WPL = 7*2+5*2+2*2+4*2=36</h4> 
<h4>(b)WPL = 4*2+7*3+5*3+2*1=46</h4> 
<h4>(c)WPL = 7*1+5*2+2*3+4*3=35</h4> 
<h4>(c)树的WPL最小.可以验证,它恰好是哈夫曼树.</h4> 
<h2>二.哈夫曼树的构造: </h2> 
<h4>给定n个权值分别为w1, w2,.., W{,的结点，构造哈夫曼树的算法描述如下: <br> 1)将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。<br> 2)构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且<br> 将新结点的权值置为左、右子树上根结点的权值之和。<br> 3)从F中删除刚才选出的两棵树，同时将新得到的树加入F中。<br> 4)重复步骤2)和3),直至F中只剩下一棵树为止。<br> 从上述构造过程中可以看出哈夫曼树具有如下特点: <br> 1)每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。<br> 2)构造过程中共新建了n-1个结点(双分支结点)，因此哈夫曼树的结点总数为2n-1。<br> 3)每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。<br> 例如，权值(7,5,2,4)的哈夫曼树的构造过程如下图 :</h4> 
<p><img alt="" height="416" src="https://images2.imgbox.com/92/2b/780s2BDD_o.png" width="943"> </p> 
<h2> 三.代码实现:</h2> 
<h3>1. 树中结点的结构体</h3> 
<pre><code class="language-cpp">typedef struct TreeNode
{
	int weight;//权值 
	int parent;//父结点 
	int lchild;//左孩子 
	int rchild;//右孩子 
}TreeNode;</code></pre> 
<h3> 2.哈夫曼树的结构体</h3> 
<pre><code class="language-cpp">typedef struct HFTree
{
	TreeNode *data;//数据域 
	int length;//长度(结点个数) 
}HFTree;</code></pre> 
<h3> 3.初始化哈夫曼树</h3> 
<p> </p> 
<pre><code class="language-cpp">HFTree *initTree(int *weight,int length)
{/*参数一:权值数组
参数二:数组长度*/
	HFTree *T = (HFTree *)malloc(sizeof(HFTree));//申请一颗树的空间 
	T-&gt;data = (TreeNode *)malloc(sizeof(TreeNode)*(2*length-1));//申请一个结点的空间,长度由数组长度确定 
	T-&gt;length = length;//长度写入 
	int i;
	for(i=0;i&lt;length;i++)
	{/*按序一次写入权值,父结点初始为0,左右孩子初始为-1*/
		T-&gt;data[i].weight = weight[i];
		T-&gt;data[i].parent = 0;
		T-&gt;data[i].rchild = -1;
		T-&gt;data[i].lchild = -1;
	}
	return T;
}</code></pre> 
<h3>4.挑选最小权值的两个结点下标</h3> 
<pre><code class="language-cpp">int *selectMin(HFTree *T)
{
	int min = 10000;//第一小 
	int secondMin = 10000;//第二小 
	int minIndex;//第一小的下标 
	int i;
	int secondIndex;//第二小的下标 
	for(i=0;i&lt;T-&gt;length;i++)
	{/*挨个比对,遇到小的写入min,并把下标写入minIndex*/
		if(T-&gt;data[i].parent==0)
		{
			if(T-&gt;data[i].weight&lt;min)
			{
				min = T-&gt;data[i].weight;
				minIndex = i;
			}
		}
	}
	for(i=0;i&lt;T-&gt;length;i++)
	{/*挨个对比,遇到小的,并且下标不等于第一小的下标,写入seconMin,并把下标写入secondIndex*/
		if(T-&gt;data[i].parent==0&amp;&amp;i!=minIndex)
		{
			if(T-&gt;data[i].weight&lt;secondMin)
			{
				secondMin = T-&gt;data[i].weight;
				secondIndex = i;
			}
		}
	}
	int *res = (int *)malloc(sizeof(int)*2);//由于要传两个参数,因此申请大小为2的内存空间 
	res[0] = minIndex;//写入第一小的下标 
	res[1] = secondIndex;//写入第二小的下标 
	return res;//返回指针 
}</code></pre> 
<h3> 5.创建哈夫曼树</h3> 
<pre><code class="language-cpp">void creatHFTree(HFTree *T)
{
	int *res;//用以接收selectMin()函数的两个参数 
	int min;//权值第一小的下标 
	int secondMin;//权值第二小的下标 
	int i;
	int length = T-&gt;length*2-1;//叶子结点数目n则总结点数目2n-1 
	for(i=T-&gt;length;i&lt;length;i++)
	{
		res = selectMin(T);//接收两个最小权值的下标 
		min = res[0];//第一小赋值给min 
		secondMin = res[1];//第二小赋值给seconMin 
		T-&gt;data[i].weight = T-&gt;data[min].weight+T-&gt;data[secondMin].weight;//连个最小的结点相加 
		T-&gt;data[i].lchild = min;//父结点的左孩子下标为min 
		T-&gt;data[i].rchild = secondMin;//父结点的右孩子下标为secondMin 
		T-&gt;data[i].parent = 0;//该父结点的父结点暂时没有,设为0 
		T-&gt;data[min].parent = i;//左孩子的父结点为i 
		T-&gt;data[secondMin].parent = i;//右孩子的父结点为i 
		T-&gt;length++;//树的结点数加一(长度加一) 
	}
}</code></pre> 
<h3> 6.前序遍历</h3> 
<pre><code class="language-cpp">void preOrder(HFTree *T,int index)
{/*参数一:哈夫曼树的结构体
参数二:树的下标*/
	if(index!=-1)//index!=-1表示该树不为空 
	{
		printf("%d ",T-&gt;data[index].weight);//输出权值 
		preOrder(T,T-&gt;data[index].lchild);//递归,遍历左子树 
		preOrder(T,T-&gt;data[index].rchild);//递归,遍历右子树 
	}
}</code></pre> 
<h3> 7.主函数</h3> 
<pre><code class="language-cpp">int main()
{
	int weight[4]={1,2,3,4};//定义权值数组 
	HFTree *T = initTree(weight,4);//初始化哈夫曼树
	int *res = selectMin(T);//接收两个最小的权值的下标 
	printf("%d,%d\n",res[0],res[1]); 
	creatHFTree(T);//创建哈夫曼树 
	preOrder(T,T-&gt;length-1);//前序遍历哈夫曼树 
	return 0;
} </code></pre> 
<h2>完整代码如下:</h2> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
/*树中结点的结构体*/
typedef struct TreeNode
{
	int weight;//权值 
	int parent;//父结点 
	int lchild;//左孩子 
	int rchild;//右孩子 
}TreeNode;
/*哈夫曼树的结构体*/
typedef struct HFTree
{
	TreeNode *data;//数据域 
	int length;//长度(结点个数) 
}HFTree;
/*初始化哈夫曼树*/
HFTree *initTree(int *weight,int length)
{/*参数一:权值数组
参数二:数组长度*/
	HFTree *T = (HFTree *)malloc(sizeof(HFTree));//申请一颗树的空间 
	T-&gt;data = (TreeNode *)malloc(sizeof(TreeNode)*(2*length-1));//申请一个结点的空间,长度由数组长度确定 
	T-&gt;length = length;//长度写入 
	int i;
	for(i=0;i&lt;length;i++)
	{/*按序一次写入权值,父结点初始为0,左右孩子初始为-1*/
		T-&gt;data[i].weight = weight[i];
		T-&gt;data[i].parent = 0;
		T-&gt;data[i].rchild = -1;
		T-&gt;data[i].lchild = -1;
	}
	return T;
}
/*挑选最小权值的两个结点下标*/ 
int *selectMin(HFTree *T)
{
	int min = 10000;//第一小 
	int secondMin = 10000;//第二小 
	int minIndex;//第一小的下标 
	int i;
	int secondIndex;//第二小的下标 
	for(i=0;i&lt;T-&gt;length;i++)
	{/*挨个比对,遇到小的写入min,并把下标写入minIndex*/
		if(T-&gt;data[i].parent==0)
		{
			if(T-&gt;data[i].weight&lt;min)
			{
				min = T-&gt;data[i].weight;
				minIndex = i;
			}
		}
	}
	for(i=0;i&lt;T-&gt;length;i++)
	{/*挨个对比,遇到小的,并且下标不等于第一小的下标,写入seconMin,并把下标写入secondIndex*/
		if(T-&gt;data[i].parent==0&amp;&amp;i!=minIndex)
		{
			if(T-&gt;data[i].weight&lt;secondMin)
			{
				secondMin = T-&gt;data[i].weight;
				secondIndex = i;
			}
		}
	}
	int *res = (int *)malloc(sizeof(int)*2);//由于要传两个参数,因此申请大小为2的内存空间 
	res[0] = minIndex;//写入第一小的下标 
	res[1] = secondIndex;//写入第二小的下标 
	return res;//返回指针 
}
/*创建哈夫曼树*/
void creatHFTree(HFTree *T)
{
	int *res;//用以接收selectMin()函数的两个参数 
	int min;//权值第一小的下标 
	int secondMin;//权值第二小的下标 
	int i;
	int length = T-&gt;length*2-1;//叶子结点数目n则总结点数目2n-1 
	for(i=T-&gt;length;i&lt;length;i++)
	{
		res = selectMin(T);//接收两个最小权值的下标 
		min = res[0];//第一小赋值给min 
		secondMin = res[1];//第二小赋值给seconMin 
		T-&gt;data[i].weight = T-&gt;data[min].weight+T-&gt;data[secondMin].weight;//连个最小的结点相加 
		T-&gt;data[i].lchild = min;//父结点的左孩子下标为min 
		T-&gt;data[i].rchild = secondMin;//父结点的右孩子下标为secondMin 
		T-&gt;data[i].parent = 0;//该父结点的父结点暂时没有,设为0 
		T-&gt;data[min].parent = i;//左孩子的父结点为i 
		T-&gt;data[secondMin].parent = i;//右孩子的父结点为i 
		T-&gt;length++;//树的结点数加一(长度加一) 
	}
}
/*前序遍历*/
void preOrder(HFTree *T,int index)
{/*参数一:哈夫曼树的结构体
参数二:树的下标*/
	if(index!=-1)//index!=-1表示该树不为空 
	{
		printf("%d ",T-&gt;data[index].weight);//输出权值 
		preOrder(T,T-&gt;data[index].lchild);//递归,遍历左子树 
		preOrder(T,T-&gt;data[index].rchild);//递归,遍历右子树 
	}
}
int main()
{
	int weight[4]={1,2,3,4};//定义权值数组 
	HFTree *T = initTree(weight,4);//初始化哈夫曼树
	int *res = selectMin(T);//接收两个最小的权值的下标 
	printf("%d,%d\n",res[0],res[1]); 
	creatHFTree(T);//创建哈夫曼树 
	preOrder(T,T-&gt;length-1);//前序遍历哈夫曼树 
	return 0;
} </code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f14ae437ce13e829c2bc4dd8f3eb081e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">是德科技keysight E8257D信号发生器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8cdc4517eeec904eaffef316ad30d26f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在 SQL 中计算总行数的百分比</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>