<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】预处理&amp;&amp;编译链接&amp;&amp;调试技巧详解 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/669a05b18da24116f8d6e2bb09d8e39e/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【C语言】预处理&amp;&amp;编译链接&amp;&amp;调试技巧详解">
  <meta property="og:description" content="主页：醋溜马桶圈-CSDN博客
专栏：C语言_醋溜马桶圈的博客-CSDN博客
gitee：mnxcc (mnxcc) - Gitee.com
目录
1.预处理
1.1 预定义符号
1.2 #define
1.2.1 #define 定义标识符
1.2.2 #define 定义宏
1.2.3 #define 替换规则
1.2.4 #和##
1.2.4.1 # 的作用
1.2.4.2 ## 的作用 1.2.5 带有副作用的宏参数
1.2.6 宏和函数的对比 对比
1.2.7 内联函数 1.2.8 命名约定 1.3 #undef
1.4 命令行定义 1.5 条件编译
1.5.1 常见的条件编译指令
1.6 头文件包含
1.6.1 头文件被包含的方式
1.6.2 嵌套文件的包含
2.程序环境 编译和链接
2.1 翻译环境和执行环境
2.2 编译和链接
2.3 翻译
2.3.1 翻译的几个阶段
2.3.1.1 预编译
2.3.1.2 编译
词法分析
符号汇总
2.3.1.3 汇编">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-23T18:41:54+08:00">
    <meta property="article:modified_time" content="2024-03-23T18:41:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】预处理&amp;&amp;编译链接&amp;&amp;调试技巧详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#38d8f0;"><strong>主页：</strong></span><a href="https://blog.csdn.net/m0_74722801?spm=1011.2266.3001.5343" title="醋溜马桶圈-CSDN博客">醋溜马桶圈-CSDN博客</a></p> 
 <p><span style="color:#ff9900;"><strong>专栏：</strong></span><a href="https://blog.csdn.net/m0_74722801/category_12396525.html?spm=1001.2014.3001.5482" title="C语言_醋溜马桶圈的博客-CSDN博客">C语言_醋溜马桶圈的博客-CSDN博客</a></p> 
 <p><span style="color:#fe2c24;"><strong>gitee：</strong></span><a href="https://gitee.com/mnxcc" rel="nofollow" title="mnxcc (mnxcc) - Gitee.com">mnxcc (mnxcc) - Gitee.com</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E9%A2%84%E5%A4%84%E7%90%86-toc" style="margin-left:0px;"><a href="#1.%E9%A2%84%E5%A4%84%E7%90%86" rel="nofollow">1.预处理</a></p> 
<p id="1.%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7-toc" style="margin-left:40px;"><a href="#1.%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7" rel="nofollow">1.1 预定义符号</a></p> 
<p id="2.%23define-toc" style="margin-left:40px;"><a href="#2.%23define" rel="nofollow">1.2 #define</a></p> 
<p id="2.1%23define%20%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6-toc" style="margin-left:80px;"><a href="#2.1%23define%20%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6" rel="nofollow">1.2.1 #define 定义标识符</a></p> 
<p id="2.2%23define%20%E5%AE%9A%E4%B9%89%E5%AE%8F-toc" style="margin-left:80px;"><a href="#2.2%23define%20%E5%AE%9A%E4%B9%89%E5%AE%8F" rel="nofollow">1.2.2 #define 定义宏</a></p> 
<p id="2.3%23define%20%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99-toc" style="margin-left:80px;"><a href="#2.3%23define%20%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99" rel="nofollow">1.2.3 #define 替换规则</a></p> 
<p id="2.4%23%E5%92%8C%23%23-toc" style="margin-left:80px;"><a href="#2.4%23%E5%92%8C%23%23" rel="nofollow">1.2.4 #和##</a></p> 
<p id="2.4.1%23%20%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:120px;"><a href="#2.4.1%23%20%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">1.2.4.1 # 的作用</a></p> 
<p id="2.4.2%23%23%20%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0-toc" style="margin-left:120px;"><a href="#2.4.2%23%23%20%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0" rel="nofollow">1.2.4.2 ## 的作用 </a></p> 
<p id="2.5%20%E5%B8%A6%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%AE%8F%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.5%20%E5%B8%A6%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%AE%8F%E5%8F%82%E6%95%B0" rel="nofollow">1.2.5 带有副作用的宏参数</a></p> 
<p id="2.6%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0-toc" style="margin-left:80px;"><a href="#2.6%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0" rel="nofollow">1.2.6 宏和函数的对比 </a></p> 
<p id="%E5%AF%B9%E6%AF%94-toc" style="margin-left:120px;"><a href="#%E5%AF%B9%E6%AF%94" rel="nofollow">对比</a></p> 
<p id="**2.7%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:80px;"><a href="#**2.7%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">1.2.7 内联函数 </a></p> 
<p id="2.8%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%C2%A0-toc" style="margin-left:80px;"><a href="#2.8%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%C2%A0" rel="nofollow">1.2.8 命名约定 </a></p> 
<p id="3.%23undef-toc" style="margin-left:40px;"><a href="#3.%23undef" rel="nofollow">1.3 #undef</a></p> 
<p id="**4.%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9A%E4%B9%89%C2%A0-toc" style="margin-left:40px;"><a href="#**4.%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9A%E4%B9%89%C2%A0" rel="nofollow">1.4 命令行定义 </a></p> 
<p id="5.%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91-toc" style="margin-left:40px;"><a href="#5.%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91" rel="nofollow">1.5 条件编译</a></p> 
<p id="%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4" rel="nofollow">1.5.1 常见的条件编译指令</a></p> 
<p id="6.%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-toc" style="margin-left:40px;"><a href="#6.%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB" rel="nofollow">1.6 头文件包含</a></p> 
<p id="6.1%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A2%AB%E5%8C%85%E5%90%AB%E7%9A%84%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#6.1%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A2%AB%E5%8C%85%E5%90%AB%E7%9A%84%E6%96%B9%E5%BC%8F" rel="nofollow">1.6.1 头文件被包含的方式</a></p> 
<p id="6.2%E5%B5%8C%E5%A5%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB-toc" style="margin-left:80px;"><a href="#6.2%E5%B5%8C%E5%A5%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB" rel="nofollow">1.6.2 嵌套文件的包含</a></p> 
<p id="2.%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83%20%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5-toc" style="margin-left:0px;"><a href="#2.%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83%20%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5" rel="nofollow">2.程序环境 编译和链接</a></p> 
<p id="1.%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83%E5%92%8C%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83-toc" style="margin-left:40px;"><a href="#1.%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83%E5%92%8C%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83" rel="nofollow">2.1 翻译环境和执行环境</a></p> 
<p id="2.%E8%AF%A6%E8%A7%A3C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#2.%E8%AF%A6%E8%A7%A3C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5" rel="nofollow">2.2 编译和链接</a></p> 
<p id="2.1%E7%BF%BB%E8%AF%91%E7%8E%AF%E9%95%9C-toc" style="margin-left:40px;"><a href="#2.1%E7%BF%BB%E8%AF%91%E7%8E%AF%E9%95%9C" rel="nofollow">2.3 翻译</a></p> 
<p id="2.2%E7%BF%BB%E8%AF%91%E7%9A%84%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5-toc" style="margin-left:80px;"><a href="#2.2%E7%BF%BB%E8%AF%91%E7%9A%84%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5" rel="nofollow">2.3.1 翻译的几个阶段</a></p> 
<p id="2.2.1%E9%A2%84%E7%BC%96%E8%AF%91-toc" style="margin-left:120px;"><a href="#2.2.1%E9%A2%84%E7%BC%96%E8%AF%91" rel="nofollow">2.3.1.1 预编译</a></p> 
<p id="2.2.2%E7%BC%96%E8%AF%91-toc" style="margin-left:120px;"><a href="#2.2.2%E7%BC%96%E8%AF%91" rel="nofollow">2.3.1.2 编译</a></p> 
<p id="%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:160px;"><a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">词法分析</a></p> 
<p id="%E7%AC%A6%E5%8F%B7%E6%B1%87%E6%80%BB-toc" style="margin-left:160px;"><a href="#%E7%AC%A6%E5%8F%B7%E6%B1%87%E6%80%BB" rel="nofollow">符号汇总</a></p> 
<p id="2.2.3%E6%B1%87%E7%BC%96-toc" style="margin-left:120px;"><a href="#2.2.3%E6%B1%87%E7%BC%96" rel="nofollow">2.3.1.3 汇编</a></p> 
<p id="%E7%94%9F%E6%88%90%E7%AC%A6%E5%8F%B7%E8%A1%A8-toc" style="margin-left:160px;"><a href="#%E7%94%9F%E6%88%90%E7%AC%A6%E5%8F%B7%E8%A1%A8" rel="nofollow">生成符号表</a></p> 
<p id="2.3%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#2.3%E9%93%BE%E6%8E%A5" rel="nofollow">2.4 链接</a></p> 
<p id="1.%E5%90%88%E5%B9%B6%E6%AE%B5%E8%A1%A8-toc" style="margin-left:80px;"><a href="#1.%E5%90%88%E5%B9%B6%E6%AE%B5%E8%A1%A8" rel="nofollow">2.4.1 合并段表</a></p> 
<p id="2.%E5%90%88%E5%B9%B6%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E9%87%8D%E5%AE%9A%E4%BD%8D-toc" style="margin-left:80px;"><a href="#2.%E5%90%88%E5%B9%B6%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E9%87%8D%E5%AE%9A%E4%BD%8D" rel="nofollow"> 2.4.2 合并符号表和重定位</a></p> 
<p id="2.4%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83-toc" style="margin-left:40px;"><a href="#2.4%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83" rel="nofollow">2.5 运行</a></p> 
<p id="3.%E5%AE%9E%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%C2%A0-toc" style="margin-left:0px;"><a href="#3.%E5%AE%9E%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%C2%A0" rel="nofollow">3.实用调试技巧 </a></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AFbug%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AFbug%EF%BC%9F" rel="nofollow">3.1 什么是bug？</a></p> 
<p id="2.%E8%B0%83%E8%AF%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%A4%9A%E9%87%8D%E8%A6%81%EF%BC%9F-toc" style="margin-left:40px;"><a href="#2.%E8%B0%83%E8%AF%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%A4%9A%E9%87%8D%E8%A6%81%EF%BC%9F" rel="nofollow">3.2 调试是什么？有多重要？</a></p> 
<p id="2.2%20%E8%B0%83%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#2.2%20%E8%B0%83%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4" rel="nofollow">3.3 调试的基本步骤</a></p> 
<p id="3.debug%E5%92%8Crelease%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#3.debug%E5%92%8Crelease%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">3.4 debug和release的介绍</a></p> 
<p id="4.windows%E7%8E%AF%E5%A2%83%E8%B0%83%E8%AF%95%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#4.windows%E7%8E%AF%E5%A2%83%E8%B0%83%E8%AF%95%E4%BB%8B%E7%BB%8D" rel="nofollow">3.5 windows环境调试介绍</a></p> 
<p id="4.1%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E5%87%86%E5%A4%87-toc" style="margin-left:80px;"><a href="#4.1%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E5%87%86%E5%A4%87" rel="nofollow">3.5.1 调试环境的准备</a></p> 
<p id="4.2%E5%AD%A6%E4%BC%9A%E5%BF%AB%E6%8D%B7%E9%94%AE-toc" style="margin-left:80px;"><a href="#4.2%E5%AD%A6%E4%BC%9A%E5%BF%AB%E6%8D%B7%E9%94%AE" rel="nofollow">3.5.2 学会快捷键</a></p> 
<p id="4.3%E8%B0%83%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E5%BD%93%E5%89%8D%E4%BF%A1%E6%81%AF%C2%A0-toc" style="margin-left:80px;"><a href="#4.3%E8%B0%83%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E5%BD%93%E5%89%8D%E4%BF%A1%E6%81%AF%C2%A0" rel="nofollow">3.5.3 调试的时候查看程序当前信息 </a></p> 
<p id="1.%E6%9F%A5%E7%9C%8B%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC-toc" style="margin-left:120px;"><a href="#1.%E6%9F%A5%E7%9C%8B%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC" rel="nofollow">3.5.3.1 查看临时变量的值</a></p> 
<p id="2.%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF-toc" style="margin-left:120px;"><a href="#2.%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF" rel="nofollow">3.5.3.2 查看内存信息</a></p> 
<p id="3.%E6%9F%A5%E7%9C%8B%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88-toc" style="margin-left:120px;"><a href="#3.%E6%9F%A5%E7%9C%8B%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88" rel="nofollow">3.5.3.3 查看调用堆栈</a></p> 
<p id="4.%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BF%A1%E6%81%AF-toc" style="margin-left:120px;"><a href="#4.%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BF%A1%E6%81%AF" rel="nofollow">3.5.3.4 查看汇编信息</a></p> 
<p id="5.%E6%9F%A5%E7%9C%8B%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%A1%E6%81%AF-toc" style="margin-left:120px;"><a href="#5.%E6%9F%A5%E7%9C%8B%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%A1%E6%81%AF" rel="nofollow">3.5.3.5 查看寄存器信息</a></p> 
<p id="6.%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E5%A5%BD%EF%BC%88%E6%98%93%E4%BA%8E%E8%B0%83%E8%AF%95%EF%BC%89%E7%9A%84%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#6.%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E5%A5%BD%EF%BC%88%E6%98%93%E4%BA%8E%E8%B0%83%E8%AF%95%EF%BC%89%E7%9A%84%E4%BB%A3%E7%A0%81" rel="nofollow">3.6 如何写出好（易于调试）的代码</a></p> 
<p id="%C2%A0%E5%B8%B8%E8%A7%81%E7%9A%84coding%E6%8A%80%E5%B7%A7-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%B8%B8%E8%A7%81%E7%9A%84coding%E6%8A%80%E5%B7%A7" rel="nofollow">3.6.1 常见的coding技巧</a></p> 
<p id="assert-toc" style="margin-left:120px;"><a href="#assert" rel="nofollow">3.6.1.1 assert</a></p> 
<p id="const-toc" style="margin-left:120px;"><a href="#const" rel="nofollow">3.6.1.2 const</a></p> 
<p id="%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88-toc" style="margin-left:160px;"><a href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88" rel="nofollow">常量指针</a></p> 
<p id="%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F-toc" style="margin-left:160px;"><a href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F" rel="nofollow">指针常量</a></p> 
<p id="%E5%8C%BA%E5%88%86%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%C2%A0-toc" style="margin-left:160px;"><a href="#%E5%8C%BA%E5%88%86%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%C2%A0" rel="nofollow">区分常量指针和指针常量 </a></p> 
<p id="7.%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF-toc" style="margin-left:40px;"><a href="#7.%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF" rel="nofollow">3.7 编程常见的错误</a></p> 
<p id="7.1%E7%BC%96%E8%AF%91%E5%9E%8B%E9%94%99%E8%AF%AF-toc" style="margin-left:80px;"><a href="#7.1%E7%BC%96%E8%AF%91%E5%9E%8B%E9%94%99%E8%AF%AF" rel="nofollow">3.7.1 编译型错误</a></p> 
<p id="7.2%E9%93%BE%E6%8E%A5%E5%9E%8B%E9%94%99%E8%AF%AF-toc" style="margin-left:80px;"><a href="#7.2%E9%93%BE%E6%8E%A5%E5%9E%8B%E9%94%99%E8%AF%AF" rel="nofollow">3.7.2 链接型错误</a></p> 
<p id="7.3%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF-toc" style="margin-left:80px;"><a href="#7.3%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF" rel="nofollow">3.7.3 运行时错误</a></p> 
<p id="3.8%20%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%C2%A0-toc" style="margin-left:40px;"><a href="#3.8%20%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%C2%A0" rel="nofollow">3.8 编程思维 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E9%A2%84%E5%A4%84%E7%90%86">1.预处理</h2> 
<h3 id="1.%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7">1.1 预定义符号</h3> 
<blockquote> 
 <p><strong>__FILE__          //进行编译的源文件</strong></p> 
 <p><strong>__LINE__         //文件当前的行号</strong></p> 
 <p><strong>__DATE__       //文件被编译的日期</strong></p> 
 <p><strong>__TIME__        //文件被编译的时间</strong></p> 
 <p><strong>__STDC__       //如果编译器遵循ANSI C，其值为1，否则未定义</strong></p> 
</blockquote> 
<p>这些预定义符号都是语言内置的</p> 
<p>举个例子：</p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/2b/f8/Z7NjYwL2_o.png" width="1128"></p> 
<h3 id="2.%23define">1.2 #define</h3> 
<p>#define是一种预处理指令，他有两种用法：</p> 
<ol><li>#define 定义常量（标识符）</li><li>#define 定义宏 </li></ol> 
<h4 id="2.1%23define%20%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6">1.2.1 #define 定义标识符</h4> 
<blockquote> 
 <p>语法：</p> 
 <p><strong>        #define  name  stuff</strong></p> 
</blockquote> 
<p>举个例子：</p> 
<p><img alt="" height="422" src="https://images2.imgbox.com/c6/fc/rvq4t6Ba_o.png" width="1200"></p> 
<p>#define 是完全替换，比如</p> 
<p><img alt="" height="319" src="https://images2.imgbox.com/00/8d/CvY6LL2m_o.png" width="1200"></p> 
<p>所以在定义的时候，为了强调他是一个整体，需要自己带上括号：</p> 
<p><img alt="" height="314" src="https://images2.imgbox.com/c6/64/WcR8XcLy_o.png" width="821"></p> 
<p><strong>注意</strong>：由于是完全替换，在define定义标识符的时候，<strong>不要在最后加   ;  </strong> 否则替换的时候会将  <strong>; </strong> 也替换过去，会导致语法错误</p> 
<h4 id="2.2%23define%20%E5%AE%9A%E4%B9%89%E5%AE%8F">1.2.2 #define 定义宏</h4> 
<blockquote> 
 <p>#define 机制包括了一个规定，允许把<strong>参数替换到文本</strong>中，这种实现通常会被解释为宏（macro）或定义宏（define macro）</p> 
</blockquote> 
<p>下面是宏的声明方式：</p> 
<p>#define name( parament-list ) stuff</p> 
<p>其中的parament-list是一个由逗号隔开的符号表，他们可能出现在stuff中</p> 
<p><strong>注意：</strong></p> 
<p>参数列表的左括号必须与name紧邻</p> 
<p>如果两者之间有任何空白存在，参数列表就会被释解释为stuff的一部分</p> 
<p>如：</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/5f/0f/6MeC3xdS_o.png" width="883"></p> 
<p>#define定义宏也是完全替换，比如：</p> 
<p><img alt="" height="341" src="https://images2.imgbox.com/79/0b/My0WgT0y_o.png" width="945"></p> 
<p>为了防止出现失误，我们在声明的时候需要加上括号：</p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/3f/90/3qh3o9F2_o.png" width="956"></p> 
<p>我们在写宏的时候，如果逻辑需要，我们可以加上足够多的括号来使宏变得完整</p> 
<h4 id="2.3%23define%20%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99">1.2.3 #define 替换规则</h4> 
<p>在程序中扩展#define定义符号和宏时，需要涉及几个步骤</p> 
<ol><li>在调用宏时，首先对参数进行检查，看看是否包含任何<strong>由#define定义的符号</strong>。如果是，他们<strong>首先被替换</strong></li><li>替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换</li><li>最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程</li></ol> 
<p><strong>注意：</strong></p> 
<ol><li>宏参数和#define定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归</li><li>当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索 </li></ol> 
<h4 id="2.4%23%E5%92%8C%23%23">1.2.4 #和##</h4> 
<h5 id="2.4.1%23%20%E7%9A%84%E4%BD%9C%E7%94%A8">1.2.4.1 # 的作用</h5> 
<p><strong>如何把参数插入到字符串中？、</strong></p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/cc/4d/FQDmuu8l_o.png" width="825"></p> 
<p>我们发现字符串是有自动连接的特点的</p> 
<p>假设有这样的代码：</p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/ba/13/bx5VhzLl_o.png" width="916"></p> 
<p>我们如何用宏来实现printf的功能呢，这里我们使用#</p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/4b/be/gBqRrZUH_o.png" width="1064"></p> 
<p>他的替换是周怎么完成的呢 </p> 
<p><img alt="" height="538" src="https://images2.imgbox.com/f5/59/YcAvLGeo_o.png" width="1133"></p> 
<p>这里只有当字符串作为宏参数的时候才可以把字符串放在字符串中</p> 
<p>使用#，<strong>把一个宏参数变成对应的字符串 </strong></p> 
<p>比如：代码中的<strong>#N</strong>会被预处理器处理为：<strong>“N”</strong></p> 
<p>所以<strong>“#N”</strong>即被处理为<strong>““N””</strong></p> 
<h5 id="2.4.2%23%23%20%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0">1.2.4.2 ## 的作用 </h5> 
<blockquote> 
 <p><strong>##可以把位于他两边的符号合成一个符号</strong></p> 
 <p><strong>他允许宏定义从分离的文本片段创建标识符</strong></p> 
</blockquote> 
<p><img alt="" height="274" src="https://images2.imgbox.com/28/fd/Y7frebX6_o.png" width="1172"></p> 
<p>注意：这样的连接必须产生一个合法的标识符，否则其结果就是未定义的</p> 
<h4 id="2.5%20%E5%B8%A6%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%AE%8F%E5%8F%82%E6%95%B0">1.2.5 带有副作用的宏参数</h4> 
<p>当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么在使用这个宏的时候就可能出现危险，导致不可预测的后果。<strong>副作用就是表达式求值的时候出现的有永久性效果</strong></p> 
<blockquote> 
 <p><strong>x+1；//不带副作用</strong></p> 
 <p><strong>x++；//带副作用</strong></p> 
</blockquote> 
<p>MAX宏可以证明具有副作用的参数所引起的问题 </p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/a5/c3/qJdTMCsO_o.png" width="688"></p> 
<p>这段代码输出的结果是什么？</p> 
<p>这里我们得知道预处理之后的结果是什么： </p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/f2/d0/g4cOqqbN_o.png" width="1200">这段代码是证明执行的呢？</p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/6a/ce/GQBFwuY1_o.png" width="1200"></p> 
<h4 id="2.6%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0">1.2.6 宏和函数的对比 </h4> 
<p>宏通常被应用于执行简单的运算</p> 
<p>比如在两个数中找出较大的一个</p> 
<blockquote> 
 <p>#define MAX(a, b) ((a)&gt;(b)?(a):(b))</p> 
</blockquote> 
<p>那为什么不用函数来完成这个任务？</p> 
<p>原因有二：</p> 
<ol><li>用于调用函数和从函数返回的代码可能实际执行这个小型计算工作所需要的时间更多<br><strong>所以宏比函数在程序的规模和速度方面更胜一筹</strong></li><li>更为重要的是函数的参数必须声明为特定的类型<br> 所以函数只能在类型合适的表达式上使用<br><strong>宏是类型无关的</strong></li></ol> 
<p><img alt="" height="330" src="https://images2.imgbox.com/c1/75/sJAXWFt5_o.png" width="812"><strong> 宏的缺点：</strong>当然和函数相比，宏也有劣势的地方：</p> 
<ol><li>每次使用宏的时候，一份宏定义的代码将插入到程序中，除非宏比较短，否则可能大幅度增加程序的长度</li><li>宏是没法调试的</li><li>宏由于类型无关，也就不够严谨</li><li>宏可能会带来运算符优先级的问题，导致过程容易出现错误</li></ol> 
<p> 宏有时候可以做函数做不到的事情，比如：<strong>宏的参数可以出现类型，但是函数做不到</strong></p> 
<p><img alt="" height="293" src="https://images2.imgbox.com/e3/b6/iQDasqsG_o.png" width="941"></p> 
<h5 id="%E5%AF%B9%E6%AF%94">对比</h5> 
<p><img alt="" height="749" src="https://images2.imgbox.com/d7/2c/ADQ6j0ar_o.png" width="720"></p> 
<p><strong>建议：</strong></p> 
<p>如果逻辑比较简单，可以使用宏来实现</p> 
<p>如果计算逻辑比较负责，那么就使用函数实现 </p> 
<h4 id="**2.7%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%C2%A0">1.2.7 内联函数 </h4> 
<p>C99之后，C++引入了内联函数的概念  <strong>inline关键字</strong></p> 
<p>内联函数具有函数和宏的<strong>双重优点：</strong></p> 
<blockquote> 
 <ol><li>内联函数是函数</li><li>内联函数又像宏一样，在调用的地方展开</li></ol> 
</blockquote> 
<h4 id="2.8%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%C2%A0">1.2.8 命名约定 </h4> 
<p>一般来讲函数的宏的使用语法很相似。所以语言本身没法帮我们区分二者</p> 
<p>那我们平时的一个习惯是：</p> 
<blockquote> 
 <ul><li><strong>把宏名全部大写               //MAX</strong></li><li><strong>函数名不要全部大写        //Max</strong></li></ul> 
</blockquote> 
<h3 id="3.%23undef">1.3 #undef</h3> 
<p>这条指令用于<strong>移除一个宏定义</strong></p> 
<p><img alt="" height="566" src="https://images2.imgbox.com/d1/9f/UoB27Smo_o.png" width="1200"></p> 
<h3 id="**4.%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9A%E4%B9%89%C2%A0">1.4 命令行定义 </h3> 
<p>许多C的编译器提供了一种能力，允许在命令行中定义符号，用于启动编译过程</p> 
<p>例如：当我们根据同一个源文件要编译出一个程序的不同版本的时候，这个特性有点用处</p> 
<p>（假定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一 个机器内存大写，我们需要一个数组能够大写。）</p> 
<h3 id="5.%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91">1.5 条件编译</h3> 
<p>在编译一个程序序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的，因为我们有条件编译指令</p> 
<p>条件编译就是：<strong>满足条件就编译，不满足条件就不编译</strong></p> 
<p>比如说：</p> 
<blockquote> 
 <p>调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译</p> 
</blockquote> 
<p><img alt="" height="506" src="https://images2.imgbox.com/62/78/kbOpuJqS_o.png" width="1091"></p> 
<h4 id="%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4">1.5.1 常见的条件编译指令</h4> 
<blockquote> 
 <p><strong>1.<br> #if   常量表达式<br>         //...<br> #endif<br> //常量表达式由预处理器求值<br> 如：<br> #define __DEBUG__ 1<br> #if __DEBUG__<br>         //..<br> #endif</strong></p> 
</blockquote> 
<p>表达式为真则编译，为假则不编译</p> 
<p><img alt="" height="215" src="https://images2.imgbox.com/07/90/alpy8tb2_o.png" width="755"></p> 
<blockquote> 
 <p><strong>2.多个分支的条件编译<br> #if 常量表达式<br>         //...<br> #elif 常量表达式<br>         //...<br> #else<br>         //...<br> #endif</strong></p> 
</blockquote> 
<p>只会选择以一个#if或者#elif执行 </p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/4a/d3/VyDnnomp_o.png" width="875"></p> 
<blockquote> 
 <p><strong>3.判断是否被定义<br> #if defined(symbol)<br> #ifdef symbol<br><br> #if !defined(symbol)<br> #ifndef symbol </strong></p> 
</blockquote> 
<p>判断（symbol）是否被定义过，如果被定义过则执行代码</p> 
<p><img alt="" height="452" src="https://images2.imgbox.com/72/c9/0wO8KF4g_o.png" width="917"></p> 
<p><img alt="" height="399" src="https://images2.imgbox.com/02/30/5kXrQpIq_o.png" width="919"></p> 
<blockquote> 
 <p><strong>4.嵌套指令<br> #if defined(OS_UNIX)<br>         #ifdef OPTION1<br>                 unix_version_option1();<br>         #endif<br>         #ifdef OPTION2<br>                 unix_version_option2();<br>         #endif<br> #elif defined(OS_MSDOS)        <br>         #ifdef OPTION2<br>                 msdos_version_option2();<br>         #endif<br> #endif</strong></p> 
</blockquote> 
<p><strong>注意：#if 与 #endif 是配套使用的，同时出现，同时消失</strong></p> 
<h3 id="6.%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB">1.6 头文件包含</h3> 
<p>我们已经知道，#include 指令可以使另外一个文件被编译，就像它实际出现于 #include 指令的地方一样</p> 
<p>这种替换的方式很简单：</p> 
<p>预处理器先删除这条指令，并用包含文件的内容替换<br> 这样一个源文件被包含10次，那就实际被编译10次</p> 
<h4 id="6.1%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A2%AB%E5%8C%85%E5%90%AB%E7%9A%84%E6%96%B9%E5%BC%8F">1.6.1 头文件被包含的方式</h4> 
<p>头文件的包含一般有两种方式：</p> 
<blockquote> 
 <p>1.包含本地文件（自己的.h文件）<br> #include "xxx.h"（用双引号）</p> 
 <p></p> 
 <p>2.包含标准库中的文件<br> #include &lt;xxx.h&gt; （用尖括号）</p> 
</blockquote> 
<p><strong>查找策略：</strong></p> 
<p>先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件</p> 
<blockquote> 
 <p>#include包括""和&lt;&gt;这两种情况</p> 
 <p><strong>""是在用户工作目录下寻找（用户的工作目录是通过编译器指定的）<br> &lt;&gt;是找系统标准库函数，通过系统环境变量指定系统库目录</strong></p> 
</blockquote> 
<p>如果找不到就提示编译错误</p> 
<h4 id="6.2%E5%B5%8C%E5%A5%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB">1.6.2 嵌套文件的包含</h4> 
<p>如果出现这样的场景</p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/59/14/1qdy8P98_o.png" width="1080"></p> 
<p>comm.h和comm.c是公共模块<br> test1.h和test1.c使用了公共模块<br> test2.h和test2.c使用了公共模块<br> test.h和test.c使用了test1模块和test2模块。<br> 这样最终程序中就会出现<strong>两份comm.h</strong>的内容<br> 这样就造成了文件内容的重复</p> 
<p>我们可以用条件编译解决这个问题</p> 
<p>每个头文件的开头写：</p> 
<blockquote> 
 <p><strong>#ifndef __TEST_H__<br> #define __TEST_H__<br> //头文件的内容<br> #endif  //__TEST_H__</strong></p> 
</blockquote> 
<p>或者 </p> 
<blockquote> 
 <p><strong>#pragma once</strong></p> 
</blockquote> 
<p><img alt="" height="150" src="https://images2.imgbox.com/a0/3a/i0803azk_o.png" width="734"></p> 
<p><strong>就可以避免头文件的重复引入</strong></p> 
<h2 id="2.%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83%20%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><strong>2.程序环境 编译和链接</strong></h2> 
<h3 id="1.%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83%E5%92%8C%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83">2.1 翻译环境和执行环境</h3> 
<p>在ANSI C的任何一种实现环境中，存在两个不同的环境</p> 
<ul><li>第一种是翻译环境，在这个环境中源代码被转换为可执行的机器指令</li><li>第二种是执行环境，它用于实际执行代码</li></ul> 
<p><img alt="" height="547" src="https://images2.imgbox.com/4f/1c/0LyAWPgx_o.png" width="1200"></p> 
<p><img alt="" height="166" src="https://images2.imgbox.com/96/cf/4YfLzICr_o.png" width="911"></p> 
<p></p> 
<h3 id="2.%E8%AF%A6%E8%A7%A3C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5">2.2 编译和链接</h3> 
<p><img alt="" height="583" src="https://images2.imgbox.com/34/6e/Thuvz898_o.png" width="1118"></p> 
<h3 id="2.1%E7%BF%BB%E8%AF%91%E7%8E%AF%E9%95%9C">2.3 翻译</h3> 
<p><img alt="" height="622" src="https://images2.imgbox.com/f1/fc/YyR3vlLX_o.png" width="1069"></p> 
<ul><li>组成一个程序的每个源文件通过编译过程分别抓换成目标代码（object code）</li><li>每个目标文件文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序</li><li>链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也 链接到程序中</li></ul> 
<h4 id="2.2%E7%BF%BB%E8%AF%91%E7%9A%84%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5">2.3.1 翻译的几个阶段</h4> 
<p><img alt="" height="275" src="https://images2.imgbox.com/e4/99/BRDOhT7k_o.png" width="967"></p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/a7/62/EQ8H335A_o.png" width="972"></p> 
<h5 id="2.2.1%E9%A2%84%E7%BC%96%E8%AF%91">2.3.1.1 预编译</h5> 
<p><strong>预编译的过程：</strong></p> 
<ol><li>注释的替换（删除） 注释被替换成一个空格</li><li>头文件的包含  #include &lt; &gt;</li><li>#define 符号的替换</li></ol> 
<p>所有的预处理指令都是在预编译阶段处理的 （文本操作）</p> 
<h5 id="2.2.2%E7%BC%96%E8%AF%91">2.3.1.2 编译</h5> 
<h6 id="%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">词法分析</h6> 
<p>假如有下面一段代码</p> 
<pre><code class="language-cs">array[index] = (index+4)*(2+6) </code></pre> 
<p>将源代码程序输入扫描器，扫描器的任务就是简单的进行<strong>词法分析</strong>，把代码中的字符<strong>分割成一系列的记号</strong>（关键字、标识符、字面量、特殊字符等）</p> 
<p>上面程序进行词法分析后得到了16个记号：</p> 
<p><img alt="" height="651" src="https://images2.imgbox.com/b8/cf/KzHQ8FTr_o.png" width="559"></p> 
<p>生成一棵语法树</p> 
<p><img alt="" height="602" src="https://images2.imgbox.com/92/a8/X6H4Y55I_o.png" width="1200"></p> 
<h6 id="%E7%AC%A6%E5%8F%B7%E6%B1%87%E6%80%BB">符号汇总</h6> 
<p>一个工程中可以包含多个.c文件，如何在一个.c文件中调用另一个.c文件中的函数呢</p> 
<p>这里我们了解一个概念叫做符号汇总</p> 
<p>假设有这样的代码</p> 
<p><img alt="" height="573" src="https://images2.imgbox.com/7b/49/9ksnpaTE_o.png" width="1200"></p> 
<p>进行符号汇总</p> 
<p><img alt="" height="482" src="https://images2.imgbox.com/d4/66/HMIBnWN3_o.png" width="1200"></p> 
<p><strong>注意：符号汇总只能汇总全局变量</strong></p> 
<h5 id="2.2.3%E6%B1%87%E7%BC%96">2.3.1.3 汇编</h5> 
<p>把汇编代码翻译成了二进制的指令，生成了.o文件（目标文件）</p> 
<h6 id="%E7%94%9F%E6%88%90%E7%AC%A6%E5%8F%B7%E8%A1%A8">生成符号表</h6> 
<p>假设给汇总的符号给上地址，生成一个符号表</p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/c1/a2/swADyQok_o.png" width="1200"></p> 
<h3 id="2.3%E9%93%BE%E6%8E%A5">2.4 链接</h3> 
<h4 id="1.%E5%90%88%E5%B9%B6%E6%AE%B5%E8%A1%A8">2.4.1 合并段表</h4> 
<p><img alt="" height="454" src="https://images2.imgbox.com/60/cf/1ekG84GS_o.png" width="1200"></p> 
<h4 id="2.%E5%90%88%E5%B9%B6%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E9%87%8D%E5%AE%9A%E4%BD%8D"> 2.4.2 合并符号表和重定位</h4> 
<p><img alt="" height="465" src="https://images2.imgbox.com/e1/72/w5MYtEA1_o.png" width="1098"></p> 
<h3 id="2.4%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">2.5 运行</h3> 
<p>程序执行的过程：</p> 
<ol><li><strong>程序必须载入内存中。</strong>在有操作系统的环境中：一般这个<strong>由操作系统完成</strong>。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成</li><li><strong>程序的执行便开始。</strong>接着便调用main函数</li><li><strong>开始执行程序代码。</strong>这个时候程序将使用一个<strong>运行时堆栈（stack）</strong>，存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程中一直保留他们的值</li><li><strong>终止程序。</strong>正常终止main函数；也有可能是意外终止</li></ol> 
<h2 id="3.%E5%AE%9E%E7%94%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%C2%A0">3.实用调试技巧 </h2> 
<h3 id="1.%E4%BB%80%E4%B9%88%E6%98%AFbug%EF%BC%9F">3.1 什么是bug？</h3> 
<p>作为程序员，每天被bug支配着，当然应该了解下对手了。</p> 
<p>bug原意本来为昆虫的意思，1947年9月9日，葛丽丝·霍普（Grace Hopper）发现了第一个电脑上的bug。当在Mark II计算机上工作时，整个团队都搞不清楚为什么电脑不能正常运作了。经过大家的深度挖掘，发现原来是一只飞蛾意外飞入了一台电脑内部而引起的故障（如图所示）。这个团队把错误解除了，并在日记本中记录下了这一事件。也因此，人们逐渐开始用“bug”来称呼计算机中的隐错。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/6b/72/JnpI2i4x_o.png"></p> 
<h3 id="2.%E8%B0%83%E8%AF%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%A4%9A%E9%87%8D%E8%A6%81%EF%BC%9F">3.2 调试是什么？有多重要？</h3> 
<p>所有发生的事情都一定有迹可循，如果问心无愧，就不需要掩盖也就没有迹象了；如果问心有愧，就必然需要掩盖，那就一定会有迹象，<strong>迹象越多就越容易顺藤而上，这就是推理的途径</strong></p> 
<p>顺着这条途径顺流而下就是犯罪，逆流而上就是真相</p> 
<p><strong>一名优秀的程序员是一名出色的侦探</strong></p> 
<p>每一次尝试都是尝试破案的过程</p> 
<p><strong>调试</strong>（英语：Debugging / Debug），又称除错，是发现和减少计算机程序或电子仪器设备中程序</p> 
<p>错误的一个过程。</p> 
<h3 id="2.2%20%E8%B0%83%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4">3.3 调试的基本步骤</h3> 
<ul><li>发现程序错误的存在</li><li>以<strong>隔离、消除</strong>等方式对错误进行<strong>定位 </strong></li><li>确定错误产生的原因</li><li>提出纠正错误的解决办法</li><li>对程序错误予以改正，重新测试</li></ul> 
<p>发现程序错误：程序员自己、测试人员、用户 </p> 
<h3 id="3.debug%E5%92%8Crelease%E7%9A%84%E4%BB%8B%E7%BB%8D">3.4 debug和release的介绍</h3> 
<ul><li><strong>Debug 通常称为调试版本</strong>，它包含调试信息，并且不作任何优化，便于程序员调试程序</li><li><strong>Release 称为发布版本</strong>，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用</li></ul> 
<p>测试人员站在用户的角度，测试的是发布版本 </p> 
<p><strong>代码：</strong></p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
 char *p = "hello world";
 printf("%s\n", p);
 return 0;
}</code></pre> 
<p>上述代码在<strong>Debug</strong>环境的结果展示</p> 
<p><img alt="" height="1029" src="https://images2.imgbox.com/9b/3f/gC6hjGeZ_o.png" width="1200"></p> 
<p>上述代码在<strong>Release</strong>环境的结果展示</p> 
<p><img alt="" height="1029" src="https://images2.imgbox.com/42/7c/HaT2vlIy_o.png" width="1200"></p> 
<p>Debug和Release<strong>反汇编</strong>展示对比</p> 
<p><img alt="" height="1029" src="https://images2.imgbox.com/10/64/F15aLrPW_o.png" width="1200"></p> 
<p><img alt="" height="1029" src="https://images2.imgbox.com/3a/c0/aNnRvGXB_o.png" width="1200"></p> 
<p>所以我们说调试就是在<strong>Debug</strong><strong>版本</strong>的环境中，找代码中<strong>潜伏的问题</strong>的一个过程</p> 
<p>那编译器进行了哪些优化呢？ 请看如下代码：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
    int i = 0;
    int arr[10] = {0};
    for(i=0; i&lt;=12; i++)
   {
        arr[i] = 0;
        printf("hehe\n");
   }
    return 0;
}</code></pre> 
<p>如果是 debug 模式去编译，程序的结果是死循环。</p> 
<p>如果是 release 模式去编译，程序没有死循环。</p> 
<p>那他们之间有什么区别呢？</p> 
<p>就是因为优化导致的</p> 
<h3 id="4.windows%E7%8E%AF%E5%A2%83%E8%B0%83%E8%AF%95%E4%BB%8B%E7%BB%8D">3.5 windows环境调试介绍</h3> 
<h4 id="4.1%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E5%87%86%E5%A4%87">3.5.1 调试环境的准备</h4> 
<p>在环境中选择<strong> </strong><strong>debug</strong> 选项，才能使代码正常调试</p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/b1/3d/Deauy9cR_o.png" width="781"></p> 
<h4 id="4.2%E5%AD%A6%E4%BC%9A%E5%BF%AB%E6%8D%B7%E9%94%AE">3.5.2 学会快捷键</h4> 
<p><strong>最常使用的几个快捷键： </strong></p> 
<p><strong>F5 </strong></p> 
<ul><li>启动调试，经常用来直接跳到下一个断点处</li></ul> 
<p><strong>F9 </strong></p> 
<ul><li>创建断点和取消断点</li><li><strong>断点</strong>的重要作用，可以在程序的任意位置设置断点</li><li>这样就可以使得程序在想要的位置随意停止执行，继而一步步执行下去</li></ul> 
<p><strong>F10 </strong></p> 
<ul><li>逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句</li></ul> 
<p><strong>F11 </strong></p> 
<ul><li>逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑<strong>进入函数内部</strong></li></ul> 
<p><strong>CTRL + F5 </strong></p> 
<ul><li>开始执行不调试，如果你想让程序直接运行起来而不调试就可以直接使用 </li></ul> 
<p>在笔记本电脑上可以配合使用<strong>FN</strong>键 </p> 
<h4 id="4.3%E8%B0%83%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E5%BD%93%E5%89%8D%E4%BF%A1%E6%81%AF%C2%A0">3.5.3 调试的时候查看程序当前信息 </h4> 
<h5 id="1.%E6%9F%A5%E7%9C%8B%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC">3.5.3.1 查看临时变量的值</h5> 
<p>在调试开始之后，用于观察变量的值</p> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/3d/51/kpq8P2Yu_o.png" width="1200"></p> 
<h5 id="2.%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF">3.5.3.2 查看内存信息</h5> 
<p>在调试开始之后，用于观察内存信息</p> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/d9/2f/ouoDzgQb_o.png" width="1200"></p> 
<h5 id="3.%E6%9F%A5%E7%9C%8B%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88">3.5.3.3 查看调用堆栈</h5> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/76/14/G6lmxHjk_o.png" width="1200"></p> 
<p>通过调用堆栈，可以清晰的反映函数的调用关系以及当前调用所处的位置</p> 
<h5 id="4.%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BF%A1%E6%81%AF">3.5.3.4 查看汇编信息</h5> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/91/e3/j9rprMsC_o.png" width="1200"></p> 
<h5 id="5.%E6%9F%A5%E7%9C%8B%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%A1%E6%81%AF">3.5.3.5 查看寄存器信息</h5> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/c8/79/IgVNNXGo_o.png" width="1200"></p> 
<p>可以查看当前运行环境的寄存器的使用信息</p> 
<blockquote> 
 <p id="5.%E5%A4%9A%E5%A4%9A%E5%8A%A8%E6%89%8B%EF%BC%8C%E5%B0%9D%E8%AF%95%E8%B0%83%E8%AF%95%EF%BC%8C%E6%89%8D%E8%83%BD%E8%BF%9B%E6%AD%A5"><strong>多多动手，尝试调试，才能进步</strong></p> 
 <ul><li> 一定要熟练掌握调试技巧</li><li>初学者可能80%的时间在写代码，20%的时间在调试。但是一个程序员可能20%的时间在写程序，但是80%的时间在调试。</li><li><strong>我们所讲的都是一些简单的调试。 </strong></li><li><strong>以后可能会出现很复杂调试场景：多线程程序的调试等</strong></li><li><strong>多多使用快捷键，提升效率</strong> </li></ul> 
</blockquote> 
<h3 id="6.%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E5%A5%BD%EF%BC%88%E6%98%93%E4%BA%8E%E8%B0%83%E8%AF%95%EF%BC%89%E7%9A%84%E4%BB%A3%E7%A0%81">3.6 如何写出好（易于调试）的代码</h3> 
<ol><li>代码运行正常</li><li>bug很少</li><li>效率高</li><li>可读性高</li><li>可维护性高</li><li>注释清晰</li><li>文档齐全</li></ol> 
<h4 id="%C2%A0%E5%B8%B8%E8%A7%81%E7%9A%84coding%E6%8A%80%E5%B7%A7" style="background-color:transparent;">3.6.1 常见的coding技巧</h4> 
<ol><li>使用assert（断言）</li><li>尽量使用const</li><li>养成良好的编码风格</li><li>添加必要的注释</li><li>避免编码的陷阱</li></ol> 
<h5 id="assert">3.6.1.1 assert</h5> 
<p>assert函数是C语言标准库&lt;assert.h&gt;中的一个函数，函数原型为：</p> 
<blockquote> 
 <p>   <strong> void</strong> <strong>assert(int expression)</strong></p> 
</blockquote> 
<p>该函数输入参数只有一个int类型参数，返回值为void类型</p> 
<p><strong>assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行</strong></p> 
<p id="%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><strong>用法总结与注意事项</strong></p> 
<ol><li>在函数开始处检验传入参数的合法性</li><li>每个assert只检验一个条件，因为同时检验多个条件时，如果断言失败，无法直观的判断是哪个条件失败</li><li>不能使用改变环境的语句，因为assert只在Debug中生效，如果这么做，会使用程序在真正运行时遇到问题</li><li>assert和后面的语句应空一行，以形成逻辑和视觉上的一致感</li><li><a name="t8"></a>有的地方，assert不能代替条件过滤</li></ol> 
<h5 id="const">3.6.1.2 const</h5> 
<h6 id="%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88">常量指针</h6> 
<p>常量指针是指针<strong>指向的内容</strong>是常量，可以有以下两种定义方式</p> 
<pre><code class="language-cs">const int* n;

int const* n;</code></pre> 
<p>常量指针说的是<strong>不能通过这个指针改变变量的值</strong>，但是<strong>可以通过其他的引用来改变变量的值</strong></p> 
<pre><code class="language-cs">int a=5;
const int* n=&amp;a;
a=6;</code></pre> 
<p>常量指针指向的值不能改变，但是这并不意味着指针本身不能改变，<strong>常量指针可以指向其他的地址</strong></p> 
<pre><code class="language-cs">int a=5;
int b=6;
const int* n=&amp;a;
n=&amp;b;</code></pre> 
<h6 id="%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F">指针常量</h6> 
<p>指针常量是指<strong>指针本身</strong>是个常量，不能再指向其他的地址，写法如下</p> 
<pre><code class="language-cs">int*const n;</code></pre> 
<p>需要注意的是，指针常量<strong>指向的地址不能改变</strong>，但是地址中<strong>保存的数值是可以改变的</strong>，可以<strong>通过其他指向改地址的指针来修改</strong></p> 
<pre><code class="language-cs">int a=5;
int*p=&amp;a;
int* const n=&amp;a;
*p=8;</code></pre> 
<h6 id="%E5%8C%BA%E5%88%86%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%C2%A0">区分常量指针和指针常量 </h6> 
<p>区分常量指针和指针常量的关键就在于星号（*）的位置，我们以星号为分界线</p> 
<ul><li>如果const在星号的左边，则为常量指针 </li><li>如果const在星号的右边，则为指针常量</li></ul> 
<p>如果我们将星号读作"指针"，将const读作‘常量'的话，内容正好符合。</p> 
<blockquote> 
 <ul><li>int const * n；是常量指针</li><li>int * const n；是指针常量</li></ul> 
</blockquote> 
<h3 id="7.%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF">3.7 编程常见的错误</h3> 
<h4 id="7.1%E7%BC%96%E8%AF%91%E5%9E%8B%E9%94%99%E8%AF%AF">3.7.1 编译型错误</h4> 
<p>直接看错误提示信息（双击），解决问题，或者凭借经验就可以搞定</p> 
<h4 id="7.2%E9%93%BE%E6%8E%A5%E5%9E%8B%E9%94%99%E8%AF%AF">3.7.2 链接型错误</h4> 
<p>看错误提示信息，主要再代码中找到错误信息中的标识符，然后定位问题所在</p> 
<p>一般是<strong>标识符名不存在</strong>或者<strong>拼写错误</strong></p> 
<h4 id="7.3%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF" style="background-color:transparent;">3.7.3 运行时错误</h4> 
<p>借助调试，逐步定位问题</p> 
<h3 id="3.8%20%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%C2%A0" style="background-color:transparent;">3.8 编程思维 </h3> 
<p>作为初学编程的各位小伙伴们，肯定已经或多或少地听说过编程思维这个词了，那么到底什么是编程思维呢</p> 
<p><strong>编程语言</strong></p> 
<p>表面含义，编程就是以各式的编程语言来编译代码，类似于英语，也是一门语言。那么作为语言，英语有诸多的语法，那么编程语言同样有一定的语法。毕竟写出来的代码是需要让机器看懂的。</p> 
<p><strong>编程思维</strong></p> 
<p>那么思维是什么呢，简单说就是做一件事情，脑海里要能够搭建起一个简单的框架，然后再填填补补。构建这个框架的思维就是编程思维，这要求咱们在编程前必须阅读并理解需求，不能只停留在代码的层面，要全局思考，结果会使得代码简洁又高效。</p> 
<p><strong>举例</strong></p> 
<p>For example，这是一段利用C语言写出最简单的逆序输出，显然，很通俗易懂，但是当输入n个内容，这段代码显然不适用了。</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main() {
    int a, b, c, d, e, f, g, h, i, j;
    scanf("%d %d %d %d %d %d %d %d %d %d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;g,&amp;h,&amp;i,&amp;j);
    printf("%d %d %d %d %d %d %d %d %d %d", j, i, h, g, f, e, d, c, b, a);
}</code></pre> 
<p>那么就可以尝试使用下面这段码</p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
int main()
{
    int arr[10] = {0};
    for(int i = 9;i&gt;=0;i--)
    {
        scanf("%d",&amp;arr[i]);
    }
    for(int i = 0;i&lt;10;i++)
    {
        printf("%d ",arr[i]);
    }
    return 0;
}</code></pre> 
<p>显然，这段代码就有了一定的框架结构，这就是编程思维的外在体现。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81e7359e43545df53f4c81965cc719f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构——二叉树-堆(堆的实现，堆排序，TopK问题)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/63875d367be9934ae07c30551b796e85/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Day18:LeedCode 513.找树左下角的值 112. 路径总和 106.从中序与后序遍历序列构造二叉树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>