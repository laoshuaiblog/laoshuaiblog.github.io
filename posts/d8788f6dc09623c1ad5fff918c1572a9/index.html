<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自定义springboot starter - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/d8788f6dc09623c1ad5fff918c1572a9/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="自定义springboot starter">
  <meta property="og:description" content="自定义 springboot starter 上一篇springboot-自动配置原理在最后提了一下，了解了autoConfiguration，离springboot-stater就只差一个demo，好了，最近比较闲，来搞一个demo看看，demo实现了两个功能：
使用Aspectj方式的aop，来实现对某类函数参数监控;定义一个自己的配置类，读取我们在yml或properties里面配置的参数，同时提供一个service，用来获取我们读取的结果。 这里是示例工程starter.
starter 看了自动配置原理之后，应该知道META-INF/spring.facotires这个家伙是配置的重点了吧，我们很多个的东西都是在这个里头。因此，我们自己的stater当然也少不了这个配置文件，先贴个工程结构。
spring-boot-myaop-starter ├─ pom.xml ├─ spring-boot-myaop-starter.iml └─ src/main ├─ java └─ resources └─ META-INF └─ spring.factories AOP部分 先按照正常工程把一些配置都配好，先来写一个AspectJ的。
package com.wt.myaop.aspect; @Aspect @Component public class MyAspect { @Pointcut(&#34;@annotation(myAnno)&#34;) public void myAspectPointCut(MyAopAnnotation myAnno) { } @Before(&#34;myAspectPointCut(myAnno)&#34;) public void performanceTrance2(JoinPoint joinPoint, MyAopAnnotation myAnno) throws Throwable { System.out.println(&#34;--------------myaop-starter args monitor start-----------------&#34;); Object[] args = joinPoint.getArgs(); Class&amp;lt;?&amp;gt;[] types = myAnno.argTypes(); for (int i = 0; i &amp;lt; Math.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-07-30T15:50:00+08:00">
    <meta property="article:modified_time" content="2019-07-30T15:50:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自定义springboot starter</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="content" id="articleContent"> 
 <blockquote> 
  <h2>自定义 springboot starter</h2> 
 </blockquote> 
 <p>上一篇<a href="https://my.oschina.net/wtkid/blog/3079375" rel="nofollow" title="springboot-autoConfiguration">springboot-自动配置原理</a>在最后提了一下，了解了autoConfiguration，离springboot-stater就只差一个demo，好了，最近比较闲，来搞一个demo看看，demo实现了两个功能：</p> 
 <ol><li>使用Aspectj方式的aop，来实现对某类函数参数监控;</li><li>定义一个自己的配置类，读取我们在yml或properties里面配置的参数，同时提供一个service，用来获取我们读取的结果。</li></ol> 
 <p><a href="https://gitee.com/wt123/learn/tree/master/spring-boot-myaop-starter" rel="nofollow" title="示例工程starter">这里是示例工程starter</a>.</p> 
 <h2>starter</h2> 
 <p>看了自动配置原理之后，应该知道META-INF/spring.facotires这个家伙是配置的重点了吧，我们很多个的东西都是在这个里头。因此，我们自己的stater当然也少不了这个配置文件，先贴个工程结构。</p> 
 <pre><code>spring-boot-myaop-starter
├─ pom.xml
├─ spring-boot-myaop-starter.iml
└─ src/main
        ├─ java
        └─ resources
            └─ META-INF
                └─ spring.factories
</code></pre> 
 <h3>AOP部分</h3> 
 <p>先按照正常工程把一些配置都配好，先来写一个AspectJ的。</p> 
 <pre><code class="language-java">package com.wt.myaop.aspect;
@Aspect
@Component
public class MyAspect {

    @Pointcut("@annotation(myAnno)")
    public void myAspectPointCut(MyAopAnnotation myAnno) {
    }

    @Before("myAspectPointCut(myAnno)")
    public void performanceTrance2(JoinPoint joinPoint, MyAopAnnotation myAnno) throws Throwable {
        System.out.println("--------------myaop-starter args monitor start-----------------");
        Object[] args = joinPoint.getArgs();
        Class&lt;?&gt;[] types = myAnno.argTypes();
        for (int i = 0; i &lt; Math.min(args.length, types.length); i++) {
            System.out.println("type:" + types[i] + "&lt;---&gt;arg:" + args[i]);
        }
        System.out.println("--------------myaop-starter args monitor end-----------------");
    }
}
</code></pre> 
 <p>我们这里使用的是<a href="https://my.oschina.net/u/3870904" rel="nofollow">@Before</a>，在这个方法里面获取到所有参数，然后将所有参数的类型和值都打印出来，方法前后输出日志，比较简单。</p> 
 <p>然后来看pointCut，<strong>这是一个基于注解的，这样其他项目引入这个starter的时候就可以直接以注解来使用，对其他项目不具有侵入性</strong>。所以，我们还需要定义一个注解。</p> 
 <pre><code class="language-java">package com.wt.myaop.anno;

@Target(ElementType.METHOD)
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAopAnnotation {
    Class&lt;?&gt;[] argTypes() default {};
}
</code></pre> 
 <p>注解里面有属性，用来定义方法参数的类型顺序，当然也可以不需要，放这里只是为了方便。</p> 
 <h3>属性读取部分</h3> 
 <p><a href="mailto:%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AF%BB%E5%8F%96%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E4%B8%80%E4%B8%AAspringboot%E7%9A%84%E6%B3%A8%E8%A7%A3@ConfigurationProperties.%E6%9D%A5%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E9%85%8D%E7%BD%AE%E7%B1%BB%EF%BC%8C%E4%B8%BA%E4%BA%86%E7%BC%A9%E7%9F%AD%E4%BB%A3%E7%A0%81%E9%95%BF%E5%BA%A6%EF%BC%8C%E9%83%BD%E6%B2%A1%E6%9C%89%E8%B4%B4getter" rel="nofollow">属性的读取我们需要用到一个springboot的注解@ConfigurationProperties.来看看这个配置类，为了缩短代码长度，都没有贴getter</a>/setter方法哦。</p> 
 <pre><code class="language-java">package com.wt.myaop.config;

@ConfigurationProperties(prefix = MyConfig.MY_PREFIX)
public class MyConfig {
    public static final String MY_PREFIX = "myconfig";
    /**
     * 不加该注解也能正常得到值
     */
    @NestedConfigurationProperty
    private UserConfig user;

    private String job;
}
</code></pre> 
 <p><strong>代码中我们定义了一个常量MY_PREFIX，这个是配置文件中的前缀，springboot会读取这个前缀的配置来注入到这个实体当中，当然，配置肯定不会是在我们这个starter项目中来配置，是我们实际使用的project中配置的哦！要不然我还不如直接写死，对吧，嘻嘻</strong>。</p> 
 <p>除了基本属性之外，还提供了一个实体属性，UserConfig。来看看这个东西吧。</p> 
 <pre><code class="language-java">package com.wt.myaop.config;

public class UserConfig {
    private String username;
    private Integer age;
    private String sex;
}
</code></pre> 
 <p>配置信息的接收实体有了，我们现在来定义一个service，这个service的作用就是注入这个实体，然后输出配置信息，以检查我们的配置生效了。service的接口就不贴了哈，只贴实现类了。</p> 
 <pre><code class="language-java">package com.wt.myaop.service;

public class MyConfigServiceImpl implements MyConfigService {
    private final MyConfig myconfig;
    public MyConfigServiceImpl(MyConfig myConfig) {
        this.myconfig = myConfig;
    }
    @Override
    public void printMyConfig() {
        System.out.println(myConfig);
    }
}
</code></pre> 
 <p>看构造方法和属性，构造方法注入了我们的配置，当然，我们如果需要使用这个service，我们就需要手动将这个配置注入进来，以确保service实例化时，myconfig不会为null，里面的方法很简单，仅仅打印了我们的配置类MyConfig。</p> 
 <p>starter像这样就算完了吗？当然没有，可以感受到以上这些其实都跟普通的project的配置没有太多差别，很简单。</p> 
 <p>回忆一下我们自动配置的核心是不是叫xxxAutoConfiguration的东西呢？spring.vactories中的哦！</p> 
 <p>好了，来吧，开始定义我们自己的AutoConfiguration。</p> 
 <pre><code class="language-java">package com.wt.myaop.autoconfig;

@Configuration
@ComponentScan({"com.wt.myaop.aspect"})
@AutoConfigureAfter(AopAutoConfiguration.class)
@EnableConfigurationProperties(MyConfig.class)
public class MyArgsMonitorAopAutoConfig {

    private MyConfig myConfig;

    public MyArgsMonitorAopAutoConfig(MyConfig myConfig) {
        this.myConfig = myConfig;
    }

    @Bean
    public MyConfigService getMyConfigService(){
        return new MyConfigServiceImpl(myConfig);
    }

}
</code></pre> 
 <p>我们现在来研究一下这个类都有什么。</p> 
 <pre><code>@Configuration: 表明这个类是一个配置类;
@ComponentScan: 指出需要扫描的包，可以看到上面扫描的包中包含了Aspect注解的配置，当然使用aop这部分是必不可少的;
@AutoConfigureAfter: 指出当前类需要再某个自动配置完成之后才开始配置;
@EnableConfigurationProperties: 为@ConfigurationProperties注解提供支持，什么意思呢；
	解释一下这个，把@ConfigurationProperties标注的类(MyConfig)注册成bean，以支持依赖注入，本身这些类
	是不会被注册成bean的，当然我们可以在配置类上加@Component注解。使用这个注解可以在我们需要某个配置类
	注册成bean的时候，就使用，侵入性小，避免了配置类上加@Component注解。
</code></pre> 
 <p>从上面代码中可以看到我们的配置类MyConfig通过构造方法被注入到了MyArgsMonitorAopAutoConfig当中，而MyArgsMonitorAopAutoConfig是一个配置类，里面通过@Bean的方式配置了MyConfigService。</p> 
 <p><strong>看起来很简答吧，实际上也很简单，autoConfiguration的配置类就好了，引入这个类，就相当于引入了一个Myconfig的配置类，和一个我们能够使用的MyConfigService</strong>。</p> 
 <p>自动配置的类有了，需要放到spring.factories中才能生效。</p> 
 <pre><code class="language-properties"># META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.wt.myaop.autoconfig.MyArgsMonitorAopAutoConfig
</code></pre> 
 <p>这样starter部分就算是完成了。</p> 
 <blockquote> 
  <p>Tips: 自动配置其实很简单，把需要的配置都放到一个叫做starter的工程里面，然后创建一个XxxAutoConfiguration的自动配置类，把需要的配置都放到这个类里面配置好。最后把这个自动配置类加到META-INF/spring.factories中就行了，是不是很容易，嘻嘻。</p> 
 </blockquote> 
 <h2>demo</h2> 
 <p>demo其实也是使用的之前分析源码那个工程，下面有地址。重点来配置和启动一下我们自己的starter。</p> 
 <p><a href="https://gitee.com/wt123/learn/tree/master/springboot_source_learn" rel="nofollow" title="示例工程demo">这里是示例工程demo</a>.</p> 
 <p>有了starter之后，使用mvn clean install命令将其jar安装到本地。</p> 
 <p>在demo工程中引入这个依赖。</p> 
 <pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.wt.starter&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-myaop-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
 <h3>使用MyConfig配置</h3> 
 <p>我们starter里面有个MyConfig的配置对吧，好了，现在我们可以在yml或者properties文件中来定义了。我这里用的是yml哈。</p> 
 <pre><code class="language-yaml">myconfig:
  job: programer
  user:
    username: wt
    age: 25
    sex: real_man
</code></pre> 
 <p><strong>注意我们的前缀是myconfig，下面的job和user都是实体类MyConfig的属性，因为user是个实体了类，因此下面也列出了它的属性username，age，sex.(可以去前面的MyConfig和UserConfig两个实体的属性进行对比)。</strong></p> 
 <h3>使用参数监控AOP</h3> 
 <p>starter中除了上面的MyConfig之外，还有个aop监控参数的功能，我们马上把它用起来。</p> 
 <p>先定义一个service，接口就不贴了</p> 
 <pre><code class="language-java">@Service
public class MyStarterServiceImpl implements MyStarterService {

    @Override
    @MyAopAnnotation(argTypes = {String.class})
    public void helloStarter(String msg, Long currentTime) {
        System.out.println("----hello starter,msg = " + msg + ",currentTime = " + currentTime);
    }
}
</code></pre> 
 <p>方法加上了注解MyAopAnnotation，为了被starter当中的aop拦截到。</p> 
 <p>再来定义一个controller用来测试。</p> 
 <pre><code class="language-java">@RestController
@RequestMapping("/starter")
public class MyStarterController {

    @Autowired
    private MyConfigService myConfigService;

    @Autowired
    private MyStarterService myStarterService;

    @RequestMapping("/test")
    public Object starter() {
        myConfigService.printMyConfig();
        myStarterService.helloStarter("wt", System.currentTimeMillis());
        return "success";
    }
}
</code></pre> 
 <p>注意区分一下，MyConfigService是我们starter里面的，MyStarterService是我们demo工程里面的。</p> 
 <p>现在启动工程，访问<a href="http://127.0.0.1:8080/starter/test%E8%AF%95%E8%AF%95%EF%BC%81" rel="nofollow">http://127.0.0.1:8080/starter/test试试！</a></p> 
 <p>来看看输出(复制了输出，没有使用截图):</p> 
 <pre><code>MyConfig{user=UserConfig{username='wt', age=25, sex='real_man'}, job='programer'}
------------------myaop-starter args monitor start--------------------
type:class java.lang.String&lt;---&gt;arg:wt
------------------myaop-starter args monitor end--------------------
----hello starter,msg = wt,currentTime = 1564472340205
</code></pre> 
 <p>第一行是 myConfigService.printMyConfig()的输出，他输出了我们的在yml中的配置，这个输出说明了我们的配置被成功赋值给MyConfig了。说明我们的config生效了。</p> 
 <p><a href="mailto:%E7%AC%AC%E4%BA%8C%E8%A1%8C%E5%92%8C%E7%AC%AC%E5%9B%9B%E8%A1%8C%E6%98%AFstarter%E5%BD%93%E4%B8%ADaop%E9%83%A8%E5%88%86@Before%E6%96%B9%E6%B3%95%E7%9A%84%E5%89%8D%E5%90%8E%E8%BE%93%E5%87%BA%EF%BC%8C%E4%B8%AD%E9%97%B4%E7%AC%AC%E4%B8%89%E8%A1%8C%E8%BE%93%E5%87%BA%E4%BA%86%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8BString%E5%92%8C%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BCwt%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E6%B3%A8%E8%A7%A3%E4%B8%8A%E5%8F%AA%E6%8C%87%E5%AE%9A%E4%BA%86%E4%B8%80%E4%B8%AAString.class%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%9C%A8%E8%BF%99%E9%87%8C%E6%B2%A1%E6%9C%89%E6%8A%8A%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B9%9F%E8%BE%93%E5%87%BA%E6%9D%A5%EF%BC%8C%E5%85%B7%E4%BD%93%E9%80%BB%E8%BE%91%E5%B0%B1%E5%8E%BB%E7%9C%8Bstarter%E5%BD%93%E4%B8%ADaop%E7%9A%84%E9%82%A3%E4%B8%AA" rel="nofollow">第二行和第四行是starter当中aop部分@Before方法的前后输出，中间第三行输出了参数类型String和参数的值wt，因为我们注解上只指定了一个String.class，因此在这里没有把第二个参数也输出来，具体逻辑就去看starter当中aop的那个</a>@Before的方法了。</p> 
 <p>最后一行是被加强的方法的输出，打印了msg和currentTime。</p> 
 <p>现在可以来想象一下springboot在yml或properties文件中的Datasource等配置咯！</p> 
 <p>看到这里starter部分就算结束了，总的来讲这个家伙也不难，对吧，嘻嘻。</p> 
 <p>胜利的旗帜在向各位招手，Good Luck！</p> 
 <p>over~~~</p> 
</div> 
<p>转载于:https://my.oschina.net/wtkid/blog/3081202</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/75fb049741dcae09f75c61584bac1a05/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio下的SDK的配置方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c29dea2d6f98bde52d88ac8ed5bb8c8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《流畅的Python》读书笔记——Python一等函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>