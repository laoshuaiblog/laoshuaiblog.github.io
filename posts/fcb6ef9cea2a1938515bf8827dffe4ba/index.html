<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之哈夫曼树（C语言） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/fcb6ef9cea2a1938515bf8827dffe4ba/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="数据结构之哈夫曼树（C语言）">
  <meta property="og:description" content="一、哈夫曼树的概念 给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
该代码的核心在于弄懂如何构建哈夫曼树和生成哈夫曼树编码。主要通过找出两个最小值开始作为最底端叶节点，由下到上构建出哈夫曼树。
二、代码步骤 1、定义二叉树和字符指针数组
2、二叉树的初始化
3、查找最小两个值的下标（min1&amp;lt;min2)
4、构建哈夫曼树
5、生成哈夫曼树编码
6、测试代码
7、程序入口
8、运行结果
三、代码功能 1、定义二叉树和字符指针数组 typedef struct HTNode { double weight; int parent; int lc, rc; }*HuffmanTree; typedef char **HuffmanCode; 2、二叉树的初始化 HuffmanTree initHuffmanTree(HuffmanTree&amp;amp; HT,int n) { int i; int m = 2 * n - 1; HT = (HuffmanTree)malloc(sizeof(HTNode)*(m &#43; 1)); for(i = 0; i &amp;lt;= m; i&#43;&#43;) { HT[i].lc = 0; HT[i].parent = 0; HT[i].rc = 0; HT[i].weight = 0; } return HT; } 3、查找最小两个值的下标（min1&amp;lt;min2) void Select(HuffmanTree&amp;amp; HT, int n, int&amp;amp; min1, int&amp;amp; min2) { int min; for (int i = 1; i &amp;lt;= n; i&#43;&#43;) { if (HT[i].">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-05-29T15:46:08+08:00">
    <meta property="article:modified_time" content="2022-05-29T15:46:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之哈夫曼树（C语言）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E4%B8%80%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">一、哈夫曼树的概念</h2> 
<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p> 
<p>该代码的核心在于弄懂如何构建哈夫曼树和生成哈夫曼树编码。主要通过找出两个最小值开始作为最底端叶节点，由下到上构建出哈夫曼树。</p> 
<p style="text-align:center;"><img alt="" height="487" src="https://images2.imgbox.com/5c/fa/rrbx3Tl9_o.png" width="626"></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E6%AD%A5%E9%AA%A4">二、代码步骤</h2> 
<p id="1%E3%80%81%E5%AE%9A%E4%B9%89%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%AE%9A%E4%B9%89%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" rel="nofollow">1、定义二叉树和字符指针数组</a></p> 
<p id="2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2、二叉树的初始化</a></p> 
<p id="3%E3%80%81%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E4%B8%A4%E4%B8%AA%E5%80%BC%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%88min1%3Cmin2)-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E4%B8%A4%E4%B8%AA%E5%80%BC%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%88min1%3Cmin2%29" rel="nofollow">3、查找最小两个值的下标（min1&lt;min2)</a></p> 
<p id="4%E3%80%81%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91" rel="nofollow">4、构建哈夫曼树</a></p> 
<p id="5%E3%80%81%E7%94%9F%E6%88%90%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E7%94%9F%E6%88%90%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81" rel="nofollow">5、生成哈夫曼树编码</a></p> 
<p id="6%E3%80%81%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81" rel="nofollow">6、测试代码</a></p> 
<p id="7%E3%80%81%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3" rel="nofollow">7、程序入口</a></p> 
<p id="8%E3%80%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-toc" style="margin-left:80px;"><a href="#8%E3%80%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" rel="nofollow">8、运行结果</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%8A%9F%E8%83%BD">三、代码功能</h2> 
<h4 id="1%E3%80%81%E5%AE%9A%E4%B9%89%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">1、定义二叉树和字符指针数组</h4> 
<pre><code>typedef struct HTNode
{
	double weight;
	int parent;
	int lc, rc; 
}*HuffmanTree;

typedef char **HuffmanCode;</code></pre> 
<h4 id="2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">2、二叉树的初始化</h4> 
<pre><code>HuffmanTree initHuffmanTree(HuffmanTree&amp; HT,int n)
{
	int i;
	int m = 2 * n - 1;
	HT = (HuffmanTree)malloc(sizeof(HTNode)*(m + 1));
	for(i = 0; i &lt;= m; i++)
	{
		HT[i].lc = 0;
		HT[i].parent = 0;
		HT[i].rc = 0;
		HT[i].weight = 0;
	}
	return HT;
}</code></pre> 
<h4 id="3%E3%80%81%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E4%B8%A4%E4%B8%AA%E5%80%BC%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%88min1%3Cmin2)">3、查找最小两个值的下标（min1&lt;min2)</h4> 
<pre><code>void Select(HuffmanTree&amp; HT, int n, int&amp; min1, int&amp; min2)
{
	int min;
	for (int i = 1; i &lt;= n; i++)
	{
		if (HT[i].parent == 0)
		{
			min = i;
			break;
		}
	}
	for (int i = min + 1; i &lt;= n; i++)
	{
		if (HT[i].parent == 0 &amp;&amp; HT[i].weight &lt; HT[min].weight)
			min = i;
	}
	min1 = min;
	for (int i = 1; i &lt;= n; i++)
	{
		if (HT[i].parent == 0 &amp;&amp; i != min1)
		{
			min = i;
			break;
		}
	}
	for (int i = min + 1; i &lt;= n; i++)
	{
		if (HT[i].parent == 0 &amp;&amp; HT[i].weight &lt; HT[min].weight&amp;&amp;i != min1)
			min = i;
	}
	min2 = min;
}</code></pre> 
<h4 id="4%E3%80%81%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91">4、构建哈夫曼树</h4> 
<pre><code>void CreateHuff(HuffmanTree&amp; HT,double* w, int n)
{
	int m = 2 * n - 1; 
	for (int i = 1; i &lt;= n; i++)
	{
		HT[i].weight = w[i - 1];
	}
	for (int i = n + 1; i &lt;= m; i++)
	{
		int min1, min2;
		Select(HT, i - 1, min1, min2);
		HT[i].weight = HT[min1].weight + HT[min2].weight; 
		HT[min1].parent = i; 
		HT[min2].parent = i;
		HT[i].lc = min1; 
		HT[i].rc = min2;
	}
	printf("Huffman is: \n");
	printf("subscript    weight     parent   lchild   rchild\n");
	printf("0                                  \n");
	for (int i = 1; i &lt;= m; i++)
	{
	    printf("%-4d         %-6.2lf      %-6d     %-6d   %-6d\n", i, HT[i].weight, HT[i].parent, HT[i].lc, HT[i].rc);
	}
	printf("\n");
}</code></pre> 
<h4 id="5%E3%80%81%E7%94%9F%E6%88%90%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%BC%96%E7%A0%81">5、生成哈夫曼树编码</h4> 
<pre><code>void HuffCoding(HuffmanTree&amp; HT, HuffmanCode&amp; HC, int n)
{
	HC = (HuffmanCode)malloc(sizeof(char*)*(n + 1));
	char* code = (char*)malloc(sizeof(char)*n);
	code[n - 1] = '\0';
	for (int i = 1; i &lt;= n; i++)
	{
		int start = n - 1; 
		int c = i; 
		int p = HT[c].parent; 
		while (p)
		{
			if (HT[p].lc == c) 
				code[--start] = '0';
			else
				code[--start] = '1';
			c = p;
			p = HT[c].parent; 
		}
		HC[i] = (char*)malloc(sizeof(char)*(n - start));
		strcpy(HC[i], &amp;code[start]); 
	}
	free(code);
}</code></pre> 
<h4 id="6%E3%80%81%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">6、测试代码</h4> 
<pre><code>void test()
{
	int n = 0;
	printf("input the number of data: ");
	scanf("%d", &amp;n);
	double* w = (double*)malloc(sizeof(double)*n);
	if (n &gt;= 0)
	{
		printf("input the data: ");
	    for (int i = 0; i &lt; n; i++)
	    {
	    	scanf("%lf", &amp;w[i]);
	    }
    	HuffmanTree HT;
    	HT = initHuffmanTree(HT,n);
    	CreateHuff(HT, w, n); 

    	HuffmanCode HC;
    	HuffCoding(HT, HC, n); 

    	for (int i = 1; i &lt;= n; i++)
    	{
    		printf("The data %.2lf code is:  %s\n", HT[i].weight, HC[i]);
    	}
    	free(w);	
	}
	else
	{
		printf("malloc fail\n");
		return;
	}
}</code></pre> 
<h4 id="7%E3%80%81%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3">7、程序入口</h4> 
<pre><code>int main()
{
	test();
	return 1;
}</code></pre> 
<h4 id="8%E3%80%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">8、运行结果</h4> 
<pre><code>input the number of data: 5
input the data: 0.1 0.2 0.3 0.25 0.15
Huffman is:
subscript    weight     parent   lchild   rchild
0
1            0.10        6          0        0
2            0.20        7          0        0
3            0.30        8          0        0
4            0.25        7          0        0
5            0.15        6          0        0
6            0.25        8          1        5
7            0.45        9          2        4
8            0.55        9          6        3
9            1.00        0          7        8

The data 0.10 code is:  100
The data 0.20 code is:  00
The data 0.30 code is:  11
The data 0.25 code is:  01
The data 0.15 code is:  101</code></pre> 
<h2 id="%E5%9B%9B%E3%80%82%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81">四、整体代码</h2> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;string.h&gt;

typedef struct HTNode
{
	double weight;
	int parent;
	int lc, rc; 
}*HuffmanTree;

typedef char **HuffmanCode;

HuffmanTree initHuffmanTree(HuffmanTree&amp; HT,int n)
{
	int i;
	int m = 2 * n - 1;
	HT = (HuffmanTree)malloc(sizeof(HTNode)*(m + 1));
	for(i = 0; i &lt;= m; i++)
	{
		HT[i].lc = 0;
		HT[i].parent = 0;
		HT[i].rc = 0;
		HT[i].weight = 0;
	}
	return HT;
}

void Select(HuffmanTree&amp; HT, int n, int&amp; min1, int&amp; min2)
{
	int min;
	for (int i = 1; i &lt;= n; i++)
	{
		if (HT[i].parent == 0)
		{
			min = i;
			break;
		}
	}
	for (int i = min + 1; i &lt;= n; i++)
	{
		if (HT[i].parent == 0 &amp;&amp; HT[i].weight &lt; HT[min].weight)
			min = i;
	}
	min1 = min;
	for (int i = 1; i &lt;= n; i++)
	{
		if (HT[i].parent == 0 &amp;&amp; i != min1)
		{
			min = i;
			break;
		}
	}
	for (int i = min + 1; i &lt;= n; i++)
	{
		if (HT[i].parent == 0 &amp;&amp; HT[i].weight &lt; HT[min].weight&amp;&amp;i != min1)
			min = i;
	}
	min2 = min;
}

void CreateHuff(HuffmanTree&amp; HT,double* w, int n)
{
	int m = 2 * n - 1; 
	for (int i = 1; i &lt;= n; i++)
	{
		HT[i].weight = w[i - 1];
	}
	for (int i = n + 1; i &lt;= m; i++)
	{
		int min1, min2;
		Select(HT, i - 1, min1, min2);
		HT[i].weight = HT[min1].weight + HT[min2].weight; 
		HT[min1].parent = i; 
		HT[min2].parent = i;
		HT[i].lc = min1; 
		HT[i].rc = min2;
	}
	printf("Huffman is: \n");
	printf("subscript    weight     parent   lchild   rchild\n");
	printf("0                                  \n");
	for (int i = 1; i &lt;= m; i++)
	{
	    printf("%-4d         %-6.2lf      %-6d     %-6d   %-6d\n", i, HT[i].weight, HT[i].parent, HT[i].lc, HT[i].rc);
	}
	printf("\n");
}

void HuffCoding(HuffmanTree&amp; HT, HuffmanCode&amp; HC, int n)
{
	HC = (HuffmanCode)malloc(sizeof(char*)*(n + 1));
	char* code = (char*)malloc(sizeof(char)*n);
	code[n - 1] = '\0';
	for (int i = 1; i &lt;= n; i++)
	{
		int start = n - 1; 
		int c = i; 
		int p = HT[c].parent; 
		while (p)
		{
			if (HT[p].lc == c) 
				code[--start] = '0';
			else
				code[--start] = '1';
			c = p;
			p = HT[c].parent; 
		}
		HC[i] = (char*)malloc(sizeof(char)*(n - start));
		strcpy(HC[i], &amp;code[start]); 
	}
	free(code);
}

void test()
{
	int n = 0;
	printf("input the number of data: ");
	scanf("%d", &amp;n);
	double* w = (double*)malloc(sizeof(double)*n);
	if (n &gt;= 0)
	{
		printf("input the data: ");
	    for (int i = 0; i &lt; n; i++)
	    {
	    	scanf("%lf", &amp;w[i]);
	    }
    	HuffmanTree HT;
    	HT = initHuffmanTree(HT,n);
    	CreateHuff(HT, w, n); 

    	HuffmanCode HC;
    	HuffCoding(HT, HC, n); 

    	for (int i = 1; i &lt;= n; i++)
    	{
    		printf("The data %.2lf code is:  %s\n", HT[i].weight, HC[i]);
    	}
    	free(w);	
	}
	else
	{
		printf("malloc fail\n");
		return;
	}
}

int main()
{
	test();
	return 1;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/36150dca010cc14b2a5dae9ae3b74f9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Vue】Vue组件或页面中查看当前Vm对象的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d77316d42ee2c52fe4d45f73432ca92/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">牛吃草问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>