<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌入式-C语言-9-Makefile/结构体/联合体 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/6b69606b14ead5008b46435f212e8ccd/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="嵌入式-C语言-9-Makefile/结构体/联合体">
  <meta property="og:description" content="一、Makefile 1.1.问：如果项目产品代码有1万源文件.c,编译极其的繁琐
gcc -o main main.c a.c b.c .... 一个万.c
这么简化程序的编译呢？
答：必须只能利用Makefile来实现
1.2.Makefile功能：能够制定编译规则,将来让gcc编译器根据这个规则来编译程序，Makefile本质就是一个文本文件,此文件给make命令使用，将来make命令会根据Makefile里面的编译规则让gcc编译程序。
1.3.Makefile语法格式：
目标：依赖1 依赖2 依赖3 ....依赖N
(TAB键)编译命令1
(TAB键)编译命令2
...
(TAB键)编译命令N
(TAB键) 还可以是其他命令:ls/cp/cd等
注意：Makefile注释用#
例如：目标是把helloworld.c编译生成helloworld
vim Makfile 添加
#指定规则:一步到位
helloworld:helloworld.c
gcc -o helloworld helloworld.c #或者
#指定规则1：分步
helloworld:helloworld.o
gcc -o helloworld helloworld.o
#指定规则2:
helloworld.o:helloworld.c
gcc -c -o helloworld.o helloword.c
案例：利用Makefile编译helloworld.c文件
vim helloworld.c
vim Makefile
make //编译程序
./helloworld
make //编译提示helloworld是最新的
vim helloworld.c //修改源文件
ls -lh //查看helloworld.c和helloworld的时间戳
make //又重新编译
先检查有没有helloworld文件，如果有，就检查helloworld.c文件的时间戳是不是比他新，如果helloworld.c文件比helloworld文件新，就重新编译，反之不更新，如果没有helloworld文件，就按编译规则来。
1.4.Makefile工作原理">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-02-15T18:24:30+08:00">
    <meta property="article:modified_time" content="2022-02-15T18:24:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式-C语言-9-Makefile/结构体/联合体</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#0d0016;">一、Makefile</span></strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;">1.1.问：如果项目产品代码有1万源文件.c,编译极其的繁琐</p> 
<p style="margin-left:.0001pt;text-align:justify;">             gcc -o main main.c a.c b.c .... 一个万.c</p> 
<p style="margin-left:.0001pt;text-align:justify;">             这么简化程序的编译呢？</p> 
<p style="margin-left:.0001pt;text-align:justify;">      答：必须只能利用Makefile来实现</p> 
<p style="margin-left:.0001pt;text-align:justify;">1.2.Makefile功能：<span style="color:#ff0000;">能够制定编译规则</span><span style="color:#fe2c24;">,将来让gcc编译器根据这个规则来编译程序，<strong><strong>Makefile本质就是一个文本文件</strong></strong>,此文件给make命令使用，将来</span><span style="color:#ff0000;">make命令会根据Makefile里面的编译规则让gcc编译程序。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">1.3.Makefile语法格式：</p> 
<p style="margin-left:.0001pt;text-align:justify;">      目标：依赖1  依赖2 依赖3 ....依赖N</p> 
<p style="margin-left:.0001pt;text-align:justify;">      (TAB键)编译命令1</p> 
<p style="margin-left:.0001pt;text-align:justify;">      (TAB键)编译命令2</p> 
<p style="margin-left:.0001pt;text-align:justify;">      ...</p> 
<p style="margin-left:.0001pt;text-align:justify;">      (TAB键)编译命令N</p> 
<p style="margin-left:.0001pt;text-align:justify;">      (TAB键) 还可以是其他命令:ls/cp/cd等</p> 
<p style="margin-left:.0001pt;text-align:justify;">      注意：<span style="color:#ff0000;">Makefile注释用#</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">      例如：<span style="color:#ff0000;">目标是把helloworld.c编译生成helloworld</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">      vim Makfile 添加</p> 
<p style="margin-left:.0001pt;text-align:justify;">     <span style="color:#ff0000;"> #指定规则:一步到位</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">      helloworld:helloworld.c</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">gcc -o helloworld helloworld.c</span> </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">      #或者</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">      #指定规则1：分步</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">      helloworld:helloworld.o</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">gcc -o helloworld helloworld.o</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">      #指定规则2:</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">      helloworld.o:helloworld.c</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">gcc -c -o helloworld.o helloword.c</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">      案例：利用Makefile编译helloworld.c文件</p> 
<p style="margin-left:.0001pt;text-align:justify;">      vim helloworld.c</p> 
<p style="margin-left:.0001pt;text-align:justify;">      vim Makefile</p> 
<p style="margin-left:.0001pt;text-align:justify;">      make   //编译程序</p> 
<p style="margin-left:.0001pt;text-align:justify;">      ./helloworld</p> 
<p style="margin-left:.0001pt;text-align:justify;">      make //编译提示helloworld是最新的</p> 
<p style="margin-left:.0001pt;text-align:justify;">     vim helloworld.c //修改源文件</p> 
<p style="margin-left:.0001pt;text-align:justify;">     ls -lh //查看helloworld.c和helloworld的时间戳</p> 
<p style="margin-left:.0001pt;text-align:justify;">     make //又重新编译</p> 
<p style="text-align:center;"><img alt="" height="162" src="https://images2.imgbox.com/03/cc/brXn1wcW_o.png" width="520"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">先检查有没有helloworld文件，如果有，就检查helloworld.c文件的时间戳是不是比他新，如果helloworld.c文件比helloworld文件新，就重新编译，反之不更新，如果没有helloworld文件，就按编译规则来。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">1.4.Makefile工作原理</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">当执行make命令时,make命令首先在当前目录下找Makefile,一旦找到Makfile文件,打开此文件并且找到所有的编译规则,通过这些编译规则确定了最终的目标是helloworld和源文件helloworld.c,然后make命令首先在当前目录下找是否存在目标文件helloworld,如果helloworld存在,然后检查helloworld和helloworld.c的时间戳哪个更新,如果helloworld的时间戳比helloworld.c新,说明源文件没有改过,无需编译,提示文件最新,如果helloworld的时间戳比helloworld.c要旧，说明helloworld.c修改过,根据编译规则的命令重新编译，如果一开始没有找到helloworld,程序整个重新编译</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">1.5.Makefile小技巧</p> 
<p style="margin-left:.0001pt;text-align:justify;">      <span style="color:#ff0000;">%.o:%.c</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">      (TAB键)gcc </span> <span style="color:#ff0000;">-c </span> <span style="color:#ff0000;">-o </span> <span style="color:#ff0000;">$@</span> <span style="color:#ff0000;"> $&lt;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">      说明：</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#ff0000;">  %.o:目标文件.o</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">      %.c:源文件.c</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">      $@:目标文件</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">      $&lt;:源文件</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">      <strong><span style="color:#ff0000;"><strong>作用是将当前目录下所有的.c文件单独编译生成对应的.o目标文件</strong></span></strong></p> 
<h2 style="margin-left:.0001pt;text-align:justify;">二、复合类型之结构体</h2> 
<p style="margin-left:.0001pt;text-align:justify;">2.1.目前C程序分配内存的方法两种：定义变量和定义数组</p> 
<p style="margin-left:.0001pt;text-align:justify;">定义变量的缺陷：不能大量定义,所以诞生数组</p> 
<p style="margin-left:.0001pt;text-align:justify;">定义数组的缺陷：数据类型是相同的,所以诞生结构体</p> 
<p style="margin-left:.0001pt;text-align:justify;">问：什么场合需要定义大量变量和变量的数据类型不相同呢？</p> 
<p style="margin-left:.0001pt;text-align:justify;">答：比如让计算机记录或者描述一个学生的信息</p> 
<p style="margin-left:.0001pt;text-align:justify;">学生的信息如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;">int age; //年龄</p> 
<p style="margin-left:.0001pt;text-align:justify;">char *name ;//名字</p> 
<p style="margin-left:.0001pt;text-align:justify;">int id; //学号</p> 
<p style="margin-left:.0001pt;text-align:justify;">float score; //学分</p> 
<p style="margin-left:.0001pt;text-align:justify;">显然变量的数据类型不一致,数组无法做到,采用结构体.</p> 
<p style="margin-left:.0001pt;text-align:justify;">2.2.结构体特点：<span style="color:#ff0000;">能够包含大量的变量并且对变量的数据类型无要求</span>       </p> 
<p style="margin-left:.0001pt;text-align:justify;">对应的关键字：struct</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">结构体也是一种数据类型</span>,它<span style="color:#ff0000;">是程序员自行定义的一种数据类型</span>，类比成一个int类型，<span style="color:#ff0000;">结构体分配的内存是连续的</span>,一个成员挨着一个成员</p> 
<p style="margin-left:.0001pt;text-align:justify;">2.3.结构体声明定义的使用方法：</p> 
<p style="margin-left:.0001pt;text-align:justify;">a)方法1：直接定义结构体变量(很少用)</p> 
<p style="margin-left:.0001pt;text-align:justify;">1.语法：struct  {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">结构体成员; //又称结构体字段</p> 
<p style="margin-left:.0001pt;text-align:justify;">   }结构体变量名;</p> 
<p style="margin-left:.0001pt;text-align:justify;">2.例如：描述学生信息 </p> 
<pre><code class="language-cpp">  //定义一个学生信息的结构体变量student1
   struct  {
int age; //描述学生的年龄
int id; //描述学生的学号
float score; //描述学生的学分
char name[30]; //描述学生的姓名
   }student1;
   //再定义一个学生信息的结构体变量student2
   struct  {
int age; //描述学生的年龄
int id; //描述学生的学号
float score; //描述学生的学分
char name[30]; //描述学生的姓名
   }student2;</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">3.缺陷：每次定义一个结构体变量,结构体成员都要重新写一遍,很繁琐</p> 
<p style="margin-left:.0001pt;text-align:justify;">b)方法2：先声明结构体数据类型, 然后用这种结构体数据类型定义结构体变量(常用,掌握)</p> 
<p style="margin-left:.0001pt;text-align:justify;">1.声明结构体数据类型的语法：</p> 
<p style="margin-left:.0001pt;text-align:justify;">    struct  结构体名 {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">结构体成员;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    };</p> 
<p style="margin-left:.0001pt;text-align:justify;">    注意：<span style="color:#ff0000;">不会分配内存</span>     大型程序,结构体<span style="color:#ff0000;">声明放到头文件来写</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2.用结构体数据类型定义结构体变量的语法：</p> 
<p style="margin-left:.0001pt;text-align:justify;">   struct 结构体名  结构体变量名;</p> 
<p style="margin-left:.0001pt;text-align:justify;">   注意：<span style="color:#ff0000;">会分配内存</span>        大型程序,结构体<span style="color:#ff0000;">定义放到源文件中来写</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">3.例如：</p> 
<p style="margin-left:.0001pt;text-align:justify;">   //1.声明描述学生信息的结构体数据类型</p> 
<pre><code class="language-cpp">   struct student {
int age; //描述学生的年龄
int id; //描述学生的学号
float score; //描述学生的学分
char name[30]; //描述学生的姓名
   };</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">  //2.定义两个学生信息的结构体变量  </p> 
<pre><code class="language-cpp">struct student student1;
struct student studnet2;
//或者
struct student student1, student2;</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">4.缺陷：每次定义结构体变量,struct 结构体名每次都要书写,很烦躁！</p> 
<p style="margin-left:.0001pt;text-align:justify;">c)方法3：先<span style="color:#ff0000;">用typedef关键字给一个声明的结构体数据类型取别名</span>(外号)，然后<span style="color:#ff0000;">用别名定义结构体变量</span>(实际开发最常用)</p> 
<p style="margin-left:.0001pt;text-align:justify;">1)务必掌握typedef关键字</p> 
<p style="margin-left:.0001pt;text-align:justify;">   功能：给数据类型取别名(外号)</p> 
<p style="margin-left:.0001pt;text-align:justify;">   语法：typedef  原数据类型   别名;</p> 
<p style="margin-left:.0001pt;text-align:justify;">   例如：对于基本数据类型取别名(实际开发代码)</p> 
<pre><code class="language-cpp">typedef  char  s8;   //s=signed:有符号,8:8位
typedef unsigned char u8; //u=unsiged
typedef short s16;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef float f32;
typedef double f64;
//使用：
int a 写成 s32 a;
unsigned char b 写成 u8 b</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">2.用typedef对声明的结构体取别名</p> 
<p style="margin-left:.0001pt;text-align:justify;">   注意：规定：<span style="color:#ff0000;">别名后面加_t,对于大型程序写头文件</span><span style="color:#ff0000;">(不成文规定)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">   形式1：</p> 
<p style="margin-left:.0001pt;text-align:justify;">   语法：typedef struct {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    结构体成员;</p> 
<p style="margin-left:.0001pt;text-align:justify;">   }<span style="color:#ff0000;">别名_t</span>；    </p> 
<p style="margin-left:.0001pt;text-align:justify;">   例如：</p> 
<pre><code class="language-cpp">typedef struct  {
int age; //描述学生的年龄
int id; //描述学生的学号
float score; //描述学生的学分
char name[30]; //描述学生的姓名
   }stu_t;</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">   形式2：</p> 
<p style="margin-left:.0001pt;text-align:justify;">   语法：typedef struct 结构体名{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    结构体成员;</p> 
<p style="margin-left:.0001pt;text-align:justify;">   }别名_t；    </p> 
<p style="margin-left:.0001pt;text-align:justify;">   例如：  </p> 
<pre><code class="language-cpp">typedef struct  studnet{
int age; //描述学生的年龄
int id; //描述学生的学号
float score; //描述学生的学分
char name[30]; //描述学生的姓名
   }stu_t;</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">   形式3：</p> 
<pre><code class="language-cpp">   struct  studnet{
int age; //描述学生的年龄
int id; //描述学生的学号
float score; //描述学生的学分
char name[30]; //描述学生的姓名
int weight; //学生的体重
   };
   //取别名
   typedef struct student stu_t;</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">3.不管使用哪种typedef对结构体数据类型取别名,定义结构体变量都一样</p> 
<p style="margin-left:.0001pt;text-align:justify;">    定义结构体变量语法：别名  结构体变量名;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    例如：定义两个学生信息的结构体变量</p> 
<p style="margin-left:.0001pt;text-align:justify;">    stu_t student1;    </p> 
<p style="margin-left:.0001pt;text-align:justify;">    stu_t student2;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    或者：</p> 
<p style="margin-left:.0001pt;text-align:justify;">    stu_t     student1, student2;</p> 
<p style="margin-left:.0001pt;text-align:justify;">     </p> 
<p style="margin-left:.0001pt;text-align:justify;">2.4.结构体变量的初始化方式，两种方式：</p> 
<p style="margin-left:.0001pt;text-align:justify;">a)<span style="color:#ff0000;">传统初始化方式：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">1.语法：struct 结构体名/别名  结构体变量名 = {初始化的值};</p> 
<p style="margin-left:.0001pt;text-align:justify;">2.例如： </p> 
<pre><code class="language-cpp">struct student student1 = {18, 666, 100, "哥", 128};
//或者
stu_t  student1 = {18, 666, 100, "哥"};</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">3.缺陷：定义初始化的时候需要按照顺序全部初始化,因为有些场合可以不用按照顺序,关键是可以不用全部初始化</p> 
<p style="margin-left:.0001pt;text-align:justify;">b)<span style="color:#ff0000;">标记初始化方式： </span> </p> 
<p style="margin-left:.0001pt;text-align:justify;">1.语法：struct 结构体名/别名  结构体变量名 = {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">.某个成员名 = 初始化值,</p> 
<p style="margin-left:.0001pt;text-align:justify;">.某个成员名 = 初始化值,</p> 
<p style="margin-left:.0001pt;text-align:justify;">... };</p> 
<p style="margin-left:.0001pt;text-align:justify;">2.例如：</p> 
<pre><code class="language-cpp">struct student student1 = {
.name   = "哥",
.weight = 128,
.age = 18,
 };
//或者
stu_t  student1 = {
.name   = "哥",
.weight = 128,
.age = 18,
};</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">3.<span style="color:#ff0000;">特点：不用按照顺序,不用全部成员初始化</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2.5.结构体变量成员的访问：两种形式</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">a)通过"."运算符来访问结构体变量的成员</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">   语法：结构体变量名.成员名; //<span style="color:#ff0000;">将来可以访问这个成员的内存区域</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">   例如：</p> 
<pre><code class="language-cpp">stu_t  student1 = {
.name   = "哥",
.weight = 128,
.age = 18,
 };
//读查看
printf("%s %d %d\n",
student1.name, student1.weight, student1.age);
//写修改
strcpy(student1.name, "弟");    
student1.weight = 821;
student1.age = 17;  </code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">b)通过"-&gt;"运算符来<span style="color:#ff0000;">访问结构体指针变量</span>的成员</p> 
<p style="margin-left:.0001pt;text-align:justify;">语法：结构体指针变量名-&gt;成员名; //将来可以访问这个成员的内存区域</p> 
<p style="margin-left:.0001pt;text-align:justify;">例如：</p> 
<pre><code class="language-cpp">stu_t  student1 = {
.name   = "哥",
.weight = 128,
.age = 18,
    };
stu_t *p = &amp;student1; //定义一个结构体指针变量p指向student1结构体变量
//读查看
printf("%s %d %d\n",
p-&gt;name, p-&gt;weight, p-&gt;age
  strcpy(p-&gt;name, "弟");    
  p-&gt;weight = 821;
  p-&gt;age = 17;  </code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">2.6.<span style="color:#ff0000;">结构体变量之间可以直接赋值</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">      例如：</p> 
<p style="margin-left:.0001pt;text-align:justify;">      stu_t  student1  = {18, 666, 100, "哥", 128};</p> 
<p style="margin-left:.0001pt;text-align:justify;">      stu_t  student2 = student1;</p> 
<p style="margin-left:.0001pt;text-align:justify;">      或者</p> 
<p style="margin-left:.0001pt;text-align:justify;">      stu_t  student1  = {18, 666, 100, "哥", 128};</p> 
<p style="margin-left:.0001pt;text-align:justify;">      stu_t *p = &amp;student1; //p指向student1</p> 
<p style="margin-left:.0001pt;text-align:justify;">      stu_t student2 = *p;      </p> 
<p style="margin-left:.0001pt;text-align:justify;">2.7.结构体嵌套：结构体成员还是一个结构体</p> 
<p style="margin-left:.0001pt;text-align:justify;">      例如：</p> 
<p style="margin-left:.0001pt;text-align:justify;">      //声明描述学生出生日期的结构体</p> 
<pre><code class="language-cpp">typedef struct birthday {
int year;  //年
int month; //月
int date; //日
}birthday_t;
//声明描述学生信息的结构体
typedef struct student {
char name[30]; //姓名
int age; //年龄
//struct birthday birth; //学生的出生日期
birthday_t  birth; //学生的出生日期
     };</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">2.8.函数的形参是结构体,两种形式</p> 
<p style="margin-left:.0001pt;text-align:justify;">a)直接传递结构体变量本身,形参是实参的一份拷贝,结构体有多大就需要拷贝多大，函数通过形参是<span style="color:#ff0000;">不能修改</span>结构体实参,<span style="color:#ff0000;">只是对形参做了改变</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">b)直接传递结构体变量的地址，函数通过形参<span style="color:#ff0000;">可以直接修改</span>结构体实参,代码执行效率高,如果是指针只需拷贝4字节</p> 
<p style="margin-left:.0001pt;text-align:justify;">c)公式,规矩：如果函数要访问结构体,将来要传递结构体指针,不要传递结构体变量，<span style="color:#ff0000;">如果函数对结构体成员不进行修改,形参用const修饰</span></p> 
<pre><code class="language-cpp">  void show(const stu_t *pst)
  {
printf("%s\n", pst-&gt;name);
//不让修改：strcpy(pst-&gt;name, "蛋");
  }
  void grow(stu_t *pst)
  {
pst-&gt;age++;
  }</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">2.9.结构体<span style="color:#ff0000;">内存对齐问题</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">a)gcc对结构体成员编译时,<span style="color:#ff0000;">默认按4字节对齐</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">例如：</p> 
<p style="margin-left:.0001pt;text-align:justify;">struct A {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">char buf[2];</p> 
<p style="margin-left:.0001pt;text-align:justify;">int val;</p> 
<p style="margin-left:.0001pt;text-align:justify;">};</p> 
<p style="margin-left:.0001pt;text-align:justify;">结果：sizeof(struct A) = 8</p> 
<p style="margin-left:.0001pt;text-align:justify;">内存分布图:</p> 
<p style="text-align:center;"><img alt="" height="287" src="https://images2.imgbox.com/3b/56/NfKycPSE_o.png" width="441"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">b)演示代码：</p> 
<pre><code class="language-cpp">/*结构体内存对齐*/
#include &lt;stdio.h&gt;
//声明结构体数据类型A
struct A {
    char buf[2]; //4
    int val; //4
};
//声明结构体数据类型B
struct B {
    char c; //4
    short s[2]; //4
    int i; //4
};
#pragma pack(1) //让gcc强制从这个地方开始后面代码按照1字节对齐方式编译
    //声明结构体类型C
    struct C {
        char c; //1
        short s[2]; //4
        int i; //4
};
#pragma pack() //让gcc到这里在恢复成默认4字节对齐
//声明结构体类型D
struct D {
    int i; //4
    char c; //4
};
//声明结构体类型E
struct E {
    double d;  //8
    char c; //4
};
int main(void)
{
    printf("sizeof(struct A) = %d\n", sizeof(struct A)); //8
    printf("sizeof(struct B) = %d\n", sizeof(struct B)); //12
    printf("sizeof(struct C) = %d\n", sizeof(struct C)); //9
    printf("sizeof(struct D) = %d\n", sizeof(struct D)); //8
    printf("sizeof(struct E) = %d\n", sizeof(struct E)); //12
    return 0;
}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 style="margin-left:.0001pt;text-align:justify;">三、联合体</h2> 
<p style="margin-left:.0001pt;text-align:justify;">3.1.特点：</p> 
<p style="margin-left:.0001pt;text-align:justify;">a)它和结构体使用语法一模一样,只是将关键字struct换成union</p> 
<p style="margin-left:.0001pt;text-align:justify;">b)联合体中所有成员是<strong><span style="color:#ff0000;">共用一块内存</span></strong>,优点节省内存</p> 
<p style="margin-left:.0001pt;text-align:justify;">c)联合体占用的内存<strong><span style="color:#ff0000;">按成员中占内存最大的来算</span></strong>例如：</p> 
<pre><code class="language-cpp">union A {
char a;
short b;
int c;
};
sizeof(union A) = 4;</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">d)初始化问题</p> 
<p style="margin-left:.0001pt;text-align:justify;">   union A  a = {8}; //<span style="color:#ff0000;">默认给第一个成员</span>a,a = 8</p> 
<p style="margin-left:.0001pt;text-align:justify;">   union A  a = {.c = 8} //强制给c赋值</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">3.2.经典笔试题</p> 
<p style="margin-left:.0001pt;text-align:justify;">      现象：</p> 
<p style="margin-left:.0001pt;text-align:justify;">      1.X86架构的CPU为<span style="color:#ff0000;">小端模式</span>：数据的<span style="color:#ff0000;">低位在内存的低地址</span>,数据的<span style="color:#ff0000;">高位在内存的高地址处</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">         例如：</p> 
<p style="margin-left:.0001pt;text-align:justify;">         int a = 0x12345678;</p> 
<p style="margin-left:.0001pt;text-align:justify;">         内存条</p> 
<p style="margin-left:.0001pt;text-align:justify;">         低地址 高地址</p> 
<p style="margin-left:.0001pt;text-align:justify;">         0-------1-----2-------3------4---------------------------------&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">           0x78    0x56  0x34   0x12</p> 
<p style="margin-left:.0001pt;text-align:justify;">     2.POWERPC架构的CPU为<span style="color:#ff0000;">大端模式</span>：</p> 
<p style="margin-left:.0001pt;text-align:justify;">数据的<span style="color:#ff0000;">低位在内存的高地址</span>,数据的<span style="color:#ff0000;">高位在内存的低地址处</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">         例如：</p> 
<p style="margin-left:.0001pt;text-align:justify;">         int a = 0x12345678;</p> 
<p style="margin-left:.0001pt;text-align:justify;">         内存条</p> 
<p style="margin-left:.0001pt;text-align:justify;">         低地址 高地址</p> 
<p style="margin-left:.0001pt;text-align:justify;">         0-------1-----2-------3------4---------------------------------&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">           0x12    0x34  0x56   0x78</p> 
<p style="margin-left:.0001pt;text-align:justify;">     要求：编写一个程序求当前处理器是X86架构还是POWERPC架构</p> 
<p style="margin-left:.0001pt;text-align:justify;">思路：采用union或者指针</p> 
<p style="margin-left:.0001pt;text-align:justify;">提示：</p> 
<p style="margin-left:.0001pt;text-align:justify;"> union A {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">char a;</p> 
<p style="margin-left:.0001pt;text-align:justify;">int b;</p> 
<p style="margin-left:.0001pt;text-align:justify;">};</p> 
<p style="margin-left:.0001pt;text-align:justify;">参考代码：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
//声明一个联合体
typedef union w
{
  int a;  //4 字节
  char b; //1 字节
} c_t;
int main(void)
{
  //定义联合体变量
  c_t c.a=1;
  if (c.b==1)
   printf("小端\nn");
  else
   printf("大端\n");
  return 1;
}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/399c9af72732a8f96140888c9e717396/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">生成Git ssh公钥和私钥（ppk）文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36a6e8986056d1dae0dce3e022a3c6fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2022JDK安装配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>