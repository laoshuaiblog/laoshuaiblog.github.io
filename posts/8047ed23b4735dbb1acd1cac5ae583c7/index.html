<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue3的MVVM简介详情 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/8047ed23b4735dbb1acd1cac5ae583c7/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Vue3的MVVM简介详情">
  <meta property="og:description" content="简介
​ MVVM旨在利用WPF中的数据绑定函数，通过从视图层中几乎删除所有GUI代码（代码隐藏），更好地促进视图层开发与模式其余部分的分离。不需要用户体验（UX）开发人员编写GUI代码，他们可以使用框架标记语言（如XAML），并创建到应用程序开发人员编写和维护的视图模型的数据绑定。角色的分离使得交互设计师可以专注于用户体验需求，而不是对业务逻辑进行编程。这样，应用程序的层次可以在多个工作流中进行开发以提高生产力。即使一个开发人员在整个代码库上工作，视图与模型的适当分离也会更加高效，因为基于最终用户反馈，用户界面通常在开发周期中经常发生变化，而且处于开发周期后期。
在Vue 3中，MVVM（Model-View-ViewModel）是一种常见的架构模式，用于将应用程序的数据模型（Model）与用户界面（View）分离，并通过ViewModel来进行交互和通信。
下面是对Vue 3中MVVM的详细解释：
Model（数据模型）：
Model代表应用程序的数据和业务逻辑。它可以是从后端API获取的数据、本地存储的数据或用户输入的数据等。在Vue中，数据模型通常是通过定义Vue实例的data选项来表示。这些数据可以是简单的变量、对象、数组等。 View（用户界面）：
View是用户直接与应用程序交互的界面。它通常由HTML模板和Vue指令组成，用于渲染数据和响应用户的操作。在Vue中，可以使用Vue的模板语法来定义视图。模板语法允许将数据绑定到HTML元素，使数据的变化能够自动更新到视图上。 ViewModel（视图模型）：
ViewModel是连接数据模型和用户界面的中间层。它负责处理数据的变化、用户输入的响应和与数据模型的交互。在Vue中，ViewModel由Vue组件扮演的角色。组件是可重用的Vue实例，它封装了特定的功能和视图，并通过props接收数据、通过methods响应事件、通过computed计算属性处理数据等。 MVVM模式的工作原理如下：
用户与View进行交互，例如输入表单、点击按钮等。View通过指令和数据绑定将用户的操作反映到ViewModel中。ViewModel接收到用户的操作后，可以对数据进行处理、验证、发送网络请求等。ViewModel将处理后的数据更新到数据模型中。数据模型的更新会触发View的重新渲染，用户界面随之更新。 Vue 3通过其响应式系统实现了MVVM模式的核心功能。它使用了Proxy对象来追踪数据的变化，并在数据发生变化时自动更新相关的视图。
总结：MVVM模式在Vue 3中提供了一种结构化的方式来组织应用程序的代码和数据。它通过将数据模型、用户界面和视图模型分离，使得应用程序更易于开发、测试和维护。Vue 3的响应式系统和组件化特性为MVVM的实现提供了强大的支持。
运行原理:
当view变化,VM监听后更改model
当model变化,VM监听后更改view">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-08T14:57:10+08:00">
    <meta property="article:modified_time" content="2023-08-08T14:57:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue3的MVVM简介详情</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p>简介</p> 
 <p>​ MVVM旨在利用WPF中的数据绑定函数，通过从视图层中几乎删除所有GUI代码（代码隐藏），更好地促进视图层开发与模式其余部分的分离。不需要用户体验（UX）开发人员编写GUI代码，他们可以使用框架标记语言（如XAML），并创建到应用程序开发人员编写和维护的视图模型的数据绑定。角色的分离使得交互设计师可以专注于用户体验需求，而不是对业务逻辑进行编程。这样，应用程序的层次可以在多个工作流中进行开发以提高生产力。即使一个开发人员在整个代码库上工作，视图与模型的适当分离也会更加高效，因为基于最终用户反馈，用户界面通常在开发周期中经常发生变化，而且处于开发周期后期。</p> 
 <p></p> 
 <p>在Vue 3中，MVVM（Model-View-ViewModel）是一种常见的架构模式，用于将应用程序的数据模型（Model）与用户界面（View）分离，并通过ViewModel来进行交互和通信。</p> 
 <p>下面是对Vue 3中MVVM的详细解释：</p> 
 <ol><li> <p>Model（数据模型）：</p> 
   <ul><li>Model代表应用程序的数据和业务逻辑。它可以是从后端API获取的数据、本地存储的数据或用户输入的数据等。</li><li>在Vue中，数据模型通常是通过定义Vue实例的data选项来表示。这些数据可以是简单的变量、对象、数组等。</li></ul></li><li> <p>View（用户界面）：</p> 
   <ul><li>View是用户直接与应用程序交互的界面。它通常由HTML模板和Vue指令组成，用于渲染数据和响应用户的操作。</li><li>在Vue中，可以使用Vue的模板语法来定义视图。模板语法允许将数据绑定到HTML元素，使数据的变化能够自动更新到视图上。</li></ul></li><li> <p>ViewModel（视图模型）：</p> 
   <ul><li>ViewModel是连接数据模型和用户界面的中间层。它负责处理数据的变化、用户输入的响应和与数据模型的交互。</li><li>在Vue中，ViewModel由Vue组件扮演的角色。组件是可重用的Vue实例，它封装了特定的功能和视图，并通过props接收数据、通过methods响应事件、通过computed计算属性处理数据等。</li></ul></li></ol> 
 <p>MVVM模式的工作原理如下：</p> 
 <ol><li>用户与View进行交互，例如输入表单、点击按钮等。</li><li>View通过指令和数据绑定将用户的操作反映到ViewModel中。</li><li>ViewModel接收到用户的操作后，可以对数据进行处理、验证、发送网络请求等。</li><li>ViewModel将处理后的数据更新到数据模型中。</li><li>数据模型的更新会触发View的重新渲染，用户界面随之更新。</li></ol> 
 <p>Vue 3通过其响应式系统实现了MVVM模式的核心功能。它使用了Proxy对象来追踪数据的变化，并在数据发生变化时自动更新相关的视图。</p> 
 <p>总结：MVVM模式在Vue 3中提供了一种结构化的方式来组织应用程序的代码和数据。它通过将数据模型、用户界面和视图模型分离，使得应用程序更易于开发、测试和维护。Vue 3的响应式系统和组件化特性为MVVM的实现提供了强大的支持。</p> 
 <p><strong>运行原理:</strong></p> 
 <p>当view变化,VM监听后更改model</p> 
 <p>当model变化,VM监听后更改view</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/ce/6d/R2WJecjT_o.png" width="892"> 
   </div> 
  </div> 
 </div> 
 <p></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/342219160984d90f276520b69cbb56aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ts那些简单的语义</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fc18057b4005fc0dadd1938408d69ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VMWare Workstation中NAT模式设置静态IP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>