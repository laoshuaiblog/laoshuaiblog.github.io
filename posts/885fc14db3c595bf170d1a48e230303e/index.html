<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第一章 .Net 控件开发(WebForm) 开发简单自定义控件(9) 流程和生命周期 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/885fc14db3c595bf170d1a48e230303e/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="第一章 .Net 控件开发(WebForm) 开发简单自定义控件(9) 流程和生命周期">
  <meta property="og:description" content="1、 上章结束的时候已经把整个自定义简单控件的实现都讲好了。打算准备讲复合控件，但是还是有必要把自定义简单控件的流程和生命周期来讲下。
2、 流程： （1） 继承WebControl类，重写RenderContents方法；
（2） 设置最外层元素需要重写TagKey属性；
（3） 需要设置样式需要重写CreateControlStyle方法，如需要自定义需要继承Style或者Style的子类；
（4） 设置Html元素的ID和Name属性时设置它的唯一性；
（5） 自定义数据事件类时，继承或者直接使用EventArgs类；
（6） 显示实现IPostBackEventHandler和IPostBackDataHandler接口。
using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Web.UI.WebControls;using System.Web.UI;namespace WebFormControl{public class TestControlSum:WebControl,IPostBackEventHandler,IPostBackDataHandler{protected override void RenderContents(System.Web.UI.HtmlTextWriter writer){base.RenderContents(writer);//（1）继承WebControl类，重写RenderContents方法；}protected override System.Web.UI.HtmlTextWriterTag TagKey{get{return base.TagKey;//（2）设置最外层元素需要重写TagKey属性；}}protected override Style CreateControlStyle(){return base.CreateControlStyle();//(3)}// （4）	设置Html元素的ID和Name属性时设置它的唯一性；// （5）	自定义数据事件类时，继承或者直接使用EventArgs类；void IPostBackEventHandler.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2011-09-09T09:22:40+08:00">
    <meta property="article:modified_time" content="2011-09-09T09:22:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第一章 .Net 控件开发(WebForm) 开发简单自定义控件(9) 流程和生命周期</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、 上章结束的时候已经把整个自定义简单控件的实现都讲好了。打算准备讲复合控件，但是还是有必要把自定义简单控件的流程和生命周期来讲下。</p> 
<p>2、 流程： <br> （1） 继承WebControl类，重写RenderContents方法；<br> （2） 设置最外层元素需要重写TagKey属性；<br> （3） 需要设置样式需要重写CreateControlStyle方法，如需要自定义需要继承Style或者Style的子类；<br> （4） 设置Html元素的ID和Name属性时设置它的唯一性；<br> （5） 自定义数据事件类时，继承或者直接使用EventArgs类；<br> （6） 显示实现IPostBackEventHandler和IPostBackDataHandler接口。</p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web.UI.WebControls;
using System.Web.UI;

namespace WebFormControl
{
    public class TestControlSum:WebControl,IPostBackEventHandler,IPostBackDataHandler
    {
        protected override void RenderContents(System.Web.UI.HtmlTextWriter writer)
        {
            base.RenderContents(writer);//（1）继承WebControl类，重写RenderContents方法；
        }
        protected override System.Web.UI.HtmlTextWriterTag TagKey
        {
            get
            {
                return base.TagKey;//（2）设置最外层元素需要重写TagKey属性；
            }
        }
        protected override Style CreateControlStyle()
        {
            return base.CreateControlStyle();//(3)
        }
        // （4）	设置Html元素的ID和Name属性时设置它的唯一性；
        // （5）	自定义数据事件类时，继承或者直接使用EventArgs类；
        void IPostBackEventHandler.RaisePostBackEvent(string eventArgument)
        {
            throw new NotImplementedException();//（6）显示实现IPostBackEventHandler接口
        }

        bool IPostBackDataHandler.LoadPostData(string postDataKey, System.Collections.Specialized.NameValueCollection postCollection)
        {
            throw new NotImplementedException();//(6) 显示实现IPostBackDataHandler接口
        }

        void IPostBackDataHandler.RaisePostDataChangedEvent()
        {
            throw new NotImplementedException();//(6)  显示实现IPostBackDataHandler接口
        }
    }
}
</code></pre> 
<p>3、 生命周期阶段：<br> （1） 页请求：页请求发生在页生命周期开始之前。用户请求页时，ASP.NET 将确定是否需要分析和编译页（从而开始页的生命周期），或者是否可以在不运行页的情况下发送页的缓存版本以进行响应。<br> （2） 开始：在开始阶段，将设置页属性，如 Request 和 Response。在此阶段，页还将确定请求是回发请求还是新请求，并设置 IsPostBack 属性。此外，在开始阶段期间，还将设置页的 UICulture 属性。<br> （3） 页初始化：页初始化期间，可以使用页中的控件，并将设置每个控件的 UniqueID 属性。此外，任何主题都将应用于页。如果当前请求是回发请求，则回发数据尚未加载，并且控件属性值尚未还原为视图状态中的值。<br> （4） 加载：加载期间，如果当前请求是回发请求，则将使用从视图状态和控件状态恢复的信息加载控件属性。<br> （5） 验证：在验证期间，将调用所有验证程序控件的 Validate 方法，此方法将设置各个验证程序控件和页的 IsValid 属性。<br> （6） 回发事件处理：如果请求是回发请求，则将调用所有事件处理程序。<br> （7） 呈现：在呈现之前，会针对该页和所有控件保存视图状态。在呈现阶段中，页会针对每个控件调用 Render 方法，它会提供一个文本编写器，用于将控件的输出写入页的 Response 属性的 OutputStream 中。<br> （8） 卸载：完全呈现页并已将页发送至客户端、准备丢弃该页后，将调用卸载。此时，将卸载页属性（如 Response 和 Request）并执行清理。</p> 
<p>4、  生命周期事件：</p> 
<p>（1）       预初始化</p> 
<p>（2）       初始化</p> 
<p>（3）       初始化完成</p> 
<p>（4）       预加载</p> 
<p>（5）       加载</p> 
<p>（6）       控件事件</p> 
<p>（7）       加载完成</p> 
<p>（8）       预呈现</p> 
<p>（9）       保存状态完成</p> 
<p>（10）   呈现</p> 
<p>（11）   卸载</p> 
<p>事件的顺序大致上是这样的，在Aspx页面上看下</p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

public partial class TestControlSumPage : System.Web.UI.Page
{
    protected void Page_PreInit(object sender, EventArgs e)
    {
        Response.Write("预初始化&lt;br/&gt;");
        //检查 IsPostBack 属性来确定是不是第一次处理该页。
        //创建或重新创建动态控件。
        //动态设置主控页。
        //动态设置 Theme 属性。
        //读取或设置配置文件属性值。
    }
    protected void Page_Init(object sender, EventArgs e)
    {
        Response.Write("初始化&lt;br/&gt;");
        //在所有控件都已初始化且已应用所有外观设置后引发。使用该事件来读取或初始化控件属性。
    }
    protected void Page_InitComplete(object sender, EventArgs e)
    {
        Response.Write("初始化完成&lt;br/&gt;");
        //使用该事件来处理要求先完成所有初始化工作的任务。
    }
    protected void Page_PreLoad(object sender, EventArgs e)
    {
        Response.Write("预加载&lt;br/&gt;");
        //如果需要在 Load 事件之前对页或控件执行处理，请使用该事件。 
        //在 Page 引发该事件后，它会为自身和所有控件加载视图状态，然后会处理 Request 实例包括的任何回发数据。
    }
    protected void Page_Load(object sender, EventArgs e)
    {
        Response.Write("加载&lt;br/&gt;");
        //Page 在 Page 上调用 OnLoad 事件方法，然后以递归方式对每个子控件执行相同操作，如此循环往复，直到加载完本页和所有控件为止。
        //使用 OnLoad 事件方法来设置控件中的属性并建立数据库连接。
    }
    //控件事件
    protected void Page_LoadComplete(object sender, EventArgs e)
    {
        Response.Write("加载完成&lt;br/&gt;");
        //对需要加载页上的所有其他控件的任务使用该事件。
    }
    protected void Page_PreRender(object sender, EventArgs e)
    {
        Response.Write("预呈现&lt;br/&gt;");
        //在该事件发生前：
        //Page 对象会针对每个控件和页调用 EnsureChildControls。 
        //设置了 DataSourceID 属性的每个数据绑定控件会调用 DataBind 方法。
        //页上的每个控件都会发生 PreRender 事件。使用该事件对页或其控件的内容进行最后更改。
    }
    protected void Page_SaveStateComplete(object sender, EventArgs e)
    {
        Response.Write("保存状态完成&lt;br/&gt;");
        //在该事件发生前，已针对页和所有控件保存了 ViewState。将忽略此时对页或控件进行的任何更改。
        //使用该事件执行满足以下条件的任务：要求已经保存了视图状态，但未对控件进行任何更改。
    }
    protected void Page_Render(object sender, EventArgs e)
    {
        Response.Write("呈现&lt;br/&gt;");
        //这不是事件；在处理的这个阶段，Page 对象会在每个控件上调用此方法。所有 ASP.NET Web 服务器控件都有一个用于写出发送给浏览器的控件标记的 Render 方法。
        //如果创建自定义控件，通常要重写此方法以输出控件的标记。不过，如果自定义控件只合并标准的 ASP.NET Web 服务器控件，不合并自定义标记，则不需要重写 Render 方法。
        //用户控件（.ascx 文件）自动合并呈现，因此不需要在代码中显式呈现该控件。
    }
    //Page_Unload事件
    
}</code></pre> 
<p> </p> 
<pre><code class="language-html">预初始化
初始化
初始化完成
预加载
加载
加载完成
预呈现
保存状态完成
</code></pre> 
<p align="left">生命周期阶段和生命周期事件详细信息请参照MSDN地址：<a href="http://msdn.microsoft.com/zh-cn/library/ms178472%28VS.80%29.aspx" rel="nofollow">http://msdn.microsoft.com/zh-cn/library/ms178472(VS.80).aspx</a></p> 
<p align="left">代码下载地址：<a href="http://files.cnblogs.com/nethch/NetHch%281-9%29.rar" rel="nofollow">点击下载</a></p> 
<p align="center"><span style="color:#ff00">本博客内容有些来源于网络或书籍如果侵害到你的权益，请及时联系我(<span style="color:#ff00"><a href="mailto:hch458458@vip.qq.com" rel="nofollow">hch458458@vip.qq.com</a>)</span></span><br> <span style="color:#ff00">版权归nethch所有,转载请注明出处!</span><br> </p> 
<p> </p> 
<p><br>  </p> 
<p> </p> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a785b5c35ff15f3622d12f403a2fce1e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c#中 把字符串转换为拼音码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e0c6cf79931c54c837ab5b0518093cc4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NoMethodError: undefined method `init&#39; for Mysql:Class</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>