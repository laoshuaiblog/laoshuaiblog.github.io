<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>我的西皮优学习笔记（五）-＞二进制及其表示法 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/f652c6cf428a502048f2f49d0d06e84d/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="我的西皮优学习笔记（五）-＞二进制及其表示法">
  <meta property="og:description" content="进制的运算 1、十进制的对比分析 在十进制的数字中，每一列的权都是前一列的10倍，从右到左，每一列的权分别是1，10，100，1000…
看到十进制数的时候会发现其右下角有一个小小的10，这个小小的数称为十进制的c基,也就是说十进制的基是10
例：比如说：2345这个数是个十进制数
我们的一般就是个直接理解2345，这种思想是我们的常识思想，其实它真正的数字意义是在我们学习数字的时候刚开始的思维方式，
两个一千，三个一百，四个10，五个1，拿过来作为机器思想的描述就是：
每一位上的数字乘上他们对应位的权，再将结果加起来得到最终的数值
2、二进制 每一位上的数字只有0和1两个值，最后将多位合并起来就组成了一个二进制数
二进制的基是2
每一列的权从右到左分别是：1，2，4，8，16…，以此类推，也就是说个位的权是20,十位21…等等，同样通过机器的思想去理解
二进制就是：每一位上的数字(0/1)去乘上对应位的权（2的几次方）
1）二进制转换为十进制 个位权对应十进制：1
十位权对应十进制：2
百位权对应十进制：4
千位权对应十进制：8
…
例：1011
描述过来就是：1 * 1&#43;1 * 2&#43;0 * 4 &#43; 1 * 8
通过二进制权对应的十进制的数来实现二进制到十进制的转化
2）十进制转二进制 比如说：给定十进制数84需要转换为二进制数
那么84中含的二进制的最大权就是64
所以64这一位上的数是1
然后 通过 84&#43;64 = 20
64的下一位上的权是32，但是20&amp;lt;32，所以32这一位上的数就是0
32的下一位上的权是16，同时20&amp;gt;16，所以16这一位上的数就是1
以此类推
得到的 84》》》1010100
3、半字节，字节和字 对于二进制 8位一组称为字节，它能表示2^8 = 256 个数字，计算机中存储数据习惯于用字节作为单位，而不是用位作为单位。
4位的一组或者说半个字节称为半字节，能表示 2^4 = 16个数字（也就是一个十六进制数占用一个半字节），不常用，1024个字节称为1千字节（kilobyte ，KB），1024比特称为1千比特（kilobit，Kb或者Kbit），相似的MB，Mb称为兆字节，和兆比特，GB和Gb称为吉字节和吉比特。内存的容量一般用字节作为单位，但是信息传输率一般用比特/秒，作为单位。
对于微处理器来说，处理的一块数据称为字，字的大小取决于微处理器的结构。64位的处理器表示对64位的字进行操作，32位的处理器
对于32位的字进行处理。比较简单的微处理器也有8位或者16位字的
**最低有效位：**在一组位中，权为1的那位称其为最低有效位（lsb）
**最高有效位：**这组的位的另一端称为最高有效位（msb）
对于一个字来说可以通过十六进制来表示，这样就可以通过最低有效字节和最高有效字节来表示：
比如说：DEAFDAD8
最低有效字节是D8
最高有效字节是DE
4、二进制的溢出： 进行十进制的加法运算的时候经常会发生一个情况就是进位，比如说两个千位极的数相加就有可能生成一个万位级的数，但是正常在进行十进制的加法的时候并不会对这个有什么疑惑，因为十进制的数字加法一般是数字长度可变的，但是对于二进制的加法来说并不一样，一般在操作二进制数的时候都是操作的定长的数字。
比如说在两个四位的二进制数相加的时候，就有可能会产生一个五位的二进制数，但是用于接收这个结果的还是四位的长度，那么此时就会产生溢出（overflow），这个时候会将生成的第五位抛弃。从而产生了一个不正确的结果。
5、有符号的二进制数 二进制用于表示数当然是可以表示正负的，之前我们一直在考虑的是表示正数的无符号数（unsigned），那么就存在可以同时表示正数和复数的有符号数（signed），而用于表示有符号的二进制数的表示方法常用的有两种：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-02-09T00:44:38+08:00">
    <meta property="article:modified_time" content="2021-02-09T00:44:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">我的西皮优学习笔记（五）-＞二进制及其表示法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>进制的运算</h2> 
<h3><a id="1_2"></a>1、十进制的对比分析</h3> 
<blockquote> 
 <p>在十进制的数字中，每一列的<font color="red" size="5">权</font>都是前一列的10倍，从右到左，每一列的权分别是1，10，100，1000…</p> 
 <p>看到十进制数的时候会发现其右下角有一个小小的10，这个小小的数称为十进制的c基,也就是说<font color="red">十进制的基是10</font></p> 
</blockquote> 
<p>例：比如说：2345这个数是个十进制数</p> 
<p>我们的一般就是个直接理解2345，这种思想是我们的常识思想，其实它真正的数字意义是在我们学习数字的时候刚开始的思维方式，</p> 
<p>两个一千，三个一百，四个10，五个1，拿过来作为机器思想的描述就是：</p> 
<p><strong>每一位上的数字乘上他们对应位的权，再将结果加起来得到最终的数值</strong></p> 
<h3><a id="2_16"></a>2、二进制</h3> 
<blockquote> 
 <p>每一位上的数字只有0和1两个值，最后将多位合并起来就组成了一个二进制数</p> 
 <p>二进制的<font color="red" size="5">基</font>是2</p> 
 <p>每一列的<font color="red" size="5">权</font>从右到左分别是：1，2，4，8，16…，以此类推，也就是说个位的权是2<sup>0,十位2</sup>1…等等，同样通过机器的思想去理解</p> 
 <p>二进制就是：每一位上的数字(0/1)去乘上对应位的权（2的几次方）</p> 
</blockquote> 
<h4><a id="1_26"></a>1）二进制转换为十进制</h4> 
<p>个位权对应十进制：1</p> 
<p>十位权对应十进制：2</p> 
<p>百位权对应十进制：4</p> 
<p>千位权对应十进制：8</p> 
<p>…</p> 
<p>例：1011</p> 
<p>描述过来就是：1 * 1+1 * 2+0 * 4 + 1 * 8</p> 
<p>通过二进制权对应的十进制的数来实现二进制到十进制的转化</p> 
<h4><a id="2_44"></a>2）十进制转二进制</h4> 
<p>比如说：给定十进制数84需要转换为二进制数</p> 
<p>那么84中含的二进制的最大权就是64</p> 
<p>所以64这一位上的数是1</p> 
<p>然后 通过 84+64 = 20</p> 
<p>64的下一位上的权是32，但是20&lt;32，所以32这一位上的数就是0</p> 
<p>32的下一位上的权是16，同时20&gt;16，所以16这一位上的数就是1</p> 
<p>以此类推</p> 
<p>得到的 84》》》1010100</p> 
<h3><a id="3_62"></a>3、半字节，字节和字</h3> 
<p>对于二进制 8位一组称为<strong>字节</strong>，它能表示2^8 = 256 个数字，计算机中存储数据习惯于用字节作为单位，而不是用位作为单位。</p> 
<p>4位的一组或者说半个字节称为<strong>半字节</strong>，能表示 2^4 = 16个数字（也就是一个十六进制数占用一个半字节），不常用，1024个字节称为1千字节（kilobyte ，KB），1024比特称为1千比特（kilobit，Kb或者Kbit），相似的MB，Mb称为兆字节，和兆比特，GB和Gb称为吉字节和吉比特。内存的容量一般用字节作为单位，但是信息传输率一般用比特/秒，作为单位。</p> 
<p>对于微处理器来说，处理的一块数据称为字，字的大小取决于微处理器的结构。64位的处理器表示对64位的字进行操作，32位的处理器</p> 
<p>对于32位的字进行处理。比较简单的微处理器也有8位或者16位字的</p> 
<p>**最低有效位：**在一组位中，权为1的那位称其为最低有效位（lsb）</p> 
<p>**最高有效位：**这组的位的另一端称为最高有效位（msb）</p> 
<p>对于一个字来说可以通过十六进制来表示，这样就可以通过<strong>最低有效字节和最高有效字节</strong>来表示：</p> 
<p>比如说：DEAFDAD8</p> 
<p>最低有效字节是D8</p> 
<p>最高有效字节是DE</p> 
<h3><a id="4_86"></a>4、二进制的溢出：</h3> 
<p>进行十进制的加法运算的时候经常会发生一个情况就是进位，比如说两个千位极的数相加就有可能生成一个万位级的数，但是正常在进行十进制的加法的时候并不会对这个有什么疑惑，因为十进制的数字加法一般是数字长度可变的，但是对于二进制的加法来说并不一样，一般在操作二进制数的时候都是操作的定长的数字。</p> 
<p>比如说在两个四位的二进制数相加的时候，就有可能会产生一个五位的二进制数，但是用于接收这个结果的还是四位的长度，那么此时就会产生溢出（overflow），这个时候<strong>会将生成的第五位抛弃</strong>。从而产生了一个不正确的结果。</p> 
<h3><a id="5_92"></a>5、有符号的二进制数</h3> 
<p>二进制用于表示数当然是可以表示正负的，之前我们一直在考虑的是表示正数的无符号数（unsigned），那么就存在可以同时表示正数和复数的有符号数（signed），而用于表示有符号的二进制数的表示方法常用的有两种：</p> 
<ul><li>带符号的原码</li><li>带符号的补码</li></ul> 
<h4><a id="1_99"></a>1）带符号的原码</h4> 
<p>将一个N位的二进制数进行区域设置，从左数的第一位，也就是最高位作为<strong>符号位</strong>，剩下的N-1位置为<strong>数值位</strong>，表示当前二进制数数值的绝对值。</p> 
<p>其中符号位上：</p> 
<ul><li>0表示正数</li><li>1表示负数</li></ul> 
<p>存在的问题就是，普通的二进制数运算无法在带符号的原码下完成，比如说，-5(10)和5(10)相加的结果理应是0，但是用带符号的二进制原码去计算：</p> 
<p>​ 1101(2) + 0101(2) = 10010(2)</p> 
<p>这样的计算结果很明显是错误且不合道理的。</p> 
<p><strong>表示范围：</strong>[-2<sup>(N-1)+1,2</sup>(N-1)-1]</p> 
<p>通过带符号的原码表示的时候0有两个表示方法：+0和-0 。同一个数字有两种不同的表示方法可能会造成麻烦。</p> 
<h4><a id="2_118"></a>2）带符号的补码</h4> 
<p>对于补码来说最高位的权是-2<sup>(N-1)，而不是2</sup>(N-1):</p> 
<p>因为对于二进制的补码来说正数的最高位是0，0111…11(2) = 2^(N-1) -1，复数的最高位是1，1000…000(2) = -2(N-1)。所以说最高位的权表示的是-2^(N-1），相应的最高位就可以作为符号位，因为正数的最高位都是0，负数的最高位都是1.</p> 
<p>而数值位在转换的时候也不一样：</p> 
<p>​ 无符号二进制数转换成有符号的二进制补码应该这样进行，首先将数扩一位，然后设置符号位，然后对对数据的每一位取反，然后在数据的最低位+1，因为二进制的补码表示0位0000000…000，具有唯一的标识方法，所以也可以进行普通的加法。</p> 
<p>示例：</p> 
<p>​ +2 的四位二进制补码表示为：0010</p> 
<p>​ -2 的四位二进制补码表示为：1101 -&gt; 1110</p> 
<p><strong>计算二进制补码负数的值：</strong></p> 
<p>​ 将二进制数1001(2)转换为十进制数：</p> 
<p>​ 首先最高位是1，所以这个数是一个负数，然后每位取反 0110，加1 ，0111 ，这个数的十进制表达为7，所以就是-7(10)</p> 
<p>​ 将二进制数0010(2) 转换为十进制数：</p> 
<p>​ 首先最高位是0，所以这个数一定是一个正数，然后直接进行转换，所以这个数是2(10)</p> 
<p><strong>补码的加法运算：</strong></p> 
<p>​ 计算 -2(10) + 1(20)</p> 
<p>​ 首先2 的二进制补码表达为0010，-2的二进制补码表达为1110(2)，1的二进制表达为0001，1的二进制补码表达为0010(2),两数相加，补码表达为1111(0)，转换成十进制数，先取反，0000(2)，加一,0001，所以计算的结果为-1</p> 
<p>​ 计算-7(10) + 7(10)</p> 
<p>​ 首先7的二进制表达是0111，7的二进制补码表达是0111(2)，-7的二进制补码表达是1001(2)，相加等于10000(2)，第五位抛弃，剩下的4位就是0000(2).</p> 
<p>综上补码的运算有以下这么几条原则：</p> 
<ol><li>当进行N位的数据加法时，第N位的进位，也就是N+1位的结果会被丢弃，就是说，虽然我是进行4位的计算，就是说可以根据直接的数值计算的方式去计算符号位，但是最后这个数如果有第5位直接把第五位丢弃，剩下的数的值就是二进制补码计算最后的值</li><li>二进制的减法计算用补码去表示就是，将二进制的负数表示成补码，然后和第一个操作数的补码进行相加。</li><li>四位二进制数补码虽然是四位的，其实表示的范围是[-2(N-1),2[N-1]]</li><li>计算0的二进制补码的时候，就是将所有的二进制位取法，111…11(2)，然后+1，最后舍弃掉最高位，因此0是唯一的，这和原码的系统不同，补码中0没有-0这一种表达方式，因此0的表达是唯一的，被认为是正数，因为它的符号位是0</li></ol> 
<h4><a id="3_163"></a>3）带符号的反码</h4> 
<p>对于一个二进制数来说，如果这个二进制数是正数，那么它的反码就是它本身，但是如果这个二进制数是负数，那么它的反码就是在其原码的基础上，符号位不变，其余的各个位取反。</p> 
<p>比如说：</p> 
<p>​ 1 的原码是 0001 ，它的反码是 0001</p> 
<p>​ -1 的原码是1001， 它的反码是1110</p> 
<p>两者相加：1 + （-1） = 0001 + 1110 = 1111(2) 然后取反 = 1000 = -0</p> 
<p>对于反码的计算来说，结果的真值部分也就是数值部分是正确的，但是问题就出现在0这个特殊的数值上，它有100000和00000这样的两种表达方式，于是才出现了补码来解决这样的问题。</p> 
<blockquote> 
 <p>出现这样问题的原因是：</p> 
 <p>​ 首先回顾一下人脑的计算方式，在人脑中不管是几进制都会根据符号判断加减运算，然后对真值区域进行加减，到那时对于计算机来说，加减乘除作为最基本的运算，要设计的尽可能的简单，让计算机去“辨别”符号位显然是一种非常复杂的设计，于是设计出能将符号位也参与运算的方法。根据运算原则的话，减去一个数相当于加上这个数的负数，所以计算机只有加法没有减法就会极大的遍历计算机运算的设计</p> 
</blockquote> 
<h4><a id="4_181"></a>4）小结</h4> 
<p>各种码之间的相互转换：</p> 
<ol><li>原码、补码、反码的正数表达都一样不需要转换</li><li>负数的原码转反码：符号位不变，真值位各位取反</li><li>负数的反码转原码：符号位不变，真值位各位取反</li><li>负数的原码转补码：符号位不变，真值位取反，末尾+1，舍掉溢出位</li><li>负数的补码转原码：符号位不变，真值位取反，末尾+1，舍掉溢出位</li><li>负数的反码转补码：末尾+1</li><li>负数的补码转反码：末尾-1（这里的反码是补码和反码指向的同一个原码的反码，而不是补码的反码）</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d997cbc647f6b92781fea7c9a267468/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PIL生成图像验证码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df454681f438c1edb33d5ed3a38837de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python矩阵运算库效率_python - 布尔矩阵运算的最快方法_performance_酷徒编程知识库...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>