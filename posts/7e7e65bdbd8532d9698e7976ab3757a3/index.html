<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode刷题 --- 前缀和 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/7e7e65bdbd8532d9698e7976ab3757a3/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="LeetCode刷题 --- 前缀和">
  <meta property="og:description" content="前缀和（Prefix Sum）
定义：前缀和是一种重要的预处理，能大大降低查询的时间复杂度。结合Hash缓存，能够进一步优化提升算法执行效率
prefixSum [0] = 0 【备注：此处不要定义prefix[0]=nums[0]，这种定义违背前缀和的意义】
prefixSum [1] = prefixSum[0] &#43; nums[0] = 0 &#43; num[0]
…
prefixSum [i] = prefixSum [i-1] &#43; nums [i]。
由此推导出两个变换公式： （1）nums[某一项] = 两个相邻 前缀和 之差：
nums[x] = prefixSum[x] - prefixSum[x - 1]
（2）从left到right的元素和等于prefixSum[right&#43;1] –prefixSum[left];
例题：
560. 和为 K 的子数组
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。
代码
public static int subarraySum(int[] nums, int k) { // 计算前缀和 int[] sum = new int[nums.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-26T11:15:24+08:00">
    <meta property="article:modified_time" content="2023-07-26T11:15:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode刷题 --- 前缀和</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前缀和（Prefix Sum）</p> 
<p>定义：前缀和是一种重要的预处理，能大大降低查询的时间复杂度。结合Hash缓存，能够进一步优化提升算法执行效率</p> 
<blockquote> 
 <p style="margin-left:.0001pt;">prefixSum [0] = <strong><span style="color:#ff0000;">0</span></strong> <strong><span style="color:#ff0000;">【备注：此处不要定义</span></strong><strong><span style="color:#ff0000;">prefix[0]=nums[0]</span></strong><strong><span style="color:#ff0000;">，这种定义违背前缀和的意义】</span></strong></p> 
 <p style="margin-left:.0001pt;">prefixSum [1] = prefixSum[0] + nums[0] = 0 + num[0]</p> 
 <p style="margin-left:.0001pt;">…</p> 
 <p style="margin-left:.0001pt;">prefixSum [i] = prefixSum [i-1] + nums [i]。</p> 
 <p style="margin-left:.0001pt;"></p> 
 <p style="margin-left:.0001pt;"><strong>由此推导出两个变换公式：</strong><strong> </strong></p> 
 <p style="margin-left:.0001pt;">（1）nums[某一项] = 两个相邻 前缀和 之差：</p> 
 <p style="margin-left:.0001pt;">nums[x] = prefixSum[x] - prefixSum[x - 1]</p> 
 <p style="margin-left:.0001pt;">（2）从left到right的元素和等于prefixSum[right+1] –prefixSum[left];</p> 
</blockquote> 
<p style="margin-left:.0001pt;"></p> 
<p style="margin-left:.0001pt;">例题：</p> 
<p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/" rel="nofollow" title="560. 和为 K 的子数组">560. 和为 K 的子数组</a></p> 
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code><strong> </strong>的连续子数组的个数 </em>。</p> 
<p>代码</p> 
<pre><code class="language-java">public static int subarraySum(int[] nums, int k) {
    // 计算前缀和
    int[] sum = new int[nums.length+1];
    sum[0] = 0;
    for (int i = 0; i &lt; nums.length; i++) {
        sum[i+1] = sum[i] + nums[i];
    }

    // 遍历数组，sum[j] - sum[i]就是i-j个元素的和，避免多次累加
    int count = 0;
    for (int i = 0; i &lt; sum.length; i++) {
        for (int j = i+1; j &lt; sum.length; j++) {
            if (sum[j] - sum[i] == k) {
                // 注意此处循环不能跳出，例如 [1,-1,0]，前两个为零，前三个相加也为零
                count++;
            }
        }
    }

    return count;
}</code></pre> 
<p> </p> 
<pre><code class="language-python">class Solution:
    def subarraySum(self, nums: List[int], k: int) -&gt; int:
        sumArry = [0]
        for i in nums:
            sumArry.append(sumArry[-1] + i)

        res = 0
        for i in range(len(sumArry)):
            for j in range(i + 1, len(sumArry)):
                if sumArry[j] - sumArry[i] == k:
                    res += 1

        return res</code></pre> 
<p></p> 
<p><a href="https://leetcode.cn/problems/continuous-subarray-sum/" rel="nofollow" title="523. 连续的子数组和">523. 连续的子数组和</a></p> 
<blockquote> 
 <p>题目</p> 
 <p>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：子数组大小 至少为 2 ，且子数组元素总和为 k 的倍数。<br> 如果存在，返回 true ；否则，返回 false 。如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数</p> 
 <p></p> 
 <p>分析：</p> 
 <p>        题目要求的是能够整除k 的连续子数组的和，因此可以考虑使用前缀和来求解 。</p> 
 <p>代码</p> 
 <pre><code class="language-java">public boolean checkSubarraySum1(int[] nums, int k) {
    // 长度小于2，直接返回false
    if(nums.length&lt;2) return false;
    
    // 求前缀和数组
    int[] ints = new int[nums.length+1];
    ints[0]=0;
    for (int i = 0; i &lt; nums.length; i++) {
        ints[i+1]=ints[i]+nums[i];
    }

    // 遍历前缀和数组，遇到满足要求的，返回true
    for (int i = 0; i &lt; ints.length; i++) {
        for (int j = i; j &lt; ints.length; j++) {
            int x = ints[j]- ints[i];
            if (j-i+1 &gt;2 &amp;&amp; (x)%k == 0){
                return true;
            }
        }
    }
    return false;
}</code></pre> 
 <p>很遗憾，这个解法在LeetCode上超时了，需要优化 0_o''</p> 
</blockquote> 
<p></p> 
<p>算法优化：</p> 
<blockquote> 
 <p>同余定理：</p> 
 <p>        如果两个数被同一个数整除后，余数相同，那么这两个数的差值可以被该数整除</p> 
 <p>推理公式：</p> 
 <p>        (sum[i] - sum[j]) % k == 0</p> 
 <p>        sum[i] % k == sum[j] % k</p> 
 <p>演变：</p> 
 <p>        如果数组前（i-1）个数字的和整除k后余数为r,那么前r个数字的和整除k后余数为(r+nums[i])%k;</p> 
 <p></p> 
 <p>代码</p> 
 <pre><code class="language-java">public boolean checkSubarraySum1(int[] nums, int k) {
    // 定义一个map，key存放前i个数组对K的余数，value存放上一个值为key的坐标
    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
    int remain = 0;
    for (int i = 0; i &lt; nums.length; i++) {
        // 使用同余定理转换的式子
        remain = (remain + nums[i]) % k;
        // 如果remain为0，说明前i 个数可以整除K
        // 只要i&gt;=1，就可以返回true
        if (remain == 0 &amp;&amp; i&gt;=1) {
            return true;
        }
        // 如果不存在这个余数，那么就存起来
        // value为第一次出现这个余数的坐标
        if (!map.containsKey(remain)) {
            map.put(remain, i);
        }
        // 如果已经存在这个余数了，那么可以用同余定理进行判断
        // 拿到上一次出现这个余数的坐标
        // 如果当前坐标减去之前的坐标大于等于2，那么说明有子数组可以整除K
        if (map.containsKey(remain) &amp;&amp; (i - map.get(remain)) &gt;=2) {
            return true;
        }
    }
    return false;
}
</code></pre> 
 <p>代码2</p> 
 <pre><code class="language-java">public boolean checkSubarraySum2(int[] nums, int k) {
    // 定义一个map,保存已经存在的前缀和，key是前缀和，value是第一次出现这个前缀和的坐标
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    // 定义左边界，即数组第0位开始之前的前缀和，值为0，坐标定义为-1；
    map.put(0, -1);
    // 定义x就是前缀和
    int x = 0;
    // 遍历数组
    for (int i = 0; i &lt; nums.length; i++) {
        // 求前缀和的公式
        x = (x + nums[i]) % k;
        // 已经出现过这个前缀和了，说明存在子数组的和刚好整除k
        if (map.containsKey(x)) {
            // 如果长度大于2，就返回true
            if ((i - map.get(x)) &gt;= 2) {
                return true;
            }
        } else {
            // 不存在这个前缀和，就把这个前缀和放到map中
            map.put(x, i);
        }
    }
    // 其余情况返回false。
    return false;
}</code></pre> 
 <pre><code class="language-python">    def checkSubarraySum1(self, nums: List[int], k: int) -&gt; bool:
        cur_dict = {0: -1}
        x = 0
        for index, value in enumerate(nums):
            x = (x + value) % k
            if x not in cur_dict.keys():
                cur_dict[x] = index
            else:
                if index - cur_dict.get(x) &gt;= 2:
                    return True
        return False</code></pre> 
 <p></p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/97d06b7db46a913070722471ef17504a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">YOLO 划分数据集（训练集、验证集、测试集）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fbc825696897b017233fd6785716e48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">存储简单了解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>