<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：堆和二叉树遍历 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/fcbe23e3baf50876458461d679d828de/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="数据结构：堆和二叉树遍历">
  <meta property="og:description" content="堆的特征 1.堆是一个完全二叉树
2.堆分为大堆和小堆。大堆：左右节点都小于根节点
小堆：左右节点都大于根节点
堆的应用：堆排序，topk问题
堆排序 堆排序的思路：
1.升序排序，建小堆。堆顶就是这个堆最小的数，堆顶和这个堆的最后一个数换位置，然后再把最后一个数取出，再pop这个数。就得到最小值。像这样每次取一个最小值，再删掉。依次把取出的数放在数组中，就得到升序排序了。
2.降序排序，建大堆。思路同升序一样。
上面说的是向下调整。向下调整就是每次取个数，由于和堆的最后一个数交换了位置，取出之后的二叉树需要调整一下才能成为一个堆。如果是大堆，就比较堆顶的和左右子树，大于它，堆顶和大的那个交换，这样层层交换下去。
如果一共有k层，最坏交换k次，如果是N个节点，就是log(N&#43;1)次。
堆排序就是排N个数嘛，时间复杂度就是O(N*logN)，空间复杂度就是O(N)。
向上调整：
向上调整可以应用于尾部插入数。调成一个大堆后停止。
对于一个随机数组，建大堆，向下调整法：
对于一个随机数组建小堆，向上调整法：
topk问题 如何从10000个数中取出最大的50个数？此问题也可以用于：内存空间不够，建堆数量有限，如何在大量的数据中取出前k个最大（小）的数。
答：先取出这些数据中前50(k)个建小堆，剩下的数和堆顶相比，遇到大于堆顶的数就直接替换掉堆顶的数。替换一次，小堆也要向下调整一次，保持它是一个小堆。这样比到最后一个数。就能保持这个小堆是这10000个数中最大的50个了。
如果是取出最小的50个数，那就是建大堆了。遇到比堆顶小的就替换、调整等。
二叉树的遍历 用链表建二叉树。
typedef struct BinaryNode { int val; struct BinaryNode* left; struct BinaryNode* right; }BTNode,*pBTNode; 如上述代码所示，树的一个节点存储三个值，一个是它的数据，一个是它指向的左子树指针，一个是指向右子树的指针。如果左子树和右子树都是空，就指向空。
这样由链表构建的一个二叉树。可以通过三种遍历方式来读取整个二叉树的数据。
前序：根----左子树----右子树
中序：左子树----根----右子树
后序：左子树----右子树----根
前中后序的命名是根据访问根的顺序来命名的。以前序遍历来举例：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-22T19:09:11+08:00">
    <meta property="article:modified_time" content="2024-03-22T19:09:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：堆和二叉树遍历</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>堆的特征</h4> 
<p>1.堆是一个完全二叉树</p> 
<p>2.堆分为大堆和小堆。大堆：左右节点都小于根节点</p> 
<p>小堆：左右节点都大于根节点</p> 
<p></p> 
<p>堆的应用：堆排序，topk问题</p> 
<p></p> 
<h4>堆排序</h4> 
<p>堆排序的思路：</p> 
<p>1.升序排序，建小堆。堆顶就是这个堆最小的数，堆顶和这个堆的最后一个数换位置，然后再把最后一个数取出，再pop这个数。就得到最小值。像这样每次取一个最小值，再删掉。依次把取出的数放在数组中，就得到升序排序了。</p> 
<p>2.降序排序，建大堆。思路同升序一样。</p> 
<p>上面说的是向下调整。向下调整就是每次取个数，由于和堆的最后一个数交换了位置，取出之后的二叉树需要调整一下才能成为一个堆。如果是大堆，就比较堆顶的和左右子树，大于它，堆顶和大的那个交换，这样层层交换下去。</p> 
<p><img alt="" height="962" src="https://images2.imgbox.com/ab/aa/siz073oq_o.png" width="1200"></p> 
<p><img alt="" height="489" src="https://images2.imgbox.com/15/f2/WcWvzZml_o.png" width="1200"></p> 
<p>如果一共有k层，最坏交换k次，如果是N个节点，就是log(N+1)次。</p> 
<p>堆排序就是排N个数嘛，时间复杂度就是O(N*logN)，空间复杂度就是O(N)。</p> 
<p></p> 
<p>向上调整：</p> 
<p>向上调整可以应用于尾部插入数。调成一个大堆后停止。</p> 
<p><img alt="" height="511" src="https://images2.imgbox.com/47/82/9uHSaed5_o.png" width="1170"></p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/fa/a2/uodyxYcF_o.png" width="1200"></p> 
<p></p> 
<p>对于一个随机数组，建大堆，向下调整法：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/3d/9e/D9SxjRES_o.png" width="1200"></p> 
<p></p> 
<p>对于一个随机数组建小堆，向上调整法：</p> 
<p><img alt="" height="1197" src="https://images2.imgbox.com/b2/b7/9LujiVHM_o.png" width="1200"></p> 
<p><img alt="" height="236" src="https://images2.imgbox.com/63/76/iLWBel62_o.png" width="253"></p> 
<p></p> 
<h4><strong>topk问题</strong></h4> 
<p>如何从10000个数中取出<strong><span style="color:#ff9900;">最大</span></strong>的50个数？此问题也可以用于：内存空间不够，建堆数量有限，如何在大量的数据中取出前k个<strong><span style="color:#ff9900;">最大</span></strong>（小）的数。</p> 
<p>答：先取出这些数据中前50(k)个建<strong><span style="color:#38d8f0;">小堆</span></strong>，剩下的数和堆顶相比，遇到大于堆顶的数就直接替换掉堆顶的数。替换一次，小堆也要向下调整一次，保持它是一个小堆。这样比到最后一个数。就能保持这个小堆是这10000个数中最大的50个了。</p> 
<p>如果是取出<span style="color:#ff9900;"><strong>最小</strong></span>的50个数，那就是建<strong><span style="color:#38d8f0;">大堆</span></strong>了。遇到比堆顶小的就替换、调整等。</p> 
<p></p> 
<h4>二叉树的遍历</h4> 
<p>用链表建二叉树。</p> 
<pre><code class="language-cpp">typedef struct BinaryNode
{
    int val;
    struct BinaryNode* left;
    struct BinaryNode* right;
}BTNode,*pBTNode;
</code></pre> 
<p>如上述代码所示，树的一个节点存储三个值，一个是它的数据，一个是它指向的左子树指针，一个是指向右子树的指针。如果左子树和右子树都是空，就指向空。</p> 
<p>这样由链表构建的一个二叉树。可以通过三种遍历方式来读取整个二叉树的数据。</p> 
<p>前序：根----左子树----右子树</p> 
<p>中序：左子树----根----右子树</p> 
<p>后序：左子树----右子树----根</p> 
<p>前中后序的命名是根据访问根的顺序来命名的。以前序遍历来举例：</p> 
<p><img alt="" height="885" src="https://images2.imgbox.com/9c/47/nHxwBWSp_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/08adad90f297dfd17fcc1656dfb54b1e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【JS】如何避免输入中文拼音时触发input事件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/63d631bd1d8f96fa8a1a0aaa1a963cbd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[ABC298D] Writing a Numeral</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>