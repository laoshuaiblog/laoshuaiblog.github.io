<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>lombok注解介绍 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/97a3db278c5f3f821f23238d41a442a6/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="lombok注解介绍">
  <meta property="og:description" content="lombok注解介绍 lombok注解文档 lombok官网下载
lombok是一个可以帮助我们简化java代码编写的工具类，尤其是简化javabean的编写，即通过采用注解的方式，消除代码中的构造方法，getter/setter等代码，使我们写的类更加简洁，当然，这带来的副作用就是不易阅读…不过，还是能看得懂吧，废话不多说，先看一下lombok支持的一些常见的注解。
@NonNull@Cleanup@Getter/@Setter@ToString@EqualsAndHashCode@NoArgsConstructor/@RequiredArgsConstructor /@AllArgsConstructor@Data@Value@SneakyThrows@Synchronized@Log @NonNull 这个注解可以用在成员方法或者构造方法的参数前面，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，举个例子来看看：
//成员方法参数加上@NonNull注解 public String getName(@NonNull Person p){ return p.getName(); } 实际效果相当于：
public String getName(@NonNull Person p){ if(p==null){ throw new NullPointerException(&#34;person&#34;); } return p.getName(); } 用在构造方法的参数上效果类似，就不再举例子了。
@Cleanup 这个注解用在变量前面，可以保证此变量代表的资源会被自动关闭，默认是调用资源的close()方法，如果该资源有其它关闭方法，可使用@Cleanup(“methodName”)来指定要调用的方法，就用输入输出流来举个例子吧：
public static void main(String[] args) throws IOException { @Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[1024]; while (true) { int r = in.read(b); if (r == -1) break; out.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-12-09T17:49:43+08:00">
    <meta property="article:modified_time" content="2016-12-09T17:49:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">lombok注解介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="lombok注解介绍">lombok注解介绍</h2> 
<p><a href="https://projectlombok.org/features/index.html" rel="nofollow">lombok注解文档</a> <br> <a href="https://projectlombok.org/" rel="nofollow">lombok官网下载</a></p> 
<p>lombok是一个可以帮助我们简化java代码编写的工具类，尤其是简化javabean的编写，即通过采用注解的方式，消除代码中的构造方法，getter/setter等代码，使我们写的类更加简洁，当然，这带来的副作用就是不易阅读…不过，还是能看得懂吧，废话不多说，先看一下lombok支持的一些常见的注解。</p> 
<ol><li><strong>@NonNull</strong></li><li><strong>@Cleanup</strong></li><li><strong>@Getter/@Setter</strong></li><li><strong>@ToString</strong></li><li><strong>@EqualsAndHashCode</strong></li><li><strong>@NoArgsConstructor/@RequiredArgsConstructor /@AllArgsConstructor</strong></li><li><strong>@Data</strong></li><li><strong>@Value</strong></li><li><strong>@SneakyThrows</strong></li><li><strong>@Synchronized</strong></li><li><strong>@Log</strong></li></ol> 
<hr> 
<h3 id="nonnull">@NonNull</h3> 
<p>这个注解可以用在成员方法或者构造方法的参数前面，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，举个例子来看看：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//成员方法参数加上@NonNull注解</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>(@NonNull Person p){
    <span class="hljs-keyword">return</span> p.getName();
}</code></pre> 
<p>实际效果相当于：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>(@NonNull Person p){
    <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span>){
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"person"</span>);
    }
    <span class="hljs-keyword">return</span> p.getName();
}</code></pre> 
<p>用在构造方法的参数上效果类似，就不再举例子了。</p> 
<h3 id="cleanup">@Cleanup</h3> 
<p>这个注解用在变量前面，可以保证此变量代表的资源会被自动关闭，默认是调用资源的close()方法，如果该资源有其它关闭方法，可使用@Cleanup(“methodName”)来指定要调用的方法，就用输入输出流来举个例子吧：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> IOException {
     <span class="hljs-annotation">@Cleanup</span> InputStream in = <span class="hljs-keyword">new</span> FileInputStream(args[<span class="hljs-number">0</span>]);
     <span class="hljs-annotation">@Cleanup</span> OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(args[<span class="hljs-number">1</span>]);
     <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];
     <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
       <span class="hljs-keyword">int</span> r = in.read(b);
       <span class="hljs-keyword">if</span> (r == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;
       out.write(b, <span class="hljs-number">0</span>, r);
     }
 }</code></pre> 
<p>实际效果相当于：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> IOException {
     InputStream in = <span class="hljs-keyword">new</span> FileInputStream(args[<span class="hljs-number">0</span>]);
     <span class="hljs-keyword">try</span> {
       OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(args[<span class="hljs-number">1</span>]);
       <span class="hljs-keyword">try</span> {
         <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10000</span>];
         <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
           <span class="hljs-keyword">int</span> r = in.read(b);
           <span class="hljs-keyword">if</span> (r == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;
           out.write(b, <span class="hljs-number">0</span>, r);
         }
       } <span class="hljs-keyword">finally</span> {
         <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>) {
           out.close();
         }
       }
     } <span class="hljs-keyword">finally</span> {
       <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>) {
         in.close();
       }
    }
}</code></pre> 
<p>是不是简化了很多。</p> 
<h3 id="gettersetter">@Getter/@Setter</h3> 
<p>这一对注解从名字上就很好理解，用在成员变量前面，相当于为成员变量生成对应的get和set方法，同时还可以为生成的方法指定访问修饰符，当然，默认为public，直接来看下面的简单的例子：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Programmer</span>{<!-- --></span>
    <span class="hljs-annotation">@Getter</span>
    <span class="hljs-annotation">@Setter</span>
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-annotation">@Setter</span>(AccessLevel.PROTECTED)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-annotation">@Getter</span>(AccessLevel.PUBLIC)
    <span class="hljs-keyword">private</span> String language;
}</code></pre> 
<p>实际效果相当于：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Programmer</span>{<!-- --></span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">private</span> String language;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name){
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>(){
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age){
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getLanguage</span>(){
        <span class="hljs-keyword">return</span> language;
    }
}</code></pre> 
<p>这两个注解还可以直接用在类上，可以为此类里的所有<strong>非静态</strong>成员变量生成对应的get和set方法。</p> 
<h3 id="tostringequalsandhashcode">@ToString/@EqualsAndHashCode</h3> 
<p>这两个注解也比较好理解，就是生成toString，equals和hashcode方法，同时后者还会生成一个canEqual方法，用于判断某个对象是否是当前类的实例，生成方法时只会使用类中的<strong>非静态</strong>和<strong>非transient</strong>成员变量，这些都比较好理解，就不举例子了。 <br> 当然，这两个注解也可以添加限制条件，例如用@ToString(exclude={“param1”，“param2”})来排除param1和param2两个成员变量，或者用@ToString(of={“param1”，“param2”})来指定使用param1和param2两个成员变量，@EqualsAndHashCode注解也有同样的用法。</p> 
<h3 id="noargsconstructorrequiredargsconstructor-allargsconstructor">@NoArgsConstructor/@RequiredArgsConstructor /@AllArgsConstructor</h3> 
<p>这三个注解都是用在类上的，第一个和第三个都很好理解，就是为该类产生无参的构造方法和包含所有参数的构造方法，第二个注解则使用类中所有带有@NonNull注解的或者带有final修饰的成员变量生成对应的构造方法，当然，和前面几个注解一样，成员变量都是<strong>非静态</strong>的，另外，如果类中含有final修饰的成员变量，是无法使用@NoArgsConstructor注解的。 <br> 三个注解都可以指定生成的构造方法的访问权限，同时，第二个注解还可以用@RequiredArgsConstructor(staticName=”methodName”)的形式生成一个指定名称的静态方法，返回一个调用相应的构造方法产生的对象，下面来看一个生动鲜活的例子：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-annotation">@RequiredArgsConstructor</span>(staticName = <span class="hljs-string">"sunsfan"</span>)
<span class="hljs-annotation">@AllArgsConstructor</span>(access = AccessLevel.PROTECTED)
<span class="hljs-annotation">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;
    <span class="hljs-annotation">@NonNull</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> y;
    <span class="hljs-annotation">@NonNull</span>
    <span class="hljs-keyword">private</span> String name;
}</code></pre> 
<p>实际效果相当于：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> y;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-keyword">public</span> <span class="hljs-title">Shape</span>(){
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-title">Shape</span>(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">double</span> y,String name){
        <span class="hljs-keyword">this</span>.x = x;
        <span class="hljs-keyword">this</span>.y = y;
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">Shape</span>(<span class="hljs-keyword">double</span> y,String name){
        <span class="hljs-keyword">this</span>.y = y;
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Shape <span class="hljs-title">sunsfan</span>(<span class="hljs-keyword">double</span> y,String name){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Shape(y,name);
    }
}</code></pre> 
<h3 id="datavalue">@Data/@Value</h3> 
<p>呃!! <br> @Data注解综合了3,4,5和6里面的@RequiredArgsConstructor注解，其中@RequiredArgsConstructor使用了类中的带有@NonNull注解的或者final修饰的成员变量，它可以使用@Data(staticConstructor=”methodName”)来生成一个静态方法，返回一个调用相应的构造方法产生的对象。这个例子就也省略了吧… <br> @Value注解和@Data类似，区别在于它会把所有成员变量默认定义为private final修饰，并且不会生成set方法。</p> 
<h3 id="sneakythrows">@SneakyThrows</h3> 
<p>这个注解用在方法上，可以将方法中的代码用try-catch语句包裹起来，捕获异常并在catch中用Lombok.sneakyThrow(e)把异常抛出，可以使用@SneakyThrows(Exception.class)的形式指定抛出哪种异常，很简单的注解，直接看个例子：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SneakyThrows</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> {<!-- --></span>
    <span class="hljs-annotation">@SneakyThrows</span>(UnsupportedEncodingException.class)
    <span class="hljs-keyword">public</span> String <span class="hljs-title">utf8ToString</span>(<span class="hljs-keyword">byte</span>[] bytes) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes, <span class="hljs-string">"UTF-8"</span>);
    }

    <span class="hljs-annotation">@SneakyThrows</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Throwable();
    }
}</code></pre> 
<p>实际效果相当于：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SneakyThrows</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> {<!-- --></span>
    <span class="hljs-annotation">@SneakyThrows</span>(UnsupportedEncodingException.class)
    <span class="hljs-keyword">public</span> String <span class="hljs-title">utf8ToString</span>(<span class="hljs-keyword">byte</span>[] bytes) {
        <span class="hljs-keyword">try</span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes, <span class="hljs-string">"UTF-8"</span>);
        }<span class="hljs-keyword">catch</span>(UnsupportedEncodingException uee){
            <span class="hljs-keyword">throw</span> Lombok.sneakyThrow(uee);
        }
    }

    <span class="hljs-annotation">@SneakyThrows</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
        <span class="hljs-keyword">try</span>{
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Throwable();
        }<span class="hljs-keyword">catch</span>(Throwable t){
            <span class="hljs-keyword">throw</span> Lombok.sneakyThrow(t);
        }
    }
}</code></pre> 
<h3 id="synchronized">@Synchronized</h3> 
<p>这个注解用在类方法或者实例方法上，效果和synchronized关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized关键字的锁对象分别是类的class对象和this对象，而@Synchronized得锁对象分别是私有静态final对象<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame"> 
   
   <span class="math" id="MathJax-Span-1" style="width: 11.843em; display: inline-block;"><span style="display: inline-block; position: relative; width: 9.443em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.603em 1000em 2.936em -0.424em); top: -2.557em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">L</span><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">O</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math-italic;">C<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.056em;"></span></span><span class="mi" id="MathJax-Span-6" style="font-family: MathJax_Math-italic;">K<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.056em;"></span></span><span class="texatom" id="MathJax-Span-7"><span class="mrow" id="MathJax-Span-8"><span class="mo" id="MathJax-Span-9"><span style='font-family: STIXGeneral, "Arial Unicode MS", serif; font-size: 80%; font-style: normal; font-weight: normal;'>和</span></span></span></span><span class="texatom" id="MathJax-Span-10"><span class="mrow" id="MathJax-Span-11"><span class="mo" id="MathJax-Span-12"><span style='font-family: STIXGeneral, "Arial Unicode MS", serif; font-size: 80%; font-style: normal; font-weight: normal;'>私</span></span></span></span><span class="texatom" id="MathJax-Span-13"><span class="mrow" id="MathJax-Span-14"><span class="mo" id="MathJax-Span-15"><span style='font-family: STIXGeneral, "Arial Unicode MS", serif; font-size: 80%; font-style: normal; font-weight: normal;'>有</span></span></span></span><span class="mi" id="MathJax-Span-16" style="font-family: MathJax_Math-italic;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.056em;"></span></span><span class="mi" id="MathJax-Span-17" style="font-family: MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-18" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-20" style="font-family: MathJax_Math-italic;">l</span><span class="texatom" id="MathJax-Span-21"><span class="mrow" id="MathJax-Span-22"><span class="mo" id="MathJax-Span-23"><span style='font-family: STIXGeneral, "Arial Unicode MS", serif; font-size: 80%; font-style: normal; font-weight: normal;'>对</span></span></span></span><span class="texatom" id="MathJax-Span-24"><span class="mrow" id="MathJax-Span-25"><span class="mo" id="MathJax-Span-26"><span style='font-family: STIXGeneral, "Arial Unicode MS", serif; font-size: 80%; font-style: normal; font-weight: normal;'>象</span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.33em;"></span></span> 
  </span><script type="math/tex" id="MathJax-Element-1">LOCK和私有final对象</script>lock，当然，也可以自己指定锁对象，例子也很简单，往下看：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Synchronized</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object readLock = <span class="hljs-keyword">new</span> Object();

    <span class="hljs-annotation">@Synchronized</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>() {
        System.out.println(<span class="hljs-string">"world"</span>);
    }

    <span class="hljs-annotation">@Synchronized</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">answerToLife</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
    }

    <span class="hljs-annotation">@Synchronized</span>(<span class="hljs-string">"readLock"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span>() {
        System.out.println(<span class="hljs-string">"bar"</span>);
    }
}</code></pre> 
<p>实际效果相当于：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Synchronized</span> {<!-- --></span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object $LOCK = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>];
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object $lock = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>];
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object readLock = <span class="hljs-keyword">new</span> Object();

   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>() {
     <span class="hljs-keyword">synchronized</span>($LOCK) {
       System.out.println(<span class="hljs-string">"world"</span>);
     }
   }

   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">answerToLife</span>() {
     <span class="hljs-keyword">synchronized</span>($lock) {
       <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
     }
   }

   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span>() {
     <span class="hljs-keyword">synchronized</span>(readLock) {
       System.out.println(<span class="hljs-string">"bar"</span>);
     }
   }
 }</code></pre> 
<h3 id="log">@Log</h3> 
<p>这个注解用在类上，可以省去从日志工厂生成日志对象这一步，直接进行日志记录，具体注解根据日志工具的不同而不同，同时，可以在注解中使用topic来指定生成log对象时的类名。不同的日志注解总结如下(上面是注解，下面是实际作用)：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-annotation">@CommonsLog</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);
<span class="hljs-annotation">@JBossLog</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);
<span class="hljs-annotation">@Log</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());
<span class="hljs-annotation">@Log</span>4j
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);
<span class="hljs-annotation">@Log</span>4j2
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);
<span class="hljs-annotation">@Slf</span>4j
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);
<span class="hljs-annotation">@XSlf</span>4j
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);</code></pre> 
<p>关于lombok的注解先写到这里，当然，还有其他一些注解需要大家自己去摸索，同时lombok一直在扩展，将来肯定会加入更多的注解元素，拭目以待了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f90185d659251429c30a4097746441a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Asp.Net WebForm 母版页&#43;用户控件的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45024ecb6803cdc4aee4c02eb465be96/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Asp.Net Cookie 和 Session 的编写、读取 和 删除</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>