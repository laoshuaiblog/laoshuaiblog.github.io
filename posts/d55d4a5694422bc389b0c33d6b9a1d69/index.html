<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java高级编程——Java反射机制 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/d55d4a5694422bc389b0c33d6b9a1d69/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Java高级编程——Java反射机制">
  <meta property="og:description" content="Java高级编程——Java反射机制 目录
Java高级编程——Java反射机制
一、Java反射机制概述
1.Java Reflection
2.补充：动态语言 vs 静态语言
3.Java反射机制研究及应用
4.反射相关的主要API
二、理解Class类并获取Class实例
1.Class 类
2. Class类的常用方法
3.反射的应用举例
4.获取Class类的实例 (四种方法)
5.哪些类型可以有Class对象？
上代码
三、类的加载与ClassLoader的理解
1.了解：类的加载过程
2.了解：什么时候会发生类初始化？
3.了解：ClassLoader
上代码
四、创建运行时类的对象
1.有了Class对象，能做什么？
上代码
五、获取运行时类的完整结构
1.通过反射获取运行时类的完整结构
2.小 结
上代码
六、调用运行时类的指定结构
1.调用指定方法
2.调用指定属性
3.关于setAccessible方法的使用
上代码
七、反射的应用：动态代理
1.代理设计模式的原理
2.Java动态代理相关API
3.动态代理步骤
4.动态代理与AOP（Aspect Orient Programming)
代码演示
静态代理
动态代理
一、Java反射机制概述 1.Java Reflection 2.补充：动态语言 vs 静态语言 框架 =反射 &#43; 注解 &#43; 设计模式
3.Java反射机制研究及应用 4.反射相关的主要API 二、理解Class类并获取Class实例 1.Class 类 2. Class类的常用方法 3.反射的应用举例 4.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-06-27T22:16:19+08:00">
    <meta property="article:modified_time" content="2023-06-27T22:16:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java高级编程——Java反射机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6" style="text-align:center;">Java高级编程——Java反射机制</h2> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-toc" style="margin-left:0px;"><a href="#Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6" rel="nofollow">Java高级编程——Java反射机制</a></p> 
<p id="%C2%A0%E4%B8%80%E3%80%81Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80%E3%80%81Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0" rel="nofollow"> 一、Java反射机制概述</a></p> 
<p id="1.Java%20Reflection-toc" style="margin-left:40px;"> <a href="#1.Java%20Reflection" rel="nofollow">1.Java Reflection</a></p> 
<p id="%C2%A02.%E8%A1%A5%E5%85%85%EF%BC%9A%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%20vs%20%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80-toc" style="margin-left:40px;"><a href="#%C2%A02.%E8%A1%A5%E5%85%85%EF%BC%9A%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%20vs%20%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80" rel="nofollow"> 2.补充：动态语言 vs 静态语言</a></p> 
<p id="%C2%A03.Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%8F%8A%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A03.Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%8F%8A%E5%BA%94%E7%94%A8" rel="nofollow"> 3.Java反射机制研究及应用</a></p> 
<p id="%C2%A04.%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%BB%E8%A6%81API-toc" style="margin-left:40px;"><a href="#%C2%A04.%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%BB%E8%A6%81API" rel="nofollow"> 4.反射相关的主要API</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%90%86%E8%A7%A3Class%E7%B1%BB%E5%B9%B6%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%90%86%E8%A7%A3Class%E7%B1%BB%E5%B9%B6%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B" rel="nofollow">二、理解Class类并获取Class实例</a></p> 
<p id="1.Class%20%E7%B1%BB-toc" style="margin-left:40px;"> <a href="#1.Class%20%E7%B1%BB" rel="nofollow">1.Class 类</a></p> 
<p id="%C2%A02.%C2%A0Class%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A02.%C2%A0Class%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow"> 2. Class类的常用方法</a></p> 
<p id="%C2%A03.%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%C2%A03.%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B" rel="nofollow"> 3.反射的应用举例</a></p> 
<p id="%C2%A04.%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%20(%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95)-toc" style="margin-left:40px;"><a href="#%C2%A04.%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%20%28%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%29" rel="nofollow"> 4.获取Class类的实例 (四种方法)</a></p> 
<p id="%C2%A05.%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%9C%89Class%E5%AF%B9%E8%B1%A1%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%C2%A05.%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%9C%89Class%E5%AF%B9%E8%B1%A1%EF%BC%9F" rel="nofollow"> 5.哪些类型可以有Class对象？</a></p> 
<p id="%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow"> 上代码</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">三、类的加载与ClassLoader的理解</a></p> 
<p id="1.%E4%BA%86%E8%A7%A3%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"> <a href="#1.%E4%BA%86%E8%A7%A3%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" rel="nofollow">1.了解：类的加载过程</a></p> 
<p id="%C2%A02.%E4%BA%86%E8%A7%A3%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%C2%A02.%E4%BA%86%E8%A7%A3%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F" rel="nofollow"> 2.了解：什么时候会发生类初始化？</a></p> 
<p id="%C2%A03.%E4%BA%86%E8%A7%A3%EF%BC%9AClassLoader-toc" style="margin-left:40px;"><a href="#%C2%A03.%E4%BA%86%E8%A7%A3%EF%BC%9AClassLoader" rel="nofollow"> 3.了解：ClassLoader</a></p> 
<p id="%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow"> 上代码</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1" rel="nofollow">四、创建运行时类的对象</a></p> 
<p id="1.%E6%9C%89%E4%BA%86Class%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"> <a href="#1.%E6%9C%89%E4%BA%86Class%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">1.有了Class对象，能做什么？</a></p> 
<p id="%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow"> 上代码</a></p> 
<p id="%E4%BA%94%E3%80%81%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84" rel="nofollow">五、获取运行时类的完整结构</a></p> 
<p id="1.%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"> <a href="#1.%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84" rel="nofollow">1.通过反射获取运行时类的完整结构</a></p> 
<p id="%C2%A02.%E5%B0%8F%20%E7%BB%93-toc" style="margin-left:40px;"><a href="#%C2%A02.%E5%B0%8F%20%E7%BB%93" rel="nofollow"> 2.小 结</a></p> 
<p id="%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow">上代码</a></p> 
<p id="%E5%85%AD%E3%80%81%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84" rel="nofollow">六、调用运行时类的指定结构</a></p> 
<p id="1.%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"> <a href="#1.%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95" rel="nofollow">1.调用指定方法</a></p> 
<p id="%C2%A02.%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#%C2%A02.%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7" rel="nofollow"> 2.调用指定属性</a></p> 
<p id="%C2%A03.%E5%85%B3%E4%BA%8EsetAccessible%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A03.%E5%85%B3%E4%BA%8EsetAccessible%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow"> 3.关于setAccessible方法的使用</a></p> 
<p id="%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow"> 上代码</a></p> 
<p id="%E4%B8%83%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">七、反射的应用：动态代理</a></p> 
<p id="1.%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"> <a href="#1.%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">1.代理设计模式的原理</a></p> 
<p id="%C2%A02.Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9B%B8%E5%85%B3API-toc" style="margin-left:40px;"><a href="#%C2%A02.Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9B%B8%E5%85%B3API" rel="nofollow"> 2.Java动态代理相关API</a></p> 
<p id="%C2%A03.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#%C2%A03.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%A5%E9%AA%A4" rel="nofollow"> 3.动态代理步骤</a></p> 
<p id="%C2%A04.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EAOP%EF%BC%88Aspect%20Orient%20Programming)-toc" style="margin-left:40px;"><a href="#%C2%A04.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EAOP%EF%BC%88Aspect%20Orient%20Programming%29" rel="nofollow"> 4.动态代理与AOP（Aspect Orient Programming)</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow"> 代码演示</a></p> 
<p id="%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:120px;"><a href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">静态代理</a></p> 
<p id="%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:120px;"><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">动态代理</a></p> 
<hr> 
<h2 id="%C2%A0%E4%B8%80%E3%80%81Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"> 一、Java反射机制概述</h2> 
<h3 id="1.Java%20Reflection">1.Java Reflection</h3> 
<p class="img-center"><img alt="" height="344" src="https://images2.imgbox.com/27/76/0VIZAV22_o.png" width="775"></p> 
<h3 id="%C2%A02.%E8%A1%A5%E5%85%85%EF%BC%9A%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%20vs%20%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80"> 2.补充：动态语言 vs 静态语言</h3> 
<p class="img-center"><img alt="" height="332" src="https://images2.imgbox.com/00/bd/vA4ts3OK_o.png" width="744"></p> 
<blockquote> 
 <p style="text-align:center;"><span style="color:#fe2c24;"><strong> 框架 =反射 + 注解 + 设计模式</strong></span></p> 
</blockquote> 
<h3 id="%C2%A03.Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%8F%8A%E5%BA%94%E7%94%A8"> 3.Java反射机制研究及应用</h3> 
<p class="img-center"><img alt="" height="391" src="https://images2.imgbox.com/5f/04/9J2hyePX_o.png" width="775"></p> 
<h3 id="%C2%A04.%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%BB%E8%A6%81API"> 4.反射相关的主要API</h3> 
<p class="img-center"><img alt="" height="291" src="https://images2.imgbox.com/dd/ff/tUsRC0PO_o.png" width="733"></p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%90%86%E8%A7%A3Class%E7%B1%BB%E5%B9%B6%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B">二、理解Class类并获取Class实例</h2> 
<h3 id="1.Class%20%E7%B1%BB">1.Class 类</h3> 
<p class="img-center"><img alt="" height="289" src="https://images2.imgbox.com/46/2f/hISknL3r_o.png" width="748"></p> 
<p class="img-center"><img alt="" height="298" src="https://images2.imgbox.com/c9/04/RgknzMOx_o.png" width="739"></p> 
<h3 id="%C2%A02.%C2%A0Class%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"> 2. Class类的常用方法</h3> 
<p class="img-center"><img alt="" height="312" src="https://images2.imgbox.com/13/97/UDA1mSik_o.png" width="728"></p> 
<h3 id="%C2%A03.%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"> 3.反射的应用举例</h3> 
<p class="img-center"><img alt="" height="256" src="https://images2.imgbox.com/fd/ef/QDKCoBXP_o.png" width="401"></p> 
<h3 id="%C2%A04.%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%20(%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95)"> 4.获取Class类的实例 (四种方法)</h3> 
<p class="img-center"><img alt="" height="306" src="https://images2.imgbox.com/66/6b/44O6ysma_o.png" width="717"></p> 
<h3 id="%C2%A05.%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%9C%89Class%E5%AF%B9%E8%B1%A1%EF%BC%9F"> 5.哪些类型可以有Class对象？</h3> 
<p class="img-center"><img alt="" height="273" src="https://images2.imgbox.com/f1/17/OFLXQMsy_o.png" width="723"></p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/1c/a6/lZhh2dsK_o.png" width="1200"></p> 
<h4 id="%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81"> 上代码</h4> 
<pre><code class="language-java">package com.tyl.java;

import org.junit.Test;

import java.lang.annotation.ElementType;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename: ReflectionTest
 * @create 2023-06-19 21:08
 *
 *
 */
public class ReflectionTest {

    // 反射之前，对于Person的操作
    @Test
    public void test1(){
        // 1.创建Person类的对象
        Person p1 = new Person("tyl", 20);

        // 2.通过对象，调用其内部的属性、方法
        p1.age = 10;
        System.out.println(p1.toString());

        p1.show();

        // 在Person类外部，不可以通过Person类的对象调用其内部私有结构。
        // 比如：name、showNation() 以及私有的构造器

    }

    // 反射之后，对于Person的操作
    @Test
    public void test2() throws Exception {
        Class clazz = Person.class;

        // 1.通过反射，创建Person类的对象
        Constructor cons = clazz.getConstructor(String.class, int.class);
        Object obj = cons.newInstance("tyl", 22);
        Person p = (Person) obj;
        System.out.println(p.toString());

        // 2.通过反射，调用对象指定的属性、方法
        // 调用属性
        Field age = clazz.getDeclaredField("age");
        age.set(p,10);
        System.out.println(p.toString());

        // 调用方法
        Method show = clazz.getDeclaredMethod("show");
        show.invoke(p);

        System.out.println("************************************************");
        // 通过反射，可以调用Person类的私有结构的。比如：私有的构造器、方法、属性
        // 调用私有的构造器
        Constructor cons1 = clazz.getDeclaredConstructor(String.class);
        cons1.setAccessible(true);
        Object p1 = cons1.newInstance("wc");
        Person p2 = (Person) p1;
        System.out.println(p2);

        // 调用私有的属性
        Field name = clazz.getDeclaredField("name");
        name.setAccessible(true);
        name.set(p2,"xxxx");
        System.out.println(p2);

        // 调用私有的方法
        Method showNation = clazz.getDeclaredMethod("showNation", String.class);
        showNation.setAccessible(true);
        String nation = (String) showNation.invoke(p2, "china");
        System.out.println(nation);

    }

    // 疑问1：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用那个？
    // 建议：直接new的方式。
    // 什么时候会使用：反射的方式。反射的特征：动态性

    // 疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？
    // 不矛盾


    /*
    关于java.Lang.CLass类的理解
    1.类的加载过程：
        程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。
    接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件
    加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此
    运行时类，就作为Class的一个实例。

    2.换句话说，CLass的实例就对应着一个运行时类。

    3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式
      来获取此运行时类。
     */

    //获取Class的实例的方式 （前三种方式需要掌握）
    @Test
    public void test3() throws ClassNotFoundException {

        // 方式一：调用运行时类的属性：.cLass
        Class&lt;Person&gt; clazz1 = Person.class;
        System.out.println(clazz1);

        // 方式二：通过运行时类的对象，调用getCLass（）
        Person p1 = new Person();
        Class clazz2 = p1.getClass();
        System.out.println(clazz2);

        // 方式三：调用CLass的静态方法：forName(String cLassPath). 常用
        Class clazz3 = Class.forName("com.tyl.java.Person");
//        Class clazz3 = Class.forName("java.lang.String");
        System.out.println(clazz3);

        System.out.println(clazz1 == clazz2); // true
        System.out.println(clazz1 == clazz3); // true

        // 方式四：使用类的加载器：CLassLoader
        ClassLoader classLoader = ReflectionTest.class.getClassLoader();
        Class clazz4 = classLoader.loadClass("com.tyl.java.Person");
        System.out.println(clazz4);

        System.out.println(clazz1 == clazz4); // true


    }


    // 万事万物皆对象？对象, XXX, FiLe, URL, 反射，前端、数据库操作


    // CLass实例可以是哪些结构的说明：
    @Test
    public void test4(){

        Class c1 = Object.class;
        Class c2 = Comparable.class;
        Class c3 = String[].class;
        Class c4 = int[][].class;
        Class c5 = ElementType.class;
        Class c6 = Override.class;
        Class c7 = int.class;
        Class c8 = void.class;
        Class c9 = Class.class;

        int[] a = new int[10];
        int[] b = new int[100];
        Class c10 = a.getClass();
        Class c11 = b.getClass();

        // 只要数组的元素类型与维度一样，就是同一个Class
        System.out.println(c10 == c11);

    }


}
</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3">三、类的加载与ClassLoader的理解</h2> 
<h3 id="1.%E4%BA%86%E8%A7%A3%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">1.了解：类的加载过程</h3> 
<p class="img-center"><img alt="" height="327" src="https://images2.imgbox.com/50/0e/tRv7bRkE_o.png" width="674"></p> 
<p class="img-center"><img alt="" height="340" src="https://images2.imgbox.com/0d/56/pF3sUZxi_o.png" width="657"></p> 
<p class="img-center"><img alt="" height="375" src="https://images2.imgbox.com/0e/f2/3QMEdDNP_o.png" width="677"></p> 
<h3 id="%C2%A02.%E4%BA%86%E8%A7%A3%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"> 2.了解：什么时候会发生类初始化？</h3> 
<p class="img-center"><img alt="" height="298" src="https://images2.imgbox.com/13/b5/fh4Oipnz_o.png" width="688"></p> 
<p class="img-center"><img alt="" height="346" src="https://images2.imgbox.com/65/f8/vo5XmdTO_o.png" width="662"></p> 
<p class="img-center"><img alt="" height="335" src="https://images2.imgbox.com/60/71/fA1BBjmG_o.png" width="664"></p> 
<h3 id="%C2%A03.%E4%BA%86%E8%A7%A3%EF%BC%9AClassLoader"> 3.了解：ClassLoader</h3> 
<p class="img-center"><img alt="" height="296" src="https://images2.imgbox.com/d8/3d/acU5ZiZr_o.png" width="658"></p> 
<p class="img-center"><img alt="" height="319" src="https://images2.imgbox.com/ce/a7/Q64THsKz_o.png" width="660"></p> 
<p class="img-center"><img alt="" height="246" src="https://images2.imgbox.com/4f/57/dusl7Mp9_o.png" width="673"></p> 
<h4> 上代码</h4> 
<pre><code class="language-java">package com.tyl.java;

import org.junit.Test;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename: ClassLoaderTest
 * @create 2023-06-20 18:10
 *
 * 了解类的加载器
 */
public class ClassLoaderTest {
    @Test
    public void test1(){
        // 对于自定义类，使用系统类加载器进行加载
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);

        // 调用系统类加载器的getParent（）:获取扩展类加载器
        ClassLoader classLoader1 = classLoader.getParent();
        System.out.println(classLoader1);

        // 调用扩展类加载器的getParent（）：无法获取引导类加载器
        // 引导类加载器主要负责加载java的核心类库，无法加载自定义类的。
        ClassLoader classLoader2 = classLoader1.getParent();
        System.out.println(classLoader2);

        ClassLoader classLoader3 = String.class.getClassLoader();
        System.out.println(classLoader3);

    }

    /*
    Properties: 用来读取配置文件。
     */
    @Test
    public void test2() throws IOException {

        Properties pros = new Properties();
        // 此时的文件默认在当前的nodule下
        // 读取配置文件的方式一
//        FileInputStream fis = new FileInputStream("jdbc1.properties");
        FileInputStream fis = new FileInputStream("src\\jdbc1.properties");
        pros.load(fis);

        // 读取配置文件的方式二：使用CLassLoader
        // 配置文件默认识别为：当前nodule的src下
//        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
//        InputStream is = classLoader.getResourceAsStream("jdbc1.properties");
//        pros.load(is);

        String user = pros.getProperty("user");
        String password = pros.getProperty("password");
        System.out.println("user =" + user + ", password = " + password);

    }

}
</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1">四、创建运行时类的对象</h2> 
<h3 id="1.%E6%9C%89%E4%BA%86Class%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F">1.有了Class对象，能做什么？</h3> 
<p class="img-center"><img alt="" height="310" src="https://images2.imgbox.com/2a/32/R55ceVTu_o.png" width="683"></p> 
<p class="img-center"><img alt="" height="316" src="https://images2.imgbox.com/0d/d1/8TztxWQz_o.png" width="665"></p> 
<h4> 上代码</h4> 
<pre><code class="language-java">package com.tyl.java;

import org.junit.Test;

import java.util.Random;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename: NewInstanceTest
 * @create 2023-06-20 18:33
 *
 * 通过反射创建对应的运行时类的对象
 */
public class NewInstanceTest {

    @Test
    public void test1() throws InstantiationException, IllegalAccessException {

        Class&lt;Person&gt; clazz = Person.class;

        /*
        newInstance（）:调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。

        要想此方法正常的创建运行时类的对象，要求：
        1.运行时类必须提供空参的构造器
        2.空参的构造器的访问权限得够。通常，设置为public

        在javabean中要求提供一个public的空参构造器。原因：
        1.便于通过反射，创建运行时类的对象
        2.便于子类继承此运行时类时，默认调用super（）时，保证父类有此构造器
         */

        Person obj = clazz.newInstance();
        System.out.println(obj);

    }


    // 体会反射的动态性
    @Test
    public void test2(){

        for (int i = 0; i &lt; 100; i++) {

            int num = new Random().nextInt(3);
            String classPath = "";
            switch (num){
                case 0:
                    classPath = "java.util.Date";
                    break;
                case 1:
                    classPath = "java.lang.Object";
                    break;
                case 2:
                    classPath = "com.tyl.java.Person";
                    break;
            }
            Object obj = null;
            try {
                obj = getInstance(classPath);
                System.out.println(obj);
            } catch (InstantiationException e) {
                throw new RuntimeException(e);
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }

    }

    /*
    创建一个指定类的对象。
    cLassPath:指定类的全类名
     */
    public Object getInstance(String classPath) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
        Class clazz = Class.forName(classPath);
        return clazz.newInstance();
    }


}
</code></pre> 
<h2 id="%E4%BA%94%E3%80%81%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84">五、获取运行时类的完整结构</h2> 
<h3 id="1.%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84">1.通过反射获取运行时类的完整结构</h3> 
<p class="img-center"><img alt="" height="244" src="https://images2.imgbox.com/19/f1/a1JGwn5e_o.png" width="765"></p> 
<p class="img-center"><img alt="" height="303" src="https://images2.imgbox.com/f7/b5/DuYQOl0I_o.png" width="787"></p> 
<p class="img-center"><img alt="" height="285" src="https://images2.imgbox.com/8a/7b/B8vsHigf_o.png" width="600"></p> 
<p class="img-center"><img alt="" height="328" src="https://images2.imgbox.com/75/fb/P6gvmd3E_o.png" width="624"></p> 
<p class="img-center"><img alt="" height="289" src="https://images2.imgbox.com/61/bc/yDWEPmPB_o.png" width="604"></p> 
<p class="img-center"><img alt="" height="311" src="https://images2.imgbox.com/43/56/ZSwTVKoi_o.png" width="592"></p> 
<h3 id="%C2%A02.%E5%B0%8F%20%E7%BB%93"> 2.小 结</h3> 
<blockquote> 
 <p>1.在实际的操作中，取得类的信息的操作代码，并不会经常开发。</p> 
 <p>2.一定要熟悉java.lang.reflect包的作用，反射机制。</p> 
 <p>3.如何取得属性、方法、构造器的名称，修饰符等。</p> 
</blockquote> 
<h4 id="%E4%B8%8A%E4%BB%A3%E7%A0%81">上代码</h4> 
<pre><code class="language-java">package com.tyl.java2;

import com.tyl.java1.Person;
import org.junit.Test;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java2
 * @Project：workidea
 * @Filename: FiledTest
 * @create 2023-06-20 19:47
 */
public class FiledTest {
    @Test
    public void test1(){

        Class&lt;Person&gt; clazz = Person.class;

        //获取属性结构
        //getFields（）:获取当前运行时类及其父类中声明为public访问权限的属性
        Field[] fields = clazz.getFields();
        for(Field f : fields){
            System.out.println(f);
        }
        System.out.println();

        //getDecLaredFields（）:获取当前运行时类中声明的所有属性。（不包含父类中声明的属性)
        Field[] declaredFields = clazz.getDeclaredFields();
        for(Field f : declaredFields){
            System.out.println(f);
        }
    }

    // 权限修饰符 数据类型 变量名
    @Test
    public void test2(){
        Class&lt;Person&gt; clazz = Person.class;
        Field[] declaredFields = clazz.getDeclaredFields();
        for(Field f : declaredFields){
            // 1.权限修饰弑
            int modifiers = f.getModifiers();
            System.out.print(Modifier.toString(modifiers) + "\t");

            // 2.数据类型
            Class&lt;?&gt; type = f.getType();
            System.out.print(type.getName() + "\t");

            // 3.变量名
            String name = f.getName();
            System.out.print(name);

            System.out.println();
        }


    }
}
</code></pre> 
<pre><code class="language-java">package com.tyl.java2;

import com.tyl.java1.Person;
import org.junit.Test;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java2
 * @Project：workidea
 * @Filename: MethodTest
 * @create 2023-06-20 20:32
 *
 * 获取运行时类的方法结构
 */
public class MethodTest {
    @Test
    public void test1(){

        Class&lt;Person&gt; clazz = Person.class;

        // getMethods（）:获取当前运行时类及其所有父类中声明为public权限的方法
        Method[] methods = clazz.getMethods();
        for(Method m : methods){
            System.out.println(m);
        }

        System.out.println("*********************************");

        // getDecLaredMethods（）:获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for(Method m : declaredMethods){
            System.out.println(m);
        }
    }

    /*
     @XXXx
    权限修饰符   返回值类型     方法名(参数类型虹形参名1，···)  throws XxxException{}
     */
    @Test
    public void test2(){
        Class&lt;Person&gt; clazz = Person.class;
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for(Method m : declaredMethods){

            // 1.获取方法声明的注解
            Annotation[] annotations = m.getAnnotations();
            for(Annotation a : annotations){
                System.out.println(a);
            }

            // 2.权限修饰符
            System.out.print(Modifier.toString(m.getModifiers()) + "\t");

            // 3.返回值类型
            System.out.print(m.getReturnType().getName() + "\t");

            // 4.方法名
            String name = m.getName();
            System.out.print(name);

            System.out.print("(");

            // 5.形参列表
            Class[] parameterTypes = m.getParameterTypes();
            if(!(parameterTypes == null &amp;&amp; parameterTypes.length == 0)){
                for (int i = 0; i &lt; parameterTypes.length; i++) {

                    if(i == parameterTypes.length - 1 ){
                        System.out.print(parameterTypes[i].getName() + " args_ " + i);
                        break;
                    }

                    System.out.print(parameterTypes[i].getName() + " args_ " + i + ",");
                }
            }

            System.out.print(")");

            // 6.抛出异常
            Class[] exceptionTypes = m.getExceptionTypes();

            if(exceptionTypes.length &gt; 0){
                for (int i = 0; i &lt; exceptionTypes.length; i++) {
                    if(!(exceptionTypes == null &amp;&amp; exceptionTypes.length == 0)){
                        System.out.print("throws: ");
                        System.out.print(exceptionTypes[i].getName());
                        break;
                    }
                    System.out.print(exceptionTypes[i].getName() + ",");
                }
            }

            System.out.println();

        }

    }

}
</code></pre> 
<pre><code class="language-java">package com.tyl.java2;

import com.tyl.java1.Person;
import org.junit.Test;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java2
 * @Project：workidea
 * @Filename: OtherTest
 * @create 2023-06-20 21:26
 */
public class OtherTest {
    /*
    获取构造器结构
     */
    @Test
    public void test1(){
        Class&lt;Person&gt; clazz = Person.class;

        // getConstructors（）:获取当前运行时类中声明为public的构造器
        Constructor[] constructors = clazz.getConstructors();
        for(Constructor c : constructors){
            System.out.println(c);
        }

        System.out.println();
        // getDecLaredConstructors（）:获取当前运行时类中声明的所有的构造器
        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();
        for(Constructor c : declaredConstructors){
            System.out.println(c);
        }

    }

    /*
    茯取运行时类的父类
     */
    @Test
    public void test2(){
        Class&lt;Person&gt; clazz = Person.class;
        Class superclass = clazz.getSuperclass();
        System.out.println(superclass);
    }

    /*
    茯取运行时类带泛型的父类
     */
    @Test
    public void test3(){
        Class&lt;Person&gt; clazz = Person.class;
        Type genericSuperclass = clazz.getGenericSuperclass();
        System.out.println(genericSuperclass);
    }

    /*
    茯取运行时类带泛型的父类的泛型

    代码：   逻辑性代码  vs  功能性代码
     */
    @Test
    public void test4(){
        Class&lt;Person&gt; clazz = Person.class;

        Type genericSuperclass = clazz.getGenericSuperclass();

        ParameterizedType paramType = (ParameterizedType) genericSuperclass;

        // 获取泛型类型
        Type[] actualTypeArguments = paramType.getActualTypeArguments();
//        System.out.println(actualTypeArguments[0].getTypeName());
        System.out.println(((Class)actualTypeArguments[0]).getName());
    }


    /*
    获取运行时类实现的接口
     */
    @Test
    public void test5(){
        Class&lt;Person&gt; clazz = Person.class;

        Class[] interfaces = clazz.getInterfaces();
        for(Class c : interfaces){
            System.out.println(c);
        }

        System.out.println("************************");
        // 获取运行时类的父类实现的接口
        Class[] interfaces1 = clazz.getSuperclass().getInterfaces();
        for(Class c : interfaces1){
            System.out.println(c);
        }

    }

    /*
    获取运行时类所在的包
     */
    @Test
    public void test6(){
        Class&lt;Person&gt; clazz = Person.class;
        Package aPackage = clazz.getPackage();
        System.out.println(aPackage);

    }

    /*
    获取运行时类声明的注解
     */
    @Test
    public void test7(){
        Class&lt;Person&gt; clazz = Person.class;
        Annotation[] annotations = clazz.getAnnotations();
        for(Annotation a : annotations){
            System.out.println(a);
        }

    }

}

</code></pre> 
<h2 id="%E5%85%AD%E3%80%81%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84">六、调用运行时类的指定结构</h2> 
<h3 id="1.%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95">1.调用指定方法</h3> 
<p class="img-center"><img alt="" height="283" src="https://images2.imgbox.com/97/db/KWl1rBcO_o.png" width="704"></p> 
<p class="img-center"><img alt="" height="244" src="https://images2.imgbox.com/9d/95/fILpqdUp_o.png" width="650"></p> 
<h3 id="%C2%A02.%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7"> 2.调用指定属性</h3> 
<p class="img-center"><img alt="" height="236" src="https://images2.imgbox.com/96/86/8ec6XwPL_o.png" width="687"></p> 
<h3 id="%C2%A03.%E5%85%B3%E4%BA%8EsetAccessible%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"> 3.关于setAccessible方法的使用</h3> 
<p class="img-center"><img alt="" height="205" src="https://images2.imgbox.com/8c/eb/eNyaoopB_o.png" width="694"></p> 
<h4> 上代码</h4> 
<pre><code class="language-java">package com.tyl.java2;

import com.tyl.java1.Person;
import org.junit.Test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java2
 * @Project：workidea
 * @Filename: ReflectionTest
 * @create 2023-06-25 16:00
 *
 * 调用运行时类中指定的结构：属性、方法、构造器
 */
public class ReflectionTest {
    /*
    不需要掌握
     */
    @Test
    public void test1() throws Exception {
        Class clazz = Person.class;

        //创建运行时类的对象
        Person p = (Person) clazz.newInstance();

        //获取指定的属性   要求运行时类中属性明为public
        // 通常不用
        Field id = clazz.getField("id");

        /*
        设置当前属性的值
        set（）:参数1：指明设置哪个对象的属性   参数2：将此属性值设置为多少
         */
        id.set(p,1001);

        /*
        获取当前属性的值
        get（）:参数1：获取哪个对象的当前属性值
         */
        int pid = (int) id.get(p);
        System.out.println(pid);

    }

    /*
    如何操作运行时类中的指定的属性·需要掌握
     */
    @Test
    public void test2() throws Exception {
        Class clazz = Person.class;

        // 创建运行时类的对象
        Person p = (Person) clazz.newInstance();

        // 1.getDecLaredField(string fieldName):获取运行时类中指定变量名的属性
        Field name = clazz.getDeclaredField("name");

        // 2.保证当前属性是可访问的
        name.setAccessible(true);

        // 3.获取、设置指定对象的此属性值
        name.set(p,"tyl");
        System.out.println(name.get(p));
    }

    /*
    如何操作运行时类中的指定的方法~~需要掌握
     */
    @Test
    public void test3() throws Exception {
        Class clazz = Person.class;

        // 创建运行时类的对象
        Person p = (Person) clazz.newInstance();

        /*
        1.获取指定的某个方法
          getDecLaredMethod（）:参数1：指明获取的方法的名称  参数2：指明获取的方法的形参列表
         */
        Method show = clazz.getDeclaredMethod("show", String.class);

        // 2. 保证当前属性是可访问的
        show.setAccessible(true);

        /*
        3.调用方法的invoke（）:参数1：方法的调用者   参数2：给方法形参赋值的实参
        invoke（）的返回值即为对应类中调用的方法的返回值。
         */
        Object returnValue = show.invoke(p, "China");
        System.out.println(returnValue);


        System.out.println("****************如何调用静态方法*******************");

        // private static void showDesc
        Method showDesc = clazz.getDeclaredMethod("showDesc");
        showDesc.setAccessible(true);
        //如果调用的运行时类中的方法没有返回值，则此invoke（）返回nuLL
//        Object returnVal = showDesc.invoke(Person.class);
        Object returnVal = showDesc.invoke(null);
        System.out.println(returnVal); // null

    }

    /*
    如何调用运行时类中的指定的构造器
     */
    @Test
    public void test4() throws Exception {
        Class clazz = Person.class;

        // private Person(String name)
        /*
        1.获取指定的构造器
        getDecLaredConstructor（）:参数：指明构造器的参数列表
         */
        Constructor constructor = clazz.getDeclaredConstructor(String.class);

        // 2. 保证当前属性是可访问的
        constructor.setAccessible(true);

        // 3. 调用此构造器创建运行时类的对象
        Person per = (Person) constructor.newInstance("tyl");
        System.out.println(per);

    }

}
</code></pre> 
<h2 id="%E4%B8%83%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">七、反射的应用：动态代理</h2> 
<h3 id="1.%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86">1.代理设计模式的原理</h3> 
<p class="img-center"><img alt="" height="233" src="https://images2.imgbox.com/14/ce/sHap0HCT_o.png" width="749"></p> 
<p class="img-center"><img alt="" height="258" src="https://images2.imgbox.com/e5/51/t9CzqOTL_o.png" width="740"></p> 
<h3 id="%C2%A02.Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9B%B8%E5%85%B3API"> 2.Java动态代理相关API</h3> 
<p class="img-center"><img alt="" height="271" src="https://images2.imgbox.com/c0/1e/bd2Nl769_o.png" width="716"></p> 
<h3 id="%C2%A03.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%A5%E9%AA%A4"> 3.动态代理步骤</h3> 
<p class="img-center"><img alt="" height="320" src="https://images2.imgbox.com/31/0b/gT8NRNJq_o.png" width="692"></p> 
<p class="img-center"><img alt="" height="263" src="https://images2.imgbox.com/71/0f/WUGbEfk3_o.png" width="677"></p> 
<p class="img-center"><img alt="" height="253" src="https://images2.imgbox.com/91/ab/y1vUZYzZ_o.png" width="679"></p> 
<p class="img-center"><img alt="" height="145" src="https://images2.imgbox.com/d5/ad/AddaB9YY_o.png" width="497"></p> 
<h3 id="%C2%A04.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EAOP%EF%BC%88Aspect%20Orient%20Programming)"> 4.动态代理与AOP（Aspect Orient Programming)</h3> 
<p class="img-center"><img alt="" height="303" src="https://images2.imgbox.com/62/83/Z4XaatUX_o.png" width="644"></p> 
<p></p> 
<p class="img-center"><img alt="" height="309" src="https://images2.imgbox.com/f5/18/rKQkOfwV_o.png" width="630"></p> 
<p class="img-center"><img alt="" height="157" src="https://images2.imgbox.com/18/72/3U4YHylV_o.png" width="695"></p> 
<p class="img-center"><img alt="" height="291" src="https://images2.imgbox.com/79/a4/IZAUljwW_o.png" width="399"></p> 
<h4 id="%C2%A0%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"> 代码演示</h4> 
<h5 id="%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">静态代理</h5> 
<p class="img-center"><img alt="" height="356" src="https://images2.imgbox.com/b4/f2/wlo9osP6_o.png" width="500"></p> 
<pre><code class="language-java">package com.tyl.java;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename: StaticProxyTest
 * @create 2023-06-25 22:31
 *
 *     静态代理举例
 * 特点：代理类和被代理类在编译期间，就确定下来了。
 */


interface ClothFactory {
    void produceCloth();
}

// 代理类
class ProxyClothFactory implements ClothFactory{

    private ClothFactory factory;

    public ProxyClothFactory(ClothFactory factory){
        this.factory = factory;
    }

    @Override
    public void produceCloth() {
        System.out.println("代理工厂做准备！！！");

        factory.produceCloth();

        System.out.println("代理工厂后续工作！！！");
    }

}


// 被代理类
class NikeClothFactory implements ClothFactory{

    @Override
    public void produceCloth() {
        System.out.println("Nike生产运动鞋！！！");

    }
}

public class StaticProxyTest {
    public static void main(String[] args) {
        // 创建被代理类的对象
        NikeClothFactory nike = new NikeClothFactory();

        // 创建代理类的对象
        ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike);

        proxyClothFactory.produceCloth();


    }

}</code></pre> 
<h5 id="%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">动态代理</h5> 
<pre><code class="language-java">package com.tyl.java;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename: ProxyTest
 * @create 2023-06-25 22:35
 *
 * 动态代理的举例
 */

interface Human{

    String getBelief();

    void eat(String food);

}


// 被代理类
class SuperMan implements Human{

    @Override
    public String getBelief() {
        return "I believe I can fly!";
    }

    @Override
    public void eat(String food) {
        System.out.println("我喜欢吃:" + food);

    }
}

class HuamUtil{

    public void method1(){
        System.out.println("*****************通用方法一************************");
    }

    public void method2(){
        System.out.println("*****************通用方法二************************");
    }
}

/*
要想实现动态代理，需要解决的问题？
问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。
问题二：当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法。
 */
class ProxyFactory{

    // 调用此方法，返回一个代理类的对象  解决问题一
    public static Object getProxyInstance(Object obj){ // obj: 被代理类的对象

        MyInvocationHandler handler = new MyInvocationHandler();

        handler.bind(obj);

        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);

    }
}

class MyInvocationHandler implements InvocationHandler{

    private Object obj; // 需要使用被代理类的对象进行赋值

    public void bind(Object obj){
        this.obj = obj;
    }

    // 当我们通过代理类的对象，调用方法和时，就会自动的调用如下的方法：invoke（）
    // 将被代理类要执行的方法和的功能就声明在invoke（）中
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        HuamUtil huamUtil = new HuamUtil();
        huamUtil.method1();

        // method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法
        // obj:被代理类的对象
        Object returnValue = method.invoke(obj, args);

        huamUtil.method2();

        // 上述方法的返回值就作为当前类中的invoke（）的返回值。
        return  returnValue;
    }
}


public class ProxyTest {
    public static void main(String[] args) {

        SuperMan superMan = new SuperMan();

        // proxyInstance:代理类的对象
        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);

        // 当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法
        String belief = proxyInstance.getBelief();
        System.out.println(belief);

        proxyInstance.eat("麻辣烫");

        System.out.println("****************************");

        NikeClothFactory nikeClothFactory = new NikeClothFactory();

        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);

        proxyClothFactory.produceCloth();

    }

}
</code></pre> 
<hr> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong> 框架 =反射 + 注解 + 设计模式</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>虽然理解的不够全面，透彻，但是在以后的框架学习中一定会有更深的理解！！！</strong></span></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f56a1306e2396cba357faa659667f3ba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">（carbon flow（1/n））计算物理母线与三绕组变压器对应关系的计算步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3eacbe7507ccc6c36f126f32a0e5c89c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">这一刻，我感觉一定要给.....（补充）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>