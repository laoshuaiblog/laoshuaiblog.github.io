<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mybatis面试题 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/ebcdae7e8863a4465258449fbc280591/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Mybatis面试题">
  <meta property="og:description" content="#{}和${}的区别是什么？ {}和${}的区别是什么？
在Mybatis中，有两种占位符
#{}解析传递进来的参数数据${}对传递进来的参数原样拼接在SQL中#{}是预编译处理，${}是字符串替换。使用#{}可以有效的防止SQL注入，提高系统安全性。 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？ 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？
第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致
&amp;lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&amp;gt; select order_id id, order_no orderno ,order_price price form orders where order_id=#{id}; &amp;lt;/select&amp;gt; 复制
第2种： 通过来映射字段名和实体类属性名的一一对应的关系
&amp;lt;select id=&#34;getOrder&#34; parameterType=&#34;int&#34; resultMap=&#34;orderresultmap&#34;&amp;gt; select * from orders where order_id=#{id} &amp;lt;/select&amp;gt; &amp;lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&amp;gt; &amp;lt;!–用id属性来映射主键字段–&amp;gt; &amp;lt;id property=”id” column=”order_id”&amp;gt; &amp;lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&amp;gt; &amp;lt;result property = “orderno” column =”order_no”/&amp;gt; &amp;lt;result property=”price” column=”order_price” /&amp;gt; &amp;lt;/reslutMap&amp;gt; 复制
我认为第二种方式会好一点。
如何获取自动生成的(主)键值? 如何获取自动生成的(主)键值?
如果我们一般插入数据的话，如果我们想要知道刚刚插入的数据的主键是多少，我们可以通过以下的方式来获取
需求：
user对象插入到数据库后，新记录的主键要通过user对象返回，通过user获取主键值。 解决思路：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-07T12:41:48+08:00">
    <meta property="article:modified_time" content="2023-07-07T12:41:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mybatis面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="Mybatis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><strong>#{}和${}的区别是什么？</strong></h2> 
<blockquote> 
 <p><strong>{}和${}的区别是什么？</strong></p> 
</blockquote> 
<p>在Mybatis中，有两种占位符</p> 
<ul><li>#{}解析传递进来的参数数据</li><li>${}对传递进来的参数<strong>原样</strong>拼接在SQL中</li><li><strong>#{}是预编译处理，${}是字符串替换</strong>。</li><li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li></ul> 
<h3 id="%E5%BD%93%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7-%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E-%EF%BC%9F"><strong>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</strong></h3> 
<blockquote> 
 <p>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</p> 
</blockquote> 
<p>第1种： 通过在查询的sql语句中<strong>定义字段名的别名，让字段名的别名和实体类的属性名一致</strong></p> 
<pre><code>     &lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&gt; 
       select order_id id, order_no orderno ,order_price price form orders where order_id=#{id}; 
    &lt;/select&gt; </code></pre> 
<p>复制</p> 
<p>第2种： <strong>通过来映射字段名和实体类属性名的一一对应的关系</strong></p> 
<pre><code> &lt;select id="getOrder" parameterType="int" resultMap="orderresultmap"&gt;
        select * from orders where order_id=#{id}
    &lt;/select&gt;
   &lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt; 
        &lt;!–用id属性来映射主键字段–&gt; 
        &lt;id property=”id” column=”order_id”&gt; 
        &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt; 
        &lt;result property = “orderno” column =”order_no”/&gt; 
        &lt;result property=”price” column=”order_price” /&gt; 
    &lt;/reslutMap&gt;</code></pre> 
<p>复制</p> 
<p>我认为第二种方式会好一点。</p> 
<h3 id="%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84(%E4%B8%BB)%E9%94%AE%E5%80%BC?"><strong>如何获取自动生成的(主)键值?</strong></h3> 
<blockquote> 
 <p>如何获取自动生成的(主)键值?</p> 
</blockquote> 
<p>如果我们一般插入数据的话，<strong>如果我们想要知道刚刚插入的数据的主键是多少，我们可以通过以下的方式来获取</strong></p> 
<p>需求：</p> 
<ul><li>user对象插入到<a href="https://cloud.tencent.com/solution/database?from=20065&amp;from_column=20065" rel="nofollow" title="数据库">数据库</a>后，新记录的主键要通过user对象返回，通过user获取主键值。</li></ul> 
<p>解决思路：</p> 
<ul><li>通过LAST_INSERT_ID()获取刚插入记录的自增主键值，<strong>在insert语句执行后，执行select LAST_INSERT_ID()就可以获取自增主键。</strong></li></ul> 
<p>mysql:</p> 
<pre><code>    &lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt;
        &lt;selectKey keyProperty="id" order="AFTER" resultType="int"&gt;
            select LAST_INSERT_ID()
        &lt;/selectKey&gt;
        INSERT INTO USER(username,birthday,sex,address) VALUES(#{username},#{birthday},#{sex},#{address})
    &lt;/insert&gt;</code></pre> 
<p>复制</p> 
<p>oracle:</p> 
<p>实现思路：</p> 
<ul><li><strong>先查询序列得到主键，将主键设置到user对象中，将user对象插入数据库。</strong></li></ul> 
<pre><code>    &lt;!-- oracle
    在执行insert之前执行select 序列.nextval() from dual取出序列最大值，将值设置到user对象 的id属性
     --&gt;
    &lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt;
        &lt;selectKey keyProperty="id" order="BEFORE" resultType="int"&gt;
            select 序列.nextval() from dual
        &lt;/selectKey&gt;

        INSERT INTO USER(id,username,birthday,sex,address) VALUES( 序列.nextval(),#{username},#{birthday},#{sex},#{address})
    &lt;/insert&gt; </code></pre> 
<p>复制</p> 
<h3 id="%E5%9C%A8mapper%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0?"><strong>在mapper中如何传递多个参数?</strong></h3> 
<blockquote> 
 <p>在mapper中如何传递多个参数?</p> 
</blockquote> 
<p><strong>第一种：使用占位符的思想</strong></p> 
<ul><li><strong>在映射文件中使用#{0},#{1}代表传递进来的第几个参数</strong></li><li>**使用@param注解:来命名参数 **</li><li><strong>{0},#{1}方式</strong></li></ul> 
<pre><code>//对应的xml,#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。

&lt;select id="selectUser"resultMap="BaseResultMap"&gt;  
    select *  fromuser_user_t   whereuser_name = #{0} anduser_area=#{1}  
&lt;/select&gt;  </code></pre> 
<p>复制</p> 
<ul><li>@param注解方式</li></ul> 
<pre><code>        public interface usermapper { 
         user selectuser(@param(“username”) string username, 
         @param(“hashedpassword”) string hashedpassword); 
        }</code></pre> 
<p>复制</p> 
<pre><code> &lt;select id=”selectuser” resulttype=”user”&gt; 
         select id, username, hashedpassword 
         from some_table 
         where username = #{username} 
         and hashedpassword = #{hashedpassword} 
    &lt;/select&gt;</code></pre> 
<p>复制</p> 
<p><strong>第二种：使用Map集合作为参数来装载</strong></p> 
<pre><code>     try{
            //映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL


            /**
             * 由于我们的参数超过了两个，而方法中只有一个Object参数收集
             * 因此我们使用Map集合来装载我们的参数
             */
            Map&lt;String, Object&gt; map = new HashMap();
            map.put("start", start);
            map.put("end", end);
            return sqlSession.selectList("StudentID.pagination", map);
        }catch(Exception e){
            e.printStackTrace();
            sqlSession.rollback();
            throw e;
        }finally{
            MybatisUtil.closeSqlSession();
        }</code></pre> 
<p>复制</p> 
<pre><code>    &lt;!--分页查询--&gt;
    &lt;select id="pagination" parameterType="map" resultMap="studentMap"&gt;

        /*根据key自动找到对应Map集合的value*/
        select * from students limit #{start},#{end};

    &lt;/select&gt;</code></pre> 
<p>复制</p> 
<h3 id="Mybatis%E5%8A%A8%E6%80%81sql%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81sql%EF%BC%9F%E8%83%BD%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8A%A8%E6%80%81sql%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8D%EF%BC%9F"><strong>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</strong></h3> 
<blockquote> 
 <p>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</p> 
</blockquote> 
<ul><li>Mybatis动态sql可以让我们在Xml映射文件内，<strong>以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能</strong>。</li><li>Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。</li><li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，<strong>根据表达式的值动态拼接sql，以此来完成动态sql的功能</strong>。</li></ul> 
<p>详情Demo可参考我别的文章：</p> 
<ul><li>https://zhongfucheng.bitcron.com/post/mybatis/mybatisru-men-kan-zhe-yi-pian-jiu-gou-liao</li></ul> 
<h3 id="Mybatis%E7%9A%84Xml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84Xml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%8Cid%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%EF%BC%9F"><strong>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</strong></h3> 
<blockquote> 
 <p>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</p> 
</blockquote> 
<p><strong>如果配置了namespace那么当然是可以重复的，因为我们的Statement实际上就是namespace+id</strong></p> 
<p>如果没有配置namespace的话，那么相同的id就会导致覆盖了。</p> 
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Mybatis%E6%98%AF%E5%8D%8A%E8%87%AA%E5%8A%A8ORM%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7%EF%BC%9F%E5%AE%83%E4%B8%8E%E5%85%A8%E8%87%AA%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><strong>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</strong></h3> 
<blockquote> 
 <p>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</p> 
</blockquote> 
<ul><li>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</li><li>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</li></ul> 
<h3 id="%E9%80%9A%E5%B8%B8%E4%B8%80%E4%B8%AAXml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%8C%E9%83%BD%E4%BC%9A%E5%86%99%E4%B8%80%E4%B8%AADao%E6%8E%A5%E5%8F%A3%E4%B8%8E%E4%B9%8B%E5%AF%B9%E5%BA%94%EF%BC%8C%E8%AF%B7%E9%97%AE%EF%BC%8C%E8%BF%99%E4%B8%AADao%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FDao%E6%8E%A5%E5%8F%A3%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C%E6%97%B6%EF%BC%8C%E6%96%B9%E6%B3%95%E8%83%BD%E9%87%8D%E8%BD%BD%E5%90%97%EF%BC%9F"><strong>通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</strong></h3> 
<blockquote> 
 <p>通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</p> 
</blockquote> 
<ul><li>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。</li><li>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement</li></ul> 
<p>举例：</p> 
<pre><code>com.mybatis3.mappers.StudentDao.findStudentById，

可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。</code></pre> 
<p>复制</p> 
<p>Dao接口里的方法，<strong>是不能重载的，因为是全限名+方法名的保存和寻找策略</strong>。</p> 
<p><strong>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</strong></p> 
<p>详情可参考：</p> 
<ul><li>https://www.cnblogs.com/soundcode/p/6497291.html</li></ul> 
<h3 id="Mybatis%E6%AF%94IBatis%E6%AF%94%E8%BE%83%E5%A4%A7%E7%9A%84%E5%87%A0%E4%B8%AA%E6%94%B9%E8%BF%9B%E6%98%AF%E4%BB%80%E4%B9%88"><strong>Mybatis比IBatis比较大的几个改进是什么</strong></h3> 
<blockquote> 
 <p>Mybatis比IBatis比较大的几个改进是什么</p> 
</blockquote> 
<ul><li>a.<strong>有接口绑定,包括注解绑定sql和xml绑定Sql</strong> ,</li><li>b.动态sql由原来的节点配置变成OGNL表达式,</li><li>c. 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置</li></ul> 
<h3 id="%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F,%E5%88%86%E5%88%AB%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84?"><strong>接口绑定有几种实现方式,分别是怎么实现的?</strong></h3> 
<blockquote> 
 <p>接口绑定有几种实现方式,分别是怎么实现的?</p> 
</blockquote> 
<p>接口绑定有两种实现方式：</p> 
<ul><li>一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定</li><li>另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.</li></ul> 
<h3 id="Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><strong>Mybatis是如何进行分页的？分页插件的原理是什么？</strong></h3> 
<blockquote> 
 <p>Mybatis是如何进行分页的？分页插件的原理是什么？</p> 
</blockquote> 
<p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p> 
<p><strong>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</strong></p> 
<p>举例：<code>select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10</code></p> 
<p>分页插件使用参考资料：</p> 
<ul><li>https://www.cnblogs.com/kangoroo/p/7998433.html</li><li>http://blog.csdn.net/yuchao2015/article/details/55001182</li><li>https://www.cnblogs.com/ljdblog/p/6725094.html</li></ul> 
<h3 id="%E7%AE%80%E8%BF%B0Mybatis%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6"><strong>简述Mybatis的插件运行原理，以及如何编写一个插件</strong></h3> 
<blockquote> 
 <p>简述Mybatis的插件运行原理，以及如何编写一个插件</p> 
</blockquote> 
<p>Mybatis仅可以<strong>编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能</strong>，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p> 
<p>实现Mybatis的Interceptor接口并复写intercept()方法，<strong>然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</strong></p> 
<h3 id="Mybatis%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><strong>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</strong></h3> 
<blockquote> 
 <p>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</p> 
</blockquote> 
<p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，<strong>可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</strong></p> 
<p>它的原理是，<strong>使用CGLIB创建目标对象的代理对象</strong>，当调用目标方法时，<strong>进入拦截器方法</strong>，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p> 
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p> 
<h3 id="Mybatis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9BExecutor%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><strong>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</strong></h3> 
<blockquote> 
 <p>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</p> 
</blockquote> 
<p>Mybatis有三种基本的Executor执行器，<strong>SimpleExecutor、ReuseExecutor、BatchExecutor</strong>。</p> 
<ul><li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，<strong>用完立刻关闭Statement对象</strong>。</li><li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map 内，供下一次使用。简言之，<strong>就是重复使用Statement对象</strong>。</li><li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），<strong>它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同</strong>。</li></ul> 
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p> 
<h3 id="MyBatis%E4%B8%8EHibernate%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%9F"><strong>MyBatis与Hibernate有哪些不同？</strong></h3> 
<blockquote> 
 <p>MyBatis与Hibernate有哪些不同？</p> 
</blockquote> 
<p>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</p> 
<p>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</p> 
<p>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/61fd2aff1a316f066ab6afe09bded82f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手把手教你：基于Django的新闻文本分类可视化系统（文本分类由bert实现）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d20570489cb42f9ba680fe184876da4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Web服务器、应用程序服务器、HTTP服务器区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>