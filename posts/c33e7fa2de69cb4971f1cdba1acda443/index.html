<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux基础 gcc编译器 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/c33e7fa2de69cb4971f1cdba1acda443/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Linux基础 gcc编译器">
  <meta property="og:description" content="该系列文章总纲链接：专题分纲目录 Linux环境
本章节内容的思维导图整理如下：
1 gcc编译器简介 gcc 是 Linux 平台下最常用的编译程序,它是Linux 平台编译器的事实标准。同时,在 Linux 平台下的嵌入式开发领域,gcc也是用得最普遍的一种编译器。gcc 之所以被广泛采用,是因为它能支持各种不同的目标体系结构。例如,它既支持基于宿主的开发(简单讲就是要为某平台编译程序,就在该平台上编译),也支持交叉编译(即在 A 平台上编译的程序是供平台 B 使用的)。目前,gcc 支持的体系结构有四十余种,常见的有 X86 系列、Arm、PowerPC 等。同时,gcc 还能运行在不同的操作系统上,如 Linux、Solaris、Windows 等。
1.1 安装gcc编译器编译环境 sudo apt-get install build-essential 1.2 编译简单的C程序 通过hello，world来学习gcc。程序如下： #include &amp;lt;stdio.h&amp;gt; int main(void) { printf(&#34;Hello, world!\n&#34;); return 0; } 我们假定该代码存为文件‘hello.c’。要用 gcc 编译该文件，使用下面的命令：
$ gcc hello.c -o hello -Wall -g 该命令将文件‘hello.c’中的代码编译为机器码并存储在可执行文件 ‘hello’中。机器码的文件名是通过 -o 选项指定的。该选项通常作为命令行中的最后一个参数。如果被省略，输出文件默认为 ‘a.out’。
如果当前目录中与可执行文件重名的文件已经存在，它将被覆盖。
选项 -Wall 开启编译器几乎所有常用的警告：强烈建议始终使用该选项。编译器有很多其他的警告选项，但 -Wall 是最常用的。默认情况下GCC 不会产生任何警告信息。当编写 C 或 C&#43;&#43; 程序时编译器警告非常有助于检测程序存在的问题。如果有用到math.h库等非gcc默认调用的标准库，请使用-lm参数;本例中，编译器使用了 -Wall 选项而没产生任何警告，因为示例程序是完全合法的;选项 &#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-02-22T20:23:46+08:00">
    <meta property="article:modified_time" content="2023-02-22T20:23:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux基础 gcc编译器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>该系列文章总纲链接：<a href="https://blog.csdn.net/vviccc/article/details/105192316" title="专题分纲目录 Linux环境">专题分纲目录 Linux环境</a></p> 
<hr> 
<p>本章节内容的思维导图整理如下：</p> 
<p style="text-align:center;"><img alt="" height="405" src="https://images2.imgbox.com/07/17/Gb3TdsSt_o.png" width="400"></p> 
<hr> 
<h2><strong>1 gcc编译器简介</strong></h2> 
<p>gcc 是 Linux 平台下最常用的编译程序,它是Linux 平台编译器的事实标准。同时,在 Linux 平台下的嵌入式开发领域,gcc也是用得最普遍的一种编译器。gcc 之所以被广泛采用,是因为它能支持各种不同的目标体系结构。例如,它既支持基于宿主的开发(简单讲就是要为某平台编译程序,就在该平台上编译),也支持交叉编译(即在 A 平台上编译的程序是供平台 B 使用的)。目前,gcc 支持的体系结构有四十余种,常见的有 X86 系列、Arm、PowerPC 等。同时,gcc 还能运行在不同的操作系统上,如 Linux、Solaris、Windows 等。</p> 
<h3><strong>1.1 安装gcc编译器编译环境</strong></h3> 
<pre><code class="language-bash">sudo apt-get install build-essential</code></pre> 
<h3><strong>1.2 编译简单的C程序</strong></h3> 
<p>通过hello，world来学习gcc。程序如下：    </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main(void)
{
    printf("Hello, world!\n");
    return 0;
}</code></pre> 
<p>我们假定该代码存为文件‘hello.c’。要用 gcc 编译该文件，使用下面的命令：</p> 
<pre><code class="language-bash">$ gcc hello.c -o hello -Wall -g</code></pre> 
<p>该命令将文件‘hello.c’中的代码编译为机器码并存储在可执行文件 ‘hello’中。机器码的文件名是通过 -o 选项指定的。该选项通常作为命令行中的最后一个参数。如果被省略，输出文件默认为 ‘a.out’。</p> 
<p>如果当前目录中与可执行文件重名的文件已经存在，它将被覆盖。</p> 
<ul><li>选项 -Wall 开启编译器几乎所有常用的警告：强烈建议始终使用该选项。编译器有很多其他的警告选项，但 -Wall 是最常用的。默认情况下GCC 不会产生任何警告信息。当编写 C 或 C++ 程序时编译器警告非常有助于检测程序存在的问题。</li><li>如果有用到math.h库等非gcc默认调用的标准库，请使用-lm参数;本例中，编译器使用了 -Wall 选项而没产生任何警告，因为示例程序是完全合法的;</li><li>选项 "-g" 表示在生成的目标文件中带调试信息，调试信息可以在程序异常中止产生core后，帮助分析错误产生的源头，包括产生错误的文件名和行号等非常多有用的信息。</li></ul> 
<p>要运行该程序，输入可执行文件的路径如下：</p> 
<pre><code class="language-bash">$ ./hello
输出
Hello, world!</code></pre> 
<p>这将可执行文件载入内存，并使 CPU 开始执行其包含的指令。 路径 ./ 指代当前目录，因此 ./hello 载入并执行当前目录下的可执行文件 ‘hello’。</p> 
<h3><strong>1.3  gcc最基本的用法与编译流程</strong></h3> 
<h4><strong>1.3.1  gcc最基本的用法是∶</strong></h4> 
<pre><code class="language-bash">gcc[options][filenames]
    options：编译器所需要的编译选项
    filenames:要编译的文件名
</code></pre> 
<h4><strong>1.3.2 gcc编译流程</strong></h4> 
<p>gcc的整个编译流程如下：</p> 
<pre><code class="language-bash">首先要编辑好xxx.c文件,之后进行编译阶段：
预处理(PreProcessing)     ：gcc -E生成xxx.i文件-&gt;
编译(Compiling)           ：gcc -S生成xxx.s文件-&gt;
汇编(Assembling)          ：gcc -c生成xxx.o文件-&gt;
链接(Linking)             ：gcc -o生成xxx文件     </code></pre> 
<p>生成的xxx文件加载到内存中，通过调度器调度在内存中执行并显示出结果。</p> 
<h3><strong>1.4 gcc涉及的文件类别简介</strong></h3> 
<pre><code class="language-bash">.c为后缀的文件:C语言源代码文件
.a为后缀的文件:是由目标文件构成的静态库文件
.so为后缀的文件:是由目标文件构成的动态库文件
.h为后缀的文件:头文件
.i为后缀的文件:是已经预处理过的C源代码文件
.ii为后缀的文件:是已经预处理过的C++源代码文件
.o为后缀的文件:是编译后的目标文件
.s为后缀的文件:是汇编语言源代码文件
.S为后缀的文件:是经过预编译的汇编语言源代码文件。</code></pre> 
<h3><strong>1.5 捕捉错误</strong></h3> 
<p>gcc的消息总是具有下面的格式</p> 
<pre><code class="language-bash">文件名:行号:消息</code></pre> 
<p>注意：</p> 
<ol><li>编译器对错误与警告区别对待，前者将阻止编译，后者表明可能存在的问题但并不阻止程序编译。</li><li>很多时候如果不启用 -Wall，程序表面看起来编译正常，但是会产生不正常的结果。</li><li>显而易见，开发程序时不检查警告是非常危险的。如果有函数使用不当，将可能导致程序崩溃或产生错误的结果。开启编译器警告选项 -Wall 可捕捉 C 编程时的多数常见错误。</li></ol> 
<hr> 
<h2><strong>2 gcc编译选项</strong></h2> 
<h3><strong>2.1 基本与常用的编译选项</strong></h3> 
<h4><strong>2.1.1 常用编译基本选项</strong></h4> 
<pre><code class="language-bash">-c           ：只是编译不链接，生成目标文件“.o”
-S           ：只是编译不汇编，生成汇编代码 “.s”
-E           ：只进行预编译，不做其他处理 “.i”
-o  file     ：把输出文件输出到file里，一般用于编译生成可执行文件 
-v           ：打印出编译器内部编译各过程的命令行信息和编译器的版本</code></pre> 
<h4><strong>2.1.2 常用调试基本选项</strong></h4> 
<p>-g：在可执行程序中包含标准调试信息。用操作系统的格式（stabs, COFF, XCOFF, or DWARF）生成调试信息。GDB可以利用这些调试信息进行调试。在大多数采用stabs格式的系统里，"-g"会生成只有GDB能使用的额外信息。与其它大多数C编译器不同，GNU CC允许开关"-g"与"-O"同时使用。优化代码采用的简捷方式可能会产生令人惊异的结果：一些声明了的变量可能根本不出现；控制流可能短暂地移动到你想不到的地方；一些语句因为其结果是常数或值已存在而不被执行；一些语句会被移到循环体外执行。无论如何这使对优化后的代码进行调试成为可能，从而可以使用优化程序处理带有BUG的程序。</p> 
<h4><strong>2.1.3 常用宏相关基本选项</strong></h4> 
<pre><code class="language-bash">-DMACRO          ：定义宏MACRO为字符串"1"。
-DMACRO=DEFN     ：定义宏MACRO为DEFN。 命令行中所有的"-D"开关都在"-U"之前进行处理。
-UMACRO          ：取消宏MACRO的定义。"-U"开关在所有的"-D"开关之后进行处理，但在"-include"和"-imacros"开关之前进行处理。</code></pre> 
<h4><strong>2.1.4 常用警告信息相关选项</strong></h4> 
<pre><code class="language-bash">-Wall          ：输出所有警告信息。
该选项相当于同时使用了下列所有的选项:
    unused-function:遇到仅声明过但尚未定义的静态函数时发出警告。
    unused-label:遇到声明过但不使用的标号的警告。
    unused-parameter:从未用过的函数参数的警告。
    unused-variable:在本地声明但从未用过的变量的警告。
    unused-value:仅计算但从未用过的值得警告。
    Format:检查对 printf 和 scanf 等函数的调用,确认各个参数类型和格式串中的一致。
    implicit-int:警告没有规定类型的声明。
    implicit-function-:在函数在未经声明就使用时给予警告。
    char-subscripts:警告把 char 类型作为数组下标。这是常见错误,程序员经常忘记在某些机器上 char 有符号。
    missing-braces:聚合初始化两边缺少大括号。
    Parentheses:在某些情况下如果忽略了括号,编译器就发出警告。
    return-type:如果函数定义了返回类型,而默认类型是 int 型,编译器就发出警告。同时警告那些不带返回值的 return 语句,如果他们所属的函数并非 void 类型。
    sequence-point:出现可疑的代码元素时,发出报警。
    Switch:如果某条 switch 语句的参数属于枚举类型,但是没有对应的 case语句使用枚举元素,编译器就发出警告(在 switch 语句中使用 default分支能够防止这个警告)。超出枚举范围的 case 语句同样会导致这个警告。
    strict-aliasing:对变量别名进行最严格的检查。
    unknown-pragmas:使用了不允许的#pragma。
    Uninitialized:在初始化之前就使用自动变量</code></pre> 
<p>需要注意的是,各警告选项既然能使之生效,当然也能使之关闭。比如假设我们想要使用-Wall 来启用个选项,同时又要关闭 unused 警告,通过下面的命令来达到目的:</p> 
<pre><code class="language-bash">$ gcc -Wall -Wno-unused test.c -o test</code></pre> 
<p>下面是使用-Wall 选项时没有生效,但又比较常用的一些警告选项。:</p> 
<pre><code class="language-bash">    cast-align：一旦某个指针类型强制转换时,会导致目标所需的地址对齐边界扩展,编译器就发出警告。例如,某些机器上只能在 2 或 4 字节边界上访问整数,如果在这种机型上把 char *强制转换成 int *类型, 编译器就发出警告。
    sign-compare：将有符号类型和无符号类型数据进行比较时发出警告。
    missing-prototypes：如果没有预先声明函数原形就定义了全局函数,编译器就发出警告。即使函数定义自身提供了函数原形也会产生这个警告。这样做的目的是检查没有在头文件中声明的全局函数。
    Packed：当结构体带有 packed 属性但实际并没有出现紧缩式给出警告。
    Padded：如果结构体通过充填进行对齐则给出警告。
    unreachable-code：如果发现从未执行的代码时给出警告。
    Inline：  如果某函数不能内嵌(inline),无论是声明为 inline 或者是指定
    -Werror： 使所有的Warning报告为Error。
    使用该选项后,gcc 发现可疑之处时不会简单的发出警告就算完事,而是将警告作为一个错误而中断编译过程。该选项在希望得到高质量代码时非常有用。
    -w：不生成任何警告信息
</code></pre> 
<h4><strong>2.1.5 常用库相关选项</strong></h4> 
<pre><code class="language-bash">-I dir      ：指定头文件所在的路径 。
-L dir      ：指定库文件所在的路径 。
-static           ：链接库到可执行程序文件中 。
-llibrary     ：连接名为library的库文件(实际上-l属于链接器选项，搜索需要的库的名字)。</code></pre> 
<h4><strong>2.1.6 常用优化相关选项</strong></h4> 
<ul><li>-O0不进行优化。</li><li>-O/O1优化。优化编译会花更长的时间，对大的函数需要更多的内存。不使用"-O"开关，编译器的目标是减少编译开销，进行调试以产生期望的结果。语句是独立的：如果在语句间用断点暂停程序，你可以给任意变量重新赋值，或把程序计数器改到函数的其它语句，最后得到的结果与源代码产生的结果还是一样的。不使用“-O”开关，编译器只把声明为“register”的变量分配到寄存器。这样编译的目标代码比PCC不使用“-O”开关编译产生的代码还差一些。</li><li>-O2进一步优化。GNU CC进行几乎所有支持的优化，但不进行空间速度平衡。编译器在使用"-O2"开关时不进行循环展开或函数内嵌。与开关"-O"相比，这一开关既增加了编译时间，又提高了生成代码的性能。"-O2"开关打开了除循环展开或函数内嵌之外的所有优化开关。也在所有机器上打开"-fforce-mem"开关，在不干扰调试的机器上消除帧指针。</li></ul> 
<h3><strong>2.2 关于库(静态库与动态库)</strong></h3> 
<h4><strong>2.2.1 库的简介</strong></h4> 
<p>@1 什么是库？</p> 
<ul><li>在windows和linux平台下都大量存在着库。本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。</li><li>由于windows和linux的本质不同，因此二者库的二进制是不兼容的。</li></ul> 
<p>@2 库的种类<br> linux下的库有两种：静态库和共享库（动态库）。二者的不同点在于代码被载入的时刻不同。</p> 
<ul><li>静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。</li><li>共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。</li></ul> 
<p>@3 库存在的意义</p> 
<ul><li>库是别人写好的现有的，成熟的，可以复用的代码，你可以使用但要记得遵守许可协议。</li><li>现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。</li><li>共享库的好处是，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。</li></ul> 
<p>@4 库文件是如何命名的，有没有什么规范<br> 在linux下，库文件一般放在/usr/lib /lib下：</p> 
<ul><li>静态库的名字一般为libxxxx.a，其中xxxx是该lib的名称</li><li>动态库的名字一般为libxxxx.so.major.minor，xxxx是该lib的名称，major是主版本号， minor是副版本号</li></ul> 
<p>@5 在linux下如何知道一个可执行程序依赖哪些库<br> ldd命令可以查看一个可执行程序依赖的共享库，例如</p> 
<pre><code class="language-bash"># ldd /bin/lnlibc.so.6
=&gt; /lib/libc.so.6 (0×40021000)/lib/ld-linux.so.2
=&gt; /lib/ld- linux.so.2 (0×40000000)</code></pre> 
<p>可以看到ln命令依赖于libc库和ld-linux库。</p> 
<p>@6 可执行程序在执行的时候如何定位共享库文件</p> 
<p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径，此时就需要系统动态载入器(dynamic linker/loader)，对于elf格式的可执行程序，是由ld -linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段，环境变量LD_LIBRARY_PATH    /etc/ld.so.cache文件列表—/lib/,/usr/lib目录找到库文件后将其载入内存。</p> 
<p>@7 在新安装一个库之后如何让系统能够找到他</p> 
<p>如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下：</p> 
<pre><code class="language-bash">编辑/etc/ld.so.conf文件，加入库文件所在目录的路径
运行ldconfig，该命令会重建/etc/ld.so.cache文件</code></pre> 
<h4><strong>2.2.2 静态库的编写过程</strong></h4> 
<p>@1 生成静态链接库的过程：</p> 
<pre><code class="language-bash">     gcc -c xx1.c xx2.c
     ar rcs libxxx.a xx1.o(目标文件1) xx2.o(目标文件2)</code></pre> 
<p>@2 静态库的使用：</p> 
<pre><code class="language-bash">     gcc -c main.c -I(头文件路径) -L(库文件所在路径) -llibxxx.a</code></pre> 
<h4><strong>2.2.3 动态库的编译过程</strong></h4> 
<p>@1 生成动态库的过程</p> 
<pre><code class="language-bash">    gcc -c -fPIC xx1.c xx2.c
    gcc -shared -o libxxx.so xx1.o(目标文件1) xx2.o(目标文件2)</code></pre> 
<p>@2 动态库的使用</p> 
<pre><code class="language-bash"> gcc -c main.c -I(头文件路径) -L(库文件所在路径) -llibxxx.so</code></pre> 
<h4><strong>2.2.4 关于库需要注意的地方</strong></h4> 
<p>@1 当静态库和动态库同名时， gcc命令将优先使用动态库。</p> 
<p>@2 动态库的路径问题 为了让执行程序顺利找到动态库，有三种方法：</p> 
<p>方法1：把库拷贝到/usr/lib和/lib目录下。</p> 
<p>方法2：在LD_LIBRARY_PATH 环境变量中加上库所在路径。例如动态库libhello.so在/home/ting/lib目录下，则使用命令：</p> 
<pre><code class="language-bash">$export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/ting/lib</code></pre> 
<p>方法3：修改/etc/ld.so.conf文件，把库所在的路径加到文件末尾，执行ldconfig刷新。加入的目录下的所有库文件都可见。</p> 
<p>@3 查看库中的符号：有时候可能需要查看一个库中到底有哪些函数，nm命令可以打印出库中的涉及到的所有符号。库既可以是静态的也可以是动态的。nm列出的符号有很多，常见的有三种：</p> 
<ol><li>一种是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；</li><li>一种是库中定义的函数，用T表示，这是最常见的；</li><li>另外一种是所谓的“弱 态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。</li></ol> 
<p>例如，假设开发者希望知道上文提到的hello库中是否定义了 printf():</p> 
<pre><code class="language-bash">$nm libhello.so |grep printf U；</code></pre> 
<p>其中printf U表示符号printf被引用，但是并没有在函数内定义，由此可以推断，要正常使用hello库，必须有其它库支持，再使用ldd命令查看hello依赖于哪些库：</p> 
<pre><code class="language-bash">$ldd hello libc.so.6=&gt;/lib/libc.so.6(0x400la000) /lib/ld-linux.so.2=&gt;/lib/ld-linux.so.2 (0x40000000)</code></pre> 
<p>@4 关于参数-WI的一些说明：</p> 
<pre><code class="language-bash">$gcc -shared -Wl,-soname,libhello.so.1 -o libhello.so.1.0 hello.o</code></pre> 
<p>另外再建立两个符号连接：</p> 
<pre><code class="language-bash">$ln -s libhello.so.1.0 libhello.so.1
$ln -s libhello.so.1 libhello.so</code></pre> 
<p>这样一个libhello的动态连接库就生成了。最重要的是传gcc -shared 参数使其生成是动态库而不是普通的执行程序。 -Wl 表示后面的参数也就是-soname , libhello.so.1直接传给连接器ld进行处理。实际上，每一个库都有一个soname，当连接器发现它正在查找的程序库中有这样一个名称，连接器便会将soname嵌入连结中的二进制文件内，而不是它正在运行的实际文件名，在程序执行期间，程序会查找拥有 soname名字的文件，而不是库的文件名，换句话说，soname是库的区分标志。 这样做的目的主要是允许系统中多个版本的库文件共存，习惯上在命名库文件的时候通常与soname相同 libxxxx.so.major.minor。</p> 
<p>@5 如果要和多个库相连接，而每个库的连接方式不一样，比如程序既要和libhello进行静态连接，又要和libbye进行动态连接，其命令应为：</p> 
<pre><code class="language-bash">$gcc testlib.o -o testlib -WI,-Bstatic -lhello -WI,-Bdynamic -lbye；其中-WI类似于分隔符的作用。</code></pre> 
<h3><strong>2.3 gcc编译器的工具链</strong></h3> 
<p>gcc的整套开发工具链包括以下工具：</p> 
<p>Binutils:：一组用于编译，链接，汇编和其他调试目的的程序，包括ar,as,ld,nm,objcopy,objdump,ranlib,readelf,size,strings,strip等。这些工具的作用如下：</p> 
<pre><code class="language-bash">    ar               ：生成静态库。
    as               ：汇编器。
    ld               ：链接器。
    nm               ：查看目标文件中的符号。
    objcopy     ：将原目标文件中的内容复制到新目标文件中，可以通过不同的参数选项调整目标文件的格式，如去掉ELF文件头。
    objdump     ：以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。
    ranlib          ：为静态库文件创建索引，相当于ar命令的-s选项。
    readelf          ：读取ELF文件头。
    size          ：列出目标文件每个段的大小和总的大小。
    strings          ：列出目标文件中的所有字符串。
    strip          ：取出目标文件中的所有符号，使得文件尺寸变小。</code></pre> 
<p>gcc：gnu的编译器集合，linux下的默认编译器。<br> glibc：gnu的C标准函数库。该库实现了linux的系统函数，例如open、read等，也实现了C语言库，如printf等。几乎所有的应用程序都要和glibc链接。</p> 
<h3><strong>2.4 链接原理简介</strong></h3> 
<h4><strong>2.4.1 链接器的任务</strong></h4> 
<p>链接器将多个目标文件链接成一个完整的，可加载的，可执行的目标文件。其输入是一组可重定位的目标文件。链接的任务：</p> 
<ol><li>符号解析：将多个目标文件内的引用符号和该符号的定义联系起来。</li><li>将符号定义与存储器的位置联系起来，修该对这些符号的作用。</li></ol> 
<h4><strong>2.4.2 ELF格式的目标文件</strong></h4> 
<p><span style="color:#4d4d4d;">ELF格式的目标文件有三种形式，如下：</span></p> 
<ol><li>可重定位目标文件：.o文件。包含二进制代码和数据，已经转换成了机器指令代码和数据，但是这样还不能直接执行，因为这些指令和数据往往引用其他模块中的符号，而这些其他模块中的符号对于本模块来说是未知的，这些符号需要链接器将所有的模块进行链接，这种操作称为“重定位”。</li><li>可执行目标文件：一般是无后缀的文件。含二进制代码和数据，已经转换成了机器指令代码和数据，而且能直接执行，因为已经经过链接，和所有模块的目标文件都产生了联系，链接器将所有需要的可重定位目标文件链接成一个可执行目标文件，这时其他模块中的符号对于本模块来说是已知的，都得到了解析和重定位，因此该文件能被直接执行。</li><li>共享目标文件：.so文件。一种特殊类型的可重定位目标文件。可以在需要它的程序中运行与加载，可以动态地加载到内存中运行。共享目标文件又称为“动态库”或者“共享库”文件。</li></ol> 
<h4><strong>2.4.3 ELF格式的可重定定位目标文件</strong></h4> 
<p>ELF文件是linux环境下最常用的目标文件格式，在大多数情况下，无论是可重定位的目标文件还是可执行目标文件均采用这种方式。关于ELF文件的一些说明：</p> 
<ul><li>ELF文件不仅包含二进制代码和数据，还包括很多链接器解析符号和解释目标文件信息。</li><li>ELF文件由两个部分组成，ELF文件头和目标文件的段。</li><li>ELF文件头前16个字节构成了一个字节序，描述了该文件系统生成的字长以及字节序，剩下的部分包括了ELF文件的一些其他信息，包括文件头的大小、目标文件的类型、目标及的类型、段头部表在目标文件内的文件偏移位置等。</li></ul> 
<p>ELF文件中目标文件的段是核心部分，由以下几个段组成：</p> 
<pre><code class="language-bash">    .text          :代码段。存储二进制的机器指令，可以被机器直接执行。
    .rodata          :只读数据段。存储程序中使用的复杂常量，如字符串等。
    .data          :数据段。存储程序中已经明确被初始化的全局数据，包括全局变量和静态变量，
                   注意：如果这些变量被初始化成0，则不存储在数据段中，而是存储在块数据段中。
    .bss          :块存储段。存储未被明确初始化的全局数据，在目标文件中这个段并不占用实际的空间，而仅仅是一个占位符，
                   以告知指定位置上应当预留全局数据的空间。(块缓存段的存在实际上是为了提高磁盘上存储空间的利用率)
    .symtab     :符号表。存储定义和引用的函数。每个可重定位的目标文件中都要有这样的一个表。在该表中，所有引用的本末块内的全局符号以及其他模块中的全局符号都要有一个登记。链接中的重定位操作就是将这些引用的全局符号的位置确定。
    .rel.text     :代码段需要的重定位信息。在代码段中，通常是一些函数名和标号，存储需要靠重定位操作修改位置的符号的汇总。
    .rel.data     :数据段需要的重定位信息。在数据段中，通常是一些全局变量，存储需要靠重定位操作修改位置的符号的汇总。
    .debug          :调试信息，存储一个用于调试的符号表。编译过程中使用-g会生成该段，该表包含源程序中所有符号的引用和定义。
                   有了这个段才可以在调试程序的时候打印并且观察变量的值。
    .line          :源程序的行号映射，程序中每个语句的行号，编译时使用-g会生成该段。
    .strtab          :字符串表。存储.symtab符号表和.debug符号表中符号的名字，这些名字是字符串，以‘\0’结束。</code></pre> 
<h4><strong>2.4.4 目标文件中的符号表</strong></h4> 
<p>利用readeldf工具可以打开文件xx.o查看符号表。在文件的最后面一块。<br> 链接器需要完成的任务：符号解析(找到所有符号则准备重定位，找不到则报错)-&gt;重定位。</p> 
<h4><strong>2.4.5 重定位的概念</strong></h4> 
<p>重定位分以下两个步骤进行：</p> 
<ol><li>重定位段：将所有目标文件中同类型的段合并，生成一个大段，合并后，程序中的指令和变量就拥有一个统一的并且惟一的运行时地址了。</li><li>重定位符号引用：由于目标文件中相同的段已经合并，因此程序对符号的引用位置就作废了。这时链接器需要修改这些引用符号的地址，使其指向正确的运行时的地址。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c0e0c384b248222229a6f1e50e870fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">引用类型和基本类型的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99de20887726ebdbe03ce51c428842a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java8 Stream流Collectors.toMap当key重复时报异常（IllegalStateException）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>