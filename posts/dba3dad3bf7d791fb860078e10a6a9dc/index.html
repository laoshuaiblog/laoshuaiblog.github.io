<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GC是如何判断一个对象为&#34;垃圾&#34;的？被GC判断为&#34;垃圾&#34;的对象一定会被回收吗？ - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/dba3dad3bf7d791fb860078e10a6a9dc/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="GC是如何判断一个对象为&#34;垃圾&#34;的？被GC判断为&#34;垃圾&#34;的对象一定会被回收吗？">
  <meta property="og:description" content="一.GC如何判断一个对象为”垃圾”的 java堆内存中存放着几乎所有的对象实例，垃圾收集器在对堆进行回收前,第一件事情就是要确定这些对象之中哪些还“存活”着,哪些已经“死去”。那么GC具体通过什么手段来判断一个对象已经”死去”的？
1.引用计数算法(已被淘汰的算法) 给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加1;当引用失效时,计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。
目前主流的java虚拟机都摒弃掉了这种算法，最主要的原因是它很难解决对象 之间相互循环引用的问题。尽管该算法执行效率很高。
2.可达性分析算法 目前主流的编程语言(java,C#等)的主流实现中,都是称通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。如下图所示，对象object 5、object 6、object 7虽然互相有关联,但是它们到GC Roots是不可达的,所以它们将会被判定为是可回收的对象。
在Java语言中,可作为GC Roots的对象包括下面几种:
虚拟机栈(栈帧中的本地变量表)中引用的对象。方法区中类静态属性引用的对象。方法区中常量引用的对象。本地方法栈中JNI(即一般说的Native方法)引用的对象。 二.被GC判断为”垃圾”的对象一定会回收吗 即使在可达性分析算法中不可达的对象,也并非是“非死不可”的,这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)
如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况),将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。
finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱,那基本上它就真的被回收了。
代码示例:
public class FinalizeEscapeGC { public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() { System.out.println(&#34;yes,i am still alive:)&#34;); } @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(&#34;finalize mehtod executed!&#34;); FinalizeEscapeGC.SAVE_HOOK = this; } public static void main(String[] args) throws Throwable { SAVE_HOOK = new FinalizeEscapeGC(); // 对象第一次成功拯救自己 SAVE_HOOK = null; System.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-04-01T16:34:19+08:00">
    <meta property="article:modified_time" content="2016-04-01T16:34:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GC是如何判断一个对象为&#34;垃圾&#34;的？被GC判断为&#34;垃圾&#34;的对象一定会被回收吗？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4 id="一gc如何判断一个对象为垃圾的">一.GC如何判断一个对象为”垃圾”的</h4> 
<p>java堆内存中存放着几乎所有的对象实例，垃圾收集器在对堆进行回收前,第一件事情就是要确定这些对象之中哪些还“存活”着,哪些已经“死去”。那么GC具体通过什么手段来判断一个对象已经”死去”的？</p> 
<h5 id="1引用计数算法已被淘汰的算法"><strong>1.引用计数算法(已被淘汰的算法)</strong></h5> 
<p><strong>给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加1;当引用失效时,计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。</strong></p> 
<p>目前主流的java虚拟机都摒弃掉了这种算法，最主要的原因是它很难解决对象 <br> 之间相互循环引用的问题。尽管该算法执行效率很高。</p> 
<h5 id="2可达性分析算法"><strong>2.可达性分析算法</strong></h5> 
<p>目前主流的编程语言(java,C#等)的主流实现中,都是称通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路<strong>就是通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。</strong>如下图所示，对象object 5、object 6、object 7虽然互相有关联,但是它们到GC Roots是不可达的,所以它们将会被判定为是可回收的对象。</p> 
<p><img src="https://images2.imgbox.com/22/bc/o7JGdTYE_o.png" alt="这里写图片描述" title=""></p> 
<p>在Java语言中,可作为GC Roots的对象包括下面几种:</p> 
<blockquote> 
 <ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象。</li></ul> 
</blockquote> 
<h4 id="二被gc判断为垃圾的对象一定会回收吗">二.被GC判断为”垃圾”的对象一定会回收吗</h4> 
<p>即使在可达性分析算法中不可达的对象,也并非是“非死不可”的,这时候它们<strong>暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历两次标记过程</strong>:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,<strong>筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)</strong></p> 
<p>如果这个对象被判定为有必要执行finalize()方法,那么<strong>这个对象将会放置在一个叫做F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。</strong>这里所谓的“执行”是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况),将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。</p> 
<p><strong>finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可</strong>,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;<strong>如果对象这时候还没有逃脱,那基本上它就真的被回收了。</strong></p> 
<p>代码示例:</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> FinalizeEscapeGC {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="hljs-keyword">null</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isAlive</span>() {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"yes,i am still alive:)"</span>);
    }

    @Override
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span>() throws Throwable {
        super.finalize();
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"finalize mehtod executed!"</span>);
        FinalizeEscapeGC.SAVE_HOOK = <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws Throwable {
        SAVE_HOOK = <span class="hljs-keyword">new</span> FinalizeEscapeGC();
        <span class="hljs-comment">// 对象第一次成功拯救自己</span>
        SAVE_HOOK = <span class="hljs-keyword">null</span>;
        System.gc();
        <span class="hljs-comment">// 因为finalize方法优先级很低,所以暂停0.5秒以等待它</span>
        Thread.sleep(<span class="hljs-number">500</span>);
        <span class="hljs-keyword">if</span> (SAVE_HOOK != <span class="hljs-keyword">null</span>) {
            SAVE_HOOK.isAlive();
        } <span class="hljs-keyword">else</span> {
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"no,i am dead:("</span>);
        }
        <span class="hljs-comment">// 下面这段代码与上面的完全相同,但是这次自救却失败了</span>
        SAVE_HOOK = <span class="hljs-keyword">null</span>;
        System.gc();
        <span class="hljs-comment">// 因为finalize方法优先级很低,所以暂停0.5秒以等待它</span>
        Thread.sleep(<span class="hljs-number">500</span>);
        <span class="hljs-keyword">if</span> (SAVE_HOOK != <span class="hljs-keyword">null</span>) {
            SAVE_HOOK.isAlive();
        } <span class="hljs-keyword">else</span> {
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"no,i am dead:("</span>);
        }
    }
}
</code></pre> 
<p>运行结果:</p> 
<pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">finalize</span> <span class="hljs-tag">mehtod</span> <span class="hljs-tag">executed</span>!
<span class="hljs-tag">yes</span>,<span class="hljs-tag">i</span> <span class="hljs-tag">am</span> <span class="hljs-tag">still</span> <span class="hljs-tag">alive</span><span class="hljs-pseudo">:)</span>
<span class="hljs-tag">no</span>,<span class="hljs-tag">i</span> <span class="hljs-tag">am</span> <span class="hljs-tag">dead</span><span class="hljs-pseudo">:(</span></code></pre> 
<p>SAVE_HOOK对象的finalize()方法确实被GC收集器触发过,并且在被收集前成功逃脱了。另外一个值得注意的地方是,代码中有两段完全一样的代码片段,执行结果却是一次逃脱成功,一次失败,这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次,如果对象面临下一次回收,它的finalize()方法不会被再次执行,因此第二段代码的自救行动失败了。</strong>因为finalize()方法已经被虚拟机调用过,虚拟机都视为“没有必要执行”。(即意味着直接回收)</p> 
<p>《深入理解java虚拟机 JVM高级特性与最佳实践》周志明</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/937d60e08cf0af1903f871a4e42d4014/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">8.plsql里的包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6b45b10cca6a8af8754ddfa26d58b51c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">平均查找长度详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>