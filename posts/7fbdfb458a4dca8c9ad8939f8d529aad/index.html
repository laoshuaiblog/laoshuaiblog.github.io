<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>黑盒测试思维导图 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/7fbdfb458a4dca8c9ad8939f8d529aad/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="黑盒测试思维导图">
  <meta property="og:description" content="黑盒测试
概念 关注程序外部结构，不考虑内部逻辑结构，只注重执行结果和外部特性注重软件的功能性需求，主要针对软件界面和软件功能进行测试基本思路 黑盒测试是以用户的角度，以输入数据与输出数据的对应关系出发进行测试的，又称数据驱动测试黑盒测试是在程序外部接口进行的测试黑盒测试发现的主要类型 输入输出错误初始化或终止性错误功能遗漏或者不正确界面错误性能不符合要求数据库和其他外部数据结构访问错误安全性错误黑盒测试用例设计方法 等价类划分 等价类 是指某个输入域的子集合 在该子集合中，各个输入数据对于揭露程序中的错误都是等效的测试某等价类的代表值就等价于对这一类其他值的测试有效等价类 对于软件规格说明来说，合理的、有意义的输入数据构成的集合无效等价类 对于软件规格说明来说，不合理的、无意义的输入数据构成的集合步骤 1、划分等价类（有效等价类和无效等价类） 按双边区间划分按取值划分按单边区间划分按限制条件/规则划分2、建立等价类表，等价类进行编号3、通过等价类导出测试用例 编号唯一尽可能多的覆盖尚未覆盖的有效等价类仅覆盖一个无效等价类覆盖所有的有效和无效等价类测试用例设计法 弱等价类测试 弱一般等价类 至少覆盖一次，取值不组合，不考虑异常区域策略 对于有效输入，取每个有效等价类的一个值不取无效等价类弱健壮等价类 取值不组合，要考虑异常区域，这是传统的等价类测试策略 对于有效输入，取每个有效等价类的一个值对于无效输入，测试用例将拥有一个无效值，并保持区域的值是有效的强等价类测试 强一般等价类 取值组合，不考虑异常区域，测试用例的设计时需要考虑等价类之间的相互作用，选取等价类的笛卡尔积的元素值来实现策略 对于有效输入，取每个有效等价类的一个值对于无效输入不考虑强健壮等价类 取值组合，考虑异常区域。这种测试也考虑到了从无效等价类取值，同时考虑多个等价类之间的互相影响策略 从所有的等价类笛卡尔乘积中选取（组合）边界值测试法 概念 是对输入或输出的边界值进行测试他作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界步骤 1、确定边界情况、2、选取测试数据3、导出测试用例测试用例设计法 一般边界条件测试用例设计法 每次保留程序中的一个变量，让其余的变量取正常值，被保留的变量依次是min、min&#43;、nom、max-，max对程序中每个变量重复健壮性边界条件测试用例设计法 每次保留程序中的一个变量，让其余的变量取正常值，被保留的变量依次是min-1、min、min&#43;、nom、max-，max、，max&#43;对程序中每个变量重复最坏边界条件测试用例设计法 所有的变量均可取min、min&#43;、nom、max-，max这五个边界值的任何一个测试用例为五个集合的笛卡尔积健壮最坏边界条件测试用例设计法 所有的变量均可取所有的变量均可取min、min&#43;、nom、max-，max这七个边界值的任何一个测试用例为七个集合的笛卡尔积错误推测法 概念 基于经验、问题分析和直觉推测程序中可能存在的各种错误前提 需要测试人员具有一定的经验软件常见缺陷 1、对输入数据没有限制和校验2、对单次数据查询的结果集大小没有约束3、网站页面执行错误时会将服务器的调试信息显示在页面上程序执行时易错情况 1、对空数据表执行删除记录操作2、重复删除记录3、添加两条相同的记录4、采用空字符串进行登录应用 登陆测试错误推测法 (1 )采用空字符串进行登录。(2)采用空格字符串进行登录。(3)输入的登录名和密码前后存在空格是否能够正常登录。(4)登录时输入SQL代码进行注入式攻击，会不会被拦截。(5)输入的密码是否加密显示。(6)密码能否复制和粘贴。(7)用户在注销之后是否能够马上再次登录。(8)是否允许同一账号在不同的客户端重复登录。(9)用户名和密码是否区分大小写。( 10)是否明确提示用户名错误或者明确提示密码错误。( 11 )是否能够较为容易地对账号和密码进行暴力破解。数据库操作测试错误推测法 (1 )对空数据表执行删除记录操作。(2)重复删除记录。( 3)添加两条相同的记录。(4)无条件查询能否执行。(5)查询的关键字之间是否可用连接符，是否能输入SQL代码。(6)输入正确的查询条件，并在前面加上空格，看查询是否能正确地执行。(7)是否支持模糊查询，对模糊查询有没有限制。(8)数据操作出错后的提示会不会泄露敏感信息。缺点 无法保证测试的覆盖率，通常不宜单独使用判定表法 用处 能够把复杂的问题按各种情况一一列举，简明易于理解，可避免疏漏适合处理针对不同的逻辑条件的组合值分别执行不同操作的数据处理问题组成 条件桩：列出问题的所有条件动作桩：列出所有可能的操作条件项：列出各个条件的具体取值动作项：列出在各个条件的具体取值下，应该采取的具体的动作判定表 也称决策表，是一个用来表达条件和行动的二维表，是分析和表达多逻辑条件下不同操作的情况的工具可以清晰地表达条件、决策规则和应采取的行动之间的逻辑关系判定表很适合描述不同条件集合下采取行动的若干组合的情况判定表驱动法 或决策表法，是根据需求描述建立判定表后，导出测试用例的方法在所有黑盒测试方法中，基于判定表的测试是最为严格、最具有逻辑性的测试方法可以设计出完整的测试用例集合判定表的类型 有限条目判定表 特点:所有条件都是二值条件C真/假)扩展条目判定表 特点:条件可以有多个值判定表的建立步骤 1、确定规则的条数2、列出所有的条件桩和动作桩3、填入条件的不同取值组合4、填入具体动作，得到初始判定表5、化简，合并一些具有相同动作的相似规则 约束：另外两个条件取当前值的前提下结果与第三个条件无关合并后的条件项用符号“—”表示，说明执行的动作与该条件无关，也称无关条件适合使用判定表驱动法的条件 (1 )程序规格说明以判定表形式给出，或很容易转换成判定表。(2)条件的排列顺序不会也不影响执行哪些操作。(3)规则的排列顺序不会也不影响执行哪些操作。(4)每当某一规则的条件已经满足，并确定要执行的操作后，不必检验别的规则。(5)如果某一规则得到满足 要执行多个操作，这些操作的执行顺序无关紧要。因果图法 用法 当被测对象的输入条件相互依赖、相互制约的时候，适合用因果图法进行测试概念 因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法因果图提供了一个把需求转化为判定表的系统化方法因果图法最后生成的就是判定表，它适合于检查程序输入条件的各种组合情况因果图的关系符号 因果图的四种基本关系 恒等 恒等:若原因出现，则结果出现;若原因不出现，则结果也不出现。父主题 非(~ ) 非(~ ):若原因出现，则结果不出现;若原因不出现，则结果出现或(V) 或(V):若几个原因中有一个出现，则结果出现;若几个原因都不出现，则结果不出现与(N) 与(N):若几个原因都出现，结果才出现:若其中有一个原因不出现，因果图的基本图形符号因果图的约束符号 因果图的五种约束类型 E约束(互斥) (1)E约束(互斥):表示不同时为1，即a、b、c中至多只有一个1:I约束(包含) (2)I约束(包含):表示至少有一个1，即a、B、c中不同时为0;0约束(唯一-) (3)0约束(唯一-):表示a b、c中有且仅有一一个1;R约束(要求) (4)R约束(要求):表示若a=1，则b必须为1。即不可能a=1日b=0M约束( 屏蔽) （5）输出的约束只有M约束( 屏蔽):若结果a是1.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-09-05T10:26:18+08:00">
    <meta property="article:modified_time" content="2022-09-05T10:26:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">黑盒测试思维导图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" class="left" height="1200" src="https://images2.imgbox.com/78/dd/oRIS7grS_o.png" width="1200"></p> 
<p></p> 
<p> </p> 
<p style="margin-left:.0001pt;"><strong><span style="color:#000000;">黑盒测试</span></strong></p> 
<p style="margin-left:.0001pt;"></p> 
<ul><li style="text-align:left;"><span style="color:#000000;">概念</span> 
  <ul><li style="text-align:left;"><span style="color:#000000;">关注程序外部结构，不考虑内部逻辑结构，只注重执行结果和外部特性</span></li><li style="text-align:left;"><span style="color:#000000;">注重软件的功能性需求，主要针对软件界面和软件功能进行测试</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">基本思路</span> 
  <ul><li style="text-align:left;"><span style="color:#000000;">黑盒测试是以用户的角度，以输入数据与输出数据的对应关系出发进行测试的，又称数据驱动测试</span></li><li style="text-align:left;"><span style="color:#000000;">黑盒测试是在程序外部接口进行的测试</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">黑盒测试发现的主要类型</span> 
  <ul><li style="text-align:left;"><span style="color:#000000;">输入输出错误</span></li><li style="text-align:left;"><span style="color:#000000;">初始化或终止性错误</span></li><li style="text-align:left;"><span style="color:#000000;">功能遗漏或者不正确</span></li><li style="text-align:left;"><span style="color:#000000;">界面错误</span></li><li style="text-align:left;"><span style="color:#000000;">性能不符合要求</span></li><li style="text-align:left;"><span style="color:#000000;">数据库和其他外部数据结构访问错误</span></li><li style="text-align:left;"><span style="color:#000000;">安全性错误</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">黑盒测试用例设计方法</span> 
  <ul><li style="text-align:left;"><span style="color:#000000;">等价类划分</span> 
    <ul><li style="text-align:left;"><span style="color:#000000;">等价类</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">是指某个输入域的子集合</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">在该子集合中，各个输入数据对于揭露程序中的错误都是等效的</span></li><li style="text-align:left;"><span style="color:#000000;">测试某等价类的代表值就等价于对这一类其他值的测试</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">有效等价类</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">对于软件规格说明来说，合理的、有意义的输入数据构成的集合</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">无效等价类</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">对于软件规格说明来说，不合理的、无意义的输入数据构成的集合</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">步骤</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">1、划分等价类（有效等价类和无效等价类）</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">按双边区间划分</span></li><li style="text-align:left;"><span style="color:#000000;">按取值划分</span></li><li style="text-align:left;"><span style="color:#000000;">按单边区间划分</span></li><li style="text-align:left;"><span style="color:#000000;">按限制条件/规则划分</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">2、建立等价类表，等价类进行编号</span></li><li style="text-align:left;"><span style="color:#000000;">3、通过等价类导出测试用例</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">编号唯一</span></li><li style="text-align:left;"><span style="color:#000000;">尽可能多的覆盖尚未覆盖的有效等价类</span></li><li style="text-align:left;"><span style="color:#000000;">仅覆盖一个无效等价类</span></li><li style="text-align:left;"><span style="color:#000000;">覆盖所有的有效和无效等价类</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">测试用例设计法</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">弱等价类测试</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">弱一般等价类</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">至少覆盖一次，取值不组合，不考虑异常区域</span></li><li style="text-align:left;"><span style="color:#000000;">策略</span> 
            <ul><li style="text-align:left;"><span style="color:#000000;">对于有效输入，取每个有效等价类的一个值</span></li><li style="text-align:left;"><span style="color:#000000;">不取无效等价类</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">弱健壮等价类</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">取值不组合，要考虑异常区域，这是传统的等价类测试</span></li><li style="text-align:left;"><span style="color:#000000;">策略</span> 
            <ul><li style="text-align:left;"><span style="color:#000000;">对于有效输入，取每个有效等价类的一个值</span></li><li style="text-align:left;"><span style="color:#000000;">对于无效输入，测试用例将拥有一个无效值，并保持区域的值是有效的</span></li></ul></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">强等价类测试</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">强一般等价类</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">取值组合，不考虑异常区域，测试用例的设计时需要考虑等价类之间的相互作用，选取等价类的笛卡尔积的元素值来实现</span></li><li style="text-align:left;"><span style="color:#000000;">策略</span> 
            <ul><li style="text-align:left;"><span style="color:#000000;">对于有效输入，取每个有效等价类的一个值</span></li><li style="text-align:left;"><span style="color:#000000;">对于无效输入不考虑</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">强健壮等价类</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">取值组合，考虑异常区域。这种测试也考虑到了从无效等价类取值，同时考虑多个等价类之间的互相影响</span></li><li style="text-align:left;"><span style="color:#000000;">策略</span> 
            <ul><li style="text-align:left;"><span style="color:#000000;">从所有的等价类笛卡尔乘积中选取（组合）</span></li></ul></li></ul></li></ul></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">边界值测试法</span> 
    <ul><li style="text-align:left;"><span style="color:#000000;">概念</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">是对输入或输出的边界值进行测试</span></li><li style="text-align:left;"><span style="color:#000000;">他作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">步骤</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">1、确定边界情况、</span></li><li style="text-align:left;"><span style="color:#000000;">2、选取测试数据</span></li><li style="text-align:left;"><span style="color:#000000;">3、导出测试用例</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">测试用例设计法</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">一般边界条件测试用例设计法</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">每次保留程序中的一个变量，让其余的变量取正常值，被保留的变量依次是min、min+、nom、max-，max</span></li><li style="text-align:left;"><span style="color:#000000;">对程序中每个变量重复</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">健壮性边界条件测试用例设计法</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">每次保留程序中的一个变量，让其余的变量取正常值，被保留的变量依次是min-1、min、min+、nom、max-，max、，max+</span></li><li style="text-align:left;"><span style="color:#000000;">对程序中每个变量重复</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">最坏边界条件测试用例设计法</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">所有的变量均可取min、min+、nom、max-，max这五个边界值的任何一个</span></li><li style="text-align:left;"><span style="color:#000000;">测试用例为五个集合的笛卡尔积</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">健壮最坏边界条件测试用例设计法</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">所有的变量均可取所有的变量均可取min、min+、nom、max-，max这七个边界值的任何一个</span></li><li style="text-align:left;"><span style="color:#000000;">测试用例为七个集合的笛卡尔积</span></li></ul></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">错误推测法</span> 
    <ul><li style="text-align:left;"><span style="color:#000000;">概念</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">基于经验、问题分析和直觉推测程序中可能存在的各种错误</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">前提</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">需要测试人员具有一定的经验</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">软件常见缺陷</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">1、对输入数据没有限制和校验</span></li><li style="text-align:left;"><span style="color:#000000;">2、对单次数据查询的结果集大小没有约束</span></li><li style="text-align:left;"><span style="color:#000000;">3、网站页面执行错误时会将服务器的调试信息显示在页面上</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">程序执行时易错情况</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">1、对空数据表执行删除记录操作</span></li><li style="text-align:left;"><span style="color:#000000;">2、重复删除记录</span></li><li style="text-align:left;"><span style="color:#000000;">3、添加两条相同的记录</span></li><li style="text-align:left;"><span style="color:#000000;">4、采用空字符串进行登录</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">应用</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">登陆测试错误推测法</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">(1 )采用空字符串进行登录。</span></li><li style="text-align:left;"><span style="color:#000000;">(2)采用空格字符串进行登录。</span></li><li style="text-align:left;"><span style="color:#000000;">(3)输入的登录名和密码前后存在空格是否能够正常登录。</span></li><li style="text-align:left;"><span style="color:#000000;">(4)登录时输入SQL代码进行注入式攻击，会不会被拦截。</span></li><li style="text-align:left;"><span style="color:#000000;">(5)输入的密码是否加密显示。</span></li><li style="text-align:left;"><span style="color:#000000;">(6)密码能否复制和粘贴。</span></li><li style="text-align:left;"><span style="color:#000000;">(7)用户在注销之后是否能够马上再次登录。</span></li><li style="text-align:left;"><span style="color:#000000;">(8)是否允许同一账号在不同的客户端重复登录。</span></li><li style="text-align:left;"><span style="color:#000000;">(9)用户名和密码是否区分大小写。</span></li><li style="text-align:left;"><span style="color:#000000;">( 10)是否明确提示用户名错误或者明确提示密码错误。</span></li><li style="text-align:left;"><span style="color:#000000;">( 11 )是否能够较为容易地对账号和密码进行暴力破解。</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">数据库操作测试错误推测法</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">(1 )对空数据表执行删除记录操作。</span></li><li style="text-align:left;"><span style="color:#000000;">(2)重复删除记录。</span></li><li style="text-align:left;"><span style="color:#000000;">( 3)添加两条相同的记录。</span></li><li style="text-align:left;"><span style="color:#000000;">(4)无条件查询能否执行。</span></li><li style="text-align:left;"><span style="color:#000000;">(5)查询的关键字之间是否可用连接符，是否能输入SQL代码。</span></li><li style="text-align:left;"><span style="color:#000000;">(6)输入正确的查询条件，并在前面加上空格，看查询是否能正确地执行。</span></li><li style="text-align:left;"><span style="color:#000000;">(7)是否支持模糊查询，对模糊查询有没有限制。</span></li><li style="text-align:left;"><span style="color:#000000;">(8)数据操作出错后的提示会不会泄露敏感信息。</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">缺点</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">无法保证测试的覆盖率，通常不宜单独使用</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">判定表法</span> 
    <ul><li style="text-align:left;"><span style="color:#000000;">用处</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">能够把复杂的问题按各种情况一一列举，简明易于理解，可避免疏漏</span></li><li style="text-align:left;"><span style="color:#000000;">适合处理针对不同的逻辑条件的组合值分别执行不同操作的数据处理问题</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">组成</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">条件桩：列出问题的所有条件</span></li><li style="text-align:left;"><span style="color:#000000;">动作桩：列出所有可能的操作</span></li><li style="text-align:left;"><span style="color:#000000;">条件项：列出各个条件的具体取值</span></li><li style="text-align:left;"><span style="color:#000000;">动作项：列出在各个条件的具体取值下，应该采取的具体的动作</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">判定表</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">也称决策表，是一个用来表达条件和行动的二维表，是分析和表达多逻辑条件下不同操作的情况的工具</span></li><li style="text-align:left;"><span style="color:#000000;">可以清晰地表达条件、决策规则和应采取的行动之间的逻辑关系</span></li><li style="text-align:left;"><span style="color:#000000;">判定表很适合描述不同条件集合下采取行动的若干组合的情况</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">判定表驱动法</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">或决策表法，是根据需求描述建立判定表后，导出测试用例的方法</span></li><li style="text-align:left;"><span style="color:#000000;">在所有黑盒测试方法中，基于判定表的测试是最为严格、最具有逻辑性的测试方法</span></li><li style="text-align:left;"><span style="color:#000000;">可以设计出完整的测试用例集合</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">判定表的类型</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">有限条目判定表</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">特点:所有条件都是二值条件C真/假)</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">扩展条目判定表</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">特点:条件可以有多个值</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">判定表的建立步骤</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">1、确定规则的条数</span></li><li style="text-align:left;"><span style="color:#000000;">2、列出所有的条件桩和动作桩</span></li><li style="text-align:left;"><span style="color:#000000;">3、填入条件的不同取值组合</span></li><li style="text-align:left;"><span style="color:#000000;">4、填入具体动作，得到初始判定表</span></li><li style="text-align:left;"><span style="color:#000000;">5、化简，合并一些具有相同动作的相似规则</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">约束：另外两个条件取当前值的前提下结果与第三个条件无关</span></li><li style="text-align:left;"><span style="color:#000000;">合并后的条件项用符号“—”表示，说明执行的动作与该条件无关，也称无关条件</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">适合使用判定表驱动法的条件</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">(1 )程序规格说明以判定表形式给出，或很容易转换成判定表。</span></li><li style="text-align:left;"><span style="color:#000000;">(2)条件的排列顺序不会也不影响执行哪些操作。</span></li><li style="text-align:left;"><span style="color:#000000;">(3)规则的排列顺序不会也不影响执行哪些操作。</span></li><li style="text-align:left;"><span style="color:#000000;">(4)每当某一规则的条件已经满足，并确定要执行的操作后，不必检验别的规则。</span></li><li style="text-align:left;"><span style="color:#000000;">(5)如果某一规则得到满足 要执行多个操作，这些操作的执行顺序无关紧要。</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">因果图法</span> 
    <ul><li style="text-align:left;"><span style="color:#000000;">用法</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">当被测对象的输入条件相互依赖、相互制约的时候，适合用因果图法进行测试</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">概念</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法</span></li><li style="text-align:left;"><span style="color:#000000;">因果图提供了一个把需求转化为判定表的系统化方法</span></li><li style="text-align:left;"><span style="color:#000000;">因果图法最后生成的就是判定表，它适合于检查程序输入条件的各种组合情况</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">因果图的关系符号</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">因果图的四种基本关系</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">恒等</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">恒等:若原因出现，则结果出现;若原因不出现，则结果也不出现。</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">父主题</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">非(~ )</span> 
            <ul><li style="text-align:left;"><span style="color:#000000;">非(~ ):若原因出现，则结果不出现;若原因不出现，则结果出现</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">或(V)</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">或(V):若几个原因中有一个出现，则结果出现;若几个原因都不出现，则结果不出现</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">与(N)</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">与(N):若几个原因都出现，结果才出现:若其中有一个原因不出现，</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">因果图的基本图形符号</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">因果图的约束符号</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">因果图的五种约束类型</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">E约束(互斥)</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">(1)E约束(互斥):表示不同时为1，即a、b、c中至多只有一个1:</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">I约束(包含)</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">(2)I约束(包含):表示至少有一个1，即a、B、c中不同时为0;</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">0约束(唯一-)</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">(3)0约束(唯一-):表示a b、c中有且仅有一一个1;</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">R约束(要求)</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">(4)R约束(要求):表示若a=1，则b必须为1。即不可能a=1日b=0</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">M约束( 屏蔽)</span> 
          <ul><li style="text-align:left;"><span style="color:#000000;">（5）输出的约束只有M约束( 屏蔽):若结果a是1.则结果b强制为0。</span></li></ul></li></ul></li><li style="text-align:left;"></ul></li><li style="text-align:left;"><span style="color:#000000;">设计测试用例步骤</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">1、找出输入输出并进行标识</span></li><li style="text-align:left;"><span style="color:#000000;">2、分析输入输出关系</span></li><li style="text-align:left;"><span style="color:#000000;">3、表明约束条件，画出因果图</span></li><li style="text-align:left;"><span style="color:#000000;">4、把因果图转换成判定表</span></li><li style="text-align:left;"><span style="color:#000000;">5、根据判定表设计测试用例</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">场景法</span> 
    <ul><li style="text-align:left;"><span style="color:#000000;">基本流和备选流 </span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">用例经过的每条路径都可以用基本流和备用流来表示</span></li><li style="text-align:left;"><span style="color:#000000;">基本流:经过用例的最简单的路径，可以用黑色的直线表示</span></li><li style="text-align:left;"><span style="color:#000000;">备选流:备选流1、2、3、4，程序执行可能经过也可能不经过的路径，一般对应异常的事件流程，用不同颜色的弧线表示</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">概念</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">场景法就是从一个流程开始，通过描述经过的路径来确定测试用例的过程，经过遍历所有的基本流和备用流来完成整个场景</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">确定用例场景</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">每个用例经过的可能路径，可以确定不同的用例场景</span></li><li style="text-align:left;"><span style="color:#000000;">从基本流开始，再将基本流和备选流结合起来</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">设计测试用例步骤</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">(1)根据软件规格说明，描述程序的基本流及各项备选流。</span></li><li style="text-align:left;"><span style="color:#000000;">(2)根据基本流和各项备选流生成不同的场景。</span></li><li style="text-align:left;"><span style="color:#000000;">(3)对每一个场景设计生成相应的测试用例。</span></li><li style="text-align:left;"><span style="color:#000000;">(4)对生成的所有测试用例重新复审，去掉多余的测试用例，测试用例确定后，对每一个测试用例确定测试数据值。</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">正交实验法</span> 
    <ul><li style="text-align:left;"><span style="color:#000000;">又称正交设计实验法或正交设计试验法</span></li><li style="text-align:left;"><span style="color:#000000;">应用背景</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">(1)有多个因素的取值变化会影响某个事件的结果，现需要通过实验来验证这种影响</span></li><li style="text-align:left;"><span style="color:#000000;">(2)影响因素个数比较多，并且每一个因素又有多种取值，实验量非常大</span></li><li style="text-align:left;"><span style="color:#000000;">( 3)不能对每一-组可能的数据都进行实验</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">Ln（t的c次方）类型</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">L</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">正交表的代号</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">n</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">需要实验的次数</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">c</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">列数（影响结果的因素的个数）</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">t</span> 
        <ul><li style="text-align:left;"><span style="color:#000000;">水平数（因素可能取值的个数）</span></li></ul></li></ul></li><li style="text-align:left;"><span style="color:#000000;">应用步骤</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">(1)明确有哪些因素(变量)</span></li><li style="text-align:left;"><span style="color:#000000;">(2)每个因素有哪几个水平(变量的取值)。</span></li><li style="text-align:left;"><span style="color:#000000;">(3)选择一个合适的正交表。</span></li><li style="text-align:left;"><span style="color:#000000;">(4 )把变量的值映射到表中。</span></li><li style="text-align:left;"><span style="color:#000000;">(5)把每一行的各因素水平的组合作为一个测试数据</span></li><li style="text-align:left;"><span style="color:#000000;">(6)可以再补充一些其他测试数据。</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">原则</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">(1)正交表的列数不能小于因子数</span></li><li style="text-align:left;"><span style="color:#000000;">(2)正交表的水平数不能小于因子的最大状态数。</span></li><li style="text-align:left;"><span style="color:#000000;">(3)正交表的行数取最小值。</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">因子</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">可能影响实验结果的条件</span></li></ul></li><li style="text-align:left;"><span style="color:#000000;">因子的状态</span> 
      <ul><li style="text-align:left;"><span style="color:#000000;">条件取值可能的个数</span></li></ul></li></ul></li></ul></li></ul> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="359" src="https://images2.imgbox.com/93/d9/gGLlOo6I_o.png" width="632"><br><span style="color:#000000;">基本流和备选流 </span></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="372" src="https://images2.imgbox.com/c9/27/XNGbJdZz_o.png" width="302"><br><span style="color:#000000;">因果图的基本图形符号</span></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="339" src="https://images2.imgbox.com/b1/94/EGY5WhWZ_o.png" width="490"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b1234c24d09db53d26734b98e08a3dd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图像平滑简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c76b0d69327212ea0ca39cae98919a48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">postMessage，addEventListener， 前端跨域请求之js代码解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>