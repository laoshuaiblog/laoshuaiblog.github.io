<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java高级编程——Java8的其它新特性 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/811faa0c3c06d369ebffcaca66a5d8e7/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Java高级编程——Java8的其它新特性">
  <meta property="og:description" content="Java高级编程——Java8的其它新特性 目录
Java高级编程——Java8的其它新特性
0.Java 8新特性简介
0.1.并行流与串行流 一、Lambda表达式
1.为什么使用 Lambda 表达式
2.两个例子
3.语法
4.类型推断
上代码
二、函数式(Functional)接口
1.什么是函数式(Functional)接口
2.如何理解函数式接口
3.函数式接口举例
4.自定义函数式接口
5. 作为参数传递 Lambda 表达式
6.Java 内置四大核心函数式接口
上代码
总结
三、方法引用与构造器引用
1.方法引用(Method References)
2.方法引用举例
上代码
3.构造器引用
4.数组引用
上代码
四、强大的Stream API
1.Stream API说明
2.为什么要使用Stream API
3.什么是 Stream
4.Stream 的操作三个步骤
创建 Stream方式（一）
1.通过集合
2.通过数组
3.通过Stream的of()
4.创建无限流
Stream 的中间操作（二）
1.选与切片
2.映射
3.排序
Stream 的终止操作（三）
1-匹配与查找
2-归约
3-收集
上代码
五、Optional类
1.概述
上代码
学习的思维方式：
1. &#34;大处着眼，小处着手&#34;
2. 逆向思维、反证法 List&amp;lt;String&amp;gt; list2; List&amp;lt;Object&amp;gt; list1 = list2;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-06-28T14:12:25+08:00">
    <meta property="article:modified_time" content="2023-06-28T14:12:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java高级编程——Java8的其它新特性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94Java8%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7" style="text-align:center;">Java高级编程——Java8的其它新特性</h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94Java8%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7-toc" style="margin-left:0px;"><a href="#Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94Java8%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7" rel="nofollow">Java高级编程——Java8的其它新特性</a></p> 
<p id="0.Java%208%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#0.Java%208%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B" rel="nofollow">0.Java 8新特性简介</a></p> 
<p id="0.1.%E5%B9%B6%E8%A1%8C%E6%B5%81%E4%B8%8E%E4%B8%B2%E8%A1%8C%E6%B5%81%C2%A0-toc" style="margin-left:40px;"><a href="#0.1.%E5%B9%B6%E8%A1%8C%E6%B5%81%E4%B8%8E%E4%B8%B2%E8%A1%8C%E6%B5%81%C2%A0" rel="nofollow">0.1.并行流与串行流 </a></p> 
<p id="%E4%B8%80%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">一、Lambda表达式</a></p> 
<p id="1.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px;"><a href="#1.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">1.为什么使用 Lambda 表达式</a></p> 
<p id="2.%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90-toc" style="margin-left:40px;"><a href="#2.%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90" rel="nofollow">2.两个例子</a></p> 
<p id="3.%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#3.%E8%AF%AD%E6%B3%95" rel="nofollow">3.语法</a></p> 
<p id="%C2%A04.%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-toc" style="margin-left:40px;"><a href="#%C2%A04.%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD" rel="nofollow"> 4.类型推断</a></p> 
<p id="%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow"> 上代码</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F(Functional)%E6%8E%A5%E5%8F%A3-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%28Functional%29%E6%8E%A5%E5%8F%A3" rel="nofollow">二、函数式(Functional)接口</a></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F(Functional)%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"> <a href="#1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%28Functional%29%E6%8E%A5%E5%8F%A3" rel="nofollow">1.什么是函数式(Functional)接口</a></p> 
<p id="%C2%A02.%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%C2%A02.%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3" rel="nofollow"> 2.如何理解函数式接口</a></p> 
<p id="%C2%A03.%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%BE%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%C2%A03.%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%BE%E4%BE%8B" rel="nofollow"> 3.函数式接口举例</a></p> 
<p id="%C2%A04.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%C2%A04.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3" rel="nofollow"> 4.自定义函数式接口</a></p> 
<p id="%C2%A05.%C2%A0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%C2%A05.%C2%A0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow"> 5. 作为参数传递 Lambda 表达式</a></p> 
<p id="%C2%A06.Java%20%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%C2%A06.Java%20%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3" rel="nofollow"> 6.Java 内置四大核心函数式接口</a></p> 
<p id="%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow"> 上代码</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8" rel="nofollow">三、方法引用与构造器引用</a></p> 
<p id="1.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8(Method%20References)-toc" style="margin-left:40px;"> <a href="#1.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%28Method%20References%29" rel="nofollow">1.方法引用(Method References)</a></p> 
<p id="%C2%A02.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%BE%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%C2%A02.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%BE%E4%BE%8B" rel="nofollow"> 2.方法引用举例</a></p> 
<p id="%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow">上代码</a></p> 
<p id="%C2%A03.%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A03.%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8" rel="nofollow"> 3.构造器引用</a></p> 
<p id="%C2%A04.%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A04.%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8" rel="nofollow"> 4.数组引用</a></p> 
<p id="%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow"> 上代码</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%BC%BA%E5%A4%A7%E7%9A%84Stream%20API-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%BC%BA%E5%A4%A7%E7%9A%84Stream%20API" rel="nofollow">四、强大的Stream API</a></p> 
<p id="1.Stream%20API%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"> <a href="#1.Stream%20API%E8%AF%B4%E6%98%8E" rel="nofollow">1.Stream API说明</a></p> 
<p id="%C2%A02.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Stream%20API-toc" style="margin-left:40px;"><a href="#%C2%A02.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Stream%20API" rel="nofollow"> 2.为什么要使用Stream API</a></p> 
<p id="%C2%A03.%E4%BB%80%E4%B9%88%E6%98%AF%20Stream-toc" style="margin-left:40px;"><a href="#%C2%A03.%E4%BB%80%E4%B9%88%E6%98%AF%20Stream" rel="nofollow"> 3.什么是 Stream</a></p> 
<p id="%C2%A04.Stream%20%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#%C2%A04.Stream%20%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4" rel="nofollow"> 4.Stream 的操作三个步骤</a></p> 
<p id="%C2%A0%E5%88%9B%E5%BB%BA%20Stream%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%88%9B%E5%BB%BA%20Stream%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89" rel="nofollow"> 创建 Stream方式（一）</a></p> 
<p id="1.%E9%80%9A%E8%BF%87%E9%9B%86%E5%90%88-toc" style="margin-left:120px;"><a href="#1.%E9%80%9A%E8%BF%87%E9%9B%86%E5%90%88" rel="nofollow">1.通过集合</a></p> 
<p id="2.%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84-toc" style="margin-left:120px;"><a href="#2.%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84" rel="nofollow">2.通过数组</a></p> 
<p id="3.%E9%80%9A%E8%BF%87Stream%E7%9A%84of()-toc" style="margin-left:120px;"><a href="#3.%E9%80%9A%E8%BF%87Stream%E7%9A%84of%28%29" rel="nofollow">3.通过Stream的of()</a></p> 
<p id="4.%E5%88%9B%E5%BB%BA%E6%97%A0%E9%99%90%E6%B5%81-toc" style="margin-left:120px;"><a href="#4.%E5%88%9B%E5%BB%BA%E6%97%A0%E9%99%90%E6%B5%81" rel="nofollow">4.创建无限流</a></p> 
<p id="Stream%20%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89-toc" style="margin-left:80px;"><a href="#Stream%20%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89" rel="nofollow">Stream 的中间操作（二）</a></p> 
<p id="%C2%A01.%E9%80%89%E4%B8%8E%E5%88%87%E7%89%87-toc" style="margin-left:120px;"><a href="#%C2%A01.%E9%80%89%E4%B8%8E%E5%88%87%E7%89%87" rel="nofollow">1.选与切片</a></p> 
<p id="2.%E6%98%A0%E5%B0%84-toc" style="margin-left:120px;"><a href="#2.%E6%98%A0%E5%B0%84" rel="nofollow">2.映射</a></p> 
<p id="3.%E6%8E%92%E5%BA%8F-toc" style="margin-left:120px;"><a href="#3.%E6%8E%92%E5%BA%8F" rel="nofollow">3.排序</a></p> 
<p id="Stream%20%E7%9A%84%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89-toc" style="margin-left:80px;"><a href="#Stream%20%E7%9A%84%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89" rel="nofollow">Stream 的终止操作（三）</a></p> 
<p id="1-%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE-toc" style="margin-left:120px;"><a href="#1-%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE" rel="nofollow">1-匹配与查找</a></p> 
<p id="2-%E5%BD%92%E7%BA%A6-toc" style="margin-left:120px;"><a href="#2-%E5%BD%92%E7%BA%A6" rel="nofollow">2-归约</a></p> 
<p id="3-%E6%94%B6%E9%9B%86-toc" style="margin-left:120px;"><a href="#3-%E6%94%B6%E9%9B%86" rel="nofollow">3-收集</a></p> 
<p id="%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow">上代码</a></p> 
<p id="%E4%BA%94%E3%80%81Optional%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81Optional%E7%B1%BB" rel="nofollow">五、Optional类</a></p> 
<p id="1.%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1.%E6%A6%82%E8%BF%B0" rel="nofollow">1.概述</a></p> 
<p id="%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81" rel="nofollow"> 上代码</a></p> 
<hr> 
<blockquote> 
 <p><strong>学习的思维方式：</strong><br> 1. "大处着眼，小处着手"</p> 
 <p>2. 逆向思维、反证法  List&lt;String&gt; list2; List&lt;Object&gt; list1 = list2;</p> 
 <p>3. 透过问题看本质</p> 
 <p><br><strong>两句话：</strong><br> 1. 小不忍则乱大谋</p> 
 <p>2. 识时务者为俊杰</p> 
</blockquote> 
<h2 id="0.Java%208%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B">0.Java 8新特性简介</h2> 
<p class="img-center"><img alt="" height="175" src="https://images2.imgbox.com/06/cf/Ww3t2NKw_o.png" width="704"></p> 
<p class="img-center"><img alt="" height="403" src="https://images2.imgbox.com/e6/20/ci9wFfc9_o.png" width="710"></p> 
<blockquote> 
 <p><strong>新特性的优点：</strong></p> 
 <p> 速度更快</p> 
 <p> 代码更少(增加了新的语法：Lambda 表达式)</p> 
 <p> 强大的 Stream API</p> 
 <p> 便于并行</p> 
 <p> 最大化减少空指针异常：Optional</p> 
 <p> Nashorn引擎，允许在JVM上运行JS应用 </p> 
</blockquote> 
<h3 id="0.1.%E5%B9%B6%E8%A1%8C%E6%B5%81%E4%B8%8E%E4%B8%B2%E8%A1%8C%E6%B5%81%C2%A0">0.1.并行流与串行流 </h3> 
<p class="img-center"><img alt="" height="191" src="https://images2.imgbox.com/33/cc/Nz9sRYsu_o.png" width="623"></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">一、Lambda表达式</h2> 
<h3 id="1.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.为什么使用 Lambda 表达式</h3> 
<blockquote> 
 <p>Lambda 是一个<span style="color:#fe2c24;"><strong>匿名函数</strong></span>，我们可以把 Lambda 表达式理解为是一段可以 <span style="color:#fe2c24;"><strong>传递的代码</strong></span>（将代码像数据一样进行传递）。使用它可以写出更简洁、更 灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p> 
</blockquote> 
<h3 id="2.%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90">2.两个例子</h3> 
<p class="img-center"><img alt="" height="309" src="https://images2.imgbox.com/6f/20/lgmOwXnM_o.png" width="544"></p> 
<pre><code class="language-java">package com.tyl.java1;

import org.junit.Test;

import java.util.Comparator;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java1
 * @Project：workidea
 * @Filename: LambdaTest
 * @create 2023-06-26 15:50
 *
 * Lambda.表达式的使用举例
 */
public class LambdaTest {

    @Test
    public void test2(){

        Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return Integer.compare(o1,o2);
            }
        };

        int compare1 = com1.compare(12, 21);
        System.out.println(compare1);

        System.out.println("************************");

        // Lambda表达式的写法
        Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);
        int compare2 = com2.compare(22, 11);
        System.out.println(compare2);


        System.out.println("************************");

        // 方法引用
        Comparator&lt;Integer&gt; com3 = Integer :: compare;
        int compare3 = com3.compare(22, 11);
        System.out.println(compare3);


    }

}
</code></pre> 
<h3 id="3.%E8%AF%AD%E6%B3%95">3.语法</h3> 
<p class="img-center"><img alt="" height="215" src="https://images2.imgbox.com/18/d5/bcCznTth_o.png" width="609"></p> 
<p class="img-center"><img alt="" height="295" src="https://images2.imgbox.com/d5/9b/ClNuvbSj_o.png" width="608"></p> 
<p class="img-center"><img alt="" height="296" src="https://images2.imgbox.com/79/33/jDBACKWl_o.png" width="602"></p> 
<h3 id="%C2%A04.%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"> 4.类型推断</h3> 
<p class="img-center"><img alt="" height="278" src="https://images2.imgbox.com/97/e0/dH09pcnG_o.png" width="651"></p> 
<h4 id="%C2%A0%E4%B8%8A%E4%BB%A3%E7%A0%81"> 上代码</h4> 
<pre><code class="language-java">package com.tyl.java1;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.function.Consumer;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java1
 * @Project：workidea
 * @Filename: LambdaTest1
 * @create 2023-06-26 16:11
 *
 *Lambda.表达式的使用
 * 1.举例：
 *          (o1,o2) -&gt; Integer.compare(o1,o2)
 * 2.格式：
         * -&gt;:Lambda.操作符或箭头操作符
         * -&gt;左边：Lambda形参列表（其实就是接口中的抽象方法的形参列表）
         * -&gt;右边：Lambda体（其实就是重写的抽象方法的方法体）
 *
 * 3.Lambda表达式的使用： (分为6种情况介绍)
 * 总结：
 * -&gt;左边：Lambda形参列表的参数类型可以省略（类型推断）；如果Lambda形参列表只有一个参数，其一对（）也可以省略。
 * -&gt;右边：Lambda体应该使用一对{}包裹；如果Lambda体只有一条执行语句(可能是return语句).省略这一对{}和return
 *
 * 4.Lambda表达式的本质：  作为函数式接口的实例
 *
 * 5.如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口.
 * 我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。
 *
 * 6.所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。
 */
public class LambdaTest1 {

    // 语法格式一：无参，无返回值
    @Test
    public void test1(){
        Runnable r1 = new Runnable(){

            @Override
            public void run() {
                System.out.println("我爱你！！！");
            }
        };
        r1.run();


        Runnable r2 = () -&gt; {
            System.out.println("你爱我");
        };
        r2.run();

    }

    // 语法格式二：Lambda 需要一个参数，但是没有返回值。
    @Test
    public void test2(){
        Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() {
            @Override
            public void accept(String s) {
                System.out.println(s);
            }
        };
        con.accept("谎言和誓言的区别？");

        System.out.println("***********************************");

        Consumer&lt;String&gt; con1 = (String s) -&gt; {
            System.out.println(s);
        };
        con1.accept("一个越打一个越爱");
    }

    // 语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”
    @Test
    public void test3(){
        Consumer&lt;String&gt; con1 = (String s) -&gt; {
            System.out.println(s);
        };
        con1.accept("一个越打一个越爱");


        System.out.println("***********************************");

        Consumer&lt;String&gt; con2 = (s) -&gt; {
            System.out.println(s);
        };
        con2.accept("一个越打一个越爱");

    }


    @Test
    public void test4(){

        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();  //类型推断

//        int[] arr = new int[]{1,2,3};
        int[] arr = {1,2,3};
    }


    // 语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略
    @Test
    public void test5(){
        Consumer&lt;String&gt; con3 = (s) -&gt; {
            System.out.println(s);
        };
        con3.accept("一个越打一个越爱");

        System.out.println("***********************************");

        Consumer&lt;String&gt; con1 = s -&gt; {
            System.out.println(s);
        };
        con1.accept("一个越打一个越爱");

    }


    // 语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值
    @Test
    public void test6(){
        Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                System.out.println(o1);
                System.out.println(o2);
                return o1.compareTo(o2);
            }
        };

        System.out.println(com1.compare(12, 21));

        System.out.println("***********************************");
        Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; {
            System.out.println(o1);
            System.out.println(o2);
            return o1.compareTo(o2);
        };

        System.out.println(com2.compare(12, 6));
    }

    // 语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略
    @Test
    public void test7(){
        Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; {
            return o1.compareTo(o2);
        };

        System.out.println(com2.compare(12, 6));

        System.out.println("***********************************");
        Comparator&lt;Integer&gt; com = (o1,o2) -&gt; o1.compareTo(o2);
        System.out.println(com.compare(12, 1));

    }

    @Test
    public void test8(){

        Consumer&lt;String&gt; con3 = (s) -&gt; {
            System.out.println(s);
        };
        con3.accept("一个越打一个越爱");

        System.out.println("***********************************");
        Consumer&lt;String&gt; con1 = s -&gt; System.out.println(s);
        con1.accept("12121321313");
    }

}
</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F(Functional)%E6%8E%A5%E5%8F%A3">二、函数式(Functional)接口</h2> 
<h3 id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F(Functional)%E6%8E%A5%E5%8F%A3">1.什么是函数式(Functional)接口</h3> 
<p class="img-center"><img alt="" height="306" src="https://images2.imgbox.com/fa/3c/PfvwCIyo_o.png" width="769"></p> 
<h3 id="%C2%A02.%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"> 2.如何理解函数式接口</h3> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/a8/e5/2AXsJbWP_o.png" width="756"></p> 
<h3 id="%C2%A03.%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%BE%E4%BE%8B"> 3.函数式接口举例</h3> 
<p class="img-center"><img alt="" height="363" src="https://images2.imgbox.com/4f/91/eeAsccri_o.png" width="793"></p> 
<h3 id="%C2%A04.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"> 4.自定义函数式接口</h3> 
<p class="img-center"><img alt="" height="326" src="https://images2.imgbox.com/dd/a8/q2sDxOq1_o.png" width="613"></p> 
<h3 id="%C2%A05.%C2%A0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F"> 5. 作为参数传递 Lambda 表达式</h3> 
<p class="img-center"><img alt="" height="296" src="https://images2.imgbox.com/32/26/8VE7FuaL_o.png" width="653"></p> 
<h3 id="%C2%A06.Java%20%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"> 6.Java 内置四大核心函数式接口</h3> 
<p class="img-center"><img alt="" height="354" src="https://images2.imgbox.com/2a/6b/v2W41APr_o.png" width="738"></p> 
<p class="img-center"><img alt="" height="407" src="https://images2.imgbox.com/8e/b1/wbH4w4kN_o.png" width="736"></p> 
<h4> 上代码</h4> 
<pre><code class="language-java">package com.tyl.java1;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java1
 * @Project：workidea
 * @Filename: LambdaTest2
 * @create 2023-06-26 17:30
 *
 * java内置的4大核心函数式接口
 * 消费型接口Consumer&lt;T&gt;    void accept(T t)
 * 供给型接口Supplier&lt;T&gt;    T get（）
 * 函数型接口Function&lt;T,R&gt;  R apply(Tt)
 * 断定型接口Predicate&lt;T&gt;   boolean test(T t)
 */
public class LambdaTest2 {

    @Test
    public void test1(){
        happyTime(500, new Consumer&lt;Double&gt;() {
            @Override
            public void accept(Double aDouble) {
                System.out.println("学习太累了，休息一下！！！" + aDouble);
            }
        });

        System.out.println("******************************");

        happyTime(410, money -&gt; System.out.println("学习太累了，休息一下下！！！" + money));
    }

    public void happyTime(double money, Consumer&lt;Double&gt; con){
        con.accept(money);
    }


    @Test
    public void test2(){
        List&lt;String&gt; list = Arrays.asList("天津","吴京","南京","北京","东京");
        List&lt;String&gt; filterStr = filterString(list, new Predicate&lt;String&gt;() {
            @Override
            public boolean test(String s) {
                return s.contains("京");
            }
        });

        System.out.println(filterStr);

        System.out.println("******************Lambda表达式*************");
        List&lt;String&gt; filterStr1 = filterString(list,s -&gt; s.contains("京"));
        System.out.println(filterStr1);

    }

    // 根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定
    public List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pred){

        ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;();

        for(String s: list){
            if(pred.test(s)){
                filterList.add(s);
            }
        }

        return filterList;
    }
}
</code></pre> 
<h3 id="%E6%80%BB%E7%BB%93">总结</h3> 
<p class="img-center"><img alt="" height="235" src="https://images2.imgbox.com/ee/c1/zStDNKAw_o.png" width="991"></p> 
<h2 id="%E4%B8%89%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">三、方法引用与构造器引用</h2> 
<h3 id="1.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8(Method%20References)">1.方法引用(Method References)</h3> 
<p class="img-center"><img alt="" height="361" src="https://images2.imgbox.com/cc/f0/Kg19H5WZ_o.png" width="772"></p> 
<h3 id="%C2%A02.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%BE%E4%BE%8B"> 2.方法引用举例</h3> 
<p class="img-center"><img alt="" height="416" src="https://images2.imgbox.com/e3/a2/2Dnx3iwA_o.png" width="702"></p> 
<p class="img-center"><img alt="" height="313" src="https://images2.imgbox.com/e3/aa/WiTDFXqQ_o.png" width="695"></p> 
<h4 id="%E4%B8%8A%E4%BB%A3%E7%A0%81">上代码</h4> 
<pre><code class="language-java">package com.tyl.java2;

import org.junit.Test;

import java.io.PrintStream;
import java.util.Comparator;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * 方法引用的使用
 *
 * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！
 *
 * 2.方法引用，本质上就是Lambda.表达式，而Lambda.表达式作为函数式接口的实例。所以
 * 方法引用，也是函数式接口的实例。
 *
 * 3.使用格式：类（或对象）：方法名
 *
 * 4.具体分为如下的三种情况：
 * 情况1  对象 :: 非静态方法
 * 情况2  类 :: 静态方法
 * 情况3  类 :: 非静态方法
 *
 * 5.方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的
 *   形参列表和返回值类型相同！(适合第一种和第二种情况）
 *
 *
 * Created by shkstart.
 */
public class MethodRefTest {

	// 情况一：对象 :: 实例方法
	// Consumer中的void accept(T t)
	// PrintStream中的void println(T t)
	@Test
	public void test1() {
		Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);
		con1.accept("西安");

		System.out.println("********************************");

		PrintStream ps = System.out;
		Consumer&lt;String&gt; con2 = ps::println;
		con2.accept("xian");

	}

	// Supplier中的T get()
	// Employee中的String getName()
	@Test
	public void test2() {
		Employee tyl = new Employee(2001, "tyl", 23, 55555);
		Supplier&lt;String&gt; sup1 = () -&gt; tyl.getName();
		System.out.println(sup1.get());

		System.out.println("********************************");

		Supplier&lt;String&gt; sup2 = tyl ::getName;
		System.out.println(sup2.get());
	}

	// 情况二：类 :: 静态方法
	// Comparator中的int compare(T t1,T t2)
	// Integer中的int compare(T t1,T t2)
	@Test
	public void test3() {
		Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);
		int compare1 = com1.compare(88, 55);
		if(compare1 == -1){
			System.out.println("前面的数小，后面的数大");
		}else {
			System.out.println("前面的数大，后面的数小");
		}

		System.out.println("********************************");
		Comparator&lt;Integer&gt; com2 = Integer::compare;
		System.out.println(com2.compare(12, 33));


	}

	// Function中的R apply(T t)
	// Math中的Long round(Double d)
	@Test
	public void test4() {
		Function&lt;Double,Long&gt; func = new Function&lt;Double, Long&gt;() {
			@Override
			public Long apply(Double d) {
				return Math.round(d);
			}
		};

		System.out.println("********************************");
		Function&lt;Double,Long&gt; func2 = d -&gt; Math.round(d);
		System.out.println(func2.apply(12.3));

		System.out.println("********************************");
		Function&lt;Double,Long&gt; func3 = Math::round;
		System.out.println(func3.apply(15.3));

	}

	// 情况三：类 :: 实例方法 （有难度）
	// Comparator中的int comapre(T t1,T t2)
	// String中的int t1.compareTo(t2)
	@Test
	public void test5() {
		Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);
		System.out.println(com1.compare("abc", "abd"));

		System.out.println("********************************");
		Comparator&lt;String&gt; com2 = String::compareTo;
		System.out.println(com2.compare("acc", "aaa"));

	}

	// BiPredicate中的boolean test(T t1, T t2);
	// String中的boolean t1.equals(t2)
	@Test
	public void test6() {
		BiPredicate&lt;String,String&gt; pre1 = (t1,t2) -&gt; t1.equals(t2);
		System.out.println(pre1.test("aaa", "aaa"));

		System.out.println("********************************");
		BiPredicate&lt;String,String&gt; pre2 = String::equals;
		System.out.println(pre2.test("aaa", "ccc"));
	}

	// Function中的R apply(T t)
	// Employee中的String getName();
	@Test
	public void test7() {
		Employee tyl = new Employee(2001, "tyl", 23, 55555);

		Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();
		System.out.println(func1.apply(tyl));

		System.out.println("********************************");

		Function&lt;Employee,String&gt; func2 = Employee::getName;
		System.out.println(func2.apply(tyl));

	}

}
</code></pre> 
<h3 id="%C2%A03.%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"> 3.构造器引用</h3> 
<p class="img-center"><img alt="" height="328" src="https://images2.imgbox.com/b1/21/Bc5FrmjX_o.png" width="769"></p> 
<h3 id="%C2%A04.%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8"> 4.数组引用</h3> 
<p class="img-center"><img alt="" height="267" src="https://images2.imgbox.com/99/8e/gOphDOTl_o.png" width="603"></p> 
<h4> 上代码</h4> 
<pre><code class="language-java">package com.tyl.java2;

import org.junit.Test;

import java.util.Arrays;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * 一、构造器引用
 *     和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。
 *     抽象方法的返回值类型即为构造器所属的类的类型
 *
 * 二、数组引用
 *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。
 *
 *
 * Created by shkstart
 */
public class ConstructorRefTest {
    //构造器引用
    // Supplier中的T get()
    // EmpLoyee的空参构造器：EmpLoyee（）
    @Test
    public void test1(){
        Supplier&lt;Employee&gt; sup = new Supplier&lt;Employee&gt;() {
            @Override
            public Employee get() {
                return new Employee();
            }
        };

        System.out.println("********************************");
        Supplier&lt;Employee&gt; sup1 = () -&gt; new Employee();
        System.out.println(sup1.get());

        System.out.println("********************************");
        Supplier&lt;Employee&gt; sup2 = Employee::new;
        System.out.println(sup2.get());

    }

    // Function中的R apply(T t)
    @Test
    public void test2(){
        Function&lt;Integer,Employee&gt; func1 = id -&gt; new Employee(id);
        Employee employee = func1.apply(1001);
        System.out.println(employee);

        System.out.println("********************************");
        Function&lt;Integer,Employee&gt; func2 = Employee::new;
        Employee employee1 = func2.apply(1002);
        System.out.println(employee1);
    }

    // BiFunction中的R apply(T t,U u)
    @Test
    public void test3(){
        BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; new Employee(id,name);
        System.out.println(func1.apply(1001, "tyl"));

        System.out.println("********************************");
        BiFunction&lt;Integer,String,Employee&gt; func2 = Employee::new;
        System.out.println(func2.apply(1002, "tyl"));

    }

    //数组引用
    //Function中的R apply(T t)
    @Test
    public void test4(){
        Function&lt;Integer,String[]&gt; func1 = Length -&gt; new String[Length];
        String[] arr1 = func1.apply(5);
        System.out.println(Arrays.toString(arr1));

        System.out.println("********************************");
        Function&lt;Integer,String[]&gt; func2 = String[]::new;
        String[] arr2 = func2.apply(10);
        System.out.println(Arrays.toString(arr2));

    }
}
</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E5%BC%BA%E5%A4%A7%E7%9A%84Stream%20API">四、强大的Stream API</h2> 
<h3 id="1.Stream%20API%E8%AF%B4%E6%98%8E">1.Stream API说明</h3> 
<p class="img-center"><img alt="" height="359" src="https://images2.imgbox.com/97/7e/lmqzKfHw_o.png" width="822"></p> 
<h3 id="%C2%A02.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Stream%20API"> 2.为什么要使用Stream API</h3> 
<p class="img-center"><img alt="" height="272" src="https://images2.imgbox.com/90/e1/o1AitUcQ_o.png" width="810"></p> 
<h3 id="%C2%A03.%E4%BB%80%E4%B9%88%E6%98%AF%20Stream"> 3.什么是 Stream</h3> 
<p class="img-center"><img alt="" height="391" src="https://images2.imgbox.com/1c/56/7NSMDGoZ_o.png" width="843"></p> 
<h3 id="%C2%A04.Stream%20%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4"> 4.Stream 的操作三个步骤</h3> 
<p class="img-center"><img alt="" height="419" src="https://images2.imgbox.com/7b/48/YZ0wrVMq_o.png" width="839"></p> 
<h4 id="%C2%A0%E5%88%9B%E5%BB%BA%20Stream%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89"> 创建 Stream方式（一）</h4> 
<h5 id="1.%E9%80%9A%E8%BF%87%E9%9B%86%E5%90%88">1.通过集合</h5> 
<p class="img-center"><img alt="" height="201" src="https://images2.imgbox.com/6b/3b/ZAYv3IRH_o.png" width="890"></p> 
<p></p> 
<h5 id="2.%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84">2.通过数组</h5> 
<p class="img-center"><img alt="" height="354" src="https://images2.imgbox.com/02/40/i2Noqj56_o.png" width="866"></p> 
<p></p> 
<h5 id="3.%E9%80%9A%E8%BF%87Stream%E7%9A%84of()">3.通过Stream的of()</h5> 
<p class="img-center"><img alt="" height="208" src="https://images2.imgbox.com/15/7e/NHv0UgLD_o.png" width="909"></p> 
<p></p> 
<h5 id="4.%E5%88%9B%E5%BB%BA%E6%97%A0%E9%99%90%E6%B5%81">4.创建无限流</h5> 
<p class="img-center"><img alt="" height="281" src="https://images2.imgbox.com/d3/36/s0RhD8dP_o.png" width="884"></p> 
<h4 id="Stream%20%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89">Stream 的中间操作（二）</h4> 
<p class="img-center"><img alt="" height="128" src="https://images2.imgbox.com/0b/f7/Xhht9jAA_o.png" width="913"></p> 
<h5 id="%C2%A01.%E9%80%89%E4%B8%8E%E5%88%87%E7%89%87"> 1.选与切片</h5> 
<p class="img-center"><img alt="" height="271" src="https://images2.imgbox.com/82/0c/3XAWXjGx_o.png" width="916"></p> 
<h5 id="2.%E6%98%A0%E5%B0%84">2.映射</h5> 
<p class="img-center"><img alt="" height="405" src="https://images2.imgbox.com/86/63/rztkpUj7_o.png" width="903"></p> 
<h5 id="3.%E6%8E%92%E5%BA%8F">3.排序</h5> 
<p class="img-center"><img alt="" height="286" src="https://images2.imgbox.com/4e/e7/hXroLRcL_o.png" width="914"></p> 
<h4 id="Stream%20%E7%9A%84%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89">Stream 的终止操作（三）</h4> 
<p class="img-center"><img alt="" height="119" src="https://images2.imgbox.com/73/b1/NuadRWcM_o.png" width="883"></p> 
<h5 id="1-%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE">1-匹配与查找</h5> 
<p class="img-center"><img alt="" height="285" src="https://images2.imgbox.com/e7/3c/HaXAicex_o.png" width="875"></p> 
<p class="img-center"><img alt="" height="260" src="https://images2.imgbox.com/4f/6c/Ax7ZjzyY_o.png" width="874"></p> 
<h5 id="2-%E5%BD%92%E7%BA%A6">2-归约</h5> 
<p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/26/10/8IcOTJId_o.png" width="891"></p> 
<p></p> 
<h5 id="3-%E6%94%B6%E9%9B%86">3-收集</h5> 
<p class="img-center"><img alt="" height="313" src="https://images2.imgbox.com/56/8c/rgLHpBtp_o.png" width="875"></p> 
<blockquote> 
 <p><strong>Collector需要使用<span style="color:#fe2c24;">Collectors（如下）</span>提供实例。</strong></p> 
</blockquote> 
<p class="img-center"><img alt="" height="399" src="https://images2.imgbox.com/34/15/pcLnxUjO_o.png" width="762"></p> 
<p class="img-center"><img alt="" height="422" src="https://images2.imgbox.com/54/39/ivkjq65M_o.png" width="762"></p> 
<h4>上代码</h4> 
<pre><code class="language-java">package com.tyl.java3;

import com.tyl.java2.Employee;
import com.tyl.java2.EmployeeData;
import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java3
 * @Project：workidea
 * @Filename: StreamAPITest
 * @create 2023-06-27 15:11
 *
 * 1.Stream关注的是对数据的运算，与CPU打交道
 * 集合关注的是数据的存储，与内存打交道
 *
 * 2.①Stream 自己不会存储元素。
 *  ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。
 *  ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。
 *
 * 3.Stream执行流程
 * ① Stream的实例化
 * ② 一系列的中间操作(过滤、映射、··)
 * ③ 终止操作
 *
 * 4.说明：
 * 4.1一个中间操作链，对数据源的数据进行处理
 * 4.2一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用
 */
public class StreamAPITest {
    // 创建 Stream方式一：通过集合
    @Test
    public void test1(){
        List&lt;Employee&gt; employees = EmployeeData.getEmployees();

//         default Stream&lt;E&gt; stream() : 返回一个顺序流
        Stream&lt;Employee&gt; stream = employees.stream();

//         default Stream&lt;E&gt; parallelStream() : 返回一个并行流
        Stream&lt;Employee&gt; parallelStream = employees.parallelStream();
    }


//    创建 Stream方式二：通过数组
    @Test
    public void test2(){
        int[] arr = {1, 2, 3, 4, 5, 6};
        // /用Arrays类static&lt;T&gt; Stream&lt;T&gt; stream(T[] array):返回一个流
        IntStream stream = Arrays.stream(arr);

        Employee e1 = new Employee(1001, "tyl");
        Employee e2 = new Employee(1002, "wc");
        Employee[] arr1 = new Employee[]{e1, e2};
        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);

    }

    // 创建 Stream方式三：通过Stream的of()
    @Test
    public void test3(){
        Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);

    }

    // 创建 Stream方式四：创建无限流
    @Test
    public void test4(){
//         迭代
//        public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)
        Stream.iterate(0,t -&gt; t+2).limit(10).forEach(System.out::println);

//         生成
//        public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)
        Stream.generate(Math::random).limit(10).forEach(System.out::println);
    }


}
</code></pre> 
<pre><code class="language-java">package com.tyl.java3;

import com.tyl.java2.Employee;
import com.tyl.java2.EmployeeData;
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java3
 * @Project：workidea
 * @Filename: StreamAPITest1
 * @create 2023-06-27 16:42
 *
 * 测试Stream的中间操作
 */
public class StreamAPITest1 {

    // 1-筛选与切片
    @Test
    public void test1(){
        List&lt;Employee&gt; list = EmployeeData.getEmployees();
//        filter(Predicate p)一接收Lambda,从流中排除某些元素。
        Stream&lt;Employee&gt; stream = list.stream();
        // 练习：查询员工表中薪资大于79阳阳的员工信息
        stream.filter(e -&gt; e.getSalary() &gt; 7000).forEach(System.out::println);

        System.out.println("************************");

//        limit(n)一截断流，使其元素不超过给定数量.
        list.stream().limit(4).forEach(System.out::println);

        System.out.println("************************");
//        skip(n)一跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空的
        list.stream().skip(4).forEach(System.out::println);

        System.out.println("************************");
//        distinct（）一筛选，通过流所生成元素的hashCode（）和equals（）去除重复元素
        list.add(new Employee(1010, "刘强东",40,8000));
        list.add(new Employee(1010, "刘强东",40,8000));
        list.add(new Employee(1010, "刘强东",40,8000));
        list.add(new Employee(1010, "刘强东",40,8000));

//        System.out.println(list);
        list.stream().distinct().forEach(System.out::println);
    }

    // 2-映射
    @Test
    public void test2(){
        // map(Function f)--接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。
        List&lt;String&gt; list = Arrays.asList("aaa", "bbb", "ccc", "ddd");
        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);

        // 练习：获取员工姓名长度大于3的员工的姓名。
        List&lt;Employee&gt; employees = EmployeeData.getEmployees();
        Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);
        namesStream.filter(name -&gt; name.length() &gt; 3).forEach(System.out::println);
        System.out.println();
        // 练习2
        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream);
        streamStream.forEach(s -&gt;{
            s.forEach(System.out::println);
        });

        System.out.println();
        // fLatMap(Function f)--接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流
        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);
        characterStream.forEach(System.out::println);

    }


    public static Stream&lt;Character&gt; fromStringToStream(String str){
        ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();
        for(Character c : str.toCharArray()){
            list.add(c);
        }
        return list.stream();

    }

    // 3-排序
    @Test
    public void test3(){
        // sorted() 产生一个新流，其中按自然顺序排序
        List&lt;Integer&gt; list = Arrays.asList(12, 545, 545, 54564, 56461, 11111);
        list.stream().sorted().forEach(System.out::println);

        // 抛异常，原因：EmpLoyee没有实现ComparabLe接口
//        List&lt;Employee&gt; employees = EmployeeData.getEmployees();
//        employees.stream().sorted().forEach(System.out::println);


        //sorted(Comparator com) 产生一个新流，其中按比较器顺序排序
        List&lt;Employee&gt; employees = EmployeeData.getEmployees();
        employees.stream().sorted((e1,e2) -&gt; {
            int agevAalue = Integer.compare(e1.getAge(), e2.getAge());
            if(agevAalue != 0){
                return agevAalue;
            }else {
                return Double.compare(e1.getSalary(),e2.getSalary());
            }
        }).forEach(System.out::println);

    }

}
</code></pre> 
<pre><code class="language-java">package com.tyl.java3;

import com.tyl.java2.Employee;
import com.tyl.java2.EmployeeData;
import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java3
 * @Project：workidea
 * @Filename: StreamAPITest2
 * @create 2023-06-27 18:03
 * &lt;p&gt;
 * 测stream的终止操作
 */
public class StreamAPITest2 {

    // 1-匹配与查找
    @Test
    public void test1() {
        List&lt;Employee&gt; employees = EmployeeData.getEmployees();
        //    allMatch(Predicate p) 检查是否匹配所有元素
        //  练习：是否所有的员工的年龄都大于18
        boolean allMatch = employees.stream().allMatch(e -&gt; e.getAge() &gt; 18);
        System.out.println(allMatch);

//    anyMatch(Predicate p) 检查是否至少匹配一个元素
//        练习：是否存在员工的工资大于19000
        boolean anyMatch = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; 19000);
        System.out.println(anyMatch);

//    noneMatch(Predicate p) 检查是否没有匹配所有元素
        // 练习：是否存在员工姓“雷"
        boolean noneMatch = employees.stream().noneMatch(e -&gt; e.getName().startsWith("雷"));
        System.out.println(noneMatch);

//    findFirst() 返回第一个元素
        Optional&lt;Employee&gt; optionalEmployee = employees.stream().findFirst();
        System.out.println(optionalEmployee);
//    findAny() 返回当前流中的任意元素
        Optional&lt;Employee&gt; optionalEmployee1 = employees.stream().findAny();
        System.out.println(optionalEmployee1);
        Optional&lt;Employee&gt; optionalEmployee2 = employees.parallelStream().findAny();
        System.out.println(optionalEmployee2);

    }

    @Test
    public void test2() {
        List&lt;Employee&gt; employees = EmployeeData.getEmployees();
//        count() 返回流中元素总数
        long count = employees.stream().filter(e -&gt; e.getSalary() &gt; 5000).count();
        System.out.println(count);

//        max(Comparator c) 返回流中最大值
         // 练习：返回最高的工资：
        Stream&lt;Double&gt; doubleStream = employees.stream().map(e -&gt; e.getSalary());
        Optional&lt;Double&gt; max = doubleStream.max(Double::compare);
        System.out.println(max);

//        min(Comparator c) 返回流中最小值
        // 练习：返回最低工资的员工
        Optional&lt;Employee&gt; min = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));
        System.out.println(min);
        System.out.println();
//        forEach(Consumer c)   内部迭代
        employees.stream().forEach(System.out::println);

        // 使用集合的遍历操作
        employees.forEach(System.out::println);

    }

    // 2-归约
    @Test
    public void test3() {
//        reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T
//        练习1：计算1-10的自然数的和
        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Integer sum = list.stream().reduce(0, Integer::sum);
        System.out.println(sum);

//        reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;
        // 练习2：计算公司所有员工工资的总和
        List&lt;Employee&gt; employees = EmployeeData.getEmployees();
        Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);
//        Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);
        Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);
        System.out.println(sumMoney);

    }

    // 3-收集
    @Test
    public void test4() {
        // collect(Collector c)-将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法
        // 练习1：查拔工资大于6880的员工，结果返回为一个List和set
        List&lt;Employee&gt; employees = EmployeeData.getEmployees();
        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; 6000).collect(Collectors.toList());
        employeeList.forEach(System.out::println);

        System.out.println();
        Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; 6000).collect(Collectors.toSet());
        employeeSet.forEach(System.out::println);

    }

}
</code></pre> 
<h2 id="%E4%BA%94%E3%80%81Optional%E7%B1%BB">五、Optional类</h2> 
<h3 id="1.%E6%A6%82%E8%BF%B0">1.概述</h3> 
<p class="img-center"><img alt="" height="366" src="https://images2.imgbox.com/9c/62/FhRdKCDw_o.png" width="863"></p> 
<p class="img-center"><img alt="" height="434" src="https://images2.imgbox.com/6b/89/igBYaYxF_o.png" width="845"></p> 
<p class="img-center"><img alt="" height="424" src="https://images2.imgbox.com/52/e2/aFoCvodw_o.png" width="829"></p> 
<h4> 上代码</h4> 
<pre><code class="language-java">package com.tyl.java4;

import org.junit.Test;

import java.util.Optional;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java4
 * @Project：workidea
 * @Filename: OptionalTest
 * @create 2023-06-27 21:27
 *
 * Optional类：为了在程序中避免出现空指针异常而创建的。
 *
 * 常用的方法：ofNullable(T t)
 *            orELse(T t)
 */
public class OptionalTest {

    /*
     创建Optional类对象的方法：
         Optional.of(T t) : 创建一个 Optional 实例，t必须非空；
         Optional.empty() : 创建一个空的 Optional 实例
         Optional.ofNullable(T t)：t可以为null
     */
    @Test
    public void test1(){

        Gril gril = new Gril();
//        gril = null;
        // of(T t):保证t是非空的
        Optional&lt;Gril&gt; optionalGril = Optional.of(gril);
    }

    @Test
    public void test2(){

        Gril gril = new Gril();
        gril = null;
        // ofNuLLable(T t):t可以为nuLL
        Optional&lt;Gril&gt; optionalGril = Optional.ofNullable(gril);
        System.out.println(optionalGril);

        //orELse(T t1):如果单前的optional内部封装的t是非空的，则返回内部的t,
        //如果内部的t是空的，则返回orELse（）方法中的参数t1.
        Gril gril1 = optionalGril.orElse(new Gril("wc"));
        System.out.println(gril1);

    }


    //使用optional.类的getGirLName（）:
    public String getGrilName2(Boy boy){
        Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);
       // 此时的boy1一定非空
        Boy boy1 = boyOptional.orElse(new Boy(new Gril("tyl")));

        Gril gril = boy1.getGril();
        // girL1一定非空
        Optional&lt;Gril&gt; grilOptional = Optional.ofNullable(gril);
        Gril gril1 = grilOptional.orElse(new Gril("wccc"));

        return gril1.getName();
    }

    @Test
    public void test3(){
        Boy boy = null;
        boy = new Boy();
        boy = new Boy(new Gril("chuanglaoshi"));
        String grilName = getGrilName2(boy);
        System.out.println(grilName);

    }

}
</code></pre> 
<pre><code class="language-java">package com.tyl.java;

import org.junit.Test;

import java.util.Optional;

/**
 * @author tyl 邮箱：tyl202061@gmail.com
 * @Package：com.tyl.java
 * @Project：workidea
 * @Filename: OptionalTest
 * @create 2023-06-28 13:52
 */
public class OptionalTest {
    @Test
    public void test1() {
        // empty（）:创建的optional对象内部value = null
        Optional&lt;Object&gt; op1 = Optional.empty();
        if (!op1.isPresent()) { // Optional封装的数据是否包含数据
            System.out.println("数据为空");
        }
        System.out.println(op1);
        System.out.println(op1.isPresent());

        // 如果Optional.封装的数据value为空，则get（）报错。否则，value.不为空时，返回value
//        System.out.println(op1.get());

    }

    @Test
    public void test2() {
        String str = "wc是个小仙女";
//        str = null;
        // of(T t):封装数据t生成optional对象。要求t非空，否则报错
        Optional&lt;String&gt; op1 = Optional.of(str);

        // get（）通常与of（）方法搭配使用。用于获取内部的封装的数据value
        System.out.println(op1.get());
    }

    @Test
    public void test3() {
        String str = "beijing";
        str = null;

        // ofNulLable(T t)：封装数据t赋给Optional内部的value。不要求t非空
        Optional&lt;String&gt; str1 = Optional.ofNullable(str);

        // orELse(Tt1):如果optional内部value.非空，则返回此value值。如果value为空，则返回t1.
        System.out.println(str1.orElse("sahnghai"));
    }

}
</code></pre> 
<blockquote> 
 <p><strong>基础接近尾声，继续加油！！！</strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3eacbe7507ccc6c36f126f32a0e5c89c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">这一刻，我感觉一定要给.....（补充）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/998c8f8196c01c0f43bff5962014940e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tomcat及项目部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>