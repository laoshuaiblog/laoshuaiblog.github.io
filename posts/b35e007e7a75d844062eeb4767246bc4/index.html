<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言-----qsort()函数 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/b35e007e7a75d844062eeb4767246bc4/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="C语言-----qsort()函数">
  <meta property="og:description" content="前面向大家介绍了冒泡排序，冒泡排序的核心思想是让数组中相邻的元素进行比较，这是一种常见的算法。但是冒泡排序有一个缺陷，就是冒泡排序只能对整型类型的数组进行操作。所以当我们要对其他类型进行排序时。例如：字符串类型的数组、结构体类型的数组。则冒泡排序此时就不起作用了，那我们要如何操作呢？
C语言为例帮我们解决这个问题，就创建了一个排任意数据类型的函数------qsort()函数。
1.qsort()函数 qsort()函数是C语言中的一个库函数，其包含在 &amp;lt;stdlib.h&amp;gt; 这个头文件中。它是C语言中的一个高级函数，可以帮助我们对任意类型的数组进行排序。
qsot()函数采用了自动快速排序的方式，当条件符合时，就会自动对所需要进行排序的数据进行排序。
那如何使用qsort()函数呢？
首先，我们要知道qsort()函数中有4个参数，形式如下
void qsort(void* base,size_t num,size_t size,int(*compare)(const void*p1,const void*p2)) 我来为大家解释下这些参数的意义
1. void* base 是一个void* 类型的指针，其指向的是需要进行排序的数组中的首个元素。
2. size_t num 是指向数组的元素个数，也就是数组的大小。
3. size_t size 是指向数组中的元素的大小。
4. int(*compare)(const void*,const void*) 是一个指向两个需要比较元素的数组。
这个比较函数是有返回值,如下表
返回值 *p1-*p2 1 *p1-*p2&amp;gt;0 -1 *p1-*p2&amp;lt;0 0 *p1*p2==0 注意： 这里的*p1 ,*p2做差的位置不是固定的，我们要根据我们的需求来决定是*p1-*p2还是
*p2 - *p1。
2.qsort()的实际使用 2.1 qsort()实现对整型数组的排序 int main() { int arr[5] = { 23,45,67,24,78 }; int sz = sizeof(arr) / sizeof(arr[0]); qsort(arr, sz, sizeof(arr[0]), com); for (int i = 0; i &amp;lt; sz; i&#43;&#43;) { printf(&#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-23T13:56:20+08:00">
    <meta property="article:modified_time" content="2024-03-23T13:56:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言-----qsort()函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前面向大家介绍了冒泡排序，冒泡排序的核心思想是让数组中相邻的元素进行比较，这是一种常见的算法。但是冒泡排序有一个缺陷，就是<strong><span style="color:#fe2c24;">冒泡排序只能对整型类型的数组进行操作。</span></strong><span style="color:#0d0016;">所以当我们要对其他类型进行排序时。例如：字符串类型的数组、结构体类型的数组。则冒泡排序此时就不起作用了，那我们要如何操作呢？</span></p> 
<p>C语言为例帮我们解决这个问题，就创建了一个排任意数据类型的函数------qsort()函数。</p> 
<h2>1.qsort()函数</h2> 
<p>qsort()函数是C语言中的一个库函数，其包含在 <strong>&lt;stdlib.h&gt; </strong>这个头文件中。它是C语言中的一个高级函数，可以帮助我们对任意类型的数组进行排序。</p> 
<p>qsot()函数采用了自动快速排序的方式，当条件符合时，就会自动对所需要进行排序的数据进行排序。</p> 
<p>那如何使用qsort()函数呢？</p> 
<p>首先，我们要知道qsort()函数中有4个参数，形式如下</p> 
<pre><code class="language-cs">void qsort(void* base,size_t num,size_t size,int(*compare)(const void*p1,const void*p2))</code></pre> 
<p>我来为大家解释下这些参数的意义</p> 
<p><span style="color:#fe2c24;"><strong>1. void* base 是一个void* 类型的指针，其指向的是需要进行排序的数组中的首个元素。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>2. size_t num 是指向数组的元素个数，也就是数组的大小。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>3. size_t size 是指向数组中的元素的大小。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>4. int(*compare)(const void*,const void*) 是一个指向两个需要比较元素的数组。</strong></span></p> 
<p><span style="color:#0d0016;">这个比较函数是有返回值,如下表</span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>                      返回值         </td><td>                      *p1-*p2                  </td></tr><tr><td>                          1</td><td>                     *p1-*p2&gt;0</td></tr><tr><td>                           -1</td><td>                      *p1-*p2&lt;0</td></tr><tr><td>                           0</td><td>                       *p1*p2==0</td></tr></tbody></table> 
<p>注意： 这里的*p1 ,*p2做差的位置不是固定的，我们要根据我们的需求来决定是*p1-*p2还是</p> 
<p>*p2 - *p1。</p> 
<h2>2.qsort()的实际使用</h2> 
<h3>2.1 qsort()实现对整型数组的排序</h3> 
<pre><code class="language-cs">int main()
{
	int arr[5] = { 23,45,67,24,78 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	qsort(arr, sz, sizeof(arr[0]), com);
	for (int i = 0; i &lt; sz; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}</code></pre> 
<p>我们先应用qsort()这个函数，接下来就是重点了。</p> 
<p>重点就是如何编写com这个比较函数。</p> 
<p>首先我们知道com这个函数的返回值是int类型的。com的两个形参为 const void*。</p> 
<p>根据此写出以下代码</p> 
<p>我们首先可能会这样写</p> 
<pre><code class="language-cs">int com(const void* p1, const void* p2)
{
	if (*p1 - *p2 &gt; 0)
	{
		return 1;
	}
	else if (*p1 - *p2 &lt; 0)
	{
		return -1;
	}
	else
	{
		return 0;
	}
}</code></pre> 
<p>但这样是会报错的，因为p1和p1的类型是void*，无法直接进行解引用的。所以，首先，我们要对p1和p2进行强制类型转换，将其转换为int*型的。</p> 
<p>此时我们可能会很疑惑，为什么偏偏是转换为int*的呢？而不是转换为其它类型的呢？</p> 
<p> 这时我们就要清楚我们是qsort()的使用者，我们是以上帝视角来使用qsort()函数的。所以我们就很清楚的知道我们就很清楚的知道我们要排序的类型是int类型的，所以我们就将其转换为int*的，在对其进行解引用。</p> 
<p>正确代码如下</p> 
<pre><code class="language-cs">int com(const void* p1, const void* p2)
{
	if (*(int*)p1 - *(int*)p2 &gt; 0)
	{
		return 1;
	}
	else if (*(int*)p1 - *(int*)p2 &lt; 0)
	{
		return -1;
	}
	else
	{
		return 0;
	}
}</code></pre> 
<p>也可以简化成一下代码</p> 
<pre><code class="language-cs">int com(const void* p1, const void* p2)
{
	return *(int*)p1 - *(int*)p2;
}</code></pre> 
<p>这里我们要根据自身需求去决定是p1-p2还是p2-p1。</p> 
<p>完整代码</p> 
<pre><code class="language-cs">int com(const void* p1, const void* p2)
{
	return *(int*)p1 - *(int*)p2;
}
int main()
{
	int arr[5] = { 23,45,67,24,78 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	qsort(arr, sz, sizeof(arr[0]), com);
	for (int i = 0; i &lt; sz; i++)
	{
		printf("%d ", arr[i]);
	}
	
	return 0;
}</code></pre> 
<h3>2.2 qsort()实现对结构体数组的排序</h3> 
<p>我们先创建一个结构体</p> 
<pre><code class="language-cs">struct stu
{
	char name[100];
	int age;
};
int main()
{
	struct stu arr[3] = { {"zhangsan",18},{"lisi",54},{"laoba",25} };
	int sz = sizeof(arr) / sizeof(arr[0]);
}</code></pre> 
<p>接下来，我们就可以通过qsort()函数根据名字和年龄来排序 。</p> 
<h4>2.2.1 根据年龄来排</h4> 
<p>整体思路跟上面讲的对整形数组排序的思路是一样的。</p> 
<p>但有一点需要注意的是，我们排序的是结构体数组，我们要使用结构体里面的某一类型数据时，要用到 -&gt; 操作符。使用方法为 <span style="color:#fe2c24;">结构体指针-&gt;结构体变量名 。</span></p> 
<p><span style="color:#0d0016;">代码如下</span></p> 
<pre><code class="language-cs">struct stu
{
	char name[100];
	int age;
};
int com_age(const void* p1, const void* p2)
{
	return ((struct stu*)p1)-&gt;age - ((struct stu*)p2)-&gt;age;
}
int main()
{
	struct stu arr[3] = { {"zhangsan",18},{"lisi",54},{"laoba",25} };
	int sz = sizeof(arr) / sizeof(arr[0]);
	qsort(arr, sz, sizeof(arr[0]),com_age);
	return 0;
}</code></pre> 
<p>通过调试发现，结构体数组里面的会根据年龄来进行排序。</p> 
<h4>2.2.2 根据名字来排</h4> 
<p>由于我们定义name的类型为char，所以这时候比较字符串就要用到 strcmp() 函数，其包含在</p> 
<p>头文件&lt;string.h&gt;中。</p> 
<p>我们要知道strcmp()函数的比较方法。其实将相对应的字符转换称为ASCII值进行交换，知道遇到相对应的字符串不同时，哪个字符的ASCII值大，则其对应的字符串就大。</p> 
<p>了解了这些，思路跟前面是差不多的。</p> 
<p>代码如下</p> 
<pre><code class="language-cs">struct stu
{
	char name[100];
	int age;
};
int com_name(const void* p1, const void* p2)
{
	return strcmp(((struct stu*)p1)-&gt;name - ((struct stu*)p2)-&gt;name);
}
int main()
{
	struct stu arr[3] = { {"zhangsan",18},{"lisi",54},{"laoba",25} };
	int sz = sizeof(arr) / sizeof(arr[0]);
	qsort(arr, sz, sizeof(arr[0]),com_name);
	return 0;
}</code></pre> 
<h2>3.冒泡排序模拟qsort()函数</h2> 
<p>既然我们是用冒泡排序来模拟qsort()函数，那么冒泡排序的思维还是用得上的，也就是说基本框架还是不变的。</p> 
<p>基本框架</p> 
<pre><code class="language-cs">void bubble_sort(void* base, size_t sz, size_t width, int (*com)(const void*p1,const void*p2))
{
for(i=0;i&lt;sz-1;i++)
{
   for(j=0;j&lt;sz-i-1;j++)
   {
      if()
    }
}
}</code></pre> 
<p>我们知道冒泡 排序的核心思想是让数组内相邻的元素进行比较，所以模拟qsort()时，依旧不变，只是获取两个相邻比较的元素方式变了，应为模拟qsort()函数时，bubble_sort 形参接收的是数组首元素的地址。所以if 里面不能直接使用数组里面的元素了。</p> 
<p>因此，我们要换一个思维。</p> 
<p>从上面的基本框架可知，bubble_sort 里面有一个比较函数的形参，而if 括号里面恰好是两个元素的比较，p1和p2也是数组里面前后的两个元素，一开始*p1是首元素，*p2是第二个元素，所以我们可以让比较汉书称为if 需要的表达式。</p> 
<p>则if 里面com函数里面实参可以这样写，如下图</p> 
<p class="img-center"><img alt="" height="244" src="https://images2.imgbox.com/b0/9c/KEOlRFZQ_o.png" width="463"></p> 
<p>因为com函数里面的参数本来是const void*类型的，无法直接进行指针的加减运算，所以我们将其类型转换为char*的。</p> 
<p>这时就有人疑惑了，我们要排序的数据类型是int型的，为什么不直接将其转换成int*呢？</p> 
<p>首先我们要清楚指针类型的意义只是让指针进行加减整数运算时能过跳过几个字节。转换成int*，一次加1能跳过4个字节，如果我们要排序7个字节的元素，就会有可能出问题。</p> 
<p>而char* 指针一次加1就跳过一个字节，这样，一个一个字节进行比较，能有更好的效果。</p> 
<p>如下所示</p> 
<pre><code class="language-cs">if (com((char*)base+j*width,(char*)base+(j+1)*width)&gt;0)</code></pre> 
<p> 比较完两个元素之后，我们就要进行交换。我们另写一个swap()函数完成此功能。</p> 
<p>因为要比较的两个元素已经知道，直接搬到函数里面</p> 
<pre><code class="language-cs">	if (com((char*)base+j*width,(char*)base+(j+1)*width)&gt;0)
	{
		swap((char*)base + j * width, (char*)base + (j + 1) * width,width);
    }</code></pre> 
<p>如何将其互换也是一个重点。</p> 
<p>因为是char* 类型的数据，加减整数1都只跳过一个字节。</p> 
<p>思维是 因为数据是存在内存中的，所以只要将数据的内存进行互换，两个元素的值也就交换了。</p> 
<p>所以将 需要比较的元素按一个一个空间来换。</p> 
<p>仅仅知道交换是不够的，我们还要知道交换几个字节，所以也要将元素大小width传过去</p> 
<pre><code class="language-cs">swap(char* buf1, char* buf2, int width)
{
	int i = 0;
	for (i = 0; i &lt; width; i++)
	{
		char tmp = *buf1;
		*buf1 = *buf2;
		*buf2 = tmp;
		buf1++;
		buf2++;
	}
}</code></pre> 
<p>到这里差不多就完成了，完整代码如下</p> 
<pre><code class="language-cs">int com(const void* p1, const void* p2)
{
	return *(int*)p1 - *(int*)p2;
}
swap(char* buf1, char* buf2, int width)
{
	int i = 0;
	for (i = 0; i &lt; width; i++)
	{
		char tmp = *buf1;
		*buf1 = *buf2;
		*buf2 = tmp;
		buf1++;
		buf2++;
	}
}
void bubble_sort(void* base, size_t sz, size_t width, int (*com)(const void*p1,const void*p2))
{
	int i = 0;
	for (i = 0; i &lt; sz - 1; i++)
	{
		int j = 0;
		for (j = 0; j &lt; sz - 1 - i; j++)
		{
			if (com((char*)base+j*width,(char*)base+(j+1)*width)&gt;0)
			{
				swap((char*)base + j * width, (char*)base + (j + 1) * width,width);
		   }
		}
	}
}
void Print(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i &lt; sz; i++)
	{
		printf("%d ", arr[i]);
	}
}
int main()
{
	int arr[5] = { 23,13,67,48,35 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr, sz, sizeof(arr[0]), com);
	Print(arr, sz);
	return 0;
}
</code></pre> 
<p><img alt="" height="694" src="https://images2.imgbox.com/02/6a/80UPi4fL_o.png" width="1200"> </p> 
<p>接着比较结构体</p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void sort(int arr[], int sz)
{
	
	int i, j;
	for (i = 0; i &lt; sz - 1; i++)
	{
		for (j = 0; j &lt; sz - i; j++)
		{
			if (arr[j] &gt; arr[j + 1])
			{
				int temp = arr[j + 1];
				arr[j + 1] = arr[j];
				arr[j] = temp;
			}
		}
	}
}
void Swap(char *p1,char *p2,int wid)
{
	for (int i = 0; i &lt; sz; i++)
	{
		char temp = *(p2 + i);
		*(p2 + i) = *(p1 + i);
		*(p1 + i) = temp;
	}
}
 
int cmp_int(const void* p1, const void* p2)
{
	return *(int*)p1 - *(int*)p2;
}
void bubble_sort(void *base,int sz,int width,int (*cmp)(const void *p1,const void *p2))
{
	
	for (i = 0; i &lt; sz - 1; i++)
	{
		for (j = 0; j &lt; sz - i - 1; j++)
		{
			if (cmp((char *)base + j * width,(char *)base + (j + 1)* width)&gt;0)
			{
				
				Swap((char*)base + j * width, (char*)base + (j + 1) * width,width);
			}
		}
	}
}
void test()
{
	int arr[] = { 3,12,35,8,9,6,59,0,8, };
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr, sz, sizeof(arr[0]), cmp_int);
	for (int i = 0; i &lt; sz; i++)
		printf("%d ", arr[i]);
}
int main()
{
	test();
	return 0;
}</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/faf4a3d6db5edfb94c55cb553593e327/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode_32_困难_最长有效括号</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c796a4877c7917ea8beea0ec7224c843/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OFDM调制解调的优势</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>