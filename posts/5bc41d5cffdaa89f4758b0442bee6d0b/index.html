<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>玩转汇编——通用数据处理指令（一） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/5bc41d5cffdaa89f4758b0442bee6d0b/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="玩转汇编——通用数据处理指令（一）">
  <meta property="og:description" content="玩转汇编——通用数据处理指令（一） 一、数据传送指令（一）通用传送指令1.传送指令MOV2.交换指令XCHG （二）堆栈操作指令1.进栈指令PUSH2.出栈指令POP3.堆栈的应用 （三）其他传送指令1.地址传送指令2.换码指令3.与IO交互的输入输出指令 一、数据传送指令 （一）通用传送指令 1.传送指令MOV ①源操作数与目的操作数类型必须一致
②两个操作数其中之一必须要有明确的类型，两者都无法指定类型时，要显示指定（eg. mov byte ptr [bx],255 即byte ptr 说明是字节操作 ）
③不允许两个操作数都是主存单元
④对专用寄存器可进行操作的指令有限，功能不强，使用时要注意。（例如，立即数不能直接传送段寄存器DS，要通过AX间接传送给DS）
2.交换指令XCHG 交换指令XCHG用来将8位或16位源操作数和目的操作数内容交换，可以在通用寄存器与通用寄存器或存储器之间对换数据。
合法格式：〈reg通用寄存器 mem存储器〉
xchg reg,reg/mem
xchg reg/mem,reg
交换指令实现位置互换，无所谓源操作数与目的操作数的位置前后，注意操作数不能是立即数，也不支持存储器与存储器之间数据对换。
在8086处理器中，空操作指令（助记符NOP）NOP与xchg ax,ax等价。空指令有两个作用：（1）该指令在主存中占用一字节空间，可用来临时占用代码空间，以便后续填入需要的指令代码；执行空指令花费时间，可实现短时间延时。
（二）堆栈操作指令 堆栈是一个按照“先进后出FIFO”存取原则组织的存储区域。堆栈具有两种基本操作：数据压入堆栈（进栈指令PUSH），数据弹出堆栈（出栈指令POP）。
8086处理器的堆栈建立在主存区域中，SS段寄存器指向段基地址，堆栈段的范围由堆栈指针寄存器SP的初值确定，这个位置就是堆栈底部（栈底处于高地址，栈顶处于低地址，栈顶即为数据入口）。数据进入堆栈，SP逐渐减小（SP-2H）；数据依次弹出堆栈，SP逐渐增大（SP&#43;2H）。
8086处理器的堆栈只能以字为单位操作。
1.进栈指令PUSH 由于目的位置就是栈顶，由SP确定，PUSH指令只表达源操作数。(SP自减)
格式为：push r16/m16/seg
&amp;lt;r16 表示16位通用寄存器内容，m16表示16位存储操作数，seg表示段寄存器内容&amp;gt;
PUSH操作步骤：
①SP←SP-2
②SS:[SP]←r16/m16/seg
进栈字量数据时，SP向低地址移动2字节单元指向栈顶，即减2（准备了两个字节的存储单元）；然后数据以“低对低，高对高”的小端方式放到栈顶。
2.出栈指令POP 由于源操作数在栈顶，由SP确定，POP指令只表达目的操作数。(SP自增)
格式为：pop r16/m16/seg
POP操作步骤：
①r16/m16/seg←SS:[SP]
②SP←SP&#43;2
出栈字量数据时，首先数据以“低对低，高对高”的小端方式原则从栈顶传送目的位置；然后SP向高地址移动2字节单元，即加2。
3.堆栈的应用 （三）其他传送指令 1.地址传送指令 存储器操作数具有地址属性，地址传送指令获取存储器操作数的地址
LEA r16,mem ;r16←mem的有效地址EA（不需类型一致）
LEA指令类似于地址操作符OFFSET的作用
LEA指令在指令执行时计算出偏移地址
OFFSET操作符在汇编阶段取得变量的偏移地址
OFFSET无需在执行时计算、指令执行速度更快
LEA指令能获取汇编阶段无法确定的偏移地址
2.换码指令 数据表是常见的数据结构，编程中经常需要获得数据表中某个特定的数据项，处理器为此专门设计了换码指令。
XLAT指令功能：AL←[BX＋AL]
使用XLAT指令前，将BX指定的缓冲区中，AL指定的位移处的一个字节数据，取出赋给AL（由于XLAT指令隐含使用BX和AL,所以其助记符后无须写出操作数，默认该缓冲区在DS数据段）。
换码指令执行前：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-11-19T17:54:06+08:00">
    <meta property="article:modified_time" content="2022-11-19T17:54:06+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">玩转汇编——通用数据处理指令（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>玩转汇编——通用数据处理指令（一）</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、数据传送指令</a></li><li><ul><li><a href="#_2" rel="nofollow">（一）通用传送指令</a></li><li><ul><li><a href="#1MOV_3" rel="nofollow">1.传送指令MOV</a></li><li><a href="#2XCHG_21" rel="nofollow">2.交换指令XCHG</a></li></ul> 
   </li><li><a href="#_31" rel="nofollow">（二）堆栈操作指令</a></li><li><ul><li><a href="#1PUSH_39" rel="nofollow">1.进栈指令PUSH</a></li><li><a href="#2POP_50" rel="nofollow">2.出栈指令POP</a></li><li><a href="#3_60" rel="nofollow">3.堆栈的应用</a></li></ul> 
   </li><li><a href="#_64" rel="nofollow">（三）其他传送指令</a></li><li><ul><li><a href="#1_65" rel="nofollow">1.地址传送指令</a></li><li><a href="#2_74" rel="nofollow">2.换码指令</a></li><li><a href="#3IO_91" rel="nofollow">3.与IO交互的输入输出指令</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、数据传送指令</h2> 
<h3><a id="_2"></a>（一）通用传送指令</h3> 
<h4><a id="1MOV_3"></a>1.传送指令MOV</h4> 
<p><img src="https://images2.imgbox.com/e9/44/J2Z3K5ZO_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>①源操作数与目的操作数类型必须一致</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d7/50/8eSGtfO9_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>②两个操作数其中之一必须要有明确的类型，两者都无法指定类型时，要显示指定（eg. mov byte ptr [bx],255 即byte ptr 说明是字节操作 ）</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/62/38/Znb4Vmo1_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>③不允许两个操作数都是主存单元</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6a/ee/Kepbzuih_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>④对专用寄存器可进行操作的指令有限，功能不强，使用时要注意。（例如，立即数不能直接传送段寄存器DS，要通过AX间接传送给DS）</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f3/20/bLBRyytN_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2XCHG_21"></a>2.交换指令XCHG</h4> 
<p>交换指令XCHG用来将8位或16位源操作数和目的操作数内容交换，可以在通用寄存器与通用寄存器或存储器之间对换数据。</p> 
<blockquote> 
 <p>合法格式：〈reg通用寄存器 mem存储器〉<br> xchg reg,reg/mem<br> xchg reg/mem,reg</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/54/4d/jlZbuXD6_o.png" alt="在这里插入图片描述"></p> 
<p>交换指令实现位置互换，无所谓源操作数与目的操作数的位置前后，<mark>注意操作数不能是立即数，也不支持存储器与存储器之间数据对换</mark>。<br> 在8086处理器中，空操作指令（助记符NOP）NOP与xchg ax,ax等价。空指令有两个作用：（1）该指令在主存中占用一字节空间，可用来临时占用代码空间，以便后续填入需要的指令代码；执行空指令花费时间，可实现短时间延时。</p> 
<h3><a id="_31"></a>（二）堆栈操作指令</h3> 
<p>堆栈是一个按照“先进后出FIFO”存取原则组织的存储区域。<strong>堆栈具有两种基本操作：数据压入堆栈（进栈指令PUSH），数据弹出堆栈（出栈指令POP）。</strong><br> 8086处理器的堆栈建立在主存区域中，SS段寄存器指向段基地址，堆栈段的范围由堆栈指针寄存器SP的初值确定，这个位置就是堆栈底部（栈底处于高地址，栈顶处于低地址，栈顶即为数据入口）。<strong>数据进入堆栈，SP逐渐减小（SP-2H）；数据依次弹出堆栈，SP逐渐增大（SP+2H）</strong>。<br> <img src="https://images2.imgbox.com/87/15/z2DNQphQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d4/31/vsjdhYsd_o.png" alt="在这里插入图片描述"></p> 
<p><strong>8086处理器的堆栈只能以字为单位操作。</strong></p> 
<h4><a id="1PUSH_39"></a>1.进栈指令PUSH</h4> 
<p>由于目的位置就是栈顶，由SP确定，PUSH指令只表达源操作数。(SP自减)</p> 
<blockquote> 
 <p><mark>格式为：push r16/m16/seg</mark><br> &lt;r16 表示16位通用寄存器内容，m16表示16位存储操作数，seg表示段寄存器内容&gt;<br> <strong>PUSH操作步骤：<br> ①SP←SP-2<br> ②SS:[SP]←r16/m16/seg</strong></p> 
</blockquote> 
<p>进栈字量数据时，SP向低地址移动2字节单元指向栈顶，即减2（准备了两个字节的存储单元）；然后数据以“低对低，高对高”的小端方式放到栈顶。<br> <img src="https://images2.imgbox.com/6b/c8/Tm7KzXoL_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2POP_50"></a>2.出栈指令POP</h4> 
<p>由于源操作数在栈顶，由SP确定，POP指令只表达目的操作数。(SP自增)</p> 
<blockquote> 
 <p><mark>格式为：pop r16/m16/seg</mark><br> <strong>POP操作步骤：<br> ①r16/m16/seg←SS:[SP]<br> ②SP←SP+2</strong></p> 
</blockquote> 
<p>出栈字量数据时，首先数据以“低对低，高对高”的小端方式原则从栈顶传送目的位置；然后SP向高地址移动2字节单元，即加2。<br> <img src="https://images2.imgbox.com/72/3e/62FUxgqp_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4e/c1/DeXK7N03_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_60"></a>3.堆栈的应用</h4> 
<p><img src="https://images2.imgbox.com/76/4f/qjblmM6A_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_64"></a>（三）其他传送指令</h3> 
<h4><a id="1_65"></a>1.地址传送指令</h4> 
<p>存储器操作数具有地址属性，地址传送指令获取存储器操作数的地址<br> LEA r16,mem ;r16←mem的有效地址EA（不需类型一致）</p> 
<blockquote> 
 <p><strong>LEA指令类似于地址操作符OFFSET的作用</strong><br> LEA指令<strong>在指令执行时</strong>计算出偏移地址<br> OFFSET操作符<strong>在汇编阶段</strong>取得变量的偏移地址<br> <strong>OFFSET无需在执行时计算、指令执行速度更快<br> LEA指令能获取汇编阶段无法确定的偏移地址</strong></p> 
</blockquote> 
<h4><a id="2_74"></a>2.换码指令</h4> 
<p>数据表是常见的数据结构，编程中经常需要获得数据表中某个特定的数据项，处理器为此专门设计了换码指令。<br> <strong>XLAT指令功能：AL←[BX＋AL]</strong><br> 使用XLAT指令前，将BX指定的缓冲区中，AL指定的位移处的一个字节数据，取出赋给AL（由于XLAT指令隐含使用BX和AL,所以其助记符后无须写出操作数，默认该缓冲区在DS数据段）。</p> 
<blockquote> 
 <p><strong>换码指令执行前：<br> 在主存建立一个字节量表格，内含有目的代码，表格首地址存放于BX，AL存放相对表格首地址的位移量。<br> 换码指令执行后：<br> 将AL寄存器的内容转换为目标代码。</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6b/ae/pkHRy7e7_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>示例解惑：<br> 在上例中，num相当于是索引值，tab是数据代码表，cx寄存器记录循环次数（当执行loop循环时cx会自减1，当cx=0时退出循环）<br> 本例将要搜索的索引值num的偏移地址赋给si寄存器（<strong>因为基址变址寻址原则上是基址存放于BX/BP寄存器中，变址存放于SI/DI寄存器中，故此处的变址偏移量先存放于SI寄存器中</strong>），tab代码表的偏移地址赋给bx寄存器（<strong>XLAT指令功能：AL←[BX＋AL]</strong> ）然后将第一个索引值赋值给al寄存器，执行XLAT指令相当于用基址变址的方法寻址，将bx存储的代码表中的内容按照偏移量取出再放入AL寄存器里（此时AL寄存器里存的是代码表中对应索引值的字符ASCII码），最后显示完再调整si，指向下一个数字。</p> 
</blockquote> 
<p>对于换码指令，我的个人理解是类似于先定义一个存储目标内容的数组（对应tab-&gt;bx）再定好要去找谁（对应num-&gt;si-&gt;al）最后从目标内容数组中取出对应索引的值，放到AL寄存器中（XLAT：AL←[BX＋AL] ）到此就完成了换码操作。</p> 
<p><img src="https://images2.imgbox.com/e2/b2/kP0BxSRT_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3IO_91"></a>3.与IO交互的输入输出指令</h4> 
<p><img src="https://images2.imgbox.com/36/cd/eGX3Q2Pg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b3/78/NMpvqNCe_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/08/65/1pRhB9Dw_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a6cf4c3ac620cf948c23f085e04fea7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">静态HTML网页设计作品 DIV布局家乡介绍网页模板代码---(太原 10页带本地存储登录注册 js表单校验)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/34803b187440aa7a136a3e818170cce1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C# 弹出小窗口并将窗口参数返回给主窗口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>