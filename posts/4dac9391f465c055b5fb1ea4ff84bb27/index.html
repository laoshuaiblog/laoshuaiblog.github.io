<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>八大排序算法之归并排序(递归实现&#43;非递归实现) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/4dac9391f465c055b5fb1ea4ff84bb27/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="八大排序算法之归并排序(递归实现&#43;非递归实现)">
  <meta property="og:description" content="目录
一.归并排序的基本思想
归并排序算法思想(排升序为例)
二.两个有序子序列(同一个数组中)的归并(排升序)
两个有序序列归并操作代码:
三.归并排序的递归实现
递归归并排序的实现:(后序遍历递归)
递归函数抽象分析: 四.非递归归并排序的实现
1.非递归归并排序算法思想:
2.算法实现
初步非递归归并排序函数:
一般情况下(所排序数组元素个数不为​编辑)边界条件分析:
经过边界修正后的非递归归并排序函数
排序实测:
一.归并排序的基本思想 归并排序是基于分治思想和归并操作而设计出来的一种高效排序算法所谓的归并操作就是将两个有序的子序列合并为一个有序序列的操作(归并操作算法的时间复杂度为O(N&#43;M),N&#43;M分别为两个子数组的元素个数) 归并排序算法思想(排升序为例) 假设数组有N个元素,先将数组不断地二分,直到将数组划分为N个由单个元素构成的子数组,整个划分过程中所有子数组构成满二叉树(或接近满二叉树)的逻辑结构,如图:数组划分完后再逐层向上将二叉树兄弟结点子数组(具有相同前驱结构)两两进行归并操作完成排序:归并操作算法的时间复杂度为O(M1&#43;M2),M1&#43;M2分别为两个子数组的元素个数,因此二叉树一层子数组的两两归并操作的总时间复杂度为O(N)(N表示原数组的元素个数),而满二叉树的层次数量级为O(logN),因此归并排序的总体时间复杂度为O(NlogN)由于归并排序的数组划分每次都是严格地二分,因此每次排序(无论具体面对怎样的序列)子数组划分结构都是稳定的满二叉树(或接近满二叉树)结构,因此归并排序的时间复杂度在各种情况下都不会有变化(不会像快排,希尔排那样由于所处理的序列的逆序数的差异而导致算法时间复杂度有所变化)然而由于有序序列归并操作需要额外开辟数组来完成,因此归并排序有较大的空间消耗,这是归并排序的一个缺陷 二.两个有序子序列(同一个数组中)的归并(排升序) 函数首部:
void MergeSort(int* arr,int* tem, int left,int right) arr是被分割的原数组,tem是用于归并操作的临时数组,left是arr的左端下标,right是arr的右端下标
假设数组arr被二等分为两个子序列(两个子序列都是有序的):接下来我们将上图中的[left,(left&#43;right)/2)和[(left&#43;right)/2),right)两个子序列(有序)合并到一个tem数组中构成一个新的有序序列(利用三指针操作完成归并):从算法gif中不难看出,归并操作的时间复杂度与两个子数组的元素个数成线性关系 两个有序序列归并操作代码: void MergeSort(int* arr,int* tem, int left,int right) { int mid = left &#43; (right - left) / 2;	//找到数组[left,right]的中间分割点 int ptr1 = left;	//ptr1指向左子数组的首元素 int ptr2 = mid;	//ptr2指向右子数组的首元素 int ptrtem = left; //ptrtem用于在tem数组中尾插数据 while (ptr1 &amp;lt; mid &amp;amp;&amp;amp; ptr2 &amp;lt; right)	//ptr1和ptr2其中一个遍历完子数组就停止循环 { //将较小元素尾插进tem数组中 if (arr[ptr1] &amp;gt; arr[ptr2]) { tem[ptrtem] = arr[ptr2]; &#43;&#43;ptrtem; &#43;&#43;ptr2; } else { tem[ptrtem] = arr[ptr1]; &#43;&#43;ptrtem; &#43;&#43;ptr1; } } //将未被遍历完的子数组剩下的元素尾插到tem数组中 while (ptr1 &amp;lt; mid) { tem[ptrtem] = arr[ptr1]; &#43;&#43;ptrtem; &#43;&#43;ptr1; } while (ptr2 &amp;lt; right) { tem[ptrtem] = arr[ptr2]; &#43;&#43;ptrtem; &#43;&#43;ptr2; } //将归并好的有序序列拷贝到原数组arr上 for (int i = left; i &amp;lt; right; &#43;&#43;i) { arr[i] = tem[i]; } } 三.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-04-05T09:33:09+08:00">
    <meta property="article:modified_time" content="2023-04-05T09:33:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">八大排序算法之归并排序(递归实现&#43;非递归实现)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="1024" src="https://images2.imgbox.com/86/b9/WU2NwI7H_o.gif" width="723"></h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">一.归并排序的基本思想</a></p> 
<p id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3(%E6%8E%92%E5%8D%87%E5%BA%8F%E4%B8%BA%E4%BE%8B)-toc" style="margin-left:80px;"><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%28%E6%8E%92%E5%8D%87%E5%BA%8F%E4%B8%BA%E4%BE%8B%29" rel="nofollow">归并排序算法思想(排升序为例)</a></p> 
<p id="%E4%BA%8C.%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%AD%90%E5%BA%8F%E5%88%97(%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD)%E7%9A%84%E5%BD%92%E5%B9%B6(%E6%8E%92%E5%8D%87%E5%BA%8F)-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%AD%90%E5%BA%8F%E5%88%97%28%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%29%E7%9A%84%E5%BD%92%E5%B9%B6%28%E6%8E%92%E5%8D%87%E5%BA%8F%29" rel="nofollow">二.两个有序子序列(同一个数组中)的归并(排升序)</a></p> 
<p id="%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E5%BD%92%E5%B9%B6%E4%BB%A3%E7%A0%81%3A-toc" style="margin-left:80px;"><a href="#%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E5%BD%92%E5%B9%B6%E4%BB%A3%E7%A0%81%3A" rel="nofollow">两个有序序列归并操作代码:</a></p> 
<p id="%E4%B8%89.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" rel="nofollow">三.归并排序的递归实现</a></p> 
<p id="%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%3A(%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92)-toc" style="margin-left:80px;"><a href="#%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%3A%28%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92%29" rel="nofollow">递归归并排序的实现:(后序遍历递归)</a></p> 
<p id="%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1%E5%88%86%E6%9E%90%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1%E5%88%86%E6%9E%90%3A%C2%A0" rel="nofollow">递归函数抽象分析: </a></p> 
<p id="%E5%9B%9B.%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">四.非递归归并排序的实现</a></p> 
<p id="1.%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%3A-toc" style="margin-left:40px;"><a href="#1.%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%3A" rel="nofollow">1.非递归归并排序算法思想:</a></p> 
<p id="2.%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2.%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" rel="nofollow">2.算法实现</a></p> 
<p id="%E5%88%9D%E6%AD%A5%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%3A-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E6%AD%A5%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%3A" rel="nofollow">初步非递归归并排序函数:</a></p> 
<p id="%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B(%E6%89%80%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E4%B8%8D%E4%B8%BA%E2%80%8B%E7%BC%96%E8%BE%91)%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90%3A-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%28%E6%89%80%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E4%B8%8D%E4%B8%BA%E2%80%8B%E7%BC%96%E8%BE%91%29%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90%3A" rel="nofollow">一般情况下(所排序数组元素个数不为​编辑)边界条件分析:</a></p> 
<p id="%E7%BB%8F%E8%BF%87%E8%BE%B9%E7%95%8C%E4%BF%AE%E6%AD%A3%E5%90%8E%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E7%BB%8F%E8%BF%87%E8%BE%B9%E7%95%8C%E4%BF%AE%E6%AD%A3%E5%90%8E%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0" rel="nofollow">经过边界修正后的非递归归并排序函数</a></p> 
<p id="%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%B5%8B%3A-toc" style="margin-left:80px;"><a href="#%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%B5%8B%3A" rel="nofollow">排序实测:</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">一.归并排序的基本思想</h2> 
<blockquote> 
 <ul><li><strong><span style="background-color:#a2e043;">归并排序</span>是基于<span style="background-color:#ffd900;">分治思想和归并操作</span>而设计出来的一种高效排序算法</strong></li><li><strong>所谓的<span style="background-color:#a2e043;">归并操作</span>就是<span style="background-color:#ffd900;">将两个有序的子序列</span>合并为<span style="color:#0d0016;"><span style="background-color:#a2e043;">一个有序序列</span></span>的操作(<span style="background-color:#ffd900;">归并操作算法</span>的<span style="background-color:#a2e043;">时间复杂度</span>为<span style="background-color:#ffd900;">O(N+M)</span>,<span style="background-color:#a2e043;">N+M</span>分别为<span style="background-color:#ffd900;">两个子数组的元素个数</span>)</strong></li></ul> 
 <h4 id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3(%E6%8E%92%E5%8D%87%E5%BA%8F%E4%B8%BA%E4%BE%8B)"><span style="color:#0d0016;"><strong>归并排序算法思想(排升序为例)</strong></span></h4> 
 <ol><li><span style="color:#0d0016;"><strong>假设</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">数组有N个元素</span></strong></span><span style="color:#0d0016;"><strong>,先<span style="background-color:#a2e043;">将数组不断地二分</span>,直到将数组划分为<span style="background-color:#ffd900;">N个由单个元素构成的子数组</span>,<span style="background-color:#a2e043;">整个划分过程中</span><span style="background-color:#ffd900;">所有子数组</span>构成<span style="background-color:#a2e043;">满二叉树(</span><span style="background-color:#ffd900;">或接近满二叉树</span><span style="background-color:#a2e043;">)</span>的逻辑结构,如图:</strong></span><img alt="" height="679" src="https://images2.imgbox.com/8f/ed/ZHcKjRTq_o.png" width="1200"></li><li><strong>数组划分完后再<span style="background-color:#ffd900;">逐层向上</span>将二叉树<span style="background-color:#a2e043;">兄弟结点子数组(具有相同前驱结构)</span><span style="background-color:#ffd900;">两两进行归并操作</span>完成排序:</strong><img alt="" height="752" src="https://images2.imgbox.com/5a/45/WogoaUxi_o.png" width="1200"></li><li><strong><span style="background-color:#ffd900;">归并操作算法</span>的<span style="background-color:#a2e043;">时间复杂度</span>为<span style="background-color:#ffd900;">O(M1+M2)</span>,<span style="background-color:#a2e043;">M1+M2</span>分别为<span style="background-color:#ffd900;">两个子数组的元素个数</span>,因此<span style="color:#fe2c24;">二叉树</span><span style="color:#0d0016;"><span style="background-color:#a2e043;">一层子数组</span></span>的<span style="color:#fe2c24;">两两归并操作</span>的<span style="background-color:#ffd900;">总时间复杂度为O(N)</span>(N表示<span style="background-color:#a2e043;">原数组的元素个数</span>),而<span style="color:#fe2c24;">满二叉树</span>的<span style="background-color:#a2e043;">层次数量级</span>为<span style="background-color:#ffd900;">O(logN)</span>,因此<span style="background-color:#a2e043;">归并排序的总体时间复杂度</span>为O(NlogN)</strong></li><li><strong>由于<span style="background-color:#ffd900;">归并排序的数组划分</span>每次都是<span style="background-color:#a2e043;">严格地二分</span>,因此每次排序(<span style="color:#fe2c24;">无论具体面对怎样的序列</span>)<span style="background-color:#ffd900;">子数组划分结构</span>都是<span style="background-color:#a2e043;">稳定的满二叉树(</span><span style="background-color:#ffd900;">或接近满二叉树</span><span style="background-color:#a2e043;">)结构</span>,因此<span style="background-color:#ffd900;">归并排序的时间复杂度</span>在<span style="background-color:#a2e043;">各种情况下都不会有变化</span>(不会像快排,希尔排那样由于<span style="background-color:#a2e043;">所处理的序列的逆序数的差异</span>而导致<span style="background-color:#ffd900;">算法时间复杂度</span>有所变化)</strong></li><li><strong>然而由于<span style="background-color:#ffd900;">有序序列归并操作</span>需要<span style="background-color:#a2e043;">额外开辟数组</span>来完成,因此归并排序有较大的空间消耗,这是归并排序的一个缺陷</strong></li></ol> 
</blockquote> 
<h2 id="%E4%BA%8C.%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%AD%90%E5%BA%8F%E5%88%97(%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD)%E7%9A%84%E5%BD%92%E5%B9%B6(%E6%8E%92%E5%8D%87%E5%BA%8F)">二.两个有序子序列(同一个数组中)的归并(排升序)</h2> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>函数首部:</strong></span></p> 
 <pre><code class="language-cpp">void MergeSort(int* arr,int* tem, int left,int right)</code></pre> 
 <p><span style="color:#0d0016;"><strong>arr是<span style="background-color:#ffd900;">被分割的原数组</span>,tem是<span style="background-color:#a2e043;">用于归并操作的临时数组</span>,left是arr的<span style="background-color:#ffd900;">左端</span>下标,right是arr的<span style="background-color:#ffd900;">右端</span>下标</strong></span></p> 
 <ul><li><span style="color:#0d0016;"><strong>假设数组arr被<span style="background-color:#a2e043;">二等分</span>为两个子序列(</strong></span><span style="color:#fe2c24;"><strong>两个子序列都是有序的</strong></span><span style="color:#0d0016;"><strong>):</strong></span><img alt="" height="454" src="https://images2.imgbox.com/03/1a/qFdZ4emr_o.png" width="917"></li><li><span style="color:#0d0016;"><strong>接下来我们将上图中的<span style="background-color:#ffd900;">[left,(left+right)/2)和[(left+right)/2),right)两个子序列</span>(有序)合并到一个<span style="background-color:#a2e043;">tem数组</span>中构成一个<span style="background-color:#ffd900;">新的有序序列</span>(利用三指针操作完成归并):</strong></span><img alt="" height="792" src="https://images2.imgbox.com/82/ee/gW5CFT0V_o.gif" width="1200"></li><li><span style="color:#0d0016;"><strong>从算法gif中不难看出,<span style="background-color:#ffd900;">归并操作的时间复杂度</span>与<span style="background-color:#a2e043;">两个子数组的元素个数</span>成</strong></span><span style="color:#fe2c24;"><strong>线性关系</strong></span></li></ul> 
 <h4 id="%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E5%BD%92%E5%B9%B6%E4%BB%A3%E7%A0%81%3A"><span style="color:#0d0016;"><strong>两个有序序列归并操作代码:</strong></span></h4> 
 <pre><code class="language-cpp">void MergeSort(int* arr,int* tem, int left,int right)
{
	int mid = left + (right - left) / 2;			//找到数组[left,right]的中间分割点

	int ptr1 = left;								//ptr1指向左子数组的首元素
	int ptr2 = mid;									//ptr2指向右子数组的首元素
	int ptrtem = left;                              //ptrtem用于在tem数组中尾插数据
	while (ptr1 &lt; mid &amp;&amp; ptr2 &lt; right)				//ptr1和ptr2其中一个遍历完子数组就停止循环
	{
		//将较小元素尾插进tem数组中
		if (arr[ptr1] &gt; arr[ptr2])
		{
			tem[ptrtem] = arr[ptr2];
			++ptrtem;
			++ptr2;
		}
		else
		{
			tem[ptrtem] = arr[ptr1];
			++ptrtem;
			++ptr1;
		}
	}
	//将未被遍历完的子数组剩下的元素尾插到tem数组中
	while (ptr1 &lt; mid)
	{
		tem[ptrtem] = arr[ptr1];
		++ptrtem;
		++ptr1;
	}
	while (ptr2 &lt; right)
	{
		tem[ptrtem] = arr[ptr2];
		++ptrtem;
		++ptr2;
	}
	
	//将归并好的有序序列拷贝到原数组arr上
	for (int i = left; i &lt; right; ++i)
	{
		arr[i] = tem[i];
	}
}</code></pre> 
</blockquote> 
<h2 id="%E4%B8%89.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">三.归并排序的递归实现</h2> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>递归函数首部:</strong></span></p> 
 <pre><code class="language-cpp">void MergeSort(int* arr,int* tem, int left,int right)</code></pre> 
 <p><span style="color:#0d0016;"><strong>arr是<span style="background-color:#ffd900;">被分割的原数组</span>,tem是<span style="background-color:#a2e043;">用于归并操作的临时数组</span>,left是<span style="background-color:#a2e043;">arr的子数组</span>的<span style="background-color:#ffd900;">左端</span>下标,right是<span style="background-color:#a2e043;">arr的子数组</span>的<span style="background-color:#ffd900;">右端</span>下标</strong></span></p> 
 <ul><li><strong>在进行<span style="color:#0d0016;"><span style="background-color:#a2e043;">子数组两两归并</span></span>之前,我们先要进行数组的<span style="background-color:#ffd900;">二分分治</span>:</strong><img alt="" height="701" src="https://images2.imgbox.com/f3/ed/BaSAfTjC_o.png" width="1200"></li><li><span style="color:#0d0016;"><strong>我们可以通过<span style="background-color:#ffd900;">分治递归</span>来<span style="background-color:#a2e043;">完成数组的整个二分过程</span>(每个<span style="background-color:#ffd900;">子数组的区间端点下标</span>都被存储在<span style="background-color:#a2e043;">递归函数的各函数栈帧</span>中):(</strong></span><span style="color:#fe2c24;"><strong>数组二分的递归框架</strong></span><span style="color:#0d0016;"><strong>)</strong></span> <pre><code class="language-cpp">void MergeSort(int* arr, int* tem, int left, int right)
{
	if (right &lt;= left+1)                  //当子数组只剩一个元素时停止划分
	{
		return;
	}
	int mid = left + (right - left) / 2;
	MergeSort(arr, tem, left, mid);      //划分出的左子数组
	MergeSort(arr, tem, mid, right);     //划分出的右子数组

	//左右子数组都有序后完成左右子数组的归并
}</code></pre> </li><li> <p><img alt="" height="656" src="https://images2.imgbox.com/8f/b0/WJ6cSeBw_o.png" width="1200"><span style="color:#0d0016;"><strong>观察<span style="background-color:#ffd900;">递归图解</span>,<span style="background-color:#a2e043;">有序序列两两归并的过程</span></strong></span><span style="color:#fe2c24;"><strong>只能</strong></span><span style="color:#0d0016;"><strong>发生在上图中的<span style="background-color:#ffd900;">第7,第13,第14,第21,第27,第28,第29步骤中</span>,因此<span style="background-color:#a2e043;">整个排序过程</span>满足<span style="background-color:#ffd900;">分治递归的后序遍历逻辑</span></strong></span></p> </li><li> <p><img alt="" height="746" src="https://images2.imgbox.com/2f/a0/bK55ZkZw_o.png" width="1200"></p> </li></ul> 
 <p></p> 
 <h4 id="%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%3A(%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92)"><strong><span style="color:#0d0016;">递归归并排序的实现:(后序遍历递归)</span></strong></h4> 
 <ul><li><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">左右子数组(有序)归并</span>的代码段位于函数中<span style="background-color:#a2e043;">两个递归语句之后</span></strong></span></li></ul> 
 <pre><code class="language-cpp">void MergeSort(int* arr, int* tem, int left, int right)
{
	if (right &lt;= left+1)                  //当子数组只剩一个元素时停止划分
	{
		return;
	}
	int mid = left + (right - left) / 2;
	MergeSort(arr, tem, left, mid);      //划分出的左子数组
	MergeSort(arr, tem, mid, right);     //划分出的右子数组
    
    
    //后序遍历,归并过程发生在两个递归语句之后
	//左右子数组都有序后完成左右子数组的归并
	int ptr1 = left;								//ptr1指向左子数组的首元素
	int ptr2 = mid;									//ptr2指向右子数组的首元素
	int ptrtem = left;                              //ptrtem用于在tem数组中尾插数据
	while (ptr1 &lt; mid &amp;&amp; ptr2 &lt; right)				//ptr1和ptr2其中一个遍历完子数组就停止循环
	{
		//将较小元素尾插进tem数组中
		if (arr[ptr1] &gt; arr[ptr2])
		{
			tem[ptrtem] = arr[ptr2];
			++ptrtem;
			++ptr2;
		}
		else
		{
			tem[ptrtem] = arr[ptr1];
			++ptrtem;
			++ptr1;
		}
	}
	//将未被遍历完的子数组剩下的元素尾插到tem数组中
	while (ptr1 &lt; mid)
	{
		tem[ptrtem] = arr[ptr1];
		++ptrtem;
		++ptr1;
	}
	while (ptr2 &lt; right)
	{
		tem[ptrtem] = arr[ptr2];
		++ptrtem;
		++ptr2;
	}

	//将归并好的有序序列拷贝到原数组arr(相应下标位置)
	for (int i = left; i &lt; right; ++i)
	{
		arr[i] = tem[i];
	}
}
</code></pre> 
 <ul><li><strong>注意细节:</strong><img alt="" height="1200" src="https://images2.imgbox.com/05/dc/U3HYKlpU_o.png" width="967"> </li></ul> 
 <h4 id="%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1%E5%88%86%E6%9E%90%3A%C2%A0"><span style="color:#0d0016;"><strong>递归函数抽象分析: </strong></span></h4> 
 <ul><li><span style="color:#0d0016;"><strong>递归函数<span style="background-color:#ffd900;">MergeSort(arr,tem,left,right)</span>可以抽象为：借助<span style="background-color:#a2e043;">tem数组</span>完成<span style="background-color:#ffd900;">arr数组[left,right)区间序列</span>的排序过程</strong></span></li><li><span style="color:#0d0016;"><strong>于是可以</strong></span><span style="color:#fe2c24;"><strong>抽象出递推公式</strong></span><span style="color:#0d0016;"><strong>:<span style="background-color:#a2e043;">MergeSort(arr,tem,left,right)</span> = <span style="background-color:#ffd900;">MergeSort(arr,tem,left,</span></strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">left + (right - left) / 2</span></strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">) </span>+<span style="background-color:#ffd900;"> MergeSort(arr,tem,</span></strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">left + (right - left) / 2,right</span></strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">)</span> +{<!-- --></strong></span><span style="color:#0d0016;"><strong><span style="background-color:#a2e043;">子数组[left,left + (right - left) / 2))和子数组[left + (right - left) / 2,right)的有序合并</span></strong></span><span style="color:#0d0016;"><strong>}</strong></span></li><li><span style="color:#0d0016;"><strong>递归公式的含义是:完成<span style="background-color:#a2e043;">arr数组[left,right)区间序列排序的过程</span>可以<span style="background-color:#ffd900;">拆分为如下三个步骤</span>:</strong></span></li></ul> 
 <ol><li><span style="color:#0d0016;"><strong>先完成<span style="background-color:#ffd900;">左子区间</span></strong></span><span style="color:#fe2c24;"><strong>[</strong><strong>left,left + (right - left) / 2)</strong></span><span style="color:#0d0016;"><strong>的排序</strong></span></li><li><span style="color:#0d0016;"><strong>再完成<span style="background-color:#ffd900;">右子区间</span></strong></span><span style="color:#fe2c24;"><strong>[</strong><strong>left + (right - left) / 2,right)</strong></span><span style="color:#0d0016;"><strong>的排序</strong></span></li><li><span style="color:#0d0016;"><strong>最后将<span style="background-color:#ffd900;">左右子区间</span><span style="background-color:#a2e043;">进行归并</span>完成<span style="background-color:#ffd900;">[left,right)区间序列</span>的排序</strong></span></li></ol> 
 <ul><li><span style="color:#0d0016;"><strong>将MergeSort函数进行一下<span style="background-color:#ffd900;">简单的封装</span>供外界调用:</strong></span> <pre><code class="language-cpp">void _MergeSort(int* arr, int size)
{
	assert(arr);
	int* tem = (int*)malloc(sizeof(int) * size);
	assert(tem);
	MergeSort(arr, tem, 0, size);
    free(tem);
}
</code></pre> </li><li><span style="color:#0d0016;"><strong>arr是<span style="background-color:#ffd900;">待排序数组</span>,size是<span style="background-color:#a2e043;">数组的元素个数</span>,MergeSort是归并排序递归函数</strong></span></li></ul> 
</blockquote> 
<h2 id="%E5%9B%9B.%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">四.非递归归并排序的实现</h2> 
<h3 id="1.%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%3A">1.非递归归并排序算法思想:</h3> 
<blockquote> 
 <ul><li><span style="color:#0d0016;"><strong>归并排序过程中<span style="background-color:#ffd900;">数组逐步被二分</span>的图示:</strong></span><img alt="" height="674" src="https://images2.imgbox.com/85/e4/lnk7qQF3_o.png" width="1160"></li><li><strong><span style="color:#0d0016;"><span style="background-color:#ffd900;">归并排序的递归实现</span>通过<span style="background-color:#a2e043;">后序遍历逻辑</span>来完成<span style="background-color:#ffd900;">各个子数组的两两归并的操作:</span></span></strong> <img alt="" height="758" src="https://images2.imgbox.com/81/7f/Ro65VNZw_o.png" width="1200"></li><li><strong><span style="color:#0d0016;">然而我们也可以利用类似于<span style="background-color:#ffd900;">层序遍历的逻辑</span>来<span style="background-color:#a2e043;">实现子数组两两归并</span>的过程:</span></strong><img alt="" height="707" src="https://images2.imgbox.com/cf/8c/nOa9PMi4_o.png" width="1200"></li></ul> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">从最高层子数组开始</span>进行<span style="background-color:#a2e043;">兄弟子数组的两两归并</span>,完成了<span style="background-color:#a2e043;">一层子数组的归并</span>再继续<span style="background-color:#ffd900;">完成前一层子数组的归并</span>直到最后完成原数组的排序,</strong></span><span style="color:#fe2c24;"><strong>我们可以通过循环来实现这个过程</strong></span></p> 
</blockquote> 
<h3 id="2.%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">2.算法实现</h3> 
<blockquote> 
 <ul><li><li><span style="color:#0d0016;"><strong>非递归归并排序函数首部:</strong></span> <pre><code class="language-cpp">void MergeSortNonR(int* arr, int size)</code></pre> <p><strong><span style="color:#0d0016;">arr代表<span style="background-color:#ffd900;">待排序的数组</span>,size为<span style="background-color:#a2e043;">待排序数组的元素个数</span></span></strong></p> </li></ul> 
 <p><img alt="" height="637" src="https://images2.imgbox.com/4e/59/lPrMph68_o.png" width="1200"></p> 
 <ul><li><strong><span style="color:#fe2c24;">先假设</span><span style="background-color:#ffd900;">所处理的数组</span>的<span style="background-color:#a2e043;">元素个数:</span>N=<img alt="2^{n}" class="mathcode" src="https://images2.imgbox.com/d5/ad/rMTwkNkg_o.png">(即数组刚好<span style="background-color:#a2e043;">能被完全二分n次</span>)</strong></li><li><strong>取<span style="color:#fe2c24;">gap</span>作为<span style="background-color:#a2e043;">二叉树结构</span><span style="color:#fe2c24;">某层次</span><span style="color:#0d0016;"><span style="background-color:#ffd900;">各</span></span><span style="background-color:#ffd900;">子数组的元素个数</span>:gap初值为1(最深层子数组<span style="background-color:#a2e043;">元素个数为1</span>),随后gap<span style="background-color:#ffd900;">以gap=2*gap的方式递增</span>,用gap来控制<span style="background-color:#a2e043;">排序函数最外层循环</span>:</strong> <pre><code class="language-cpp">	for (int gap = 1; gap &lt; size; gap *= 2)   //完成logN个层次的子数组的归并
	{

	}</code></pre> <p><span style="color:#0d0016;"><strong>该<span style="background-color:#ffd900;">循环能进行log(size)次,</span>对于每个gap值完成<span style="background-color:#a2e043;">一个层次的子数组的两两归并</span>:</strong></span><img alt="" height="1032" src="https://images2.imgbox.com/2b/2f/LcdTqVbI_o.png" width="1200"></p> </li><li> <p></p> <p><span style="color:#0d0016;"><strong>再使用一个<span style="background-color:#ffd900;">变量i</span>来遍历<span style="background-color:#a2e043;">每一个gap情形下</span>的<span style="background-color:#ffd900;">各个进行归并的序列组</span>(每个<span style="background-color:#ffd900;">序列组</span>由<span style="background-color:#a2e043;">两个子数组</span>构成):</strong></span></p>   <p></p> <pre><code class="language-cpp">	for (int gap = 1; gap &lt; size; gap *= 2)      //完成logN个层次的子数组的归并
	{
		for (int i = 0; i &lt; size; i += 2 * gap)  //i每次跳过一个归并序列组(每个序列组有两个子数组)
		{
			//对子数组[i,i+gap)和子数组[i+gap,i+2*gap)进行归并操作
		}
	}</code></pre> <p><span style="color:#0d0016;"><strong> 图解:</strong></span><img alt="" height="517" src="https://images2.imgbox.com/18/6b/4LL62XLl_o.png" width="1200"></p> <p></p> </li><li> <h4 id="%E5%88%9D%E6%AD%A5%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%3A"><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">初步</span>非递归归并排序函数:</strong></span></h4> <pre><code class="language-cpp">void MergeSortNonR(int* arr, int size)
{
	assert(arr);
	int* tem = (int*)malloc(sizeof(int) * size); //tem数组用于完成归并操作
	assert(tem);

	

	for (int gap = 1; gap &lt; size; gap *= 2)      //完成logN个层次的子数组的归并
	{
		int indextem = 0;						 //用于将数据归并到tem数组中的下标变量
		for (int i = 0; i &lt; size; i += 2 * gap)  //i每次跳过一个归并序列组(每个序列组有两个子数组)
		{
			//对子数组[i,i+gap)和子数组[i+gap,i+2*gap)进行归并操作
			int begin1 = i;                      //begin1和end1维护一个子数组
			int end1 = i + gap; 
			int begin2 = i + gap;				 //begin2和end2维护一个子数组
			int end2 = i + 2 * gap;

			while (begin1 &lt; end1 &amp;&amp; begin2 &lt; end2)
			{
				if (arr[begin1] &lt; arr[begin2])
				{
					tem[indextem] = arr[begin1];
					++indextem;
					++begin1;
				}
				else
				{
					tem[indextem] = arr[begin2];
					++indextem;
					++begin2;
				}
			}
			//将子数组[i, i + gap)或子数组[i + gap, i + 2 * gap)中未完成归并的元素完成归并
			while (begin1 &lt; end1)
			{
				tem[indextem] = arr[begin1];
				++indextem;
				++begin1;
			}
			while (begin2 &lt; end2)
			{
				tem[indextem] = arr[begin2];
				++indextem;
				++begin2;
			}

			//将完成归并的一组序列从tem数组中拷贝回arr数组中对应下标处
			for (int j = i; j &lt; end2; ++j)
			{
				arr[j] = tem[j];
			}
		}
	}

    free(tem);
}</code></pre> </li><li> <p><img alt="" height="1200" src="https://images2.imgbox.com/b1/25/SKyvW5wj_o.png" width="1112"></p> <p><span style="color:#0d0016;"><strong><span style="background-color:#a2e043;">两个子数组的归并操作</span>见前面的章节;</strong></span> </p> </li><li> <p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">初步</span><span style="background-color:#a2e043;">非递归归并排序函数</span><span style="background-color:#ffd900;">只能处理</span><span style="background-color:#a2e043;">元素个数为</span><img alt="2^{n}" class="mathcode" src="https://images2.imgbox.com/bf/cc/Aj0TKkDN_o.png">(即数组刚好<span style="background-color:#a2e043;">能被完全二分n次</span>)的数组</strong></span></p> </li><li> <p><span style="color:#0d0016;"><strong>想要使排序函数<span style="background-color:#ffd900;">能够处理</span><span style="background-color:#a2e043;">任意元素个数的数组</span>,我们就必须进行<span style="background-color:#ffd900;">算法边界条件分析</span>和<span style="background-color:#a2e043;">边界修正</span></strong></span></p> </li></ul> 
 <h4 id="%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B(%E6%89%80%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E4%B8%8D%E4%B8%BA%E2%80%8B%E7%BC%96%E8%BE%91)%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90%3A"><span style="color:#0d0016;"><strong>一般情况下(所排序数组元素个数不为<img alt="2^{n}" class="mathcode" src="https://images2.imgbox.com/16/d7/2rpM8STo_o.png">)边界条件分析:</strong></span></h4> 
 <ul><li><span style="color:#0d0016;"><strong>设<span style="background-color:#a2e043;">待排序数组的元素个数</span>为size</strong></span></li><li><span style="color:#0d0016;"><strong>函数中只有</strong></span><span style="color:#fe2c24;"><strong>下标end1,begin2,end2</strong></span><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">存在越界的可能</span>(函数中<span style="background-color:#a2e043;">begin1和end1</span>,<span style="background-color:#a2e043;">begin2和end2</span>分别用于维护<span style="background-color:#ffd900;">两个</span>在数组arr中<span style="background-color:#ffd900;">待归并的相邻子数组</span></strong></span><span style="color:#0d0016;"><strong>)</strong></span></li><li> <p></p> <p><span style="color:#0d0016;"><strong>当<span style="background-color:#ffd900;">所处理的数组元素个数</span>不为<img alt="2^{n}" class="mathcode" src="https://images2.imgbox.com/bc/76/Gdg4kt3c_o.png">时,可能会出现下图中<span style="background-color:#a2e043;">两种下标越界情况</span></strong></span></p> </li></ul> 
 <ol><li><strong><span style="color:#0d0016;">end1(end1==begin2)越界<span style="background-color:#a2e043;">(end1&gt;size)</span>(</span><span style="color:#fe2c24;">此时end2一定也越界</span><span style="color:#0d0016;">)</span></strong><img alt="" height="633" src="https://images2.imgbox.com/15/e5/zboyYDm3_o.png" width="1200"><strong>此时可以<span style="background-color:#ffd900;">直接break</span><span style="background-color:#a2e043;">终止i控制的循环</span>(end1&gt;size说明<span style="background-color:#a2e043;">arr数组</span><span style="color:#fe2c24;">按照gap划分后</span><span style="background-color:#ffd900;">尾部待归并区间数量只有一个</span>,无须进行归并操作)</strong></li><li> <p><span style="color:#0d0016;"><strong>end2越界<span style="background-color:#a2e043;">(end2&gt;size)</span>(</strong></span><span style="color:#fe2c24;"><strong>end1没越界即(end1&lt;size)</strong></span><span style="color:#0d0016;"><strong>)</strong></span></p> <p><img alt="" height="678" src="https://images2.imgbox.com/c1/28/7v7pNya8_o.png" width="1200"></p> <p><span style="color:#0d0016;"><strong>此时要<span style="background-color:#ffd900;">将end2修正为size</span>,后续便可以完成<span style="background-color:#a2e043;">arr数组(</span></strong></span><strong><span style="color:#fe2c24;">按照gap划分后</span></strong><span style="color:#0d0016;"><strong><span style="background-color:#a2e043;">)尾部剩余的两个子数组</span>的归并操作:</strong></span><img alt="" height="624" src="https://images2.imgbox.com/83/ae/bJy68Kww_o.png" width="1200"></p> </li></ol> 
 <h4 id="%E7%BB%8F%E8%BF%87%E8%BE%B9%E7%95%8C%E4%BF%AE%E6%AD%A3%E5%90%8E%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><strong>经过边界修正后的非递归归并排序函数</strong></span></h4> 
 <pre><code class="language-cpp">void MergeSortNonR(int* arr, int size)
{
	assert(arr);
	int* tem = (int*)malloc(sizeof(int) * size); //tem数组用于完成归并操作
	assert(tem);

	

	for (int gap = 1; gap &lt; size; gap *= 2)      //完成logN个层次的子数组的归并
	{
		int indextem = 0;						 //用于将数据归并到tem数组中的下标变量
		for (int i = 0; i &lt; size; i += 2 * gap)  //i每次跳过一个归并序列组
		{
			//对子数组[i,i+gap)和子数组[i+gap,i+2*gap)进行归并操作
			int begin1 = i;                      //begin1和end1维护一个子数组
			int end1 = i + gap; 
			int begin2 = i + gap;				 //begin2和end2维护一个子数组
			int end2 = i + 2 * gap;

			//进行边界修正防止越界,并且保证归并排序能完整进行
			if (end1 &gt; size)
			{
				break;                           //arr数组按照gap划分后尾部待归并区间数量只有一个,无须进行归并操作
			}
			if (end2 &gt; size)
			{
				end2 = size;                     //修正end2边界,以完成arr数组尾部剩余的两个子数组的归并操作
			}
			
			while (begin1 &lt; end1 &amp;&amp; begin2 &lt; end2)
			{
				if (arr[begin1] &lt; arr[begin2])
				{
					tem[indextem] = arr[begin1];
					++indextem;
					++begin1;
				}
				else
				{
					tem[indextem] = arr[begin2];
					++indextem;
					++begin2;
				}
			}
			//将子数组[i, i + gap)或子数组[i + gap, i + 2 * gap)中未完成归并的元素完成归并
			while (begin1 &lt; end1)
			{
				tem[indextem] = arr[begin1];
				++indextem;
				++begin1;
			}
			while (begin2 &lt; end2)
			{
				tem[indextem] = arr[begin2];
				++indextem;
				++begin2;
			}

			//将完成归并的一组序列从tem数组中拷贝回arr数组中对应下标处
			for (int j = i; j &lt; end2; ++j)
			{
				arr[j] = tem[j];
			}
		}
	}
	free(tem);
}</code></pre> 
 <h4><img alt="" height="1200" src="https://images2.imgbox.com/04/c6/BlI0fKSW_o.png" width="1200"></h4> 
 <p></p> 
 <h4 id="%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%B5%8B%3A"><span style="color:#0d0016;">排序实测:</span></h4> 
 <pre><code class="language-cpp">int main()
{
    //排序100万个数据
    srand(time(0));
	const int N = 1000000;
	int* a1 = (int*)malloc(sizeof(int) * N);
	for (int i = 0; i &lt; N; ++i)
	{
		a1[i] = rand();
	}

	int begin = clock();
	MergeSortNonR(a1,N);
	int end = clock();
	printf("MergeSortNonR:%d\n", end - begin);
	JudgeSort(a1, N); //判断序列是否有序的函数
	free(a1);
}</code></pre> 
 <p><img alt="" height="432" src="https://images2.imgbox.com/db/a2/j1LuOnH9_o.png" width="1200"></p> 
 <ul><li><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">非递归归并排序</span>和<span style="background-color:#a2e043;">递归归并排序</span>在<span style="background-color:#ffd900;">算法思想上没有任何区别</span>(只是<span style="background-color:#a2e043;">子数组归并的顺序</span>不同而已) 两者的<span style="background-color:#ffd900;">时间复杂度</span>都是O(NlogN),空间复杂度都是O(N)(算法中需要<span style="background-color:#ffd900;">开辟额外的数组tem</span>来完成<span style="background-color:#a2e043;">子序列两两归并操作</span>),但是<span style="background-color:#a2e043;">递归归并排序</span>有额外的<span style="background-color:#ffd900;">系统栈开销</span>.</strong></span></li></ul> 
 <p></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/07/43/VVfN6Xih_o.jpg"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ecb4aeb70f6b76d89bd491fd38129424/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux-编译工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/581346ab88d1b60a951f9e795a8d8e24/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何设计秒杀系统（二）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>