<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CAN总线基础知识（三） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/09ff780e8eff09371c51befe5aff63f1/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="CAN总线基础知识（三）">
  <meta property="og:description" content="1．CAN协议 1.1 帧类型 通讯时使用下面5个类型的帧：
数据帧
遥控帧
错误帧
过载帧
帧间空隙
在所有这些帧中，数据帧和遥控帧由用户设置，而其它帧则由CAN硬件设置。
数据和遥控帧有两种格式：标准和扩展格式。标准格式有11bit的ID，而扩展格式则是29bit的ID。
每个帧的用处见表6，每个帧的结构见图10到图14
表6 帧类型和每种类型帧的作用
2.2 数据帧 数据帧由发送单元使用，用来发送信息给接收单元，这是用户操作的基本帧。
数据帧有7个域组成。图15显示了数据帧的结构。
（1）帧开始（SOF）：这个域表示数据帧的开始。
（2）仲裁域：这个域表示一个帧的优先级
（3）控制域：这个域表示保留位和数据字节数
（4）数据域：这是数据内容，0-8个字节的数据能被发送
（5）CRC域：这个域用于检查帧的传输错误。
（6）ACK域：是对帧已经被正常接收的一个证实。
（7）帧结束：指示数据帧结束
（1）帧开始（SOF），对标准的或扩展的格式都是一样的。它指示一帧的开始，由1bit的显性位组成。
显性电平和隐性电平：
总线上的电平有显性电平和隐性电平两种。
总线上执行逻辑上的线“与”时，显性电平的逻辑值为“0”，隐性电平为“1”。
“显性”具有“优先”的意味，只要有一个单元输出显性电平，总线上即为显性电平，并且，“隐性”具有“包容”的意味，只有所有的单元都输出隐性电平，总线上才为隐性电平。（显性电平比隐性电平更强）
（2）仲裁域，这个域表示数据的优先级别。这个域的结构，对标准和扩展的格式是有差别的。
注1：关于ID：
标准格式的ID有11bit，从ID28到ID18被依次发送，禁止高7位全为隐性。（禁止设定：ID=1111111xxxx）。这样总共有（2048-16）个ID能被使用。
扩展格式的ID有29个bit。基本ID从ID28到ID18，扩展ID由ID17到ID0表示，基本ID和标准格式ID相同，禁止高7bit全都为隐性，（禁止设定：基本ID=1111111xxxx）。这样总共有（2048-16）个ID能被使用。
在任何情况下，总线上不可能有多个设备在同一时刻使用同一个ID传输数据帧。
（3）控制域，占6个bit，指示要传输信息的数据字节数，这个域的结构，对标准和扩展的格式是有差别的。如图18所示
注1：保留位（r0，r1），保留位必须以显性电平传送，然而，在接收侧可以接收显性、隐性集任意组合的电平。
注2：数据长度码（DLC），数据长度码与数据的字节对应关系见表7所示。数据的字节数必须是0-8个字节，但接收方对DLC=9-15的情况并不视为错误。
（4）数据域，对标准的或扩展的格式都是一样的。这个域是传输的数据，可以是0到8个字节，字节数载控制域中指明。数据输出开始于MSB。如图19所示：
（5）CRC域，对标准的或扩展的格式都是一样的。这个域用来检查帧是否有传输错误，它由15bit CRC码和一个bitCRC定界符（delimiter）（separating bit分隔bit）
CRC的产生方法是采用下面的多项式：，CRC的计算范围是SOF、仲裁域、控制域、数据域。在接收侧，会对接收到的数据帧的这些域进行CRC计算，如果计算结果与收到的CRC不一致，则表明存在传输错误。
（6）ACK域，是对一帧已被正常接收的一个确认信号，由2个bit组成，一个是ACK的slot，一个是ACK的定界符（delimiter），如图21所示：
注1：发送单元的ACK域，发送单元以隐性bit发送ACK slot和ACK 的delimiter。
注2：接收单元的ACK域，正确接收到信息的接收单元在接收帧的ACK slot里发送一个显性bit，以通知发送单元其已经正确接收完毕，这又称“sending ACK”或“returning ACK”。
“Returning an ACK”：
所有接收单元只要不是处于bus-off或休眠状态，只有正确接收信息的单元才能发送ACK。发送单元并不发送ACK。如果总线上除了发送单元，没有其它单元能接收信息，则No ACK被返回。为了通讯的建立，除了发送单元外，至少需要有一个单元能够接收信息。如果总线上有2个或更多个单元能接收到信息，如果它们中任意一个正常接收到信息，则会有ACK被返回。
（7）帧结束，指示一帧结束，由7个隐性位组成。如图22
1.3 遥控帧 遥控帧是接收单元请求发送单元发送一个信息，遥控帧有6个域组成。如图23显示的那样，除了没有数据域外其它与数据帧的结构是一样的。
(1) 帧开始（SOF）：这个域表示数据帧的开始。
(2) 竞争域：这个域表示数据的优先级，具有同样ID的数据帧被请求。
(3) 控制域：这个域表示保留位和数据字节数
(4) CRC域：这个域用于检查帧的传输错误。
(5) ACK域：是对帧已经被正常接收的一个证实。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2014-01-06T10:45:17+08:00">
    <meta property="article:modified_time" content="2014-01-06T10:45:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CAN总线基础知识（三）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><span style="font-size:18px">1．CAN协议</span></h3> 
<h4><span style="font-size:18px">1.1 帧类型</span></h4> 
<p><span style="font-size:18px">通讯时使用下面5个类型的帧：</span></p> 
<p><span style="font-size:18px">    数据帧</span></p> 
<p><span style="font-size:18px">    遥控帧</span></p> 
<p><span style="font-size:18px">    错误帧</span></p> 
<p><span style="font-size:18px">    过载帧</span></p> 
<p><span style="font-size:18px">    帧间空隙</span></p> 
<p><span style="font-size:18px">    在所有这些帧中，数据帧和遥控帧由用户设置，而其它帧则由CAN硬件设置。</span></p> 
<p><span style="font-size:18px">    数据和遥控帧有两种格式：标准和扩展格式。标准格式有11bit的ID，而扩展格式则是29bit的ID。</span></p> 
<p><span style="font-size:18px">    每个帧的用处见表6，每个帧的结构见图10到图14</span></p> 
<p style="text-align:center">表6 帧类型和每种类型帧的作用</p> 
<div style="text-align:center"> 
 <img src="https://images2.imgbox.com/3f/51/v1k4qgEQ_o.jpg" alt=""> 
</div> 
<div style="text-align:center"> 
 <img src="https://images2.imgbox.com/44/9d/1vsLEDFh_o.jpg" alt=""> 
 <br> 
</div> 
<div style="text-align:center"> 
 <img src="https://images2.imgbox.com/91/a5/vm3sR3Vf_o.jpg" alt=""> 
 <br> 
</div> 
<div style="text-align:center"> 
 <img src="https://images2.imgbox.com/94/cd/uzLA2TZL_o.jpg" alt=""> 
 <br> 
</div> 
<div style="text-align:center"> 
 <img src="https://images2.imgbox.com/64/2e/DFtONCYf_o.jpg" alt=""> 
 <br> 
</div> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h4><span style="font-size:18px">2.2 数据帧</span></h4> 
<p><span style="font-size:18px">数据帧由发送单元使用，用来发送信息给接收单元，这是用户操作的基本帧。</span></p> 
<p><span style="font-size:18px">数据帧有7个域组成。图15显示了数据帧的结构。</span></p> 
<p><span style="font-size:18px">（1）帧开始（SOF）：这个域表示数据帧的开始。</span></p> 
<p><span style="font-size:18px">（2）仲裁域：这个域表示一个帧的优先级</span></p> 
<p><span style="font-size:18px">（3）控制域：这个域表示保留位和数据字节数</span></p> 
<p><span style="font-size:18px">（4）数据域：这是数据内容，0-8个字节的数据能被发送</span></p> 
<p><span style="font-size:18px">（5）CRC域：这个域用于检查帧的传输错误。</span></p> 
<p><span style="font-size:18px">（6）ACK域：是对帧已经被正常接收的一个证实。</span></p> 
<p><span style="font-size:18px">（7）帧结束：指示数据帧结束</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/5f/d6/XAiC5GDW_o.jpg" alt=""><br> </span></p> 
<p> </p> 
<p></p> 
<p><span style="font-size:18px">（1）帧开始（SOF），对标准的或扩展的格式都是一样的。它指示一帧的开始，由1bit的显性位组成。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/62/c4/Jz7Mly59_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p><span style="font-size:18px">    显性电平和隐性电平：</span></p> 
<p><span style="font-size:18px">    总线上的电平有显性电平和隐性电平两种。</span></p> 
<p><span style="font-size:18px">    总线上执行逻辑上的线“与”时，显性电平的逻辑值为“0”，隐性电平为“1”。</span></p> 
<p><span style="font-size:18px">    “显性”具有“优先”的意味，只要有一个单元输出显性电平，总线上即为显性电平，并且，“隐性”具有“包容”的意味，只有所有的单元都输出隐性电平，总线上才为隐性电平。（显性电平比隐性电平更强）</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">（2）仲裁域，这个域表示数据的优先级别。这个域的结构，对标准和扩展的格式是有差别的。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/d3/37/PKZBR1JK_o.jpg" alt=""><br> </span></p> 
<p><span style="font-size:18px">注1：关于ID：</span></p> 
<p><span style="font-size:18px">    标准格式的ID有11bit，从ID28到ID18被依次发送，禁止高7位全为隐性。（禁止设定：ID=1111111xxxx）。这样总共有（2048-16）个ID能被使用。</span></p> 
<p><span style="font-size:18px">    扩展格式的ID有29个bit。基本ID从ID28到ID18，扩展ID由ID17到ID0表示，基本ID和标准格式ID相同，禁止高7bit全都为隐性，（禁止设定：基本ID=1111111xxxx）。这样总共有（2048-16）个ID能被使用。</span></p> 
<p><span style="font-size:18px">    在任何情况下，总线上不可能有多个设备在同一时刻使用同一个ID传输数据帧。</span></p> 
<p><span style="font-size:18px">（3）控制域，占6个bit，指示要传输信息的数据字节数，这个域的结构，对标准和扩展的格式是有差别的。如图18所示</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/85/c3/Vz8UBT9Q_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p><span style="font-size:18px">    注1：保留位（r0，r1），保留位必须以显性电平传送，然而，在接收侧可以接收显性、隐性集任意组合的电平。</span></p> 
<p><span style="font-size:18px">    注2：数据长度码（DLC），数据长度码与数据的字节对应关系见表7所示。数据的字节数必须是0-8个字节，但接收方对DLC=9-15的情况并不视为错误。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/10/37/F2gtw3F6_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p><span style="font-size:18px">（4）数据域，对标准的或扩展的格式都是一样的。这个域是传输的数据，可以是0到8个字节，字节数载控制域中指明。数据输出开始于MSB。如图19所示：</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/aa/fc/Ec1DnI3f_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p><span style="font-size:18px">（5）CRC域，对标准的或扩展的格式都是一样的。这个域用来检查帧是否有传输错误，它由15bit CRC码和一个bitCRC定界符（delimiter）（separating bit分隔bit）</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/e5/f8/ddpQToWW_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p><span style="font-size:18px">    CRC的产生方法是采用下面的多项式：，CRC的计算范围是SOF、仲裁域、控制域、数据域。在接收侧，会对接收到的数据帧的这些域进行CRC计算，如果计算结果与收到的CRC不一致，则表明存在传输错误。</span></p> 
<p><span style="font-size:18px">（6）ACK域，是对一帧已被正常接收的一个确认信号，由2个bit组成，一个是ACK的slot，一个是ACK的定界符（delimiter），如图21所示：</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/4a/4e/G7TXdB9G_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p><span style="font-size:18px">    注1：发送单元的ACK域，发送单元以隐性bit发送ACK slot和ACK 的delimiter。</span></p> 
<p><span style="font-size:18px">    注2：接收单元的ACK域，正确接收到信息的接收单元在接收帧的ACK slot里发送一个显性bit，以通知发送单元其已经正确接收完毕，这又称“sending ACK”或“returning ACK”。</span></p> 
<p><span style="font-size:18px">“Returning an ACK”：</span></p> 
<p><span style="font-size:18px">    所有接收单元只要不是处于bus-off或休眠状态，只有正确接收信息的单元才能发送ACK。发送单元并不发送ACK。如果总线上除了发送单元，没有其它单元能接收信息，则No ACK被返回。为了通讯的建立，除了发送单元外，至少需要有一个单元能够接收信息。如果总线上有2个或更多个单元能接收到信息，如果它们中任意一个正常接收到信息，则会有ACK被返回。</span></p> 
<p><span style="font-size:18px">（7）帧结束，指示一帧结束，由7个隐性位组成。如图22</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/20/43/PgclHBU0_o.jpg" alt=""><br> </span></p> 
<p style="text-align:center"><span style="font-size:18px"><br> </span></p> 
<p></p> 
<h4><span style="font-size:18px">1.3 遥控帧</span></h4> 
<p><span style="font-size:18px">    遥控帧是接收单元请求发送单元发送一个信息，遥控帧有6个域组成。如图23显示的那样，除了没有数据域外其它与数据帧的结构是一样的。</span></p> 
<p><span style="font-size:18px">(1) 帧开始（SOF）：这个域表示数据帧的开始。</span></p> 
<p><span style="font-size:18px">(2) 竞争域：这个域表示数据的优先级，具有同样ID的数据帧被请求。</span></p> 
<p><span style="font-size:18px">(3) 控制域：这个域表示保留位和数据字节数</span></p> 
<p><span style="font-size:18px">(4) CRC域：这个域用于检查帧的传输错误。</span></p> 
<p><span style="font-size:18px">(5) ACK域：是对帧已经被正常接收的一个证实。</span></p> 
<p><span style="font-size:18px">(6) 帧结束：指示遥控帧的结束</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/27/91/yESglh27_o.jpg" alt=""><br> </span></p> 
<p> </p> 
<p></p> 
<p><span style="font-size:18px">遥控帧和数据帧：</span></p> 
<p></p> 
<ul><li><span style="font-size:18px">数据帧和遥控帧之间的不同</span></li></ul> 
<p></p> 
<p></p> 
<ol><li><span style="font-size:18px">遥控帧没有数据域，在仲裁域里的RTR位是隐性电平，而数据帧RTR则为显性的。</span></li><li><span style="font-size:18px">没有数据的数据帧与遥控帧可以通过RTR为来区分</span></li></ol> 
<p></p> 
<p></p> 
<ul><li><span style="font-size:18px">遥控帧没有数据域，其数据长度码用来干什么？</span></li></ul> 
<p></p> 
<p></p> 
<ol><li><span style="font-size:18px">遥控帧的数据长度码的值表示对应请求的数据帧的数据长度码。</span></li></ol> 
<p></p> 
<p></p> 
<ul><li><span style="font-size:18px">没有数据域的数据帧用来干什么？</span></li></ul> 
<p></p> 
<p></p> 
<ol><li><span style="font-size:18px">例如，数据帧可以被各单元用来作为周期连接确认/应答，或者仲裁域本身带有实质性信息。</span></li></ol> 
<p></p> 
<h4><span style="font-size:18px">1.4 错误帧</span></h4> 
<p><span style="font-size:18px">    这个帧用来通知在传输期间发生了一个错误，错误帧由一个错误标志和一个错误定界符组成，错误帧由CAN的硬件来发送。图24显示了错误帧的结构。</span></p> 
<p><span style="font-size:18px">     (1) 错误标志：有2种错误标志类型：主动错误和被动错误标志</span></p> 
<p><span style="font-size:18px">      a)主动错误标志：6个显性位</span></p> 
<p><span style="font-size:18px">      b) 被动错误标志：6个隐性位</span></p> 
<p><span style="font-size:18px">     (2) 错误定界符：由8个隐性位组成。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/64/f3/GzO3VNKk_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p><span style="font-size:18px">    注1：错误标志重叠：取决于连接到总线上的各单元检测出错误的时间，错误标志可能一个重叠在另一个上，总共可达12bit长度。</span></p> 
<p><span style="font-size:18px">    注2：主动错误标志：处于主动错误状态的单元检测出错误时输出的错误标志。</span></p> 
<p><span style="font-size:18px">    注3：被动错误标志：处于被动错误状态的单元检测出错误时输出的错误标志。</span></p> 
<h4><span style="font-size:18px">1.5 过载帧</span></h4> 
<p><span style="font-size:18px">    这个帧被接收单元用来通知还没有准备好接收帧。它由一个过载标志和一个过载定界符组成。图25显示了错误帧的结构。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/96/29/TKzaDusA_o.jpg" alt=""><br> </span></p> 
<p><span style="font-size:18px">    (1) 过载标志：由6个显性位组成，过载标志与错误帧的主动错误标志具有相同的结构。</span></p> 
<p><span style="font-size:18px">    (2) 过载定界符：由8个隐性位组成，过载定界符与错误帧的错误定界符具有相同的结构。</span></p> 
<p align="center"></p> 
<p><span style="font-size:18px">    注1：错误标志重叠：向错误标志一样，取决于时间，过载标志可能一个重叠在另一个上，总共可达12bit长度。</span></p> 
<h4><span style="font-size:18px">1.6 帧间间隔</span></h4> 
<p><span style="font-size:18px">    这个帧用来隔开数据帧和遥控帧。数据和遥控帧可通过插入帧间间隔与前面传输的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。</span></p> 
<p><span style="font-size:18px">过载帧和错误帧前不能插入帧间间隔。如图26所示。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/8c/68/ud9kNrl5_o.jpg" alt=""><br> </span></p> 
<p align="center"></p> 
<p><span style="font-size:18px">（1）间隔：由3个隐性位组成。在间隔期间如果检测到显性电平，则必须发送过载帧，然而，如果间隔的第3bit是显性电平，间隔被认为是SOF</span></p> 
<p><span style="font-size:18px">（2）总线空闲：是隐性电平，长度没有限制（它可以是0bit长）。当总线处于这种状态的时候，总线被认为是自由空闲的，任何单元都可以启动发送信息。</span></p> 
<p><span style="font-size:18px">（3）暂停传输（传输暂停期）：有8个隐性位组成。只在处于被动错误状态的单元刚发送一个消息后的帧间隔中包含的段。</span></p> 
<h4><span style="font-size:18px">1.7 优先级的决定</span></h4> 
<p><span style="font-size:18px">    在总线空闲状态，最先开始发送消息的单元获得发送权。</span></p> 
<p><span style="font-size:18px">    多个单元同时开始发送时，各发送单元从仲裁域的第一位开始进行仲裁。连续输出显性电平最多的单元可继续发送。丢失竞争的单元在下一bit进入接收操作。</span></p> 
<p><span style="font-size:18px">    仲裁的过程如图27所示。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/4a/92/LbO5gsvE_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p><span style="font-size:18px">    (1)数据帧和遥控帧的优先级</span></p> 
<p><span style="font-size:18px">    具有相同 ID 的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权，可继续发送。</span></p> 
<p><span style="font-size:18px">    数据帧和遥控帧的仲裁过程如图28所示。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/0c/b4/2MbrbIY5_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p><span style="font-size:18px">(2)标准格式和扩展格式的优先级</span></p> 
<p><span style="font-size:18px">    标准格式 ID 与具有相同ID 的遥控帧或者扩展格式的数据帧在总线上竞争时，标准格式的RTR 位为显性位的具有优先权，可继续发送。</span></p> 
<p><span style="font-size:18px">    标准格式和扩展格式的仲裁过程如图29所示。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/a0/ad/FZwpC4Pt_o.jpg" alt=""></span></p> 
<h4><span style="font-size:18px">1.8 位填充</span></h4> 
<p><span style="font-size:18px">    位填充是一种周期性重同步收/发操作的功能，为了防止接收节点间时序由于累积而导致的错误，如果5个bit持续了同样的电平，则添加1个bit的反向数据位。</span></p> 
<p><span style="font-size:18px">    如图30显示的位填充机制：</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/4c/fa/U8t2MeOo_o.jpg" alt=""><br> </span></p> 
<p align="center"></p> 
<p><span style="font-size:18px">（1）发送单元的操作</span></p> 
<p><span style="font-size:18px">    在发送数据帧和遥控帧的时候，SOF-CRC段间的数据，相同电平如果持续5bit，在下一bit（第6bit）则要插入1bit与前5bit反向的电平。</span></p> 
<p><span style="font-size:18px">（2）接收单元的操作</span></p> 
<p><span style="font-size:18px">    在接收数据帧和遥控帧的时候，SOF-CRC段间的数据，相同电平如果持续5bit，需要删除下一bit（第6bit）再接收。如果这第6bit的电平与前5bit相同，则被视为错误，且发送错误帧。</span></p> 
<h4><span style="font-size:18px">1.9 错误的种类</span></h4> 
<p><span style="font-size:18px">    有5种类型的错误，可能有2个或更多的错误同时发生：</span></p> 
<p></p> 
<ul><li><span style="font-size:18px">位错误</span></li><li><span style="font-size:18px">填充错误</span></li><li><span style="font-size:18px">CRC错误</span></li><li><span style="font-size:18px">格式错误</span></li><li><span style="font-size:18px">ACK错误</span></li></ul> 
<p></p> 
<p><span style="font-size:18px">    表8列出了这些错误的种类、内容、错误检测帧和检测单元。</span></p> 
<div style="text-align:center"> 
 <img src="https://images2.imgbox.com/48/15/6qQjnCFr_o.jpg" alt=""> 
</div> 
<p></p> 
<ul><li><span style="font-size:18px">位错误由向总线上输出数据帧、遥控帧、错误帧、过载帧的单元和输出ACK的单元、输出错误的单元来检测。</span></li><li><span style="font-size:18px">在仲裁段输出隐性电平，但检测出显性电平时，将被视为仲裁失利，而不是位错误。</span></li><li><span style="font-size:18px">在仲裁段作为填充位输出隐性电平时，但检测出显性电平时，将不视为位错误，而是填充错误。</span></li><li><span style="font-size:18px">发送单元在ACK 段输出隐性电平，但检测到显性电平时，将被判断为其它单元的ACK 应答，而非位错误。</span></li><li><span style="font-size:18px">输出被动错误标志（6 个位隐性位）但检测出显性电平时，将遵从错误标志的结束条件，等待检测出连续相同6 个位的值（显性或隐性），并不视为位错误。</span></li></ul> 
<p></p> 
<p><span style="font-size:18px">(2) 格式错误</span></p> 
<p></p> 
<ul><li><span style="font-size:18px">即使接收单元检测出EOF（7 个位的隐性位）的最后一位（第8 个位）为显性电平，也不视为格式错误。</span></li><li><span style="font-size:18px">即使接收单元检测出数据长度码（DLC）中9∼15 的值时，也不视为格式错误。</span></li></ul> 
<p></p> 
<h4><span style="font-size:18px">1.10 错误帧的输出时序</span></h4> 
<p><span style="font-size:18px">    检测到发生错误的单元输出一个错误标志，以通知其它单元。</span></p> 
<p><span style="font-size:18px">    处于主动错误状态的单元输出的错误标志为主动错误标志；处于被动错误状态的单元输出的错误标志为被动错误标志。</span></p> 
<p><span style="font-size:18px">    发送单元发送完错误帧之后，将再次发送数据帧或遥控帧。</span></p> 
<p><span style="font-size:18px">    错误标志输出时序如表9：</span></p> 
<div style="text-align:center"> 
 <img src="https://images2.imgbox.com/8d/94/sOtdSHXk_o.jpg" alt=""> 
</div> 
<h4><span style="font-size:18px">1.11 位时序</span></h4> 
<p><span style="font-size:18px">    在没有重新同步情况下，发送单元每秒传输的位数称之为位速率。1位由下面4个段组成。</span></p> 
<p></p> 
<ul><li><span style="font-size:18px">同步段（SS）</span></li><li><span style="font-size:18px">传播时间段（PTS）</span></li><li><span style="font-size:18px">相位缓冲段1（PBS1）</span></li><li><span style="font-size:18px">相位缓冲段2（PBS2）</span></li></ul> 
<p></p> 
<p><span style="font-size:18px">    这些段又由称之为Time Quantum（以下称为Tq）的最小时间单位构成。</span></p> 
<p><span style="font-size:18px">    1位分为4个段，每个段由若干个Tq构成，这称为位时序。</span></p> 
<p><span style="font-size:18px">    1位由多少个Tq构成、每个段由多少个Tq构成等是可以设定的。通过设置bit时序。使得可以设定一个采样点以使总线上多个单元可同时采样，所谓采样点就是在这一时刻总线上的电平被锁存，这个锁存的电平作为位的值。采样点的位置在PBS1的结束处。</span></p> 
<p><span style="font-size:18px">    表10描述了各段的作用和Tq 数。1个位的构成如图31所示。</span></p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p>段名称</p> </td><td> <p>段的作用</p> </td><td width="107" colspan="2"> <p>Tq数</p> </td></tr><tr><td> <p>同步段（SS）</p> </td><td> <p>多个连接在总线上的单元通过此段实现时序的定时调整，以便同步进行接收和发送的工作。</p> <p>隐性电平到显性电平或显性电平到隐性电平变化的边沿被期望出现在本段。</p> </td><td> <p>1</p> </td><td rowspan="4"> <p>8-25</p> </td></tr><tr><td> <p>传播时间段（PTS）</p> </td><td> <p>用于吸收网络上的物理延迟的段。包括发送单元的输出延迟、总线上信号的传播延迟、接收单元的输入延迟。</p> <p>这个段的时间是以上延迟时间累加和的两倍。</p> </td><td> <p>1-8</p> </td></tr><tr><td> <p>相位缓冲段1（PBS1）</p> </td><td rowspan="2"> <p>当信号边沿不能出现在SS 段时，此段用来矫正误差。</p> <p>由于各单元以各自独立的时钟来工作，细微的时钟误差都会累积起来，PBS 段可用于吸收此误差。</p> <p>为了吸收一个时钟误差，在SJW设置的范围内增减PBS1和PBS2，PBS1和PBS2越大，允许误差越大，但是通讯速度会降低。</p> </td><td> <p>1-8</p> </td></tr><tr><td> <p>相位缓冲段2（PBS2）</p> </td><td> <p>PBS1或IPT中较大者（见注1和2）</p> </td></tr><tr><td> <p>重新同步跳转宽度（SJW）</p> </td><td> <p>因时钟频率偏差、传送延迟等原因，某些单元可能会失去同步。SJW是所能校正的最大失去同步的宽度。</p> </td><td width="107" colspan="2"> <p>1-4*PBS1</p> </td></tr></tbody></table> 
<p><span style="font-size:18px">    注1：IPT代表信息处理时间，是以采样点作为起始的时间段，用于计算后续位的位电平。这是硬件在一个采样点后立刻改变位的电平所必须要的。这个时间等于或小于2Tq，。</span></p> 
<p><span style="font-size:18px">    注2：因为采样点是处于PBS1结束处，所以IPT和PBS2重叠。当IPT = 2Tq时，PBS2不可能选为1，因此，PBS2必须是2到8Tq。</span></p> 
<p><span style="font-size:18px">    注3：重新同步的结果使相位缓冲段1增长，或使相位缓冲段2 缩短。相位缓冲段加长或缩短的数量有一个上限，此上限由SJW（重新同步跳转宽度）给定。重新同步跳转宽度应设置于1和最小值之间（此最小值为4*PBS1）。</span></p> 
<p><span style="font-size:18px">    可以从一位值转换到另一位值的过渡过程得到时钟信息。这里有一个属性，即：只有后续位的一固定最大数值才具有相同的数值。这个属性使总线单元在帧期间重新同步于位流成为可能。可用于重新同步的两个过渡过程之间的最大的长度为29个位时间。</span></p> 
<p align="center"><img src="https://images2.imgbox.com/22/f3/nkXVo0oL_o.jpg" alt=""></p> 
<p> </p> 
<h4><span style="font-size:18px">1.12 同步是如何获得的？</span></h4> 
<p><span style="font-size:18px">    CAN总线的通讯是采用NRZ（Non-Return to Zero，非归0）码，数据本身并不携带时钟信息，也即在每一位的开始或结束没有同步信号，发送单元以位时序同步的方式开始发送帧数据，接收单元根据总线电平的变化进行同步并进行接收工作。</span></p> 
<p><span style="font-size:18px">    然而，发送器和接收器之间由于彼此的时钟误差或传输路径的相位误差可能会失去同步关系，因此接收单元在接收帧的时候，必须通过硬件同步或重新同步调整它的操作时序。</span></p> 
<h4><span style="font-size:18px">1.13 硬件同步</span></h4> 
<p><span style="font-size:18px">    在总线空闲状态时，接收单元检测到SOF，就会执行这个同步调整过程。“隐式”电平跳变到“显式”电平的边缘的时间点被认为是SS，而不管SJW的值</span></p> 
<p><span style="font-size:18px">    图32显示了硬件同步机制。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/1c/57/8TFgdeVr_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p></p> 
<ul><li><span style="font-size:18px">如果沿出现在SS里，沿的相位误差e=0；</span></li><li><span style="font-size:18px">如果沿位于采集点（PBS1结束之前）之前，e&gt;0；</span></li><li><span style="font-size:18px">如果沿位于采集点之后，e&lt;0；</span></li></ul> 
<p></p> 
<h4><span style="font-size:18px">1.14 重新同步机制</span></h4> 
<p><span style="font-size:18px">    在接收过程中检测到总线电平发生了改变时执行重新同步操作。</span></p> 
<p><span style="font-size:18px">    每当检测到一个边沿（总线电平的改变），收发单元根据SJW值通过增加PBS1段或减少PBS2段，来调整同步。但，如果发生了超出SJW值的误差时，最大调整量不能超过SJW值。</span></p> 
<p><span style="font-size:18px">    图33显示了重新同步机制。</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/d9/a9/1t34tKVS_o.jpg" alt=""><br> </span></p> 
<p></p> 
<p style="text-align:left"><span style="font-size:18px">1.15 调整同步的规则</span></p> 
<p style="text-align:left"><span style="font-size:18px">    硬件同步和再同步的执行遵从如下规则：</span></p> 
<p style="text-align:left"><span style="font-size:18px">    1) 在1个位时间里（或者说在2个采样点之间），只允许一个同步（或者说只进行一次同步调整）。</span></p> 
<p style="text-align:left"><span style="font-size:18px">    2) 只有当采样点之前的总线电平和边沿后的总线电平不同时，该边沿才能用于调整同步。</span></p> 
<p style="text-align:left"><span style="font-size:18px">    3) 如果出现隐性电平到显性电平变化的边沿，且条件（1）和（2）满足，将进行同步。</span></p> 
<p style="text-align:left"><span style="font-size:18px">    4) 如果在帧间间隙期间发生隐性电平到显性电平的信号边沿（除了间隙里的第一位），则总会执行硬件同步。</span></p> 
<p style="text-align:left"><span style="font-size:18px">    5) 如果发生从所有其它隐性电平到显性电平的信号边沿，则执行再同步。</span></p> 
<p style="text-align:left"><span style="font-size:18px">    6) 如果发送单元自身输出的显性电平被检测到有延迟，则不执行再同步。</span></p> 
<p style="text-align:left"><span style="font-size:18px"> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1edb53eb61d2db55e41bd01bd16a025/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">论文写作之不二法则</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e3dfecfa0792741793e342bd4874d96/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人脸数据库汇总</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>