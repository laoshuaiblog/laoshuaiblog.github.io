<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue中computed、methods和watch之间的区别 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/527fe9713ee306434d0ba9c15b2b5bcf/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Vue中computed、methods和watch之间的区别">
  <meta property="og:description" content="对于那些开始学习Vue的人来说，对于方法、计算属性和观察者之间的区别有点混淆。
尽管通常可以使用它们中的每一个来完成或多或少相同的事情，但了解每个人在哪里胜过其他人还是很重要的。
在这个快速提示中，我们将了解Vue应用程序的这三个重要方面及其用例。我们将通过使用这三种方法中的每一种构建相同的搜索组件来实现这一点。
Methods
在一个方法中，或多或少是您所期望的——一个对象属性的函数。您可以使用方法对发生在DOM中的事件作出反应，或者可以从组件中的其他位置调用它们，例如，从计算属性或观察者中调用它们。方法用于对公共功能进行分组-例如，处理表单提交，或构建可重用的功能，如发出Ajax请求。
在Vue实例中的methods对象内创建方法：
new Vue({ el: &#34;#app&#34;, methods: { handleSubmit() {} } }) 当您想在模板中使用它时，您可以这样做：
&amp;lt;div id=&#34;app&#34;&amp;gt; &amp;lt;button @click=&#34;handleSubmit&#34;&amp;gt; Submit &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; 我们使用v-on指令将事件处理程序附加到dom元素，该元素也可以缩写为@符号。
现在，每次单击按钮时都会调用handleSubmit方法。对于要传递方法体中需要的参数的实例，可以执行以下操作：
&amp;lt;div id=&#34;app&#34;&amp;gt; &amp;lt;button @click=&#34;handleSubmit(event)&#34;&amp;gt; Submit &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; 这里我们传递一个事件对象，例如，它允许我们在表单提交的情况下阻止浏览器的默认操作。
但是，当我们使用一个指令来附加事件时，我们可以使用一个修饰符来更优雅地实现相同的事情：@click.stop=“handleSubmit”。
现在我们来看一个使用方法过滤数组中数据列表的示例。
In the demo, we want to render a list of data and a search box. The data rendered changes whenever a user enters a value in the search box. The template will look like this:">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-04-09T11:21:01+08:00">
    <meta property="article:modified_time" content="2019-04-09T11:21:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue中computed、methods和watch之间的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>对于那些开始学习Vue的人来说，对于方法、计算属性和观察者之间的区别有点混淆。</p> 
<p>尽管通常可以使用它们中的每一个来完成或多或少相同的事情，但了解每个人在哪里胜过其他人还是很重要的。</p> 
<p>在这个快速提示中，我们将了解Vue应用程序的这三个重要方面及其用例。我们将通过使用这三种方法中的每一种构建相同的搜索组件来实现这一点。</p> 
<p><strong>Methods</strong><br> 在一个方法中，或多或少是您所期望的——一个对象属性的函数。您可以使用方法对发生在DOM中的事件作出反应，或者可以从组件中的其他位置调用它们，例如，从计算属性或观察者中调用它们。方法用于对公共功能进行分组-例如，处理表单提交，或构建可重用的功能，如发出Ajax请求。</p> 
<p>在Vue实例中的methods对象内创建方法：</p> 
<pre><code>new Vue({
  el: "#app",
  methods: {
    handleSubmit() {}
  }
})
</code></pre> 
<p>当您想在模板中使用它时，您可以这样做：</p> 
<pre><code>&lt;div id="app"&gt;
  &lt;button @click="handleSubmit"&gt;
    Submit
  &lt;/button&gt;
&lt;/div&gt;
</code></pre> 
<p>我们使用v-on指令将事件处理程序附加到dom元素，该元素也可以缩写为@符号。<br> 现在，每次单击按钮时都会调用handleSubmit方法。对于要传递方法体中需要的参数的实例，可以执行以下操作：</p> 
<pre><code>&lt;div id="app"&gt;
  &lt;button @click="handleSubmit(event)"&gt;
    Submit
  &lt;/button&gt;
&lt;/div&gt;
</code></pre> 
<p>这里我们传递一个事件对象，例如，它允许我们在表单提交的情况下阻止浏览器的默认操作。</p> 
<p>但是，当我们使用一个指令来附加事件时，我们可以使用一个修饰符来更优雅地实现相同的事情：@click.stop=“handleSubmit”。</p> 
<p>现在我们来看一个使用方法过滤数组中数据列表的示例。</p> 
<p>In the demo, we want to render a list of data and a search box. The data rendered changes whenever a user enters a value in the search box. The template will look like this:<br> 在演示中，我们要呈现一个数据列表和一个搜索框。每当用户在搜索框中输入值时，所呈现的数据都会发生更改。模板将如下所示：</p> 
<pre><code>&lt;div id="app"&gt;
  &lt;h2&gt;Language Search&lt;/h2&gt;

  &lt;div class="form-group"&gt;
    &lt;input
      type="text"
      v-model="input"
      @keyup="handleSearch"
      placeholder="Enter language"
      class="form-control"
    /&gt;
  &lt;/div&gt;

  &lt;ul v-for="(item, index) in languages" class="list-group"&gt;
    &lt;li class="list-group-item" :key="item"&gt;{<!-- -->{ item }}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre> 
<p>如您所见，我们引用的是handlesearch方法，每次用户在搜索字段中键入内容时都会调用该方法。我们需要创建方法和数据：</p> 
<pre><code>new Vue({
  el: '#app',
  data() {
    return {
      input: '',
      languages: []
    }
  },
  methods: {
    handleSearch() {
      this.languages = [
        'JavaScript',
        'Ruby',
        'Scala',
        'Python',
        'Java',
        'Kotlin',
        'Elixir'
      ].filter(item =&gt; item.toLowerCase().includes(this.input.toLowerCase()))
    }
  },
  created() { this.handleSearch() }
})
</code></pre> 
<p>handlesearch方法使用输入字段的值更新列出的项。需要注意的一点是，在methods对象中，不需要使用this.handlesearch引用该方法（正如在react中必须做的那样）</p> 
<p><strong>Computed Properties</strong></p> 
<p>虽然上面示例中的搜索可以按预期工作，但更优雅的解决方案是使用计算属性。计算属性对于从现有源组合新数据非常方便，与方法相比，它们的一大优点是缓存了输出。这意味着，如果独立于计算属性的某些内容在页面上发生更改，并且重新呈现UI，则会返回缓存的结果，并且不会重新计算计算计算属性，从而避免了可能代价高昂的操作。</p> 
<p>计算属性使我们能够使用我们可用的数据进行即时计算。在本例中，我们有一个需要排序的项目数组。我们希望在用户在输入字段中输入值时进行排序。</p> 
<p>我们的模板看起来几乎与前面的迭代相同，除了我们正在传递v-for指令一个计算属性（filteredlist）：</p> 
<pre><code>&lt;div id="app"&gt;
  &lt;h2&gt;Language Search&lt;/h2&gt;

  &lt;div class="form-group"&gt;
    &lt;input
      type="text"
      v-model="input"
      placeholder="Enter language"
      class="form-control"
    /&gt;
  &lt;/div&gt;

  &lt;ul v-for="(item, index) in filteredList" class="list-group"&gt;
    &lt;li class="list-group-item" :key="item"&gt;{<!-- -->{ item }}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
  
</code></pre> 
<p>脚本部分略有不同。我们声明了数据属性中的语言（以前这是一个空数组），而不是方法，我们将逻辑移入了计算属性：</p> 
<pre><code>new Vue({
  el: "#app",
  data() {
    return {
      input: '',
      languages: [
        "JavaScript",
        "Ruby",
        "Scala",
        "Python",
        "Java",
        "Kotlin",
        "Elixir"
      ]
    }
  },
  computed: {
    filteredList() {
      return this.languages.filter((item) =&gt; {
        return item.toLowerCase().includes(this.input.toLowerCase())
      })
    }
  }
})
</code></pre> 
<p>filteredList计算属性将包含包含输入字段值的项数组。在第一次渲染时（当输入字段为空时），将渲染整个数组。当用户在字段中输入值时，filteredList将返回一个数组，其中包含输入到字段中的值。</p> 
<p>使用计算属性时，要计算的数据必须可用，否则将导致应用程序出错</p> 
<p>computed属性创建了一个新的filteredlist属性，这就是为什么我们可以在模板中引用它。每次依赖项执行此操作时，filteredlist的值都会更改。这里容易改变的依赖项是输入值。</p> 
<p>最后，请注意，计算属性允许我们在模板中创建一个变量，该变量是由一个或多个数据属性构建的。一个常见的例子是从这样一个用户的名字和姓氏创建一个全名：</p> 
<pre><code>computed: {
  fullName() {
    return `${this.firstName} ${this.lastName}`
  }
}
</code></pre> 
<p>在模板中，您可以执行全名。每当名字或姓氏的值更改时，全名的值将更改。</p> 
<p><strong>Watchers</strong><br> Watchers对于希望响应已发生的更改（例如，属性或数据属性）执行操作的情况非常有用。正如Vue文档所提到的，当您想要执行异步或昂贵的操作以响应不断变化的数据时，这是最有用的。</p> 
<p>在搜索示例中，我们可以返回到方法示例，并为输入数据属性设置一个观察程序。然后我们可以对输入值的任何变化作出反应。</p> 
<p>首先，让我们恢复模板以使用语言数据属性：</p> 
<pre><code>&lt;div id="app"&gt;
  &lt;h2&gt;Language Search&lt;/h2&gt;

  &lt;div class="form-group"&gt;
    &lt;input
      type="text"
      v-model="input"
      placeholder="Enter language"
      class="form-control"
    /&gt;
  &lt;/div&gt;

  &lt;ul v-for="(item, index) in languages" class="list-group"&gt;
    &lt;li class="list-group-item" :key="item"&gt;{<!-- -->{ item }}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre> 
<p>然后我们的Vue实例将如下所示：</p> 
<pre><code>new Vue({
  el: "#app",
  data() {
    return {
      input: '',
      languages: []
    }
  },
  watch: {
    input: {
      handler() {
        this.languages = [
          'JavaScript',
          'Ruby',
          'Scala',
          'Python',
          'Java',
          'Kotlin',
          'Elixir'
        ].filter(item =&gt; item.toLowerCase().includes(this.input.toLowerCase()))
      },
      immediate: true
    }
  }
})
</code></pre> 
<p>这里，我将观察者设置为一个对象（而不是一个函数）。这是为了我可以指定一个即时属性，它将导致观察程序在组件被装载后立即触发。这会产生填充列表的效果。然后运行的函数在handler属性中。</p> 
<p><strong>总结：</strong><br> 正如他们所说，拥有强大的力量，责任重大。Vue为您提供了构建伟大应用程序所需的超级能力。知道何时使用它们是构建用户喜爱的内容的关键。方法、计算属性和观察者是您可用的超级能力的一部分。往前走，一定要好好利用它们！</p> 
<p>原文地址：<a href="https://www.sitepoint.com/the-difference-between-computed-properties-methods-and-watchers-in-vue/" rel="nofollow">https://www.sitepoint.com/the-difference-between-computed-properties-methods-and-watchers-in-vue/</a><a href="https://www.sitepoint.com/the-difference-between-computed-properties-methods-and-watchers-in-vue/" rel="nofollow">添加链接描述</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/380940c73f080cdd5ee1eff1071120e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IDEA中的lombok失效的解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/662810d0ce97615ce70c6fa82cc78502/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">通过IDEA将项目git到coding上</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>