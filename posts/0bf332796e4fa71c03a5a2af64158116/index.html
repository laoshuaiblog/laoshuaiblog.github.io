<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring全家桶相关注解总结 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/0bf332796e4fa71c03a5a2af64158116/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="Spring全家桶相关注解总结">
  <meta property="og:description" content="spring相关 @Controller 【控制器】效验有效参数的合法性（相当于安检系统）
@Service 【服务】业务组装（客服中心）
@Repository 【数据持久层】实际业务处理（实际办理的业务）
@Component 【组件】工具类层（基础的工具）
@Configuration 【配置层】配置
上面四个注解功能是一样的，都可以用来创建bean实例
2.注入，装配 （1）@Autowired： 根据属性类型进行自动装配，默认按类型装配（byType）自动装配
作用于：标注 引用类型的构造器，方法，方法参数，注解 （2）@Resource： 可以根据类型注入，可以根据名称注入（byName），标注 类，字段，方法：
（3）@Qualifier： 根据名称进行注入，这个@Qualifier注解的使用，和上面@Autowired一起使用，
如果有多个类型一样的Bean候选者，则需要限定其中一个候选者
（4）@Value：注入普通类型属性 注解在属性上，单个注入
支持 SpEL
从配置文件读取值
@Value(&#34;${property}&#34;)
@Value(&#34;${property:默认值}&#34;)SpEL
@Value(“#{SpEL表达式}”) @ConfigurationProperties 通过指定的前缀，绑定配置文件中的配置
可以注解在类上，也可以放在@Bean的方法上。批量注入配置文件中的属性
一般用于多个数据源的配置，读写分离
@PropertySource 加载指定的配置文件
@ImportResource 标注在一个配置类,导入Spring的配置文件让其生效
Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别。
需要用@ImportResource加载生效
3.完全注解开发 创建配置类，替代xml配置文件
@Configuration ： 作为配置类，替代xml配置文件
@ComponentScan(basePackages = {“包名”})： 开启注解扫描
4.在增强类上面添加注解 @Aspect，可与@Component注解一起使用生成代理对象
5.AOP相关 在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置
（1）@Before：表示作为前置通知
（2）@After：最终通知
（3）@AfterReturning：后置通知（返回通知）
（4）@AfterThrowing：异常通知
（5）@Around：环绕通知
（6）@Pointcut：用于相同的切入点抽取
6.bean的生命周期 @Scope(&#34;作用域&#34;)作用范围设置
@PostConstruct初始化 Java自己的注解
@PreDestroy销毁 7.SpringMVC @Component的衍生注解
@Controller 标注类 : 对应 Spring MVC 控制层Controller对象，主要用于接受用户请求并调用 Service 层返回数据给前端页面。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-09T08:52:13+08:00">
    <meta property="article:modified_time" content="2023-09-09T08:52:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring全家桶相关注解总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>spring相关</h2> 
<h3>@Controller</h3> 
<p>【控制器】效验有效参数的合法性（相当于安检系统）</p> 
<h3>@Service</h3> 
<p>【服务】业务组装（客服中心）</p> 
<h3>@Repository</h3> 
<p>【数据持久层】实际业务处理（实际办理的业务）</p> 
<h3 style="background-color:transparent;">@Component</h3> 
<p>【组件】工具类层（基础的工具）</p> 
<h3 style="background-color:transparent;">@Configuration</h3> 
<p>【配置层】配置</p> 
<p>上面四个注解功能是一样的，都可以用来创建bean实例</p> 
<h2>2.注入，装配</h2> 
<h3>（1）@Autowired：</h3> 
<p>根据属性类型进行自动装配，默认按类型装配（byType）自动装配</p> 
<ul><li>作用于：标注 引用类型的构造器，方法，方法参数，注解</li><li><img alt="" height="204" src="https://images2.imgbox.com/55/53/GQRpOuXo_o.png" width="870"></li></ul> 
<h3>（2）@Resource：</h3> 
<p>可以根据类型注入，可以根据名称注入（byName），标注 类，字段，方法：</p> 
<h3>（3）@Qualifier：</h3> 
<p>根据名称进行注入，这个@Qualifier注解的使用，和上面@Autowired一起使用，<br> 如果有多个类型一样的Bean候选者，则需要限定其中一个候选者</p> 
<ul><li><img alt="" height="433" src="https://images2.imgbox.com/af/e2/GNUuTBAS_o.png" width="797"></li></ul> 
<h3>（4）@Value：注入普通类型属性</h3> 
<p>注解在属性上，<strong>单个注入</strong><br> 支持 SpEL</p> 
<ol><li>从配置文件读取值<br><code>@Value("${property}")</code><br><code>@Value("${property:默认值}")</code></li><li>SpEL<br><code>@Value(“#{SpEL表达式}”)</code></li></ol> 
<p><img alt="" height="552" src="https://images2.imgbox.com/43/21/rQdFyBt4_o.png" width="990"></p> 
<h3><strong><code>@ConfigurationProperties</code></strong></h3> 
<p>通过指定的前缀，绑定配置文件中的配置<br> 可以注解在类上，也可以放在@Bean的方法上。<strong>批量注入</strong>配置文件中的属性</p> 
<p>一般用于多个数据源的配置，读写分离</p> 
<p><img alt="" height="386" src="https://images2.imgbox.com/b7/62/FFXA1LgB_o.png" width="1116"></p> 
<p><img alt="" height="511" src="https://images2.imgbox.com/b4/0b/v8ONlppg_o.png" width="1037"></p> 
<h3>@PropertySource</h3> 
<p>加载指定的配置文件</p> 
<p><img alt="" height="43" src="https://images2.imgbox.com/f8/98/LhTIK8Fu_o.png" width="901"></p> 
<h3>@ImportResource</h3> 
<p>标注在一个配置类,导入Spring的配置文件让其生效</p> 
<p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别。<br> 需要用@ImportResource加载生效</p> 
<p><img alt="" height="49" src="https://images2.imgbox.com/ae/da/gw9M82fq_o.png" width="947"></p> 
<h2>3.完全注解开发</h2> 
<p>创建配置类，替代xml配置文件</p> 
<h3>@Configuration ：</h3> 
<p>作为配置类，替代xml配置文件</p> 
<h3>@ComponentScan(basePackages = {“包名”})：</h3> 
<p>开启注解扫描</p> 
<h2>4.在增强类上面添加注解</h2> 
<p>@Aspect，可与@Component注解一起使用生成代理对象</p> 
<h2>5.AOP相关 </h2> 
<p></p> 
<p>在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置<br> （1）@Before：表示作为前置通知<br> （2）@After：最终通知<br> （3）@AfterReturning：后置通知（返回通知）<br> （4）@AfterThrowing：异常通知<br> （5）@Around：环绕通知<br> （6）@Pointcut：用于相同的切入点抽取</p> 
<p></p> 
<h2>6.bean的生命周期</h2> 
<ul><li> <p><code>@Scope("作用域")</code>作用范围设置</p> </li><li> <p><code>@PostConstruct</code>初始化 Java自己的注解</p> </li><li><code>@PreDestroy</code>销毁</li></ul> 
<h2 style="background-color:transparent;">7.SpringMVC </h2> 
<p>@Component的衍生注解<br> @Controller 标注类 : 对应 Spring MVC 控制层Controller对象，主要用于接受用户请求并调用 Service 层返回数据给前端页面。<br> @Service 标注类 : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。<br> @Repository 标注类 : 对应持久层即 Dao 层，主要用于数据库相关操作。<br> http Request 请求处理方法映射</p> 
<h3 style="background-color:transparent;">@RequestMapping标注类，</h3> 
<p>方法 ： http路径映射到处理类或方法</p> 
<h3>@GetMapping() 标注方法 ：</h3> 
<p>http GET请求路径映射</p> 
<h3>@PostMapping()标注方法 ：</h3> 
<p>http POST请求路径映射</p> 
<h3>@PutMapping标注方法 ：</h3> 
<p>http PUT请求路径映射</p> 
<h3>@DeleteMapping标注方法 ：</h3> 
<p>http DELETE请求路径映射</p> 
<h2>前端&gt;后端传值</h2> 
<h3><code>@PathVariable</code></h3> 
<p> 获取 路径参数</p> 
<h3><code>@RequestParam</code> </h3> 
<p>获取 请求参数 url中的?后面的参数</p> 
<h3><code>@RequestBody</code> </h3> 
<p>获取 请求Body中JSON字符串</p> 
<p><img alt="" height="435" src="https://images2.imgbox.com/30/f5/cG56XUbt_o.png" width="1085"></p> 
<h2>后端&gt;前后端传值</h2> 
<h3><code>@Controller</code> </h3> 
<p>返回一个视图</p> 
<h3><code>@ResponseBody</code></h3> 
<p>标注类，方法： 用于Controller方法返回的对象，写入http的body区</p> 
<h3 style="background-color:transparent;"><code>@RestController</code></h3> 
<p>标注类： = @Controller + @ResponseBody</p> 
<h2>MyBatis注解</h2> 
<h3>mapper</h3> 
<ul><li><code>@Mapper</code> 在接口类上添加，该接口是mapper</li><li><code>@MapperScan(value)</code> 包下面的所有接口都是mapper</li></ul> 
<p><img alt="" height="240" src="https://images2.imgbox.com/8a/e9/ySiQU5CS_o.png" width="864"></p> 
<p>value：指定mapper接口类包路径</p> 
<p>basePackages = 扫描包、类<br> sqlSessionFactoryRef = SqlSessionFactory Bean对象名<br> sqlSessionTemplateRef = sqlSessionTemplate Bean对象名</p> 
<h2>sql语句配置</h2> 
<p>@Select(“select * from user”)<br> @Insert(" insert into user ( name ) values (#{name}) ")<br> @Delete(" delete from user where id= #{id} ")<br> @Update("update user set name=#{name} where id=#{id} ")<br>  </p> 
<h2>其他</h2> 
<p>@Data ： 标注在类上，提供类的get、set、equals、hashCode、canEqual、<a href="https://so.csdn.net/so/search?q=toString%E6%96%B9%E6%B3%95&amp;spm=1001.2101.3001.7020" title="toString方法">toString方法</a></p> 
<h2>异常处理</h2> 
<h3 style="background-color:transparent;">@ControllerAdvice + @ExceptionHandler</h3> 
<p>@ControllerAdvice 表<br> 示控制器通知类，@ExceptionHandler 是异常处理器，两个结合表示当出现异常的时候执⾏某个通知，也就是执⾏某个⽅法事件</p> 
<h3>AOP</h3> 
<p>@Aspect 切面</p> 
<p>@Join Point 连接点</p> 
<p>@Pointcut切点</p> 
<p>@Advice通知</p> 
<ul><li>前置通知使⽤ @Before：通知⽅法会在⽬标⽅法调⽤之前执⾏。</li><li>后置通知使⽤ @After：通知⽅法会在⽬标⽅法返回或者抛出异常后调⽤</li><li>返回之后通知使⽤ @AfterReturning：通知⽅法会在⽬标⽅法返回后调⽤。</li><li>抛异常后通知使⽤ @AfterThrowing：通知⽅法会在⽬标⽅法抛出异常后调⽤。</li><li>环绕通知使⽤ @Around：通知包裹了被通知的⽅法，在被通知的⽅法通知之前和调⽤之后执行自定义的⾏为。</li></ul> 
<p></p> 
<p></p> 
<p>持续补充中~~~~~~~~~~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b4140ac1fd14cfed965389b47f9c5d16/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">年龄迁移：基于扩散模型的容颜变化，从少年到老年全覆盖</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6fc53e507956b8e137d307f511dc48c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python项目开发：Flask基于Python的天气数据可视化平台</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>