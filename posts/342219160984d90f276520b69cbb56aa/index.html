<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ts那些简单的语义 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/342219160984d90f276520b69cbb56aa/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="ts那些简单的语义">
  <meta property="og:description" content="链接：ts保姆级教程，别再说你不会ts了 - 掘金 Typescript 类型 Typescript有哪些类型 1、Typescript 基本类型，也就是可以被直接使用的单一类型。
数字字符串布尔类型nullundefinedanyunknownvoidobject枚举never 2、复合类型，包含多个单一类型的类型。
数组类型元组类型字面量类型接口类型 3、如果一个类型不能满足要求怎么办？
可空类型，默认任何类型都可以被赋值成 null 或 undefined。联合类型，不确定类型是哪个，但能提供几种选择，如：type1 | type2。交叉类型，必须满足多个类型的组合，如：type1 &amp;amp; type2。 类型都在哪里使用 在变量中使用 在变量中使用时，直接在变量后面加上类型即可。
let a: number; let b: string; let c: null; let d: undefined; let e: boolean; let obj: Ixxx = { a: 1, b: 2, }; let fun: Iyyy = () =&amp;gt; {}; 在接口中使用 在接口中使用也比较简单，可以理解为组合多个单一类型。
interface IData { name: string; age: number; func: (s: string) =&amp;gt; void; } 在函数中使用 在函数中使用类型时，主要用于处理函数参数、函数返回值。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-07T17:02:59+08:00">
    <meta property="article:modified_time" content="2023-08-07T17:02:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ts那些简单的语义</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="rHfMx">链接：<a href="https://juejin.cn/post/7092415149809598500#comment" rel="nofollow" title="ts保姆级教程，别再说你不会ts了 - 掘金">ts保姆级教程，别再说你不会ts了 - 掘金</a></h3> 
<h3 id="PWIrc">Typescript 类型</h3> 
<h4 id="hHYvg">Typescript有哪些类型</h4> 
<p id="u01adb315"><strong>1、Typescript 基本类型，也就是可以被直接使用的单一类型。</strong></p> 
<ul><li id="u9e013cfd">数字</li><li id="u2312f9c3">字符串</li><li id="u28a421b7">布尔类型</li><li id="uc8ecbda3">null</li><li id="u5f79f8ec">undefined</li><li id="u5077169c">any</li><li id="u61c028fa">unknown</li><li id="u2efc49b7">void</li><li id="u1fd9ad9a">object</li><li id="u5dcae812">枚举</li><li id="uaead5310">never</li></ul> 
<p id="u91b62700"><strong>2、复合类型，包含多个单一类型的类型。</strong></p> 
<ul><li id="u95b4033a">数组类型</li><li id="uc289569d">元组类型</li><li id="u2f321118">字面量类型</li><li id="u7c041247">接口类型</li></ul> 
<p id="u1e3e09e9"><strong>3、如果一个类型不能满足要求怎么办？</strong></p> 
<ul><li id="u6fc74905">可空类型，默认任何类型都可以被赋值成 null 或 undefined。</li><li id="ub5a3ee2e">联合类型，不确定类型是哪个，但能提供几种选择，如：type1 | type2。</li><li id="ue220fb0a">交叉类型，必须满足多个类型的组合，如：type1 &amp; type2。</li></ul> 
<h4 id="BfZsO">类型都在哪里使用</h4> 
<p id="uf204fd96"><strong>在变量中使用</strong> 在变量中使用时，直接在变量后面加上类型即可。</p> 
<pre id="NCJL8"><code>let a: number;
let b: string;
let c: null;
let d: undefined;
let e: boolean;
let obj: Ixxx = {
  a: 1,
  b: 2,
};
let fun: Iyyy = () =&gt; {};</code></pre> 
<p id="ud794b17e"><strong>在接口中使用</strong> 在接口中使用也比较简单，可以理解为组合多个单一类型。</p> 
<pre id="Mllyl"><code>interface IData {
  name: string;
  age: number;
  func: (s: string) =&gt; void;
}</code></pre> 
<p id="ue4c83657"><strong>在函数中使用</strong> 在函数中使用类型时，主要用于处理函数参数、函数返回值。</p> 
<pre id="mHEc8"><code>// 函数参数
function a(all: string) {}
// 函数返回值
function a(a: string): string {}
// 可选参数
function a(a: number, b?: number) {}</code></pre> 
<h3 id="M4gaE">Typescript 高级用法</h3> 
<h3 id="HLtk5">类中的高级用法</h3> 
<p id="udd1cab4a">在类中的高级用法主要有以下几点：</p> 
<ul><li id="uc01bf558">继承</li><li id="ucf1d4041">存储器 get set</li><li id="u1a4640b5">readonly 修饰符</li><li id="u5fa99ac6">df公有，私有，受保护的修饰符</li><li id="uc977b245">抽象类 abstract</li></ul> 
<p id="u4e93b630">继承和存储器和 ES6 里的功能是一致的，这里就不多说了，主要说一下类的修饰符和抽象类。</p> 
<p id="u560723dc">类中的修饰符是体现面向对象封装性的主要手段，类中的属性和方法在被不同修饰符修饰之后，就有了不同权限的划分，例如：</p> 
<ul><li id="u61258bb0">public 表示在当前类、子类、实例中都能访问。</li><li id="u99a4f927">protected 表示只能在当前类、子类中访问。</li><li id="uc6f47035">private 表示只能在当前类访问。</li></ul> 
<pre id="ZsTu9"><code>class Animal {
  // 公有，私有，受保护的修饰符
  protected AnimalName: string;
  readonly age: number;
  static type: string;
  private _age: number;
  // 属性存储器
  get age(): number {
    return this._age;
  }
  set age(age: number) {
    this._age = age;
  }
  run() {
    console.log("run", this.AnimalName, this.age);
  }
  constructor(theName: string) {
    this.AnimalName = theName;
  }
}
Animal.type = "2"; // 静态属性
const dog = new Animal("dog");
dog.age = 2; // 给 readonly 属性赋值会报错
dog.AnimalName; //</code></pre> 
<p id="u888d272a">在类中的继承也十分简单，和 ES6 的语法是一样的。</p> 
<pre id="GdP2D"><code>class Cat extends Animal {
  dump() {
    console.log(this.AnimalName);
  }
}
let cat = new Cat("catname");

cat.AnimalName; // 受保护的对象，报错
cat.run; // 正常
cat.age = 2; // 正常
</code></pre> 
<p id="u0239f9a8">在面向对象中，有一个比较重要的概念就是抽象类，抽象类用于类的抽象，可以定义一些类的公共属性、公共方法，让继承的子类去实现，也可以自己实现。</p> 
<p id="ufb146bc1">抽象类有以下两个特点：</p> 
<ul><li id="u5ecb49d2">抽象类不能直接实例化</li><li id="u5167d054">抽象类中的抽象属性和方法，必须被子类实现</li></ul> 
<pre id="S6Fmy"><code>tip 经典问题：抽象类的接口的区别：
● 抽象类要被子类继承，接口要被类实现。
● 在 ts 中使用 extends 去继承一个抽象类。
● 在 ts 中使用 implements 去实现一个接口。
● 接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现。
● 抽象类是有规律的，抽离的是一个类别的公共部分，而接口只是对相同属性和方法的抽象，属性和方法可以无任何关联。</code></pre> 
<p id="ufd9dea8f"></p> 
<p id="uabba576e">抽象类的用法如下：</p> 
<pre id="Zmfmr"><code>abstract class Animal {
  abstract makeSound(): void;
  // 直接定义方法实例
  move(): void {
    console.log("roaming the earch...");
  }
}
class Cat extends Animal {
  makeSound() {} // 必须实现的抽象方法
  move() {
    console.log('move');
  }
}
new Cat3();</code></pre> 
<h4 id="LdnDf">接口中的高级用法</h4> 
<p id="uc2b33af5">接口中的高级用法主要有以下几点：</p> 
<ul><li id="u909cf318">继承</li><li id="u73e9925a">可选属性</li><li id="u04a1c001">只读属性</li><li id="u2cb5e884">索引类型：字符串和数字</li><li id="u051c5896">函数类型接口</li><li id="u464849f9">给类添加类型，构造函数类型</li></ul> 
<p id="u5e85ad56">接口中除了可以定义常规属性之外，还可以定义可选属性、索引类型等。</p> 
<pre id="rwbyU"><code>interface Ia {
  a: string;
  b?: string; // 可选属性
  readonly c: number; // 只读属性
  [key: number]: string; // 索引类型
}
// 接口继承
interface Ib extends Ia {
  age: number;
}
let test1: Ia = {
  a: "",
  c: 2,
  age: 1,
};
test1.c = 2; // 报错，只读属性
const item0 = test1[0]; // 索引类型</code></pre> 
<p id="uba1961b4">接口中同时也支持定义函数类型、构造函数类型。</p> 
<pre id="Yb7MY"><code>// 接口定义函数类型
interface SearchFunc {
  (source: string, subString: string): boolean;
}
let mySearch: SearchFunc = function (x: string, y: string) {
  return false;
};
// 接口中编写类的构造函数类型检查
interface IClass {
  new (hour: number, minute: number);
}
let test2: IClass = class {
  constructor(x: number, y: number) {}
};</code></pre> 
<h4 id="agf1m">函数中的高级用法</h4> 
<h5 id="tCObz">函数重载</h5> 
<p id="ue454cc2d">函数重载指的是一个函数可以根据不同的入参匹配对应的类型。</p> 
<p id="u68dd2192">例如：案例中的 doSomeThing 在传一个参数的时候被提示为 number 类型，传两个参数的话，第一个参数就必须是 string 类型。</p> 
<pre id="zqUfZ"><code>// 函数重载
function doSomeThing(x: string, y: number): string;
function doSomeThing(x: number): string;
function doSomeThing(x): any {}

let result = doSomeThing(0);
let result1 = doSomeThing("", 2);</code></pre> 
<h5 id="sCoJT">This 类型</h5> 
<p id="u812beea3">我们都知道，Javascript 中的 this 只有在运行的时候，才能够判断，所以对于 Typescript 来说是很难做静态判断的，对此 Typescript 给我们提供了手动绑定 this 类型，让我们能够在明确 this 的情况下，给到静态的类型提示。</p> 
<p id="uc27708aa">其实在 Javascript 中的 this，就只有这五种情况：</p> 
<ul><li id="ubbc41f30">对象调用，指向调用的对象</li><li id="u74b7b56b">全局函数调用，指向 window 对象</li><li id="u534519c8">call apply 调用，指向绑定的对象</li><li id="ue3d70bba">dom.addEventListener 调用，指向 dom</li><li id="u654f78a0">箭头函数中的 this ，指向绑定时的上下文</li></ul> 
<pre id="hhalU"><code>// 全局函数调用 - window
function doSomeThing() {
  return this;
}
const result2 = doSomeThing();

// 对象调用 - 对象
interface IObj {
  age: number;
  // 手动指定 this 类型
  doSomeThing(this: IObj): IObj;
  doSomeThing2(): Function;
}

const obj: IObj = {
  age: 12,
  doSomeThing: function () {
    return this;
  },
  doSomeThing2: () =&gt; {
    console.log(this);
  },
};
const result3 = obj.doSomeThing();
let globalDoSomeThing = obj.doSomeThing;
globalDoSomeThing(); // 这样会报错，因为我们只允许在对象中调用

// call apply 绑定对应的对象
function fn() {
  console.log(this);
}
fn.bind(document)();

// dom.addEventListener
document.body.addEventListener("click", function () {
  console.log(this); // body
});</code></pre> 
<h4 id="ImxYg">泛型</h4> 
<p id="u94fab839">泛型表示的是一个类型在定义时并不确定，需要在调用的时候才能确定的类型，主要包含以下几个知识点：</p> 
<ul><li id="u7dc62adf">泛型函数</li><li id="ucf8f5cbc">泛型类</li><li id="ud0b82cdf">泛型约束 T extends XXX</li></ul> 
<p id="ub7d13bab">我们试想一下，如果一个函数，把传入的参数直接输出，我们怎么去给它编写类型？传入的参数可以是任何类型，难道我们需要把每个类型都写一遍？</p> 
<ul><li id="ueab5b185">使用函数重载，得把每个类型都写一遍，不适合。</li><li id="u6ecac1f2">泛型，用一个类型占位 T 去代替，在使用时指定对应的类型即可。</li></ul> 
<pre id="D0md1"><code>// 使用泛型
function doSomeThing&lt;T&gt;(param: T): T {
  return param;
}

let y = doSomeThing(1);

// 泛型类
class MyClass&lt;T&gt; {
  log(msg: T) {
    return msg;
  }
}

let my = new MyClass&lt;string&gt;();
my.log("");

// 泛型约束，可以规定最终执行时，只能是哪些类型
function d2&lt;T extends string | number&gt;(param: T): T {
  return param;
}
let z = d2(true);</code></pre> 
<pre id="so8Kw"><code>// 以下四种方法，表达的含义是一致的，都是把对象中的某一个属性的 value 取出来，组成一个数组
function showKey1&lt;K extends keyof T, T&gt;(items: K[], obj: T): T[K][] {
  return items.map((item) =&gt; obj[item]);
}

function showKey2&lt;K extends keyof T, T&gt;(items: K[], obj: T): Array&lt;T[K]&gt; {
  return items.map((item) =&gt; obj[item]);
}

function showKey3&lt;K extends keyof T, T&gt;(
  items: K[],
  obj: { [K in keyof T]: any }
): T[K][] {
  return items.map((item) =&gt; obj[item]);
}

function showKey4&lt;K extends keyof T, T&gt;(
  items: K[],
  obj: { [K in keyof T]: any }
): Array&lt;T[K]&gt; {
  return items.map((item) =&gt; obj[item]);
}

let obj22 = showKey4&lt;"age", { name: string; age: number }&gt;(["age"], {
  name: "yhl",
  age: 12,
});</code></pre> 
<h4 id="vLIUh">高级类型</h4> 
<p id="uffa72e3e">Typescript 中的高级类型包括：交叉类型、联合类型、字面量类型、索引类型、映射类型等，这里我们主要讨论一下</p> 
<ul><li id="u0b3e1196">联合类型</li><li id="ud2388fc1">映射类型</li></ul> 
<p id="u0797200c"><strong>联合类型</strong> 联合类型是指一个对象可能是多个类型中的一个，如：let a :number | string 表示 a 要么是 number 类型，要么是 string 类型。</p> 
<p id="u353bef60">那么问题来了，我们怎么去确定运行时到底是什么类型？</p> 
<p id="u58163bd8">答案是类型保护。类型保护是针对于联合类型，让我们能够通过逻辑判断，确定最终的类型，是来自联合类型中的哪个类型。</p> 
<p id="u5e6ae747">判断联合类型的方法很多：</p> 
<ul><li id="u51a42790">typeof</li><li id="ud5d6fa7b">instanceof</li><li id="u843a8138">in</li><li id="u0e84c65e">字面量保护，===、!===、==、!=</li><li id="ufe6db731">自定义类型保护，通过判断是否有某个属性等</li></ul> 
<pre id="OMr0I"><code>// 自定义类型保护
function isFish(pet: Fish | Bird): pet is Fish {
  return (&lt;Fish&gt;pet).swim !== undefined;
}
if (isFish(pet)) {
  pet.swim();
} else {
  pet.fly();
}</code></pre> 
<p id="u6db9766d"><strong>映射类型</strong> 映射类型表示可以对某一个类型进行操作，产生出另一个符合我们要求的类型：</p> 
<ul><li id="u895da1a1">ReadOnly，将 T 中的类型都变为只读。</li><li id="u356b1a05">Partial，将 T 中的类型都变为可选。</li><li id="u00822084">Exclude，从 T 中剔除可以赋值给 U 的类型。</li><li id="u0a268f9d">Extract，提取 T 中可以赋值给 U 的类型。</li><li id="u43dd8fc7">NonNullable，从 T 中剔除 null 和 undefined。</li><li id="ue4631a1e">ReturnType，获取函数返回值类型。</li><li id="ue05bd69c">InstanceType，获取构造函数类型的实例类型。</li></ul> 
<p id="ue46a49b1">我们也可以编写自定义的映射类型。</p> 
<pre id="SrTZM"><code>//定义toPromise映射
type ToPromise&lt;T&gt; = { [K in keyof T]: Promise&lt;T[K]&gt; };
type NumberList = [number, number];
type PromiseCoordinate = ToPromise&lt;NumberList&gt;;
// [Promise&lt;number&gt;, Promise&lt;number&gt;]</code></pre> 
<h3 id="pHOF8">Typescript 总结</h3> 
<h4 id="nRduq">Typescript 优点</h4> 
<p id="ub3cb8d5d">1、静态类型检查，提早发现问题。</p> 
<p id="u5605e233">2、类型即文档，便于理解，协作。</p> 
<p id="uc06c416d">3、类型推导，自动补全，提升开发效率。</p> 
<p id="ud3bd53a8">4、出错时，可以大概率排除类型问题，缩短 bug 解决时间。</p> 
<p id="ubb5ca288">实战中的优点：</p> 
<p id="u622120dc">1、发现 es 规范中弃用的方法，如：Date.toGMTString。</p> 
<p id="uabfa498c">2、避免了一些不友好的开发代码，如：动态给 obj 添加属性。</p> 
<p id="u3297e77f">3、vue 使用变量，如果没有在 data 定义，会直接抛出问题。</p> 
<h4 id="isfZC">Typescript 缺点</h4> 
<p id="u31637404">1、短期增加开发成本。</p> 
<p id="ucffbb23e">2、部分库还没有写 types 文件。</p> 
<p id="u47c0d572">3、不是完全的超集。</p> 
<p id="u9e2c515b"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c888778320d1145efc5780fa4bbc11e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java学习篇59-Redis-常用指令与Jedis</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8047ed23b4735dbb1acd1cac5ae583c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue3的MVVM简介详情</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>