<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kotlin使用教程 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/8e3eb131031a71292def818d3c12b9b1/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="kotlin使用教程">
  <meta property="og:description" content="写在前面：现在工作越来越不好找，搞不好突然就会离开开发。为了在离开时候，如果想要写kotlin还能想起来怎么写，所以写了一篇教程给自己。
变量表达式方法类扩展属性及函数Function正则表达式kotlin常用的apikotlin协程和flowktx 先来一个kotlin中文站，可以用来看看kotlin新版本出了什么新特性。还可以看看b站的benny老师，他在国内的kotlin推广做了很多事。
main方法
在创建一个kotlin文件之后，不需要声明类名就可以编写main方法，只需
fun main() { } 在可以在main里面编写代码，编写完成后再点击运行即可。
变量 val a = 1 var b = &#34;&#34; // 下面这句代码会编译错误 // var b = 1 val a: Float = 1f kotlin会自动推断变量的类型，一个变量在声明后，编译器就已经确定了该变量的类型，后续是无法更改变量的类型的。可以在变量名臣后面使用&#34;:变量类型&#34;来指定变量类型，就像上面的Float一样。
使用val声明的变量不可以被重新赋值，使用var声明的变量可以被重新赋值。
java的byte、short、int、long、char、boolean、float、double在kotlin里面，是以大写字母开头体现的，并且在kotlin里面，没有Integer、Character类型。
在kotlin里面，一个String如果想要转换成Int，可以使用toInt方法，toInt本质也是调用Integer.parseInt方法。顺便一提，在kotlin里面，也可以调用parseInt方法，不过需要这样调用，java.lang.Integer.parseInt。
提到toInt，就顺便提一个kotlin在声明Int时特有的问题。如果Int的最高位是1时，Int不会将这个值视为负数，而是当做Long。此时，就需要使用toInt转换成Int。
val white:Int = 0xffffffff.toInt() long类型和java一的点不同，在java里面，long类型可以使用大小写L作为结尾，但小写l总会和数字1看错，所以kotlin不允许用小写l，只能用大写L。
除了基本数据有一点不同之外，大部分类型都和java一样，因为kotlin可以直接使用java的api，但有一些还是有点不同。
Object：对应kotlin的Any。void/Void：对应kotlin的Unit。List：List也有一点不同。java的List有add方法，而kotlin的List是没有的add和remove这样的方法的。如果想要使用add或remove方法，只能声明一个MutableList。我认为kotlin这样设计的原因，是为了让开发者可以提供一个只读的List。当开发者不希望返回的List被操作时，就返回List，而如果不在乎是否被操作，就返回MutableList。 0x、0b：kotlin同样支持在声明数字时，用0x表示16进制，用0b表示二进制，还能用_隔开数字而不影响数值。
数组：提到List，就顺便将数组说一下。在kotlin里面，如果想要使用数组，可以使用IntArray或Array。八大基本数据类型都有自己的Array，其他类型需要使用Array。Array在new时，还是比较麻烦的，以IntArray为例：
IntArray(1){ it -&amp;gt; 2 } 这里的1就是Array的长度，2就是要返回的值，这里的意思就是返回一个长度为1，第0个元素为2的数组。
it就是index，这里的it-&amp;gt;可以去掉，{}默认的名称就是it，可以修改为其他名称，比如index，这个下面会具体说明，现在只要知道能这样用即可，其他类型的数组使用的方式也是一样。如果要问，IntArray和Array有什么区别，我记得看过相关博客，说是IntArray的性能更好，所以如果使用基本类型的数组，就使用相应的Array，其他情况再用Array。
从上面的使用方式也可以看到，数组使用的方式特别麻烦，如果length很长，那就是需要判断所有index，这显然是不合理的，所以kotlin也提供了arrayOf这样的api。有intArrayOf和arrayOf等方式。
intArrayOf(1, 2, 3) arrayOf(1, 2, 3) 从上面可以看到初始化一个对象没有使用new关键字，在kotlin里面，没有new关键字，所以想要创建对象时不需要使用new。再补充一下，如果一行只写一句代码，不需要写&#34;;“，只有一行写多句代码和在声明枚举类时，才需要用”;&#34;。
val a = 1;val b = 1 enum class Word{ A, B; fun test(){ } } 如果没有在B后面补一个&#34;">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-12T21:38:44+08:00">
    <meta property="article:modified_time" content="2024-03-12T21:38:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kotlin使用教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>写在前面：现在工作越来越不好找，搞不好突然就会离开开发。为了在离开时候，如果想要写kotlin还能想起来怎么写，所以写了一篇教程给自己。</p> 
<ul><li><a href="#variable" rel="nofollow">变量</a></li><li><a href="#expression" rel="nofollow">表达式</a></li><li><a href="#function" rel="nofollow">方法</a></li><li><a href="#class" rel="nofollow">类</a></li><li><a href="#extension" rel="nofollow">扩展属性及函数</a></li><li><a href="#kotlinfunction" rel="nofollow">Function</a></li><li><a href="#regex" rel="nofollow">正则表达式</a></li><li><a href="#standardlibrary" rel="nofollow">kotlin常用的api</a></li><li><a href="#coroutineandflow" rel="nofollow">kotlin协程和flow</a></li><li><a href="#ktxid" rel="nofollow">ktx</a></li></ul> 
<p>先来一个<a href="https://www.kotlincn.net" rel="nofollow">kotlin中文站</a>，可以用来看看kotlin新版本出了什么新特性。还可以看看<a href="https://space.bilibili.com/28615855" rel="nofollow">b站的benny老师</a>，他在国内的kotlin推广做了很多事。</p> 
<p>main方法<br> 在创建一个kotlin文件之后，不需要声明类名就可以编写main方法，只需</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在可以在main里面编写代码，编写完成后再点击运行即可。</p> 
<h4 id="variable">变量</h4> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token comment">// 下面这句代码会编译错误</span>
<span class="token comment">// var b = 1</span>
<span class="token keyword">val</span> a<span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token number">1f</span>
</code></pre> 
<p>kotlin会自动推断变量的类型，一个变量在声明后，编译器就已经确定了该变量的类型，后续是无法更改变量的类型的。可以在变量名臣后面使用":变量类型"来指定变量类型，就像上面的Float一样。<br> 使用val声明的变量不可以被重新赋值，使用var声明的变量可以被重新赋值。<br> java的byte、short、int、long、char、boolean、float、double在kotlin里面，是以大写字母开头体现的，并且在kotlin里面，没有Integer、Character类型。<br> 在kotlin里面，一个String如果想要转换成Int，可以使用toInt方法，toInt本质也是调用Integer.parseInt方法。顺便一提，在kotlin里面，也可以调用parseInt方法，不过需要这样调用，java.lang.Integer.parseInt。<br> 提到toInt，就顺便提一个kotlin在声明Int时特有的问题。如果Int的最高位是1时，Int不会将这个值视为负数，而是当做Long。此时，就需要使用toInt转换成Int。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> white<span class="token operator">:</span>Int <span class="token operator">=</span> <span class="token number">0xffffffff</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>long类型和java一的点不同，在java里面，long类型可以使用大小写L作为结尾，但小写l总会和数字1看错，所以kotlin不允许用小写l，只能用大写L。<br> 除了基本数据有一点不同之外，大部分类型都和java一样，因为kotlin可以直接使用java的api，但有一些还是有点不同。</p> 
<ul><li>Object：对应kotlin的Any。</li><li>void/Void：对应kotlin的Unit。</li><li>List：List也有一点不同。java的List有add方法，而kotlin的List是没有的add和remove这样的方法的。如果想要使用add或remove方法，只能声明一个MutableList。我认为kotlin这样设计的原因，是为了让开发者可以提供一个只读的List。当开发者不希望返回的List被操作时，就返回List，而如果不在乎是否被操作，就返回MutableList。</li></ul> 
<p><b>0x、0b：</b>kotlin同样支持在声明数字时，用0x表示16进制，用0b表示二进制，还能用_隔开数字而不影响数值。</p> 
<p><b>数组：</b>提到List，就顺便将数组说一下。在kotlin里面，如果想要使用数组，可以使用IntArray或Array。八大基本数据类型都有自己的Array，其他类型需要使用Array。Array在new时，还是比较麻烦的，以IntArray为例：<br></p> 
<pre><code class="prism language-kotlin"><span class="token function">IntArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> it <span class="token operator">-&gt;</span>
    <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里的1就是Array的长度，2就是要返回的值，这里的意思就是返回一个长度为1，第0个元素为2的数组。<br> it就是index，这里的it-&gt;可以去掉，{}默认的名称就是it，可以修改为其他名称，比如index，这个下面会具体说明，现在只要知道能这样用即可，其他类型的数组使用的方式也是一样。如果要问，IntArray和Array有什么区别，我记得看过相关博客，说是IntArray的性能更好，所以如果使用基本类型的数组，就使用相应的Array，其他情况再用Array。<br> 从上面的使用方式也可以看到，数组使用的方式特别麻烦，如果length很长，那就是需要判断所有index，这显然是不合理的，所以kotlin也提供了arrayOf这样的api。有intArrayOf和arrayOf等方式。</p> 
<pre><code class="prism language-kotlin"><span class="token function">intArrayOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> 
<p>从上面可以看到初始化一个对象没有使用new关键字，在kotlin里面，没有new关键字，所以想要创建对象时不需要使用new。再补充一下，如果一行只写一句代码，不需要写";“，只有一行写多句代码和在声明枚举类时，才需要用”;"。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">val</span> b <span class="token operator">=</span> <span class="token number">1</span>

<span class="token keyword">enum</span> <span class="token keyword">class</span> Word<span class="token punctuation">{<!-- --></span>
    A<span class="token punctuation">,</span>
    B<span class="token punctuation">;</span>
    
    <span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果没有在B后面补一个";"，就没办法编写其他代码。</p> 
<p><b>类型转换</b>，在java里面，想要判断变量是否为某种类型可以使用instanceof关键字判断，而在kotlin，需要使用“is”进行判断。而kotlin和java有点不同，在java里面，即使结果为true，还是需要手动转型一次，但在kotlin里面就不需要手动转型。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> a<span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token keyword">is</span> String<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    a<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>只要为true，就可以直接使用String的api。<br> kotlin还有强转的关键字：as。这个as和java的强转还有点不一样。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> a<span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token keyword">val</span> b<span class="token operator">:</span> Int<span class="token operator">?</span> <span class="token operator">=</span> a <span class="token keyword">as</span><span class="token operator">?</span> Int
</code></pre> 
<p>as可以在后面带一个"?"，这样做的意思是，如果是该类型，就转型，如果不是就返回空。<br> 借助这个特性，可以用来判断强转是否成功，比如：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> a<span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token punctuation">(</span>a <span class="token keyword">as</span><span class="token operator">?</span> Int<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果转型成功，就+2，否则就什么都不做。</p> 
<p><b>数字的位操作：</b>在java中，有左移、右移和无符号右移，在kotlin中，不能使用"&lt;&lt;“、”&gt;&gt;“、”&gt;&gt;&gt;"来操作位移，只能使用“shl”来实现左移、"shr"来实现右移，“ushr"实现无符号右移。还有"and"作为”&amp;"的代替，“or"作为”|"的代替。</p> 
<p><b>判断字符串是否相等：</b>在java里面，判断字符串是否相等是比较麻烦的，不但要调用equals方法，还要考虑控安全。到了kotlin，就不用想那么多了，直接使用"=="就可以了。<br> 在idea里面，可以双击shift搜索show kotlin bytecode并点击decompile，就可以发现，之所以使用==就可以避免很多问题，是因为kotlin做了多空的判断。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token class-name">Object</span> first<span class="token punctuation">,</span> <span class="token class-name">Object</span> second<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> first <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> second <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">:</span> first<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但这样做其实就是占用了"==“操作符，如果想要判断两个对象的内存地址是否相等，需要使用三等号”==="。</p> 
<p><b>字符串拼接：</b>在java里面，字符串拼接是很麻烦的，kotlin可以使用$在"“里面拼接字符串。还能使用”{}“写大量代码，并在最后一行返回字符串。如果想要”$“符号，需要使用”\"转义。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token string-literal singleline"><span class="token string">"a</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">a</span></span><span class="token string">"</span></span>

<span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">2</span>
"a$<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token string-literal singleline"><span class="token string">"b"</span></span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token string-literal singleline"><span class="token string">"c"</span></span>
<span class="token punctuation">}</span>"
</code></pre> 
<p>除此之外，kotlin还能使用三引号。用三引号的字符串，可以保留字符串原本字符串的样式。</p> 
<pre><code class="prism language-kotlin"><span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal multiline"><span class="token string">"""
      123
      
        456
        """</span></span><span class="token punctuation">.</span><span class="token function">trimIndent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        
<span class="token comment">// 结果</span>
<span class="token number">123</span>

  <span class="token number">456</span>
</code></pre> 
<p>如果把trimIndent去掉，123和456前后的空行和空格就还会保留。</p> 
<p><b>空安全：</b>kotlin还有一个空安全这个特性，有了空安全，写代码方便了不少。空安全有几种用法</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 基础用法，调用字段/方法前使用问号，只有不为空才会继续执行</span>
<span class="token keyword">val</span> str<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"abc"</span></span>
str<span class="token operator">?</span><span class="token punctuation">.</span>length

<span class="token comment">// 如果可以保证不为空，就可以使用!!</span>
str<span class="token operator">!!</span><span class="token punctuation">.</span>length

<span class="token comment">// 如果在声明时没有写声明可能为空，在使用时就不用写问号</span>
<span class="token comment">// 下面这两种方式在使用时都不需要使用问号</span>
<span class="token keyword">val</span> str<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"abc"</span></span>
<span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"abc"</span></span>
str<span class="token punctuation">.</span>length
</code></pre> 
<p>如果在声明时使用了"?“，那就必须赋值，并且在用该字段时，也需要一直用”?“，就算上一句代码用了”?"，下一句还代码还是需要使用，这是kotlin考虑到多线程的情况，反例</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> MyActivity<span class="token operator">:</span> <span class="token function">Activity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> text_tv<span class="token operator">:</span> TextView<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
    
    <span class="token keyword">override</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        text_tv <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text_tv<span class="token punctuation">)</span>
        text_tv<span class="token operator">?</span><span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"aaa"</span></span>
        text_tv<span class="token operator">?</span><span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"bbb"</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，每次调用都需要用"?"，这样真的很麻烦，虽然也可以用also、let等方法解决，但这里先用latainit解决。<br> lateinit关键字，如果一个变量在构建方法时为空，但会在类的某个方法初始化，就可以用lateinit关键字，这个在android开发中很常见。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> MyActivity<span class="token operator">:</span> <span class="token function">Activity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">lateinit</span> <span class="token keyword">var</span> text_tv<span class="token operator">:</span> TextView
    
    <span class="token keyword">override</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        text_tv <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text_tv<span class="token punctuation">)</span>
        text_tv<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"aaa"</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，用了lateinit之后，就不需要使用问号。但如果想要判断一个字段是否初始化了，需要使用isLateinit</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">this</span><span class="token operator">::</span>text_tv<span class="token punctuation">.</span>isLateinit
</code></pre> 
<p>kotlin还有一个语法：“?:”。这个语法很好用，可以看一下例子：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>str<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    str <span class="token operator">?:</span><span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里str ?:return的意思就是，如果str为空就return，否则就继续执行。这个语法还有另一个用途：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>str<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> String<span class="token punctuation">{<!-- --></span>
    str <span class="token operator">?:</span><span class="token keyword">return</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果有返回值，还能这样用，除此之外还有：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>str<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> String<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> newStr <span class="token operator">=</span> str <span class="token operator">?:</span><span class="token keyword">return</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>还能用来赋值，如果不为空，就将值赋给newStr，否则就返回。<br> 有了这个特性，就不再需要编写if(xxxx)return这样的代码，只需一行代码就可以搞定。</p> 
<p>如果java的属性或方法在返回值上面加了@NotNull的注解，当kotlin去调用该属性/方法时，就无需使用"?"。如果不加就可能为空，可调用可不调用。如果加了@Nullable注解，就必须使用。<br> 相对的，如果kotlin返回一个不为空的对象，java访问时，就会有@NotNull的注解，返回为空的对象就会有@Nullable的注解。</p> 
<p><b>权限修饰符：</b>kotlin的权限修饰符有private、protected、internal和pulbic。默认的权限修饰符是public，internal表示模块可见。比如项目中引用了moduleA，这个module里面某些类或方法使用了internal修饰符，在当前module就用不了。kotlin里面没有java中包可见的修饰符。</p> 
<p><b>静态变量：</b>kotlin种没有static修饰符，想要使用静态变量只能使用伴生对象。具体用法：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> Test <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// const表示编译期常量，也就是说，该变量的值必须在编译时就可以确定的</span>
        <span class="token comment">// 使用了const修饰符的变量，在java中可以正常调用。比如这里就是：Test.VALUE_1</span>
        <span class="token keyword">const</span> <span class="token keyword">val</span> VALUE_1 <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token comment">// 如果没有使用const修饰符，就变成了这样：Test.Companion.getVALUE_2()</span>
        <span class="token keyword">val</span> VALUE_2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token comment">// 此时，可以使用JvmStatic注解，但调用起来还是不好看，Test.getVALUE_3()</span>
        <span class="token annotation builtin">@JvmStatic</span>
        <span class="token keyword">val</span> VALUE_3 <span class="token operator">=</span> <span class="token number">3</span>
        <span class="token comment">// 如果使用JvmField注解，就和VALUE_1一样了，Test.VALUE_4。</span>
        <span class="token annotation builtin">@JvmField</span>
        <span class="token keyword">val</span> VALUE_4 <span class="token operator">=</span> <span class="token number">4</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>如果不是编译期常量，又必须被java调用，才有必要加上注解。如果不是编译期常量，而只被kotlin调用，那去掉const修饰符就行，就像VALUE_2。在kotlin中调用VALUE_2也只是：Test.VALUE_2。<br><br> 可能有人会觉得kotlin特意搞这么一个出来反而更麻烦，和java的static没有区别，但实际开发下来给我的感受就是，使用了伴生对象之后，就可以将静态变量全部放在伴生对象里面。在java里面，只要使用了static就可以变成静态变量，这就很容易在开发中，将静态变量和非静态变量写在一起，这加大了维护的难度。而在kotlin里面，想要找静态变量只需到本省对象里面找就可以了，不用整个类文件找一遍。</p> 
<p><b>泛型：</b>kotlin的泛型和java泛型基本一样，只是换了新的写法和多了reified关键字。基本用法：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> Test<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span>

<span class="token comment">// 在使用时，可以指定泛型的类型</span>
Test<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment">// 如果该类或者方法有某个参数使用到该泛型，并且传值了，可以省略泛型</span>
<span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<p>泛型的边界：kotlin可以使用&lt;T: Class&gt;来制定泛型边界</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> Test<span class="token operator">&lt;</span>T<span class="token operator">:</span> CharSequence<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span>
<span class="token function">Test</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span>

<span class="token comment">// 如果给泛型边界加上"?"，在传参时还能传null，并且不需要在T旁边写"？"</span>
<span class="token keyword">class</span> Test<span class="token operator">&lt;</span>T<span class="token operator">:</span> CharSequence<span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span>
<span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果有多个边界，可以使用where关键字。多个边界只能有一个是类，其他的只能是接口，并且类必须放在最前面</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> Test<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">where</span> T<span class="token operator">:</span> CharSequence<span class="token punctuation">,</span> T<span class="token operator">:</span> View<span class="token punctuation">.</span>OnClickListener<span class="token punctuation">,</span> T<span class="token operator">:</span> View<span class="token punctuation">.</span>OnTouchListener
</code></pre> 
<p>在kotlin中，如果声明了变量类型，在调用返回值为泛型的方法时，可以不用写泛型，这在安卓开发中很常见</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 声明了text_tv的类型时</span>
<span class="token keyword">val</span> text_tv<span class="token operator">:</span> TextView <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text_tv<span class="token punctuation">)</span>
<span class="token comment">// 如果没有声明text_tv的类型，就必须指定泛型</span>
<span class="token keyword">val</span> text_tv <span class="token operator">=</span> findViewById<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text_tv<span class="token punctuation">)</span>
</code></pre> 
<p>真实的泛型，java中的泛型是伪泛型，而kotlin提供了reified关键字还实现真实的泛型。不过所谓真实的泛型，本质是通过代码内联还实现，并没有脱离java伪泛型。</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 一般情况下，启动Activity需要使用MainActivity::class.java来指定class对象</span>
<span class="token function">startActivity</span><span class="token punctuation">(</span><span class="token function">Intent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> MainActivity<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 声明一个真实泛型的startActivity</span>
<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> T<span class="token operator">:</span> Activity<span class="token operator">&gt;</span> <span class="token function">startActivity</span><span class="token punctuation">(</span>context<span class="token operator">:</span> Context<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">startActivity</span><span class="token punctuation">(</span><span class="token function">Intent</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> T<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用</span>
startActivity<span class="token operator">&lt;</span>MainActivity<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
</code></pre> 
<p>可以看到，使用了reified关键字之后，就可以直接使用T的class。在声明reified泛型时，必须在方法前面写上inline关键字，这个关键字的作用下面会讲。</p> 
<p>协变和逆变</p> 
<ul><li>协变：kotlin的&lt;out T&gt;类似java的&lt;? extends T&gt;</li><li>逆变：kotlin的&lt;in T&gt;类似java的&lt;? supe T&gt;</li></ul> 
<p>无边界通配符，kotlin使用&lt;*&gt;来表示无边界通配符。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> Test<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span>

<span class="token keyword">val</span> test<span class="token operator">:</span> Test<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<p><b>同步代码块：</b><br> 在kotlin里面，如果想要使用同步代码块，没办法像java一样在声明方法时写上synchronized关键字，只能在需要的地方使用synchronized方法，传入一个锁对象并编写对应的代码。</p> 
<pre><code class="prism language-kotlin"><span class="token function">synchronized</span><span class="token punctuation">(</span>Test<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>
</code></pre> 
<p><b>匿名函数：</b>只要使用kotlin，就会无时无刻在使用匿名函数，匿名函数是kotlin非常重要的特性，先看怎么声明。</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 声明</span>
<span class="token keyword">val</span> function<span class="token operator">:</span> <span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用</span>
<span class="token function">function</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
function<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<p>(Int) -&gt;) Unit。这里的Int就是第1个参数的类型，Unit就是返回类型，匿名函数也没有任何参数也可以有多个参数，没记错的话，kotlin最多支持声明22个参数的匿名函数。在调用时，可以直接fucntion(…)，也可以调用invoke方法。<br><br> 在function里面，想要使用Int这个参数有2种方式：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> function<span class="token operator">:</span> <span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// it就是参数默认的名称</span>
    it <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token comment">// 也可以使用 xxx -&gt; 这种方式来命名</span>
<span class="token keyword">val</span> function<span class="token operator">:</span> <span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> i <span class="token operator">-&gt;</span>
    i <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果有1个以上的参数，就必须显示声明参数名称：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 如果没有显示声明参数的名称，编译会报错</span>
<span class="token keyword">val</span> function<span class="token operator">:</span> <span class="token punctuation">(</span>Int<span class="token punctuation">,</span> String<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>Unit <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>

<span class="token comment">// 有多个参数名称时，用","隔开</span>
<span class="token keyword">val</span> function<span class="token operator">:</span> <span class="token punctuation">(</span>Int<span class="token punctuation">,</span> String<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>Unit <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> i<span class="token punctuation">,</span> s <span class="token operator">-&gt;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>还能给参数提供一个名称：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 在类型前面写名称，这样在写到 Unit = {之后，编译器就会提醒参数的默认名称</span>
<span class="token keyword">val</span> function<span class="token operator">:</span> <span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">,</span> s<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>Unit <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> i<span class="token punctuation">,</span> s <span class="token operator">-&gt;</span>  
<span class="token punctuation">}</span>
</code></pre> 
<p>匿名函数也可以为空</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 在外部套一个括号，并加一个“?”，就可以声明一个空的匿名函数</span>
<span class="token keyword">var</span> function<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token comment">// 再在其他地方初始化这个参数</span>
function <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面基本就讲完匿名函数的声明方式，但有什么用？看一看forEach的代码就知道有什么用了</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Iterable<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> Unit

<span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
list<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{<!-- --></span>  <span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，forEach方法有一个action参数，这个参数的结构和上面提到的声明方式是一样的。<br> 在kotlin中之所以可以使用list.forEach这种方式来遍历一个list，就是因为kotlin提供了这么一个方法。而且kotlin的标准库里面在，这样的代码还有很多，下面讲到kotlin标准库时，就讲有哪些常用的方法。<br> 并且日常开发中，我们也可以根据自己的需要，定义大量的匿名函数来解决我们的需求。</p> 
<p><b>typealias：</b>可以给一个匿名函数命名，比如：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">typealias</span> OnParentClickListener <span class="token operator">=</span> <span class="token punctuation">(</span>parentPosition<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit
<span class="token keyword">typealias</span> OnChildClickListener <span class="token operator">=</span> <span class="token punctuation">(</span>parentPosition<span class="token operator">:</span> Int<span class="token punctuation">,</span> childPosition<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit
</code></pre> 
<p>使用</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">private</span> <span class="token keyword">var</span> onParentClickListener<span class="token operator">:</span> OnParentClickListener<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">private</span> <span class="token keyword">var</span> onChildClickListener<span class="token operator">:</span> OnChildClickListener<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>

holder<span class="token punctuation">.</span>itemView<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{<!-- --></span>
    onParentClickListener<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>parentPosition<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

holder<span class="token punctuation">.</span>itemView<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{<!-- --></span>
    onChildClickListener<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>parentPosition<span class="token punctuation">,</span> childPosition<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><b>元组：</b>元组的概念我就不写了，不懂的查一下百度。我没有使用过其他编程语言，所以不清楚其他编程语言的元组要怎么用，所以不知道kotlin使用元组的方式是否和其他编程语言一样，我就是说一下怎么在kotlin里面使用元组。<br> 先看一简单用法</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> <span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"a"</span></span>
</code></pre> 
<p>这里的to会将1和a变成了一个Pair对象，该对象是一个data class，data class会为当前类生成component1、component2…componentN的方法，来实现元组的功能。<br> 这里的v1的类型就是Int，v2就是String。<br> 这样有什么用？元组的写法使用有用不同的人有不同的看法，但Pair对象绝对有用，有时我们只是需要一个对象来存储某个几个值，没到非要声明一个对象不可，此时Pair可能就够用了。<br> kotlin还提供了Triple还声明元组，但Triple没有to这样的方法，需要手动创建。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> <span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> v3<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Triple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string-literal singleline"><span class="token string">"a"</span></span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span>
</code></pre> 
<p>然后有一点需要注意，这里的v1、v2和v3虽然用了括号，但还是属于当前大括号的作用域，所以这行代码的上下都不能有v1这样的变量，否则就有变量重名的问题。<br> 再看看两种自定义元组的方式：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> test <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> <span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> v3<span class="token punctuation">,</span> v4<span class="token punctuation">,</span> v5<span class="token punctuation">,</span> v6<span class="token punctuation">,</span> v7<span class="token punctuation">)</span> <span class="token operator">=</span> test
<span class="token punctuation">}</span>
<span class="token keyword">class</span> Test <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token function">component1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token function">component2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"a"</span></span>
    <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token function">component3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token function">component4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token function">component5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token function">component6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token function">component7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>只需在前面写operator并且方法名称是componentN就可以。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> test <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">,</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">,</span><span class="token number">0L</span><span class="token punctuation">,</span><span class="token number">0L</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> <span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> v3<span class="token punctuation">,</span> v4<span class="token punctuation">,</span> <span class="token punctuation">)</span> <span class="token operator">=</span> test
<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> company<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> startDate<span class="token operator">:</span> Long<span class="token punctuation">,</span> <span class="token keyword">val</span> stopDate<span class="token operator">:</span>Long<span class="token punctuation">)</span>
</code></pre> 
<p>data class也可以，data class下面会重点介绍，这里只是提到元组，才写出来。</p> 
<p><b>属性委托：</b>属性委托使用by关键字，通过属性委托，就能将任务交给委托的对象来执行。kotlin提供了ReadOnlyProperty和ReadWriteProperty用声明属性委托，好像还有其他方式，但我不会用，不过只要知道用by就是属性委托就行了。来一个lazy看看属性委托有什么用：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> MyActivity<span class="token operator">:</span> <span class="token function">Activity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> tex_tv <span class="token keyword">by</span> lazy<span class="token punctuation">{<!-- --></span>
        findViewById<span class="token operator">&lt;</span>TextView<span class="token operator">&gt;</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text_tv<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        text_tv<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"aaa"</span></span>
        text_tv<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"bbb"</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的by lazy意思是延迟加载，在声明时，不会调用lazy里面的findViewById，只有在第一次使用时才会调用，第二次使用则不会。onCreate里面的代码，在第一次t调用text_tv时，发现这个变量为空，所以就调用lazy里面的代码初始化text_tv，第二次调用text时，text_tv已经初始化完成，所以就不会调用了。具体可以看看lazy里面的代码，里面的代码逻辑并不复杂。<br> 上面还提到ReadOnlyProperty和ReadWriteProperty这种方式，我们可以自定义属性委托，将一些重复任务交给委托类来执行，拿我之前在工作的例子：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 继承ReadWriteProperty，这个类有两个泛型，第一个是this，也就是要使用的外部类，第二个是属性类型，这里CharSequence也就是String</span>
<span class="token keyword">class</span> ContentDescriptionValueDelegate<span class="token operator">:</span> ReadWriteProperty<span class="token operator">&lt;</span>View<span class="token punctuation">,</span> CharSequence<span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取属性的值，第一个参数是thisRef，类型就是第一个泛型，返回值的类型是第二个泛型</span>
    <span class="token comment">// 可以看到，这里的代码等于同view.getContentDescription().toString，只要记住返回值是这样就行，该方法的作用下面会讲</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> View<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> CharSequence<span class="token operator">?</span> <span class="token operator">=</span> thisRef<span class="token punctuation">.</span>contentDescription<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 这里就是设置值，调用委托的变量设置值，最终会执行这里的代码</span>
    <span class="token comment">// 这里的代码就是view.setContentDescription(value)，并且还调用了getParent执行了其他代码</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">setValue</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> View<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> value<span class="token operator">:</span> CharSequence<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        thisRef<span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{<!-- --></span>
            contentDescription <span class="token operator">=</span> value
            parent<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">requestSendAccessibilityEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> AccessibilityEvent<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span>AccessibilityEvent<span class="token punctuation">.</span>CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{<!-- --></span>
                it<span class="token punctuation">.</span>contentDescription <span class="token operator">=</span> value
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> AccessibilityTestLayout <span class="token annotation builtin">@JvmOverloads</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span>context<span class="token operator">:</span> Context<span class="token punctuation">,</span> attrs<span class="token operator">:</span> AttributeSet<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> defStyleAttr<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">LinearLayout</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> defStyleAttr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 这里的CharSequence?就是上面的第二个泛型，其实:CharSequence?可以省略。</span>
    <span class="token comment">// 可以看到，使用了属性委托之后，该变量的返回值是CharSequence，而不是ContentDescriptionValueDelegate</span>
    <span class="token comment">// 而在new ContentDescriptionValueDelegate时，也不需要将this传进去，只要外部类是第一个泛型就行</span>
    <span class="token keyword">var</span> contentDescriptionValue <span class="token operator">:</span>CharSequence<span class="token operator">?</span> <span class="token keyword">by</span> <span class="token function">ContentDescriptionValueDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>

<span class="token comment">// MainActivity</span>
<span class="token keyword">val</span> accessibilityTestLayout <span class="token operator">=</span> <span class="token function">AccessibilityTestLayout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token comment">// 再看看实际使用，既然contentDescriptionValue的类型是CharSequence，那当然可以直接赋值</span>
<span class="token comment">// 但实际上，这里编译器帮我们干了很多事，实际编译出来的代码会调用setValue方法，但这无所谓</span>
<span class="token comment">// 虽然这是语法糖，但好用就不行，只要知道这个过程中发生了什么就行</span>
<span class="token comment">// 所以这行代码就调用了setContentDescription方法和getParent...方法</span>
accessibilityTestLayout<span class="token punctuation">.</span>contentDescriptionValue <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token comment">// 如果没有赋值，就相当于调用了getValue方法，最终就会执行上面的view.getContentDescription()方法</span>
<span class="token comment">// 而对于这里来说，只要调用contentDescriptionValue这个属性就行，非常方便。</span>
accessibilityTestLayout<span class="token punctuation">.</span>contentDescriptionValue
</code></pre> 
<p>再说一下上面这些代码的作用，这样以后遇到重复代码时，才会考虑是否应该用属性委托去掉重复代码。<br> Delegate的setValue的作用就是设置了contentDescription并通知Parent View自己的contentDescription更新了。<br> 这里如果不这样做，也可以写工具类去做，但不管怎么样都要有一个方法来统一处理，否则就需要编写重复代码。此时，属性委托就是方式之一。而具体要用什么方式，就具体问题具体分析。<br> 再看看一个安卓相关的应用：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> <span class="token function">MyOnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> View<span class="token punctuation">.</span><span class="token function">OnClickListener</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onClick</span><span class="token punctuation">(</span>v<span class="token operator">:</span> View<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">val</span> aaOnClick <span class="token operator">=</span> <span class="token function">MyOnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> CoroutinesTestActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> View<span class="token punctuation">.</span>OnClickListener <span class="token keyword">by</span> aaOnClick <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到Activity的onClick交给了aaOnClick这个外部变量去做。如果在开发中，多个控件的点击事件由一个类去做，代码就可以这样写。</p> 
<h4 id="expression">表达式</h4> 
<b>if表达式：</b>在kotlin里面，没有三元运算法，取而代之的是if表达式 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span>
<span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    code<span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token number">1</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    code<span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token number">0</span>
<span class="token punctuation">}</span>
<span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    code<span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token number">1</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token number">0</span>
</code></pre> 
<p>kotlin的if-else，可以将最后一行作为返回值</p> 
<p><b>for：</b>kotlin的for和java完全不一样，kotlin的for循环本质是执行forEach，至于为什么这样说留到扩展方法讲。下面是几种for的用法：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// .. 表示i的取值范围为[0, 10]</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">// until 表示i的取值范围为[0, 10)</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">0</span> until <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">// step 2 表示每次递增2，所以这里的值是0 2 4 6 8 10</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..</span> <span class="token number">10</span> step <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">// 上面这三种方式都是递增</span>

<span class="token comment">// 下面这两种方式都是递减，10 downTo 0的取值范围内是[10, 0]</span>
<span class="token comment">// stop 2就是每次递减2</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">10</span> downTo <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">10</span> downTo <span class="token number">0</span> step <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment">// 这里就是遍历list所有的元素</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>item <span class="token keyword">in</span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">// 也可以使用list的forEach扩展方法</span>
list<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{<!-- --></span>  <span class="token punctuation">}</span>
</code></pre> 
<p><b>when：</b>kotlin用when代替了java的swich，kotlin的when比java的switch好用很多，语法不再那么啰嗦，功能也变得更强大。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> month <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">var</span> monthStr <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token keyword">when</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token number">1</span> <span class="token operator">-&gt;</span><span class="token punctuation">{<!-- --></span>
        monthStr <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"一"</span></span>
    <span class="token punctuation">}</span>
    <span class="token number">2</span> <span class="token operator">-&gt;</span> monthStr <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"二"</span></span>
    <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token operator">-&gt;</span> monthStr <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"3"</span></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这是基础用法，可以看到，可以写大括号，也可以不写，如果只有一行代码，可以直接不写。再看3,4那里，意思是，如果是3或4，就执行后面的代码。但这种方式还是太麻烦了，可以简写：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> monthStr <span class="token operator">=</span> <span class="token keyword">when</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token number">1</span> <span class="token operator">-&gt;</span><span class="token punctuation">{<!-- --></span>
        <span class="token string-literal singleline"><span class="token string">"1"</span></span>
    <span class="token punctuation">}</span>
    <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"2"</span></span>
    <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"3"</span></span>
    <span class="token keyword">else</span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"0"</span></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>直接在when前面声明monthStr，但这种方式就必须将额外情况写出来。最后的else就是java switch的defalut。可以看到，也支持多种形式，可以像if那样将最后一行返回。<br> java的switch还支持String类型，而kotlin是支持在when使用所有类型。不过有一点需要提前说清楚，kotlin虽然支持所有类型，但编译出来的代码可能会变成if-else，没有switch该有的性能。但这无所谓，因为会编译出这样的代码，说明本身就没办法用switch语法。而用kotlin的when，比较大的作用是让代码逻辑更加清晰，从而不用在一堆if-else里面寻找目标代码。<br> 就比如上面的例子，在第2行就返回，看代码的人一看，就知道when里面是在获取实际的值，如果不关心代码细节，看到这样的代码之后，就不用看when里面的代码，而是看其他代码。后面如果关心代码实现，再回头看when里面的代码也不迟。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> any<span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token keyword">when</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">is</span> String <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"String"</span></span>
    <span class="token keyword">is</span> Int <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"Int"</span></span>
    <span class="token keyword">else</span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"unknow"</span></span>
<span class="token punctuation">}</span>

<span class="token comment">// 上面这种写法，还能这样</span>
<span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token keyword">when</span><span class="token punctuation">{<!-- --></span>
    any <span class="token keyword">is</span> String <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"String"</span></span>
    any <span class="token keyword">is</span> Int <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"Int"</span></span>
    <span class="token keyword">else</span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"unknow"</span></span>
<span class="token punctuation">}</span>
<span class="token comment">// 将when括号里面的代码去掉，然后将any写到判断那里</span>

<span class="token comment">// 既然可以将when括号的内容去掉，那就还能直接拿when当if-else使用</span>
<span class="token comment">// 此时会自上而下匹配，这里虽然有两个结果为true，但state1的判断放在state2上面，所以会返回state1的结果，不会返回state2的结果</span>
<span class="token keyword">val</span> state1 <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"s1_1"</span></span>
<span class="token keyword">val</span> state2 <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"s2_1"</span></span>
<span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token keyword">when</span><span class="token punctuation">{<!-- --></span>
    state1 <span class="token operator">==</span> <span class="token string-literal singleline"><span class="token string">"s1_1"</span></span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"s11"</span></span>
    state2 <span class="token operator">==</span> <span class="token string-literal singleline"><span class="token string">"s2_1"</span></span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"s22"</span></span>
    <span class="token keyword">else</span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"error"</span></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，代码这样写了之后，就更加简洁了，而不用写一堆if-else。</p> 
<p><b>try-catch：</b>try-catch也可以将最后一行返回，具体如下：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> numberStr <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"1"</span></span>
<span class="token keyword">val</span> number <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
    numberStr<span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里例子就是尝试将String转换为Int，如果转换失败就会抛异常执行catch的代码，此时可以写0作为返回值。</p> 
<h4 id="function">方法</h4> kotlin的方法声明和使用跟java的不一样。 
<pre><code class="prism language-kotlin"><span class="token comment">// 这个方法的返回值是Unit</span>
<span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">// 写了:Int就表示返回值是InT</span>
<span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">// 可以在下面写return</span>
<span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token comment">// 也可以不写大括号，直接在=并写返回值</span>
<span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">// 还能去掉返回类型，直接写返回值，kotlin会自动推断返回类型</span>
<span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">// 这种用法再结合if或when，就能代码看起来非常简洁</span>
<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>state<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">when</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token string-literal singleline"><span class="token string">"success"</span></span> <span class="token operator">-&gt;</span> <span class="token number">0</span>
    <span class="token string-literal singleline"><span class="token string">"error"</span></span> <span class="token operator">-&gt;</span> <span class="token number">1</span>
    <span class="token keyword">else</span> <span class="token operator">-&gt;</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><b>方法重写：</b>kotlin方法重写时，必须写override关键字，否则会编译报错，而不是像java那样，写一个可有可无的注解。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p><b>参数默认值：</b>kotlin可以给方法的参数设置默认值：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">,</span> s<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span>

<span class="token comment">// s设置了默认值，所以只需要传第一个参数就可以了</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int  <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span>
<span class="token comment">// 如果两个都设置了默认值，就不需要传参数了</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int  <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token operator">:</span> String <span class="token punctuation">)</span>
<span class="token comment">// 如果第一个设置了默认值，并且不想传值，就必须写明要传值的变量，比如这里就是s</span>
<span class="token function">test</span><span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"1"</span></span><span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">,</span> s<span class="token operator">:</span> String<span class="token punctuation">)</span>
<span class="token comment">// 即使没有使用参数默认值，也可以通过指定参数名称来改变传参顺序</span>
<span class="token function">test</span><span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"1"</span></span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<p><b>可变数组：</b>kotlin的可变数组和java的一样，只是多了参数默认值之后，有一点不一样：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 使用vararg来声明可变参数</span>
<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token operator">:</span> Int<span class="token punctuation">,</span> s<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">vararg</span> intArray<span class="token operator">:</span> Int<span class="token punctuation">)</span>
<span class="token comment">// 正常情况下，使用起来和java一样</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"a"</span></span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>

<span class="token comment">// 将可变数组声明在第一个参数</span>
<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span> <span class="token keyword">vararg</span> intArray<span class="token operator">:</span>Int<span class="token punctuation">,</span>i<span class="token operator">:</span> Int <span class="token punctuation">,</span>s<span class="token operator">:</span>String<span class="token punctuation">)</span>
<span class="token comment">// 想给i传值，就必须使用i =，s同理</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>s <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"a"</span></span><span class="token punctuation">,</span><span class="token punctuation">)</span>

<span class="token comment">// 将可变数组声明在第二个参数</span>
<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span> i<span class="token operator">:</span> Int <span class="token punctuation">,</span><span class="token keyword">vararg</span> intArray<span class="token operator">:</span>Int<span class="token punctuation">,</span>s<span class="token operator">:</span>String<span class="token punctuation">)</span>
<span class="token comment">// 第一个值会被视为i，并且也没办法通过i = 来给i设值</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span>s <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"a"</span></span><span class="token punctuation">)</span>
</code></pre> 
<p><b>方法引用，</b>kotlin也可以使用方法引用，用法和java差不多：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> Test<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token operator">::</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">fun</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里Thread需要一个Runnable对象，此时直接传入a的方法引用。</p> 
<p><b>匿名函数：</b>在方法里面声明匿名函数有一些特殊的情况。如果将匿名函数方在方法的最后一个参数，就可以写在括号外部。如果只有一个参数，并且这个参数是匿名函数，括号都可以省略，这个可以看到List的forEach方法：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Iterable<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> Unit
<span class="token comment">// 在调用forEach方法时，不需要写括号</span>
<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{<!-- --></span>  <span class="token punctuation">}</span>

<span class="token comment">// 如果还有其他参数，那就必须写括号</span>
<span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token punctuation">,</span> C <span class="token operator">:</span> MutableCollection<span class="token operator">&lt;</span><span class="token keyword">in</span> R<span class="token operator">&gt;</span><span class="token operator">&gt;</span> Iterable<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">mapTo</span><span class="token punctuation">(</span>destination<span class="token operator">:</span> C<span class="token punctuation">,</span> transform<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> R<span class="token punctuation">)</span><span class="token operator">:</span> C
<span class="token comment">// 可以看到，mapTo第一个参数不是匿名函数，第二个才是，此时括号就没办法省略</span>
<span class="token keyword">val</span> list <span class="token operator">=</span>ArrayList<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapTo</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>如果有多个匿名函数，或者匿名函数不是作为最有一个参数，就只能将匿名函数写在括号里面：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>action1<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> Unit<span class="token punctuation">,</span> action2<span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>Unit<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">,</span> i<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<p><b>SAM转换：</b>在java8之后，单一方法的接口称为SAM(Single Abstract Method)接口，java8通过Lanbda可以大大简化对SAM的调用，kotlin也是一样的。假设要设置onClick，可以有：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 使用object关键字创建匿名内部类</span>
test_btn<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token operator">:</span> View<span class="token punctuation">.</span><span class="token function">OnClickListener</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onClick</span><span class="token punctuation">(</span>v<span class="token operator">:</span> View<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 使用SAM简化</span>
test_btn<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span>View<span class="token punctuation">.</span><span class="token function">OnClickListener</span><span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 简化</span>
test_btn<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 再简化</span>
test_btn<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p><b>将匿名函数作为返回值：</b></p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"test"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果有多个参数：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span>Int<span class="token punctuation">,</span> String<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>Unit<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> i<span class="token punctuation">,</span> s <span class="token operator">-&gt;</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"test"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>还能：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> action <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span>Unit<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> action
<span class="token punctuation">}</span>
</code></pre> 
<p><b>函数是kotlin的一等公民：</b>在java中，不能直接在文件里面定义方法，而在kotlin里面，就可以直接定义方法和变量。比如：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> List<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果点击看listOf的源码，就会发现listOf没有依托于任何外部类，而是在kt文件独立存在的，kotlin存在大量的这样的方法。</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 变量也可以独立存在</span>
<span class="token keyword">public</span> <span class="token keyword">val</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> List<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span>lastIndex<span class="token operator">:</span> Int
</code></pre> 
<p><b>inline：</b>用inline修饰方法，方法就会变成一个内联方法，修饰类就会变成一个内联类。如果一个方法带有inline关键字，在编译完成后，该方法所有的代码会出现在调用的方法里面，而不只是调用该方法。怎么理解？就拿上面的listOf举例：</p> 
<pre><code class="prism language-kotlin">listOf<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>上面的listOf由于没有传参数，所以调用的是emptyList，所以这里也不传参数，然后看看编译后的代码。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TestKt</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token class-name">CollectionsKt</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var0<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译后就是直接调用emptyList，这就是inline的作用。inline可以减少代码中的方法调用，不过这也会导致编译后的代码比编写的代码多得多。再看看forEach编译后的代码：</p> 
<pre><code class="prism language-kotlin"><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{<!-- --></span> 
    <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译后：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token class-name">Iterable</span> $<span class="token keyword">this</span>$forEach$iv <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Iterable</span><span class="token punctuation">)</span><span class="token class-name">CollectionsKt</span><span class="token punctuation">.</span><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> $i$f$forEach <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
   <span class="token class-name">Iterator</span> var2 <span class="token operator">=</span> $<span class="token keyword">this</span>$forEach$iv<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">while</span><span class="token punctuation">(</span>var2<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token class-name">Object</span> element$iv <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">int</span> it <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Number</span><span class="token punctuation">)</span>element$iv<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">int</span> var5 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，并没有调用forEach方法，而是创建一个Iterator对象，再从Iterator里面遍历出所有对象。</p> 
<p><b>infix关键字：</b>infix关键字可以用来实现中缀函数，先看一个kotlin官方提供的中缀函数。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">infix</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>A<span class="token punctuation">,</span> B<span class="token operator">&gt;</span> A<span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span>that<span class="token operator">:</span> B<span class="token punctuation">)</span><span class="token operator">:</span> Pair<span class="token operator">&lt;</span>A<span class="token punctuation">,</span> B<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">Pair</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> that<span class="token punctuation">)</span>

<span class="token comment">// 使用</span>
<span class="token keyword">val</span> pair <span class="token operator">:</span>Pair<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> String<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"s"</span></span>
</code></pre> 
<p>可以看到，在调用to方法时，不需要使用括号，这就是infix关键字的作用。使用infix定义的方法，必须有且只有一个参数，是否有返回值都有可以。这个特性在日常开发中用得比较少，但偶尔可能有作用，所以提出来。</p> 
<p><b>operator关键字：</b>使用operator修饰的方法，可以使用kotlin提供的预定义符号进行调用，而不用使用方法名称。因此，在调用时，不需要使用括号。一个常见的例子：</p> 
<pre><code class="prism language-kotlin"><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre> 
<p>这里的[0]就是预定义操作符之一，对着方括号的左边按住ctrl键+鼠标左键就可以发现，可以查看这个方括号的源码，源码是：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token keyword">get</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> E
</code></pre> 
<p>这个方法有operator关键字，名称是get。前面说了，operator可以使用预定义的操作符，同样的，也只能使用预定义的名称。具体有：<br><br> 一元操作符：</p> 
<table><thead><tr><th>符号</th><th>方法名称</th></tr></thead><tbody><tr><td>“+”</td><td>unaryPlus</td></tr><tr><td>“-”</td><td>unaryMinus</td></tr><tr><td>“!”</td><td>not</td></tr></tbody></table> 
<p>算数操作符：</p> 
<table><thead><tr><th>符号</th><th>方法名称</th></tr></thead><tbody><tr><td>“+”</td><td>plus</td></tr><tr><td>“-”</td><td>minus</td></tr><tr><td>“*”</td><td>times</td></tr><tr><td>“/”</td><td>div</td></tr><tr><td>“%”</td><td>rem</td></tr></tbody></table> 
<p>比较操作符：</p> 
<table><thead><tr><th>符号</th><th>方法名称</th></tr></thead><tbody><tr><td>”==“ / “!=”</td><td>equals</td></tr><tr><td>“&lt;”/“&lt;=”/“&gt;”/“&gt;=”</td><td>“compareTo”</td></tr></tbody></table> 
<p>集合操作符：</p> 
<table><thead><tr><th>符号</th><th>方法名称</th></tr></thead><tbody><tr><td>“[]”</td><td>get</td></tr><tr><td>“[]”</td><td>set</td></tr><tr><td>“in”</td><td>contains</td></tr><tr><td>“…”</td><td>rangeTo</td></tr></tbody></table> 
<p>"…"表示的是一个区间，取值范围为：[n, m]。</p> 
<p>一些例子：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// unaryMinus：这是compose的一个例子。</span>
value <span class="token keyword">class</span> <span class="token function">Dp</span><span class="token punctuation">(</span><span class="token keyword">val</span> value<span class="token operator">:</span> Float<span class="token punctuation">)</span> <span class="token operator">:</span> Comparable<span class="token operator">&lt;</span>Dp<span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token keyword">inline</span> <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token function">unaryMinus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Dp</span><span class="token punctuation">(</span><span class="token operator">-</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用</span>
<span class="token operator">-</span><span class="token function">Dp</span><span class="token punctuation">(</span><span class="token number">1f</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">.</span>dp

<span class="token comment">// "not"虽然也是一个操作符，但开发中用得比较少，更多的是直接调用not方法</span>
<span class="token comment">// 使用”not“，就不用在编写完代码之后还将光标提到前面写"!"</span>
<span class="token comment">// 而且“not"在任何地方都可以用，只要想要取反，都可以调用"not"</span>
<span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"str"</span></span>
str<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 算数操作符我在18年开发时用过一次，需要对经纬度做加减乘除，所以我定义了下面这些方法</span>
<span class="token keyword">class</span> <span class="token function">LatLng</span><span class="token punctuation">(</span><span class="token keyword">val</span> lat<span class="token operator">:</span> Float<span class="token punctuation">,</span> <span class="token keyword">val</span> lng<span class="token operator">:</span> Float<span class="token punctuation">)</span>

<span class="token keyword">operator</span> <span class="token keyword">fun</span> LatLng<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span>latLng<span class="token operator">:</span> LatLng<span class="token punctuation">)</span><span class="token operator">:</span> LatLng<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">LatLng</span><span class="token punctuation">(</span>lat <span class="token operator">+</span> latLng<span class="token punctuation">.</span>lat<span class="token punctuation">,</span> lng <span class="token operator">+</span> latLng<span class="token punctuation">.</span>lng<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">operator</span> <span class="token keyword">fun</span> LatLng<span class="token punctuation">.</span><span class="token function">minus</span><span class="token punctuation">(</span>latLng<span class="token operator">:</span> LatLng<span class="token punctuation">)</span><span class="token operator">:</span> LatLng<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">LatLng</span><span class="token punctuation">(</span>lat <span class="token operator">-</span> latLng<span class="token punctuation">.</span>lat<span class="token punctuation">,</span> lng <span class="token operator">-</span> latLng<span class="token punctuation">.</span>lng<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这样就可以对经纬度做加减操作了</span>
<span class="token function">LatLng</span><span class="token punctuation">(</span><span class="token number">1f</span><span class="token punctuation">,</span> <span class="token number">1f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">LatLng</span><span class="token punctuation">(</span><span class="token number">2f</span><span class="token punctuation">,</span> <span class="token number">2f</span><span class="token punctuation">)</span>

<span class="token comment">// 比较操作符最常见的例子就是String的equals操作，当使用 == 判断字符串是否相等时</span>
<span class="token comment">// 就是在调用equals这个operator方法在判断</span>

<span class="token comment">// compareTo也是一个很实用的操作符，而实际上，一个类只要实现了Comparable，就可以直接使用"&lt;" "&gt;"等操作符来比较，而不用使用operator关键字</span>
<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">LatLng</span><span class="token punctuation">(</span><span class="token keyword">val</span> lat<span class="token operator">:</span> Float<span class="token punctuation">,</span> <span class="token keyword">val</span> lng<span class="token operator">:</span> Float<span class="token punctuation">)</span><span class="token operator">:</span> Comparable<span class="token operator">&lt;</span>LatLng<span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>other<span class="token operator">:</span> LatLng<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">LatLng</span><span class="token punctuation">(</span><span class="token number">1f</span><span class="token punctuation">,</span> <span class="token number">1f</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">LatLng</span><span class="token punctuation">(</span><span class="token number">2f</span><span class="token punctuation">,</span> <span class="token number">2f</span><span class="token punctuation">)</span>

<span class="token comment">// 再看一个比较有用的例子，通过下面这种方式，就可以比较两个BigDecimal，而不需要调用compareTo方法</span>
BigDecimal<span class="token punctuation">.</span>ZERO <span class="token operator">&lt;=</span> BigDecimal<span class="token punctuation">.</span>ONE
<span class="token comment">// BigDecimal还有plus的operator，所以可以</span>
BigDecimal<span class="token punctuation">.</span>ZERO <span class="token operator">+</span> BigDecimal<span class="token punctuation">.</span>ONE

<span class="token comment">// 数组操作符也很实用，最常见的例子当然是最集合的操作，还能用这种方式对String进行操作</span>
<span class="token comment">// 想要获取某个字符，不再需要调用indexOf，而是像在使用数组那样操作</span>
<span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"str"</span></span>
str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

<span class="token comment">// ".."符号可以用来声明一个IntRange</span>
<span class="token keyword">val</span> range <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">..</span> <span class="token number">3</span>
<span class="token comment">// 只是用".."确实没什么用，但如果再加上"in"操作符就会变成很好用</span>
<span class="token comment">// 再借助“in”操作符，就可以轻松的判断一个数字是否在某个区间里面</span>
<span class="token comment">// 如果是java，还需要判断是否大于等于1，小于等于3</span>
<span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span>
</code></pre> 
<h4 id="class">类</h4> 在声明一个类时，如果没有参数，就不需要写()，如果有就必须写，这个下面会讲清楚，先来将继承和实现说清楚。继承或实现一个类，都是用":"。比如： 
<pre><code class="prism language-kotlin"><span class="token comment">// 继承一个类必须后边写上括号，如果有参数就必须传参数，比如：AppCompatActivity()</span>
<span class="token comment">// 如果有多个继承/实现类，使用","隔开。这里的CoroutineScope是一个接口</span>
<span class="token keyword">class</span> CoroutinesTestActivity <span class="token operator">:</span> <span class="token function">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CoroutineScope

<span class="token comment">// 这个类就有多个参数，所以必须使用括号。在括号里面通过xx: XX这样就可以声明一个参数</span>
<span class="token comment">// 在将参数传给被继承类时，就可以使用这些参数</span>
<span class="token comment">// 使用 @JvmOverloads 就可以让这个类生成多个构造方法，而不用写多个构造方法</span>
<span class="token keyword">class</span> AccessibilityTestLayout <span class="token annotation builtin">@JvmOverloads</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span>context<span class="token operator">:</span> Context<span class="token punctuation">,</span> attrs<span class="token operator">:</span> AttributeSet<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> defStyleAttr<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">:</span> <span class="token function">LinearLayout</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> defStyleAttr<span class="token punctuation">)</span>

<span class="token comment">// 也可以使用constructor声明多个构造方法</span>
<span class="token keyword">class</span> MyView <span class="token operator">:</span> View<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>context<span class="token operator">:</span> Context<span class="token punctuation">)</span><span class="token operator">:</span><span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>context<span class="token operator">:</span> Context<span class="token punctuation">,</span> attrs<span class="token operator">:</span> AttributeSet<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> b <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 设置构造方法的可见性</span>
<span class="token comment">// 可以通过这样将构造方法设置为private</span>
<span class="token keyword">class</span> MyView <span class="token keyword">private</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span>context<span class="token operator">:</span> Context<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">View</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
<span class="token comment">// 或者这样</span>
<span class="token keyword">class</span> MyView  <span class="token operator">:</span> View<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span>context<span class="token operator">:</span> Context<span class="token punctuation">)</span><span class="token operator">:</span><span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 如果在声明类时就声明了构造方法，那要怎么初始化类的参数？使用init关键字</span>
<span class="token keyword">class</span> MyView <span class="token keyword">constructor</span><span class="token punctuation">(</span>context<span class="token operator">:</span> Context<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">View</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">init</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在声明时顺便声明成员变量</span>
<span class="token comment">// 只要在变量前面加val/var，这个变量就是一个成员变量，可以在类的任何地方使用</span>
<span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span>
<span class="token comment">// 如果不希望被外部访问，还能加上权限修饰符</span>
<span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">private</span> <span class="token keyword">val</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span>

<span class="token comment">// 抽象类的声明方式和java是一样的</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token function">BasePerson</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">private</span> <span class="token keyword">val</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span>
</code></pre> 
<p><b>open关键字：</b>kotlin在声明类时，类会有一个final的修饰符，这使得声明的类没办法被继承，如果希望一个类被继承，需要使用open关键字。成员变量和方法也是一样，如果希望一个方法能够被重写，也必须使用open关键字。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> BaseTest<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> Test1<span class="token operator">:</span> <span class="token function">BaseTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果没有使用open关键字，编译会报错：This type is final, so it cannot be inherited from.<br> 在这句提示下面，还有一个可以点击的Button，内容为：Make ‘BaseTest’ ‘open’。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> BaseTest<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> Test1<span class="token operator">:</span> <span class="token function">BaseTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>加了open之后就没问题了。<br><br> 成员变量和方法</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> BaseTest<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">open</span> <span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> Test1<span class="token operator">:</span> <span class="token function">BaseTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><b>inner关键字：</b>在kotlin里面，内部类默认为静态内部类，所以不会持有外部类的引用，如果希望这个类变成非静态内部类，需要使用inner修饰符，最常见的就是在Activity里面创建Hander。<br><br> 如果没有使用inner，引用外部类的变量会编译报错。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">class</span> MyHandler<span class="token operator">:</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token operator">:</span> Message<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        a<span class="token operator">++</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在class前面加一个inner就没问题了。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">inner</span> <span class="token keyword">class</span> MyHandler<span class="token operator">:</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token operator">:</span> Message<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        a<span class="token operator">++</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><b>一个文件编写多个class：</b>在java里面，一个类文件只能有一个public类和多个没有public的类。而kotlin就可以在一个kt文件里面定义多个class，并且还能定义方法。</p> 
<p><b>接口方法的默认实现：</b>java1.7的接口方法是不允许编写代码的，只有在java8才能在接口方法里面编写代码，但也必须使用default关键字。在kotlin里面，在定义接口方法的同时，也可以直接提供方法实现。</p> 
<p><b>data class，</b>data class可以用来声明一些实体类，使用了data class之后，就会自动生成hashCode和equals方法，还会提供componentN方法，先看看怎么用：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 这样会编译报错，构造方法必须有参数</span>
<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span>
<span class="token function">println</span><span class="token punctuation">(</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"a"</span></span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 打印结果：Person(name=a, age=1)</span>
</code></pre> 
<p>data class还会自动生成深拷贝的方法，如果想要深拷贝一个对象，就不用自己手动编写长长的拷贝代码。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> p1 <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"str"</span></span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> p3 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"str2"</span></span><span class="token punctuation">)</span>
</code></pre> 
<p>在深拷贝时，还能为某个变量重新赋值。</p> 
<p>如果使用show kotlin bytecode就会发现，短短的一行代码，kotlin就会生成很多代码，这里我就不将代码贴出来了。</p> 
<p><b>变量的get/set方法，</b>在kotlin里面，可以给变量设置get和set方法，这样就不用编写额外的方法，而且用起来也比较方便。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> Test <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 如果是val，就知只能重写get方法，不能重写set方法</span>
    <span class="token keyword">val</span> result1<span class="token operator">:</span> Boolean
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"result1 set"</span></span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0L</span>
        <span class="token punctuation">}</span>

    <span class="token keyword">val</span> result2<span class="token operator">:</span> Boolean
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0L</span>

    <span class="token keyword">var</span> result3<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token comment">// field就是变量本身，通过field = value这种方式对变量赋值</span>
        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>field <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            field <span class="token operator">=</span> value
        <span class="token punctuation">}</span>
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> field
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> test <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>result1<span class="token punctuation">)</span>
    test<span class="token punctuation">.</span>result3 <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>result3<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// result1 set</span>
<span class="token comment">// false</span>
<span class="token comment">// result3 get</span>
<span class="token comment">// true</span>
</code></pre> 
<p>而这个特性还不止于此，在kotlin使用java的get/set方法时，也能变成像在使用变量一样。</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 这两行代码本质上就是在调用TextView的setText和getText方法</span>
test_tv<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"aaa"</span></span>
<span class="token keyword">val</span> txt <span class="token operator">=</span> test_tv<span class="token punctuation">.</span>text
</code></pre> 
<p>而如果一个只有get方法，而没有set方法，也能使用这个特性</p> 
<pre><code>// java code
public class JavaTest {
    public int getA(){
        return 1;
    }
}

// kotlin code
val test = JavaTest()
val a =  test.a
// 由于没有set方法，所以不能这样用，否则会编译报错
//  test.a = 1
</code></pre> 
<p><b>object关键字，</b>object关键字有两个用途，一个是声明匿名内部类，另一个是声明单例对象。先看匿名内部类：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 想要声明匿名内部类就只能用object关键字。如果父类是一个类就补上括号，如果是接口就不用</span>
<span class="token keyword">val</span> click <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span>View<span class="token punctuation">.</span><span class="token function">OnClickListener</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onClick</span><span class="token punctuation">(</span>v<span class="token operator">:</span> View<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 这里的onClick还能简写成</span>
<span class="token keyword">val</span> click <span class="token operator">=</span> OnClickListener <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
</code></pre> 
<p>声明一个单例对象：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">object</span> Single<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">// 声明成单例对象之后，甚至可以写出这种意义不明的代码，只是调用该对象，但什么都不做</span>
Single

<span class="token keyword">object</span> Single<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 不需要声明伴生对象，就可以使用调用test方法</span>
Single<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 变量的用法也一样</span>
<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Single<span class="token punctuation">.</span>VALUE_1
    Single<span class="token punctuation">.</span>VALUE_2
<span class="token punctuation">}</span>

<span class="token keyword">object</span> Single <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> VALUE_1 <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"v"</span></span>
    <span class="token comment">// 声明编译期常量也不用在伴生对象里面声明</span>
    <span class="token keyword">const</span> <span class="token keyword">val</span> VALUE_2 <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"v"</span></span>
<span class="token punctuation">}</span>
</code></pre> 
<p><b>密封类：</b>使用sealed声明。密封类和枚举有点像，但又不完全相同。密封类的子类可以携带自己独有的状态参数以及行为方法来记录更多的实现信息以完成更多的功能，而枚举类的参数只能和声明类一样。<br><br> 没有使用密封类时：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token function">NetworkCode</span><span class="token punctuation">(</span><span class="token keyword">val</span> code<span class="token operator">:</span> Int<span class="token punctuation">)</span>

<span class="token keyword">class</span> SuccessCode<span class="token operator">:</span> <span class="token function">NetworkCode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> ErrorCode<span class="token operator">:</span> <span class="token function">NetworkCode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">val</span> networkCode<span class="token operator">:</span> NetworkCode <span class="token operator">=</span> <span class="token function">SuccessCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> networkState <span class="token operator">=</span> <span class="token keyword">when</span><span class="token punctuation">(</span>networkCode<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">is</span> SuccessCode <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"success"</span></span>
    <span class="token keyword">is</span> ErrorCode <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"failed"</span></span>
    <span class="token keyword">else</span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"failed"</span></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，还需要写else，否则就会编译报错<br><br> 如果使用密封类，就不用写else了。并且构造方法可以随意定义，不需要像枚举那样只有固定的构造方法。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token function">NetworkCode</span><span class="token punctuation">(</span><span class="token keyword">val</span> code<span class="token operator">:</span> Int<span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token function">SuccessCode</span><span class="token punctuation">(</span><span class="token keyword">val</span> str<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">NetworkCode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token function">ErrorCode</span><span class="token punctuation">(</span><span class="token keyword">val</span> i<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">NetworkCode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">val</span> networkCode<span class="token operator">:</span> NetworkCode <span class="token operator">=</span> <span class="token function">SuccessCode</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span>
<span class="token keyword">val</span> networkState <span class="token operator">=</span> <span class="token keyword">when</span><span class="token punctuation">(</span>networkCode<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">is</span> SuccessCode <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"success"</span></span>
    <span class="token keyword">is</span> ErrorCode <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">"failed"</span></span>
<span class="token punctuation">}</span>
</code></pre> 
<p><b>inline class和value class：</b>inline class可以用来对一个某个变量的行为进行封装，并且还能避免创建对象。比如：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> age <span class="token operator">=</span> <span class="token function">Age</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    age<span class="token punctuation">.</span><span class="token function">getValidateAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">Age</span><span class="token punctuation">(</span><span class="token keyword">val</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fun</span> <span class="token function">getValidateAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int<span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">if</span><span class="token punctuation">(</span>age <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token number">0</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> age
    <span class="token punctuation">}</span>
    <span class="token keyword">fun</span> <span class="token function">isZero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> age <span class="token operator">==</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里声明一个Age的inline class，并在main方法调用。看看编译后的代码是什么：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Age</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> constructor_impl<span class="token comment">/* $FF was: constructor-impl*/</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> age<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> getValidateAge_impl<span class="token comment">/* $FF was: getValidateAge-impl*/</span><span class="token punctuation">(</span><span class="token keyword">int</span> $<span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> $<span class="token keyword">this</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> $<span class="token keyword">this</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token class-name">Age</span><span class="token punctuation">.</span>constructor<span class="token operator">-</span><span class="token function">impl</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Age</span><span class="token punctuation">.</span>getValidateAge<span class="token operator">-</span><span class="token function">impl</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>可以看到，编译后虽然还是声明了Age对象，但只是调用Age对象的静态方法，并没有创建Age对象。<br><br> 在使用inline class时需要注意：</p> 
<ul><li>inline class必须在构造方法声明一个变量类型，并且也只能有一个参数，参数必须使用val而不能使用var</li><li>inline class不能被继承，因为在编译时，inline class会被加上final关键字，inline class也不能继承其他类</li><li>运行时类型会被擦除</li></ul> 
<p>inline class是在kotlin1.3版本被引入的，在kotlin1.5之后，inline class进入稳定版本，kotlin引入value class，inline class被弃用。如果在1.5以上的版本使用inline class，会有一个warning：<br> <code>'inline' modifier is deprecated. Use 'value' instead</code><br> value class对inline class进行了一些优化，目前，value&amp;nsbp;class的用法和inline class是一样的，也只能使用一个参数。未来的kotlin版本可能会支持构造方法多个参数的value class。<br> 在使用value class时，还需要在声明类时使用@JvmInline注解。</p> 
<h4 id="extension">扩展属性及函数</h4> 扩展函数是kotlin重要的组成部分，没有扩展函数，kotlin也就不会那么好用。 
<br> 
<b>扩展属性</b>的语法是： 
<pre><code class="prism language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">var</span> age<span class="token operator">:</span> Int<span class="token punctuation">,</span>  <span class="token keyword">private</span> <span class="token keyword">var</span> priateAge<span class="token operator">:</span> Int<span class="token punctuation">)</span>

<span class="token keyword">val</span> Person<span class="token punctuation">.</span>aaaAge<span class="token operator">:</span> Int <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> age

<span class="token keyword">var</span> Person<span class="token punctuation">.</span>bbbAge<span class="token operator">:</span> Int
    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> age
    <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        age <span class="token operator">=</span> value
        <span class="token comment">// 编译报错</span>
        priateAge <span class="token operator">=</span> value
    <span class="token punctuation">}</span>
    
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> person <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> bbbAAge <span class="token operator">=</span> person<span class="token punctuation">.</span>bbbAge
    person<span class="token punctuation">.</span>bbbAge <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>var/val Xxxx.yyy get()/set()。<br><br> 可以用var或val修饰，val必须提供get方法，var必须提供get和set方法，扩展属性不能操作被扩展的属性，因为扩展属性本质是对该属性生成getter和setter方法，并没有实际存在该属性。<br><br> 而无论是扩展属性还是扩展方法，都可以访问到被扩展类的public属性和方法，所以可以在set方法里面调用age变量，如果是private属性是没办法调用的。再看看编译后的代码：</p> 
<pre><code class="prism language-java"><span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> bbbAAge <span class="token operator">=</span> <span class="token function">getBbbAge</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setBbbAge</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getBbbAge</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> <span class="token class-name">Person</span> $<span class="token keyword">this</span>$bbbAge<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token class-name">Intrinsics</span><span class="token punctuation">.</span><span class="token function">checkNotNullParameter</span><span class="token punctuation">(</span>$<span class="token keyword">this</span>$bbbAge<span class="token punctuation">,</span> <span class="token string">"$this$bbbAge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> $<span class="token keyword">this</span>$bbbAge<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setBbbAge</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> <span class="token class-name">Person</span> $<span class="token keyword">this</span>$bbbAge<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token class-name">Intrinsics</span><span class="token punctuation">.</span><span class="token function">checkNotNullParameter</span><span class="token punctuation">(</span>$<span class="token keyword">this</span>$bbbAge<span class="token punctuation">,</span> <span class="token string">"$this$bbbAge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   $<span class="token keyword">this</span>$bbbAge<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>扩展属性本质是静态调用，扩展函数也是一样的，后面就不重复赘述。</p> 
<p><b>扩展函数</b>语法：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Iterable<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> Unit <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>element <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token function">action</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>fun Xxx.yyy()。<br><br> 知道语法之后，日常开发就可以自己定义一些扩展函数，因为kotlin的标准库不可能满足所有的开发需求。<br><br> 扩展属性/函数如果定义在一个普通的kotlin文件，作用域就是整个项目。扩展函数还能定义在类里面，这样作用域就只是该类，外部访问不到这些扩展函数。比如：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> person <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token comment">// 编译报错，访问不到该方法</span>
    person<span class="token punctuation">.</span><span class="token function">isZero</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">var</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> isAgeZero <span class="token operator">=</span> age<span class="token punctuation">.</span><span class="token function">isZeor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">fun</span> Int<span class="token punctuation">.</span><span class="token function">isZeor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token operator">==</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4 id="kotlinfunction">Function</h4> 这个是对匿名函数的原理进行解释，不想了解也可以不看。 
<br> 
<pre><code class="prism language-kotlin"><span class="token comment">// 写法1</span>
<span class="token keyword">var</span> action<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// 写法2</span>
<span class="token keyword">var</span> action<span class="token operator">:</span> Functiuon0<span class="token operator">&lt;</span>Unit<span class="token operator">&gt;</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token comment">// 使用</span>
action <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，两者可以用同一种用法，这里的Funtion0是什么？Funtion0就是kotlin匿名函数的底层对象，所有的() -&gt; Unit这样的语法，最终都会编译成Funtion0这种形式。<br><br> 0就是0个参数，后面的泛型就是返回类型。如果有1个参数，就是Funtion1，Function最多支持到22。<br><br> 看看Funtion的源码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function0</span><span class="token generics"><span class="token punctuation">&lt;</span>out <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token operator">:</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/** Invokes the function. */</span>
    <span class="token keyword">public</span> operator fun <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">R</span>
<span class="token punctuation">}</span>
<span class="token comment">/** A function that takes 1 argument. */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function1</span><span class="token generics"><span class="token punctuation">&lt;</span>in P1<span class="token punctuation">,</span> out <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token operator">:</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/** Invokes the function with the specified argument. */</span>
    <span class="token keyword">public</span> operator fun <span class="token function">invoke</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> <span class="token constant">P1</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">R</span>
<span class="token punctuation">}</span>
<span class="token comment">/** A function that takes 2 arguments. */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function2</span><span class="token generics"><span class="token punctuation">&lt;</span>in P1<span class="token punctuation">,</span> in P2<span class="token punctuation">,</span> out <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token operator">:</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/** Invokes the function with the specified arguments. */</span>
    <span class="token keyword">public</span> operator fun <span class="token function">invoke</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> <span class="token constant">P1</span><span class="token punctuation">,</span> p2<span class="token operator">:</span> <span class="token constant">P2</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">R</span>
<span class="token punctuation">}</span>
<span class="token comment">/** A function that takes 3 arguments. */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function3</span><span class="token generics"><span class="token punctuation">&lt;</span>in P1<span class="token punctuation">,</span> in P2<span class="token punctuation">,</span> in P3<span class="token punctuation">,</span> out <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token operator">:</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/** Invokes the function with the specified arguments. */</span>
    <span class="token keyword">public</span> operator fun <span class="token function">invoke</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> <span class="token constant">P1</span><span class="token punctuation">,</span> p2<span class="token operator">:</span> <span class="token constant">P2</span><span class="token punctuation">,</span> p3<span class="token operator">:</span> <span class="token constant">P3</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">R</span>
<span class="token punctuation">}</span>
<span class="token comment">/** A function that takes 4 arguments. */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function4</span><span class="token generics"><span class="token punctuation">&lt;</span>in P1<span class="token punctuation">,</span> in P2<span class="token punctuation">,</span> in P3<span class="token punctuation">,</span> in P4<span class="token punctuation">,</span> out <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token operator">:</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/** Invokes the function with the specified arguments. */</span>
    <span class="token keyword">public</span> operator fun <span class="token function">invoke</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> <span class="token constant">P1</span><span class="token punctuation">,</span> p2<span class="token operator">:</span> <span class="token constant">P2</span><span class="token punctuation">,</span> p3<span class="token operator">:</span> <span class="token constant">P3</span><span class="token punctuation">,</span> p4<span class="token operator">:</span> <span class="token constant">P4</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">R</span>
<span class="token punctuation">}</span>
<span class="token comment">/** A function that takes 5 arguments. */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function5</span><span class="token generics"><span class="token punctuation">&lt;</span>in P1<span class="token punctuation">,</span> in P2<span class="token punctuation">,</span> in P3<span class="token punctuation">,</span> in P4<span class="token punctuation">,</span> in P5<span class="token punctuation">,</span> out <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token operator">:</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/** Invokes the function with the specified arguments. */</span>
    <span class="token keyword">public</span> operator fun <span class="token function">invoke</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> <span class="token constant">P1</span><span class="token punctuation">,</span> p2<span class="token operator">:</span> <span class="token constant">P2</span><span class="token punctuation">,</span> p3<span class="token operator">:</span> <span class="token constant">P3</span><span class="token punctuation">,</span> p4<span class="token operator">:</span> <span class="token constant">P4</span><span class="token punctuation">,</span> p5<span class="token operator">:</span> <span class="token constant">P5</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">R</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，每个对象都有invoke方法，所以在调用时，也可以调用invoke方法。具体可以看看Functions.kt这个文件，可以看到最多支持到Funtion22。</p> 
<h4 id="regex">正则表达式</h4> kotlin使用正则表达式的方式和java有点不同。在kotlin里面，涉及到正则表达式的地方都需要使用toRegex将字符串转换成正则表达式。 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> regex <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"str"</span></span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span>
</code></pre> 
<p>如果不调用toRegex，那就不是做正则替换，只有调用了toRegex才可以</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> regex <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">.</span><span class="token function">toRegex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"str"</span></span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span>
</code></pre> 
<p>java的replace方法是不能传入正则表达式的，只有调用replaceAll才可以传入正则表达式，而kotlin直接调用replace方法，相应的，kotlin没有replaceAll方法。</p> 
<h4 id="standardlibrary">kotlin常用的api</h4> 上面已经将kotlin的用法写完了，这里再看看kotlin有哪些常用的api。 
<br> 
<b>also和let：</b>also和let类型，区别是also会返回调用者本身的值，let会将最后一行作为返回值： 
<pre><code class="prism language-kotlin"><span class="token comment">// also</span>
<span class="token keyword">val</span> list <span class="token operator">=</span> ArrayList<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">also</span><span class="token punctuation">{<!-- --></span>
    it<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    it<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// let</span>
<span class="token keyword">val</span> value <span class="token operator">=</span> <span class="token number">1f</span> <span class="token operator">/</span> <span class="token number">3</span>
<span class="token keyword">val</span> valueStr<span class="token operator">:</span> String <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{<!-- --></span> <span class="token function">DecimalFormat</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"0.00"</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token comment">// let配合as关键字，还能在开发中少编写一些代码，如果转型失败，也只会返回null。此时，不要继续执行就行了</span>
<span class="token keyword">val</span> str<span class="token operator">:</span> Any <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"str"</span></span>
str<span class="token punctuation">.</span><span class="token function">let</span><span class="token punctuation">{<!-- --></span> it <span class="token keyword">as</span><span class="token operator">?</span> String <span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span><span class="token punctuation">{<!-- --></span> <span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">, str1"</span></span> <span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">also</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><b>run、with、apply：</b>他们都可以在代码块里面访问到调用类的pubic属性和函数。run和with都是将最后一行作为返回值，apply是返回调用者本身。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">var</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span>
<span class="token keyword">val</span> str1<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span> <span class="token punctuation">{<!-- --></span>
    name <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"a"</span></span>
    age <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token punctuation">}</span>
<span class="token keyword">val</span> str2<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token function">with</span><span class="token punctuation">(</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    name <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"a"</span></span>
    age <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token string-literal singleline"><span class="token string">""</span></span>
<span class="token punctuation">}</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{<!-- --></span>
    name <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"a"</span></span>
    age <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这几个方法在android中非常实用，经常用在RecyclerView的onBindViewHolder里面，一般就是：</p> 
<pre><code class="prism language-kotlin">vh<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">{<!-- --></span>
    entity<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">{<!-- --></span>
        name_tv<span class="token punctuation">.</span>text <span class="token operator">=</span> name
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样就不用每次都调用ViewHolder和Entity了。</p> 
<p><b>takeIf：</b>如果false，就返回null。</p> 
<pre><code class="prism language-kotlin">parentFile<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{<!-- --></span> it<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{<!-- --></span>
    parentFile<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，如果文件列表为空，就继续执行，最后删除文件。而如果为null就不继续执行，是一个非常实用的方法。</p> 
<p><b>runCatching：</b>如果执行的过程中出现异常，不会直接抛异常，而是将异常捕获起来，再自己决定要怎么处理这个问题。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">safeToInt</span><span class="token punctuation">(</span>defaultValue<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Int<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">runCatching</span> <span class="token punctuation">{<!-- --></span> 
        <span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">onSuccess</span> <span class="token punctuation">{<!-- --></span> 
        <span class="token comment">// code</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">onFailure</span> <span class="token punctuation">{<!-- --></span> 
        <span class="token comment">// code</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>defaultValue<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里用this调用runCatching之后就可以直接用代码块里面使用String的toInt，执行runCatching之后，返回的是一个Result对象，可以调用该对象的一些方法对结果进行处理。而如果查看Result对象的源码，就可以发现Result是一个value class，所以在这个过程中不会创建对象。<br><br> 除了上面提到的几个方法，runCatching还有其他方法，可以自己去看看。</p> 
<p><b>buildString：</b>会创建一个StringBuilder，可以在代码块里面调用append方法，返回值是String。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> str<span class="token operator">:</span> String <span class="token operator">=</span> buildString <span class="token punctuation">{<!-- --></span>
    <span class="token function">append</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"a"</span></span><span class="token punctuation">)</span>
    <span class="token function">append</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"b"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><b>joinToString：</b>将数组或列表的元素组合成String。比如：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 打印：1, 2, 3</span>
<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">joinToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">also</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span>
</code></pre> 
<p>这个方法有很多个参数，常用参数有第一个和最后一个。第一个参数是分隔符，默认是：", "。最后第一个是返回值，可以不传，会调用对象的toString方法，也可以使用该方法重写拼装成String的逻辑。</p> 
<p><b>repeat：</b>重复n次。</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// it就是次数，从0开始</span>
<span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">printlnt</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><b>TODO：</b>这是一个非常有意思的方法。在java里面，如果一个方法想要防止自己忘记实现，通常可以用todo进行注释，而到了kotlin，就有了TODO方法。使用TODO方法之后，代码不但会变成蓝色，在执行到这行代码之后，还会抛出异常。如果觉得需要通过异常这种方式来提醒自己，就可以这样。</p> 
<p>目前就这些方法吧，平时我在开发中，我也不会留意自己调用了哪些方法，需要的时候自然会想起来，下面是list和Map相关的方法。<br><br> 先说清楚，list有的方法，array大部分也有，所以array也可以调用同样的方法。<br><br> <b>listOf相关的方法：</b>通过可变数组构建一个list。除了listOf，还有mutableListOf、arrayListOf、emptyList、linkedSetOf。这些都是构建一个普通的list。</p> 
<p><b>listOfNotNull相关的方法：</b>这个方法会将传入的元素过滤一下，保证list里面没有空元素，是一个非常实用的方法，例子：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> realSecond <span class="token operator">=</span> it <span class="token operator">/</span> <span class="token number">1000L</span>
<span class="token keyword">val</span> second <span class="token operator">=</span> realSecond <span class="token operator">%</span> <span class="token number">60</span>
<span class="token keyword">val</span> min <span class="token operator">=</span> realSecond <span class="token operator">%</span> <span class="token number">3600</span> <span class="token operator">/</span> <span class="token number">60</span>
<span class="token keyword">val</span> hour <span class="token operator">=</span> realSecond <span class="token operator">%</span> <span class="token number">86400</span> <span class="token operator">/</span> <span class="token number">3600</span>
<span class="token keyword">val</span> day <span class="token operator">=</span> realSecond <span class="token operator">/</span> <span class="token number">86400</span>
<span class="token function">listOfNotNull</span><span class="token punctuation">(</span>
    day<span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{<!-- --></span>it <span class="token operator">!=</span> <span class="token number">0L</span><span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{<!-- --></span>it <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"天"</span></span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    hour<span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{<!-- --></span>it <span class="token operator">!=</span> <span class="token number">0L</span><span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{<!-- --></span>it <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"小时"</span></span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    min<span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{<!-- --></span>it <span class="token operator">!=</span> <span class="token number">0L</span><span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{<!-- --></span>it <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"分钟"</span></span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    second<span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{<!-- --></span>it <span class="token operator">!=</span> <span class="token number">0L</span><span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{<!-- --></span>it <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"秒"</span></span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">joinToString</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it<span class="token punctuation">.</span>first</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it<span class="token punctuation">.</span>second</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">}</span>
</code></pre> 
<p>这里的it类型是Long，这里的需求就是计算出几天几时几分几秒。使用listOfNotNull和takeIf就可以保证list里面的数据不为空且数值不是0，然后再调用joinToString方法拼装成一个字符串。</p> 
<p><b>forEach相关的方法：</b>用来遍历list。</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// forEach</span>
<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">// forEachIndexed</span>
<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEachIndexed</span> <span class="token punctuation">{<!-- --></span> index<span class="token punctuation">,</span> it <span class="token operator">-&gt;</span>  <span class="token punctuation">}</span>

<span class="token comment">// indices，通过indices方法可以来遍历list的角标</span>
<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>indices<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{<!-- --></span>  <span class="token punctuation">}</span>
</code></pre> 
<p><b>map：</b>进行类型转换。</p> 
<pre><code class="prism language-kotlin"><span class="token comment">// 这样就可以将一个List&lt;Int&gt;转换成一个List&lt;String&gt;</span>
<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">{<!-- --></span> it<span class="token punctuation">.</span>toString <span class="token punctuation">}</span>

<span class="token comment">// mapNotNull，过滤空数据，注意，mapNotNull之前的空数据还会保留，只有map过程中的空数据才会被过滤掉</span>
<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapNotNull</span> <span class="token punctuation">{<!-- --></span> it<span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{<!-- --></span> it <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span>
<span class="token comment">// 1 3</span>

<span class="token comment">// mapTo</span>
<span class="token comment">// 1 2 3</span>
<span class="token keyword">val</span> list <span class="token operator">=</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapTo</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>it<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span>
</code></pre> 
<p>map还有mapIndexed、mapIndexedNotNull等方法，从名字也可以看出有什么用，我就不提供示例代码了。</p> 
<p><b>filter：</b>过滤数据</p> 
<pre><code class="prism language-kotlin"><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{<!-- --></span> it <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span>
<span class="token comment">// 1 3</span>

<span class="token comment">// filterNot则是相反的结果</span>
<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filterNot</span> <span class="token punctuation">{<!-- --></span> it <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span>
<span class="token comment">// 2</span>

<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filterNotNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span>
<span class="token comment">// 1 2 3</span>

<span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token string-literal singleline"><span class="token string">"str"</span></span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>filterIsInstance<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span>
<span class="token comment">// 1 2 3</span>
</code></pre> 
<p>filter还有filterTo、filterIndexed等方法。</p> 
<p><b>get相关的方法：</b>get相关里面，有一个是getOrNull方法。我认为这类方法是非常重要的，使用这类方法，可以有效防止越界异常。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>

<span class="token comment">// 两种写法</span>
list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

<span class="token comment">// 获取第1个元素</span>
list<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 如果不希望获取时发生越界，可以调用firstOrNull。此时，如果没第1个元素，就会返回空</span>
list<span class="token punctuation">.</span><span class="token function">firstOrNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 获取最后一个元素</span>
list<span class="token punctuation">.</span><span class="token function">last</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
list<span class="token punctuation">.</span><span class="token function">lastOrNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>first和last都有一个带有匿名函数参数的方法，意思是，从头/伟寻找符合要求的元素，如果找到了，就会返回，否则就抛异常</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">first</span> <span class="token punctuation">{<!-- --></span> it <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">}</span>
</code></pre> 
<p>它们也有orNull方法，如果不希望抛异常，就可以使用orNull方法。<br><br> 除了first和last，也有getOrNull和getOrElse方法，</p> 
<pre><code class="prism language-kotlin">list<span class="token punctuation">.</span><span class="token function">getOrNull</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>

<span class="token keyword">val</span> result <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token number">5</span><span class="token punctuation">}</span>
<span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token comment">// 5</span>
</code></pre> 
<p>在日常开发中，如果需要通过角标获取元素，我更喜欢用orNull方法，这样就可以尽量避免程序在运行时出现异常。在调用orNull之后，再调用“?”判断即可，写起来也不费劲。</p> 
<p><b>take和takeLast：</b>take就是获取前n个元素。takeLast就是获取后n个元素。和sublist是一样的，但在这里，需要传一个n的参数。</p> 
<p><b>groupBy：</b>从方法名称就可以看出，这个方法是做数据归集的。归集后是一个Map&lt;T,List&gt;。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">listOf</span><span class="token punctuation">(</span>
        <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"str"</span></span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"str1"</span></span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"str2"</span></span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"str3"</span></span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"str4"</span></span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">groupBy</span> <span class="token punctuation">{<!-- --></span> it<span class="token punctuation">.</span>age <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it<span class="token punctuation">.</span>key</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it<span class="token punctuation">.</span>value</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token operator">=</span>str<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token operator">=</span>str2<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token operator">=</span>str4<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token operator">=</span>str1<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token operator">=</span>str3<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre> 
<p>这里的key就是age，value就是List&lt;Person&gt;。</p> 
<p><b>find方法：</b>这里的find和上面提到的first{}有点像，都是从list里面寻找合适的元素。但区别是：find当找不到时，会返回空，而不是抛出异常。这个方法还是非常实用的，可以用来从列表寻找目标对象，比如：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token keyword">get</span><span class="token punctuation">(</span>path<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">find</span> <span class="token punctuation">{<!-- --></span> it<span class="token punctuation">.</span>path <span class="token operator">==</span> path <span class="token punctuation">}</span>
</code></pre> 
<p><b>any：</b>从list寻找合适的元素，如果找到，返回true，都没有找到返回false。适合用来判断list是否有某个元素符合要求。</p> 
<p><b>all：</b>遍历list所有的元素，如果所有元素都符合要求，返回true，否则返回false。使用用来判断list里面所有的元素是否符合要求。</p> 
<p>List还有很多方法， 我也没办法一一例举，剩下的可以自己随便点list的某个方法，然后看看kt文件里面还有什么方法。</p> 
<p><b>Map相关的方法：</b><br><br> <b>构建map：</b>有一种非常简单的构建map的方法。</p> 
<pre><code class="prism language-kotlin"><span class="token function">mapOf</span><span class="token punctuation">(</span>
    <span class="token number">1</span> <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"a"</span></span><span class="token punctuation">,</span>
    <span class="token number">2</span> <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"b"</span></span><span class="token punctuation">,</span>
    <span class="token number">3</span> <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"c"</span></span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre> 
<p>使用to就可以轻松地构建一个map。</p> 
<p><b>遍历map：</b>遍历map不再需要向java那样麻烦，只需调用map的forEach方法，就可以轻松遍历。</p> 
<pre><code class="prism language-kotlin">map<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{<!-- --></span> key<span class="token punctuation">,</span> value <span class="token operator">-&gt;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">key</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

map<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it<span class="token punctuation">.</span>key</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it<span class="token punctuation">.</span>value</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> map<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">key</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">value</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><b>get方法：</b>get就没有getOrNull这样的方法，只有getOrDefault和getOrElse方法。而map获取元素和设置元素还能像在使用array一样：</p> 
<pre><code>val map = HashMap&lt;Int, String&gt;()
map[1] = "a"
val a = map[1]
</code></pre> 
<p><b>map方法：</b>，Map的map方法返回的是List</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> map <span class="token operator">=</span> <span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"a"</span></span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"b"</span></span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token keyword">to</span> <span class="token string-literal singleline"><span class="token string">"c"</span></span><span class="token punctuation">,</span><span class="token punctuation">)</span>
map<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{<!-- --></span> <span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it<span class="token punctuation">.</span>key</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it<span class="token punctuation">.</span>value</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">)</span>

<span class="token comment">// 1a 2b 3c</span>
</code></pre> 
<p>除了上面提到的方法，map还有filter、any、all等方法可以使用，但相对来说，没有List的方法那么多。</p> 
<p><b>File相关的方法：</b>kotlin还为File提供了几个特别有用的方法<br><br> <b>writer和bufferWriter：</b></p> 
<pre><code>val file = File("")
val writer = file.writer()
writer.write("")
writer.close()

val writer = file.bufferedWriter()
writer.write("")
writer.newLine()
writer.close()
</code></pre> 
<p>可以看到，想要使用文件写入数据，只需简简单单的一句writer或bufferedWriter，就可以完成，而不用像java那样写一堆代码。</p> 
<p><b>readLines：</b>readLines也是一个非常实用的方法，只需一行，就能将一个文件读到内存中。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> file <span class="token operator">=</span> <span class="token function">File</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span>
<span class="token keyword">val</span> lines<span class="token operator">:</span>List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">readLines</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果想要合并lines，就可以使用上面提到的joinToString方法</p> 
<pre><code class="prism language-kotlin">lines<span class="token punctuation">.</span><span class="token function">joinToString</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">""</span></span><span class="token punctuation">)</span>
</code></pre> 
<p><b>delete：</b>kotlin提供了删除整个文件夹的api，想要删除一整个文件夹，只需调用deleteRecursively方法即可，而不用手动做文件收集再删除。</p> 
<p><b>copy：</b>既然删除可以删除整个文件夹，那复制也可以复制整个文件夹，可以调用copyRecursivel来复制整个文件夹。</p> 
<p><b>walk方法：</b>walk方法可以收集整个文件夹里面所有的文件。walk还有一个walkBottomUp方法，意思是倒序排序。</p> 
<h4 id="coroutineandflow">kotlin协程和flow</h4> 具体教程就不写了，需要的自己查，后续我看看的之前记的笔记写得怎么样，如果比较好就写出来。协程就是执行异步任务的库，flow是基于协程，实现异步数据处理的库。 
<br> 用协程来代替开发中一些异步任务还是很好用的，而且协程还能将异步代码写成同步代码而又不阻塞当前线程，从减少Listener相关的代码。这样就不会让代码出现一个Listener套一个Listener，最后出现n层嵌套的问题。 
<h4 id="ktxid">KTX</h4> 
<p>只是介绍一下KTX，不打算写教程，我平时在用一些API也很少会注意是不是KTX的API。<br> <a href="https://developer.android.google.cn/kotlin/ktx?hl=zh-cn" rel="nofollow">官网</a>。 官方介绍：Android KTX 是包含在 Android Jetpack 及其他 Android 库中的一组 Kotlin 扩展程序。KTX 扩展程序可以为 Jetpack、Android 平台及其他 API 提供简洁的惯用 Kotlin 代码。为此，这些扩展程序利用了多种 Kotlin 语言功能，其中包括：</p> 
<ul><li>扩展函数</li><li>扩展属性</li><li>Lambda</li><li>命名参数</li><li>参数默认值</li><li>协程</li></ul> 
<p>所以如果想要更好地使用kotlin，最好还是学一下KTX。</p> 
<h4><a id="_1630"></a>最后再说几句</h4> 
<p>使用了kotlin写代码之后，就要用好的kotlin的特性，可以去知乎查一下kotlin的奇淫技巧，有一些编码方式虽然不是很推荐，但可以打开的自己脑洞，帮助自己用好kotlin的特性。<br> 像扩展函数也要多用，必要时，也要自己定义扩展函数，我在开发中自己定义的扩展函数是非常多的。还要用好if-else、try-catch、when这些表达式，这些可以将最后一行作为返回值，而when的语法变为更加简洁，所以是非常好用的。<br> 如果还是带着java的思维在写kotlin的代码，那开发效率和编写出来的代码就和用java差不多。有些人在用kotlin之后，还是带着java的思维在编码，事后就说kotlin也不怎么样啊。<br> 就先写这些，这篇文章我也是边写边想写出来的，而不是去查看官方文档，如果想要看看还有什么内容漏了，可以看看kotlin中文站，后面我想到什么内容也会补上来。</p> 
<p><a href="https://github.com/nanjolnoSat/PersonalProject">html dsl</a>：这个项目是我今年(23年)年初闲着没事写出来的工具，用kotlin代码生成html代码。里面所有的代码都是用kotlin写的，如果不知道要阅读什么源码，这个项目或许可以帮助到您。</p> 
<p><b>补充一点代码格式化的内容：</b><br> 建议不要使用kotlin的代码格式化，否则会变得不幸。kotlin的android studio代码格式化做得挺差的，不管怎么调教，都没办法调出一个想要的效果。<br> java的代码格式化就做得比较好，java在第一次格式化时，只会处理空格、缩进这些问题，只有第2次才会按照android studio的设置对代码进行格式化。<br> 通常情况下，只需第一次格式化就行了，第2次格式化可能会打乱我们的代码风格。而kotlin就直接一步到位，没有了第1步，导致我经常在使用kotlin的格式化之后血压升高。<br> 举个例子：</p> 
<pre><code class="prism language-java"><span class="token class-name">StringBuilder</span> sb<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token comment">//  第一次格式化时，会变成</span>
<span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       
<span class="token comment">// 只有第二次格式化时，才可能变成</span>
sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>而如果使用kotlin，并切设置成链式调用不换行，就会一步到位执行到第2次格式化的结果，但有时我们就是想要保持换行的效果。<br> 这样的例子在kotlin有一堆，所以也导致之后，通常在格式化之后血压升高。而我在日常开发中，也有补上空格的习惯，所以对我来说，格式化可有可无。<br> 只不过在写代码的时候，有时有所疏忽，导致需要用工具格式化。但这样的代码不多，所以对我来说，格式化不是必须的。但如果真的需要，就还是用吧。<br> kotlin代码格式化的配置在：settings -&gt; Editor -&gt; Code Style -&gt; Kotlin。这里面有各种配置，可以自己慢慢调教。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bdb54f78b8776fa4dc250cfb792c41ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【WEEK1】学习目标及总结【SpringMVC】【中文版】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0079038f04703a86df170c8944bd1b83/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Lvs--部署DR集群</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>