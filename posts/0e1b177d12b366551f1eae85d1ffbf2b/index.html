<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>最详细的Jvm总结 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/0e1b177d12b366551f1eae85d1ffbf2b/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="最详细的Jvm总结">
  <meta property="og:description" content="目录 一、Java的运行路径二、编译原理三丶类加载机制装载：链接：(1)、验证(Verify)：(2)、准备(Prepare)(3)、解析(Resolve) 初始化 四丶类加载器(classloader)加载原则(双亲委派)父类委托机制破坏双亲委派 五丶运行时数据区(Run-Time Data Areas)Method Area(方法区)Heap(堆)Stacks(虚拟机栈)栈针： The pc Register(程序计数器)Native Method Stacks(本地方法栈) 六丶栈，堆，方法区的指向栈指向堆方法区指向堆堆指向方法区 七丶jvm内存模型对象创建过程为什么需要Survivor区?只有Eden不行吗？为什么需要两个Survivor区？新生代中Eden:S1:S2为什么是8:1:1？堆内存中都是线程共享的区域吗？ 八丶java对象内存模型九丶垃圾回收1丶如何确定一个对象是垃圾？引用计数法：可达性算法： 2丶什么时候会垃圾回收？四种GC条件满足其一： 3丶垃圾收集算法标记-清除标记：清除：缺点： 标记-复制标记-整理SerialSerial OldParNewParallel ScavengeParallel OldCMSG1(Garbage-First)ZGC 5丶垃圾收集器分类6丶常见问题吞吐量和停顿时间如何选择合适的垃圾收集器如何开启需要的垃圾收集器 十丶JVM参数标准参数-X参数-XX参数其他参数查看参数设置参数的常见方式实践和单位换算 十一丶内存内存溢出(OOM)内存泄露导致内存溢出 十二丶 JVM性能优化指南十三丶常见问题内存泄漏与内存溢出的区别young gc会有stw吗？major gc和full gc的区别什么是直接内存?垃圾判断的方式?不可达的对象一定要被回收吗？为什么要区分新生代和老年代？G1与CMS的区别是什么?方法区中的无用类回收 总结 一、Java的运行路径 java-&amp;gt;class文件-&amp;gt;jvm(虚拟机)-&amp;gt;操作系统-&amp;gt;硬件层面(010101的机器码)。
JVM各种折腾[内部结构、执行方式、垃圾回收、本地调用等]。
特点：一次编译到处运行
二、编译原理 Person.java -&amp;gt; 词法分析器 -&amp;gt; tokens流 -&amp;gt; 语法分析器 -&amp;gt; 语法树/抽象语法树。
-&amp;gt; 语义分析器 -&amp;gt; 注解抽象语法树 -&amp;gt; 字节码生成器 -&amp;gt; Person.class文件。
三丶类加载机制 装载： 查找和导入class文件
（1）通过一个类的全限定名获取定义此类的二进制字节流。
（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
（3）在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。
方法区和堆
Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。在 Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口 （对象不一定都在堆，对象可能在栈上分配）。
链接： (1)、验证(Verify)： 保证被加载类的正确性(贯穿整个流程的过程，要用到的时候才会去验证)
文件格式验证
元数据验证
字节码验证">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-17T14:31:12+08:00">
    <meta property="article:modified_time" content="2023-05-17T14:31:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">最详细的Jvm总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#Java_4" rel="nofollow">一、Java的运行路径</a></li><li><a href="#_11" rel="nofollow">二、编译原理</a></li><li><a href="#_15" rel="nofollow">三丶类加载机制</a></li><li><ul><li><a href="#_17" rel="nofollow">装载：</a></li><li><a href="#_26" rel="nofollow">链接：</a></li><li><ul><li><a href="#1Verify_27" rel="nofollow">(1)、验证(Verify)：</a></li><li><a href="#2Prepare_35" rel="nofollow">(2)、准备(Prepare)</a></li><li><a href="#3Resolve_41" rel="nofollow">(3)、解析(Resolve)</a></li></ul> 
   </li><li><a href="#_49" rel="nofollow">初始化</a></li></ul> 
  </li><li><a href="#classloader_53" rel="nofollow">四丶类加载器(classloader)</a></li><li><ul><li><a href="#_57" rel="nofollow">加载原则(双亲委派)父类委托机制</a></li><li><a href="#_64" rel="nofollow">破坏双亲委派</a></li></ul> 
  </li><li><a href="#RunTime_Data_Areas_67" rel="nofollow">五丶运行时数据区(Run-Time Data Areas)</a></li><li><ul><li><a href="#Method_Area_76" rel="nofollow">Method Area(方法区)</a></li><li><a href="#Heap_87" rel="nofollow">Heap(堆)</a></li><li><a href="#Stacks_95" rel="nofollow">Stacks(虚拟机栈)</a></li><li><ul><li><a href="#_98" rel="nofollow">栈针：</a></li></ul> 
   </li><li><a href="#The_pc_Register_109" rel="nofollow">The pc Register(程序计数器)</a></li><li><a href="#Native_Method_Stacks_115" rel="nofollow">Native Method Stacks(本地方法栈)</a></li></ul> 
  </li><li><a href="#_118" rel="nofollow">六丶栈，堆，方法区的指向</a></li><li><ul><li><a href="#_119" rel="nofollow">栈指向堆</a></li><li><a href="#_121" rel="nofollow">方法区指向堆</a></li><li><a href="#_125" rel="nofollow">堆指向方法区</a></li></ul> 
  </li><li><a href="#jvm_129" rel="nofollow">七丶jvm内存模型</a></li><li><ul><li><a href="#_132" rel="nofollow">对象创建过程</a></li><li><a href="#SurvivorEden_135" rel="nofollow">为什么需要Survivor区?只有Eden不行吗？</a></li><li><a href="#Survivor_141" rel="nofollow">为什么需要两个Survivor区？</a></li><li><a href="#EdenS1S2811_144" rel="nofollow">新生代中Eden:S1:S2为什么是8:1:1？</a></li><li><a href="#_146" rel="nofollow">堆内存中都是线程共享的区域吗？</a></li></ul> 
  </li><li><a href="#java_151" rel="nofollow">八丶java对象内存模型</a></li><li><a href="#_154" rel="nofollow">九丶垃圾回收</a></li><li><ul><li><a href="#1_155" rel="nofollow">1丶如何确定一个对象是垃圾？</a></li><li><ul><li><a href="#_156" rel="nofollow">引用计数法：</a></li><li><a href="#_160" rel="nofollow">可达性算法：</a></li></ul> 
   </li><li><a href="#2_165" rel="nofollow">2丶什么时候会垃圾回收？</a></li><li><ul><li><a href="#GC_168" rel="nofollow">四种GC条件满足其一：</a></li></ul> 
   </li><li><a href="#3_173" rel="nofollow">3丶垃圾收集算法</a></li><li><ul><li><a href="#_174" rel="nofollow">标记-清除</a></li><li><ul><li><a href="#_175" rel="nofollow">标记：</a></li><li><a href="#_177" rel="nofollow">清除：</a></li><li><a href="#_179" rel="nofollow">缺点：</a></li></ul> 
    </li><li><a href="#_185" rel="nofollow">标记-复制</a></li><li><a href="#_191" rel="nofollow">标记-整理</a></li><li><ul><li><a href="#Serial_193" rel="nofollow">Serial</a></li><li><a href="#Serial_Old_202" rel="nofollow">Serial Old</a></li><li><a href="#ParNew_205" rel="nofollow">ParNew</a></li><li><a href="#Parallel_Scavenge_213" rel="nofollow">Parallel Scavenge</a></li><li><a href="#Parallel_Old_220" rel="nofollow">Parallel Old</a></li><li><a href="#CMS_223" rel="nofollow">CMS</a></li><li><a href="#G1GarbageFirst_233" rel="nofollow">G1(Garbage-First)</a></li><li><a href="#ZGC_248" rel="nofollow">ZGC</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5_258" rel="nofollow">5丶垃圾收集器分类</a></li><li><a href="#6_269" rel="nofollow">6丶常见问题</a></li><li><ul><li><ul><li><a href="#_270" rel="nofollow">吞吐量和停顿时间</a></li><li><a href="#_277" rel="nofollow">如何选择合适的垃圾收集器</a></li><li><a href="#_287" rel="nofollow">如何开启需要的垃圾收集器</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#JVM_306" rel="nofollow">十丶JVM参数</a></li><li><ul><li><a href="#_307" rel="nofollow">标准参数</a></li><li><a href="#X_313" rel="nofollow">-X参数</a></li><li><a href="#XX_320" rel="nofollow">-XX参数</a></li><li><a href="#_335" rel="nofollow">其他参数</a></li><li><a href="#_342" rel="nofollow">查看参数</a></li><li><a href="#_344" rel="nofollow">设置参数的常见方式</a></li><li><a href="#_353" rel="nofollow">实践和单位换算</a></li></ul> 
  </li><li><a href="#_364" rel="nofollow">十一丶内存</a></li><li><ul><li><a href="#OOM_365" rel="nofollow">内存溢出(OOM)</a></li><li><a href="#_371" rel="nofollow">内存泄露导致内存溢出</a></li></ul> 
  </li><li><a href="#_JVM_382" rel="nofollow">十二丶 JVM性能优化指南</a></li><li><a href="#_385" rel="nofollow">十三丶常见问题</a></li><li><ul><li><a href="#_386" rel="nofollow">内存泄漏与内存溢出的区别</a></li><li><a href="#young_gcstw_390" rel="nofollow">young gc会有stw吗？</a></li><li><a href="#major_gcfull_gc_394" rel="nofollow">major gc和full gc的区别</a></li><li><a href="#_398" rel="nofollow">什么是直接内存?</a></li><li><a href="#_402" rel="nofollow">垃圾判断的方式?</a></li><li><a href="#_406" rel="nofollow">不可达的对象一定要被回收吗？</a></li><li><a href="#_410" rel="nofollow">为什么要区分新生代和老年代？</a></li><li><a href="#G1CMS_414" rel="nofollow">G1与CMS的区别是什么?</a></li><li><a href="#_418" rel="nofollow">方法区中的无用类回收</a></li></ul> 
  </li><li><a href="#_424" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="Java_4"></a>一、Java的运行路径</h2> 
<p>  java-&gt;class文件-&gt;jvm(虚拟机)-&gt;操作系统-&gt;硬件层面(010101的机器码)。<br>   JVM各种折腾[内部结构、执行方式、垃圾回收、本地调用等]。<br> 特点：一次编译到处运行<br> <img src="https://images2.imgbox.com/93/a4/f68jIdeH_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_11"></a>二、编译原理</h2> 
<p>  Person.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树/抽象语法树。<br> -&gt; 语义分析器 -&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Person.class文件。<br> <img src="https://images2.imgbox.com/6f/b7/MLIJiEpp_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_15"></a>三丶类加载机制</h2> 
<p><img src="https://images2.imgbox.com/28/47/fv7ynH0s_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_17"></a>装载：</h3> 
<p>查找和导入class文件<br> （1）通过一个类的全限定名获取定义此类的二进制字节流。<br> （2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br> （3）在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p> 
<p><strong>方法区和堆</strong><br>   Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。在 Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口 （对象不一定都在堆，对象可能在栈上分配）。<br> <img src="https://images2.imgbox.com/b1/77/DqIue1qY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_26"></a>链接：</h3> 
<h4><a id="1Verify_27"></a>(1)、验证(Verify)：</h4> 
<blockquote> 
 <p>保证被加载类的正确性(贯穿整个流程的过程，要用到的时候才会去验证)</p> 
</blockquote> 
<p>文件格式验证<br> 元数据验证<br> 字节码验证<br> 符号引用验证</p> 
<h4><a id="2Prepare_35"></a>(2)、准备(Prepare)</h4> 
<blockquote> 
 <p>为类的静态变量分配内存，并将其初始化为默认值</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ef/08/DI9CAGBF_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>注：没有赋值但是不是静态就不行，编译不通过</p> 
</blockquote> 
<h4><a id="3Resolve_41"></a>(3)、解析(Resolve)</h4> 
<blockquote> 
 <p>把类中的符号引用转换为直接引用<br> 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。<br> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行</p> 
</blockquote> 
<p>  符号引用就是一组符号来描述目标，可以是任何字面量。<br>   直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p> 
<h3><a id="_49"></a>初始化</h3> 
<blockquote> 
 <p>对类的静态变量，静态代码块执行初始化操作<br> <img src="https://images2.imgbox.com/2e/fe/qi7yducB_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="classloader_53"></a>四丶类加载器(classloader)</h2> 
<blockquote> 
 <p>  在装载(Load)阶段，其中第(1)步:通过类的全限定名获取其定义的二进制字节流，需要借助类装载器完成，顾名思义，就是用来装载Class文件的。<br> <img src="https://images2.imgbox.com/c4/27/2cl1NEIF_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_57"></a>加载原则(双亲委派)父类委托机制</h3> 
<ol><li>检查某个类是否已经加载</li></ol> 
<blockquote> 
 <p>  自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个Classloader已加载，就视为已加载此类，保证此类所有ClassLoader加载一次。</p> 
</blockquote> 
<ol start="2"><li>加载的顺序</li></ol> 
<blockquote> 
 <p>自顶向下，也就是由上层来逐层尝试加载此类</p> 
</blockquote> 
<h3><a id="_64"></a>破坏双亲委派</h3> 
<p>  复写，spi服务提供接口(java虚拟机时java的基石)可扩展能力，osgi(复写，热更新，热部署)。</p> 
<h2><a id="RunTime_Data_Areas_67"></a>五丶运行时数据区(Run-Time Data Areas)</h2> 
<p>在装载阶段的第(2),(3)步可以发现有运行时数据，堆，方法区等名词 。</p> 
<p>(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br> (3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口 。<br> 说白了就是类文件被类装载器装载进来之后，类中的内容(比如变量，常量，方法，对象等这些数据得要 。</p> 
<p>有个去处，也就是要存储起来，存储的位置肯定是在JVM中有对应的空间) 。<br> <img src="https://images2.imgbox.com/92/c4/wIR3kjEy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Method_Area_76"></a>Method Area(方法区)</h3> 
<p>(1)方法区是各个线程共享的内存区域，在虚拟机启动时创建<br> (2)虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap(非 堆)，目的是与Java堆区分开来<br> (3)用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据<br> (4)当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常<br> 此时回看装载阶段的第2步，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br> 如果这时候把从Class文件到装载的第(1)和(2)步合并起来理解的话，可以画个图</p> 
<p><img src="https://images2.imgbox.com/4c/41/21MUnkWh_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>JVM运行时数据区是一种规范，真正的实现 在JDK 8中就是Metaspace，在JDK6或7中就是Perm Space</p> 
</blockquote> 
<h3><a id="Heap_87"></a>Heap(堆)</h3> 
<p>(1)Java堆是Java虚拟机所管理内存中最大的一块，在虚拟机启动时创建，被所有线程共享。<br> (2)Java对象实例以及数组都在堆上分配。<br> 此时回看装载阶段的第3步，在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</p> 
<p><img src="https://images2.imgbox.com/b1/8b/ygj0uHxN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Stacks_95"></a>Stacks(虚拟机栈)</h3> 
<p>(1)虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个Java线程的运行状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着线程的创建而创建。<br> (2)每一个被线程执行的方法，为该栈中的栈帧，即每个方法对应一个栈帧。调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出</p> 
<h4><a id="_98"></a>栈针：</h4> 
<p>栈帧：每个栈帧对应一个被调用的方法，可以理解为一个方法的运行空间<br> 每个栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向运行时常量池的引用(A)<br> reference to the run-time constant pool)、方法返回地址(Return Address)和附加信息。</p> 
<blockquote> 
 <p>1.局部变量表:方法中定义的局部变量以及方法的参数存放在这张表中 局部变量表中的变量不可直接使用，如需要使用的话，必须通过相关指令将其加载至操作数栈中作为操作数使 用。<br> 2.操作数栈:以压栈和出栈的方式存储操作数的<br> 3.动态链接:每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用 过程中的动态连接(Dynamic Linking)。 (符号引用转变为直接引用)前面的解析找不到C 只能在动态这里从a找到c（多级调用是动态的）（支持方法多层级调用）<br> <img src="https://images2.imgbox.com/cc/87/34zkkyfQ_o.png" alt="在这里插入图片描述"><br> 4.方法返回地址:当一个方法开始执行后,只有两种方式可以退出，一种是遇到方法返回的字节码指令；一种是遇 见异常，并且这个异常没有在方法体内得到处理。<br> <img src="https://images2.imgbox.com/61/9c/6r4rw5N5_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="The_pc_Register_109"></a>The pc Register(程序计数器)</h3> 
<p>  我们都知道一个JVM进程中有多个线程在执行，而线程中的内容是否能够拥有执行权，是根据CPU调度来的。<br>   假如线程A正在执行到某个地方，突然失去了CPU的执行权，切换到线程B了，然后当线程A再获得CPU执行权的时候，怎么能继续执行呢？这就是需要在线程中维护一个变量，记录线程执行到的位置。<br>   如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；<br> 如果正在执行的是Native(本地方法)方法，则这个计数器为空。</p> 
<h3><a id="Native_Method_Stacks_115"></a>Native Method Stacks(本地方法栈)</h3> 
<p>  如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行。</p> 
<h2><a id="_118"></a>六丶栈，堆，方法区的指向</h2> 
<h3><a id="_119"></a>栈指向堆</h3> 
<p>  如果在栈帧中有一个变量，类型为引用类型，比如Object obj=new Object()，这时候就是典型的栈中元素指向堆中的对象。</p> 
<h3><a id="_121"></a>方法区指向堆</h3> 
<p>  方法区中会存放静态变量，常量等数据。如果是下面这种情况，就是典型的方法区中元素指向堆中的对象。<br> private static Object obj=new Object();</p> 
<h3><a id="_125"></a>堆指向方法区</h3> 
<p>What？堆还能指向方法区？<br>   注意，方法区中会包含类的信息，堆中会有对象，那怎么知道对象是哪个类创建的呢？</p> 
<h2><a id="jvm_129"></a>七丶jvm内存模型</h2> 
<p>重点存储数据的是堆和方法区(非堆)<br> <img src="https://images2.imgbox.com/3f/53/XSVXK8GA_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_132"></a>对象创建过程</h3> 
<p>  一般情况下，新创建的对象都会被分配到Eden区，一些特殊的大的对象会直接分配到Old区。<br> <img src="https://images2.imgbox.com/66/ec/F6TksUtW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="SurvivorEden_135"></a>为什么需要Survivor区?只有Eden不行吗？</h3> 
<ol><li>如果没有Survivor,Eden区每进行一次Minor GC,存活的对象就会被送到老年代。</li><li>这样一来，老年代很快被填满,触发Major GC(因为Major GC一般伴随着Minor GC,也可以看做触发了Full GC)。 只有经历16次Minor GC还能在新生代中存活的对象,才会被送到老年代。</li><li>Full GC(完全GC)=oldGc+YoungGc+MetaSpace(直接内存)</li></ol> 
<h3><a id="Survivor_141"></a>为什么需要两个Survivor区？</h3> 
<p>最大的好处就是解决了碎片化。<br> 永远有一个Survivor space是空的,另一个非空的Survivor space无碎片。</p> 
<h3><a id="EdenS1S2811_144"></a>新生代中Eden:S1:S2为什么是8:1:1？</h3> 
<p>收集算法来回收新生代</p> 
<h3><a id="_146"></a>堆内存中都是线程共享的区域吗？</h3> 
<p>JVM默认为每个线程在Eden上开辟一个buffer区域，用来加速对象的分配，称之为TLAB，全称:Thread<br> Local Allocation Buffer。<br> 对象优先会在TLAB上分配，但是TLAB空间通常会比较小，如果对象比较大，那么还是在共享区域分配。</p> 
<h2><a id="java_151"></a>八丶java对象内存模型</h2> 
<p>一个Java对象在内存中包括3个部分：对象头、实例数据和对齐填充（保证8的字节的倍数）（内存读取效率更高）<br> <img src="https://images2.imgbox.com/bd/3f/m0S2WH0v_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_154"></a>九丶垃圾回收</h2> 
<h3><a id="1_155"></a>1丶如何确定一个对象是垃圾？</h3> 
<h4><a id="_156"></a>引用计数法：</h4> 
<p>对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任何指针对其引用，它就是垃圾。</p> 
<p><strong>弊端 :</strong> 如果AB相互持有引用，导致永远不能被回收。</p> 
<h4><a id="_160"></a>可达性算法：</h4> 
<p>通过GC Root的对象，开始向下寻找，看某个对象是否可作为GC Root:类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等。一条引用链(只有在这条链上就不是垃圾)<br> GCroot：不是根对象，可以是（局部变量表元素，静态变量，常量，本地方法栈的JNI（本地接口，本地方法））直接或者间接用到的对象<br> 可达性：单向链表</p> 
<h3><a id="2_165"></a>2丶什么时候会垃圾回收？</h3> 
<p>GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。<br> 调用System.gc()方法通知JVM进行一次垃圾回收</p> 
<h4><a id="GC_168"></a>四种GC条件满足其一：</h4> 
<p>（1）当Eden区或者S区不够用了<br> （2）老年代空间不够用了<br> （3）方法区空间不够用了<br> （4）System.gc()</p> 
<h3><a id="3_173"></a>3丶垃圾收集算法</h3> 
<h4><a id="_174"></a>标记-清除</h4> 
<h5><a id="_175"></a>标记：</h5> 
<p>找出内存中需要回收的对象，并且把它们标记出来-----此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时</p> 
<h5><a id="_177"></a>清除：</h5> 
<p>清除掉被标记需要回收的对象，释放出对应的内存空间</p> 
<h5><a id="_179"></a>缺点：</h5> 
<p>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程<br> 序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br> (1)标记和清除两个过程都比较耗时，效率不高<br> (2)会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无<br> 法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p> 
<h4><a id="_185"></a>标记-复制</h4> 
<p>将内存划分为两块相等的区域，每次只使用其中一块<br> 当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次清除掉。</p> 
<p><strong>缺点:</strong> 空间利用率降低。</p> 
<h4><a id="_191"></a>标记-整理</h4> 
<blockquote> 
 <p>随机整理(不连续性)，线行整理（234放一起，不管有没有内存随便），滑动整理（滑到一段，其他全部干掉）</p> 
</blockquote> 
<h5><a id="Serial_193"></a>Serial</h5> 
<blockquote> 
 <p>它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更<br> 重要的是其在进行垃圾收集的时候需要暂停其他线程。<br> 优点：简单高效，拥有很高的单线程收集效率<br> 缺点：收集过程需要暂停所有线程<br> 算法：复制算法<br> 适用范围：新生代<br> 应用：Client模式下的默认新生代收集器</p> 
</blockquote> 
<h5><a id="Serial_Old_202"></a>Serial Old</h5> 
<blockquote> 
 <p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用"<strong>标记</strong>-<strong>整理算法</strong>"，运行过程和Serial收集器一样。</p> 
</blockquote> 
<h5><a id="ParNew_205"></a>ParNew</h5> 
<blockquote> 
 <p>可以把这个收集器理解为Serial收集器的多线程版本<br> <strong>优点：</strong> 在多CPU时，比Serial效率高。<br> <strong>缺点：</strong> 收集过程暂停所有应用程序线程，单CPU时比Serial效率差。<br> <strong>算法：</strong> 复制算法<br> <strong>适用范围：</strong> 新生代<br> <strong>应用：</strong> 运行在Server模式下的虚拟机中首选的新生代收集器</p> 
</blockquote> 
<h5><a id="Parallel_Scavenge_213"></a>Parallel Scavenge</h5> 
<p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注系统的<strong>吞吐量</strong>。</p> 
<blockquote> 
 <p>吞吐量=运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%。若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。</p> 
</blockquote> 
<p>-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间，<br> -XX:GCRatio直接设置吞吐量的大小。</p> 
<h5><a id="Parallel_Old_220"></a>Parallel Old</h5> 
<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和<strong>标记</strong>-<strong>整理算法</strong>进行垃圾回收，也是更加关注系统的<strong>吞吐量</strong>。</p> 
<h5><a id="CMS_223"></a>CMS</h5> 
<p>采用的是"标记-清除算法",整个过程分为4步</p> 
<blockquote> 
 <p>(1)初始标记 CMS initial mark 标记GC Roots直接关联对象，不用Tracing，速度很快<br> (2)并发标记 CMS concurrent mark 进行GC Roots Tracing<br> (3)重新标记 CMS remark 修改并发标记因用户程序变动的内容<br> (4)并发清除 CMS concurrent sweep 清除不可达对象回收空间，同时有新垃圾产生，留着下次清理称为 浮动垃圾</p> 
</blockquote> 
<p><strong>优点：</strong> 并发收集、低停顿<br> <strong>缺点：</strong> 产生大量空间碎片、并发阶段会降低吞吐量</p> 
<h5><a id="G1GarbageFirst_233"></a>G1(Garbage-First)</h5> 
<p>  它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p> 
<blockquote> 
 <p>每个Region大小都是一样的，可以是1M到32M之间的数值，但是必须保证是2的n次幂<br> 如果对象太大，一个Region放不下[超过Region大小的50%]，那么就会直接放到H中<br> 设置Region大小：-XX:G1HeapRegionSize=M<br> 所谓Garbage-Frist，其实就是优先回收垃圾最多的Region区域</p> 
</blockquote> 
<p>（1）分代收集（仍然保留了分代的概念）<br> （2）空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）<br> （3）可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）</p> 
<p><strong>初始标记:</strong> (Initial Marking） 标记以下GC Roots能够关联的对象，并且修改TAMS的值，需要暂 停用户线程<br> <strong>并发标记:</strong> （Concurrent Marking） 从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行<br> <strong>最终标记:</strong> （Final Marking） 修正在并发标记阶段因为用户程序的并发执行导致变动的数据，需暂 停用户线程<br> <strong>筛选回收:</strong> （Live Data Counting and Evacuation） 对各个Region的回收价值和成本进行排序，根据 用户所期望的GC停顿时间制定回收计划</p> 
<h5><a id="ZGC_248"></a>ZGC</h5> 
<p>JDK11新引入的ZGC收集器，不管是物理上还是逻辑上，ZGC中已经不存在新老年代的概念了<br> 会分为一个个page，当进行GC操作时会对page进行压缩，因此没有碎片问题<br> 只能在64位的linux上使用，目前用得还比较少</p> 
<blockquote> 
 <p>（1）可以达到10ms以内的停顿时间要求<br> （2）支持TB级别的内存<br> （3）堆内存变大后停顿时间还是在10ms以内</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/dd/11/2JchNv7D_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5_258"></a>5丶垃圾收集器分类</h3> 
<p><strong>串行收集器</strong>-&gt;Serial和Serial Old<br> 只能有一个垃圾回收线程执行，用户线程暂停。<br> 适用于内存比较小的嵌入式设备<br> <strong>并行收集器</strong>[吞吐量优先]-&gt;Parallel Scanvenge、Parallel Old<br> 多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。适用于科学计算、后台处理等若交互场景 。<br> <strong>并发收集器</strong>[停顿时间优先]-&gt;CMS、G1<br> 用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的时<br> 候不会停顿用户线程的运行。<br> 适用于相对时间有要求的场景，比如Web 。</p> 
<h3><a id="6_269"></a>6丶常见问题</h3> 
<h5><a id="_270"></a>吞吐量和停顿时间</h5> 
<p>停顿时间-&gt;垃圾收集器 进行 垃圾回收终端应用执行响应的时间<br> 吞吐量-&gt;运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p> 
<blockquote> 
 <p>停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验； 高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互 的任务。</p> 
</blockquote> 
<p>小结 :这两个指标也是评价垃圾回收器好处的标准。</p> 
<h5><a id="_277"></a>如何选择合适的垃圾收集器</h5> 
<p>优先调整堆的大小让服务器自己来选择</p> 
<p>如果内存小于100M，使用串行收集器</p> 
<p>如果是单核，并且没有停顿时间要求，使用串行或JVM自己选</p> 
<p>如果允许停顿时间超过1秒，选择并行或JVM自己选</p> 
<p>如果响应时间最重要，并且不能超过1秒，使用并发收集器</p> 
<h5><a id="_287"></a>如何开启需要的垃圾收集器</h5> 
<p>（1）串行</p> 
<p>-XX：+UseSerialGC</p> 
<p>-XX：+UseSerialOldGC</p> 
<p>（2）并行(吞吐量优先)：</p> 
<p>-XX：+UseParallelGC</p> 
<p>-XX：+UseParallelOldGC</p> 
<p>（3）并发收集器(响应时间优先)</p> 
<p>-XX：+UseConcMarkSweepGC</p> 
<p>-XX：+UseG1GC<br> <img src="https://images2.imgbox.com/77/91/79CW8IjT_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="JVM_306"></a>十丶JVM参数</h2> 
<h3><a id="_307"></a>标准参数</h3> 
<blockquote> 
 <p>-version<br> -help<br> -server<br> -cp</p> 
</blockquote> 
<h3><a id="X_313"></a>-X参数</h3> 
<p>-Xint 解释执行</p> 
<p>-Xcomp 第一次使用就编译成本地代码</p> 
<p>-Xmixed 混合模式，JVM自己来决定</p> 
<h3><a id="XX_320"></a>-XX参数</h3> 
<p>a.Boolean类型</p> 
<p>格式：-XX:[±] +或-表示启用或者禁用name属性</p> 
<p>比如：-XX:+UseConcMarkSweepGC 表示启用CMS类型的垃圾回收器</p> 
<p>-XX:+UseG1GC 表示启用G1类型的垃圾回收器</p> 
<p>b.非Boolean类型</p> 
<p>格式：-XX=表示name属性的值是value</p> 
<p>比如：-XX:MaxGCPauseMillis=500</p> 
<h3><a id="_335"></a>其他参数</h3> 
<p>-Xms1000M等价于-XX:InitialHeapSize=1000M</p> 
<p>-Xmx1000M等价于-XX:MaxHeapSize=1000M</p> 
<p>-Xss100等价于-XX:ThreadStackSize=100</p> 
<h3><a id="_342"></a>查看参数</h3> 
<p>java -XX:+PrintFlagsFinal -version &gt; flags.txt</p> 
<h3><a id="_344"></a>设置参数的常见方式</h3> 
<p>开发工具中设置比如IDEA，eclipse</p> 
<p>运行jar包的时候:java -XX:+UseG1GC xxx.jar</p> 
<p>web容器比如tomcat，可以在脚本中的进行设置</p> 
<p>通过jinfo实时调整某个java进程的参数(参数只有被标记为manageable的flags可以被实时修改)</p> 
<h3><a id="_353"></a>实践和单位换算</h3> 
<p>1Byte(字节)=8bit(位)</p> 
<p>1KB=1024Byte(字节)</p> 
<p>1MB=1024KB</p> 
<p>1GB=1024MB</p> 
<p>1TB=1024GB</p> 
<h2><a id="_364"></a>十一丶内存</h2> 
<h3><a id="OOM_365"></a>内存溢出(OOM)</h3> 
<p>一般会有两个原因：</p> 
<p>（1）大并发情况下</p> 
<p>（2）内存泄露导致内存溢出</p> 
<h3><a id="_371"></a>内存泄露导致内存溢出</h3> 
<p>ThreadLocal引起的内存泄露，最终导致内存溢出</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TLController</span> <span class="token punctuation">{<!-- --></span> 
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/tl"</span><span class="token punctuation">)</span> 
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">tl</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token class-name">Byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> tl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token class-name">Byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1MB tl.set(new Byte[1024*1024]); return "ok"; </span>
    <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_JVM_382"></a>十二丶 JVM性能优化指南</h2> 
<p><img src="https://images2.imgbox.com/d4/f8/1vyQ7blf_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_385"></a>十三丶常见问题</h2> 
<h3><a id="_386"></a>内存泄漏与内存溢出的区别</h3> 
<blockquote> 
 <p>内存泄漏是指不再使用的对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。 内存泄漏很容易导致内存溢出，但内存溢出不一定是内存泄漏导致的。</p> 
</blockquote> 
<h3><a id="young_gcstw_390"></a>young gc会有stw吗？</h3> 
<blockquote> 
 <p>不管什么 GC，都会发送 stop-the-world，区别是发生的时间长短。而这个时间跟垃圾收集器又有关 系，Serial、PartNew、Parallel Scavenge 收集器无论是串行还是并行，都会挂起用户线程，而 CMS 和 G1 在并发标记时，是不会挂起用户线程的，但其它时候一样会挂起用户线程，stop the world 的时 间相对来说就小很多了。</p> 
</blockquote> 
<h3><a id="major_gcfull_gc_394"></a>major gc和full gc的区别</h3> 
<blockquote> 
 <p>Major GC在很多参考资料中是等价于 Full GC 的，我们也可以发现很多性能监测工具中只有 Minor GC 和 Full GC。一般情况下，一次 Full GC 将会对年轻代、老年代、元空间以及堆外内存进行垃圾回收。触 发 Full GC 的原因有很多：当年轻代晋升到老年代的对象大小，并比目前老年代剩余的空间大小还要大 时，会触发 Full GC；当老年代的空间使用率超过某阈值时，会触发 Full GC；当元空间不足时（JDK1.7 永久代不足），也会触发 Full GC；当调用 System.gc() 也会安排一次 Full GC。</p> 
</blockquote> 
<h3><a id="_398"></a>什么是直接内存?</h3> 
<blockquote> 
 <p>Java的NIO库允许Java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通 常访问直接内存的速度会优于Java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内 存。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是 有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存</p> 
</blockquote> 
<h3><a id="_402"></a>垃圾判断的方式?</h3> 
<blockquote> 
 <p>引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为0就会回收但是JVM没 有用这种方式，因为无法判定相互循环引用（A引用B,B引用A）的情况。 引用链法： 通过一种GC ROOT的对象（方法区中静态变量引用的对象等-static变量）来判断，如果有 一条链能够到达GC ROOT就说明，不能到达GC ROOT就说明可以回收。</p> 
</blockquote> 
<h3><a id="_406"></a>不可达的对象一定要被回收吗？</h3> 
<blockquote> 
 <p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真 正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行 一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个 对象建立关联，否则就会被真的回收。</p> 
</blockquote> 
<h3><a id="_410"></a>为什么要区分新生代和老年代？</h3> 
<blockquote> 
 <p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不 同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合 适的垃圾收集算法。 比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制 成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分 配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集</p> 
</blockquote> 
<h3><a id="G1CMS_414"></a>G1与CMS的区别是什么?</h3> 
<blockquote> 
 <p>CMS 主要集中在老年代的回收，而 G1 集中在分代回收，包括了年轻代的 Young GC 以及老年代的 Mix GC；G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的 产生；在初始化标记阶段，搜索可达对象使用到的 Card Table，其实现方式不一样</p> 
</blockquote> 
<h3><a id="_418"></a>方法区中的无用类回收</h3> 
<blockquote> 
 <p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。 类需要同时满足下面 3 个条件才能算是 “无用的类” : a-该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 b-加载该类的 ClassLoader 已经被回收。 c-该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p> 
</blockquote> 
<hr> 
<h2><a id="_424"></a>总结</h2> 
<p>例如：以上就是今天要讲的JVM内容，希望对大家有所帮助，希望大家点赞支持一下作者谢谢！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/685bccaa845d3f3a3f9cb52ee1c07b90/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言实现rsa加密</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ebce54bb71a9d607293a1ad4943359d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java基础教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>