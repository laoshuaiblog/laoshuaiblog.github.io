<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>负数-补码 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/dca0c4fdb7993ad147fc5b59c7867614/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="负数-补码">
  <meta property="og:description" content="今天看网络小说热血传奇之路，提到游戏里的沙巴克刷钱bug，说是当沙城的钱负到21亿的时候会开始变正。虽然传奇玩的较晚，时间也不长也不深入，不知道这事，但是小说作者作为传奇的骨灰级玩家，提到的这事让我很感兴趣，就从21亿这个数来看，这事肯定是真的了。显然这21亿就是int的最大值2147483647了，而且涉及到负数的问题，想起以前关于负数补码的知识看过但没通透，今天把它弄明白。 看了些补码的知识，摘抄了些，自己整理了些。 顺便带着两个小问题：
INT_MAX = 2147483647 ;
cout&amp;lt;&amp;lt;INT_MAX&#43;1&amp;lt;&amp;lt;endl; //正确结果为-2147483648
UINT_MAX = 4294967295；
cout&amp;lt;&amp;lt;UINT_MAX&#43;1&amp;lt;&amp;lt;endl; //正确结果为0
开始正文： 负数在计算机中如何表示？
举例来说，&#43;8在计算机中表示为二进制的1000，那么-8怎么表示呢？
很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，&#43;8就是00001000，而-8则是10001000。
但是，随便找一本《计算机原理》，都会告诉你，实际上，计算机内部采用2的补码（Two&#39;s Complement）表示负数。
什么是2的补码？
它是一种数值的转换方法，要分二步完成：
第一步，每一个二进制位都取相反值，0变成1，1变成0。比如，00001000的相反值就是11110111。
第二步，将上一步得到的值加1。11110111就变成11111000。
所以，00001000的2的补码就是11111000。也就是说，-8在计算机（8位机）中就是用11111000表示。
不知道你怎么看，反正我觉得很奇怪，为什么要采用这么麻烦的方式表示负数，更直觉的方式难道不好吗？
为什么要用2的补码
首先，要明确一点。计算机内部用什么方式表示负数，其实是无所谓的。只要能够保持一一对应的关系，就可以用任意方式表示负数。所以，既然可以任意选择，那么理应选择一种最方便的方式。
2的补码就是最方便的方式。它的便利体现在，所有的加法运算可以使用同一种电路完成。
还是以-8作为例子。
假定有两种表示方法。一种是直觉表示法，即10001000；另一种是2的补码表示法，即1 1111000。请问哪一种表示法在加法运算中更方便？
随便写一个计算式，16 &#43; (-8) = ? 1 0001000 取反 1 1110111 加1 &#43;1 = 1 1111000 再取反 1 0000111 &#43; 1 = 1 0001000 取反不不包括符号位两次取反得到原值 正数的补码是其本身 负数的补码是符号位不变 其他位取反之后加1 连着变换两次相当于没有做任何操作
16的二进制表示是 00010000，所以用直觉表示法，加法就要写成： ０００１００００ ＋１０００１０００
－－－－－－－－－
１００１１０００
可以看到，如果按照正常的加法规则，就会得到10011000的结果，转成十进制就是-24。显然，这是错误的答案。也就是说，在这种情况下，正常的加法规则不适用于正数与负数的加法，因此必须制定两套运算规则，一套用于正数加正数，还有一套用于正数加负数。从电路上说，就是必须为加法运算做两种电路。
现在，再来看2的补码表示法。
０００１００００">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2011-12-14T22:44:29+08:00">
    <meta property="article:modified_time" content="2011-12-14T22:44:29+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">负数-补码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="blog_text" class="cnt"> 
 <h4 class="title pre fs1">今天看网络小说热血传奇之路，提到游戏里的沙巴克刷钱bug，说是当沙城的钱负到21亿的时候会开始变正。虽然传奇玩的较晚，时间也不长也不深入，不知道这事，但是小说作者作为传奇的骨灰级玩家，提到的这事让我很感兴趣，就从21亿这个数来看，这事肯定是真的了。显然这21亿就是int的最大值2147483647了，而且涉及到负数的问题，想起以前关于负数补码的知识看过但没通透，今天把它弄明白。</h4> 
 <h4 class="title pre fs1">看了些补码的知识，摘抄了些，自己整理了些。</h4> 
 <h4 class="title pre fs1"></h4> 
 <p>顺便带着两个小问题：</p> 
 <p>INT_MAX = <span style="color:#ff0000">2147483647</span> ;</p> 
 <p>cout&lt;&lt;INT_MAX+1&lt;&lt;endl; //正确结果为-2147483648</p> 
 <p>UINT_MAX = 4294967295；</p> 
 <p>cout&lt;&lt;UINT_MAX+1&lt;&lt;endl; //正确结果为0</p> 
 <h4 class="title pre fs1"><span style="font-size:24px">开始正文：</span></h4> 
 <div class="bct fc05 fc11 nbw-blog ztag js-fs2"> 
  <p></p> 
  <div> 
   <p><strong>负数在计算机中如何表示？</strong></p> 
   <p></p> 
   <p>举例来说，+8在计算机中表示为二进制的1000，那么-8怎么表示呢？</p> 
   <p>很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+8就是00001000，而-8则是10001000。</p> 
   <p>但是，随便找一本《计算机原理》，都会告诉你，实际上，计算机内部采用2的补码（Two's Complement）表示负数。</p> 
   <p><strong>什么是2的补码？</strong></p> 
   <p>它是一种数值的转换方法，要分二步完成：</p> 
   <p>第一步，每一个二进制位都取相反值，0变成1，1变成0。比如，00001000的相反值就是11110111。</p> 
   <p>第二步，将上一步得到的值加1。11110111就变成11111000。</p> 
   <p>所以，00001000的2的补码就是11111000。也就是说，-8在计算机（8位机）中就是用11111000表示。</p> 
   <p>不知道你怎么看，反正我觉得很奇怪，为什么要采用这么麻烦的方式表示负数，更直觉的方式难道不好吗？</p> 
   <p></p> 
   <p><strong>为什么要用2的补码</strong></p> 
   <p>首先，要明确一点。计算机内部用什么方式表示负数，其实是无所谓的。只要能够保持一一对应的关系，就可以用任意方式表示负数。所以，既然可以任意选择，那么理应选择一种最方便的方式。</p> 
   <p>2的补码就是最方便的方式。它的便利体现在，<span style="font-size:24px; color:#ff0000">所有的加法运算可以使用同一种电路完成</span>。</p> 
   <p>还是以-8作为例子。</p> 
   <p>假定有两种表示方法。一种是直觉表示法，即10001000；另一种是<span style="color:#ff0000">2的补码表示法</span>，即1 1111000。请问哪一种表示法在加法运算中更方便？</p> 
   <p>随便写一个计算式，16 + (-8) = ?                  <span style="color:#ff0000">   1 0001000 取反 1 1110111    加1    +1 = 1 1111000</span>   再取反  1 0000111  + 1  = 1 0001000 取<span style="color:#ff0000">反不不包括符号位</span><strong><span style="color:#ff0000">两次取反得到原值</span></strong>                                                                     <span style="color:#ff0000">    正数的补码是其本身 负数的补码是符号位不变 其他位取反之后加1  </span><br> <br>                                                                              连着变换两次相当于没有做任何操作<br> </p> 
   <p>16的二进制表示是 00010000，所以用直觉表示法，加法就要写成：                                                        <br> </p> 
   <p>　０００１００００                                                                                                                                  <br> ＋１０００１０００<br> －－－－－－－－－<br> 　１００１１０００</p> 
   <p>可以看到，如果按照正常的加法规则，就会得到10011000的结果，转成十进制就是-24。显然，这是错误的答案。也就是说，在这种情况下，正常的加法规则不适用于正数与负数的加法，因此必须制定两套运算规则，一套用于正数加正数，还有一套用于正数加负数。从电路上说，就是必须为加法运算做两种电路。</p> 
   <p>现在，再来看2的补码表示法。</p> 
   <p>　０００１００００<br> ＋１１１１１０００<br> －－－－－－－－－<br> １００００１０００</p> 
   <p>可以看到，按照正常的加法规则，得到的结果是100001000。注意，这是一个9位的二进制数。我们已经假定这是一台8位机，因此最高的第9位是一个溢出位，会被自动舍去。所以，结果就变成了00001000，转成十进制正好是8，也就是16 + (-8) 的正确答案。这说明了，2的补码表示法可以将加法运算规则，扩展到整个整数集，从而用一套电路就可以实现全部整数的加法。</p> 
   <p><span style="color:#ff0000"><strong>2的补码的本质及正确性</strong></span></p> 
   <p>我们要看先一下模的概念</p> 
   <p>“模”是指一个计量系统的计数范围。如时钟等。计算机也可以看成一个计量机器，它也有一个计量范</p> 
   <div class="spctrl"></div> 
   <p>　　围，即都存在一个“模”。例如：</p> 
   <div class="spctrl"></div> 
   <p>　　时钟的计量范围是0～11，模=12。</p> 
   <div class="spctrl"></div> 
   <p>　　表示n位的计算机计量范围是0～2^(n)-1，模=2^(n)。</p> 
   <div class="spctrl"></div> 
   <p>　　“模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的</p> 
   <div class="spctrl"></div> 
   <p>　　余数。任何有模的计量器，均可化减法为加法运算。</p> 
   <div class="spctrl"></div> 
   <p>　　例如： 假设当前时针指向10点，而准确时间是6点，调整时间可有以下两种拨法：</p> 
   <div class="spctrl"></div> 
   <p>　　你可以往回拨4个小时，也可以向前拨8个小时（12-10+6，在钟表系统里模是12）</p> 
   <div class="spctrl"></div> 
   <p>　　在以12模的系统中，加8和减4效果是一样的，因此凡是<span style="color:#ff0000">减4运算，都可以用加8来代替</span>。</p> 
   <div class="spctrl"></div> 
   <p>　　对“模”而言，8和4互为补数。实际上以12模的系统中，11和1，10和2，9和3，7和5，6和6都有这个特</p> 
   <div class="spctrl"></div> 
   <p>　　性。共同的特点是两者相加等于模。</p> 
   <div class="spctrl"></div> 
   <p>　　对于计算机，其概念和方法完全一样。n位计算机，设n=8， 所能表示的最大数是11111111，若再</p> 
   <div class="spctrl"></div> 
   <p>　　加1称为100000000(9位)，但因只有8位，最高位1自然丢失。又回了00000000，所以8位二进制系统的</p> 
   <div class="spctrl"></div> 
   <p>　　模为2^8。 在这样的系统中减法问题也可以化成加法问题，只需把减数用相应的补数表示就可以</p> 
   <div class="spctrl"></div> 
   <p>　　了。</p> 
   <p></p> 
   <p>       再次重申一下这句话：</p> 
   <p>      <strong>在以12模的系统中，加8和减4效果是一样的，因此凡是减4运算，都可以用加8来代替。</strong>      </p> 
   <p>      所以对于<span style="font-size:24px; color:#ff0000">模</span>为10000 0000的8位系统来说，减去b和加上10000 0000-b是一个道理，而（10000 0000-b）是什么？恰好就是b的补码</p> 
   <p><strong>补码怎么求，“</strong><span style="font-size:18px; color:#ff0000">取反加一</span><strong>” 这口诀怎么来的？</strong></p> 
   <p>承认了<span style="color:#ff0000">8 - 5 = 8 + （-5的补码）</span>这个事实后，我们来看-5的补码怎么求，“取反加一”怎么来的</p> 
   <p>其实看完了上面的模的问题，该问题的答案基本已经出来了</p> 
   <p>-5的补码是 <span style="color:#ff0000">10000 0000 - 5 = 1111 1111 + 1 -5 = （1111 1111 - 5） + 1</span></p> 
   <p><span style="color:#ff0000">1111 1111减去一个数事实上就是在对这个数取反，后面那个是+1</span></p> 
   <p><strong>两个小问题的解释：</strong></p> 
   <p>(1)</p> 
   <p>32位系统里，int的最大值为01111111 11111111 11111111 11111111，加1之后为</p> 
   <p>10000000   00000000   00000000   00000000。这个数是什么？</p> 
   <p>首先这是个负数--&gt;负数在计算器里都是补码形式存放--&gt;这是个补码--&gt;那么真值是？--&gt; -2147483648（<span style="color:#ff0000">已知负数的补码求该负数</span>，不会求的百度一下吧。。。）</p> 
   <p>(2)                                                                                                                                                                    <span style="color:#ff0000"> 再取反就得到原来的值</span><br> </p> 
   <p>对于unsigned，最大值（32个1）加1后最前面的1自然丢失，剩下32个0，所以就是0。</p> 
   <p></p> 
   <p></p> 
   <p>结束。</p> 
  </div> 
 </div> 
</div> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ada29a262d58ffa9fca7f38282a23d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">设置 DevMgr_Show_NonPresent_Devices 令未连接的历史设备在 Windows 设备管理器中现形...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d9814c2a41f97650336b1a1240abffc1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C#后台提示警告框</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>