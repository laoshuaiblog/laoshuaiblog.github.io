<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【leetcode&#43;深度/广度优先搜索】841. 钥匙和房间 (DFS,BFS) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/f35154181ef0b18d068d60b3b7345c1d/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【leetcode&#43;深度/广度优先搜索】841. 钥匙和房间 (DFS,BFS)">
  <meta property="og:description" content="leetcode-cn：leetcode面试75道精华：https://leetcode.cn/studyplan/leetcode-75/
841.钥匙和房间：https://leetcode.cn/problems/keys-and-rooms/description/
一、题目：841. 钥匙和房间 有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0号房间外的其余所有房间都被锁住。 你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。
当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。
给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回
示例
示例 1： 输入：rooms = [[1],[2],[3],[]] 输出：true 解释： 我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。 然后我们去 2 号房间，拿到钥匙 3。 最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。
示例 2： 输入：rooms = [[1,3],[3,0,1],[2],[0]] 输出：false 解释：我们不能进入 2 号房间。
提示：
n == rooms.length
2 &amp;lt;= n &amp;lt;= 1000">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-14T14:22:42+08:00">
    <meta property="article:modified_time" content="2024-03-14T14:22:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【leetcode&#43;深度/广度优先搜索】841. 钥匙和房间 (DFS,BFS)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>leetcode-cn</strong>：leetcode面试75道精华：<a href="https://leetcode.cn/studyplan/leetcode-75/" rel="nofollow">https://leetcode.cn/studyplan/leetcode-75/</a><br> 841.钥匙和房间：<a href="https://leetcode.cn/problems/keys-and-rooms/description/" rel="nofollow">https://leetcode.cn/problems/keys-and-rooms/description/</a></p> 
<p><img src="https://images2.imgbox.com/76/a9/2N7YbSoU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="841__5"></a>一、题目：841. 钥匙和房间</h2> 
<p>有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0号房间外的其余所有房间都被锁住。 你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p> 
<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p> 
<p>给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回</p> 
<p>示例</p> 
<blockquote> 
 <p>示例 1： 输入：rooms = [[1],[2],[3],[]] 输出：true 解释： 我们从 0 号房间开始，拿到钥匙 1。<br> 之后我们去 1 号房间，拿到钥匙 2。 然后我们去 2 号房间，拿到钥匙 3。 最后我们去了 3 号房间。<br> 由于我们能够进入每个房间，我们返回 true。</p> 
 <p>示例 2： 输入：rooms = [[1,3],[3,0,1],[2],[0]] 输出：false 解释：我们不能进入 2 号房间。</p> 
</blockquote> 
<p>提示：</p> 
<blockquote> 
 <p>n == rooms.length<br> 2 &lt;= n &lt;= 1000<br> 0 &lt;= rooms[i].length &lt;= 1000<br> 1 &lt;=sum(rooms[i].length) &lt;= 3000<br> 0 &lt;= rooms[i][j] &lt; n<br> 所有 rooms[i] 的值 <strong>互不相同</strong></p> 
</blockquote> 
<h3><a id="1_DFS_Depth_First_Search_30"></a>解法1：<code>深度</code>优先搜索 （DFS, Depth First Search）</h3> 
<p>深度优先搜索（DFS）（算法笔记）：<a href="https://blog.csdn.net/Arabot_/article/details/129702049">https://blog.csdn.net/Arabot_/article/details/129702049</a></p> 
<blockquote> 
 <p>深度优先搜索属于搜索问题的一种，当问题可以被描述为“路径搜索”时，就可以采用搜素问题的所有解的方式来进行解决，所以DFS本质还是<strong>暴力</strong>。</p> 
 <p>深度搜索具有两个关键词，即“<strong>岔道口</strong>”和“<strong>死胡同</strong>”，这两个词来源于<code>迷宫问题</code>，这也是搜索问题最原始的表现。<br> 当碰到岔道口时（一次多个选择时），总是以“深度”作为前进的关键词，<strong><code>不碰到死胡同就不回头</code></strong>，因此被称为“深搜”。<br> 深搜适合于求解需要**<code>遍历所有解或路径的问题</code>**，并且剪枝很重要。<br> 深搜和广搜在数据结构中的应用就是对非线性存储结构进行遍历。<br> 搜索和分治是两大分析问题的方法，而回溯、剪枝、动态规划可以说是对深度搜索和分治算法进行优化。</p> 
</blockquote> 
<h4><a id="__42"></a>思路 （常用递归）</h4> 
<p>from <a href="https://leetcode.cn/problems/keys-and-rooms/solutions/18826/7xing-dfs-8xing-bfs-liang-chong-fang-fa-san-chong-" rel="nofollow">https://leetcode.cn/problems/keys-and-rooms/solutions/18826/7xing-dfs-8xing-bfs-liang-chong-fang-fa-san-chong-</a></p> 
<ol><li>先找第 ０ 个房间的第一个钥匙</li><li>进入那个房间，再找它的第一个钥匙 重复以往，直到没钥匙了，</li><li>那么退回当前房间 ，找到房间的第二把钥匙，如果该房间没有，则返回上一间房间 ，重复以往</li></ol> 
<p>递归调用函数的<br> <img src="https://images2.imgbox.com/f0/9e/lBAQix7n_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="python_51"></a>python代码</h4> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">canVisitAllRooms</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> rooms<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token comment"># 抽象</span>
        <span class="token comment"># 一个数字就是一个房间，以及二维数组中数据，也可以通用理解为节点序号</span>
        <span class="token comment"># set add remove 添加删除原始</span>
        <span class="token comment"># set1.union(set2)   并集</span>
        <span class="token comment"># set1.intersection(set2) 交集</span>
        <span class="token comment"># 如果没有返回，程序自动返回继续执行</span>
        <span class="token comment"># nonlocal 关键字用于在嵌套函数中声明一个变量不属于本地作用域，</span>
        <span class="token comment"># 它指向的是上一层函数的局部变量。这意味着你可以在嵌套函数中修改外部函数的变量。</span>
        <span class="token keyword">def</span> <span class="token function">dps</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
            vist<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
            <span class="token keyword">for</span> key <span class="token keyword">in</span> rooms<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> key <span class="token keyword">not</span> <span class="token keyword">in</span> vist<span class="token punctuation">:</span>
                    dps<span class="token punctuation">(</span>key<span class="token punctuation">)</span>

        vist<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        dps<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        num_rooms<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>rooms<span class="token punctuation">)</span>
        <span class="token keyword">return</span>  <span class="token builtin">len</span><span class="token punctuation">(</span>vist<span class="token punctuation">)</span><span class="token operator">==</span>num_rooms
      
</code></pre> 
<h5><a id="python_75"></a>python多级嵌套函数如何理解？</h5> 
<p>嵌套函数可以访问其外部函数的变量和参数，这是一种封装和组织代码的方式</p> 
<pre><code class="prism language-python"> <span class="token keyword">def</span> <span class="token function">canVisitAllRooms</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> rooms<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
 	  <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
 	  	vist<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
	vist<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre> 
<h5><a id="python_set_list___87"></a>python set 和list 数据结构有什么区别?</h5> 
<pre><code class="prism language-python">vist<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 或 vist={0}</span>
</code></pre> 
<p>Python 中的 set 和 list 是两种不同的数据结构，它们在元素操作方面有一些显著的区别：</p> 
<ol><li> <p>元素唯一性：<br> set：集合中的元素是唯一的，<strong>不允许重复</strong>。<br> list：列表中的元素可以重复，没有唯一性要求。</p> </li><li> <p>元素顺序：<br> set：集合中的元素是<strong>无序</strong>的，不能通过索引访问元素。<br> list：列表中的元素是有序的，可以通过索引访问和操作元素。</p> </li><li> <p>性能：<br> set：由于集合使用<strong>哈希表</strong>实现，因此在查找、添加和删除元素时通常具有较高的性能。<br> list：列表的查找和删除操作（特别是对于大量元素）可能比集合慢，因为它们需要遍历整个列表。</p> </li><li> <p>元素操作：<br> <strong>set：</strong><br> <code>添加元素</code>：使用 <strong>add()</strong> 方法。<br> 删除元素：使用 remove()（如果元素不存在会引发错误）或 discard()（如果元素不存在也不会引发错误）方法。<br> 交集、并集、差集等操作：使用 intersection(), union(), difference() 等方法。</p> </li></ol> 
<p><strong>list：</strong><br> 添加元素：使用 <strong>append()</strong> 方法或 insert() 方法。<br> 删除元素：使用 remove() 方法（删除第一个匹配的元素）或 pop() 方法（删除指定索引处的元素）。<br> 排序、反转等操作：使用 sort(), reverse() 等方法。</p> 
<h3><a id="2___BFS_120"></a>解法2 ： 广度优先搜索 （BFS）</h3> 
<p><a href="https://leetcode.cn/problems/keys-and-rooms/solutions/18826/7xing-dfs-8xing-bfs-liang-chong-fang-fa-san-chong-" rel="nofollow">https://leetcode.cn/problems/keys-and-rooms/solutions/18826/7xing-dfs-8xing-bfs-liang-chong-fang-fa-san-chong-</a></p> 
<ol><li>首先，建立一个登记表（python中用<strong>双向队列或者list实现</strong>），把 ０ 号房间的所有钥匙都依次记录，</li><li>然后删除0号房间在登记表（队列）记录，同时用一个visited表（set）记录已经去过的房间，防止重复登记</li><li>进入<strong>队列记录表</strong>中最早登记的房间（X号房间），结合（visited表）进行登记，去过的就不登记到队列记录表，登记完钥匙后，删除x号房间的记录</li><li>继续按按<strong>队列登记表</strong>的房间进入查找、登记，直到队列登记表没有要去的房间，表示所有能打开的房间都检查完了，</li><li>最后根据（visited表）房间的数量与已知房间数量对比，得出能否打开所有的房间（len(visited)==len(rooms)）</li></ol> 
<h4><a id="BFSpython_128"></a>BFS的python代码</h4> 
<p>其中 collections.deque() # 创建一个空队列，这个是双向的队列</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">canVisitAllRooms</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> rooms<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        queue<span class="token operator">=</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 创建一个空队列，这个是双向的队列</span>
        <span class="token comment"># 先将第0号房间添加到检查列表</span>
        queue<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>rooms<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        visited<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span>  <span class="token comment"># 已经去过的房间</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            search_room_id<span class="token operator">=</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#  移除并返回队列的右端元素</span>
            visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>search_room_id<span class="token punctuation">)</span>
            <span class="token keyword">for</span> key <span class="token keyword">in</span> rooms<span class="token punctuation">[</span>search_room_id<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> key <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>  <span class="token comment"># 获得钥匙是否去过，非常重要，否则会反复去</span>
                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>

        <span class="token keyword">print</span><span class="token punctuation">(</span>visited<span class="token punctuation">,</span>num_room<span class="token punctuation">)</span>
         
        <span class="token keyword">return</span>  <span class="token builtin">len</span><span class="token punctuation">(</span>visited<span class="token punctuation">)</span><span class="token operator">==</span><span class="token builtin">len</span><span class="token punctuation">(</span>rooms<span class="token punctuation">)</span>
</code></pre> 
<h5><a id="pythondeque_150"></a>python双向队列deque的操作方法</h5> 
<pre><code class="prism language-python">append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    在队列的<span class="token operator">**</span>右端<span class="token operator">**</span>添加一个元素。
appendleft<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  在队列的<span class="token operator">**</span>左端<span class="token operator">**</span>添加一个元素。

extend<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span> 在队列的右端添加多个元素，其中 iterable 可以是列表、集合或任何迭代器。
extendleft<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>，在队列的左端添加多个元素，iterable 中的元素会被逆序添加到队列中。


pop<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token operator">**</span>移除并返回<span class="token operator">**</span>队列的右端元素。
popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>  移除并返回队列的左端元素。
remove<span class="token punctuation">(</span>value<span class="token punctuation">)</span>  移除队列中第一个匹配的 value 元素
clear<span class="token punctuation">(</span><span class="token punctuation">)</span>移除队列中的所有元素。

count<span class="token punctuation">(</span>x<span class="token punctuation">)</span>计算队列中元素 x 出现的次数。
reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>  将队列中的元素反转。
copy<span class="token punctuation">(</span><span class="token punctuation">)</span>  创建并返回队列的一个浅拷贝。

index<span class="token punctuation">(</span>x<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> stop<span class="token operator">=</span>sys<span class="token punctuation">.</span>maxsize<span class="token punctuation">)</span>返回找到的第一个 x 元素的索引，索引范围从 start 到 stop。
insert<span class="token punctuation">(</span>i<span class="token punctuation">,</span> x<span class="token punctuation">)</span>  在队列的指定位置 i 插入元素 x。如果插入会导致 deque 超过 maxlen 的限制，则会引发 IndexError。
</code></pre> 
<p>具体操作</p> 
<pre><code class="prism language-python">

<span class="token comment"># 使用 extendleft 方法在队列头部添加列表中的所有元素</span>
queue<span class="token punctuation">.</span>extendleft<span class="token punctuation">(</span>list_elements<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"队列的内容:"</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre> 
<h2><a id="_547____185"></a>二、 巩固：547. 省份数量 (分类)</h2> 
<p><a href="https://leetcode.cn/problems/number-of-provinces/description/?envType=study-plan-v2&amp;envId=leetcode-75" rel="nofollow">https://leetcode.cn/problems/number-of-provinces/description/?envType=study-plan-v2&amp;envId=leetcode-75</a><br> 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p> 
<p><strong><code>省份</code></strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p> 
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p> 
<p><strong>返回矩阵中 省份 的数量</strong><br> <img src="https://images2.imgbox.com/af/94/zHnJhn9K_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_196"></a>算法-深度优先</h3> 
<p><strong>思路：</strong><br> 对于每个城市，如果该城市尚未被访问过，则从该城市开始深度优先搜索，通过矩阵 isConnected 得到与该城市直接相连的城市有哪些，这些城市和该城市属于同一个连通分量，然后对这些城市继续深度优先搜索，直到同一个连通分量的所有城市都被访问到，即可得到一个省份。<br> 遍历完全部城市以后，即可得到连通分量的总数，即省份的总数。</p> 
<blockquote> 
 <p>链接：<a href="https://leetcode.cn/problems/number-of-provinces/solutions/549895/sheng-fen-shu-liang-by-leetcode-solution-eyk0/" rel="nofollow">https://leetcode.cn/problems/number-of-provinces/solutions/549895/sheng-fen-shu-liang-by-leetcode-solution-eyk0/</a></p> 
</blockquote> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> isConnected<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        visited<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>city_id<span class="token punctuation">)</span><span class="token punctuation">:</span>
            visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>city_id<span class="token punctuation">)</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>isConnected<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> j <span class="token keyword">not</span> <span class="token keyword">in</span> visited <span class="token keyword">and</span>  isConnected<span class="token punctuation">[</span>city_id<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                    dfs<span class="token punctuation">(</span>j<span class="token punctuation">)</span>
        count<span class="token operator">=</span><span class="token number">0</span>
        <span class="token comment"># 每次迭代，就把把一个省的城市找完</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>isConnected<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 检查过的城市不用去了</span>
            <span class="token keyword">if</span>  i <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
                count<span class="token operator">+=</span><span class="token number">1</span>
                dfs<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token keyword">return</span> count
</code></pre> 
<h2><a id="_DPS_BPS_225"></a>其他题 （DPS/ BPS）</h2> 
<p>.<a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description" rel="nofollow">1466. 重新规划路线</a><br> . 994 发烂的橘子 ：<a href="https://leetcode.cn/problems/rotting-oranges" rel="nofollow">https://leetcode.cn/problems/rotting-oranges</a></p> 
<h2><a id="_230"></a>附录</h2> 
<p>原题</p> 
<p><img src="https://images2.imgbox.com/79/d4/0zmCc8Jt_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d354576011a5da30e683263bcca9fe4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LVS&#43;Keepalived 高可用群集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0648337ca029c3974a8fcbf6e74c4337/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器数据恢复—raid5热备盘上线同步数据失败的如何恢复数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>