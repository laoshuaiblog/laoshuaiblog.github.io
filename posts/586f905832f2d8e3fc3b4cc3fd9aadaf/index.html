<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>类比学习——java 泛型&amp; kotlin 泛型中的 in out where - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/586f905832f2d8e3fc3b4cc3fd9aadaf/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="类比学习——java 泛型&amp; kotlin 泛型中的 in out where">
  <meta property="og:description" content="在学习 kotlin 泛型的时候，经常会遇到 in out 这两个词，一会用in 一会用out，为啥这里要用 out ？为啥哪里用 in ？啥什么用 out 啥时候用in ？对应上面问题以前我是晕乎乎的，不是很明白，于是打算写这篇文章梳理一下，搞清楚怎么回事。
Java 泛型 在学kotlin 泛型之前，先回顾一下Java中的泛型
为了方便说明引入下面几个类
具体代码
public class Animal { } public class Dog extends Animal{ } public class Cat extends Animal{ } public class Corgi extends Dog { } public class Result&amp;lt;T&amp;gt;{ private T data; public Result() { } public Result(T data) { this.data = data; } public void setData(T data) { this.data = data; } public T getData() { return data; } } 1.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-02-24T21:46:55+08:00">
    <meta property="article:modified_time" content="2021-02-24T21:46:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">类比学习——java 泛型&amp; kotlin 泛型中的 in out where</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在学习 kotlin 泛型的时候，经常会遇到 in out 这两个词，一会用in 一会用out，为啥这里要用 out ？为啥哪里用 in ？啥什么用 out 啥时候用in ？对应上面问题以前我是晕乎乎的，不是很明白，于是打算写这篇文章梳理一下，搞清楚怎么回事。</p> 
<h2><a id="Java__2"></a>Java 泛型</h2> 
<p>在学kotlin 泛型之前，先回顾一下Java中的泛型<br>为了方便说明引入下面几个类<br> <img src="https://images2.imgbox.com/5e/01/pJyeTpDi_o.png" alt="在这里插入图片描述"></p> 
<p><br>具体代码</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Corgi</span> <span class="token keyword">extends</span> <span class="token class-name">Dog</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> T data<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">Result</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> T <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>   <span class="token keyword">return</span> data<span class="token punctuation">;</span>  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


</code></pre> 
<h4><a id="1_30"></a>1.不可型变</h4> 
<pre><code class="prism language-java">Result<span class="token generics function"><span class="token punctuation">&lt;</span>Dog<span class="token punctuation">&gt;</span></span> dogResult <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Result<span class="token generics function"><span class="token punctuation">&lt;</span> Animal<span class="token punctuation">&gt;</span></span> animalResult <span class="token operator">=</span> dogResult<span class="token punctuation">;</span> <span class="token comment">// 编译错误</span>
</code></pre> 
<p>虽然 Dog 是 Animal 的子类，但是Java 泛型是不可以型变的，<code>Result&lt;Dog&gt;</code> 对象不能赋值给 <code>Result&lt;Animal&gt;</code> , 他们之间没有关系。<br>如果 Java 泛型不是这样设计的就容易造成运行时异常，例如</p> 
<pre><code class="prism language-java"> Result<span class="token generics function"><span class="token punctuation">&lt;</span>Dog<span class="token punctuation">&gt;</span></span> dogResult <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 Result<span class="token generics function"><span class="token punctuation">&lt;</span>Animal<span class="token punctuation">&gt;</span></span> animalResult <span class="token operator">=</span> dogResult<span class="token punctuation">;</span> <span class="token comment">// 编译器错误 ❌</span>
<span class="token comment">//假设👆上面这句代码可以编译通过</span>
<span class="token comment">//那么我们就可以调用set方法设置一个Animal对象</span>
 animalResult<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//但是我们用dogResult的get方法取的时候，本以为是Dog 但实际是Animal 这样就会出现类型转换异常 ClassCastException</span>
 Dog dog <span class="token operator">=</span> dogResult<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>所以 Java 这样设计是为了安全考虑。<br>为了安全，这样的限制显然会失去一些API的灵活性。于是 Java 提供有限制通配符 <code>? extends X</code> 、<code>? super X</code> 、<code>&lt;?&gt;</code> 来提升API 的灵活性。</p> 
<h4><a id="2___extends_48"></a>2.型变性通配符 —— ? extends</h4> 
<pre><code class="prism language-java">Result<span class="token generics function"><span class="token punctuation">&lt;</span>Dog<span class="token punctuation">&gt;</span></span> dogResult <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//泛型类型可以是Animal 或者Animal的子类</span>
Result<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token operator">&gt;</span> animalResult <span class="token operator">=</span> dogResult<span class="token punctuation">;</span> <span class="token comment">// 编译通过</span>
<span class="token comment">// animalResult=new Result&lt;Object&gt;(new Object());//父类不行，编译错误 ❌</span>

<span class="token comment">//Result&lt;? extends Animal&gt; 修改data数据，保证了数据的安全性，不会让dogResult.getData()发生数据转换异常</span>
<span class="token comment">//  animalResult.setData(new Animal());// 编译错误</span>

<span class="token comment">//Result&lt;? extends Animal&gt; 泛型限制保证 animalResult.getData()一定是Animal对象,</span>
<span class="token comment">// 所以可以通过animalResult获取数据是没问题的</span>
 Animal animal <span class="token operator">=</span> animalResult<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>&lt;? extends X&gt;</code> 可以表示泛型是 X 也可以是 X 的子类，所以上面代码中 <code>Result&lt;? extends Animal&gt; animalResult = dogResult;</code> 是可以的，但是为了安全考虑，<code>animalResult</code> 只可以读数据，不可用写入数据，防止出现类型异常。</p> 
<p><code>&lt;? extends X&gt;</code> 可以安全的使用读取数据（返回值为 X 的函数），但不能写入数据（参数为 X 的函数）因为参数需要的是X 还是 X 的那个子类不确定，就像上面的例子 <code>animalResult</code> 指向的类型是 Result 所以setData 应该放入一个Dog对象，但是 <code>animalResult</code> 也可以指向一个 <code>Result&lt;Cat&gt;</code> 对象，我们只能确定 <code>animalResult</code> 指向的对象泛型是Animal 或者是它的子类，但无法确认它到底是具体哪一个类型（是 Dog 还是Cat 还是……），所以setData的时候我们无法确认到底放那个对象。为了安全考虑，写入数据在这种通配符的情况是不被允许的。</p> 
<p>总结 ? extends 通配符</p> 
<ol><li>可以协变，如上 Cat、Dog、Corgi 都是 Animal 的子类，所以 <code>Result&lt;Cat&gt;</code> 、<code>Result&lt;Dog&gt;</code> 、<code>Result&lt;Corgi&gt;</code> 都可以用 <code>Result&lt;? extends Animal&gt;</code> 表示。? extends 通配符 限定了上界，泛型的类型可以是 Animal 或它的子类，但不能超过它，即不能是它的父类。</li><li>此通配符，只可以读不可用写，这种对象通常称为消费者。</li></ol> 
<h4><a id="3__super_74"></a>3.逆变型通配符 —— ？super</h4> 
<pre><code class="prism language-java">        Result<span class="token generics function"><span class="token punctuation">&lt;</span>Dog<span class="token punctuation">&gt;</span></span> dogResult <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Result<span class="token generics function"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">&gt;</span></span> objResult <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//泛型类型可以是Animal 或者Animal的父类</span>
        Result<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Animal<span class="token operator">&gt;</span> animalResult <span class="token operator">=</span> objResult<span class="token punctuation">;</span> <span class="token comment">// 编译通过</span>
        <span class="token comment">// 编译错误，Dog是Animal的子类</span>
<span class="token comment">//        animalResult=dogResult ❌</span>

        <span class="token comment">//可以写，使用set方法</span>
        animalResult<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果读的话，返回值是Object，无法确认具体类型</span>
        Object data <span class="token operator">=</span> animalResult<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>&lt;? super X&gt;</code> 可以表示泛型是 X 也可以是 X 的父类，所以上面代码 <code>Result&lt;? super Animal&gt; animalResult = objResult;</code> 是可以的，但 <code>animalResult=dogResult</code> 不可用。此通配符限制了泛型是 X 也可以是 X 的父类，所以通配符，是可以安全的写入数据的（参数为 X 的函数） 但传入的类型必须是 X 或者他的子类，因为 <code>? super X</code> 可以保证泛型是X 或它的父类，根据类的多态特性，可以使用子类代替父类。如果读的话，无法确认具体的类型，因为只知道是 X 或 它的父类，但具体那个不知道，所有返回的类型是他们顶层父类 Object。</p> 
<p>总结 ? super 通配符</p> 
<ol><li>可以逆变 。? super 通配符 限定了下界，泛型的类型可以是 Animal 或它的父类，但不能低于它，即不能是它的子类。</li><li>此通配符，可以写，但读无法确定类型，这种对象通常称为生产者。</li></ol> 
<h4><a id="4_96"></a>4.使用通配符限定参数</h4> 
<h5><a id="_extends_X__97"></a>? extends X 作为参数</h5> 
<p>例如 Java 中集合框架中的 addAll 方法</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">interface</span> Collection<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span> extends Iterable<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
   boolean <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> extends E<span class="token operator">&gt;</span> items<span class="token punctuation">)</span><span class="token punctuation">;</span>	
<span class="token punctuation">}</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>分割线<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>

<span class="token comment">//假设声明一个ArrayList&lt;Animal&gt; 那么它的元素可以是Animal 或者它的子类 </span>
ArrayList<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span> list <span class="token operator">=</span> new ArrayList<span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 0️⃣  </span>
list<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>new ArrayList<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>new ArrayList<span class="token operator">&lt;</span>Cat<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1️⃣</span>
<span class="token comment">// list.addAll(new ArrayList&lt;Object&gt;()); 编译错误❌</span>

</code></pre> 
<p>声明的集合类型是 ArrayList 所以此时 addAll 的形参类型相当于是 <code>Collection&lt;? extends Animal&gt;</code> 这样就限定了集合泛型必须是 Animal 或者它的子类，于是就保证了通过addAll 方式添加到 list 集合中的元素一定是 Animal 或者它的子类的对象，保证了数据的正确性。</p> 
<h5><a id="_super_X__118"></a>? super X 作为参数</h5> 
<pre><code class="prism language-kotlin"> <span class="token keyword">public</span> void <span class="token function">forEach</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">&gt;</span> action<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      	……

        <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>modCount <span class="token operator">==</span> expectedModCount <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//? super E 通配符可以调用写入方法（参数有 E 的函数）</span>
            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">elementAt</span><span class="token punctuation">(</span>es<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        ……
<span class="token punctuation">}</span>
 
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>分割线<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
    
  ArrayList<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span> list <span class="token operator">=</span> new ArrayList<span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 0️⃣   </span>
 list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>new Consumer<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation builtin">@Override</span>
            <span class="token keyword">public</span> void <span class="token function">accept</span><span class="token punctuation">(</span>Animal <span class="token keyword">data</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 0️⃣   </span>
 list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>new Consumer<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation builtin">@Override</span>
            <span class="token keyword">public</span> void <span class="token function">accept</span><span class="token punctuation">(</span>Object <span class="token keyword">data</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面代码中 forEach 的形参类型是 <code>Consumer&lt;? super Animal&gt;</code> , 所以泛型可以值 Animal 或者它的父类，所以不管是 <code>Consumer&lt;Animal&gt;</code> 还是 <code>Consumer&lt;Object&gt;</code> 都是可以的。</p> 
<h2><a id="kotlin__152"></a>kotlin 泛型</h2> 
<p>kotlin 泛型和 Java 类似，虽然没有 ? extends 和 ？super 这样的通配符 ，但是有类似功能的修饰符 in out<br>可以简单理解 ？extends 对应 out，? super 对应 in</p> 
<h4><a id="1_155"></a>1.不可型变</h4> 
<pre><code class="prism language-kotlin"><span class="token keyword">val</span> dogResult <span class="token operator">=</span> Result<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> animalResult<span class="token operator">:</span> Result<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span> <span class="token operator">=</span> dogResult <span class="token comment">// 编译错误</span>
</code></pre> 
<p>和 Java 一致</p> 
<h4><a id="2__out_161"></a>2.型变修饰符 —— out</h4> 
<pre><code class="prism language-kotlin">    <span class="token keyword">val</span> dogResult <span class="token operator">=</span> <span class="token function">Result</span><span class="token punctuation">(</span><span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">//泛型类型可以是Animal 或者Animal的子类</span>
    <span class="token keyword">val</span> animalResult<span class="token operator">:</span> Result<span class="token operator">&lt;</span><span class="token keyword">out</span> Animal<span class="token operator">&gt;</span> <span class="token operator">=</span> dogResult <span class="token comment">// 编译通过</span>
<span class="token comment">// animalResult=new Result&lt;Object&gt;(new Object())//父类不行，编译错误 ❌</span>

<span class="token comment">//  animalResult.data=Animal()// 编译错误</span>
    
    <span class="token keyword">val</span> animal <span class="token operator">=</span> animalResult<span class="token punctuation">.</span>data
</code></pre> 
<p>和 Java ？extends 一致，具有型变行，可读不可写</p> 
<h4><a id="3__int_173"></a>3.型变修饰符 —— int</h4> 
<pre><code class="prism language-kotlin">    <span class="token keyword">val</span> dogResult <span class="token operator">=</span> <span class="token function">Result</span><span class="token punctuation">(</span><span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> objResult <span class="token operator">=</span> Result<span class="token operator">&lt;</span>Any<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    <span class="token comment">//泛型类型可以是Animal 或者Animal的父类</span>
    <span class="token keyword">val</span> animalResult<span class="token operator">:</span> Result<span class="token operator">&lt;</span><span class="token keyword">in</span> Animal<span class="token operator">&gt;</span> <span class="token operator">=</span> objResult <span class="token comment">// 编译通过</span>
    <span class="token comment">// 编译错误，Dog是Animal的子类</span>
   <span class="token comment">//  animalResult=dogResult ❌</span>
    
    <span class="token comment">//可以写，使用set方法</span>
    animalResult<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">//如果读的话，返回值是Any?，无法确认具体类型</span>
    <span class="token keyword">val</span> <span class="token keyword">data</span><span class="token operator">:</span>Any<span class="token operator">?</span> <span class="token operator">=</span> animalResult<span class="token punctuation">.</span>data
</code></pre> 
<p>和 Java ？super 一致，具有可逆变性，可写不可读<br></p> 
<h3><a id="Kotlin____190"></a>Kotlin 泛型之 —— 声明处型变</h3> 
<p>在Java 泛型中我们列举了使用通配符限定参数的方式，看了 <code>java.util.ArrayList</code> 的Api 是如何利用泛型通配符提升Api灵活性的同时，保证数据安全的。 kotlin 也可以按照 ？extends 替换 out，? super 替换 in 的方式限定参数也是可以达到和Java一样的效果。但是如果你看 <code>kotlin.collections.ArrayList</code> 的addAll 的方法并不是我们想的那样。<br><code>java.util.ArrayList</code> 的 addAll 方法</p> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">&gt;</span> item<span class="token punctuation">)</span>
</code></pre> 
<p>按照上面的分析，我们想的 <code>kotlin.collections.ArrayList</code> 的addAll 大概是这样的</p> 
<pre><code class="prism language-kotlin">   <span class="token keyword">fun</span> <span class="token function">addAll</span><span class="token punctuation">(</span>elements<span class="token operator">:</span> Collection<span class="token operator">&lt;</span><span class="token keyword">out</span> E<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean
</code></pre> 
<p>但实际源码是这样写的</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">addAll</span><span class="token punctuation">(</span>elements<span class="token operator">:</span> Collection<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean
</code></pre> 
<p>参数类型是 <code>Collection&lt;E&gt;</code> 而不是 <code>Collection&lt;out E&gt;</code> 虽然没有 out 但参数仍然可以起到限制作用。</p> 
<pre><code class="prism language-kotlin">    <span class="token keyword">val</span> list <span class="token operator">=</span> mutableListOf<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//public inline fun &lt;T&gt; mutableListOf(): MutableList&lt;T&gt; = ArrayList()</span>
    list<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>mutableListOf<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//    list.addAll(mutableListOf&lt;Any&gt;()) 编译错误</span>
<span class="token comment">//    list.addAll(mutableListOf&lt;String&gt;()) 编译错误</span>
</code></pre> 
<p>查看 Collection 你会发现它在定义的时候加上了out</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">interface</span> Collection<span class="token operator">&lt;</span><span class="token keyword">out</span> E<span class="token operator">&gt;</span> <span class="token operator">:</span> Iterable<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
 
    <span class="token keyword">public</span> <span class="token keyword">val</span> size<span class="token operator">:</span> Int
	……
<span class="token punctuation">}</span>
</code></pre> 
<p>这种在类或接口定义处指定 out ，称之为**声明处型变，**这样声明的接口或类中，只能提供读的方法，不能提供写入的方法，此类型我们打算让他变成具有型变性的。例如我把上面的 Result 改成声明处型变</p> 
<pre><code class="prism language-kotlin"><span class="token comment">//原版 java to kotlin</span>
<span class="token keyword">class</span> Result<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">var</span> <span class="token keyword">data</span><span class="token operator">:</span> T<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/99/f2/sQyylWjg_o.png" alt="在这里插入图片描述"></p> 
<p>我们加上out 发现报错了，因为 out 只读不能写，所以需要吧var 改成 val</p> 
<p><img src="https://images2.imgbox.com/86/49/fHWtFjOQ_o.png" alt="在这里插入图片描述"><br> <br>这样我们在使用Result 就是协变的了</p> 
<pre><code class="prism language-kotlin"> <span class="token keyword">val</span> dogResult<span class="token operator">:</span>Result<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">Result</span><span class="token punctuation">(</span><span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">//默认就是协变的了，所以 Result&lt;Dog&gt; 对象赋值给 Result&lt;Animal&gt; 类型变量</span>
  <span class="token keyword">val</span> animalResult<span class="token operator">:</span> Result<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span> <span class="token operator">=</span> dogResult <span class="token comment">// 编译通过</span>
  <span class="token keyword">val</span> animal <span class="token operator">=</span> animalResult<span class="token punctuation">.</span>data
</code></pre> 
<p>声明类型的时候 out 就可以不用写了，你要写了人家还提示你多余<img src="https://images2.imgbox.com/b9/77/LohrPVq5_o.png" alt="在这里插入图片描述"><br> <br>说完 out，in 也是同理，我们也可以在类或接口上指定</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">class</span> Result<span class="token operator">&lt;</span><span class="token keyword">in</span> T<span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> <span class="token keyword">data</span><span class="token operator">:</span> T<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
    
    <span class="token keyword">fun</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token operator">:</span> T<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token operator">=</span><span class="token keyword">data</span> <span class="token punctuation">}</span>

    编译报错，只写，不能读
   <span class="token comment">// fun getData(): T? =data</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样我们在使用Result 就是逆变性的</p> 
<pre><code class="prism language-kotlin">    <span class="token keyword">val</span> objResult<span class="token operator">:</span> Result<span class="token operator">&lt;</span>Any<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> animalResult<span class="token operator">:</span> Result<span class="token operator">&lt;</span> Animal<span class="token operator">&gt;</span> <span class="token operator">=</span> objResult <span class="token comment">// 编译通过</span>
    <span class="token comment">// 编译错误，Dog是Animal的子类</span>
    <span class="token comment">//  animalResult=Result&lt;Dog&gt;() //❌</span>
    <span class="token comment">//可以写，使用set方法</span>
    animalResult<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="kotlin_where_258"></a>kotlin 中的where</h3> 
<p>看kotlin的wherect之前，还是看看Java中类似的语法<br><br> <br>泛型函数</p> 
<pre><code class="prism language-java"><span class="token comment">//定义  在方法返回类型前用 &lt;T&gt; 声明泛型</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>分割线<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token comment">//使用 也放任意类型</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>加限制的泛型函数</p> 
<pre><code class="prism language-java"><span class="token comment">//定义</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token operator">&gt;</span>  <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>分割线<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token comment">//使用 只可以传入 Animal或它的子类</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>加多条限制的泛型函数</p> 
<pre><code class="prism language-java"> <span class="token comment">//定义  多个限定用 &amp; 连接 只能有一个类且必须放在首位，可以有多个接口</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token operator">&amp;</span> Serializable <span class="token operator">&amp;</span> Closeable<span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Data</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span><span class="token punctuation">,</span>Closeable<span class="token punctuation">{<!-- --></span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//接收的泛型必须是继承Animal 实现 Serializable,Closeable接口的类型</span>
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//      test(Animal());//编译错误</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>Kotlin 中的 where 就是用来实现 Java 中 多条限制的泛型函数</p> 
<pre><code class="prism language-java">fun <span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token function">test</span><span class="token punctuation">(</span>data<span class="token operator">:</span> T<span class="token punctuation">)</span> where T <span class="token operator">:</span> Serializable<span class="token punctuation">,</span> T <span class="token operator">:</span> Animal<span class="token punctuation">,</span> T <span class="token operator">:</span> Closeable <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

 <span class="token keyword">class</span> <span class="token class-name">Data</span> <span class="token operator">:</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Serializable<span class="token punctuation">,</span> Closeable <span class="token punctuation">{<!-- --></span>
    override fun <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

fun <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//  test(Animal())//编译错误</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_311"></a>参考文档</h3> 
<p><br><a href="https://www.kotlincn.net/docs/reference/generics.html" rel="nofollow">泛型：in、out、where - Kotlin 语言中文站</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cc06c9cca3b6a2b3025e53fc1852d715/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jQuery 获取input name 及常用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/23b05e05a10e2aaaca672bb3f9964b86/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kubectl exec 遇到 unable to upgrade connection Forbidden 的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>