<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>bic准则 python实现_python机器学习---时间序列算法 0117-2020 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/0d0518904d0b0451071cea1a5893fe39/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="bic准则 python实现_python机器学习---时间序列算法 0117-2020">
  <meta property="og:description" content="时间序列概念
时间序列建模步骤
时间序列python实现时间序列概念
时间序列是指将同一统计指标的数值按其发生的时间先后顺序排列而成的数列。时间序列分析的主要目的是根据已有的历史数据对未来进行预测。ARIMA时间序列建模步骤
本文利用 ARIMA构建高性能时间序列模型，来预测医保支出费用。对整个建模的步骤及步骤用到的技术进行总结：
1 建模步骤
ARIMA是一个非常强大的预测时间序列数据的模型，但是数据准备和参数调整过程是非常耗时的。在实现ARIMA之前，需要使数据保持平稳，并使用前面讨论的ACF和PACF图确定p和q的值，一般情况下，下面是实现ARIMA应该遵循的步骤：
(1) 加载数据，动态数据预处理：包括平稳性检验，及非平稳性数据处理，正太性检验；
(2) 时间序列模型ARIMA参数估计：包括q、d、p确定
(3) 建模，指标评估，残差检验
(4) 在验证集上进行预测：在验证集基础上进行预测
(5) 计算RMSE：用验证集上的预测值和实际值检查RMSE值
1.1 动态数据预处理
1.1.1 平稳性检验
时间序列的平稳性是我们建模的重要前提。一般说来，某个实测过程如果它的系统参数和运行时周围的条件不改变，即可视为平稳的。
平稳性要求序列的均值和方差不发生明显变化。
平稳性检验细化分为严平稳与弱平稳：
(1)严平稳：严平稳表示的分布不随时间的改变而改变。如：白噪声(正态)，无论怎么取，都是期望为0，方差为1。
(2)弱平稳：期望与相关系数(依赖性)不变，未来某时刻的t的值Xt就要依赖于它的过去信息，所以需要依赖性。
建模时，首先要对加载的原始数据进行平稳性检验，对于平稳的数据可直接进入下一步骤，对于非平稳数据，可进行差分处理，再进行后续步骤。
1.1.2 差分法
差分法：时间序列在t与t-1时刻的差值。
1.2 ARIMA模型参数估计
1.2.1 AR模型
自回归模型(AR)是描述当前值与历史值之间的关系，用变量自身的历史时间数据对自身进行预测。自回归模型必须满足平稳性的要求。
p阶自回归过程的公式定义：
其中，
是当前值， 是常数项，p是阶数， 是自相关系数， 是误差。
自回归模型的限制：
(1)自回归模型是用自身的数据来进行预测
(2)必须具有平稳性
(3)必须具有自相关性，如果自相关系数(
)小于0.5，则不宜采用
(4)自回归只适用于预测与自身前期相关的现象
1.2.2 MA模型
移动平均模型(MA)关注的是自回归模型中的误差项的累加，移动平均法能有效地消除预测中的随机波动。
q阶自回归过程的公式定义：
其中，
是当前值， 是常数项，q是阶数， 是误差。
1.2.3 APIMA模型
自回归移动平均模型(ARMA)是自回归与移动平均的结合。
自回归移动平均模型(ARMA)公式定义：
ARIMA(p，d，q)模型全称为差分自回归移动平均模型，AR是自回归， p为自回归项； MA为移动平均，q为移动平均项数，d为时间序列成为平稳时所做的差分次数。
原理：将非平稳时间序列转化为平稳时间序列，然后将因变量仅对它的滞后值，以及随机误差项的现值和滞后值进行回归所建立的模型。
1.2.4 自相关函数ACF
有序的随机变量序列与其自身相比较，自相关函数反映了同一序列在不同时序的取值之间的相关性。
公式定义：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-12-05T13:26:47+08:00">
    <meta property="article:modified_time" content="2020-12-05T13:26:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">bic准则 python实现_python机器学习---时间序列算法 0117-2020</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>时间序列概念</p> 
 <p>时间序列建模步骤</p> 
 <p>时间序列python实现时间序列概念</p> 
 <p>时间序列是指将同一统计指标的数值按其发生的时间先后顺序排列而成的数列。时间序列分析的主要目的是根据已有的历史数据对未来进行预测。ARIMA时间序列建模步骤</p> 
 <p>本文利用 ARIMA构建高性能时间序列模型，来预测医保支出费用。对整个建模的步骤及步骤用到的技术进行总结：</p> 
 <p>1 建模步骤</p> 
 <p>ARIMA是一个非常强大的预测时间序列数据的模型，但是数据准备和参数调整过程是非常耗时的。在实现ARIMA之前，需要使数据保持平稳，并使用前面讨论的ACF和PACF图确定p和q的值，一般情况下，下面是实现ARIMA应该遵循的步骤：</p> 
 <p>(1) 加载数据，动态数据预处理：包括平稳性检验，及非平稳性数据处理，正太性检验；</p> 
 <p>(2) 时间序列模型ARIMA参数估计：包括q、d、p确定</p> 
 <p>(3) 建模，指标评估，残差检验</p> 
 <p>(4) 在验证集上进行预测：在验证集基础上进行预测</p> 
 <p>(5) 计算RMSE：用验证集上的预测值和实际值检查RMSE值</p> 
 <p>1.1 动态数据预处理</p> 
 <p>1.1.1 平稳性检验</p> 
 <p>时间序列的平稳性是我们建模的重要前提。一般说来，某个实测过程如果它的系统参数和运行时周围的条件不改变，即可视为平稳的。</p> 
 <p>平稳性要求序列的均值和方差不发生明显变化。</p> 
 <p>平稳性检验细化分为严平稳与弱平稳：</p> 
 <p>(1)严平稳：严平稳表示的分布不随时间的改变而改变。如：白噪声(正态)，无论怎么取，都是期望为0，方差为1。</p> 
 <p>(2)弱平稳：期望与相关系数(依赖性)不变，未来某时刻的t的值Xt就要依赖于它的过去信息，所以需要依赖性。</p> 
 <p>建模时，首先要对加载的原始数据进行平稳性检验，对于平稳的数据可直接进入下一步骤，对于非平稳数据，可进行差分处理，再进行后续步骤。</p> 
 <p>1.1.2 差分法</p> 
 <p>差分法：时间序列在t与t-1时刻的差值。</p> 
 <p>1.2 ARIMA模型参数估计</p> 
 <p>1.2.1 AR模型</p> 
 <p>自回归模型(AR)是描述当前值与历史值之间的关系，用变量自身的历史时间数据对自身进行预测。自回归模型必须满足平稳性的要求。</p> 
 <p>p阶自回归过程的公式定义：</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>其中，</p> 
 <p align="center"><img src="" alt=""> 是当前值， </p> 
 <p align="center"><img src="" alt=""> 是常数项，p是阶数， </p> 
 <p align="center"><img src="" alt=""> 是自相关系数， </p> 
 <p align="center"><img src="" alt=""> 是误差。</p> 
 <p>自回归模型的限制：</p> 
 <p>(1)自回归模型是用自身的数据来进行预测</p> 
 <p>(2)必须具有平稳性</p> 
 <p>(3)必须具有自相关性，如果自相关系数(</p> 
 <p align="center"><img src="" alt="">)小于0.5，则不宜采用</p> 
 <p>(4)自回归只适用于预测与自身前期相关的现象</p> 
 <p>1.2.2 MA模型</p> 
 <p>移动平均模型(MA)关注的是自回归模型中的误差项的累加，移动平均法能有效地消除预测中的随机波动。</p> 
 <p>q阶自回归过程的公式定义：</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>其中，</p> 
 <p align="center"><img src="" alt=""> 是当前值， </p> 
 <p align="center"><img src="" alt=""> 是常数项，q是阶数， </p> 
 <p align="center"><img src="" alt=""> 是误差。</p> 
 <p>1.2.3 APIMA模型</p> 
 <p>自回归移动平均模型(ARMA)是自回归与移动平均的结合。</p> 
 <p>自回归移动平均模型(ARMA)公式定义：</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>ARIMA(p，d，q)模型全称为差分自回归移动平均模型，AR是自回归， p为自回归项； MA为移动平均，q为移动平均项数，d为时间序列成为平稳时所做的差分次数。</p> 
 <p>原理：将非平稳时间序列转化为平稳时间序列，然后将因变量仅对它的滞后值，以及随机误差项的现值和滞后值进行回归所建立的模型。</p> 
 <p>1.2.4 自相关函数ACF</p> 
 <p>有序的随机变量序列与其自身相比较，自相关函数反映了同一序列在不同时序的取值之间的相关性。</p> 
 <p>公式定义：</p> 
 <p align="center"><img src="" alt=""></p> 
 <p align="center"><img src="" alt=""> 的取值范围为[-1,1]</p> 
 <p>1.2.5 偏自相关函数(PACF)</p> 
 <p>对于一个平稳AR(p)模型，求出滞后k自相关系数p(k)时，实际上得到并不是x(t)与x(t-k)之间单纯的相关关系，x(t)同时还会受到中间k-1个随机变量x(t-1)、x(t-2)、……、x(t-k+1)的影响，而这k-1个随机变量又都和x(t-k)具有相关关系，所以自相关系数p(k)里实际掺杂了其他变量对x(t)与x(t-k)的影响。</p> 
 <p>偏自相关函数是剔除了中间k-1个随机变量x(t-1)、x(t-2)、……、x(t-k+1)的干扰之后 x(t-k)对x(t)影响的相关程度。</p> 
 <p>总结的说，ACF还包含了其他变量的影响 而偏自相关系数PACF是严格这两个变量之间的相关性。</p> 
 <p>1.2.6 ARIMA(p,d,q)参数确定</p> 
 <p align="center">ARIMA(p,d,q)阶数确定可以概括为如下图：<img src="" alt=""></p> 
 <p>截尾：落在置信区间内(95%的点都符合该规则)。概括的说，AR(p) 看PACF MA(q) 看ACF。</p> 
 <p>1.3 ARIMA建模及评估</p> 
 <p>经过1.2节概述，ARIMA建模流程概括为：(1)将序列平稳(差分法确定d)；(2)p和q阶数确定：ACF与PACF；(3)ARIMA(p,d,q)。</p> 
 <p>模型选择AIC与BIC：</p> 
 <p>AIC：赤池信息准则(Akaike Information Criterion，AIC)</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>BIC：贝叶斯信息准则(Bayesian Information Criterion，BIC)</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>其中，k为模型参数个数，n为样本数量，L为似然函数。</p> 
 <p>根据AIC和BIC评估指标可以帮助确定最佳p、q阶数，使模型最优</p> 
 <p>1.4 ARIMA预测</p> 
 <p>1.5 误差评估</p> 
 <p>模型残差检验：通过以上的步骤确定模型参数之后，可将确定的参数代入模型，对数据进行预测，并进行可视化。</p> 
 <p>ARIMA模型的残差是否是平均值为0且方差为常数的正态分布</p> 
 <p>QQ图：线性即正态分布时间序列python实现</p> 
 <p>本文使用上一篇介绍的相关技术，对测试数据制作案例Demo，并将结果展示，后续有相关场景开发时，可参考</p> 
 <p>%matplotlib inline</p> 
 <p>import pandas as pd</p> 
 <p>import pandas_datareader</p> 
 <p>import datetime</p> 
 <p>import matplotlib.pylab as plt</p> 
 <p>import seaborn as sns</p> 
 <p>from matplotlib.pylab import style</p> 
 <p>from statsmodels.tsa.arima_model import ARIMA</p> 
 <p>from statsmodels.graphics.tsaplots import plot_acf, plot_pacf</p> 
 <p>style.use('ggplot')</p> 
 <p>plt.rcParams['font.sans-serif'] = ['SimHei']</p> 
 <p>plt.rcParams['axes.unicode_minus'] = False</p> 
 <p>stockFile = 'data/T10yr.csv'</p> 
 <p>stock = pd.read_csv(stockFile, index_col=0, parse_dates=[0])</p> 
 <p align="center">stock.head(10)<img src="" alt=""></p> 
 <p>stock_week = stock['Close'].resample('W-MON').mean()</p> 
 <p>stock_train = stock_week['2000':'2015']</p> 
 <p>stock_train.plot(figsize=(12,8))</p> 
 <p>plt.legend(bbox_to_anchor=(1.25, 0.5))</p> 
 <p>plt.title("Stock Close")</p> 
 <p align="center">sns.despine()<img src="" alt=""></p> 
 <p>stock_diff = stock_train.diff()</p> 
 <p>stock_diff = stock_diff.dropna()</p> 
 <p>plt.figure()</p> 
 <p>plt.plot(stock_diff)</p> 
 <p>plt.title('一阶差分')</p> 
 <p align="center">plt.show()<img src="" alt=""></p> 
 <p>acf = plot_acf(stock_diff, lags=20)</p> 
 <p>plt.title("ACF")</p> 
 <p align="center">acf.show()<img src="" alt=""></p> 
 <p>pacf = plot_pacf(stock_diff, lags=20)</p> 
 <p>plt.title("PACF")</p> 
 <p align="center">pacf.show()<img src="" alt=""></p> 
 <p>model = ARIMA(stock_train, order=(1, 1, 1),freq='W-MON')</p> 
 <p>result = model.fit()</p> 
 <p>#print(result.summary())</p> 
 <p>pred = result.predict('20140609', '20160701',dynamic=True, typ='levels')</p> 
 <p align="center">print (pred)<img src="" alt=""></p> 
 <p>plt.figure(figsize=(6, 6))</p> 
 <p>plt.xticks(rotation=45)</p> 
 <p>plt.plot(pred)</p> 
 <p align="center">plt.plot(stock_train)<img src="" alt=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bbe7d57b4bd4889fc8b10c572d0d8eec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【神器】这三款网络抓包工具在手，同事想甩锅都难！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f895cac4a2bcd4826ecc6959fd04d4db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">redis对象编码源码阅读——有序集合编码和转码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>