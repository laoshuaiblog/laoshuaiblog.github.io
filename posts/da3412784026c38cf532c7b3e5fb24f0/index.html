<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【TS】566- 一文读懂 TS 中 Object, object, {} 类型之间的区别 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/da3412784026c38cf532c7b3e5fb24f0/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="【TS】566- 一文读懂 TS 中 Object, object, {} 类型之间的区别">
  <meta property="og:description" content="创建了一个 “重学TypeScript” 的微信群，想加群的小伙伴，加我微信 &#34;semlinker&#34;，备注重学TS。
本文是 ”重学TS系列“ 第 27 篇文章，感谢您的阅读！
TypeScript 2.2 引入了被称为 object 类型的新类型，它用于表示非原始类型。在 JavaScript 中以下类型被视为原始类型：string、boolean、number、bigint、symbol、null 和 undefined。
所有其他类型均被视为非基本类型。新的 object 类型表示如下：
// All primitive types type Primitive = string | boolean | number | bigint | symbol | null | undefined; // All non-primitive types type NonPrimitive = object; 让我们看看 object 类型，如何让我们编写更精确的类型声明。
一、使用 object 类型进行类型声明 随着 TypeScript 2.2 的发布，标准库的类型声明已经更新，以使用新的对象类型。例如，Object.create() 和Object.setPrototypeOf() 方法，现在需要为它们的原型参数指定 object | null 类型：
// node_modules/typescript/lib/lib.es5.d.ts interface ObjectConstructor { create(o: object | null): any; setPrototypeOf(o: any, proto: object | null): any; // .">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-04-17T07:27:00+08:00">
    <meta property="article:modified_time" content="2020-04-17T07:27:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【TS】566- 一文读懂 TS 中 Object, object, {} 类型之间的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/b6/08/oSWZKkd8_o.png"></p> 
 <blockquote> 
  <p>创建了一个 “重学TypeScript” 的微信群，想加群的小伙伴，加我微信 <strong>"semlinker"</strong>，备注重学TS。</p> 
  <p>本文是 ”重学TS系列“ 第 <strong>27 </strong>篇文章，感谢您的阅读！</p> 
 </blockquote> 
 <p>TypeScript 2.2 引入了被称为 <code>object</code> 类型的新类型，它用于表示非原始类型。在 JavaScript 中以下类型被视为原始类型：<code>string</code>、<code>boolean</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>、<code>null</code> 和 <code>undefined</code>。</p> 
 <p>所有其他类型均被视为非基本类型。新的 <code>object</code> 类型表示如下：</p> 
 <pre class="has"><code class="language-go">// All primitive types
type Primitive = string 
 | boolean | number 
 | bigint | symbol 
 | null | undefined;

// All non-primitive types
type NonPrimitive = object;
</code></pre> 
 <p>让我们看看 <code>object</code> 类型，如何让我们编写更精确的类型声明。</p> 
 <h4>一、使用 object 类型进行类型声明</h4> 
 <p>随着 TypeScript 2.2 的发布，标准库的类型声明已经更新，以使用新的对象类型。例如，<code>Object.create()</code> 和<code>Object.setPrototypeOf()</code> 方法，现在需要为它们的原型参数指定 <code>object | null</code> 类型：</p> 
 <pre class="has"><code class="language-go">// node_modules/typescript/lib/lib.es5.d.ts
interface ObjectConstructor {
  create(o: object | null): any;
  setPrototypeOf(o: any, proto: object | null): any;
  // ...
}
</code></pre> 
 <p>将原始类型作为原型传递给 <code>Object.setPrototypeOf()</code> 或 <code>Object.create()</code> 将导致在运行时抛出类型错误。TypeScript 现在能够捕获这些错误，并在编译时提示相应的错误：</p> 
 <pre class="has"><code class="language-go">const proto = {};

Object.create(proto);     // OK
Object.create(null);      // OK
Object.create(undefined); // Error
Object.create(1337);      // Error
Object.create(true);      // Error
Object.create("oops");    // Error
</code></pre> 
 <p><code>object</code> 类型的另一个用例是作为 ES2015 的一部分引入的 WeakMap 数据结构。它的键必须是对象，不能是原始值。这个要求现在反映在类型定义中：</p> 
 <pre class="has"><code class="language-go">interface WeakMap&lt;K extends object, V&gt; {
  delete(key: K): boolean;
  get(key: K): V | undefined;
  has(key: K): boolean;
  set(key: K, value: V): this;
}
</code></pre> 
 <h4>二、Object vs object vs {}</h4> 
 <p>也许令人困惑的是，TypeScript 定义了几个类型，它们有相似的名字，但是代表不同的概念：</p> 
 <ul><li><p><code>object</code></p></li><li><p><code>Object</code></p></li><li><p><code>{}</code></p></li></ul> 
 <p>我们已经看到了上面的新对象类型。现在让我们讨论 <code>Object</code> 和 <code>{}</code> 表示什么。</p> 
 <h5>2.1 Object 类型</h5> 
 <p>TypeScript 定义了另一个与新的 <code>object</code> 类型几乎同名的类型，那就是 <code>Object</code> 类型。该类型是所有 Object 类的实例的类型。它由以下两个接口来定义：</p> 
 <ul><li><p>Object 接口定义了 Object.prototype 原型对象上的属性；</p></li><li><p>ObjectConstructor 接口定义了 Object 类的属性。</p></li></ul> 
 <p>下面我们来看一下上述两个接口的相关定义：</p> 
 <p>1、<code>Object</code> 接口定义</p> 
 <pre class="has"><code class="language-go">// node_modules/typescript/lib/lib.es5.d.ts

interface Object {
  constructor: Function;
  toString(): string;
  toLocaleString(): string;
  valueOf(): Object;
  hasOwnProperty(v: PropertyKey): boolean;
  isPrototypeOf(v: Object): boolean;
  propertyIsEnumerable(v: PropertyKey): boolean;
}
</code></pre> 
 <p>2、<code>ObjectConstructor</code> 接口定义</p> 
 <pre class="has"><code class="language-go">// node_modules/typescript/lib/lib.es5.d.ts

interface ObjectConstructor {
  /** Invocation via `new` */
  new(value?: any): Object;
  /** Invocation via function calls */
  (value?: any): any;

  readonly prototype: Object;

  getPrototypeOf(o: any): any;

  // ···
}

declare var Object: ObjectConstructor;
</code></pre> 
 <p>Object 类的所有实例都继承了 Object 接口中的所有属性。我们可以看到，如果我们创建一个返回其参数的函数：</p> 
 <p>传入一个 Object 对象的实例，它总是会满足该函数的返回类型 —— 即要求返回值包含一个 toString() 方法。</p> 
 <pre class="has"><code class="language-go">// Object: Provides functionality common to all JavaScript objects.
function f(x: Object): { toString(): string } {
  return x; // OK
}
</code></pre> 
 <p>而 <code>object</code> 类型，它用于表示非原始类型（undefined, null, boolean, number, bigint, string, symbol）。使用这种类型，我们不能访问值的任何属性。</p> 
 <h5>2.2 Object vs object</h5> 
 <p>有趣的是，类型 <code>Object</code> 包括原始值：</p> 
 <pre class="has"><code class="language-go">function func1(x: Object) { }
func1('semlinker'); // OK
</code></pre> 
 <p>为什么？<code>Object.prototype</code> 的属性也可以通过原始值访问：</p> 
 <pre class="has"><code class="language-go">&gt; 'semlinker'.hasOwnProperty === Object.prototype.hasOwnProperty
true
</code></pre> 
 <blockquote> 
  <p>感兴趣的读者，可以自行了解一下 “JavaScript 装箱和拆箱” 的相关内容。</p> 
 </blockquote> 
 <p>相反，<code>object</code> 类型不包括原始值：</p> 
 <pre class="has"><code class="language-go">function func2(x: object) { }

// Argument of type '"semlinker"' 
// is not assignable to parameter of type 'object'.(2345)
func2('semlinker'); // Error
</code></pre> 
 <p>需要注意的是，当对 Object 类型的变量进行赋值时，如果值对象属性名与 Object 接口中的属性冲突，则 TypeScript 编译器会提示相应的错误：</p> 
 <pre class="has"><code class="language-go">// Type '() =&gt; number' is not assignable to type 
// '() =&gt; string'.
// Type 'number' is not assignable to type 'string'.
const obj1: Object = { 
   toString() { return 123 } // Error
}; 
</code></pre> 
 <p>而对于 object 类型来说，TypeScript 编译器不会提示任何错误：</p> 
 <pre class="has"><code class="language-go">const obj2: object = { 
  toString() { return 123 } 
};
</code></pre> 
 <p>另外在处理 object 类型和字符串索引对象类型的赋值操作时，也要特别注意。比如：</p> 
 <pre class="has"><code class="language-go">let strictTypeHeaders: { [key: string]: string } = {};
let header: object = {};
header = strictTypeHeaders; // OK
// Type 'object' is not assignable to type '{ [key: string]: string; }'.
strictTypeHeaders = header; // Error
</code></pre> 
 <p>在上述例子中，最后一行会出现编译错误，这是因为 <code>{ [key: string]: string }</code> 类型相比 <code>object</code> 类型更加精确。而 <code>header = strictTypeHeaders;</code> 这一行却没有提示任何错误，是因为这两种类型都是非基本类型，<code>object</code> 类型比 <code>{ [key: string]: string }</code> 类型更加通用。</p> 
 <h5>2.3 空类型 {}</h5> 
 <p>还有另一种类型与之非常相似，即空类型：<code>{}</code>。它描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误：</p> 
 <pre class="has"><code class="language-go">// Type {}
const obj = {};

// Error: Property 'prop' does not exist on type '{}'.
obj.prop = "semlinker";
</code></pre> 
 <p>但是，你仍然可以使用在 Object 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用：</p> 
 <pre class="has"><code class="language-go">// Type {}
const obj = {};

// "[object Object]"
obj.toString();
</code></pre> 
 <p>在 JavaScript 中创建一个表示二维坐标点的对象很简单：</p> 
 <pre class="has"><code class="language-go">const pt = {}; 
pt.x = 3; 
pt.y = 4;
</code></pre> 
 <p>然而以上代码在 TypeScript 中，每个赋值语句都会产生错误：</p> 
 <pre class="has"><code class="language-go">const pt = {}; // (A)
// Property 'x' does not exist on type '{}'
pt.x = 3; // Error
// Property 'y' does not exist on type '{}'
pt.y = 4; // Error
</code></pre> 
 <p>这是因为第 A 行中的 pt 类型是根据它的值 {} 推断出来的，你只可以对已知的属性赋值。这个问题怎么解决呢？有些读者可能会先想到接口，比如这样子：</p> 
 <pre class="has"><code class="language-go">interface Point {
  x: number;
  y: number;
}

// Type '{}' is missing the following 
// properties from type 'Point': x, y(2739)
const pt: Point = {}; // Error
pt.x = 3;
pt.y = 4;
</code></pre> 
 <p>很可惜对于以上的方案，TypeScript 编译器仍会提示错误。那么这个问题该如何解决呢？其实我们可以直接通过对象字面量进行赋值：</p> 
 <pre class="has"><code class="language-go">const pt = { 
  x: 3,
  y: 4, 
}; // OK
</code></pre> 
 <p>而如果你需要一步一步地创建对象，你可以使用类型断言（as）来消除 TypeScript 的类型检查：</p> 
 <pre class="has"><code class="language-go">const pt = {} as Point; 
pt.x = 3;
pt.y = 4; // OK
</code></pre> 
 <p>但是更好的方法是声明变量的类型并一次性构建对象：</p> 
 <pre class="has"><code class="language-go">const pt: Point = { 
  x: 3,
  y: 4, 
};
</code></pre> 
 <p>另外在使用 <code>Object.assign</code> 方法合并多个对象的时候，你可能也会遇到以下问题：</p> 
 <pre class="has"><code class="language-go">const pt = { x: 666, y: 888 };
const id = { name: "semlinker" };
const namedPoint = {};
Object.assign(namedPoint, pt, id);

// Property 'name' does not exist on type '{}'.(2339)
namedPoint.name; // Error
</code></pre> 
 <p>这时候你可以使用对象展开运算符 <code>...</code> 来解决上述问题：</p> 
 <pre class="has"><code class="language-go">const pt = { x: 666, y: 888 };
const id = { name: "semlinker" };
const namedPoint = {...pt, ...id}

//(property) name: string
namedPoint.name // Ok
</code></pre> 
 <h4>三、对象字面量类型 vs 接口类型</h4> 
 <p>我们除了可以通过 Object 和 object 类型来描述对象之外，也可以通过对象的属性来描述对象：</p> 
 <pre class="has"><code class="language-go">// Object literal type
let obj3: { prop: boolean };

// Interface
interface ObjectType {
  prop: boolean;
}

let obj4: ObjectType;
</code></pre> 
 <p>在 TypeScript 中有两种定义对象类型的方法，它们非常相似：</p> 
 <pre class="has"><code class="language-go">// Object literal type
type ObjType1 = {
  a: boolean,
  b: number;
  c: string,
};

// Interface
interface ObjType2 {
  a: boolean,
  b: number;
  c: string,
}
</code></pre> 
 <p>在以上代码中，我们使用分号或逗号作为分隔符。尾随分隔符是允许的，也是可选的。好的，那么现在问题来了，对象字面量类型和接口类型之间有什么区别呢？下面我从以下几个方面来分析一下它们之间的区别：</p> 
 <h5>3.1 内联</h5> 
 <p>对象字面量类型可以内联，而接口不能：</p> 
 <pre class="has"><code class="language-go">// Inlined object literal type:
function f1(x: { prop: number }) {}

function f2(x: ObjectInterface) {} // referenced interface
interface ObjectInterface {
  prop: number;
}
</code></pre> 
 <h5>3.2 名称重复</h5> 
 <p>含有重复名称的类型别名是非法的：</p> 
 <pre class="has"><code class="language-go">// @ts-ignore: Duplicate identifier 'PersonAlias'. (2300)
type PersonAlias = {first: string};

// @ts-ignore: Duplicate identifier 'PersonAlias'. (2300)
type PersonAlias = {last: string};
</code></pre> 
 <blockquote> 
  <p>TypeScript 2.6 支持在 .ts 文件中通过在报错一行上方使用 <code>// @ts-ignore</code> 来忽略错误。</p> 
  <p><code>// @ts-ignore</code> 注释会忽略下一行中产生的所有错误。建议实践中在 <code>@ts-ignore</code>之后添加相关提示，解释忽略了什么错误。</p> 
  <p>请注意，这个注释仅会隐藏报错，并且我们建议你少使用这一注释。</p> 
 </blockquote> 
 <p>相反，含有重复名称的接口将会被合并：</p> 
 <pre class="has"><code class="language-go">interface PersonInterface {
  first: string;
}

interface PersonInterface {
  last: string;
}

const sem: PersonInterface = {
  first: 'Jiabao',
  last: 'Huang',
};
</code></pre> 
 <h5>3.3 映射类型</h5> 
 <p>对于映射类型（A行），我们需要使用对象字面量类型：</p> 
 <pre class="has"><code class="language-go">interface Point {
  x: number;
  y: number;
}

type PointCopy1 = {
  [Key in keyof Point]: Point[Key]; // (A)
};

// Syntax error:
// interface PointCopy2 {
//   [Key in keyof Point]: Point[Key];
// };
</code></pre> 
 <h5>3.4 多态 this 类型</h5> 
 <p>多态 this 类型仅适用于接口：</p> 
 <pre class="has"><code class="language-go">interface AddsStrings {
  add(str: string): this;
};

class StringBuilder implements AddsStrings {
  result = '';
  add(str: string) {
    this.result += str;
    return this;
  }
}
</code></pre> 
 <h4>四、总结</h4> 
 <p>相信很多刚接触 TypeScript 的读者，看到 Object、object 和 {} 这几种类型时，也会感到疑惑。因为不知道它们之间的有什么区别，什么时候使用？为了让读者能更直观的了解到它们之间的区别，最后我们来做个总结：</p> 
 <h5>4.1 object 类型</h5> 
 <p>object 类型是：TypeScript 2.2 引入的新类型，它用于表示非原始类型。</p> 
 <pre class="has"><code class="language-go">// node_modules/typescript/lib/lib.es5.d.ts
interface ObjectConstructor {
  create(o: object | null): any;
  // ...
}

const proto = {};

Object.create(proto);     // OK
Object.create(null);      // OK
Object.create(undefined); // Error
Object.create(1337);      // Error
Object.create(true);      // Error
Object.create("oops");    // Error
</code></pre> 
 <h5>4.2 Object 类型</h5> 
 <p>Object 类型：它是所有 Object 类的实例的类型。它由以下两个接口来定义：</p> 
 <p>它由以下两个接口来定义：</p> 
 <ul><li><p>Object 接口定义了 Object.prototype 原型对象上的属性；</p></li></ul> 
 <pre class="has"><code class="language-go">// node_modules/typescript/lib/lib.es5.d.ts

interface Object {
  constructor: Function;
  toString(): string;
  toLocaleString(): string;
  valueOf(): Object;
  hasOwnProperty(v: PropertyKey): boolean;
  isPrototypeOf(v: Object): boolean;
  propertyIsEnumerable(v: PropertyKey): boolean;
}
</code></pre> 
 <ul><li><p>ObjectConstructor 接口定义了 Object 类的属性。</p></li></ul> 
 <pre class="has"><code class="language-go">// node_modules/typescript/lib/lib.es5.d.ts

interface ObjectConstructor {
  /** Invocation via `new` */
  new(value?: any): Object;
  /** Invocation via function calls */
  (value?: any): any;

  readonly prototype: Object;

  getPrototypeOf(o: any): any;

  // ···
}

declare var Object: ObjectConstructor;
</code></pre> 
 <p>Object 类的所有实例都继承了 Object 接口中的所有属性。</p> 
 <h5>4.3 {} 类型</h5> 
 <p>{} 类型：它描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误。</p> 
 <pre class="has"><code class="language-go">// Type {}
const obj = {};

// Error: Property 'prop' does not exist on type '{}'.
obj.prop = "semlinker";
</code></pre> 
 <p>但是，你仍然可以使用在 Object 类型上定义的所有属性和方法。</p> 
 <h4>五、参考资源</h4> 
 <ul><li><p>the-object-type-in-typescript</p></li><li><p>typing-objects-typescript</p></li><li><p>difference-between-object-and-in-typescript</p></li></ul> 
 <p style="text-align: center">▼</p> 
 <p style="text-align: center">往期精彩回顾</p> 
 <p style="text-align: center">▼</p> 
 <p style="text-align: left"><a target="_blank" href="https://blog.csdn.net/qq_36380426/article/details/105177298" rel="noopener noreferrer"> </a></p> 
 <p><a target="_blank" href="https://blog.csdn.net/qq_36380426/article/details/105177298" rel="noopener noreferrer"> </a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a3b6dd302aa05af716d0bd70d8d7c682c9f4527a9a0c03cd107635711c394ab155127f9e&amp;idx=1&amp;mid=2247484142&amp;scene=21&amp;sn=946ba90d10e2625513f09e60a462b3a7#wechat_redirect" rel="nofollow"> </a></p> 
 <p><a target="_blank" href="https://blog.csdn.net/qq_36380426/article/details/105190380" rel="noopener noreferrer">掌握 TS 这些工具类型，让你开发事半功倍</a></p> 
 <p style="text-align: center"><a target="_blank" href="https://blog.csdn.net/qq_36380426/article/details/105190380" rel="noopener noreferrer">掌握 TS 这些工具类型，让你开发事半功倍</a></p> 
 <p style="text-align: left"><a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a3abdd302abdf2546a7e999ad080924f9a2c37e2ea7b72d8227632fa39dad053bec20628&amp;idx=1&amp;mid=2247484147&amp;scene=21&amp;sn=20dfc8704b2854e16cf558dd231871f5#wechat_redirect" rel="nofollow"> </a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a3abdd302abdf2546a7e999ad080924f9a2c37e2ea7b72d8227632fa39dad053bec20628&amp;idx=1&amp;mid=2247484147&amp;scene=21&amp;sn=20dfc8704b2854e16cf558dd231871f5#wechat_redirect" rel="nofollow"> </a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a3abdd302abdf2546a7e999ad080924f9a2c37e2ea7b72d8227632fa39dad053bec20628&amp;idx=1&amp;mid=2247484147&amp;scene=21&amp;sn=20dfc8704b2854e16cf558dd231871f5#wechat_redirect" rel="nofollow"> </a></p> 
 <a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a3abdd302abdf2546a7e999ad080924f9a2c37e2ea7b72d8227632fa39dad053bec20628&amp;idx=1&amp;mid=2247484147&amp;scene=21&amp;sn=20dfc8704b2854e16cf558dd231871f5#wechat_redirect" rel="nofollow"> <p>遇到这些 TS 问题你会头晕么？</p> </a> 
 <p style="text-align: center"><a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a3abdd302abdf2546a7e999ad080924f9a2c37e2ea7b72d8227632fa39dad053bec20628&amp;idx=1&amp;mid=2247484147&amp;scene=21&amp;sn=20dfc8704b2854e16cf558dd231871f5#wechat_redirect" rel="nofollow">遇到这些 TS 问题你会头晕么？</a></p> 
 <p style="text-align: left"><a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a38add302a9c01c9bea63f5974554e2a9ab856f1cb3b66620a02452d12d1967fb676dc9f&amp;idx=1&amp;mid=2247484114&amp;scene=21&amp;sn=af33c36580d21c2ffe4e8204f71c10b8#wechat_redirect" rel="nofollow"> </a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a38add302a9c01c9bea63f5974554e2a9ab856f1cb3b66620a02452d12d1967fb676dc9f&amp;idx=1&amp;mid=2247484114&amp;scene=21&amp;sn=af33c36580d21c2ffe4e8204f71c10b8#wechat_redirect" rel="nofollow"> </a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a38add302a9c01c9bea63f5974554e2a9ab856f1cb3b66620a02452d12d1967fb676dc9f&amp;idx=1&amp;mid=2247484114&amp;scene=21&amp;sn=af33c36580d21c2ffe4e8204f71c10b8#wechat_redirect" rel="nofollow"> </a></p> 
 <a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a38add302a9c01c9bea63f5974554e2a9ab856f1cb3b66620a02452d12d1967fb676dc9f&amp;idx=1&amp;mid=2247484114&amp;scene=21&amp;sn=af33c36580d21c2ffe4e8204f71c10b8#wechat_redirect" rel="nofollow"> <p>在 TS 中如何实现类型保护？类型谓词了解一下</p> </a> 
 <p style="text-align: center"><a href="http://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw%3D%3D&amp;chksm=ea47a38add302a9c01c9bea63f5974554e2a9ab856f1cb3b66620a02452d12d1967fb676dc9f&amp;idx=1&amp;mid=2247484114&amp;scene=21&amp;sn=af33c36580d21c2ffe4e8204f71c10b8#wechat_redirect" rel="nofollow">在 TS 中如何实现类型保护？类型谓词了解一下</a></p> 
 <p>聚焦全栈，专注分享 Angular、TypeScript、Node.js 、Spring 技术栈等全栈干货。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/197b62ae384683e985d68d47420cc55d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker 安装keepalived</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1500adf5f525f656be2af521626985be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Unity】在Inspector上显示自定义的位掩码枚举（Flags）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>