<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VC&#43;&#43; 的串口通讯 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/32c30a0e03058701460ee2d9a33d753a/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="VC&#43;&#43; 的串口通讯">
  <meta property="og:description" content="在VC&#43;&#43;中有两种方法可以进行串口通讯。一种是利用Microsoft公司提供的ActiveX控件 Microsoft Communications Control。另一种是直接用VC&#43;&#43;访问串口。下面将简述这两种方法。
一、Microsoft Communications Control
Microsoft公司在WINDOWS中提供了一个串口通讯控件，用它，我们可以很简单的利用串口进行通讯。在使用它之前，应将控件加在应用程序的对话框上。然后再用ClassWizard 生成相应的对象。现在我们可以使用它了。
该控件有很多自己的属性，你可以通过它的属性窗口来设置，也可以用程序设置。我推荐用程序设置，这样更灵活。
SetCommPort：指定使用的串口。
GetCommPort：得到当前使用的串口。
SetSettings：指定串口的参数。一般设为默认参数&#34;9600，N，8，1&#34;。这样方便与其他串口进行通讯。
GetSettings：取得串口参数。
SetPortOpen：打开或关闭串口，当一个程序打开串口时，另外的程序将无法使用该串口。
GetPortOpen：取得串口状态。
GetInBufferCount：输入缓冲区中接受到的字符数。
SetInPutLen：一次读取输入缓冲区的字符数。设置为0时，程序将读取缓冲区的全部字符。
GetInPut：读取输入缓冲区。
GetOutBufferCount：输出缓冲区中待发送的字符数。
SetOutPut：写入输出缓冲区。
一般而言，使用上述函数和属性就可以进行串口通讯了。以下是一个范例。
#define MESSAGELENGTH 100
class CMyDialog : public CDialog
{
protected: VARIANT InBuffer;
VARIANT OutBuffer;
CMSComm m_Com;
public:
......
}
BOOL CMyDiaLog::OnInitDialog()
{
CDialog::OnInitDialog();
m_Com.SetCommPort(1);
if (!m_Com.GetPortOpen()) {
m_Com.SetSettings(&#34;57600,N,8,1&#34;);
m_Com.SetPortOpen(true);
m_Com.SetInBufferCount(0);
SetTimer(1,10,NULL);
InBuffer.bstrVal=new unsigned short[MESSAGELENGTH];
OutBuffer.bstrVal=new unsigned short[MESSAGELENGTH];
OutBuffer.vt=VT_BSTR;
}
return true;
}
void CMyDiaLog::OnTimer(UINT nIDEvent) {
if (m_Com.">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2005-03-26T00:33:00+08:00">
    <meta property="article:modified_time" content="2005-03-26T00:33:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VC&#43;&#43; 的串口通讯</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="fontsize10" style="FONT-SIZE: 10.5pt">在VC++中有两种方法可以进行串口通讯。一种是利用Microsoft公司提供的ActiveX控件 Microsoft Communications Control。另一种是直接用VC++访问串口。下面将简述这两种方法。<br><br>　　一、Microsoft Communications Control<br><br>　　Microsoft公司在WINDOWS中提供了一个串口通讯控件，用它，我们可以很简单的利用串口进行通讯。在使用它之前，应将控件加在应用程序的对话框上。然后再用ClassWizard 生成相应的对象。现在我们可以使用它了。<br><br>　　该控件有很多自己的属性，你可以通过它的属性窗口来设置，也可以用程序设置。我推荐用程序设置，这样更灵活。<br><br>　　　SetCommPort：指定使用的串口。<br><br>　　　GetCommPort：得到当前使用的串口。<br><br>　　　SetSettings：指定串口的参数。一般设为默认参数"9600，N，8，1"。这样方便与其他串口进行通讯。<br><br>　　　GetSettings：取得串口参数。<br><br>　　　SetPortOpen：打开或关闭串口，当一个程序打开串口时，另外的程序将无法使用该串口。<br><br>　　　GetPortOpen：取得串口状态。<br><br>　　　GetInBufferCount：输入缓冲区中接受到的字符数。<br><br>　　　SetInPutLen：一次读取输入缓冲区的字符数。设置为0时，程序将读取缓冲区的全部字符。<br><br>　　　GetInPut：读取输入缓冲区。<br><br>　　　GetOutBufferCount：输出缓冲区中待发送的字符数。<br><br>　　　SetOutPut：写入输出缓冲区。<br><br>　　一般而言，使用上述函数和属性就可以进行串口通讯了。以下是一个范例。<br><br>#define MESSAGELENGTH 100<br><br>class CMyDialog : public CDialog<br>{<!-- --><br>protected: <br>VARIANT InBuffer;<br>VARIANT OutBuffer;<br>CMSComm m_Com;<br>public:<br>......<br>}<br><br>BOOL CMyDiaLog::OnInitDialog()<br>{<!-- --><br>CDialog::OnInitDialog();<br>m_Com.SetCommPort(1);<br>if (!m_Com.GetPortOpen()) {<!-- --><br>m_Com.SetSettings("57600,N,8,1");<br>m_Com.SetPortOpen(true);<br>m_Com.SetInBufferCount(0);<br>SetTimer(1,10,NULL);<br>InBuffer.bstrVal=new unsigned short[MESSAGELENGTH];<br>OutBuffer.bstrVal=new unsigned short[MESSAGELENGTH];<br>OutBuffer.vt=VT_BSTR;<br>}<br>return true;<br>}<br><br>void CMyDiaLog::OnTimer(UINT nIDEvent) <br>{<!-- --><br>if (m_Com.GetInBufferCount()&gt;=MESSAGELENGTH) {<!-- --><br>InBuffer=m_Com.GetInput();<br>// handle the InBuffer. <br>// Fill the OutBuffer. <br>m_Com.SetOutput(OutBuffer);<br>}<br>CDialog::OnTimer(nIDEvent);<br>}<br><br><br><br>　　用该控件传输的数据是UNICODE格式。关于UNICODE和ANSI的关系和转换请参看MSDN。 <br><br>　　关于该控件的其他详细资料请查看MSDN关于COMM CONTROL部分。<br><br>　　二、直接用VC++访问串口。<br><br>　　在VC++中，串口和磁盘文件可以统一的方式来简单读写。这两者几乎没有什么不同，只是在WINDOWS 9X下磁盘文件只能做同步访问，而串口只能做异步访问。<br><br>　　CreateFile：用指定的方式打开指定的串口。通常的方式为<br><br>　　m_hCom = CreateFile( "COM1", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL );<br><br>　　m_hCom为文件句柄。GENERIC_READ | GENERIC_WRITE指定可以对串口进行读写操作。第三个参数0表示串口为独占打开。OPEN_EXISTING表示当指定串口不存在时，程序将返回失败。 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED则表示文件属性。当打开串口时，必须指定 FILE_FLAG_OVERLAPPED，它表示文件或设备不会维护访问指针，则在读写时，必须使用OVERLAPPED 结构指定访问的文件偏移量。<br><br>　　　ReadFile：读取串口数据。<br><br>　　　WriteFile：向串口写数据。<br><br>　　　CloseHandle：关闭串口。<br><br>　　COMMTIMEOUTS：COMMTIMEOUTS主要用于串口超时参数设置。COMMTIMEOUTS结构如下：<br><br>typedef struct _COMMTIMEOUTS { <br>DWORD ReadIntervalTimeout; <br>DWORD ReadTotalTimeoutMultiplier; <br>DWORD ReadTotalTimeoutConstant; <br>DWORD WriteTotalTimeoutMultiplier; <br>DWORD WriteTotalTimeoutConstant; <br>} COMMTIMEOUTS,*LPCOMMTIMEOUTS; <br><br><br>　　ReadIntervalTimeout：两字符之间最大的延时，当读取串口数据时，一旦两个字符传输的时间差超过该时间，读取函数将返回现有的数据。设置为0表示该参数不起作用。 <br><br>　　ReadTotalTimeoutMultiplier：读取每字符间的超时。<br><br>　　ReadTotalTimeoutConstant：一次读取串口数据的固定超时。所以在一次读取串口的操作中，其超时为ReadTotalTimeoutMultiplier乘以读取的字节数再加上 ReadTotalTimeoutConstant。将ReadIntervalTimeout设置为MAXDWORD，并将ReadTotalTimeoutMultiplier 和ReadTotalTimeoutConstant设置为0，表示读取操作将立即返回存放在输入缓冲区的字符。<br><br>　　WriteTotalTimeoutMultiplier：写入每字符间的超时。<br><br>　　WriteTotalTimeoutConstant：一次写入串口数据的固定超时。所以在一次写入串口的操作中，其超时为WriteTotalTimeoutMultiplier乘以写入的字节数再加上 WriteTotalTimeoutConstant。<br><br>　　SetCommTimeouts函数可以设置某设备句柄的超时参数，要得到某设备句柄的超时参数可以用GetCommTimeouts函数。<br><br>　　DCB：DCB结构主要用于串口参数设置。该结构太庞大，这里就不一一讲述了，有兴趣者可查看MSDN关于DCB的描述。其中下面两个是比较重要的属性。<br><br>　　BaudRate：串口的通讯速度。一般设置为9600。<br><br>　　ByteSize：字节位数。一般设置为8。<br><br>　　DCB结构可以用SetCommState函数来设置，并可以用GetCommState来得到现有串口的属性。<br><br>　　SetupComm：设置串口输入、输出缓冲区。<br><br>　　OVERLAPPED：保存串口异步通讯的信息。具体结构如下：<br><br>typedef struct _OVERLAPPED { <br>DWORD Internal; <br>DWORD InternalHigh; <br>DWORD Offset; <br>DWORD OffsetHigh; <br>HANDLE hEvent; <br>} OVERLAPPED; <br><br><br>　　Internal，InternalHigh是保留给系统使用的，用户不需要设置。<br><br>　　Offset，OffsetHigh是读写串口的偏移量，一般设置OffsetHigh为NULL，可以支持2GB数据。<br><br>　　hEvent读写事件，因为串口是异步通讯，操作可能被其他进程堵塞，程序可以通过检查该时间来得知是否读写完毕。事件将在读写完成后，自动设置为有效。<br><br>　　通过以上这些函数和结构，我们就可以通过串口进行通讯了，现在我们具体看下面的实例：<br><br>BOOL CSerial::Open( int nPort, int nBaud )<br>{<!-- --><br>if( m_bOpened ) return( TRUE );<br><br>char szPort[15];<br>DCB dcb;<br><br>wsprintf( szPort, "COM%d", nPort );<br>m_hComDev = CreateFile( szPort, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL );<br>if( m_hComDev == NULL ) return( FALSE );<br><br>memset( &amp;m_OverlappedRead, 0, sizeof( OVERLAPPED ) );<br>memset( &amp;m_OverlappedWrite, 0, sizeof( OVERLAPPED ) );<br><br>COMMTIMEOUTS CommTimeOuts;<br>CommTimeOuts.ReadIntervalTimeout = 0xFFFFFFFF;<br>CommTimeOuts.ReadTotalTimeoutMultiplier = 0;<br>CommTimeOuts.ReadTotalTimeoutConstant = 0;<br>CommTimeOuts.WriteTotalTimeoutMultiplier = 0;<br>CommTimeOuts.WriteTotalTimeoutConstant = 5000;<br>SetCommTimeouts( m_hComDev, &amp;CommTimeOuts );<br><br>m_OverlappedRead.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );<br>m_OverlappedWrite.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );<br><br>dcb.DCBlength = sizeof( DCB );<br>GetCommState( m_hComDev, &amp;dcb );<br>dcb.BaudRate = nBaud;<br>dcb.ByteSize = 8;<br>if( !SetCommState( m_hComDev, &amp;dcb ) ||<br>!SetupComm( m_hComDev, 10000, 10000 ) ||<br>m_OverlappedRead.hEvent == NULL ||<br>m_OverlappedWrite.hEvent == NULL ){<!-- --><br>DWORD dwError = GetLastError();<br>if( m_OverlappedRead.hEvent != NULL ) CloseHandle( m_OverlappedRead.hEvent );<br>if( m_OverlappedWrite.hEvent != NULL ) CloseHandle( m_OverlappedWrite.hEvent );<br>CloseHandle( m_hComDev );<br>return FALSE;<br>}<br><br>m_bOpened = TRUE;<br><br>return m_bOpened;<br><br>}<br><br>int CSerial::InBufferCount( void )<br>{<!-- --><br><br>if( !m_bOpened || m_hComDev == NULL ) return( 0 );<br><br>DWORD dwErrorFlags;<br>COMSTAT ComStat;<br><br>ClearCommError( m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat );<br><br>return (int)ComStat.cbInQue;<br><br>}<br><br>DWORD CSerial::ReadData( void *buffer, DWORD dwBytesRead)<br>{<!-- --><br><br>if( !m_bOpened || m_hComDev == NULL ) return 0;<br><br>BOOL bReadStatus;<br>DWORD dwErrorFlags;<br>COMSTAT ComStat;<br><br>ClearCommError( m_hComDev, &amp;dwErrorFlags, &amp;ComStat );<br>if( !ComStat.cbInQue ) return 0;<br><br>dwBytesRead = min(dwBytesRead,(DWORD) ComStat.cbInQue);<br><br>bReadStatus = ReadFile( m_hComDev, buffer, dwBytesRead, &amp;dwBytesRead, &amp;m_OverlappedRead );<br>if( !bReadStatus ){<!-- --><br>if( GetLastError() == ERROR_IO_PENDING ){<!-- --><br>WaitForSingleObject( m_OverlappedRead.hEvent, 2000 );<br>return dwBytesRead;<br>}<br>return 0;<br>}<br><br>return dwBytesRead;<br><br>}<br><br>DWORD CSerial::SendData( const char *buffer, DWORD dwBytesWritten)<br>{<!-- --><br><br>if( !m_bOpened || m_hComDev == NULL ) return( 0 );<br><br>BOOL bWriteStat;<br><br>bWriteStat = WriteFile( m_hComDev, buffer, dwBytesWritten, &amp;dwBytesWritten, &amp;m_OverlappedWrite );<br>if( !bWriteStat){<!-- --><br>if ( GetLastError() == ERROR_IO_PENDING ) {<!-- --><br>WaitForSingleObject( m_OverlappedWrite.hEvent, 1000 );<br>return dwBytesWritten;<br>}<br>return 0;<br>}<br>return dwBytesWritten;<br><br>}<br><br><br><br>　　上述函数基本实现串口的打开，读写操作。本文章略去该串口类的说明和关闭函数。读者应该能将这些内容写完。接下来，你就可以在你的程序中调用该串口类了。关于本文有任何疑问，请与作者联系。<br><br>　　本文参考文献：MSDN 1999, Microsoft Corp</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df7ad00d84e8cf980bd7cd306bd56483/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第三章 传奇的开始--Delphi</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ecf08c6519993074b23e362a25f1e0e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第五章 逆转的奇迹</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>