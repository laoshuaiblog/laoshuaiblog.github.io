<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>「Redis」07 持久化操作（RDB、AOF） - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/4cb1831d421ae805833693183aa9739a/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="「Redis」07 持久化操作（RDB、AOF）">
  <meta property="og:description" content="笔记整理自【尚硅谷】Redis 6 入门到精通 超详细 教程
Redis——持久化操作（RDB、AOF） 1. RDB（Redis DataBase） 概述 RDB是什么
在指定的时间间隔内将内存中的数据集快照写入磁盘， 即 Snapshot 快照，恢复时是将快照文件直接读到内存里。 备份是如何执行的
Redis 会单独创建一个子进程（fork）来进行持久化会先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件替换上次持久化好的文件（内容覆盖到 dump.rdb）。整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。 Fork 作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程
在 Linux 程序中，fork() 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，Linux 中引入了 “写时复制技术”
一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程
RDB持久化流程
redis.conf dump 文件名字
在 redis.conf 中配置文件名称，默认为 dump.rdb。
dump 保存位置
rdb 文件的保存路径可以修改。默认为 Redis 启动时命令行所在的目录下。
stop-writes-on-bgsave-error
当 redis 无法写入磁盘，直接关闭 redis 的写操作。推荐 yes。
rdbcompression 压缩文件
对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis 会采用 LZF 算法 进行压缩。
如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能。推荐 yes。">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-22T19:20:01+08:00">
    <meta property="article:modified_time" content="2023-03-22T19:20:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">「Redis」07 持久化操作（RDB、AOF）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>笔记整理自<a href="https://www.bilibili.com/video/BV1Rv41177Af?p=1&amp;vd_source=13a619fab8ad1c8102b5202d7d2f2dfc" rel="nofollow">【尚硅谷】Redis 6 入门到精通 超详细 教程</a></p> 
</blockquote> 
<h2><a id="RedisRDBAOF_1"></a>Redis——持久化操作（RDB、AOF）</h2> 
<h3><a id="1_RDBRedis_DataBase_3"></a>1. RDB（Redis DataBase）</h3> 
<h4><a id="_5"></a>概述</h4> 
<p><strong>RDB是什么</strong></p> 
<ul><li>在指定的<font color="red">时间间隔</font>内将内存中的数据集<font color="red">快照</font>写入磁盘， 即 <em><strong>Snapshot</strong></em> 快照，恢复时是将快照文件直接读到内存里。</li></ul> 
<p><strong>备份是如何执行的</strong></p> 
<ul><li><em><strong>Redis</strong></em> 会单独创建一个子进程（<em><strong>fork</strong></em>）来进行持久化</li><li>会<font color="red">先</font>将数据<font color="red">写</font>入到一个<font color="red">临时文件</font>中，待持久化过程完成后，再将这个<font color="red">临时文件替换上次持久化</font>好的文件（内容覆盖到 <em><strong>dump.rdb</strong></em>）。</li><li>整个过程中，主进程是不进行任何 <em><strong>IO</strong></em> 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 <em><strong>RDB</strong></em> 方式要比 <em><strong>AOF</strong></em> 方式更加的高效。</li><li><strong><em>RDB</em> 的缺点是<font color="red">最后一次持久化后的数据可能丢失</font></strong>。</li></ul> 
<p><img src="https://images2.imgbox.com/c0/02/LBjvPiw0_o.png" alt="image-20220922111754078"></p> 
<h4><a id="Fork_20"></a>Fork</h4> 
<ul><li> <p>作用是复制一个与当前进程<font color="red">一样的进程</font>。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并<font color="red">作为原进程的子进程</font></p> </li><li> <p>在 <em><strong>Linux</strong></em> 程序中，<em><strong>fork()</strong></em> 会产生一个和父进程完全相同的子进程，但子进程在此后多会 <em><strong>exec</strong></em> 系统调用，出于效率考虑，<em><strong>Linux</strong></em> 中引入了 <font color="red"><strong>“写时复制技术”</strong></font></p> </li><li> <p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</p> </li></ul> 
<p><strong>RDB持久化流程</strong></p> 
<p><img src="https://images2.imgbox.com/c9/55/7YPcxKAb_o.png" alt="image-20220922113142962"></p> 
<h4><a id="redisconf_32"></a>redis.conf</h4> 
<ul><li> <p><strong><em>dump</em> 文件名字</strong></p> 
  <ul><li> <p>在 <em><strong>redis.conf</strong></em> 中配置文件名称，默认为 <em><strong>dump.rdb</strong></em>。</p> <p><img src="https://images2.imgbox.com/90/b9/KUsphWD8_o.png" alt="image-20220922110536871"></p> </li></ul> </li><li> <p><strong><em>dump</em> 保存位置</strong></p> 
  <ul><li> <p><em><strong>rdb</strong></em> 文件的保存路径可以修改。默认为 <em><strong>Redis</strong></em> 启动时命令行所在的目录下。</p> <p><img src="https://images2.imgbox.com/c9/49/NCjWCFOY_o.png" alt="image-20220922134225367"></p> <p><img src="https://images2.imgbox.com/a1/91/2AqbeqbF_o.png" alt="image-20220922120419576"></p> </li></ul> </li><li> <p><em><strong>stop-writes-on-bgsave-error</strong></em></p> 
  <ul><li> <p>当 <em><strong>redis</strong></em> 无法写入磁盘，直接关闭 <em><strong>redis</strong></em> 的写操作。推荐 <em><strong>yes</strong></em>。</p> <p><img src="https://images2.imgbox.com/f1/34/737dNsId_o.png" alt="image-20220922134154294"></p> </li></ul> </li><li> <p><em><strong>rdbcompression</strong></em> <strong>压缩文件</strong></p> 
  <ul><li> <p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，<em><strong>redis</strong></em> 会采用 <font color="red"><strong><em>LZF</em> 算法</strong></font> 进行压缩。</p> </li><li> <p>如果你不想消耗 <em><strong>CPU</strong></em> 来进行压缩的话，可以设置为关闭此功能。推荐 <em><strong>yes</strong></em>。</p> <p><img src="https://images2.imgbox.com/c4/90/3tXxcF92_o.png" alt="image-20220922134209030"></p> </li></ul> </li><li> <p><em><strong>rdbchecksum</strong></em> <strong>检查完整性</strong></p> 
  <ul><li> <p>在存储快照后，还可以让 <em><strong>redis</strong></em> 使用 <font color="red"><strong><em>CRC64</em> 算法</strong></font> 来进行数据校验。</p> 
    <ul><li>即检查数据是否完整、是否有损坏。</li></ul> </li><li> <p>但是这样做会增加大约 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             10 
            
           
             % 
            
           
          
            10\% 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8056em; vertical-align: -0.0556em;"></span><span class="mord">10%</span></span></span></span></span> 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。推荐 <em><strong>yes</strong></em>。</p> <p><img src="https://images2.imgbox.com/aa/a1/QJtQ3wMP_o.png" alt="image-20220922134240433"></p> </li></ul> </li></ul> 
<h4><a id="save_VS_bgsave_72"></a><strong>save</strong> VS bgsave</h4> 
<p><em><strong>RDB</strong></em> 持久化主要是通过<code>save</code>和<code>bgsave</code>两个命令对Redis数据库中当前的数据做<code>snapshot(快照)</code>并生成 <em><strong>rdb</strong></em> 文件来实现的。在 <em><strong>Redis</strong></em> 启动的时候会检测 <em><strong>rdb</strong></em> 文件，然后载入 <em><strong>rdb</strong></em> 文件中未过期的数据到服务器中。</p> 
<ul><li><code>save</code>时只管保存，其它不管，全部阻塞。手动保存。</li><li><code>bgsave</code>是非阻塞的，通过 <em><strong>fork</strong></em> 了一个子进程来完成的。</li></ul> 
<p><strong><em>save</em> 和 <em>bgsave</em> 的区别</strong></p> 
<ul><li><em><strong>save</strong></em>：直接调用 <code>rdbSave</code>函数 ，阻塞 <em><strong>Redis</strong></em> 主进程，直到保存完成为止。在主进程阻塞期间，服务器不能处理客户端的任何请求。</li><li><em><strong>bgsave</strong></em>：<font color="red"><strong><em>Redis</em> 会在后台异步进行快照操作，快照同时还可以响应客户端请求。</strong></font> 
  <ul><li><em><strong>fork</strong></em> 出一个子进程，子进程负责调用<code>rdbSave</code>函数，并在保存完成之后向主进程发送信号，通知保存已完成。</li><li><em><strong>Redis</strong></em> 服务器在<code>bgsave </code>执行期间仍然可以继续处理客户端的请求。</li></ul> </li></ul> 
<p><em><strong>RDB</strong></em> 可以通过向服务器提供配置信息来自动间隔性保存。如默认情况下服务器满足以下 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         3 
        
       
      
        3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span> 个条件中任意一个条件就会触发 <em><strong>bgsave</strong></em> 命令：</p> 
<pre><code>格式：
save 秒钟 写操作次数
save 900 1    // 服务器在900s(15min)之内，对数据库进行了至少1次修改
save 300 10   // 服务器在300s(5min)之内，对数据库进行了至少10次修改
save 60 10000 // 服务器在60s(1min)之内，对数据库进行了至少10000次修改
</code></pre> 
<p><em><strong>RDB</strong></em> 是整个内存的压缩过的 <em><strong>Snapshot</strong></em>，<em><strong>RDB</strong></em> 的数据结构，可以配置复合的快照触发条件。</p> 
<p>默认是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 分钟内改了 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         10000 
        
       
      
        10000 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">10000</span></span></span></span></span> 次，或 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         5 
        
       
      
        5 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span> 分钟内改了 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         10 
        
       
      
        10 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">10</span></span></span></span></span> 次，或 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         15 
        
       
      
        15 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">15</span></span></span></span></span> 分钟内改了 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 次。</p> 
<p>这种持久化方式被称为快照 <em><strong>snapshotting</strong></em>。</p> 
<ul><li> <p><font color="red">禁用</font></p> 
  <ul><li> <p><font color="red">不设置 <em><strong>save</strong></em> 指令</font>，或者<font color="red">给 <em><strong>save</strong></em> 传入空字符串</font></p> </li><li> <p>动态停止 <em><strong>RDB</strong></em>：<code>redis-cli config set save ""</code> # save后给空值，表示禁用保存策略</p> <p><img src="https://images2.imgbox.com/87/e4/U01VJanG_o.png" alt="image-20220922134052875"></p> </li></ul> </li></ul> 
<p>可以通过<code>lastsave</code>命令获取最后一次成功执行快照的时间。</p> 
<p>执行<code>flushall</code>命令，也会产生<code>dump.rdb</code>文件，但里面是空的，无意义。</p> 
<p><strong>rdb的备份</strong></p> 
<ul><li> <p>先通过<code>config get dir</code>：查询 <em><strong>rdb</strong></em> 文件的目录</p> </li><li> <p>将<code>*.rdb</code>的文件拷贝到别的地方</p> 
  <ul><li><code>cp dump.rdb dump2.rdb</code></li></ul> </li><li> <p><em><strong>rdb</strong></em> 的恢复</p> 
  <ul><li>关闭 <em><strong>Redis</strong></em></li><li>先把备份的文件拷贝到工作目录下：<code>cp dump2.rdb dump.rdb</code></li><li>启动 <em><strong>Redis</strong></em>, 备份数据会直接加载</li></ul> </li></ul> 
<h4><a id="_125"></a>优点</h4> 
<ul><li>适合大规模的数据恢复；</li><li>对数据完整性和一致性要求<font color="red">不高</font>更适合使用；</li><li><strong>节省磁盘空间</strong>；</li><li><strong>恢复速度快</strong>。</li></ul> 
<h4><a id="_132"></a>缺点</h4> 
<ul><li><em><strong>Fork</strong></em> 的时候，内存中的数据被克隆了一份，大致 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          2 
         
        
       
         2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span> 倍的膨胀性需要考虑。</li><li>虽然 <em><strong>Redis</strong></em> 在 <em><strong>fork</strong></em> 时使用了<font color="red"><strong>写时拷贝技术</strong></font>，但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果 <em><strong>Redis</strong></em> 意外 <em><strong>down</strong></em> 掉的话，就会丢失最后一次快照后的所有修改。</li></ul> 
<h4><a id="_138"></a>小总结</h4> 
<p><img src="https://images2.imgbox.com/b4/1f/ziE1svWh_o.png" alt="image-20220922122323962"></p> 
<h3><a id="2_AOFAppend_Only_File_142"></a>2. AOF（Append Only File）</h3> 
<h4><a id="_144"></a>概述</h4> 
<p>以<font color="red"><strong>日志</strong>的形式来记录每个写操作（增量保存）</font>，将 <em><strong>Redis</strong></em> 执行过的所有<strong>写</strong>指令记录下来<font color="red"><strong>（读操作不记录）</strong></font>， <font color="red"><strong>只许追加文件但不可以改写文件</strong></font>，<em><strong>Redis</strong></em> 启动之初会读取该文件重新构建数据，换言之，如果 <em><strong>Redis</strong></em> 重启就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p> 
<p><strong><em>AOF</em> 持久化流程</strong></p> 
<ul><li> <p>客户端的请求写命令会被 <em><strong>append</strong></em> 追加到 <em><strong>AOF</strong></em> 缓冲区内；</p> </li><li> <p><em><strong>AOF</strong></em> 缓冲区根据 <em><strong>AOF</strong></em> 持久化策略 <code>[always,everysec,no]</code> 将操作 <em><strong>sync</strong></em> 同步到磁盘的 <em><strong>AOF</strong></em> 文件中；</p> </li><li> <p><em><strong>AOF</strong></em> 文件大小超过重写策略或手动重写时，会对 <em><strong>AOF</strong></em> 文件 <em><strong>Rewrite</strong></em> 重写，压缩 <em><strong>AOF</strong></em> 文件容量；</p> </li><li> <p><em><strong>Redis</strong></em> 服务重启时，会重新 <em><strong>load</strong></em> 加载 <em><strong>AOF</strong></em> 文件中的写操作达到数据恢复的目的。</p> <p><img src="https://images2.imgbox.com/d2/2d/aSQzf7AA_o.png" alt="image-20220922143832996"></p> </li></ul> 
<p><em><strong>AOF</strong></em> 和 <em><strong>RDB</strong></em> 同时开启时，系统默认读取 <em><strong>AOF</strong></em> 的数据（数据不会存在丢失）。</p> 
<h4><a id="_162"></a>配置</h4> 
<ul><li> <p><strong><em>AOF</em> 默认不开启</strong></p> 
  <ul><li>此时我们将 <em><strong>AOF</strong></em> 开启，改为 <em><strong>yes</strong></em>。</li></ul> <p><img src="https://images2.imgbox.com/ce/ad/1Yn0fue5_o.png" alt="image-20220922143216278"></p> </li><li> <p><strong>文件名字</strong></p> 
  <ul><li>可以在<code>redis.conf</code>中配置文件名称，默认为 <code>appendonly.aof</code></li><li><em><strong>AOF</strong></em> 文件的保存路径，同 <em><strong>RDB</strong></em> 的路径一致。</li></ul> <p><img src="https://images2.imgbox.com/4f/ca/l2kPzysj_o.png" alt="image-20220922143237262"></p> <p><img src="https://images2.imgbox.com/42/eb/b6acW241_o.png" alt="image-20220922155529774"></p> </li><li> <p><strong><em>AOF</em> 启动/修复/恢复</strong></p> <p><em><strong>AOF</strong></em> 的备份机制和性能虽然和 <em><strong>RDB</strong></em> 不同，但是备份和恢复的操作同 <em><strong>RDB</strong></em> 一样，都是拷贝备份文件，需要恢复时再拷贝到 <em><strong>Redis</strong></em> 工作目录下，启动系统即加载。</p> 
  <ul><li>正常恢复 
    <ul><li>修改默认的 <em><strong>appendonly no</strong></em>，改为 <em><strong>yes</strong></em></li><li>将有数据的 <em><strong>aof</strong></em> 文件复制一份保存到对应目录（查看目录：config get dir）</li><li>恢复：重启 <em><strong>redis</strong></em> 然后重新加载</li></ul> </li><li>异常恢复 
    <ul><li>修改默认的 <em><strong>appendonly no</strong></em>，改为 <em><strong>yes</strong></em></li><li>如遇到 <em><strong>AOF</strong></em> 文件损坏，通过<code>/usr/local/bin/redis-check-aof--fix appendonly.aof</code>进行恢复</li><li>备份被写坏的 <em><strong>AOF</strong></em> 文件</li><li>恢复：重启 <em><strong>redis</strong></em>，然后重新加载</li></ul> </li></ul> </li><li> <p><strong><em>AOF</em> 同步频率设置</strong></p> 
  <ul><li><em><strong>appendfsync always</strong></em> 
    <ul><li>始终同步，每次 <em><strong>Redis</strong></em> 的写入都会立刻记入日志；</li><li>性能较差但数据完整性比较好。</li></ul> </li><li><em><strong>appendfsync everysec</strong></em>（推荐 并且也是默认） 
    <ul><li>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</li><li>这种策略可以兼顾速度和安全性。</li></ul> </li><li><em><strong>appendfsync no</strong></em> 
    <ul><li><em><strong>Redis</strong></em> 不主动进行同步，把同步时机交给操作系统。</li></ul> </li></ul> <p><img src="https://images2.imgbox.com/d3/71/7fzz3xd7_o.png" alt="image-20220922143311476"></p> </li></ul> 
<h4><a id="Rewrite__206"></a><em><strong>Rewrite</strong></em> 重写压缩</h4> 
<ul><li> <p><em><strong>AOF</strong></em> 采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当 <em><strong>AOF</strong></em> 文件的大小超过所设定的阈值时，<em><strong>Redis</strong></em> 可以在不打断服务客户端的情况下， 对 <em><strong>AOF</strong></em> 文件进行重建（<em><strong>rebuild</strong></em>）。</p> </li><li> <p>执行命令 <em><strong>bgrewriteaof</strong></em>，<em><strong>Redis</strong></em> 会将 <em><strong>AOF</strong></em> 文件的内容压缩，生成一个新的 <em><strong>AOF</strong></em> 文件，只保留可以恢复数据的<strong>最小</strong>指令集。</p> 
  <ul><li><em><strong>Redis2.2</strong></em> 需要自己手动执行 <em><strong>bgrewriteaof</strong></em> 命令；<em><strong>Redis2.4</strong></em> 则可以自动触发 <em><strong>AOF</strong></em> 重写</li></ul> <pre><code>set k1 v1
set k2 v2
      ↓
set k1 v1 k2 v2
</code></pre> </li></ul> 
<p><strong>重写原理，如何实现重写</strong></p> 
<ul><li><em><strong>AOF</strong></em> 文件持续增长而过大时，会 <em><strong>fork</strong></em> 出一条新进程来将文件重写（也是先写临时文件最后再 <em><strong>rename</strong></em>），redis4.0版本后的重写，是指就是把 <em><strong>rdb</strong></em> 的快照，以二级制的形式附在新的 <em><strong>aof</strong></em> 头部，作为已有的历史数据，替换掉原来的流水账操作。</li></ul> 
<p><em><strong>no-appendfsync-on-rewrite</strong></em>：</p> 
<ul><li>如果 <em><strong>no-appendfsync-on-rewrite=<code>yes</code></strong></em>，不写入 <em><strong>aof</strong></em> 文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</li><li>如果 <em><strong>no-appendfsync-on-rewrite=<code>no</code>,</strong></em> 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</li></ul> 
<p><strong>触发机制，何时重写</strong></p> 
<ul><li><em><strong>Redis</strong></em> 会记录上次重写时的 <em><strong>AOF</strong></em> 大小，默认配置是当 <em><strong>AOF</strong></em> 文件大小是上次 <em><strong>rewrite</strong></em> 后大小的一倍且文件大于 <em><strong>64M</strong></em> 时触发</li><li>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定 <em><strong>Redis</strong></em> 要满足一定条件才会进行重写。</li><li><em><strong>auto-aof-rewrite-percentage</strong></em>：设置重写的基准值，文件达到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          100 
         
        
          % 
         
        
       
         100\% 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8056em; vertical-align: -0.0556em;"></span><span class="mord">100%</span></span></span></span></span> 时开始重写（文件是原来重写后文件的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          2 
         
        
       
         2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span> 倍时触发）</li><li><em><strong>auto-aof-rewrite-min-size</strong></em>：设置重写的基准值，最小文件 <em><strong>64MB</strong></em>。达到这个值开始重写。</li><li>例如：文件达到 <em><strong>70MB</strong></em> 开始重写，降到 <em><strong>50MB</strong></em>，下次什么时候开始重写？<em><strong>100MB</strong></em></li><li>系统载入时或者上次重写完毕时，<em><strong>Redis</strong></em> 会记录此时 <em><strong>AOF</strong></em> 大小，设为 <em><strong>base_size</strong></em></li><li>如果 <em><strong>Redis</strong></em> 的<font color="red"> <em><strong>AOF</strong></em> 当前大小 <em><strong>&gt;= base_size + base_size×100%</strong></em></font>（默认）且 <font color="red">当前大小 <em><strong>&gt;=64mb</strong></em></font>（默认）的情况下，<em><strong>Redis</strong></em> 会对 <em><strong>AOF</strong></em> 进行重写。</li></ul> 
<p><img src="https://images2.imgbox.com/9a/73/f1xE2lJ7_o.png" alt="image-20220922143524347"></p> 
<p><strong>重写流程</strong></p> 
<ul><li><em><strong>bgrewriteaof</strong></em> 触发重写，判断是否当前有 <em><strong>bgsave</strong></em> 或 <em><strong>bgrewriteaof</strong></em> 在运行，如果有，则等待该命令结束后再继续执行。</li><li>主进程 <em><strong>fork</strong></em> 出子进程执行重写操作，保证主进程不会阻塞。</li><li>子进程遍历 <em><strong>redis</strong></em> 内存中数据到临时文件，客户端的写请求同时写入 <em><strong>aof_buf</strong></em> 缓冲区和 <em><strong>aof_rewrite_buf</strong></em> 重写缓冲区保证原 <em><strong>AOF</strong></em> 文件完整以及新 <em><strong>AOF</strong></em> 文件生成期间的新的数据修改动作不会丢失。</li><li>子进程写完新的 <em><strong>AOF</strong></em> 文件后，向主进程发信号，父进程更新统计信息。 
  <ul><li>主进程把 <em><strong>aof_rewrite_buf</strong></em> 中的数据写入到新的 <em><strong>AOF</strong></em> 文件。</li></ul> </li><li>使用新的 <em><strong>AOF</strong></em>文件覆盖旧的 <em><strong>AOF</strong></em> 文件，完成 <em><strong>AOF</strong></em> 重写。</li></ul> 
<p><img src="https://images2.imgbox.com/b5/95/08dYgdoq_o.png" alt="image-20220922155045827"></p> 
<h4><a id="_253"></a>优点</h4> 
<ul><li>备份机制更稳健，丢失数据概率更低；</li><li>可读的日志文本，通过操作 <em><strong>AOF</strong></em> 稳健，可以处理误操作。</li></ul> 
<h4><a id="_258"></a>缺点</h4> 
<ul><li>比起 <em><strong>RDB</strong></em> 占用更多的磁盘空间；</li><li>恢复备份速度要慢；</li><li>每次读写都同步的话，有一定的性能压力；</li><li>存在个别 <font color="red"><em>Bug</em></font>，造成不能恢复。</li></ul> 
<h4><a id="_265"></a>小总结</h4> 
<p><img src="https://images2.imgbox.com/56/0b/MwDcLZT8_o.png" alt="image-20220922143649566"></p> 
<h3><a id="3__269"></a>3. 总结</h3> 
<h4><a id="__271"></a>Ⅰ. 用哪个好</h4> 
<ul><li>官方推荐两个都启用。</li><li>如果对数据不敏感，可以选单独用 <em><strong>RDB</strong></em>。</li><li>不建议单独用 <em><strong>AOF</strong></em>，因为可能会出现 <font color="red"><em>Bug</em></font>。</li><li>如果只是做纯内存缓存，<strong>可以都不用。</strong></li></ul> 
<h4><a id="__278"></a>Ⅱ. 官网建议</h4> 
<ul><li><em><strong>RDB</strong></em> 持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li><li><em><strong>AOF</strong></em> 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据， <em><strong>AOF</strong></em> 命令以 <em><strong>redis</strong></em> 协议追加保存每次写的操作到文件末尾</li><li><em><strong>Redis</strong></em> 还能对 <em><strong>AOF</strong></em> 文件进行后台重写，使得 <em><strong>AOF</strong></em> 文件的体积不至于过大</li><li>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以<strong>不使用</strong>任何持久化方式.</li><li>同时开启两种持久化方式 
  <ul><li>在这种情况下，当 <em><strong>redis</strong></em> 重启的时候会优先载入 <em><strong>AOF</strong></em> 文件来恢复原始的数据，因为在通常情况下 <em><strong>AOF</strong></em> 文件保存的数据集要比 <em><strong>RDB</strong></em> 文件保存的数据集要完整</li></ul> </li><li><em><strong>RDB</strong></em> 的数据不实时，同时使用两者时服务器重启也只会找 <em><strong>AOF</strong></em> 文件。那要不要只使用 <em><strong>AOF</strong></em> 呢？</li><li>建议不要，因为 <em><strong>RDB</strong></em> 更适合用于备份数据库（<em><strong>AOF</strong></em> 在不断变化不好备份），快速重启，而且不会有 <em><strong>AOF</strong></em> 可能潜在的 <font color="red"><em>bug</em></font>，留着作为一个万一的手段。</li><li>性能建议 
  <ul><li>因为 <em><strong>RDB</strong></em> 文件只用作后备用途，建议只在 <font color="red"><em><strong>Slave</strong></em> 上持久化 <em><strong>RDB</strong></em> 文件</font>，而且只要 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            15 
           
          
         
           15 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">15</span></span></span></span></span> 分钟备份一次就够了，只保留 <code>save 900 1</code> 这条规则。</li><li>如果使用 <em><strong>AOF</strong></em>，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只 <em><strong>load</strong></em> 自己的 <em><strong>AOF</strong></em> 文件就可以了。</li><li>代价，一是带来了持续的 <em><strong>IO</strong></em>，二是 <em><strong>AOF</strong></em> <em><strong>rewrite</strong></em> 的最后将 <em><strong>rewrite</strong></em> 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</li><li>只要硬盘许可，应该尽量减少 <em><strong>AOF</strong></em> <em><strong>rewrite</strong></em> 的频率，<em><strong>AOF</strong></em> 重写的基础大小默认值 <em><strong>64M</strong></em> <font color="red">太小</font>了，可以设到 <font color="red"><em><strong>5G</strong></em></font> 以上。</li><li>默认超过原大小 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            100 
           
          
            % 
           
          
         
           100\% 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8056em; vertical-align: -0.0556em;"></span><span class="mord">100%</span></span></span></span></span> 大小时重写可以改到适当的数值。</li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29f62717d6e139a8abd1f00a14c21567/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软件工程用例图与类图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3bbde30ab1ba825c95f209167287a12a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Collectors.toMap 根据字段去重</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>