<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ã€C&#43;&#43;ã€‘æ‰‹æ’•å“ˆå¸Œè¡¨çš„é—­æ•£åˆ—å’Œå¼€æ•£åˆ— - è€å¸…çš„åšå®¢</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/eb58bfa102b47c1f350dc235ebbb9779/">
  <meta property="og:site_name" content="è€å¸…çš„åšå®¢">
  <meta property="og:title" content="ã€C&#43;&#43;ã€‘æ‰‹æ’•å“ˆå¸Œè¡¨çš„é—­æ•£åˆ—å’Œå¼€æ•£åˆ—">
  <meta property="og:description" content="&amp;gt; ä½œè€…ï¼šáƒ“æ—§è¨€~
&amp;gt; åº§å³é“­ï¼šæ¾æ ‘åƒå¹´ç»ˆæ˜¯æœ½ï¼Œæ§¿èŠ±ä¸€æ—¥è‡ªä¸ºè£ã€‚
&amp;gt; ç›®æ ‡ï¼šæ‰‹æ’•å“ˆå¸Œè¡¨çš„é—­æ•£åˆ—å’Œå¼€æ•£åˆ—
&amp;gt; æ¯’é¸¡æ±¤ï¼šè°ä¸æ˜¯ä¸€è¾¹å—ä¼¤ï¼Œä¸€è¾¹å­¦ä¼šåšå¼ºã€‚
&amp;gt; ä¸“æ é€‰è‡ªï¼šCå˜å˜è¿›é˜¶
&amp;gt; æœ›å°ä¼™ä¼´ä»¬ç‚¹èµğŸ‘æ”¶è—âœ¨åŠ å…³æ³¨å“ŸğŸ’•ğŸ’•
ğŸŒŸå‰è¨€ è°ˆåˆ°å“ˆå¸Œè¡¨ï¼Œå¤§å®¶éƒ½åšè¿‡è¿™æ ·çš„é¢˜ç›®ï¼Œç»Ÿè®¡å­—ç¬¦ä¸²çš„å­—æ¯ä¸ªæ•°ï¼Œåƒè¿™æ ·çš„é¢˜ç›®å¯ä»¥åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªå­—æ¯é‡‡ç”¨ a[&#39;ch&#39;]&#43;&#43; è®¡å…¥æ•°ç»„ä¸­ï¼Œè¿™æ ·çš„æ•°ç»„æˆ‘ä»¬ç§°ä¹‹ä¸ºå“ˆå¸Œè¡¨ï¼Œè¿™ç§å“ˆå¸Œè¡¨ä¹Ÿæ˜¯æœ€ç®€å•çš„ï¼Œå¦‚æœè¯´ä¸ºäº†æ–¹ä¾¿ç›´æ¥è°ƒç”¨å“ˆå¸Œè¡¨ï¼Œé‚£è¿™ä¸ªå“ˆå¸Œè¡¨è¯¥å¦‚ä½•æ¨¡æ‹Ÿå‘¢ï¼Ÿè¿™ä¸ªé—®é¢˜ä¹Ÿæ˜¯ä»Šå¤©æˆ‘ä»¬æ‰€æ¢è®¨çš„ï¼Œæ‰‹æ’•å“ˆå¸Œè¡¨ã€‚
â­ä¸»ä½“ å­¦ä¹ æ‰‹æ’•å“ˆå¸Œè¡¨çš„é—­æ•£åˆ—å’Œå¼€æ•£åˆ—å’±ä»¬æŒ‰ç…§ä¸‹é¢çš„å›¾è§£ï¼š
ğŸŒ™å“ˆå¸Œæ¦‚å¿µ çŸ¥è¯†å›é¡¾
åœ¨é¡ºåºç»“æ„ä»¥åŠå¹³è¡¡æ ‘ä¸­ï¼Œç”±äºå…ƒç´ å…³é”®ç ä¸å…¶å­˜å‚¨ä½ç½®ä¹‹é—´æ²¡æœ‰å¯¹åº”çš„å…³ç³»ï¼Œå› æ­¤åœ¨æŸ¥æ‰¾ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œå¿…é¡»è¦ç»è¿‡å…³é”®ç çš„å¤šæ¬¡æ¯”è¾ƒï¼›æ¯”å¦‚é¡ºåºè¡¨ä¸­éœ€è¦ä»è¡¨å¤´å¼€å§‹ä¾æ¬¡å¾€åæ¯”å¯¹å¯»æ‰¾ï¼ŒæŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå¹³è¡¡æ ‘ä¸­éœ€è¦ä»ç¬¬ä¸€å±‚å¼€å§‹é€å±‚å¾€ä¸‹æ¯”å¯¹å¯»æ‰¾ï¼ŒæŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦ä¸º O(logN)ï¼›å³æœç´¢çš„æ•ˆç‡å–å†³äºæœç´¢è¿‡ç¨‹ä¸­å…ƒç´ çš„æ¯”è¾ƒæ¬¡æ•°ã€‚
åˆ†ææ¢è®¨
å¦‚æœæ„é€ ä¸€ç§å­˜å‚¨ç»“æ„ï¼Œå¯ä»¥é€šè¿‡æŸç§å‡½æ•° (hashFunc) ä½¿å…ƒç´ çš„å­˜å‚¨ä½ç½®ä¸å®ƒçš„å…³é”®ç ä¹‹é—´èƒ½å¤Ÿå»ºç«‹ä¸€å¯¹ä¸€çš„æ˜ å°„å…³ç³»ï¼Œé‚£ä¹ˆåœ¨æŸ¥æ‰¾æ—¶é€šè¿‡è¯¥å‡½æ•°å°±å¯ä»¥å¾ˆå¿«æ‰¾åˆ°è¯¥å…ƒç´ ï¼›å½“å‘è¯¥ç»“æ„ä¸­ï¼š
æ’å…¥å…ƒç´ æ—¶ï¼šæ ¹æ®å¾…æ’å…¥å…ƒç´ çš„å…³é”®ç ï¼Œä»¥æ­¤å‡½æ•°è®¡ç®—å‡ºè¯¥å…ƒç´ çš„å­˜å‚¨ä½ç½®å¹¶æŒ‰æ­¤ä½ç½®è¿›è¡Œå­˜æ”¾ï¼›æœç´¢å…ƒç´ æ—¶ï¼šå¯¹å…ƒç´ çš„å…³é”®ç è¿›è¡ŒåŒæ ·çš„è®¡ç®—ï¼ŒæŠŠæ±‚å¾—çš„å‡½æ•°å€¼å½“åšå…ƒç´ çš„å­˜å‚¨ä½ç½®ï¼Œåœ¨ç»“æ„ä¸­æŒ‰æ­¤ä½ç½®å–å…ƒç´ æ¯”è¾ƒï¼Œè‹¥å…³é”®ç ç›¸ç­‰ï¼Œåˆ™æœç´¢æˆåŠŸã€‚ æ€»ç»“å½’çº³
è¯¥æ–¹æ³•å³ä¸º å“ˆå¸Œ (æ•£åˆ—) æ–¹æ³•ï¼Œå“ˆå¸Œæ–¹æ³•ä¸­ä½¿ç”¨çš„è½¬æ¢å‡½æ•°ç§°ä¸ºå“ˆå¸Œ (æ•£åˆ—) å‡½æ•°ï¼Œæ„é€ å‡ºæ¥çš„ç»“æ„ç§°ä¸ºå“ˆå¸Œè¡¨ (Hash Table) (æˆ–è€…ç§°æ•£åˆ—è¡¨)ã€‚
æ³¨æ„äº‹é¡¹
æˆ‘ä»¬ä¸Šé¢æåˆ°çš„ä¸ç®¡æ˜¯é¡ºåºæœç´¢ã€å¹³è¡¡æ ‘æœç´¢è¿˜æ˜¯å“ˆå¸Œæœç´¢ï¼Œå…¶ key å€¼éƒ½æ˜¯å”¯ä¸€çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœç´¢æ ‘ä¸­ä¸å…è®¸å‡ºç°ç›¸åŒ key å€¼çš„èŠ‚ç‚¹ï¼Œå“ˆå¸Œè¡¨ä¸­ä¹Ÿä¸å…è®¸å‡ºç°ç›¸åŒ key å€¼çš„å…ƒç´ ï¼Œæˆ‘ä»¬ä¸‹æ–‡æ‰€è¿›è¡Œçš„æ‰€æœ‰æ“ä½œä¹Ÿéƒ½æ˜¯åœ¨è¿™å‰æä¹‹ä¸Šè¿›è¡Œçš„ã€‚
ğŸŒ™å“ˆå¸Œå†²çª ä¸åŒå…³é”®å­—é€šè¿‡ç›¸åŒå“ˆå¸Œå“ˆæ•°è®¡ç®—å‡ºç›¸åŒçš„å“ˆå¸Œåœ°å€ï¼Œè¯¥ç§ç°è±¡ç§°ä¸ºå“ˆå¸Œå†²çªæˆ–å“ˆå¸Œç¢°æ’ã€‚
å“ˆå¸Œå†²çªæœ‰ä¸¤ç§å¸¸è§çš„è§£å†³åŠæ³•ï¼š
é—­æ•£åˆ— (å¼€æ”¾å®šå€æ³•)ï¼šå½“å‘ç”Ÿå“ˆå¸Œå†²çªæ—¶ï¼Œå¦‚æœå“ˆå¸Œè¡¨æœªè¢«è£…æ»¡ï¼Œè¯´æ˜åœ¨å“ˆå¸Œè¡¨ä¸­å¿…ç„¶è¿˜æœ‰ç©ºä½ç½®ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠ key å­˜æ”¾åˆ°å†²çªä½ç½®ä¸­çš„ â€œä¸‹ä¸€ä¸ªâ€ ç©ºä½ç½®ä¸­å»ï¼›å¼€æ•£åˆ— (é“¾åœ°å€æ³•)ï¼šé¦–å…ˆå¯¹å…³é”®ç é›†åˆç”¨æ•£åˆ—å‡½æ•°è®¡ç®—æ•£åˆ—åœ°å€ï¼Œå…·æœ‰ç›¸åŒåœ°å€çš„å…³é”®ç  (å“ˆå¸Œå†²çª) å½’äºåŒä¸€å­é›†åˆï¼Œæ¯ä¸€ä¸ªå­é›†åˆç§°ä¸ºä¸€ä¸ªæ¡¶ï¼Œå„ä¸ªæ¡¶ä¸­çš„å…ƒç´ é€šè¿‡ä¸€ä¸ªå•é“¾è¡¨é“¾æ¥èµ·æ¥ï¼Œå„é“¾è¡¨çš„å¤´ç»“ç‚¹å­˜å‚¨åœ¨å“ˆå¸Œè¡¨ä¸­ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“å‘ç”Ÿå“ˆå¸Œå†²çªæ—¶ï¼ŒæŠŠ key ç›´æ¥é“¾æ¥åœ¨è¯¥ä½ç½®çš„ä¸‹é¢ã€‚ ğŸŒ™å“ˆå¸Œå‡½æ•° å“ˆå¸Œå‡½æ•°æœ‰å¦‚ä¸‹è®¾è®¡åŸåˆ™ï¼š
å“ˆå¸Œå‡½æ•°çš„å®šä¹‰åŸŸå¿…é¡»åŒ…æ‹¬éœ€è¦å­˜å‚¨çš„å…¨éƒ¨å…³é”®ç ï¼Œè€Œå¦‚æœå“ˆå¸Œè¡¨å…è®¸æœ‰mä¸ªåœ°å€æ—¶ï¼Œå…¶å€¼åŸŸå¿…é¡»åœ¨0åˆ°m-1ä¹‹é—´ï¼›å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºæ¥çš„åœ°å€è¦å°½é‡èƒ½å‡åŒ€åˆ†å¸ƒåœ¨æ•´ä¸ªç©ºé—´ä¸­ï¼›å“ˆå¸Œå‡½æ•°åº”è¯¥æ¯”è¾ƒç®€å•ã€‚ ğŸ’«ç›´æ¥å®šå€æ³• ä»€ä¹ˆæ˜¯ç›´æ¥å®šå€æ³•ï¼š
ç›´æ¥å®šå€å°±æ˜¯æ ¹æ® key å€¼ç›´æ¥å¾—åˆ°å­˜å‚¨ä½ç½®ï¼Œæœ€å¤šå†è¿›è¡Œä¸€ä¸ªç®€å•çš„å¸¸æ•°ä¹‹é—´çš„è½¬æ¢ã€‚
åˆ†æï¼š">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-24T20:30:20+08:00">
    <meta property="article:modified_time" content="2024-03-24T20:30:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="è€å¸…çš„åšå®¢" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">è€å¸…çš„åšå®¢</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ã€C&#43;&#43;ã€‘æ‰‹æ’•å“ˆå¸Œè¡¨çš„é—­æ•£åˆ—å’Œå¼€æ•£åˆ—</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>&gt; ä½œè€…ï¼šáƒ“æ—§è¨€~<br> &gt; åº§å³é“­ï¼šæ¾æ ‘åƒå¹´ç»ˆæ˜¯æœ½ï¼Œæ§¿èŠ±ä¸€æ—¥è‡ªä¸ºè£ã€‚</p> 
 <p>&gt; ç›®æ ‡ï¼šæ‰‹æ’•å“ˆå¸Œè¡¨çš„é—­æ•£åˆ—å’Œå¼€æ•£åˆ—</p> 
 <p>&gt; æ¯’é¸¡æ±¤ï¼šè°ä¸æ˜¯ä¸€è¾¹å—ä¼¤ï¼Œä¸€è¾¹å­¦ä¼šåšå¼ºã€‚</p> 
 <p>&gt; ä¸“æ é€‰è‡ªï¼š<a href="https://blog.csdn.net/aalykk/category_12617655.html" title="Cå˜å˜è¿›é˜¶">Cå˜å˜è¿›é˜¶</a></p> 
 <p>&gt; æœ›å°ä¼™ä¼´ä»¬ç‚¹èµğŸ‘æ”¶è—âœ¨åŠ å…³æ³¨å“ŸğŸ’•ğŸ’•</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/59/1c/xpPmn5Hw_o.jpg"></p> 
<h2>ğŸŒŸå‰è¨€</h2> 
<p>è°ˆåˆ°å“ˆå¸Œè¡¨ï¼Œå¤§å®¶éƒ½åšè¿‡è¿™æ ·çš„é¢˜ç›®ï¼Œç»Ÿè®¡å­—ç¬¦ä¸²çš„å­—æ¯ä¸ªæ•°ï¼Œåƒè¿™æ ·çš„é¢˜ç›®å¯ä»¥åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªå­—æ¯é‡‡ç”¨ a['ch']++ è®¡å…¥æ•°ç»„ä¸­ï¼Œè¿™æ ·çš„æ•°ç»„æˆ‘ä»¬ç§°ä¹‹ä¸ºå“ˆå¸Œè¡¨ï¼Œè¿™ç§å“ˆå¸Œè¡¨ä¹Ÿæ˜¯æœ€ç®€å•çš„ï¼Œå¦‚æœè¯´ä¸ºäº†æ–¹ä¾¿ç›´æ¥è°ƒç”¨å“ˆå¸Œè¡¨ï¼Œé‚£è¿™ä¸ªå“ˆå¸Œè¡¨è¯¥å¦‚ä½•æ¨¡æ‹Ÿå‘¢ï¼Ÿè¿™ä¸ªé—®é¢˜ä¹Ÿæ˜¯ä»Šå¤©æˆ‘ä»¬æ‰€æ¢è®¨çš„ï¼Œæ‰‹æ’•å“ˆå¸Œè¡¨ã€‚</p> 
<h2><strong>â­ä¸»ä½“</strong></h2> 
<p>å­¦ä¹ æ‰‹æ’•å“ˆå¸Œè¡¨çš„é—­æ•£åˆ—å’Œå¼€æ•£åˆ—å’±ä»¬æŒ‰ç…§ä¸‹é¢çš„å›¾è§£ï¼š</p> 
<p><img alt="" height="617" src="https://images2.imgbox.com/55/a0/XutxgFoW_o.png" width="1076"></p> 
<p></p> 
<h3>ğŸŒ™å“ˆå¸Œæ¦‚å¿µ</h3> 
<p><span style="color:#4da8ee;"><strong>çŸ¥è¯†å›é¡¾</strong></span></p> 
<p>åœ¨é¡ºåºç»“æ„ä»¥åŠå¹³è¡¡æ ‘ä¸­ï¼Œç”±äºå…ƒç´ å…³é”®ç ä¸å…¶å­˜å‚¨ä½ç½®ä¹‹é—´æ²¡æœ‰å¯¹åº”çš„å…³ç³»ï¼Œå› æ­¤åœ¨æŸ¥æ‰¾ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œå¿…é¡»è¦ç»è¿‡å…³é”®ç çš„å¤šæ¬¡æ¯”è¾ƒï¼›æ¯”å¦‚é¡ºåºè¡¨ä¸­éœ€è¦ä»è¡¨å¤´å¼€å§‹ä¾æ¬¡å¾€åæ¯”å¯¹å¯»æ‰¾ï¼ŒæŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œå¹³è¡¡æ ‘ä¸­éœ€è¦ä»ç¬¬ä¸€å±‚å¼€å§‹é€å±‚å¾€ä¸‹æ¯”å¯¹å¯»æ‰¾ï¼ŒæŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦ä¸º O(logN)ï¼›å³æœç´¢çš„æ•ˆç‡å–å†³äºæœç´¢è¿‡ç¨‹ä¸­å…ƒç´ çš„æ¯”è¾ƒæ¬¡æ•°ã€‚</p> 
<p><span style="color:#4da8ee;"><strong>åˆ†ææ¢è®¨</strong></span></p> 
<p>å¦‚æœæ„é€ ä¸€ç§å­˜å‚¨ç»“æ„ï¼Œå¯ä»¥é€šè¿‡æŸç§å‡½æ•° (hashFunc) ä½¿å…ƒç´ çš„å­˜å‚¨ä½ç½®ä¸å®ƒçš„å…³é”®ç ä¹‹é—´èƒ½å¤Ÿå»ºç«‹ä¸€å¯¹ä¸€çš„æ˜ å°„å…³ç³»ï¼Œé‚£ä¹ˆåœ¨æŸ¥æ‰¾æ—¶é€šè¿‡è¯¥å‡½æ•°å°±å¯ä»¥å¾ˆå¿«æ‰¾åˆ°è¯¥å…ƒç´ ï¼›å½“å‘è¯¥ç»“æ„ä¸­ï¼š</p> 
<ul><li>æ’å…¥å…ƒç´ æ—¶ï¼šæ ¹æ®å¾…æ’å…¥å…ƒç´ çš„å…³é”®ç ï¼Œä»¥æ­¤å‡½æ•°è®¡ç®—å‡ºè¯¥å…ƒç´ çš„å­˜å‚¨ä½ç½®å¹¶æŒ‰æ­¤ä½ç½®è¿›è¡Œå­˜æ”¾ï¼›</li><li>æœç´¢å…ƒç´ æ—¶ï¼šå¯¹å…ƒç´ çš„å…³é”®ç è¿›è¡ŒåŒæ ·çš„è®¡ç®—ï¼ŒæŠŠæ±‚å¾—çš„å‡½æ•°å€¼å½“åšå…ƒç´ çš„å­˜å‚¨ä½ç½®ï¼Œåœ¨ç»“æ„ä¸­æŒ‰æ­¤ä½ç½®å–å…ƒç´ æ¯”è¾ƒï¼Œè‹¥å…³é”®ç ç›¸ç­‰ï¼Œåˆ™æœç´¢æˆåŠŸã€‚</li></ul> 
<p><span style="color:#4da8ee;"><strong>æ€»ç»“å½’çº³</strong></span></p> 
<p>è¯¥æ–¹æ³•å³ä¸º å“ˆå¸Œ (æ•£åˆ—) æ–¹æ³•ï¼Œå“ˆå¸Œæ–¹æ³•ä¸­ä½¿ç”¨çš„è½¬æ¢å‡½æ•°ç§°ä¸ºå“ˆå¸Œ (æ•£åˆ—) å‡½æ•°ï¼Œæ„é€ å‡ºæ¥çš„ç»“æ„ç§°ä¸ºå“ˆå¸Œè¡¨ (Hash Table) (æˆ–è€…ç§°æ•£åˆ—è¡¨)ã€‚</p> 
<p><span style="color:#4da8ee;"><strong>æ³¨æ„äº‹é¡¹</strong></span></p> 
<p>æˆ‘ä»¬ä¸Šé¢æåˆ°çš„ä¸ç®¡æ˜¯é¡ºåºæœç´¢ã€å¹³è¡¡æ ‘æœç´¢è¿˜æ˜¯å“ˆå¸Œæœç´¢ï¼Œå…¶ key å€¼éƒ½æ˜¯å”¯ä¸€çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœç´¢æ ‘ä¸­ä¸å…è®¸å‡ºç°ç›¸åŒ key å€¼çš„èŠ‚ç‚¹ï¼Œå“ˆå¸Œè¡¨ä¸­ä¹Ÿä¸å…è®¸å‡ºç°ç›¸åŒ key å€¼çš„å…ƒç´ ï¼Œæˆ‘ä»¬ä¸‹æ–‡æ‰€è¿›è¡Œçš„æ‰€æœ‰æ“ä½œä¹Ÿéƒ½æ˜¯åœ¨è¿™å‰æä¹‹ä¸Šè¿›è¡Œçš„ã€‚</p> 
<h3>ğŸŒ™å“ˆå¸Œå†²çª</h3> 
<p><strong>ä¸åŒå…³é”®å­—é€šè¿‡ç›¸åŒå“ˆå¸Œå“ˆæ•°è®¡ç®—å‡ºç›¸åŒçš„å“ˆå¸Œåœ°å€ï¼Œè¯¥ç§ç°è±¡ç§°ä¸ºå“ˆå¸Œå†²çªæˆ–å“ˆå¸Œç¢°æ’ã€‚</strong></p> 
<blockquote> 
 <p>å“ˆå¸Œå†²çªæœ‰ä¸¤ç§å¸¸è§çš„è§£å†³åŠæ³•ï¼š</p> 
 <ol><li>é—­æ•£åˆ— (å¼€æ”¾å®šå€æ³•)ï¼šå½“å‘ç”Ÿå“ˆå¸Œå†²çªæ—¶ï¼Œå¦‚æœå“ˆå¸Œè¡¨æœªè¢«è£…æ»¡ï¼Œè¯´æ˜åœ¨å“ˆå¸Œè¡¨ä¸­å¿…ç„¶è¿˜æœ‰ç©ºä½ç½®ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠ key å­˜æ”¾åˆ°å†²çªä½ç½®ä¸­çš„ â€œä¸‹ä¸€ä¸ªâ€ ç©ºä½ç½®ä¸­å»ï¼›</li><li>å¼€æ•£åˆ— (é“¾åœ°å€æ³•)ï¼šé¦–å…ˆå¯¹å…³é”®ç é›†åˆç”¨æ•£åˆ—å‡½æ•°è®¡ç®—æ•£åˆ—åœ°å€ï¼Œå…·æœ‰ç›¸åŒåœ°å€çš„å…³é”®ç  (å“ˆå¸Œå†²çª) å½’äºåŒä¸€å­é›†åˆï¼Œæ¯ä¸€ä¸ªå­é›†åˆç§°ä¸ºä¸€ä¸ªæ¡¶ï¼Œå„ä¸ªæ¡¶ä¸­çš„å…ƒç´ é€šè¿‡ä¸€ä¸ªå•é“¾è¡¨é“¾æ¥èµ·æ¥ï¼Œå„é“¾è¡¨çš„å¤´ç»“ç‚¹å­˜å‚¨åœ¨å“ˆå¸Œè¡¨ä¸­ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“å‘ç”Ÿå“ˆå¸Œå†²çªæ—¶ï¼ŒæŠŠ key ç›´æ¥é“¾æ¥åœ¨è¯¥ä½ç½®çš„ä¸‹é¢ã€‚</li></ol> 
</blockquote> 
<h3>ğŸŒ™å“ˆå¸Œå‡½æ•°</h3> 
<p><strong>å“ˆå¸Œå‡½æ•°æœ‰å¦‚ä¸‹è®¾è®¡åŸåˆ™</strong>ï¼š</p> 
<ol><li>å“ˆå¸Œå‡½æ•°çš„å®šä¹‰åŸŸå¿…é¡»åŒ…æ‹¬éœ€è¦å­˜å‚¨çš„å…¨éƒ¨å…³é”®ç ï¼Œè€Œå¦‚æœå“ˆå¸Œè¡¨å…è®¸æœ‰mä¸ªåœ°å€æ—¶ï¼Œå…¶å€¼åŸŸå¿…é¡»åœ¨0åˆ°m-1ä¹‹é—´ï¼›</li><li>å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºæ¥çš„åœ°å€è¦å°½é‡èƒ½å‡åŒ€åˆ†å¸ƒåœ¨æ•´ä¸ªç©ºé—´ä¸­ï¼›</li><li>å“ˆå¸Œå‡½æ•°åº”è¯¥æ¯”è¾ƒç®€å•ã€‚</li></ol> 
<h4><strong>Â ğŸ’«</strong><strong>ç›´æ¥å®šå€æ³•</strong></h4> 
<p><span style="color:#4da8ee;"><strong>ä»€ä¹ˆæ˜¯ç›´æ¥å®šå€æ³•ï¼š</strong></span></p> 
<p>ç›´æ¥å®šå€å°±æ˜¯æ ¹æ® key å€¼ç›´æ¥å¾—åˆ°å­˜å‚¨ä½ç½®ï¼Œæœ€å¤šå†è¿›è¡Œä¸€ä¸ªç®€å•çš„å¸¸æ•°ä¹‹é—´çš„è½¬æ¢ã€‚</p> 
<p><span style="color:#4da8ee;"><strong>åˆ†æï¼š</strong></span></p> 
<ul><li><strong>ç›´æ¥å®šå€æ³•çš„ä¼˜ç‚¹æ˜¯ç®€å•ï¼Œä¸”ä¸ä¼šå¼•èµ·å“ˆå¸Œå†²çª</strong>Â ï¼Œç”±äºç›´æ¥å®šå€æ³•çš„ key å€¼ç»è¿‡å“ˆå¸Œå‡½æ•°è½¬æ¢åå¾—åˆ°çš„å€¼ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼Œæ‰€ä»¥ä¸å­˜åœ¨å“ˆå¸Œå†²çªã€‚</li><li><strong>ç›´æ¥å®šå€æ³•é€‚ç”¨äºæ•°æ®èŒƒå›´é›†ä¸­çš„æƒ…å†µ</strong>ï¼Œè¿™æ · key å€¼æ˜ å°„åˆ°å“ˆå¸Œè¡¨åï¼Œå“ˆå¸Œè¡¨çš„ç©ºé—´åˆ©ç”¨ç‡é«˜ï¼Œæµªè´¹çš„ç©ºé—´è¾ƒå°‘</li></ul> 
<p><span style="color:#4da8ee;"><strong>å›¾è§£ï¼š</strong></span></p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/0f/9a/o0BEzSGc_o.png" width="951"></p> 
<h4><strong>Â ğŸ’«é™¤ç•™ä½™æ•°æ³•</strong></h4> 
<p><span style="color:#4da8ee;"><strong>ä»€ä¹ˆæ˜¯é™¤ç•™ä½™æ•°æ³•ï¼š</strong></span></p> 
<p>ç®€å•æ¥è¯´å°±æ˜¯ç”¨ key å€¼é™¤ä»¥å“ˆå¸Œè¡¨çš„å¤§å°å¾—åˆ°çš„ä½™æ•°ä½œä¸ºå“ˆå¸Œæ˜ å°„çš„åœ°å€ï¼Œå°† key ä¿å­˜åˆ°è¯¥åœ°å€ä¸­</p> 
<p><span style="color:#4da8ee;"><strong>åˆ†æï¼š</strong></span></p> 
<ul><li>é™¤ç•™ä½™æ•°çš„ä¼˜ç‚¹æ˜¯å¯ä»¥å¤„ç†æ•°æ®èŒƒå›´åˆ†æ•£çš„æ•°æ®</li><li>ç¼ºç‚¹æ˜¯ä¼šå¼•å‘å“ˆå¸Œå†²çª</li></ul> 
<p><span style="color:#4da8ee;"><strong>å›¾è§£ï¼š</strong></span></p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/01/91/HhYup99R_o.png" width="1050"></p> 
<h4><strong>Â ğŸ’«æ–¹æ³•æ€»ç»“</strong></h4> 
<p>ç›´æ¥å®šåˆ¶æ³•â€“(å¸¸ç”¨)</p> 
<ul><li>å–å…³é”®å­—çš„æŸä¸ªçº¿æ€§å‡½æ•°ä¸ºæ•£åˆ—åœ°å€ï¼šHashï¼ˆKeyï¼‰= A*Key + B ä¼˜ç‚¹ï¼šç®€å•ã€å‡åŒ€ ç¼ºç‚¹ï¼šéœ€è¦äº‹å…ˆçŸ¥é“å…³é”®å­—çš„åˆ†å¸ƒæƒ…å†µä½¿ç”¨åœºæ™¯ï¼šé€‚åˆæŸ¥æ‰¾æ¯”è¾ƒå°ä¸”è¿ç»­çš„æƒ…å†µ</li></ul> 
<p>é™¤ç•™ä½™æ•°æ³•â€“(å¸¸ç”¨)</p> 
<ul><li>è®¾æ•£åˆ—è¡¨ä¸­å…è®¸çš„åœ°å€æ•°ä¸ºmï¼Œå–ä¸€ä¸ªä¸å¤§äºmï¼Œä½†æœ€æ¥è¿‘æˆ–è€…ç­‰äºmçš„è´¨æ•°pä½œä¸ºé™¤æ•°ï¼ŒæŒ‰ç…§å“ˆå¸Œå‡½æ•°ï¼š**Hash(key) = key% p(p&lt;=m),**å°†å…³é”®ç è½¬æ¢æˆå“ˆå¸Œåœ°å€</li></ul> 
<p>å¹³æ–¹å–ä¸­æ³•â€“(äº†è§£)</p> 
<ul><li>å‡è®¾å…³é”®å­—ä¸º1234ï¼Œå¯¹å®ƒå¹³æ–¹å°±æ˜¯1522756ï¼ŒæŠ½å–ä¸­é—´çš„3ä½227ä½œä¸ºå“ˆå¸Œåœ°å€ï¼› å†æ¯”å¦‚å…³é”®å­—ä¸º4321ï¼Œå¯¹å®ƒå¹³æ–¹å°±æ˜¯18671041ï¼ŒæŠ½å–ä¸­é—´çš„3ä½671(æˆ–710)ä½œä¸ºå“ˆå¸Œåœ°å€ å¹³æ–¹å–ä¸­æ³•æ¯”è¾ƒé€‚åˆï¼šä¸çŸ¥é“å…³é”®å­—çš„åˆ†å¸ƒï¼Œè€Œä½æ•°åˆä¸æ˜¯å¾ˆå¤§çš„æƒ…å†µ</li></ul> 
<p>æŠ˜å æ³•â€“(äº†è§£)</p> 
<ul><li>æŠ˜å æ³•æ˜¯å°†å…³é”®å­—ä»å·¦åˆ°å³åˆ†å‰²æˆä½æ•°ç›¸ç­‰çš„å‡ éƒ¨åˆ†(æœ€åä¸€éƒ¨åˆ†ä½æ•°å¯ä»¥çŸ­äº›)ï¼Œç„¶åå°†è¿™å‡ éƒ¨åˆ†å åŠ æ±‚å’Œï¼Œå¹¶æŒ‰æ•£åˆ—è¡¨è¡¨é•¿ï¼Œå–åå‡ ä½ä½œä¸ºæ•£åˆ—åœ°å€ã€‚æŠ˜å æ³•é€‚åˆäº‹å…ˆä¸éœ€è¦çŸ¥é“å…³é”®å­—çš„åˆ†å¸ƒï¼Œé€‚åˆå…³é”®å­—ä½æ•°æ¯”è¾ƒå¤šçš„æƒ…å†µ</li></ul> 
<p>éšæœºæ•°æ³•â€“(äº†è§£)</p> 
<ul><li>é€‰æ‹©ä¸€ä¸ªéšæœºå‡½æ•°ï¼Œå–å…³é”®å­—çš„éšæœºå‡½æ•°å€¼ä¸ºå®ƒçš„å“ˆå¸Œåœ°å€ï¼Œå³H(key) = random(key),å…¶ä¸­randomä¸ºéšæœºæ•°å‡½æ•°ã€‚é€šå¸¸åº”ç”¨äºå…³é”®å­—é•¿åº¦ä¸ç­‰æ—¶é‡‡ç”¨æ­¤æ³•</li></ul> 
<p>æ•°å­¦åˆ†ææ³•â€“(äº†è§£)</p> 
<ul><li>è®¾æœ‰nä¸ªdä½æ•°ï¼Œæ¯ä¸€ä½å¯èƒ½æœ‰rç§ä¸åŒçš„ç¬¦å·ï¼Œè¿™rç§ä¸åŒçš„ç¬¦å·åœ¨å„ä½ä¸Šå‡ºç°çš„é¢‘ç‡ä¸ä¸€å®šç›¸åŒï¼Œå¯èƒ½åœ¨æŸäº›ä½ä¸Šåˆ†å¸ƒæ¯”è¾ƒå‡åŒ€ï¼Œæ¯ç§ç¬¦å·å‡ºç°çš„æœºä¼šå‡ç­‰ï¼Œåœ¨æŸäº›ä½ä¸Šåˆ†å¸ƒä¸å‡åŒ€åªæœ‰æŸå‡ ç§ç¬¦å·ç»å¸¸å‡ºç°ã€‚å¯æ ¹æ®æ•£åˆ—è¡¨çš„å¤§å°ï¼Œé€‰æ‹©å…¶ä¸­å„ç§ç¬¦å·åˆ†å¸ƒå‡åŒ€çš„è‹¥å¹²ä½ä½œä¸ºæ•£åˆ—åœ°å€ã€‚</li></ul> 
<h3>ğŸŒ™é—­æ•£åˆ—å“ˆå¸Œ</h3> 
<p>é—­æ•£åˆ—ä¹Ÿå«å¼€æ”¾å®šå€æ³•ï¼Œå½“å‘ç”Ÿå“ˆå¸Œå†²çªæ—¶ï¼Œå¦‚æœå“ˆå¸Œè¡¨æœªè¢«è£…æ»¡ï¼Œè¯´æ˜åœ¨å“ˆå¸Œè¡¨ä¸­å¿…ç„¶è¿˜æœ‰ç©ºä½ç½®ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠ key å­˜æ”¾åˆ°å†²çªä½ç½®ä¸­çš„ â€œä¸‹ä¸€ä¸ªâ€ ç©ºä½ç½®ä¸­å»ï¼›é‚£å¦‚ä½•å¯»æ‰¾ä¸‹ä¸€ä¸ªç©ºä½ç½®å‘¢ï¼Ÿæœ‰ä¸¤ç§æ–¹æ³• <strong>â€“ çº¿æ€§æ¢æµ‹æ³•å’ŒäºŒæ¬¡æ¢æµ‹æ³•ã€‚</strong></p> 
<h4><strong>Â ğŸ’«</strong>çº¿æ€§æ¢æµ‹æ³•</h4> 
<p><span style="color:#4da8ee;"><strong>ä»€ä¹ˆæ˜¯çº¿æ€§æ¢æµ‹ï¼š</strong></span></p> 
<p>çº¿æ€§æ¢æµ‹æ³•æ˜¯æŒ‡ä»å‘ç”Ÿå†²çªçš„ä½ç½®å¼€å§‹ï¼Œä¾æ¬¡å‘åæ¢æµ‹ï¼Œç›´åˆ°å¯»æ‰¾åˆ°ä¸‹ä¸€ä¸ªç©ºä½ç½®ä¸ºæ­¢</p> 
<p><span style="color:#4da8ee;"><strong>å›¾è§£ï¼š</strong></span></p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/11/f2/FNEn6sEX_o.png" width="1048"></p> 
<h4><strong>ğŸ’«</strong>å“ˆå¸Œè¡¨çš„åŸºæœ¬æ¡†æ¶</h4> 
<p><span style="color:#4da8ee;"><strong>æ¡†æ¶æ­å»ºæ­¥éª¤ï¼š</strong></span></p> 
<ul><li>åœ¨å“ˆå¸Œè¡¨ä¸­æˆ‘ä»¬ä½¿ç”¨äº† vector æ¥å­˜å‚¨æ•°æ®ï¼Œå¹¶å¢åŠ äº†ä¸€ä¸ªå˜é‡ n æ¥è®°å½•è¡¨ä¸­æœ‰æ•ˆæ•°æ®çš„ä¸ªæ•°ï¼›åŒæ—¶ï¼Œå“ˆå¸Œè¡¨çš„æ¯ä¸ªä¸‹æ ‡ä½ç½®å­˜å‚¨çš„æ•°æ®éƒ½æ˜¯ä¸€ä¸ª KV æ¨¡å‹çš„é”®å€¼å¯¹</li><li>å½“keyæ˜ å°„çš„ä¸‹æ ‡ä½ç½®è¢«å ç”¨æ—¶ï¼Œkeyä¼šå‘åå¯»æ‰¾ä¸‹ä¸€ä¸ªç©ºä½ç½®è¿›è¡Œæ’å…¥ï¼Œä½†å¦‚æœkeyèµ°åˆ°æ•°ç»„å°¾éƒ½è¿˜æ²¡æ‰¾åˆ°ç©ºä½ç½®ï¼Œé‚£ä¹ˆkeyå°±ä¼šä»æ•°ç»„èµ·å§‹ä½ç½®é‡æ–°å¾€åå¯»æ‰¾</li><li>åœ¨å“ˆå¸Œè¡¨çš„æ¯ä¸ªä½ç½®çš„æ•°æ®ä¸­è¿˜å¢åŠ äº†ä¸€ä¸ª state å˜é‡æ¥è®°å½•è¯¥ä½ç½®çš„çŠ¶æ€ (å­˜åœ¨ã€åˆ é™¤ã€ç©º)Â </li></ul> 
<p><span style="color:#4da8ee;"><strong>ä»£ç å¦‚ä¸‹ï¼š</strong></span></p> 
<pre><code class="language-cpp">//æ ‡è¯†æ¯ä¸ªå­˜å‚¨ä½ç½®çš„çŠ¶æ€--ç©ºã€å­˜åœ¨ä¸åˆ é™¤
enum State {
	EMPTY,
	EXIST,
	DELETE
};

//å“ˆå¸Œè¡¨æ¯ä¸ªä¸‹æ ‡ä½ç½®å­˜å‚¨çš„æ•°æ®çš„ç»“æ„
template&lt;class K, class V&gt;
struct HashData {
	pair&lt;K, V&gt; _kv;
	State _state = EMPTY;  //é»˜è®¤ä¸ºç©º
};

template&lt;class K, class V&gt;
class HashTable {
	typedef HashData&lt;K, V&gt; Data;
private:
	vector&lt;Data&gt; _tables;
	size_t _n;  //è®°å½•è¡¨ä¸­æœ‰æ•ˆæ•°æ®çš„ä¸ªæ•°
};
</code></pre> 
<h4><strong>ğŸ’«</strong>å“ˆå¸Œè¡¨çš„æ’å…¥åˆ é™¤ä¸æŸ¥æ‰¾</h4> 
<p><span style="color:#4da8ee;"><strong>æ’å…¥ï¼š</strong></span></p> 
<p>é€šè¿‡å“ˆå¸Œå‡½æ•°å¾—åˆ°ä½™æ•°å³æ•°ç»„ä¸‹æ ‡ï¼Œå¦‚æœè¯¥ä¸‹æ ‡çš„çŠ¶æ€ä¸ºåˆ é™¤æˆ–ä¸ºç©ºåˆ™æ’å…¥ï¼Œå¦‚æœä¸ºå­˜åœ¨åˆ™å‘åå¯»æ‰¾ä¸‹ä¸€ä¸ªçŠ¶æ€ä¸ºåˆ é™¤/ç©ºçš„ä½ç½®è¿›è¡Œæ’å…¥ã€‚</p> 
<p><span style="color:#4da8ee;"><strong>æŸ¥æ‰¾ï¼š</strong></span></p> 
<p>é€šè¿‡å“ˆå¸Œå‡½æ•°å¾—åˆ°ä½™æ•°å³æ•°ç»„ä¸‹æ ‡ï¼Œå–å‡ºå°æ ‡ä½ç½®çš„keyä¸ç›®æ ‡keyè¿›è¡Œæ¯”è¾ƒï¼Œç›¸ç­‰å°±è¿”å›è¯¥ä½ç½®çš„åœ°å€ï¼Œä¸ç›¸ç­‰å°±ç»§ç»­å¾€åæŸ¥æ‰¾ï¼Œå¦‚æœæŸ¥æ‰¾åˆ°çŠ¶æ€ä¸ºç©ºçš„ä¸‹æ ‡ä½ç½®å°±è¿”å› nullptrã€‚</p> 
<p><span style="color:#4da8ee;"><strong>åˆ é™¤ï¼š</strong></span></p> 
<p>å¤ç”¨æŸ¥æ‰¾å‡½æ•°ï¼ŒæŸ¥æ‰¾åˆ°å°±é€šè¿‡æŸ¥æ‰¾å‡½æ•°çš„è¿”å›å€¼å°†å°æ ‡ä½ç½®æ•°æ®çš„çŠ¶æ€ç½®ä¸º åˆ é™¤ï¼Œæ‰¾ä¸åˆ°å°±è¿”å› falseã€‚</p> 
<p><span style="color:#4da8ee;"><strong>ä»£ç å®ç°ï¼š</strong></span></p> 
<pre><code class="language-cpp">#pragma once

#include &lt;vector&gt;
#include &lt;utility&gt;
using std::pair;
using std::vector;

//æ ‡è¯†æ¯ä¸ªå­˜å‚¨ä½ç½®çš„çŠ¶æ€--ç©ºã€å­˜åœ¨ä¸åˆ é™¤
enum State {
	EMPTY,
	EXIST,
	DELETE
};

//å“ˆå¸Œè¡¨æ¯ä¸ªä¸‹æ ‡ä½ç½®å­˜å‚¨çš„æ•°æ®çš„ç»“æ„
template&lt;class K, class V&gt;
struct HashData {
	pair&lt;K, V&gt; _kv;
	State _state = EMPTY;  //é»˜è®¤ä¸ºç©º
};

//å“ˆå¸Œè¡¨
template&lt;class K, class V&gt;
class HashTable {
	typedef HashData&lt;K, V&gt; Data;

public:
	HashTable()
		: _n(0)
	{
		//å°†å“ˆå¸Œè¡¨çš„å¤§å°é»˜è®¤ç»™ä¸º10
		_tables.resize(10);
	}

	bool insert(const pair&lt;K, V&gt;&amp; kv) {
		if (find(kv.first))
			return false;

		//é™¤ç•™ä½™æ•°æ³• &amp;&amp; çº¿æ€§æ¢æµ‹æ³•
		//å°†æ•°æ®æ˜ å°„åˆ° æ•°æ®çš„keyå€¼é™¤ä»¥å“ˆå¸Œè¡¨çš„å¤§å°å¾—åˆ°çš„ä½™æ•° çš„ä½ç½®ï¼Œå¦‚æœè¯¥ä½ç½®è¢«å ç”¨å¾€åæ”¾
		size_t hashi = kv.first % _tables.size();
		//ä¸èƒ½æ”¾åœ¨EXISTçš„ä½ç½®ï¼ŒDELETEå’ŒEMPTYéƒ½èƒ½æ”¾
		while (_tables[hashi]._state == EXIST) {
			++hashi;
			if (hashi == _tables.size()) hashi = 0;  //å¦‚æœæ¢æµ‹åˆ°æœ«å°¾åˆ™ä»å¤´å¼€å§‹é‡æ–°æ¢æµ‹
		}

		_tables[hashi]._kv = kv;
		_tables[hashi]._state = EXIST;
		++_n;

		return true;
	}

		//å°†findçš„è¿”å›å€¼å®šä¹‰ä¸ºDataçš„åœ°å€ï¼Œå¯ä»¥æ–¹ä¾¿æˆ‘ä»¬è¿›è¡Œåˆ é™¤ä»¥åŠä¿®æ”¹V
		Data* find(const K&amp; key) {
			Hash hash;  //ä»¿å‡½æ•°å¯¹è±¡
			size_t hashi = hash(key) % _tables.size();
			//è®°å½•hashiçš„èµ·å§‹ä½ç½®ï¼Œé¿å…å“ˆå¸Œè¡¨ä¸­å…ƒç´ å…¨ä¸ºEXISTå’ŒDELETEæ—¶å¯¼è‡´æ­»å¾ªç¯
			size_t starti = hashi;
			//æœ€å¤šæ‰¾åˆ°ç©º
			while (_tables[hashi]._state != EMPTY) {
				//keyç›¸ç­‰å¹¶ä¸”stateä¸ºEXISTæ‰è¡¨ç¤ºæ‰¾åˆ°
				if (_tables[hashi]._kv.first == key &amp;&amp; _tables[hashi]._state == EXIST)
					return &amp;_tables[hashi];
				++hashi;
				//å¦‚æœæ‰¾åˆ°å°¾è¿˜æ²¡æ‰¾åˆ°ï¼Œå°±ä»0é‡æ–°æ‰¾
				if (hashi == _tables.size()) hashi = 0;
				//å¦‚æœæ‰¾ä¸€åœˆè¿˜æ²¡æ‰¾åˆ°ï¼Œå°±è·³å‡ºå¾ªç¯
				if (hashi == starti) break;
			}

			return nullptr;
		}

	bool erase(const K&amp; key) {
		//æ‰¾ä¸åˆ°å°±ä¸åˆ ï¼Œæ‰¾åˆ°å°±æŠŠçŠ¶æ€ç½®ä¸ºDELETEå³å¯
		Data* ret = find(key);
		if (ret) {
			ret-&gt;_state = DELETE;
			return true;
		}

		return false;
	}

private:
	vector&lt;Data&gt; _tables;
	size_t _n;  //è®°å½•è¡¨ä¸­æœ‰æ•ˆæ•°æ®çš„ä¸ªæ•°
};
</code></pre> 
<h4><strong>ğŸ’«</strong>å“ˆå¸Œè¡¨çš„æ‰©å®¹</h4> 
<p>å“ˆå¸Œè¡¨çš„æ‰©å®¹å’Œæ™®é€šé¡ºåºè¡¨å®¹å™¨çš„æ‰©å®¹ä¸åŒï¼Œå®ƒä¸æ˜¯å®¹å™¨æ»¡äº†æ‰æ‰©å®¹ï¼Œè€Œæ˜¯ä¼šæœ‰ä¸€ä¸ªè´Ÿè½½å› å­ï¼Œä¹Ÿå«è½½è·å› å­ï¼Œå½“è½½è·å› å­è¶…è¿‡ä¸€å®šå¤§å°æ—¶å°±ç«‹å³æ‰©å®¹ã€‚</p> 
<p><span style="color:#4da8ee;"><strong>ä»£ç å¦‚ä¸‹ï¼š</strong></span></p> 
<pre><code class="language-cpp">bool insert(const pair&lt;K, V&gt;&amp; kv) {
    if (find(kv.first))
        return false;

    //å¦‚æœå¤§äºæ ‡å®šçš„è½½è·å› å­å°±æ‰©å®¹ï¼Œè¿™é‡Œæˆ‘ä»¬å°†è½½è·å› å­æ ‡å®šä¸º0.7
    //æ‰©å®¹ç°ä»£å†™æ³•--å¤ç”¨insertæ¥å£
    if ((1.0 * _n / _tables.size()) &gt;= 0.7) {
        HashTable&lt;K, V&gt; newHT;
        newHT._tables.resize(_tables.size() * 2);

        for (auto&amp; e : _tables)
            newHT.insert(e._kv);

        _tables.swap(newHT._tables);
    }

    //é™¤ç•™ä½™æ•°æ³• &amp;&amp; çº¿æ€§æ¢æµ‹æ³•
    //å°†æ•°æ®æ˜ å°„åˆ° æ•°æ®çš„keyå€¼é™¤ä»¥å“ˆå¸Œè¡¨çš„å¤§å°å¾—åˆ°çš„ä½™æ•° çš„ä½ç½®ï¼Œå¦‚æœè¯¥ä½ç½®è¢«å ç”¨å¾€åæ”¾
    size_t hashi = kv.first % _tables.size();
    //ä¸èƒ½æ”¾åœ¨EXISTçš„ä½ç½®ï¼ŒDELETEå’ŒEMPTYéƒ½èƒ½æ”¾
    while (_tables[hashi]._state == EXIST) {
        ++hashi;
        if (hashi == _tables.size()) hashi = 0;  //å¦‚æœæ¢æµ‹åˆ°æœ«å°¾åˆ™ä»å¤´å¼€å§‹é‡æ–°æ¢æµ‹
    }

    _tables[hashi]._kv = kv;
    _tables[hashi]._state = EXIST;
    ++_n;

    return true;
}
</code></pre> 
<h4><strong>ğŸ’«</strong>å“ˆå¸Œè¡¨çš„ä»¿å‡½æ•°</h4> 
<p>æ¨¡æ¿å‚æ•°æ˜¯ä¸€ä¸ªä»¿å‡½æ•°ï¼Œä»¿å‡½æ•°åˆ†ä¸ºè®¾è®¡è€…æä¾›çš„é»˜è®¤ä»¿å‡½æ•°å’Œç”¨æˆ·æä¾›çš„ä»¿å‡½æ•°ï¼Œç³»ç»Ÿé»˜è®¤çš„ä»¿å‡½æ•°å¯ä»¥å°†ä¸€äº›å¸¸è§çš„ key çš„ç±»å‹å…¨éƒ¨è½¬åŒ–ä¸ºæ•´å½¢ï¼Œæ¯”å¦‚å­—ç¬¦ä¸²ã€æŒ‡é’ˆã€æ•´æ•°ï¼›è€Œç”¨æˆ·æä¾›çš„ä»¿å‡½æ•°åˆ™å¯ä»¥æ ¹æ®ç”¨æˆ·è‡ªå·±çš„ key ç±»å‹å°†å…¶è½¬åŒ–ä¸ºæ•´å½¢ï¼Œæ¯”å¦‚ People ç±» (èº«ä»½è¯å·)ã€Date ç±» ç­‰ç­‰</p> 
<p><span style="color:#4da8ee;"><strong>ä»£ç å¦‚ä¸‹ï¼š</strong></span></p> 
<pre><code class="language-cpp">template&lt;&gt;
struct HashFunc&lt;string&gt; {
	size_t operator()(const string&amp; key) {
		size_t sum = 0;
		for (auto ch : key)
			sum += ch;

		return sum;
	}
};
</code></pre> 
<p><span style="color:#4da8ee;"><strong>ç»†èŠ‚åˆ†æï¼š</strong></span></p> 
<p>æœ‰äº†ä»¿å‡½æ•°ï¼Œè§£å†³äº†ä¼ å­—ç¬¦ä¸²çš„é—®é¢˜</p> 
<h4><strong>ğŸ’«é—­æ•£åˆ—</strong>æ•´ä½“ä»£ç å®ç°</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
using namespace std;

// å“ˆå¸Œè¡¨çš„ä»¿å‡½æ•° ï¼Œé€šè¿‡ä¸Šå±‚å®¹å™¨æä¾›çš„ä»¿å‡½æ•°è·å–åˆ°å…ƒç´ çš„é”®å€¼
template&lt;class K&gt;
struct HashFunc
{
	size_t operator()(const K&amp; key)
	{
		return (size_t)key;
	}
};

// ç±»æ¨¡æ¿ç‰¹åŒ–
template&lt;&gt;
struct HashFunc&lt;string&gt;
{
	size_t operator()(const string&amp; key)
	{
		size_t hash = 0;
		for (auto e : key)
		{
			hash += e;
			hash *= 131;
		}

		return hash;
	}
};

// é—­æ•£åˆ—å“ˆå¸Œè¡¨
namespace open_address
{
	enum State
	{
		EMPTY,  // ç©º
		EXIST,  // å­˜åœ¨
		DELETE  // åˆ é™¤
	};

	// å“ˆå¸Œè¡¨æ¯ä¸ªä¸‹æ ‡çš„ä½ç½®å­˜å‚¨çš„æ•°æ®çš„ç»“æ„
	template&lt;class K, class V&gt;
	struct HashData
	{
		pair&lt;K, V&gt; _kv;
		State _state = EMPTY; // é»˜è®¤ä¸ºç©º
	};

	// å“ˆå¸Œè¡¨
	template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt;
	class HashTable
	{
	public:

		// é»˜è®¤å¼€è¾Ÿ 10 ä¸ªç©ºé—´
		HashTable(size_t size = 10)
		{
			_tables.resize(size);
		}

		// æŸ¥æ‰¾
		HashData&lt;K, V&gt;* Find(const K&amp; key)
		{
			// ä»¿å‡½æ•°å¯¹è±¡
			Hash hs;
			// çº¿æ€§æ¢æµ‹
			size_t hashi = hs(key) % _tables.size();
			while (_tables[hashi]._state != EMPTY)
			{
				// keyç›¸ç­‰å¹¶ä¸”stateä¸ºEXISTï¼ˆå­˜åœ¨ï¼‰æ‰èƒ½è¡¨ç¤ºæ‰¾åˆ°
				if (key == _tables[hashi]._kv.first
					&amp;&amp; _tables[hashi]._state == EXIST)
				{
					return &amp;_tables[hashi];
				}

				++hashi;
				hashi %= _tables.size();
			}

			return nullptr;
		}

		// æ’å…¥
		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			// ä¸ºç©ºå°±è¿”å›
			if (Find(kv.first))
				return false;

			// æ‰©å®¹
			if (_n * 10 / _tables.size() &gt;= 7)
			{
				// æ‰©å®¹
				HashTable&lt;K, V, Hash&gt; newHT(_tables.size() * 2);
				// éå†æ—§è¡¨ï¼Œæ’å…¥åˆ°æ–°è¡¨
				for (auto&amp; e : _tables)
				{
					if (e._state == EXIST)
					{
						newHT.Insert(e._kv);
					}
				}
				// äº¤æ¢
				_tables.swap(newHT._tables);
			}

			// ä»¿å‡½æ•°å¯¹è±¡
			Hash hs;
			// çº¿æ€§æ¢æµ‹ï¼Œæ‰¾éœ€è¦æ’å…¥çš„åœ°æ–¹
			size_t hashi = hs(kv.first) % _tables.size();
			while (_tables[hashi]._state == EXIST)
			{
				++hashi;
				hashi %= _tables.size();
			}

			_tables[hashi]._kv = kv;
			_tables[hashi]._state = EXIST;
			++_n;

			return true;
		}

		// åˆ é™¤
		bool Erase(const K&amp; key)
		{
			// æŸ¥æ‰¾
			HashData&lt;K, V&gt;* ret = Find(key);
			if (ret)
			{
				_n--; // å…ƒç´ å‡ä¸€
				ret-&gt;_state = DELETE;// çŠ¶æ€æ”¹ä¸ºåˆ é™¤
				return true;
			}
			else
			{
				return false;
			}
		}

	private:
		vector&lt;HashData&lt;K, V&gt;&gt; _tables;
		size_t _n = 0;  // å®é™…å­˜å‚¨çš„æ•°æ®ä¸ªæ•°
	};

	// æµ‹è¯•ä¸€
	void TestHT1()
	{
		int a[] = { 1,4,24,34,7,44,17,37 };
		
		// åˆ›å»ºå“ˆå¸Œè¡¨
		HashTable&lt;int, int&gt; ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e)); // æ’å…¥å…ƒç´ 
		}

		for (auto e : a)
		{
			auto ret = ht.Find(e);
			if (ret)
			{
				cout &lt;&lt; ret-&gt;_kv.first &lt;&lt; ":E" &lt;&lt; endl;
			}
			else
			{
				cout &lt;&lt; ret-&gt;_kv.first &lt;&lt; ":D" &lt;&lt; endl;
			}
		}
		cout &lt;&lt; endl;

		ht.Erase(34);
		ht.Erase(4);

		for (auto e : a)
		{
			auto ret = ht.Find(e);
			if (ret)
			{
				cout &lt;&lt; ret-&gt;_kv.first &lt;&lt; ":E" &lt;&lt; endl;
			}
			else
			{
				cout &lt;&lt; e &lt;&lt; ":D" &lt;&lt; endl;
			}
		}
		cout &lt;&lt; endl;
	}

	// æµ‹è¯•äºŒ
	struct Date
	{
		int _year;
		int _month;
		int _day;
	};
	struct HashFuncDate
	{
		// 2024/6/3
		// 2024/3/6
		size_t operator()(const Date&amp; d)
		{
			size_t hash = 0;
			hash += d._year;
			hash *= 131;

			hash += d._month;
			hash *= 131;

			hash += d._day;
			hash *= 131;

			return hash;
		}
	};
	void TestHT2()
	{
		HashTable&lt;string, string&gt; dict;
		dict.Insert(make_pair("sort", "æ’åº"));
		dict.Insert(make_pair("string", "å­—ç¬¦ä¸²"));
		HashTable&lt;Date, string, HashFuncDate&gt; DateHash;
	}

}</code></pre> 
<h3>ğŸŒ™å¼€æ•£åˆ—å“ˆå¸Œ</h3> 
<p><span style="color:#4da8ee;"><strong>ä»€ä¹ˆæ˜¯å¼€æ•£åˆ—å“ˆå¸Œï¼š</strong></span></p> 
<p>å¼€æ•£åˆ—æ³•åˆå« é“¾åœ°å€æ³• (å¼€é“¾æ³•)ï¼Œé¦–å…ˆå¯¹å…³é”®ç é›†åˆç”¨æ•£åˆ—å‡½æ•°è®¡ç®—æ•£åˆ—åœ°å€ï¼Œå³ key æ˜ å°„çš„ä¸‹æ ‡ä½ç½®ï¼Œå…·æœ‰ç›¸åŒåœ°å€çš„å…³é”®ç  (å“ˆå¸Œå†²çª) å½’äºåŒä¸€å­é›†åˆï¼Œæ¯ä¸€ä¸ªå­é›†åˆç§°ä¸ºä¸€ä¸ªæ¡¶ (å“ˆå¸Œæ¡¶)ï¼Œå„ä¸ªæ¡¶ä¸­çš„å…ƒç´ é€šè¿‡ä¸€ä¸ªå•é“¾è¡¨é“¾æ¥èµ·æ¥ï¼Œå„é“¾è¡¨çš„å¤´ç»“ç‚¹å­˜å‚¨åœ¨å“ˆå¸Œè¡¨ä¸­ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“å‘ç”Ÿå“ˆå¸Œå†²çªæ—¶ï¼ŒæŠŠ key ä½œä¸ºä¸€ä¸ªèŠ‚ç‚¹ç›´æ¥é“¾æ¥åˆ°ä¸‹æ ‡ä½ç½®çš„å“ˆå¸Œæ¡¶ä¸­ã€‚</p> 
<p><span style="color:#4da8ee;"><strong>å›¾è§£ï¼š</strong></span></p> 
<p><img alt="" height="503" src="https://images2.imgbox.com/d3/c3/Sqjxld15_o.png" width="1088"></p> 
<h4><strong>Â ğŸ’«</strong>å¼€æ•£åˆ—çš„èŠ‚ç‚¹ç»“æ„</h4> 
<p>ç”±äºå¼€æ•£åˆ—çš„ä¸åŒå†²çªä¹‹é—´ä¸ä¼šäº’ç›¸å½±å“ï¼Œæ‰€ä»¥å¼€æ•£åˆ—ä¸å†éœ€è¦ state å˜é‡æ¥è®°å½•æ¯ä¸ªä¸‹è¡¨ä½ç½®çš„çŠ¶æ€ï¼›åŒæ—¶ï¼Œå› ä¸ºå¼€æ•£åˆ—æ¯ä¸ªä¸‹æ ‡ä½ç½®é“¾æ¥çš„éƒ½æ˜¯ä¸€ä¸ªå“ˆå¸Œæ¡¶ï¼Œæ‰€ä»¥ vector ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼ŒæŒ‡å‘å•é“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥ _tables æ˜¯ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ï¼›æœ€åï¼Œä¸ºäº†æ˜¯ä¸åŒç±»å‹çš„ key éƒ½èƒ½å¤Ÿè®¡ç®—å‡ºæ˜ å°„çš„ä¸‹æ ‡ä½ç½®ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿™é‡Œä¹Ÿéœ€è¦ä¼ é€’ä»¿å‡½æ•°ã€‚</p> 
<p><span style="color:#4da8ee;"><strong>ä»£ç å¦‚ä¸‹ï¼š</strong></span></p> 
<pre><code class="language-cpp">//å¼€æ•£åˆ—
namespace hash_bucket {
	//å“ˆå¸Œè¡¨çš„èŠ‚ç‚¹ç»“æ„--å•é“¾è¡¨
	template&lt;class K, class V&gt;
	struct HashNode {
		pair&lt;K, V&gt; _kv;
		HashNode&lt;K, V&gt;* next;

		HashNode(const pair&lt;K, V&gt;&amp; kv)
			: _kv(kv)
			, next(nullptr)
		{}
	};

	//å“ˆå¸Œè¡¨çš„ä»¿å‡½æ•°
	template&lt;class K&gt;
	struct HashFunc {
		size_t operator()(const K&amp; key) {
			return key;
		}
	};

	//ç±»æ¨¡æ¿ç‰¹åŒ–
	template&lt;&gt;
	struct HashFunc&lt;string&gt; {
		size_t operator()(const string&amp; key) {
			//BKDRå­—ç¬¦ä¸²å“ˆå¸Œç®—æ³•
			size_t sum = 0;
			for (auto ch : key)
				sum = sum * 131 + ch;

			return sum;
		}
	};

	//å“ˆå¸Œè¡¨
	template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt;
	class HashTable {
		typedef HashNode&lt;K, V&gt; Node;
        	private:
		vector&lt;Node*&gt; _tables;  //æŒ‡é’ˆæ•°ç»„
		size_t _n;  //è¡¨ä¸­æœ‰æ•ˆæ•°æ®çš„ä¸ªæ•°
	};
}
</code></pre> 
<h4><strong>Â ğŸ’«</strong>å¼€æ•£åˆ—çš„æ’å…¥åˆ é™¤ä¸æŸ¥æ‰¾</h4> 
<p><span style="color:#4da8ee;"><strong>å¼€æ•£åˆ—çš„æ’å…¥</strong></span></p> 
<p>å¼€æ•£åˆ—æ’å…¥çš„å‰éƒ¨åˆ†å’Œé—­æ•£åˆ—ä¸€æ ·ï¼Œæ ¹æ® key ä¸å“ˆå¸Œè¡¨å¤§å°å¾—åˆ°æ˜ å°„çš„ä¸‹æ ‡ä½ç½®ï¼Œä¸é—­æ•£åˆ—ä¸åŒçš„æ˜¯ï¼Œç”±äºå“ˆå¸Œè¡¨ä¸­æ¯ä¸ªä¸‹æ ‡ä½ç½®éƒ½æ˜¯ä¸€ä¸ªå“ˆå¸Œæ¡¶ï¼Œå³ä¸€ä¸ªå•é“¾è¡¨ï¼Œé‚£ä¹ˆå¯¹äºå‘ç°å“ˆå¸Œå†²çªçš„å…ƒç´ æˆ‘ä»¬åªéœ€è¦å°†å…¶é“¾æ¥åˆ°å“ˆå¸Œæ¡¶ä¸­å³å¯ï¼Œè¿™é‡Œæ˜¾ç„¶æ˜¯é€‰æ‹©å°†å†²çªå…ƒç´ è¿›è¡Œå¤´æ’ï¼Œå› ä¸ºå°¾æ’è¿˜éœ€è¦æ‰¾å°¾ï¼Œä¼šå¯¼è‡´æ•ˆç‡é™ä½ï¼š</p> 
<pre><code class="language-cpp">// æ’å…¥å‡½æ•°
bool Insert(const pair&lt;K, V&gt;&amp; kv)
{
	// æŸ¥çœ‹å…ƒç´ æ˜¯å¦å­˜åœ¨
	if (Find(kv.first))
		return false;

	// ä»¿å‡½æ•°å¯¹è±¡
	Hash hs;

	// è´Ÿè½½å› å­åˆ°1å°±æ‰©å®¹
	if (_n == _tables.size())
	{
		// æ‰©å®¹
		vector&lt;Node*&gt; newTables(_tables.size() * 2, nullptr);
		for (size_t i = 0; i &lt; _tables.size(); i++)
		{
			// å–å‡ºæ—§è¡¨ä¸­èŠ‚ç‚¹ï¼Œé‡æ–°è®¡ç®—æŒ‚åˆ°æ–°è¡¨æ¡¶ä¸­
			Node* cur = _tables[i];
			while (cur)
			{
				Node* next = cur-&gt;_next;

				// å¤´æ’åˆ°æ–°è¡¨
				size_t hashi = hs(cur-&gt;_kv.first) % newTables.size();
				cur-&gt;_next = newTables[hashi];
				newTables[hashi] = cur;

				cur = next;
			}

			_tables[i] = nullptr;
		}

		_tables.swap(newTables);
	}
			
	// è°ƒç”¨ä»¿å‡½æ•°çš„åŒ¿åå¯¹è±¡æ¥å°†keyè½¬æ¢ä¸ºæ•´æ•°
	size_t hashi = hs(kv.first) % _tables.size();
			
	// å¤´æ’
	Node* newnode = new Node(kv);
	newnode-&gt;_next = _tables[hashi];
	_tables[hashi] = newnode;

	++_n;
	return true;
}</code></pre> 
<p><span style="color:#4da8ee;"><strong>å¼€æ•£åˆ—çš„æŸ¥æ‰¾</strong></span></p> 
<p>å¼€æ•£åˆ—çš„æŸ¥æ‰¾ä¹Ÿå¾ˆç®€å•ï¼Œæ ¹æ®ä½™æ•°æ‰¾åˆ°ä¸‹æ ‡ï¼Œç”±äºä¸‹æ ‡ä½ç½®å­˜å‚¨çš„æ˜¯é“¾è¡¨é¦–å…ƒç´ åœ°å€ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å–å‡ºé¦–å…ƒç´ åœ°å€ï¼Œç„¶åé¡ºåºéå†å•é“¾è¡¨å³å¯ï¼š</p> 
<pre><code class="language-cpp">// æŸ¥æ‰¾
Node* Find(const K&amp; key)
{
	// ä»¿å‡½æ•°å¯¹è±¡
	Hash hs;
	size_t hashi = hs(key) % _tables.size();
	Node* cur = _tables[hashi];
	while (cur)
	{
		if (cur-&gt;_kv.first == key)
		{
			return cur;
		}

		cur = cur-&gt;_next;
	}

	return nullptr;
}</code></pre> 
<p><span style="color:#4da8ee;"><strong>å¼€æ•£åˆ—çš„åˆ é™¤</strong></span></p> 
<p>å’Œé—­æ•£åˆ—ä¸åŒçš„æ˜¯ï¼Œå¼€æ•£åˆ—çš„åˆ é™¤ä¸èƒ½ç›´æ¥é€šè¿‡æŸ¥æ‰¾å‡½æ•°çš„è¿”å›å€¼æ¥è¿›è¡Œåˆ é™¤ï¼Œå› ä¸ºå•é“¾è¡¨åœ¨åˆ é™¤èŠ‚ç‚¹æ—¶è¿˜éœ€è¦æ”¹å˜çˆ¶èŠ‚ç‚¹çš„æŒ‡å‘ï¼Œè®©å…¶æŒ‡å‘ç›®æ ‡èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦é€šè¿‡éå†å•é“¾è¡¨æ¥è¿›è¡Œåˆ é™¤ï¼š</p> 
<pre><code class="language-cpp">// åˆ é™¤
bool Erase(const K&amp; key)
{
	// ä»¿å‡½æ•°å¯¹è±¡
	Hash hs;
	size_t hashi = hs(key) % _tables.size();
	Node* prev = nullptr;
	Node* cur = _tables[hashi];
	while (cur)
	{
		// åˆ é™¤è¿˜è¦åˆ†æ˜¯å¦ä¸ºå¤´èŠ‚ç‚¹
		if (cur-&gt;_kv.first == key)
		{
			// åˆ é™¤
			if (prev)
			{
				prev-&gt;_next = cur-&gt;_next;
			}
			else
			{
				_tables[hashi] = cur-&gt;_next;
			}

			delete cur;

			--_n;
			return true;
		}

		// ä¸‹ä¸€ä¸ªç»“ç‚¹
		prev = cur;
		cur = cur-&gt;_next;
	}

	return false;
}</code></pre> 
<h4><strong>ğŸ’«</strong>å¼€æ•£åˆ—æ•´ä½“ä»£ç å®ç°</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
using namespace std;

// å“ˆå¸Œè¡¨çš„ä»¿å‡½æ•° ï¼Œé€šè¿‡ä¸Šå±‚å®¹å™¨æä¾›çš„ä»¿å‡½æ•°è·å–åˆ°å…ƒç´ çš„é”®å€¼
template&lt;class K&gt;
struct HashFunc
{
	size_t operator()(const K&amp; key)
	{
		return (size_t)key;
	}
};

// ç±»æ¨¡æ¿ç‰¹åŒ–
template&lt;&gt;
struct HashFunc&lt;string&gt;
{
	size_t operator()(const string&amp; key)
	{
		size_t hash = 0;
		for (auto e : key)
		{
			hash += e;
			hash *= 131;
		}

		return hash;
	}
};

// å¼€æ•£åˆ—å“ˆå¸Œè¡¨
namespace hash_bucket
{
	// å“ˆå¸Œè¡¨çš„èŠ‚ç‚¹ç»“æ„ -- å•é“¾è¡¨
	template&lt;class K, class V&gt;
	struct HashNode
	{
		HashNode&lt;K, V&gt;* _next;
		pair&lt;K, V&gt; _kv;

		// åˆå§‹åŒ–åˆ—è¡¨
		HashNode(const pair&lt;K, V&gt;&amp; kv)
			:_next(nullptr)
			, _kv(kv)
		{}
	};

	// å“ˆå¸Œè¡¨
	template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt;
	class HashTable
	{
		typedef HashNode&lt;K, V&gt; Node;
	public:

		// æ„é€ å‡½æ•°
		HashTable()
		{
			_tables.resize(10, nullptr); // å¼€ç©ºé—´
			_n = 0;
		}

		// ææ„å‡½æ•°
		~HashTable()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				while (cur)
				{
					Node* next = cur-&gt;_next;
					delete cur;

					cur = next;
				}
				_tables[i] = nullptr;
			}
		}

		// æ’å…¥å‡½æ•°
		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			// æŸ¥çœ‹å…ƒç´ æ˜¯å¦å­˜åœ¨
			if (Find(kv.first))
				return false;

			// ä»¿å‡½æ•°å¯¹è±¡
			Hash hs;

			// è´Ÿè½½å› å­åˆ°1å°±æ‰©å®¹
			if (_n == _tables.size())
			{
				// æ‰©å®¹
				vector&lt;Node*&gt; newTables(_tables.size() * 2, nullptr);
				for (size_t i = 0; i &lt; _tables.size(); i++)
				{
					// å–å‡ºæ—§è¡¨ä¸­èŠ‚ç‚¹ï¼Œé‡æ–°è®¡ç®—æŒ‚åˆ°æ–°è¡¨æ¡¶ä¸­
					Node* cur = _tables[i];
					while (cur)
					{
						Node* next = cur-&gt;_next;

						// å¤´æ’åˆ°æ–°è¡¨
						size_t hashi = hs(cur-&gt;_kv.first) % newTables.size();
						cur-&gt;_next = newTables[hashi];
						newTables[hashi] = cur;

						cur = next;
					}

					_tables[i] = nullptr;
				}

				_tables.swap(newTables);
			}

			// è°ƒç”¨ä»¿å‡½æ•°çš„åŒ¿åå¯¹è±¡æ¥å°†keyè½¬æ¢ä¸ºæ•´æ•°
			size_t hashi = hs(kv.first) % _tables.size();

			// å¤´æ’
			Node* newnode = new Node(kv);
			newnode-&gt;_next = _tables[hashi];
			_tables[hashi] = newnode;

			++_n;
			return true;
		}

		// æŸ¥æ‰¾
		Node* Find(const K&amp; key)
		{
			// ä»¿å‡½æ•°å¯¹è±¡
			Hash hs;
			size_t hashi = hs(key) % _tables.size();
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (cur-&gt;_kv.first == key)
				{
					return cur;
				}

				cur = cur-&gt;_next;
			}

			return nullptr;
		}

		// åˆ é™¤
		bool Erase(const K&amp; key)
		{
			// ä»¿å‡½æ•°å¯¹è±¡
			Hash hs;
			size_t hashi = hs(key) % _tables.size();
			Node* prev = nullptr;
			Node* cur = _tables[hashi];
			while (cur)
			{
				// åˆ é™¤è¿˜è¦åˆ†æ˜¯å¦ä¸ºå¤´èŠ‚ç‚¹
				if (cur-&gt;_kv.first == key)
				{
					// åˆ é™¤
					if (prev)
					{
						prev-&gt;_next = cur-&gt;_next;
					}
					else
					{
						_tables[hashi] = cur-&gt;_next;
					}

					delete cur;

					--_n;
					return true;
				}

				// ä¸‹ä¸€ä¸ªç»“ç‚¹
				prev = cur;
				cur = cur-&gt;_next;
			}

			return false;
		}

		// æµ‹è¯•
		void Some()
		{
			size_t bucketSize = 0;
			size_t maxBucketLen = 0;
			size_t sum = 0;
			double averageBucketLen = 0;

			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				if (cur)
				{
					++bucketSize;
				}

				size_t bucketLen = 0;
				while (cur)
				{
					++bucketLen;
					cur = cur-&gt;_next;
				}

				sum += bucketLen;

				if (bucketLen &gt; maxBucketLen)
				{
					maxBucketLen = bucketLen;
				}
			}

			averageBucketLen = (double)sum / (double)bucketSize;

			printf("load factor:%lf\n", (double)_n / _tables.size());
			printf("all bucketSize:%d\n", _tables.size());
			printf("bucketSize:%d\n", bucketSize);
			printf("maxBucketLen:%d\n", maxBucketLen);
			printf("averageBucketLen:%lf\n\n", averageBucketLen);
		}

	private:
		vector&lt;Node*&gt; _tables; // æŒ‡é’ˆæ•°ç»„
		size_t _n; // å…ƒç´ ä¸ªæ•°
	};

	// æµ‹è¯•ä¸€
	void TestHT1()
	{
		HashTable&lt;int, int&gt; ht;
		int a[] = { 1,4,24,34,7,44,17,37 };
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		ht.Insert(make_pair(5, 5));
		ht.Insert(make_pair(15, 15));
		ht.Insert(make_pair(25, 25));

		ht.Erase(5);
		ht.Erase(15);
		ht.Erase(25);
		ht.Erase(35);

		for (auto e : a)
		{
			auto ret = ht.Find(e);
			if (ret)
			{
				cout &lt;&lt; ret-&gt;_kv.first &lt;&lt; ":E" &lt;&lt; endl;
			}
			else
			{
				cout &lt;&lt; ret-&gt;_kv.first &lt;&lt; ":D" &lt;&lt; endl;
			}
		}
		cout &lt;&lt; endl;

		HashTable&lt;string, string&gt; dict;
		dict.Insert(make_pair("sort", "æ’åº"));
		dict.Insert(make_pair("string", "å­—ç¬¦ä¸²"));
	}

	// æµ‹è¯•äºŒ
	void TestHT2()
	{
		const size_t N = 30000;

		unordered_set&lt;int&gt; us;
		set&lt;int&gt; s;
		HashTable&lt;int, int&gt; ht;

		vector&lt;int&gt; v;
		v.reserve(N);
		srand(time(0));
		for (size_t i = 0; i &lt; N; ++i)
		{
			//v.push_back(rand()); // Næ¯”è¾ƒå¤§æ—¶ï¼Œé‡å¤å€¼æ¯”è¾ƒå¤š
			v.push_back(rand() + i); // é‡å¤å€¼ç›¸å¯¹å°‘
			//v.push_back(i); // æ²¡æœ‰é‡å¤ï¼Œæœ‰åº
		}

		size_t begin1 = clock();
		for (auto e : v)
		{
			s.insert(e);
		}
		size_t end1 = clock();
		cout &lt;&lt; "set insert:" &lt;&lt; end1 - begin1 &lt;&lt; endl;

		size_t begin2 = clock();
		for (auto e : v)
		{
			us.insert(e);
		}
		size_t end2 = clock();
		cout &lt;&lt; "unordered_set insert:" &lt;&lt; end2 - begin2 &lt;&lt; endl;

		size_t begin10 = clock();
		for (auto e : v)
		{
			ht.Insert(make_pair(e, e));
		}
		size_t end10 = clock();
		cout &lt;&lt; "HashTbale insert:" &lt;&lt; end10 - begin10 &lt;&lt; endl &lt;&lt; endl;

		size_t begin3 = clock();
		for (auto e : v)
		{
			s.find(e);
		}
		size_t end3 = clock();
		cout &lt;&lt; "set find:" &lt;&lt; end3 - begin3 &lt;&lt; endl;

		size_t begin4 = clock();
		for (auto e : v)
		{
			us.find(e);
		}
		size_t end4 = clock();
		cout &lt;&lt; "unordered_set find:" &lt;&lt; end4 - begin4 &lt;&lt; endl;

		size_t begin11 = clock();
		for (auto e : v)
		{
			ht.Find(e);
		}
		size_t end11 = clock();
		cout &lt;&lt; "HashTable find:" &lt;&lt; end11 - begin11 &lt;&lt; endl &lt;&lt; endl;

		cout &lt;&lt; "æ’å…¥æ•°æ®ä¸ªæ•°ï¼š" &lt;&lt; us.size() &lt;&lt; endl &lt;&lt; endl;
		ht.Some();

		size_t begin5 = clock();
		for (auto e : v)
		{
			s.erase(e);
		}
		size_t end5 = clock();
		cout &lt;&lt; "set erase:" &lt;&lt; end5 - begin5 &lt;&lt; endl;

		size_t begin6 = clock();
		for (auto e : v)
		{
			us.erase(e);
		}
		size_t end6 = clock();
		cout &lt;&lt; "unordered_set erase:" &lt;&lt; end6 - begin6 &lt;&lt; endl;

		size_t begin12 = clock();
		for (auto e : v)
		{
			ht.Erase(e);
		}
		size_t end12 = clock();
		cout &lt;&lt; "HashTable Erase:" &lt;&lt; end12 - begin12 &lt;&lt; endl &lt;&lt; endl;
	}
}
</code></pre> 
<h2 style="background-color:transparent;">ğŸŒŸç»“æŸè¯­</h2> 
<p>Â  Â  Â  Â ä»Šå¤©å†…å®¹å°±åˆ°è¿™é‡Œå•¦ï¼Œæ—¶é—´è¿‡å¾—å¾ˆå¿«ï¼Œå¤§å®¶æ²‰ä¸‹å¿ƒæ¥å¥½å¥½å­¦ä¹ ï¼Œä¼šæœ‰ä¸€å®šçš„æ”¶è·çš„ï¼Œå¤§å®¶å¤šå¤šåšæŒï¼Œå˜»å˜»ï¼ŒæˆåŠŸè·¯ä¸Šæ³¨å®šå­¤ç‹¬ï¼Œå› ä¸ºåšæŒçš„äººä¸å¤šã€‚é‚£è¯·å¤§å®¶ä¸¾èµ·è‡ªå·±çš„å°æ‰‹ç»™åšä¸»ä¸€é”®ä¸‰è¿ï¼Œæœ‰ä½ ä»¬çš„æ”¯æŒæ˜¯æˆ‘æœ€å¤§çš„åŠ¨åŠ›ğŸ’ğŸ’ğŸ’ï¼Œå›è§ã€‚</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/2d/c1/evBvfcK8_o.jpg" width="200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7edbb08136dff19f61357326c8d4c653/" rel="prev">
			<span class="pager__subtitle">Â«&thinsp;Previous</span>
			<p class="pager__title">qinakunå®ç°å…¨å±€çŠ¶æ€ç®¡ç†</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f3d6fc2d0e1f320b5afa90339f8122f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;Â»</span>
			<p class="pager__title">tewa-707eå…‰çŒ«è¶…çº§å¯†ç è·å–æ–¹æ³•</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 è€å¸…çš„åšå®¢.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>