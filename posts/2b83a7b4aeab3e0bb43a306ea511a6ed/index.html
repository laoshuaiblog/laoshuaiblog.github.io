<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之MySQL独爱B&#43;树(二叉树、AVL树、红黑树、B树对比) - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/2b83a7b4aeab3e0bb43a306ea511a6ed/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="数据结构之MySQL独爱B&#43;树(二叉树、AVL树、红黑树、B树对比)">
  <meta property="og:description" content="一、二叉查找树 （1）二叉树简介：
二叉查找树也称为有序二叉查找树，满足二叉查找树的一般性质，是指一棵空树具有如下性质：
1、任意节点左子树不为空,则左子树的值均小于根节点的值；
2、任意节点右子树不为空,则右子树的值均大于于根节点的值；
3、任意节点的左右子树也分别是二叉查找树；
4、没有键值相等的节点； 上图为一个普通的二叉查找树，按照中序遍历的方式可以从小到大的顺序排序输出：15、20、30、50、60、70。
对上述二叉树进行查找，如查键值为30的记录，先找到根，其键值是50，50大于30，因此查找50的左子树，找到20；而30大于20，再找其右子树；一共找了3次。如果按15、20、30、50、60、70的顺序来找同样需求3次。用同样的方法在查找键值为70的这个记录，这次用了3次查找，而顺序查找需要6次。计算平均查找次数得：顺序查找的平均查找次数为（1&#43;2&#43;3&#43;4&#43;5&#43;6）/ 6 = 3.3次，二叉查找树的平均查找次数为（3&#43;3&#43;3&#43;2&#43;2&#43;1）/6=2.3次。二叉查找树的平均查找速度比顺序查找来得更快。
（2）局限性及应用
一个二叉查找树是由n个节点随机构成，所以，对于某些情况，二叉查找树会退化成一个有n个节点的线性链。
大家看上图，如果我们的根节点选择是最小或者最大的数，那么二叉查找树就完全退化成了线性结构。上图中的平均查找次数为（1&#43;2&#43;3&#43;4&#43;5&#43;5）/6=3.16次，和顺序查找差不多。显然这个二叉树的查询效率就很低，因此若想最大性能的构造一个二叉查找树，需要这个二叉树是平衡的（这里的平衡从一个显著的特点可以看出这一棵树的高度比上一个输的高度要大，在相同节点的情况下也就是不平衡），从而引出了一个新的定义-平衡二叉树AVL。
二、AVL树 （1）简介
AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。 从上面是一个普通的平衡二叉树，这张图我们可以看出，任意节点的左右子树的平衡因子差值都不会大于1。
（2）局限性
由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。
（3）应用
1、Windows NT内核中广泛存在；
三、红黑树 （1）简介
一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是若平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数变少，所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。
（2）性质
1、每个节点非红即黑； 2、根节点是黑的； 3、每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的； 4、如果一个节点是红的,那么它的两儿子都是黑的； 5、对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点； 6、每条路径都包含相同的黑节点；
（3）应用
1、广泛用于C&#43;&#43;的STL中，Map和Set都是用红黑树实现的； 2、著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间； 3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查； 4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器； 5、Java中TreeMap的实现；
四、B/B&#43;树 （1）简介
B/B&#43;树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗B/B&#43;树的高度远远小于红黑树的高度(在下面B/B&#43;树的性能分析中会提到)。B/B&#43;树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。
注意B-树就是B树，-只是一个符号。
（2）B树的性质
1、定义任意非叶子结点最多只有M个儿子，且M&amp;gt;2； 2、根结点的儿子数为[2, M]； 3、除根结点以外的非叶子结点的儿子数为[M/2, M]； 4、每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 5、非叶子结点的关键字个数=指向儿子的指针个数-1； 6、非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &amp;lt; K[i&#43;1]； 7、非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 8、所有叶子结点位于同一层； 这里只是一个简单的B树，在实际中B树节点中关键字很多的。
五、B&#43;树 （1）简介">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2018-09-20T14:53:17+08:00">
    <meta property="article:modified_time" content="2018-09-20T14:53:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之MySQL独爱B&#43;树(二叉树、AVL树、红黑树、B树对比)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>一、二叉查找树</strong></h3> 
<p>（1）二叉树简介：</p> 
<p>二叉查找树也称为有序二叉查找树，满足二叉查找树的一般性质，是指一棵空树具有如下性质：</p> 
<p>1、任意节点左子树不为空,则左子树的值均小于根节点的值；</p> 
<p>2、任意节点右子树不为空,则右子树的值均大于于根节点的值；</p> 
<p>3、任意节点的左右子树也分别是二叉查找树；</p> 
<p>4、没有键值相等的节点； </p> 
<p><img alt="" class="has" height="146" src="https://images2.imgbox.com/b5/64/0wlq8wH1_o.png" width="148"><br>  <br> 上图为一个普通的二叉查找树，按照<strong>中序遍历</strong>的方式可以从小到大的顺序排序输出：15、20、30、50、60、70。</p> 
<p>对上述二叉树进行查找，如查键值为30的记录，先找到根，其键值是50，50大于30，因此查找50的左子树，找到20；而30大于20，再找其右子树；一共找了3次。如果按15、20、30、50、60、70的顺序来找同样需求3次。用同样的方法在查找键值为70的这个记录，这次用了3次查找，而顺序查找需要6次。计算平均查找次数得：顺序查找的平均查找次数为（1+2+3+4+5+6）/ 6 = 3.3次，二叉查找树的平均查找次数为（3+3+3+2+2+1）/6=2.3次。二叉查找树的平均查找速度比顺序查找来得更快。</p> 
<p>（2）局限性及应用</p> 
<p>一个二叉查找树是由n个节点随机构成，所以，对于某些情况，二叉查找树会退化成一个有n个节点的线性链。</p> 
<p><img alt="" class="has" height="440" src="https://images2.imgbox.com/aa/5b/Us1U7tnG_o.png" width="481"><br><br> 大家看上图，如果我们的根节点选择是最小或者最大的数，那么二叉查找树就完全退化成了线性结构。上图中的平均查找次数为（1+2+3+4+5+5）/6=3.16次，和顺序查找差不多。显然这个二叉树的查询效率就很低，因此若想最大性能的构造一个二叉查找树，需要这个二叉树是平衡的（这里的平衡从一个显著的特点可以看出这一棵树的高度比上一个输的高度要大，在相同节点的情况下也就是不平衡），从而引出了一个新的定义-平衡二叉树AVL。</p> 
<h3><strong>二、AVL树</strong></h3> 
<p>（1）简介</p> 
<p>AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。 </p> 
<p><img alt="" class="has" height="434" src="https://images2.imgbox.com/4f/79/7MUAhM6T_o.png" width="500"><br>  <br> 从上面是一个普通的平衡二叉树，这张图我们可以看出，任意节点的左右子树的平衡因子差值都不会大于1。</p> 
<p>（2）局限性</p> 
<p>由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。</p> 
<p>（3）应用</p> 
<p>1、Windows NT内核中广泛存在；</p> 
<h3><strong>三、红黑树</strong></h3> 
<p>（1）简介</p> 
<p>一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是若平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，<strong>相对于要求严格的AVL树来说，它的旋转次数变少，所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。</strong></p> 
<p>（2）性质</p> 
<p>1、每个节点非红即黑； <br> 2、根节点是黑的； <br> 3、每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的； <br> 4、如果一个节点是红的,那么它的两儿子都是黑的； <br> 5、对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点； <br> 6、每条路径都包含相同的黑节点；</p> 
<p><img alt="" class="has" height="614" src="https://images2.imgbox.com/22/38/0UM0L3wP_o.png" width="851"></p> 
<p>（3）应用</p> 
<p>1、广泛用于C++的STL中，Map和Set都是用红黑树实现的； <br> 2、著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间； <br> 3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查； <br> 4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器； <br> 5、Java中TreeMap的实现；</p> 
<h3><strong>四、B/B+树</strong></h3> 
<p>（1）简介</p> 
<p>B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度(在下面B/B+树的性能分析中会提到)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。</p> 
<p>注意B-树就是B树，-只是一个符号。</p> 
<p>（2）B树的性质</p> 
<p>1、定义任意非叶子结点最多只有M个儿子，且M&gt;2； <br> 2、根结点的儿子数为[2, M]； <br> 3、除根结点以外的非叶子结点的儿子数为[M/2, M]； <br> 4、每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） <br> 5、非叶子结点的关键字个数=指向儿子的指针个数-1； <br> 6、非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]； <br> 7、非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； <br> 8、所有叶子结点位于同一层； <br><img alt="" class="has" height="321" src="https://images2.imgbox.com/2a/37/xOHp5gpY_o.png" width="573"><br> 这里只是一个简单的B树，在实际中B树节点中关键字很多的。</p> 
<h3><strong>五、B+树</strong></h3> 
<p>（1）简介</p> 
<p>B+树是应文件系统所需而产生的一种B树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中。所有的非叶子节点都可以看成索引部分！</p> 
<p>（2）B+树的性质(下面提到的都是和B树不相同的性质)</p> 
<p>1、非叶子节点的子树指针与关键字个数相同； <br> 2、非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)； <br> 3、为所有叶子节点增加一个链指针； <br> 4、所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)； <br> 5、非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层； <br> 6、更适合于文件系统；</p> 
<p><img alt="" class="has" height="345" src="https://images2.imgbox.com/9d/85/QccOgkpx_o.png" width="569"></p> 
<p>非叶子节点（比如5，28，65）只是一个key（索引），实际的数据存在叶子节点上（5，8，9）才是真正的数据或指向真实数据的指针。</p> 
<p>（3）应用　　</p> 
<p>1、B和B+树主要用在文件系统以及数据库做索引，比如MySQL；</p> 
<h3><strong>六、B/B+树性能分析</strong></h3> 
<p>n个节点的平衡二叉树的高度为H(即logn)，而n个节点的B/B+树的高度为logt((n+1)/2)+1； <br> 若要作为内存中的查找表，B树却不一定比平衡二叉树好，尤其当m较大时更是如此。因为查找操作CPU的时间在B-树上是O(mlogtn)=O(lgn(m/lgt))，而m/lgt&gt;1；所以m较大时O(mlogtn)比平衡二叉树的操作时间大得多。因此在内存中使用B树必须取较小的m。（通常取最小值m=3，此时B-树中每个内部结点可以有2或3个孩子，这种3阶的B-树称为2-3树）。</p> 
<h3><strong>七、为什么说B+树比B树更适合数据库索引？</strong></h3> 
<p>1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p> 
<p>2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p> 
<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p> 
<p>4、B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/286ada483e8da6349eb3bcbf84d13008/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NoSQL和SQL简介和对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3a0f820188ae0d936e311748ad6d21e5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">通过注解进行Date类型和String类型转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>