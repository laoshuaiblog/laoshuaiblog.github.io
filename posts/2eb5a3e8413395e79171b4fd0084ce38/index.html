<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于FCNN的特征提取网络 - 老帅的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://laoshuaiblog.github.io/posts/2eb5a3e8413395e79171b4fd0084ce38/">
  <meta property="og:site_name" content="老帅的博客">
  <meta property="og:title" content="基于FCNN的特征提取网络">
  <meta property="og:description" content="一、背景
对于深度学习相关的轴承故障分析，以前的研究要么使用原始的一维时间序列直接作为网络模型的输入，要么使用通过一维信号转换获得的二维波形信号作为网络模型的输入。基于原始数据的深度学习需要消耗大量的计算资源，此外大量的无用数据会大大降低模型的训练精度，因此本文希望将数据驱动的故障诊断转化为特征驱动的故障诊断，基于关键信息进行诊断大大加快了计算效率。
现有的卷积以一维和二维为主，一维时间序列信号进行分析口与较好的提取波形的时间序列特征，但是无法识别其内部的空间领域；二维波形信号的分析可以保留信号的空间领域特征，但是容易丢失时域特征。
二、模型
2.1融合卷积神经网络（FCNN）
融合卷积神经网络（FCNN）相比于单一的一维卷积和二维卷积的优势在于保证时序特征提取的同时可以基于图像处理手段找到“故障图”中的关键信息，并将二者进行融合挖掘深层次的故障特征信息驱动后续的故障识别算法。
基于FCNN的自编码器，编码部分包括以为信息编码和二维信息编码，在特征识别的最后将一维特征和二维特征数据进行拼接，并且通过全连接的方式进行特征融合。个网络层之间使用RELU函数进行激活，可增加模型的曲线拟合能力，但是该模型没有使用池化层，因为池化层会降低诊断的准确性。
FCNN特征提取结构表：
为实现自编码的训练过程，选择使用SmoothL1Loss损失函数。SmoothL1Loss同时具有L1Loss的优点和L2Loss的优点，当预测值和groundtruth差别较小的时候，其实是使用L2Loss，损失函数相较于L1Loss比较圆滑；而当差别大的时候没事L1Loss比较稳定，不容易梯度爆炸。其公式如下：
为实现梯度下降，系统使用Adam优化传统的随机梯度下降，可以解决系数梯度和噪声问题。
此编码层可将4096个数据点降维到一个二维平面上并以此作为故障信号特征点。
2.2故障诊断模型的改进过程
SVM算法具有良好的分类特性，其关键在于核函数的选择，每种核函数都i有对应的使用场景，基于特征参数在平面上的分布特点口与选择使用高斯核函数进行分类。高斯和函数是一种局部性较强的核函数，可以将一个样本映射到一个更高维的空间内，其公式为：
但是存在超参数选择困难问题，主要的超参数包括C和gamma，其中C是惩罚系数，C越高导致模型过拟合，不合适的C使得模型的泛化能力较差。二gamma时高斯核函数的超参数，gamma的选择决定了数据库映射后在高维空间的分部，gamma越大，支持向量越少，gamma越小支持向量越大，而支持向量的数据和训练预测的精度和速度有关。
文中使用了麻雀搜索算法对SVM的模型进行优化。麻雀搜索算法对种群进行初始化时采用的是随机生成的方式，而这种麻雀种群生成策略会导致分布不均匀然后影响后期的迭代。对此模型基于混沌序列进行初始种群的分布优化。因Tent混沌映射具有更好的均匀性，在初始化种群时选择Tent映射，其表达式如下，在迭代过程中的值会更新。
在种群初始化的过程中引入Tent映射后所产生的混沌麻雀序列如下所示：
为增大麻雀搜索算法迭代过程中的寻优范围，本文将引入飞行策略Levy。Levy飞行策略是一种游走算法，每一步的步长从一个heavy tail分布函数中采样，生成服从莱维分布的随机步长的方法如下所示：
论文参考：基于深度学习的滚动轴承故障诊断方法">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-10-07T16:25:03+08:00">
    <meta property="article:modified_time" content="2022-10-07T16:25:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="老帅的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">老帅的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于FCNN的特征提取网络</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、背景</p> 
<p>对于深度学习相关的轴承故障分析，以前的研究要么使用原始的一维时间序列直接作为网络模型的输入，要么使用通过一维信号转换获得的二维波形信号作为网络模型的输入。基于原始数据的深度学习需要消耗大量的计算资源，此外大量的无用数据会大大降低模型的训练精度，因此本文希望将数据驱动的故障诊断转化为特征驱动的故障诊断，基于关键信息进行诊断大大加快了计算效率。</p> 
<p>现有的卷积以一维和二维为主，一维时间序列信号进行分析口与较好的提取波形的时间序列特征，但是无法识别其内部的空间领域；二维波形信号的分析可以保留信号的空间领域特征，但是容易丢失时域特征。</p> 
<p>二、模型</p> 
<p>2.1融合卷积神经网络（FCNN）</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/a4/01/KKoXGvQL_o.png" width="849"></p> 
<p> 融合卷积神经网络（FCNN）相比于单一的一维卷积和二维卷积的优势在于保证时序特征提取的同时可以基于图像处理手段找到“故障图”中的关键信息，并将二者进行融合挖掘深层次的故障特征信息驱动后续的故障识别算法。</p> 
<p>基于FCNN的自编码器，编码部分包括以为信息编码和二维信息编码，在特征识别的最后将一维特征和二维特征数据进行拼接，并且通过全连接的方式进行特征融合。个网络层之间使用RELU函数进行激活，可增加模型的曲线拟合能力，但是该模型没有使用池化层，因为池化层会降低诊断的准确性。</p> 
<p>FCNN特征提取结构表：</p> 
<p><img alt="" height="743" src="https://images2.imgbox.com/64/39/pAv4ckTC_o.png" width="531"></p> 
<p>为实现自编码的训练过程，选择使用SmoothL1Loss损失函数。SmoothL1Loss同时具有L1Loss的优点和L2Loss的优点，当预测值和groundtruth差别较小的时候，其实是使用L2Loss，损失函数相较于L1Loss比较圆滑；而当差别大的时候没事L1Loss比较稳定，不容易梯度爆炸。其公式如下：</p> 
<p><img alt="" height="82" src="https://images2.imgbox.com/f8/28/58sxjsOR_o.png" width="610"></p> 
<p>为实现梯度下降，系统使用Adam优化传统的随机梯度下降，可以解决系数梯度和噪声问题。</p> 
<p>此编码层可将4096个数据点降维到一个二维平面上并以此作为故障信号特征点。</p> 
<p>2.2故障诊断模型的改进过程</p> 
<p><img alt="" height="422" src="https://images2.imgbox.com/e9/b2/wTn6CWIa_o.png" width="1200"></p> 
<p> SVM算法具有良好的分类特性，其关键在于核函数的选择，每种核函数都i有对应的使用场景，基于特征参数在平面上的分布特点口与选择使用高斯核函数进行分类。高斯和函数是一种局部性较强的核函数，可以将一个样本映射到一个更高维的空间内，其公式为：</p> 
<p><img alt="" height="98" src="https://images2.imgbox.com/64/73/KLwdWZl9_o.png" width="594"></p> 
<p>但是存在超参数选择困难问题，主要的超参数包括C和gamma，其中C是惩罚系数，C越高导致模型过拟合，不合适的C使得模型的泛化能力较差。二gamma时高斯核函数的超参数，gamma的选择决定了数据库映射后在高维空间的分部，gamma越大，支持向量越少，gamma越小支持向量越大，而支持向量的数据和训练预测的精度和速度有关。</p> 
<p>文中使用了麻雀搜索算法对SVM的模型进行优化。麻雀搜索算法对种群进行初始化时采用的是随机生成的方式，而这种麻雀种群生成策略会导致分布不均匀然后影响后期的迭代。对此模型基于混沌序列进行初始种群的分布优化。因Tent混沌映射具有更好的均匀性，在初始化种群时选择Tent映射，其表达式如下，在迭代过程中<img alt="f_{m}^{i}" class="mathcode" src="https://images2.imgbox.com/e1/9f/QnOmx3Lu_o.png">的值会更新。</p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/5d/fc/jrUwvPmK_o.png" width="762"></p> 
<p>在种群初始化的过程中引入Tent映射后所产生的混沌麻雀序列如下所示：</p> 
<p><img alt="" height="97" src="https://images2.imgbox.com/ce/e5/nOU0nDiM_o.png" width="650"></p> 
<p>为增大麻雀搜索算法迭代过程中的寻优范围，本文将引入飞行策略Levy。Levy飞行策略是一种游走算法，每一步的步长从一个heavy tail分布函数中采样，生成服从莱维分布的随机步长的方法如下所示：</p> 
<p><img alt="" height="657" src="https://images2.imgbox.com/90/58/ZCmhI69S_o.png" width="666"></p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/69/12/VYMAWogc_o.png" width="760"></p> 
<p> </p> 
<p> 论文参考：基于深度学习的滚动轴承故障诊断方法</p> 
<p></p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/067b2404f0ad58556add6fb7c85dc825/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构初阶——栈和队列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdcf2980541cb5d9bfca2a17c3be9661/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">判断一个数是否为素数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 老帅的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>